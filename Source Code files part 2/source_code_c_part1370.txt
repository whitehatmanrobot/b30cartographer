 memory");
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	
	ULONG ulItem;
    for (ulItem = 0; ulItem < m_dwSetupItemCount && nPUIDIndex < m_nNumOfValidDependentPUID; ulItem++)
    {
    	if (WU_TYPE_ACTIVE_SETUP_RECORD	!=  GetRecordType(m_pSetupItems[ulItem]) ||
    		!m_pSetupItems[ulItem]->ps->bHidden || m_pSetupItems[ulItem]->ps->state == WU_ITEM_STATE_PRUNED) 
    		continue;
    	PINVENTORY_ITEM pItem = m_pSetupItems[ulItem];
    	// get a hidden setup dependency item record
    	BOOL fRet = ReadDescription(pItem, pMapFile);
        if (!fRet)
        	// failed to read description file for this item, assume this dependency does not apply
        	// this way, we will not download any item not apply, but may miss some items that apply
            continue;
        
       
        // Title is composed as BuildMin.BuildMax.SPMajor.SPMinor
        PWU_VARIABLE_FIELD pvField = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE); 
        if (!pvField)
       	{
       		// title is NULL, error, ignore this item
       		LOG_error("Title is NULL");
       		continue;
       	}
        wchar_t * pvTitle = (wchar_t*) pvField->pData;
        
        DWORD dwBuild[4];
        dwBuild[0]=0;
        dwBuild[1]=99999;
        dwBuild[2]=0;
        dwBuild[3]=0;
        
        int nBuildIndex = 0;
        int nTemp = 0;
        BOOL fBreak = FALSE;
        
        while (nBuildIndex<4 && !fBreak)
        {
        	
        	if (*pvTitle != L'.' && *pvTitle != NULL ) 
        	{
   		       	if (*pvTitle > L'9' || *pvTitle < '0')
        		{
        			// illegal use of this title
    	    		LOG_error("Illegal character '%c' found in the title",(char)*pvTitle);
        			SetLastError(ERROR_INVALID_DATA);
        			return FALSE;
        		}
        		else 
        		{
        			nTemp *=10;
        			nTemp += (*pvTitle - L'0');
        		}
        	}
        	else
        	{
        		if (!*pvTitle) fBreak = TRUE;
        		dwBuild[nBuildIndex++] = nTemp;
        		nTemp = 0;
        	}
        	pvTitle++;
        }

        LOG_out("Title is %d.%d.%d.%d\n", dwBuild[0], dwBuild[1], dwBuild[2], dwBuild[3]);
        
        // determine if this item apply
        if (dwBuild[0] <= VersionInfo.dwBuildNumber &&
        	dwBuild[1] >= VersionInfo.dwBuildNumber &&
        	dwBuild[2] == VersionInfo.wServicePackMajor&&
        	dwBuild[3] == VersionInfo.wServicePackMinor)
        {
        	// applys, add this to the list
        	LOG_out("This dependency item applied");
        	m_pValidDependentPUIDArray[nPUIDIndex++] = pItem->GetPuid();
        }
        else
        	LOG_out("This dependency item NOT applied");
    }
    return TRUE;
}


BOOL CV31Server::IsDependencyApply(PUID puid)
{
	LOG_block("CV31Server::IsDependencyApply()");
	LOG_out("puid(%d)", (long)puid);
	
	// handle no link
	if (WU_NO_LINK == puid) return TRUE;
	// no depend item is valid 
	if (!m_nNumOfValidDependentPUID) 
	{
		LOG_out("No dependecy item");
		return FALSE;
	}
	for (int nItem = 0; nItem < m_nNumOfValidDependentPUID; nItem ++)
	{
		if (m_pValidDependentPUIDArray[nItem] == puid) 
		{
			LOG_out ("puid(%d) applies", (long)puid);
			return TRUE;
		}
		if (m_pValidDependentPUIDArray[nItem] == 0) break; // 0 mark the end of valid puid
	}
	LOG_out("puid(%d) does not apply", (long)puid);
	return FALSE;
}

BOOL CV31Server::GetBitMask(LPSTR szBitmapLocalFileName, PUID nDirectoryPuid, PBYTE* pByte, LPSTR szDecompressedName)
{
	LOG_block("CV31Server::GetBitMask()");
	LOG_out("Parameters --- %s",szBitmapLocalFileName);
	SetLastError(0);
	
	// Parameter validation
	if (!szBitmapLocalFileName) 
	{
		LOG_error("Invalid Parameter");
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	SafeGlobalFree(*pByte);

	PBITMASK pBitMask = NULL;
	DWORD dwLength = 0;
	DWORD dwError = 0;
	BOOL fRetVal = FALSE;
	
	// log parameter
	LOG_out("szBitmapLocalFileName(%s)",szBitmapLocalFileName);

	char szBitmapServerFileName[INTERNET_MAX_URL_LENGTH];
	ZeroMemory(szBitmapServerFileName, INTERNET_MAX_URL_LENGTH*sizeof(char));

	char szBitmapFileWithDir[MAX_PATH];
	wsprintf(szBitmapFileWithDir, "%d/%s", nDirectoryPuid, szBitmapLocalFileName);

	m_pDu->DuUrlCombine(szBitmapServerFileName, m_szV31ContentUrl, szBitmapFileWithDir);

	dwError = m_pDu->DownloadFileToMem(szBitmapServerFileName, 
						(PBYTE*)&pBitMask, &dwLength, TRUE, szBitmapLocalFileName, szDecompressedName);
						
	if (ERROR_SUCCESS != dwError)
	{
		LOG_error("Failed to download %s --- %d", szBitmapServerFileName, dwError);
		return FALSE;
	}

	int iMaskByteSize = ((pBitMask->iRecordSize+7)/8);
	int nIndex = 0;
	
	for (int nItem =0; nItem < pBitMask->iLocaleCount; nItem ++)
	{
		nIndex = pBitMask->iOemCount + nItem;
		if (pBitMask->bmID[nIndex] == m_pDu->m_lcidLocaleID) break;
	}

	if (nItem >= pBitMask->iLocaleCount)
	{
		// not found
		// bad locale ? or missing locale info?
		LOG_error("LCID %d is not found in %s", m_pDu->m_lcidLocaleID, szBitmapLocalFileName);
		SetLastError(ERROR_UNSUPPORTED_TYPE);
		goto ErrorReturn;
	}

	*pByte =(PBYTE) GlobalAlloc(GMEM_ZEROINIT, iMaskByteSize);
	if (!pByte)
	{
		LOG_error("Out of memory");
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		goto ErrorReturn;
	}

	CopyMemory((PVOID)*pByte, (const PVOID) pBitMask->GetBitMaskPtr(nIndex+2), iMaskByteSize);

	fRetVal = TRUE;

	/* The next part of the code can be used to print of bitmask.as
	if (lstrcmp (szBitmapLocalFileName, "bitmask.cdm") == 0) goto ErrorReturn;
	for (nIndex = 0; nIndex < pBitMask->iLocaleCount; nIndex ++)
	{
		char szTTT [MAX_PATH];
		ZeroMemory(szTTT, MAX_PATH);
		wsprintf(szTTT, "%d --- ", pBitMask->bmID[nIndex +2 + pBitMask->iOemCount]);
		PBYTE pTep = (PBYTE) pBitMask->GetBitMaskPtr(nIndex +2 + pBitMask->iOemCount);
		for (nItem = 0; nItem < iMaskByteSize; nItem ++)
		{
			char szTTTTT [MAX_PATH];
			wsprintf(szTTTTT, "%d, ", pTep[nItem]);
			lstrcat(szTTT, szTTTTT);
		}	
		LOG_out("%s", szTTT);
	}*/
		
ErrorReturn:
	SafeGlobalFree(pBitMask);
	return fRetVal;	
}


BOOL CV31Server::ReadGuidrvINF()
{
	LOG_block("CV31Server::ReadGuidrvINF()");
    char szServerFile[INTERNET_MAX_URL_LENGTH + 1];
    char szLocalFile[MAX_PATH];
    char szValue[1024];
    int nDefaultBufferLength = 512;

    SafeGlobalFree(m_pszExcludedDriver);
    
    // Now read the Catalog.ini file to find out if any of these items needs to be turned off
    m_pDu->DuUrlCombine(szServerFile, m_szV31ContentUrl, GUIDRVINF);
    PathCombineA(szLocalFile, m_pDu->GetDuDownloadPath(), GUIDRVINF);
    if (ERROR_SUCCESS!=m_pDu->DownloadFile(szServerFile, szLocalFile, FALSE, FALSE))
    {
        LOG_out("No guidrv.inf found");
        return TRUE;
    }
    int nReadLength;
    do
    {
        nDefaultBufferLength <<=1;
        SafeGlobalFree(m_pszExcludedDriver);
        m_pszExcludedDriver = (LPSTR) GlobalAlloc(GPTR, nDefaultBufferLength * sizeof(char));
        if (!m_pszExcludedDriver)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            LOG_error("Out of memory");
            return FALSE;
        }
        nReadLength = GetPrivateProfileSectionA("ExcludedDrivers", m_pszExcludedDriver, nDefaultBufferLength, szLocalFile);
    } while ( nDefaultBufferLength-2 == nReadLength);

    if (!lstrlenA(m_pszExcludedDriver))
    {
        SafeGlobalFree(m_pszExcludedDriver);
        m_pszExcludedDriver = NULL;
    }  
    return TRUE;
}


BOOL CV31Server::IsPUIDExcluded(PUID nPuid)
{
    if (m_dwGlobalExclusionItemCount > 0)
    {
        for (DWORD dwCnt = 0; dwCnt < m_dwGlobalExclusionItemCount; dwCnt++)
        {
            if (nPuid == m_GlobalExclusionArray[dwCnt])
                return TRUE;
        }
    }
    return FALSE;
}

BOOL CV31Server::IsDriverExcluded(LPCSTR szWHQLId, LPCSTR szHardwareId)
{
    LOG_block("CV31Server::IsDriverExcluded()");
    LOG_out("%s %s", szWHQLId, szHardwareId);
    if(m_pszExcludedDriver)
    {
        char* pTemp = m_pszExcludedDriver;
        while (*pTemp)
        {
            // try to find if the driver is excluded
            char* pCharEnd = pTemp;
            char* pCharBegin = pTemp;
            // first one is the id for the cab
            while (*pCharEnd != ',' && *pCharEnd != '\0') pCharEnd++;
            if (NULL == *pCharEnd)
            {
                LOG_error("guidrvs.inf corruption --- %s", pTemp);
                return TRUE; // guidrvs.inf corrupted, assume excluded
            }
            if (lstrlenA(szWHQLId) == (int)(pCharEnd - pCharBegin)
               && !StrCmpNI(szWHQLId, pCharBegin, (int)(pCharEnd-pCharBegin)))
            {
                // cab name matches, try to match hardware id
                // ignore second and third one
                for (int i=0; i<2; i++)
                {
                    pCharBegin = pCharEnd + 1;
                    pCharEnd = pCharBegin;
                    while (*pCharEnd != ',' && *pCharEnd != '\0') pCharEnd++;
                    if (NULL == *pCharEnd)
                    {
                        LOG_error("guidrvs.inf corruption --- %s", pTemp);
                        return TRUE; // guidrv.inf corrupted, assume excluded
                    }
                }
                // the forth one should be the hardware id
                pCharBegin = pCharEnd + 1;
                if (!lstrcmpi(szHardwareId, pCharBegin) || ('*' == *pCharBegin && !*(pCharBegin+1)))
                {
                    LOG_out("Found match in guidrvs.inf, excluded --- %s", pTemp);
                    return TRUE;
                }
            }
            // move to next string
            pTemp += lstrlenA(pTemp) + 1;
        }
    }
    return FALSE;
}

BOOL CV31Server::GetAltName(LPCSTR szCabName, LPSTR szAltName, int nSize)
{
    if (!szCabName || !szAltName) return FALSE;

    char* pTemp = const_cast<char*>(szCabName);
    while (*pTemp && *pTemp != '_') pTemp++;
    int nTempSize = (int)(pTemp-szCabName);
    if (nTempSize >= nSize) return FALSE;
    lstrcpynA(szAltName, szCabName, nTempSize+1);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\wsdueng.cpp ===
#include "wsdueng.h"

HINSTANCE g_hinst;
CDynamicUpdate *g_pDynamicUpdate = NULL;
DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask);


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ;
    }
    return TRUE;
}


// Required function to be able to link CDMLIB..
HMODULE GetModule()
{
    return g_hinst;
}


// --------------------------------------------------------------------------
// Function Name: SetEstimatedDownloadSpeed
// Function Description: Sets the Download speed used for download time estimates
//
// Function Returns:
//      Nothing
//
void WINAPI SetEstimatedDownloadSpeed(DWORD dwBytesPerSecond)
{
    if (NULL != g_pDynamicUpdate)
        g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = dwBytesPerSecond;
}

// --------------------------------------------------------------------------
// Function Name: DuInitializeA
// Function Description: Initializes the DynamicUpdate class and converts the OSVERSIONINFO information into a Platform ID
//
// Function Returns:
//      INVALID_HANDLE_VALUE if it fails
//      HANDLE value of 1 if it succeeds
//
// NOTE: The use of a HANDLE could allow us to return the address of the DynamicUpdate Object, which was originally intended, but it seemed simpler
// to just use a global.. 
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, IN LPCSTR pszTempPath, POSVERSIONINFOEXA posviTargetOS, IN LPCSTR pszTargetArch, 
							IN LCID lcidTargetLocale, IN BOOL fUnattend, IN BOOL fUpgrade, IN PWINNT32QUERY pfnWinnt32QueryCallback)
{
	LOG_block("DuInitializeA in DuEng");

	// parameter validation
	// RogerJ, October 5th, 2000
	if (!pfnWinnt32QueryCallback) 
	{
		LOG_error("Callback function pointer invalid");
		SetLastError(ERROR_INVALID_PARAMETER);
		return INVALID_HANDLE_VALUE;
	}
	// DONE RogerJ
	
    // parse the OSVERSIONINFO struct for the platform ID
    int iPlatformID = 0;
    // The TargetOS Platform ID is based on a couple of things.
    // The Whister Platform ID is the OSVERSIONINFOEX structure with the fields dwMajorVersion and dwMinorVersion set to 5.1
    // The other identifier in the platform ID is whether its i386 or ia64 (64bit) .. This is defined in the pszTargetArch String

    if (5 == posviTargetOS->dwMajorVersion)
    {
        if (1 == posviTargetOS->dwMinorVersion)
        {
            // Whistler
            if (NULL != StrStrI(pszTargetArch, "i386"))
            {
                iPlatformID = 18; // Whistler x86 (normal)
            }
            else if (NULL != StrStrI(pszTargetArch, "ia64"))
            {
                iPlatformID = 19; // Whistler ia64 (64bit)
            }
        }
        else if (2 == posviTargetOS->dwMinorVersion)
        {
            // Whistler
            if (NULL != StrStrI(pszTargetArch, "i386"))
            {
                iPlatformID = 18; // Whistler x86 (normal)
            }
            else if (NULL != StrStrI(pszTargetArch, "ia64"))
            {
                iPlatformID = 19; // Whistler ia64 (64bit)
            }
        }
    }

    if (0 == iPlatformID)
    {
        // No known Platform ID for DynamicUpdate was found.. Return Error
        return INVALID_HANDLE_VALUE;
    }
    WORD wPlatformSKU = posviTargetOS->wSuiteMask;

	if (g_pDynamicUpdate)
	{
		// a former call to this function has already initialized an instance of CDynamicUpdate class
		delete g_pDynamicUpdate;
		g_pDynamicUpdate = NULL;
	}

    
    g_pDynamicUpdate = new CDynamicUpdate(iPlatformID, lcidTargetLocale, wPlatformSKU, pszTempPath, 
    									  pszBasePath, pfnWinnt32QueryCallback, posviTargetOS);
    if (NULL == g_pDynamicUpdate)
    {
        return INVALID_HANDLE_VALUE;
    }
    
    return (HANDLE)1;    
}

// --------------------------------------------------------------------------
// Function Name: DuDoDetection
// Function Description: Searches the Catalogs on the WU Site to find Updates for setup
//
// Function Returns:
//      FALSE if there are no items OR there is an error.. Use GetLastError() for more information.
//      TRUE if it succeeds and there are items to download.
//
// Comment: If return value is FALSE and GetLastError return ERROR_NO_MORE_ITEMS there are no items to download.
//
// Modified by RogerJ October 6th, 2000
// --- Added Driver Detection
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize)
{
	LOG_block("DuDoDetection in DuEng");

	DWORD dwRetSetup, dwRetDriver;
	dwRetSetup = dwRetDriver = 0;
	
    if (NULL == g_pDynamicUpdate)
        return FALSE;

    g_pDynamicUpdate->ClearDownloadItemList();
    dwRetSetup = g_pDynamicUpdate->DoSetupUpdateDetection();
    if (ERROR_SUCCESS != dwRetSetup)
    {
    	LOG_error("Failed to get setup update item! --- %d", dwRetSetup);
        g_pDynamicUpdate->PingBack(DU_PINGBACK_SETUPDETECTIONFAILED, 0, NULL, FALSE);
    }

	// do driver detection here
	if (!g_pDynamicUpdate->DoDriverDetection() ||
		!g_pDynamicUpdate->DoWindowsUpdateDriverDetection())
	{
		LOG_error("Failed to detect driver!");
		dwRetDriver = GetLastError();
        g_pDynamicUpdate->PingBack(DU_PINGBACK_DRIVERDETECTIONFAILED, 0, NULL, FALSE);
	}


	if (dwRetSetup && dwRetDriver)
	{
		LOG_error("Both Setup item and Driver detection failed");
		return FALSE;
	}
	
    if (g_pDynamicUpdate->m_dwDownloadItemCount > 0)
    {
        g_pDynamicUpdate->UpdateDownloadItemSize();
        *pdwEstimatedSize = g_pDynamicUpdate->m_dwTotalDownloadSize; // size in bytes
        // Time Estimate is based on roughly how long it took us to download the data files.
        if (0 == g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond)
            g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond = 2048; // default to 120k per minute, (2048 bytes per second).

        *pdwEstimatedTime = g_pDynamicUpdate->m_dwTotalDownloadSize / g_pDynamicUpdate->m_dwDownloadSpeedInBytesPerSecond; // number of seconds
        if (*pdwEstimatedTime == 0)
            *pdwEstimatedTime = 1; // at least one second

		if (dwRetSetup)
			SetLastError(dwRetSetup);
		if (dwRetDriver)
			SetLastError(dwRetDriver);
			
        return TRUE;
    }
    else
    {
    	// initialize the size and time for setup
    	*pdwEstimatedTime = 1;
    	*pdwEstimatedSize = 0;
        // At this point there was no error, but we have no items to download, 
        SetLastError(ERROR_NO_MORE_ITEMS);
        return TRUE;
    }
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify)
{
    if ((NULL == g_pDynamicUpdate) || (NULL == hwndNotify))
    {
    	SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (0 == g_pDynamicUpdate->m_dwDownloadItemCount)
    {
        SetLastError(ERROR_NO_MORE_ITEMS);
        PostMessage(hwndNotify, WM_DYNAMIC_UPDATE_COMPLETE, (WPARAM) DU_STATUS_SUCCESS, (LPARAM) NULL);

        return TRUE;
    }

    g_pDynamicUpdate->SetCallbackHWND(hwndNotify);  
    g_pDynamicUpdate->SetAbortDownload(FALSE);

    if (ERROR_SUCCESS != g_pDynamicUpdate->DownloadFilesAsync())
    {
        return FALSE;
    }

    return TRUE; // download has been started
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void WINAPI DuAbortDownload(IN HANDLE hConnection)
{
    if (NULL == g_pDynamicUpdate)
        return;

    g_pDynamicUpdate->SetAbortDownload(TRUE);
    return;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void WINAPI DuUninitialize(IN HANDLE hConnection)
{
    if (NULL == g_pDynamicUpdate)
        return;
    
    // We want to hold up the Uninitialize process until any other Threads
    // specifically the Download Thread. We are going to wait on the DownloadThreadProc
    // thread handle if it exists. Once the thread finishes, the wait proc will exit
    // and we can continue.

    if (NULL != g_pDynamicUpdate->m_hDownloadThreadProc)
        WaitAndPumpMessages(1, &g_pDynamicUpdate->m_hDownloadThreadProc, QS_ALLINPUT);
    
    delete g_pDynamicUpdate;
    g_pDynamicUpdate = NULL;

    LOG_close();
    return;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
CDynamicUpdate::CDynamicUpdate(int iPlatformID, LCID lcidLocaleID, WORD wPlatformSKU, LPCSTR pszTempPath, LPCSTR pszDownloadPath, PWINNT32QUERY pfnWinnt32QueryCallback,
							   POSVERSIONINFOEXA pVersionInfo)
    :   m_iPlatformID(iPlatformID),
        m_lcidLocaleID(lcidLocaleID),
        m_wPlatformSKU(wPlatformSKU),
        m_hwndClientNotify(NULL),
        m_pDownloadItemList(NULL),
        m_dwDownloadItemCount(0),
        m_dwTotalDownloadSize(0),
        m_dwCurrentBytesDownloaded(0),
        m_hInternet(NULL),
        m_hConnect(NULL),
        m_hOpenRequest(NULL),
        m_pV3(NULL),
        m_fAbortDownload(FALSE),
        m_dwLastPercentComplete(0),
        m_dwDownloadSpeedInBytesPerSecond(0),
        m_hDownloadThreadProc(NULL),
        m_pfnWinNT32Query(pfnWinnt32QueryCallback)
{

    (void)FixUpV3LocaleID(); // BUG: 435184 - Map 0c0a to 040a for V3 purposes

    if (NULL != pszTempPath)
    {
        lstrcpy(m_szTempPath, pszTempPath);
    }
    if (NULL != pszDownloadPath)
    {
        lstrcpy(m_szDownloadPath, pszDownloadPath);
    }

    lstrcpy(m_szCurrentConnectedServer, ""); // initialize to null.

	CopyMemory((PVOID)&m_VersionInfo, (PVOID)pVersionInfo, sizeof(OSVERSIONINFOEXA));

    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csDownload);
//    m_hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES);
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
CDynamicUpdate::~CDynamicUpdate()
{
    ClearDownloadItemList(); // free up any memory in the download list
    m_arrayHardwareId.RemoveAll();
    if (m_pV3) delete m_pV3;
    m_pV3 = NULL;

    DeleteCriticalSection(&m_cs);
    DeleteCriticalSection(&m_csDownload);
    SafeInternetCloseHandle(m_hOpenRequest);
    SafeInternetCloseHandle(m_hConnect);
    SafeInternetCloseHandle(m_hInternet);
    SafeCloseHandle(m_hDownloadThreadProc);
}

LPSTR CDynamicUpdate::DuUrlCombine(LPSTR pszDest, LPCSTR pszBase, LPCSTR pszAdd)
{
    if ((NULL == pszDest) || (NULL == pszBase) || (NULL == pszAdd))
    {
        return NULL;
    }

    lstrcpy(pszDest, pszBase);
    int iLen = lstrlen(pszDest);
    if ('/' == pszDest[iLen - 1])
    {
        // already has a trailing slash, check the 'add' string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, skip it.
            lstrcat(pszDest, pszAdd + 1);
        }
        else
        {
            lstrcat(pszDest, pszAdd);
        }
    }
    else
    {
        // no trailing slash, check the add string for a preceding slash
        if ('/' == *pszAdd)
        {
            // has a preceding slash, Add Normally
            lstrcat(pszDest, pszAdd);
        }
        else
        {
            lstrcat(pszDest, "/");
            lstrcat(pszDest, pszAdd);
        }
    }
    return pszDest;
}


LPCSTR CDynamicUpdate::GetDuDownloadPath()
{
    return m_szDownloadPath;
}

LPCSTR CDynamicUpdate::GetDuServerUrl()
{
    return m_szServerUrl;
}

LPCSTR CDynamicUpdate::GetDuTempPath()
{
    return m_szTempPath;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
DWORD CDynamicUpdate::DoSetupUpdateDetection()
{
    if (NULL == m_pV3)
    {
        m_pV3 = new CV31Server(this);
        if (NULL == m_pV3)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (!m_pV3->ReadIdentInfo())
    {
        return GetLastError();
    }

    if (!m_pV3->GetCatalogPUIDs())
    {
        return GetLastError();
    }

    if (!m_pV3->GetCatalogs())
    {
        // there was an error reading the catalogs
        return GetLastError();
    }
    if (!m_pV3->ReadCatalogINI())
    {
        return GetLastError();
    }
    if (!m_pV3->UpdateDownloadItemList(m_VersionInfo))
    {
        // there was an error parsing the catalogs and creating the download list.
        return GetLastError();
    }
    return ERROR_SUCCESS;
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void CDynamicUpdate::AddDownloadItemToList(DOWNLOADITEM *pDownloadItem)
{
	LOG_block("CDynamicUpdate::AddDownloadItemToList");
    if (NULL == pDownloadItem)
    {
        return;
    }


    if (NULL == m_pDownloadItemList) // no drivers in list yet
    {
        m_pDownloadItemList = pDownloadItem;
    }
    else
    {

        // add to the end of the list
        DOWNLOADITEM *pCurrent = m_pDownloadItemList;
        while (NULL != pCurrent->pNext)
        {
            pCurrent = pCurrent->pNext;
        }

        pCurrent->pNext = pDownloadItem;
        pDownloadItem->pPrev = pCurrent;
    }

    m_dwDownloadItemCount++;
    LOG_out("Item added, %d cab(s), first cab ---\"%s\"", pDownloadItem->iNumberOfCabs, pDownloadItem->mszFileList);
}

// --------------------------------------------------------------------------
//
//
//
//
//
//
// --------------------------------------------------------------------------
void CDynamicUpdate::RemoveDownloadItemFromList(DOWNLOADITEM *pDownloadItem)
{
    if (NULL == pDownloadItem)
    {
        return;
    }

    if (NULL == m_pDownloadItemList)
    {
        return;
    }

    DOWNLOADITEM *pCurrent = m_pDownloadItemList;

    while (NULL != pCurrent)
    {
        if (pCurrent == pDownloadItem)
        {
            break;
        }

        pCurrent = pCurrent->pNext;
    }

    if ((NULL == pCurrent) || (pCurrent != pDownloadItem))
    {
        return; // unexpected
    }

    if (NULL == pCurrent->pPrev) // first item in list
    {
        if (NULL == pCurrent->pNext) // only item in list
        {
            m_pDownloadItemList = NULL;
            m_dwDownloadItemCount = 0;
        }
        else
        {
            pCurrent->pNext->pPrev = NULL; // next job becomes first
            m_pDownloadItemList = pCurrent->pNext;
            m_dwDownloadItemCount--;
        }
    }
    else
    {
        pCurrent->pPrev->pNext = pCurrent->pNext;
        if (NULL != pCurrent->pNext)
        {
            pCurrent->pNext->pPrev = pCurrent->pPrev;
        }
    }
}

void CDynamicUpdate::SetCallbackHWND(HWND hwnd)
{
    m_hwndClientNotify = hwnd;
}

void CDynamicUpdate::SetAbortDownload(BOOL fAbort)
{
    EnterCriticalSection(&m_cs);
    m_fAbortDownload = fAbort;
    LeaveCriticalSection(&m_cs);
}

void CDynamicUpdate::UpdateDownloadItemSize()
{
    m_dwTotalDownloadSize = 0;
    DOWNLOADITEM *pCurrent = m_pDownloadItemList;
    while (pCurrent)
    {
        m_dwTotalDownloadSize += pCurrent->dwTotalFileSize;
        pCurrent = pCurrent->pNext;
    }
}

void CDynamicUpdate::ClearDownloadItemList()
{
    EnterCriticalSection(&m_csDownload);
    DOWNLOADITEM *pCurrent = m_pDownloadItemList;
    DOWNLOADITEM *pNext;
    while (pCurrent)
    {
        pNext = pCurrent->pNext;
        SafeGlobalFree(pCurrent);
        pCurrent = pNext;
    }
    m_pDownloadItemList = NULL;
    m_dwDownloadItemCount = 0;
    LeaveCriticalSection(&m_csDownload);
}

void CDynamicUpdate::EnterDownloadListCriticalSection()
{
    EnterCriticalSection(&m_csDownload);
}

void CDynamicUpdate::LeaveDownloadListCriticalSection()
{
    LeaveCriticalSection(&m_csDownload);
}

void CDynamicUpdate::FixUpV3LocaleID()
{
    // Some XP Locale ID's map to a different Locale ID in V3 Terms
    // First Example was a new Spanish (Modern) Locale ID (0c0a)
    // which in V3 was (040a). For the V3 period we will fix up
    // any specific LCID's until IU handles this.

    switch (m_lcidLocaleID)
    {
    case 3082: // 0c0a = Spanish (Modern)
        {
            m_lcidLocaleID = 1034; // 040a
            break;
        }
    default:
        {
            // do nothing.
        }
    }

    return;
};

DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask)
{
    DWORD dwWaitResult;
    MSG msg;

    while (TRUE)
    {
        dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, FALSE, 1000, dwWakeMask);
        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
            return dwWaitResult;
        }

        if (WAIT_OBJECT_0 + nCount == dwWaitResult)
        {
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return dwWaitResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\multiszarray.cpp ===
// -----------------------------------------------------------------------------------
// Created by RogerJ, October 4th, 2000
// Implementation of MultiSZ smart Array
//

#include <windows.h>
#include "MultiSZArray.h"

// class CMultiSZString

// defatul constructor
CMultiSZString::CMultiSZString()
{
	m_nSize = m_nStringCount = m_nIndex = 0;
	m_bFound = FALSE;
	m_szHardwareId = NULL;
	prev = next = NULL;
}

// constructor
CMultiSZString::CMultiSZString(LPCTSTR pszHardwareId, int nSize)
{
	prev = next = NULL;
	m_nSize = m_nStringCount = m_nIndex = 0;
	m_bFound = FALSE;
	m_szHardwareId = NULL;
	if (pszHardwareId)
	{

		if (nSize >= 0)
		{
			// passed in a regular LPCTSTR
			m_nSize = nSize;
			m_nStringCount = 1;
		}
		else
		{
			// passed in a multi-sz LPCTSTR
			// get the size
			LPTSTR pTemp = const_cast<LPTSTR>(pszHardwareId);
			while (*pTemp)
			{
				int nTempSize = lstrlen(pTemp) + 1;
				m_nSize += nTempSize;
				pTemp += nTempSize;

				m_nStringCount++;
			}
		}
		
		
		// allocate memory
		m_szHardwareId = new TCHAR [m_nSize+1];

		if (!m_szHardwareId)
			// failed to allocate memory
			throw ERROR_OUTOFMEMORY;

		// initialize allocated memory
		ZeroMemory (m_szHardwareId, (m_nSize+1) * sizeof(TCHAR)); // +1 for a possible trail NULL
		CopyMemory ((PVOID)m_szHardwareId, (CONST VOID*)pszHardwareId, m_nSize*sizeof(TCHAR));
		m_nSize ++;
	}
}

// copy constructor
CMultiSZString::CMultiSZString(CMultiSZString& CopyInfo)
{
	prev = next = NULL;
	m_nIndex = 0;
	m_nSize = CopyInfo.m_nSize;
	m_bFound = CopyInfo.m_bFound;
	
	// allocate memory
	m_szHardwareId = new TCHAR [m_nSize];
	if (!m_szHardwareId)
		// failed to allocate memory
		throw ERROR_OUTOFMEMORY;
	// initialize allocated memory
	ZeroMemory (m_szHardwareId, m_nSize * sizeof(TCHAR));
	CopyMemory ((PVOID)m_szHardwareId, (CONST VOID*)(CopyInfo.m_szHardwareId), m_nSize*sizeof(TCHAR));
}
	
// destructor
CMultiSZString::~CMultiSZString()
{
	if (m_szHardwareId)
		delete [] m_szHardwareId;
	m_szHardwareId = NULL;
	prev = next = NULL;
	m_nSize = m_nIndex = 0;
}


BOOL CMultiSZString::ToString (LPTSTR pszBuffer, int* pnBufferLen)
{
	if (!pszBuffer)
	{
		// query for output buffer length
		if (m_nSize <= 0) 
			*pnBufferLen = 1;
		else 
			*pnBufferLen = m_nSize;
		return TRUE;
	}

	if (*pnBufferLen < m_nSize)
	{
		*pnBufferLen = m_nSize;
		return FALSE;
	}

	// duel with NULL string special case
	if (m_nSize <= 0)
	{
		*pszBuffer = NULL;
		return TRUE;
	}

	ZeroMemory(pszBuffer, *pnBufferLen * sizeof(TCHAR));
	
	LPTSTR pTemp = m_szHardwareId;
	LPTSTR pTemp2 = pszBuffer;
	while (*pTemp)
	{
		lstrcpy(pTemp2,pTemp);
		// add space in the place of NULL character
		pTemp2 += lstrlen(pTemp2);
		*pTemp2 = ' ';
		pTemp2++;
		// move to next string in Multi-SZ string
		pTemp += lstrlen(pTemp) + 1;
	}
	return TRUE;
}


// compare two multi-sz string
BOOL CMultiSZString::Compare (CMultiSZString& CompareSZ)
{
	LPTSTR pThis = m_szHardwareId;
	LPTSTR pComp = CompareSZ.m_szHardwareId;

	// compare size first
	if (m_nSize != CompareSZ.m_nSize) return FALSE;

	// size are same
	while (*pThis && *pComp)
	{
		// compare one string in the list
		if (0 != lstrcmp(pThis, pComp))
			return FALSE;

		// move to next string
		int nIncrement = lstrlen(pThis);
		pThis += nIncrement + 1;
		pComp += nIncrement + 1;
	}

	// one multi-sz terminates, check to see if both terminates
	if (*pThis || *pComp) return FALSE;
	else return TRUE;
		
}


// compare two multi-sz string case insensitively
BOOL CMultiSZString::CompareNoCase (CMultiSZString& CompareSZ)
{
	LPTSTR pThis = m_szHardwareId;
	LPTSTR pComp = CompareSZ.m_szHardwareId;

	// compare size first
	if (m_nSize != CompareSZ.m_nSize) return FALSE;

	// size are same
	while (*pThis && *pComp)
	{
		// compare one string in the list
		if (0 != lstrcmpi(pThis, pComp))
			return FALSE;

		// move to next string
		int nIncrement = lstrlen(pThis) + 1;
		pThis += nIncrement;
		pComp += nIncrement;
	}

	// one multi-sz terminates, check to see if both terminates
	if (*pThis || *pComp) return FALSE;
	else return TRUE;
		
}

LPCTSTR CMultiSZString::GetNextString(void)
{
	// reached end of the multiSZ string
	if (m_nIndex >= m_nSize) return NULL;
	
	// else
	LPTSTR pTemp = m_szHardwareId + m_nIndex;
	m_nIndex += lstrlen(pTemp) + 1;
	return pTemp;
}

// return TRUE if pszIn is in the Multi-SZ string
BOOL CMultiSZString::Contains(LPCTSTR pszIn)
{
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmp(pThis, pszIn))
			// match found
			return TRUE;
		pThis += (lstrlen(pThis) +1);
	}

	// not found
	return FALSE;
}


// return TRUE if pszIn is in the Multi-SZ string
BOOL CMultiSZString::ContainsNoCase(LPCTSTR pszIn)
{
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmpi(pThis, pszIn))
			// match found
			return TRUE;
		pThis += (lstrlen(pThis) +1);
	}

	// not found
	return FALSE;
}

BOOL CMultiSZString::PositionIndex(LPCTSTR pszIn, int* pPosition)
{
	if (!pPosition) return FALSE;
	*pPosition = 0;
	
	LPTSTR pThis = m_szHardwareId;

	while (*pThis)
	{
		if (!lstrcmpi(pThis, pszIn))
		{	
			// match found
			return TRUE;
		}
		pThis += (lstrlen(pThis) +1);
		(*pPosition)++;
	}

	// not found
	*pPosition = -1;
	return FALSE;
}
	
	


// Class CMultiSZArray

// default constructor
CMultiSZArray::CMultiSZArray()
{
	m_nCount = 0;
	m_pHead = m_pTail = m_pIndex = NULL;
}

// other constructors
CMultiSZArray::CMultiSZArray(LPCTSTR pszHardwareId, int nSize)
{
	CMultiSZString *pNode = new CMultiSZString(pszHardwareId, nSize);

	if (!pNode) throw ERROR_OUTOFMEMORY;

	m_nCount = 1;
	m_pHead = m_pTail = m_pIndex = pNode;
}

CMultiSZArray::CMultiSZArray(CMultiSZString* pNode)
{
	if (!pNode) return;

	m_nCount = 1;
	m_pHead = m_pTail = m_pIndex =pNode;
}

// destructor
CMultiSZArray::~CMultiSZArray(void)
{
	RemoveAll();
}

// member functions

// Function RemoveAll() delete all the memory allocated for the array and set the status back to initial state
BOOL CMultiSZArray::RemoveAll(void)
{
	CMultiSZString* pTemp = NULL;

	for (int i=0; i<m_nCount; i++)
	{
		pTemp = m_pHead;
		m_pHead = m_pHead->next;

		delete pTemp;
	}

	m_pHead = m_pTail = m_pIndex = NULL;
	m_nCount = 0;
	return TRUE;
}

BOOL CMultiSZArray::Add(CMultiSZString* pInfo)
{
	if (!pInfo) return TRUE;

	if (!m_nCount)
		m_pHead = pInfo;
	else
	{
		// link
		m_pTail->next = pInfo;
		pInfo->prev = m_pTail;
		pInfo->next = NULL;
	}
	// move tail
	m_pTail = pInfo;
	m_nCount++;
	return TRUE;
}

BOOL CMultiSZArray::Add(LPCSTR pszHardwareId, int nSize)
{
	CMultiSZString* pNode = new CMultiSZString(pszHardwareId, nSize);
	return Add(pNode);
}


BOOL CMultiSZArray::Remove(LPCSTR pszHardwareId)
{
	CMultiSZString* pTemp = m_pHead;
	while (pTemp)
	{
		if (pTemp->m_szHardwareId == pszHardwareId)
		{
			// found match
			if (pTemp->prev)
				// not the head node
				pTemp->prev->next = pTemp->next;
			else
			{
				// head node, move the head node
				m_pHead = pTemp->next;
				if (m_pHead) m_pHead->prev = NULL;
			}

			if (pTemp->next)
				// not the tail node
				pTemp->next->prev = pTemp->prev;
			else
			{
				// tail node, move the tail node
				m_pTail = pTemp->prev;
				if (m_pTail) m_pTail->next = NULL;
			}
			delete pTemp;
			m_nCount--;
			return TRUE;
		}
		pTemp = pTemp->next;
	}
	// no match found or no node in the array
	return FALSE;
}
		
BOOL CMultiSZArray::ToString(LPTSTR pszBuffer, int* pnBufferLen)
{
	int nTempLen = 0;
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		nTempLen += pTemp->m_nSize;
		pTemp = pTemp->next;
	}

	nTempLen++; // the trailing NULL character
	
	if (!pszBuffer)
	{
		// request for length
		*pnBufferLen = nTempLen;
		return TRUE;
	}
	else
	{
		if (*pnBufferLen < nTempLen)
		{
			// buffer too small
			*pnBufferLen = nTempLen;
			return FALSE;
		}
		else
		{
			ZeroMemory(pszBuffer, *pnBufferLen * sizeof (TCHAR));
			
			LPTSTR pszTemp = pszBuffer;
			int nSizeLeft = *pnBufferLen;
			pTemp = m_pHead;

			for (int j=0; j<m_nCount; j++)
			{
				pTemp->ToString(pszTemp, &nSizeLeft);
				pszTemp += pTemp->m_nSize - 1;
				*pszTemp = '\n';
				nSizeLeft -= pTemp->m_nSize;

				pTemp = pTemp->next;
			}

			return TRUE;
		}		
	}
}

int CMultiSZArray::GetTotalStringCount()
{
	CMultiSZString* pTemp = m_pHead;
	int nTotalCount = 0;
	
	for (int i = 0; i<m_nCount; i++)
	{
		nTotalCount += pTemp->m_nStringCount;

		pTemp = pTemp->next;
	}

	return nTotalCount;
}

CMultiSZString* CMultiSZArray::GetNextMultiSZString()
{
	CMultiSZString* pTemp = m_pIndex;

	if (m_pIndex) m_pIndex = m_pIndex->next;

	return pTemp;
}
		
BOOL CMultiSZArray::Contains(LPCTSTR pszIn)
{
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->Contains(pszIn))
			return TRUE;
		pTemp = pTemp->next;
	}

	return FALSE;
}

BOOL CMultiSZArray::ContainsNoCase(LPCTSTR pszIn)
{
	CMultiSZString* pTemp = m_pHead;

	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->ContainsNoCase(pszIn))
			return TRUE;
		pTemp = pTemp->next;
	}

	return FALSE;
}

BOOL CMultiSZArray::PositionIndex(LPCTSTR pszIn, PosIndex* pPosition)
{
	if (!pPosition) return FALSE;
	CMultiSZString* pTemp = m_pHead;

	pPosition->y = 0;
	pPosition->x = 0;
	
	for (int i=0; i<m_nCount; i++)
	{
		if (pTemp->PositionIndex(pszIn, &(pPosition->y)))
			return TRUE;
		(pPosition->x)++;
		pTemp = pTemp->next;
	}

	pPosition->x = pPosition->y = -1;
	return FALSE;
}

BOOL CMultiSZArray::CheckFound(int nIndex)
{
    if (nIndex > m_nCount) return FALSE;
    
    CMultiSZString* pTemp = NULL;
    ResetIndex();

    for (int i=0; i<=nIndex; i++)
    {
        pTemp = GetNextMultiSZString();
    }

    pTemp->CheckFound();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\multiszarray.h ===
// -------------------------------------------------------------------------------
// Created by RogerJ, October 4th, 2000
// This header file declares two classes that are closely linked to each other. These
// two classes provided a convenient way to construct, add, and remove a multi-sz list
// array.

#ifndef _WINDOWS_UPDATE_MULTI_SZ_LIST_BY_ROGERJ	
#define _WINDOWS_UPDATE_MULTI_SZ_LIST_BY_ROGERJ

struct PosIndex
{
	PosIndex() { x = y = -1;};
	int x;
	int y;
	inline BOOL operator < (PosIndex& other) { return (x<other.x) || ((x==other.x) && (y<other.y));};
	inline BOOL operator > (PosIndex& other) { return (x>other.x) || ((x==other.x) && (y>other.y));};
	inline BOOL operator == (PosIndex& other) { return (x==other.x) && (y==other.y);};
};

// forward declaration
class CMultiSZArray;

class CMultiSZString
{
public:
	// default constructor
	CMultiSZString();
	CMultiSZString (LPCTSTR pszHardwareId, int nSize = -1);
	// copy constructor
	CMultiSZString (CMultiSZString& CopyInfo);
	// destructor
	~CMultiSZString (void);

	// member functions
	BOOL ToString(LPTSTR pszBuffer, int* pnBufferLen);
	BOOL Compare(CMultiSZString& CompareString);
	BOOL CompareNoCase (CMultiSZString& CompareString);
	inline BOOL operator == (CMultiSZString& CompareString) { return Compare(CompareString);};
	inline void ResetIndex(void) { m_nIndex = 0; };
	LPCTSTR GetNextString(void);
	BOOL Contains(LPCTSTR pszIn);
	BOOL ContainsNoCase (LPCTSTR pszIn);
	BOOL PositionIndex(LPCTSTR pszIn, int* pPosition);
	inline void CheckFound(void) { m_bFound = TRUE;};
	inline BOOL IsFound(void) { return m_bFound; };

	// friend class
	friend class CMultiSZArray;
private:
	// member variables
	LPTSTR m_szHardwareId;
	int m_nSize;
	int m_nStringCount;
	int m_nIndex;
	BOOL m_bFound;

	// linking pointers
	CMultiSZString* prev;
	CMultiSZString* next;
};

class CMultiSZArray
{
public:
	// default constructor
	CMultiSZArray();
	// other constructors
	CMultiSZArray(CMultiSZString* pInfo);
	CMultiSZArray(LPCTSTR pszHardwareId, int nSize = -1);
	// destructor
	~CMultiSZArray(void);

	// operations
	BOOL RemoveAll(void);
	BOOL Add(CMultiSZString* pInfo);
	BOOL Add(LPCSTR pszHardwareId, int nSize = -1);
	inline BOOL Remove(CMultiSZString* pInfo) { return Remove(pInfo->m_szHardwareId);};
	inline BOOL Remove(CMultiSZString& Info) { return Remove(Info.m_szHardwareId);};
	BOOL Remove(LPCTSTR pszHardwareId);
	inline int GetCount(void) { return m_nCount;};
	BOOL ToString (LPTSTR pszBuffer, int* pnBufferLen);
	int GetTotalStringCount(void);
	inline void ResetIndex() { m_pIndex = m_pHead; };
	CMultiSZString* GetNextMultiSZString(void);
	BOOL Contains(LPCTSTR pszIn);
	BOOL ContainsNoCase (LPCTSTR pszIn);
	BOOL PositionIndex(LPCTSTR pszIn, PosIndex* pPosition);
	BOOL CheckFound(int nIndex);

private:
	// member vairables
	CMultiSZString* m_pHead;
	CMultiSZString* m_pTail;
	int m_nCount;
	CMultiSZString* m_pIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wsdu\wsdueng\wsdueng.h ===
#include <windows.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <devguid.h>
#include <regstr.h>
#include <stdio.h>
#include <lmcons.h>
#include <wininet.h>
#include <fdi.h>

#include <wuv3.h>
#include <varray.h>
#include <v3stdlib.h>
#include <filecrc.h>
#include <newtrust.h>

#include "log.h"
#include "v3server.h"
#include "dynamic.h"
#include "MultiSZArray.h"

#define DU_STATUS_SUCCESS       1
#define DU_STATUS_ABORT         2
#define DU_STATUS_FAILED        3

#define WM_DYNAMIC_UPDATE_COMPLETE WM_APP + 1000 + 1000
// (WPARAM) Completion Status (SUCCESS, ABORTED, FAILED) : (LPARAM) (DWORD) Error Code if Status Failed
#define WM_DYNAMIC_UPDATE_PROGRESS WM_APP + 1000 + 1001
// (WPARAM) (DWORD) TotalDownloadSize : (LPARAM) (DWORD) BytesDownloaded 

#define DU_CONNECTION_RETRY 2

// REMOVE THIS when checked into Whistler Tree .. Personal Should be Defined.
#ifndef VER_SUITE_PERSONAL
#define VER_SUITE_PERSONAL 0x00000200
#endif


// RogerJ --- the next part of this header file contains information for avoid autodisconnection
//
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0

static const char c_szDialmonClass[] = "MS_WebcheckMonitor";
// DONE


#define DU_PINGBACK_DOWNLOADSTATUS          0
#define DU_PINGBACK_DRIVERNOTFOUND          1
#define DU_PINGBACK_SETUPDETECTIONFAILED    2
#define DU_PINGBACK_DRIVERDETECTIONFAILED   3

#define sizeOfArray(a)  (sizeof(a) / sizeof(a[0]))
#define SafeGlobalFree(x)       if (NULL != x) { GlobalFree(x); x = NULL; }
#define SafeInternetCloseHandle(x) if (NULL != x) { InternetCloseHandle(x); x = NULL; }
#define SafeCloseHandle(x) if (INVALID_HANDLE_VALUE != x) { CloseHandle(x); x = INVALID_HANDLE_VALUE; }

void WINAPI SetEstimatedDownloadSpeed(DWORD dwBytesPerSecond);
HANDLE WINAPI DuInitializeA(IN LPCSTR pszBasePath, IN LPCSTR pszTempPath, IN POSVERSIONINFOEXA posviTargetOS, 
                            IN LPCSTR pszTargetArch, IN LCID lcidTargetLocale, IN BOOL fUnattend, IN BOOL fUpgrade, 
                            IN PWINNT32QUERY pfnWinnt32QueryCallback);
BOOL WINAPI DuDoDetection(IN HANDLE hConnection, OUT PDWORD pdwEstimatedTime, OUT PDWORD pdwEstimatedSize);
BOOL WINAPI DuBeginDownload(IN HANDLE hConnection, IN HWND hwndNotify);
void WINAPI DuAbortDownload(IN HANDLE hConnection);
void WINAPI DuUninitialize(IN HANDLE hConnection);

// fdi.cpp
BOOL fdi(char *cabinet_fullpath, char *directory);

typedef struct DOWNLOADITEM
{
    char mszFileList[2048]; // MultiSZ list of Cabs to Download
    DWORD dwTotalFileSize;
    DWORD dwBytesDownload;
    int iCurrentCab;
    int iNumberOfCabs;
    BOOL fComplete;
    PUID puid;

    DOWNLOADITEM *pNext;
    DOWNLOADITEM *pPrev;
} DOWNLOADITEM;

typedef struct DOWNLOADTHREADPROCINFO
{
    char szLocalFile[MAX_PATH];
    BOOL fCheckTrust;
    BOOL fDecompress;
    HWND hwndNotify;
    HINTERNET hInternet;
} DOWNLOADTHREADPROCINFO, *PDOWNLOADTHREADPROCINFO;

class CDynamicUpdate
{
public:
    CDynamicUpdate(int iPlatformID, LCID lcidLocaleID, WORD wPlatformSKU, LPCSTR pszTempPath, 
                   LPCSTR pszDownloadPath, PWINNT32QUERY pfnWinnt32QueryCallback, POSVERSIONINFOEXA pVersionInfo);
    ~CDynamicUpdate();

public:
    BOOL DoDriverDetection(void);
    BOOL IsHardwareIdHasDriversOnCD(LPCSTR pszHardwareIdList);
    BOOL DoWindowsUpdateDriverDetection(void);
    BOOL DoPrinterDriverDetection(void);
    DWORD DoSetupUpdateDetection(void);

public:
    // Class Member Access Functions
    LPCSTR GetDuTempPath();
    LPCSTR GetDuDownloadPath();
    LPCSTR GetDuServerUrl();
    int GetTargetPlatformID();
    LCID GetTargetLocaleID();
    void SetCallbackHWND(HWND hwnd);
    void SetAbortDownload(BOOL fAbort);

    // Helper Functions
    LPSTR DuUrlCombine(LPSTR pszDest, LPCSTR pszBase, LPCSTR pszAdd);

    // Download Funcntions
    DWORD DownloadFilesAsync();
    DWORD DownloadFile(LPCSTR pszDownloadUrl, LPCSTR pszLocalFile, BOOL fDecompress, BOOL fCheckTrust);
    DWORD DownloadFileToMem(LPCSTR pszDownloadUrl, PBYTE *lpBuffer, DWORD *pdwAllocatedLength, BOOL fDecompress, LPSTR pszFileName, LPSTR pszDecompresedFileName);
    DWORD AsyncDownloadProc();
    DWORD PingBack(int iPingBackType, PUID puid, LPCSTR pszPnPID, BOOL fSucceeded);
 
    // Download Item Management Functions
    void AddDownloadItemToList(DOWNLOADITEM *pDownloadItem);
    void RemoveDownloadItemFromList(DOWNLOADITEM *pDownloadItem);
    void ClearDownloadItemList();
    void UpdateDownloadItemSize();
    void EnterDownloadListCriticalSection();
    void LeaveDownloadListCriticalSection();
    BOOL NeedRetry(DWORD dwErrCode);

    // Language Fix Up Helpers (BUG: 435184) Need to map Some Languages from XP LCID's to V3 LCID's.
    void FixUpV3LocaleID();


    // Download Helper Functions
    DWORD OpenHttpConnection(LPCSTR pszDownloadUrl, BOOL fGetRequest);
    BOOL IsServerFileNewer(FILETIME ft, DWORD dwServerFileSize, LPCSTR pszLocalFile);

public:
    CV31Server *m_pV3;

    int m_iPlatformID;
    LCID m_lcidLocaleID;
    WORD m_wPlatformSKU;
    char m_szTempPath[MAX_PATH];
    char m_szDownloadPath[MAX_PATH];
    char m_szServerUrl[INTERNET_MAX_URL_LENGTH + 1];
    
    // This is the core list of files that we will download. It contains all the setup
    // update items, and all the drivers that are going to be downloaded.
    DOWNLOADITEM *m_pDownloadItemList;
    DWORD m_dwCurrentBytesDownloaded;
    DWORD m_dwDownloadItemCount;
    DWORD m_dwTotalDownloadSize;
    DWORD m_dwDownloadSpeedInBytesPerSecond;

    HWND m_hwndClientNotify;
    DWORD m_dwLastPercentComplete;
    BOOL m_fAbortDownload;
    CRITICAL_SECTION m_cs;
    CRITICAL_SECTION m_csDownload;
    OSVERSIONINFOEX m_VersionInfo;

    // RogerJ, this is the multi-sz array used for driver detection
    CMultiSZArray m_arrayHardwareId;

    // Download Connection Handles
    HINTERNET m_hInternet;
    HINTERNET m_hConnect;
    HINTERNET m_hOpenRequest;

    char m_szCurrentConnectedServer[INTERNET_MAX_URL_LENGTH];

    // RogerJ October 5th, 2000
    // call back function pointer
    PWINNT32QUERY m_pfnWinNT32Query;
    HANDLE m_hDownloadThreadProc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\atol.cpp ===
//////////////////////////////////////////////////////////////////////////////////////////////////
//
//      string.c 
//
//      This file contains most commonly used string operation.  ALl the setup project should link here
//  or add the common utility here to avoid duplicating code everywhere or using CRT runtime.
//
//  Created             4\15\997        inateeg
//
///////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include "utils2.h"

//=================================================================================================
//
// copied from msdev\crt\src\atox.c
//
// long AtoL(char *nptr) - Convert string to long
//
// Purpose:
//       Converts ASCII string pointed to by nptr to binary.
//       Overflow is not detected.
//
// Entry:
//       nptr = ptr to string to convert
//
// Exit:
//       return long int value of the string
//
// Exceptions:
//       None - overflow is not detected.
//
//=================================================================================================

long AtoL(const TCHAR *nptr)
{
    int c;                  /* current char */
    long total;             /* current total */
    int sign;               /* if '-', then negative, otherwise positive */

    // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
    // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
    // DBCS Trailing bytes -- pritvi

    /* skip whitespace */
    while ( IsSpace((int)(unsigned TCHAR)*nptr) )
        ++nptr;

    c = (int)(unsigned TCHAR)*nptr++;
    sign = c;               /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned TCHAR)*nptr++;        /* skip sign */

    total = 0;

    while (IsDigit(c)) {
        total = 10 * total + (c - '0');         /* accumulate digit */
        c = (int)(unsigned TCHAR)*nptr++;        /* get next char */
    }

    if (sign == '-')
        return -total;
    else
        return total;   /* return result, negated if necessary */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\expression.cpp ===
/////////////////////////////////////////////////////////////////
//
// File Modified by RogerJ, 03/09/00 
//
/////////////////////////////////////////////////////////////////
#include "wudetect.h"

const TCHAR DET_TYPE_FILEVERSION[] =	TEXT("FileVer");
const TCHAR DET_TYPE_REGKEYEXISTS[] =	TEXT("RegKeyExists");
const TCHAR DET_TYPE_REGKEYSUBSTR[] =	TEXT("RegKeySubStr");
const TCHAR DET_TYPE_REGKEYBINARY[] =   TEXT("RegKeyBinary");
const TCHAR DET_TYPE_REGKEYVERSION[] =	TEXT("RegKeyVersion");
const TCHAR DET_TYPE_40BITSEC[] =	    TEXT("40BitSec");


void CExpressionParser::vSkipWS(void)
{
	while ( ( *m_pch==' ' ) || ( *m_pch=='\t') )
	{
		m_pch++;
	}
}


bool CExpressionParser::fGetCurToken( PARSE_TOKEN_TYPE & tok,
				  TOKEN_IDENTIFIER *grTokens,
				  int nSize)
{
	bool fError = true;
	int index;

	vSkipWS();

	TCHAR *pchStart = m_pch;

	for ( index = 0; index < nSize; index++ )
	{
		TCHAR *pchTok = grTokens[index].pszTok;
		
		while ( ( *pchTok==*m_pch ) && ( *pchTok!='\0' ) && ( *m_pch!='\0' ) )
		{
			m_pch++;
			pchTok++;
		}

		if ( *pchTok=='\0' )
		{
			// match
			fError = false;
			tok = grTokens[index].tok;
			break;
		}
		else if ( *m_pch == '\0' )
		{
			fError = false;
			tok = TOKEN_DONE;
		}
	}

	if ( (pchStart == m_pch) && (TOKEN_DONE != tok) )
	{
		// we haven't moved at all so this must be a variable.
		fError = false;
		tok = TOKEN_VARIABLE;
	}

//done:
	return fError;
}

bool CExpressionParser::fGetCurTermToken(PARSE_TOKEN_TYPE & tok)
{
	static TOKEN_IDENTIFIER grTermTokens[] = { 
		{TEXT("("), TOKEN_LEFTPAREN},
		{TEXT(")"), TOKEN_RIGHTPAREN},
		{TEXT("!"), TOKEN_NOT}
	};

	bool fError = fGetCurToken(tok, grTermTokens, sizeof(grTermTokens)/sizeof(TOKEN_IDENTIFIER));

	if ( !fError && (TOKEN_DONE == tok) )
	{
		fError = true;
	}

	return fError;
}

bool CExpressionParser::fGetCurExprToken(PARSE_TOKEN_TYPE & tok)
{
	static TOKEN_IDENTIFIER grExprTokens[] = { 
		{TEXT("&&"), TOKEN_AND},
		{TEXT("||"), TOKEN_OR}
	};

	return fGetCurToken(tok, grExprTokens, sizeof(grExprTokens)/sizeof(TOKEN_IDENTIFIER));
}

bool CExpressionParser::fGetVariable(TCHAR *pszVariable)
{
	bool fError = false;
	TCHAR *pchEnd = m_pch;

	while ( _istdigit(*pchEnd) || _istalpha(*pchEnd) )
	{
		pchEnd++;
	}

	if ( pchEnd == m_pch )
	{
		fError = true;
	}
	else
	{
		// pointers in IA64 is 64 bits.  The third argument of this function
		// requires an int (32 bits).  Since the variable name should be always
		// has a length within 32 bits, a static cast should have no problem.
		lstrcpyn(pszVariable, m_pch, (int)(pchEnd - m_pch + 1));
		m_pch = pchEnd;
	}

	return fError;
}

/////////////////////////////////////////////////////////////////////////////
// fGetCifEntry
//   Get an entry from the CIF file.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fGetCifEntry
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if Successfully retrieved CIF file value
//                  FALSE if failed
// Parameter 
//          TCHAR* pszParamName --- [IN] Name of the CIF file
//          TCHAR* pszParamValue --- [OUT] Value of the CIF file
//          DWORD cbParamValue --- size of the pszParamValue in TCHAR
// NOTE: This function calls GetCustomData to retrieve the value of CIF file
//       GetCustomData is defined in inseng.h which takes only ANSI strings.
//       Thus, UNICODE version of this function needed to convert parameters 
//       to and from ANSI compatibles.
//
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unknown (YanL?)
// Modification --- UNICODE and Win64 enabled
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fGetCifEntry(
						 TCHAR *pszParamName,
						 TCHAR *pszParamValue, 
						 DWORD cbParamValue)
// pszParamName is [IN], pszParamValue is [OUT], the function GetCustomData requires
// LPSTR for both parameters, string conversion is necessary in the UNICODE case
{
#ifdef _UNICODE	
	bool fSucceed;
	int nLengthOfpszParamName;
	char *pszParamNameANSI;
	char *pszParamValueANSI;

	nLengthOfpszParamName = lstrlen(pszParamName)+1; // including the NULL character
	//
	// NTBUG9#161019 PREFIX:leaking memory - waltw 8/16/00
	//	Free ANSI buffers before return in all cases via unicodeExit.
	//	Also fixed potentially dangerous conversion of uninitialized [OUT] parameter
	//	and wasteful conversion of [IN] parameter
	//
	pszParamValueANSI = (char *) malloc(cbParamValue*sizeof(char));
	pszParamNameANSI = (char *) malloc(sizeof(char)*nLengthOfpszParamName);
	if ((NULL == pszParamValueANSI) || (NULL == pszParamNameANSI))
	{
		fSucceed = FALSE;
		goto unicodeExit;
	}

	// do UNICODE to ANSI string conversion	
	wcstombs(pszParamNameANSI,pszParamName,nLengthOfpszParamName);
//	wcstombs(pszParamValueANSI,pszParamValue,cbParamValue);	// Uninitialized [OUT] buffer - don't convert!
	// make actual function call
    fSucceed= (ERROR_SUCCESS == m_pDetection->pCifComp->GetCustomData(pszParamNameANSI, 
														pszParamValueANSI, 
														cbParamValue));
	// do ANSI to UNICODE string conversion
//	mbstowcs(pszParamName,pszParamNameANSI,nLengthOfpszParamName); // [IN] param not modified by GetCustomData
	mbstowcs(pszParamValue,pszParamValueANSI,cbParamValue);

unicodeExit:
	if (NULL != pszParamValueANSI)
	{
		free(pszParamValueANSI);
	}

	if (NULL != pszParamNameANSI)
	{
		free(pszParamNameANSI);
	}

	return fSucceed;


#else
	return (ERROR_SUCCESS == m_pDetection->pCifComp->GetCustomData(pszParamName, 
														pszParamValue, 
														cbParamValue));
#endif
}

bool CExpressionParser::fPerformDetection(TCHAR * pszVariable, bool & fResult)
{
	bool fError = false;
	TCHAR szBuf[MAX_PATH];
	TCHAR szDetection[MAX_PATH];
	if ( fGetCifEntry(pszVariable, szBuf, sizeof(szBuf)/sizeof(TCHAR)) )
	{
		if ( GetStringField2(szBuf, 0, szDetection, sizeof(szDetection)/sizeof(TCHAR)) != 0)
		{
			if ( lstrcmpi(szDetection, DET_TYPE_FILEVERSION) == 0 )
			{
				fResult = fDetectFileVer(szBuf);
			}
			else if ( lstrcmpi(szDetection, DET_TYPE_REGKEYEXISTS) == 0 )
			{
				fResult = fDetectRegKeyExists(szBuf);
			}
			else if ( lstrcmpi(szDetection, DET_TYPE_REGKEYSUBSTR) == 0 )
			{
				fResult = fDetectRegSubStr(szBuf);
			}
            else if ( lstrcmpi(szDetection, DET_TYPE_REGKEYBINARY) == 0 )
			{
				fResult = fDetectRegBinary(szBuf);
			}
			else if ( lstrcmpi(szDetection, DET_TYPE_REGKEYVERSION) == 0 )
			{
				fResult = fDetectRegKeyVersion(szBuf);
			}
			else if ( lstrcmpi(szDetection, DET_TYPE_40BITSEC) == 0 )
			{
				fResult = fDetect40BitSecurity(szBuf);
			}
		}
	}

	return fError;
}


bool CExpressionParser::fEvalTerm(bool & fResult, bool fSkip)
{
	PARSE_TOKEN_TYPE tok;

	bool fError = fGetCurTermToken(tok);
	if ( fError ) goto done;

	if ( TOKEN_LEFTPAREN == tok )
	{
		fError = fEvalExpr(fResult);
		if ( fError ) goto done;
		
		fError = fGetCurTermToken(tok);
		if ( fError ) goto done;

		if ( TOKEN_RIGHTPAREN != tok )
		{
			fError = true;
		}
	}
	else if ( TOKEN_NOT == tok )
	{
		fError = fEvalTerm(fResult, false);
		if ( fError ) goto done;

		fResult = !fResult;
	}
	else // TOKEN_VARIABLE == tok
	{
		TCHAR szVariable[MAX_PATH];

		fError = fGetVariable(szVariable);
		if ( fError ) goto done;
		
		if ( !fSkip )
		{
			fError = fPerformDetection(szVariable, fResult);
			if ( fError ) goto done;
		}
	}

done:
	return fError;
}

HRESULT CExpressionParser::fEvalExpression(TCHAR * pszExpr, 
						bool * pfResult)
{
	HRESULT hr = S_OK;
	m_pch = pszExpr;

	if ( fEvalExpr(*pfResult) )
	{
		hr = E_FAIL;
	}

	return hr;
}


bool CExpressionParser::fEvalExpr(bool & fResult)
{
	bool fTmpResult;
	PARSE_TOKEN_TYPE tok;
	bool fError = fEvalTerm(fResult, false);
	if ( fError ) goto done;
	
	while ( TRUE )
	{
		fError = fGetCurExprToken(tok);
		if ( fError ) goto done;

		if ( TOKEN_AND == tok )
		{
			fError = fEvalTerm(fTmpResult, !fResult);
			if ( fError ) goto done;

			if ( fResult )
			{
				fResult = fResult && fTmpResult;
			}
		}
		else if ( TOKEN_OR == tok )
		{
			fError = fEvalTerm(fTmpResult, fResult);
			if ( fError ) goto done;

			if ( !fResult )
			{
				fResult = fResult || fTmpResult;
			}
		}
		else // if ( TOKEN_DONE == tok )
		{
			break;
		}
	}

done:
	return fError;
}

// The codes Under this line is not compiled, so they are not UNICODE ready
#if 0
void Evaluate(TCHAR *pszExpr)
{
	bool fResult;
	HRESULT hr = fEvalExpression(pszExpr, &fResult);

	if ( FAILED(hr) )
		printf("%s == ERROR\n", pszExpr);
	else
		printf("%s == %c\n", pszExpr, fResult ? 'T' : 'F');
}

int main()
{
	Evaluate(TEXT("((T && F)  || !F || T)"));
	Evaluate(TEXT("F || F || (T && T && F)"));
	Evaluate(TEXT("((T && F)  || !F || T)"));
	Evaluate(TEXT(""));
	Evaluate(TEXT("T"));
	Evaluate(TEXT("F||T"));
	Evaluate(TEXT("!F"));

	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\expression.h ===
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
//////////////////////////////////////////////////////////////////////////////

typedef enum _PARSE_TOKEN_TYPE
{
	TOKEN_LEFTPAREN,
	TOKEN_RIGHTPAREN,
	TOKEN_AND,
	TOKEN_OR,
	TOKEN_NOT,
	TOKEN_VARIABLE,
	TOKEN_DONE
} PARSE_TOKEN_TYPE;

typedef struct _TOKEN_IDENTIFIER
{
	TCHAR *pszTok;
	PARSE_TOKEN_TYPE tok;
} TOKEN_IDENTIFIER;

const bool FAILURE_RESULT = false;

class CExpressionParser
{
public:
	typedef enum _enumToken
	{
		// comparison tokens
		COMP_EQUALS,
		COMP_NOT_EQUALS,
		COMP_LESS_THAN,
		COMP_LESS_THAN_EQUALS,
		COMP_GREATER_THAN,
		COMP_GREATER_THAN_EQUALS,
		// directory tokens
		DIR_SYSTEM,
		DIR_WINDOWS
	} enumToken;

	typedef struct _TokenMapping
	{
		const TCHAR * /*const*/ pszToken;
		enumToken enToken;

	} TokenMapping;

    CExpressionParser(DETECTION_STRUCT *pDetection)
        : m_pDetection(pDetection),
		  m_pch(NULL)
    {}

	//
	// Expression parsing methods
	//
    void vSkipWS(void);

    bool fGetCurToken( PARSE_TOKEN_TYPE & tok,
				  TOKEN_IDENTIFIER *grTokens,
				  int nSize);

    bool fGetCurTermToken(PARSE_TOKEN_TYPE & tok);
    bool fGetCurExprToken(PARSE_TOKEN_TYPE & tok);

    bool fGetVariable(TCHAR *pszVariable);

    bool fPerformDetection(TCHAR * pszVariable, bool & fResult);

    bool fEvalTerm(bool & fResult, bool fSkip);

    HRESULT fEvalExpression(TCHAR * pszExpr, bool * pfResult);

    bool fEvalExpr(bool & fResult);

	bool fGetCifEntry(	 TCHAR *pszParamName,
						 TCHAR *pszParamValue, 
						 DWORD cbParamValue);

	//
	// Detection methods
	//
	bool fKeyType(TCHAR *szRootType, HKEY *phKey);
	bool fDetectRegSubStr(TCHAR * pszBuf);
    bool fDetectRegBinary(TCHAR * pszBuf);
	bool fDetectFileVer(TCHAR * pszBuf);
    bool fDetectRegKeyExists(TCHAR * pszBuf);
    bool fDetectRegKeyVersion(TCHAR * pszBuf);
    bool fDetect40BitSecurity(TCHAR * pszBuf);

	bool fMapToken(TCHAR *pszToken,
				   int nSize,
				   TokenMapping grTokenMap[],
				   enumToken *penToken);
	bool fMapRootDirToken(TCHAR *pszRootDirToken, enumToken *penToken);
	bool fMapComparisonToken(TCHAR *pszComparisonToken, 
						     enumToken *penToken);
	bool fCompareVersion(IN  DWORD dwVer1,
					 IN  DWORD dwBuild1,
					 IN  enumToken enComparisonToken,
			         IN  DWORD dwVer2,
					 IN  DWORD dwBuild2);
	DWORD dwParseValue(DWORD iToken, TCHAR * szBuf, TargetRegValue & targetValue);


private:
    TCHAR *m_pch;
	DETECTION_STRUCT *m_pDetection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\detdlls.h ===
//=--------------------------------------------------------------------------=
// DetDLLs.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _DETDLLS_H
#define _DETDLLS_H


//=--------------------------------------------------------------------------=
// Detection DLL 

// CIF file keys
#define DETVERSION_KEY      TEXT("DetectVersion")
#define DETREG_KEY			TEXT("DetRegKey")
#define DETREG_VALUE		TEXT("DetRegValue")
#define DETREG_VERSION		TEXT("DetRegVersion")
#define DETREG_SUBSTR		TEXT("DetRegSubStr")
#define DETREG_BINARY		TEXT("DetRegBinary")
#define DET_EXPRESSION		TEXT("DetExpr")

#define DETFIELD_INSTALLED		TEXT("INSTALLED")
#define DETFIELD_NOT_INSTALLED	TEXT("NOT_INSTALLED")

#endif _DETDLLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\40bitsecurity.cpp ===
#include "wudetect.h"

///////////////////////////////////////////////////////////////////////////////////////////
//
// Function IsThisFileDomesticOnly
//-----------------------------------------------------------------------------------------
//
// Return Value --- TRUE if the specified file is for domestic only
// Parameter
//          LPTSTR lpFileName --- [IN] filename of the file needed to be examined
///////////////////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready, other minor modifications
//
///////////////////////////////////////////////////////////////////////////////////////////
bool IsThisFileDomesticOnly(LPTSTR lpFileName)
{
	// string constants have been modified to lower case only to save run time conversion
     TCHAR    DomesticTag1[] = TEXT(/*"US/Canada Only, Not for Export"*/"us/canada only, not for export");
     TCHAR    DomesticTag2[] = TEXT(/*"Domestic Use Only"*/"domestic use only");
     TCHAR    DomesticTag3[] = TEXT(/*"US and Canada Use Only"*/"us and canada use only");
     TCHAR    Description1[ MAX_PATH ];
     DWORD   DefLang = 0x04b00409;
 
     DWORD   dwLen;
     PVOID   VersionBlock;
     UINT    DataLength;
     DWORD   dwHandle;
     LPTSTR  Description;
     TCHAR    ValueTag[ MAX_PATH ];
     PDWORD  pdwTranslation;
     UINT   uLen;
     bool    fDomestic = false;
 
     if ((dwLen = GetFileVersionInfoSize((LPTSTR)lpFileName, &dwHandle)) != 0 )
     {
         if ((VersionBlock = malloc(dwLen)) != NULL )
         {
             if (GetFileVersionInfo((LPTSTR)lpFileName, dwHandle, dwLen, VersionBlock))
             {
                 if (!VerQueryValue(VersionBlock, TEXT("\\VarFileInfo\\Translation"), (void **)&pdwTranslation, &uLen))
                 {
                     pdwTranslation = &DefLang;
                     uLen = sizeof(DWORD);
                 }
 
                 wsprintf( ValueTag, TEXT("\\StringFileInfo\\%04x%04x\\FileDescription"),
                          LOWORD(*pdwTranslation), HIWORD(*pdwTranslation) );
 
                 if (VerQueryValue( VersionBlock,
                                    ValueTag,
                                    (void **)&Description,
                                    &DataLength))
                 {
                      _tcscpy( Description1, Description );
                     _tcslwr( Description1 );
					 /*
					 // modification made directly to the string to save runtime conversion
                     _tcslwr( DomesticTag1 );
                     _tcslwr( DomesticTag2 );
                     _tcslwr( DomesticTag3 );
					 */
 
                     if (( _tcsstr( Description1, DomesticTag1 )) ||
                         ( _tcsstr( Description1, DomesticTag2 )) ||
                         ( _tcsstr( Description1, DomesticTag3 )))
                     {
                         fDomestic = true;
                     }
                 }
             }
         }
         free(VersionBlock);
         dwHandle = 0L;
     }
 
     return fDomestic;
}

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetect40BitSecurity
//   Detect if 40-bit security is installed.
//
//	 Form: E=40BitSec
// Notes:
//  If any of the following files are 128 bit, you can assume it's a 128bit system:
// 
// (in system32)
// schannel.dll
// security.dll
// ntlmssps.dll
// 
// (in system32\drivers)
// ndiswan.sys
// 
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser (declared in expression.h)
// Function fDetect40BitSecurity
//---------------------------------------------------------------------------
//
// Return Value --- true if the system has 40 bit security 
// Parameter
//          TCHAR* pszBuf --- [IN] ignored
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready, other minor modifications
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fDetect40BitSecurity(TCHAR * pszBuf)
{
	bool fSuccess = true;
    TCHAR szSystemDir[MAX_PATH];
    TCHAR szFilePath[MAX_PATH];
    TCHAR *grFileList[] = {  TEXT("schannel.dll"),
                             TEXT("security.dll"),
                             TEXT("ntlmssps.dll"),
                             TEXT("drivers\\ndiswan.sys") };

    if ( GetSystemDirectory(szSystemDir, sizeof(szSystemDir)/sizeof(TCHAR)) != 0 )
    {
		// check see if the last character in szSystemDir is backslash, which will happen if the 
		// system directory is the root directory
		if (szSystemDir[_tcslen(szSystemDir)-1]!='\\')
			_tcscat(szSystemDir, TEXT("\\"));

        for (   int index = 0;
                fSuccess && (index < (sizeof(grFileList)/sizeof(grFileList[0])));
                index++ )
        {
            _tcscpy(szFilePath, szSystemDir);
            _tcscat(szFilePath, grFileList[index]);
            fSuccess = !IsThisFileDomesticOnly(szFilePath);
        }
    }

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\detection.h ===
/////////////////////////////////////////////////////////////////////////////
// detection.h
//
// Copyright (C) Microsoft Corp. 1998
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
//
// Description:
//   DLL loaded by the install engine that exposes entry points
//   that can determines the installation status of legacy or complex
//   components.  The dll name and entry points are specified for a
//   component in the CIF file.
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

const TCHAR HKEY_LOCAL_MACHINE_ROOT[] =		TEXT("HKLM"); 
const TCHAR HKEY_CURRENT_USER_ROOT[] =		TEXT("HKCU"); 
const TCHAR HKEY_CLASSES_ROOT_ROOT[] =	    TEXT("HKCR"); 
const TCHAR HKEY_CURRENT_CONFIG_ROOT[] =		TEXT("HKCC"); 
const TCHAR HKEY_USERS_ROOT[] =				TEXT("HKUR"); 
const TCHAR HKEY_PERFORMANCE_DATA_ROOT[] =   TEXT("HKPD"); 
const TCHAR HKEY_DYN_DATA_ROOT[] =			TEXT("HKDD");

const TCHAR REG_BINARY_TYPE[] = TEXT("BINARY");
const TCHAR REG_NONE_TYPE[] = TEXT("NONE");
const TCHAR REG_DWORD_TYPE[] = TEXT("DWORD");
const TCHAR REG_SZ_TYPE[] = TEXT("SZ");

const DWORD MAX_VERSION_STRING_LEN = 30;

typedef struct
{
	TCHAR szName[MAX_PATH];
	DWORD type;

	union
	{
		DWORD dw;
		TCHAR sz[MAX_PATH];
	};
} TargetRegValue;

typedef union
{
	DWORD dw;
	TCHAR sz[MAX_PATH];

} ActualKeyValue;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\detection.cpp ===
#include "wudetect.h"


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::dwKeyType
//   
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fKeyType
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if key type match made, FALSE if no match made
// Parameter
//          TCHAR* szRootType --- [IN] string contains the value of key type
//          HKEY* phkey --- [OUT] retrieved key type value
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fKeyType(TCHAR *szRootType, HKEY *phKey)
{
	bool fError = false;
	
	if ( lstrcmpi(HKEY_LOCAL_MACHINE_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_LOCAL_MACHINE; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_USER_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_USER; 
	}
	else if ( lstrcmpi(HKEY_CLASSES_ROOT_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CLASSES_ROOT; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_CONFIG_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_CONFIG; 
	}
	else if ( lstrcmpi(HKEY_USERS_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_USERS; 
	}
	else if ( lstrcmpi(HKEY_PERFORMANCE_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_PERFORMANCE_DATA;
	}
	else if ( lstrcmpi(HKEY_DYN_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_DYN_DATA; 
	}
	else
	{
		fError = true;
	}

	return fError;
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegSubStr
//   Detect a substring in registry datum.
//
//	 Form: E=RegSubstr,<SubStr>,<RootKey>,<KeyPath>,<RegValue>,<RegData>
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// This function is not modifed to be UNICODE ready, since it is not compiled
/////////////////////////////////////////////////////////////////////////////
#if 0
bool CExpressionParser::fDetectRegSubStr(TCHAR * pszBuf)
{

	DWORD dwInstallStatus = DET_NOTINSTALLED;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	char szTargetKeyName[MAX_PATH];
	char szTargetKeyValue[MAX_PATH];
	char szKeyMissingStatus[MAX_PATH];
	char szData[MAX_PATH];
	char szSubStr[MAX_PATH];
	char szBuf[MAX_PATH];
	

	// get the registry key name from the components section of the
	// CIF file.
	if ( FGetCifEntry(pDetection, DETREG_KEY, szBuf, sizeof(szBuf)) &&
		 (dwKeyType(szBuf, &hKeyRoot, szTargetKeyName, sizeof(szTargetKeyName)) == ERROR_SUCCESS) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( FGetCifEntry(pDetection, DETREG_SUBSTR, szBuf, sizeof(szBuf)) &&
	            (GetStringField2(szBuf, 0, szTargetKeyValue, sizeof(szTargetKeyValue)) != 0) &&
	            (GetStringField2(szBuf, 1, szKeyMissingStatus, sizeof(szKeyMissingStatus)) != 0) )
			{
				DWORD size = sizeof(szData);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szData,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						_strlwr(szData);

						// iterate thru the substrings looking for a match.
						int index = 2;
						while ( GetStringField2(szBuf, index, szSubStr, sizeof(szSubStr)) != 0 )
						{
							_strlwr(szSubStr);

							if ( strstr(szData, szSubStr) != NULL )
							{
								*pDetection->pdwInstalledVer = 1; 
								*pDetection->pdwInstalledBuild = 1; 
								dwInstallStatus = DET_INSTALLED;
								goto quit_while;
							}
							index++;
						}
quit_while:;
					}
				}
				else
				{
					// if we get an error, assume the key does not exist.  Note that if
					// the status is DETFIELD_NOT_INSTALLED then we don't have to do 
					// anything since that is the default status.
					if ( lstrcmpi(DETFIELD_INSTALLED, szKeyMissingStatus) == 0 )
					{
						dwInstallStatus = DET_INSTALLED;
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

cleanup:
	return dwInstallStatus;

return false;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapComparisonToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapComparisonToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszComparisonToken --- [IN] the token need to find a match
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fMapComparisonToken(TCHAR *pszComparisonToken, 
											  enumToken *penToken)
{
	static TokenMapping grComparisonTokenMap[] = 
	{
		{TEXT("="),		COMP_EQUALS},
		{TEXT("!="),	COMP_NOT_EQUALS},
		{TEXT("<"),		COMP_LESS_THAN},
		{TEXT("<="),	COMP_LESS_THAN_EQUALS},
		{TEXT(">"),		COMP_GREATER_THAN},
		{TEXT(">="),	COMP_GREATER_THAN_EQUALS}
	};

	return fMapToken(pszComparisonToken,
					 sizeof(grComparisonTokenMap)/sizeof(grComparisonTokenMap[0]),
					 grComparisonTokenMap,
					 penToken);
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapRootDirToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapRootDirToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszRootDirToken --- [IN] the token need to find a match
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fMapRootDirToken(TCHAR *pszRootDirToken, enumToken *penToken)
{
	static TokenMapping grDirectoryTokenMap[] = 
	{
		{TEXT("sysdir"),	DIR_SYSTEM},
		{TEXT("windir"),	DIR_WINDOWS},
	};

	return fMapToken(pszRootDirToken,
					 sizeof(grDirectoryTokenMap)/sizeof(grDirectoryTokenMap[0]),
					 grDirectoryTokenMap,
					 penToken);
}

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszToken --- [IN] the token need to find a match
//          int nSize --- [IN] number of tokens to be matched as the template
//          TokenMapping grTokenMap[] --- [IN] token template to be matched
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////
bool CExpressionParser::fMapToken(TCHAR *pszToken,
								  int nSize,
								  TokenMapping grTokenMap[],
								  enumToken *penToken)
{
	for ( int index = 0; index < nSize; index++ )
	{
		if ( _tcscmp(pszToken, grTokenMap[index].pszToken) == 0 )
		{
			*penToken = grTokenMap[index].enToken;
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectFileVer
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fDetectFileVer
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if version of input files matched the file version in the system, FALSE otherwise
// Parameter
//          TCHAR* pszBuf --- [IN] the name of the input file
//////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////


const DWORD WU_MAX_COMPARISON_LEN = 3;
const DWORD WU_MAX_VERSION_LEN = 30;

bool CExpressionParser::fDetectFileVer(TCHAR * pszBuf)
{
	bool fResult = false;
	TCHAR szRootDir[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	TCHAR szFilePath[MAX_PATH];
	TCHAR szComparison[WU_MAX_COMPARISON_LEN];
	TCHAR szVersion[WU_MAX_VERSION_LEN];
	enumToken enComparisonToken;
	enumToken enRootDirToken;


	// Get reg root type (HKLM, etc)
	if ( (GetStringField2(pszBuf, 1, szRootDir, sizeof(szRootDir)/sizeof(TCHAR)) != 0) &&
		 (GetStringField2(pszBuf, 2, szFile, sizeof(szFile)/sizeof(TCHAR)) != 0) &&
		 fMapRootDirToken(szRootDir, &enRootDirToken) )
	{
		// create the file path
		if ( enRootDirToken == DIR_SYSTEM )
		{
			if ( GetSystemDirectory(szFilePath, sizeof(szFilePath)/sizeof(TCHAR)) == 0 )
				return false;
		}
		else // DIR_WINDOWS
		{
			if ( GetWindowsDirectory(szFilePath, sizeof(szFilePath)/sizeof(TCHAR)) == 0 )
				return false;
		}

		if (szFilePath[_tcslen(szFilePath)-1]!='\\') _tcscat(szFilePath, TEXT("\\"));
		_tcscat(szFilePath, szFile);
		
		if ( (GetStringField2(pszBuf, 3, szComparison, sizeof(szComparison)/sizeof(TCHAR)) != 0) &&
			 fMapComparisonToken(szComparison, &enComparisonToken) )
		{
			DWORD dwSize;
			DWORD dwReserved;
			DWORD dwVer, dwBuild;
			VS_FIXEDFILEINFO    *pVerInfo;
			UINT                uLen;
			

			dwSize = GetFileVersionInfoSize(szFilePath, &dwReserved);

			if ( dwSize > 0)
			{
				TCHAR *pbVerInfo = (TCHAR *)malloc(dwSize);

				if ( GetFileVersionInfo(szFilePath, dwReserved, dwSize, pbVerInfo) &&
					 (VerQueryValue(pbVerInfo, TEXT("\\"), (void **)&pVerInfo, &uLen) != 0) )
				{
					for ( int index = 4; 
						  !fResult && (GetStringField2(pszBuf, index, szVersion, sizeof(szVersion)/sizeof(TCHAR)) != 0); 
						  index++ )
					{
						fConvertDotVersionStrToDwords(szVersion, &dwVer, &dwBuild);

						fResult = fCompareVersion(pVerInfo->dwProductVersionMS,
												  pVerInfo->dwProductVersionLS,
												  enComparisonToken,
												  dwVer,
												  dwBuild);
					}
				}
				free(pbVerInfo);
			}
		}
		else
			// just a file existence check.
			fResult = (_taccess(szFilePath, 00) != -1);
	}

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\filever.cpp ===
#include "wudetect.h"
/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::dwKeyType
//   
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fKeyType
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if key type match made, FALSE if no match made
// Parameter
//          TCHAR* szRootType --- [IN] string contains the value of key type
//          HKEY* phkey --- [OUT] retrieved key type value
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fKeyType(TCHAR *szRootType, HKEY *phKey)
{
	bool fError = false;
	
	if ( lstrcmpi(HKEY_LOCAL_MACHINE_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_LOCAL_MACHINE; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_USER_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_USER; 
	}
	else if ( lstrcmpi(HKEY_CLASSES_ROOT_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CLASSES_ROOT; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_CONFIG_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_CONFIG; 
	}
	else if ( lstrcmpi(HKEY_USERS_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_USERS; 
	}
	else if ( lstrcmpi(HKEY_PERFORMANCE_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_PERFORMANCE_DATA;
	}
	else if ( lstrcmpi(HKEY_DYN_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_DYN_DATA; 
	}
	else
	{
		fError = true;
	}

	return fError;
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegSubStr
//   Detect a substring in registry datum.
//
//	 Form: E=RegSubstr,<SubStr>,<RootKey>,<KeyPath>,<RegValue>,<RegData>
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// This function is not modifed to be UNICODE ready, since it is not compiled
/////////////////////////////////////////////////////////////////////////////
#if 0
bool CExpressionParser::fDetectRegSubStr(TCHAR * pszBuf)
{

	DWORD dwInstallStatus = DET_NOTINSTALLED;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	char szTargetKeyName[MAX_PATH];
	char szTargetKeyValue[MAX_PATH];
	char szKeyMissingStatus[MAX_PATH];
	char szData[MAX_PATH];
	char szSubStr[MAX_PATH];
	char szBuf[MAX_PATH];
	

	// get the registry key name from the components section of the
	// CIF file.
	if ( FGetCifEntry(pDetection, DETREG_KEY, szBuf, sizeof(szBuf)) &&
		 (dwKeyType(szBuf, &hKeyRoot, szTargetKeyName, sizeof(szTargetKeyName)) == ERROR_SUCCESS) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( FGetCifEntry(pDetection, DETREG_SUBSTR, szBuf, sizeof(szBuf)) &&
	            (GetStringField2(szBuf, 0, szTargetKeyValue, sizeof(szTargetKeyValue)) != 0) &&
	            (GetStringField2(szBuf, 1, szKeyMissingStatus, sizeof(szKeyMissingStatus)) != 0) )
			{
				DWORD size = sizeof(szData);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szData,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						_strlwr(szData);

						// iterate thru the substrings looking for a match.
						int index = 2;
						while ( GetStringField2(szBuf, index, szSubStr, sizeof(szSubStr)) != 0 )
						{
							_strlwr(szSubStr);

							if ( strstr(szData, szSubStr) != NULL )
							{
								*pDetection->pdwInstalledVer = 1; 
								*pDetection->pdwInstalledBuild = 1; 
								dwInstallStatus = DET_INSTALLED;
								goto quit_while;
							}
							index++;
						}
quit_while:;
					}
				}
				else
				{
					// if we get an error, assume the key does not exist.  Note that if
					// the status is DETFIELD_NOT_INSTALLED then we don't have to do 
					// anything since that is the default status.
					if ( lstrcmpi(DETFIELD_INSTALLED, szKeyMissingStatus) == 0 )
					{
						dwInstallStatus = DET_INSTALLED;
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

cleanup:
	return dwInstallStatus;
return false;
}
#endif
/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapComparisonToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapComparisonToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszComparisonToken --- [IN] the token need to find a match
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fMapComparisonToken(TCHAR *pszComparisonToken, 
											  enumToken *penToken)
{
	static TokenMapping grComparisonTokenMap[] = 
	{
		{TEXT("="),		COMP_EQUALS},
		{TEXT("!="),	COMP_NOT_EQUALS},
		{TEXT("<"),		COMP_LESS_THAN},
		{TEXT("<="),	COMP_LESS_THAN_EQUALS},
		{TEXT(">"),		COMP_GREATER_THAN},
		{TEXT(">="),	COMP_GREATER_THAN_EQUALS}
	};

	return fMapToken(pszComparisonToken,
					 sizeof(grComparisonTokenMap)/sizeof(grComparisonTokenMap[0]),
					 grComparisonTokenMap,
					 penToken);
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapRootDirToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapRootDirToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszRootDirToken --- [IN] the token need to find a match
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fMapRootDirToken(TCHAR *pszRootDirToken, enumToken *penToken)
{
	static TokenMapping grDirectoryTokenMap[] = 
	{
		{TEXT("sysdir"),	DIR_SYSTEM},
		{TEXT("windir"),	DIR_WINDOWS},
	};

	return fMapToken(pszRootDirToken,
					 sizeof(grDirectoryTokenMap)/sizeof(grDirectoryTokenMap[0]),
					 grDirectoryTokenMap,
					 penToken);
}

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fMapToken
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fMapToken
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if a matching is found, FALSE otherwise
// Parameter 
//          TCHAR* pszToken --- [IN] the token need to find a match
//          int nSize --- [IN] number of tokens to be matched as the template
//          TokenMapping grTokenMap[] --- [IN] token template to be matched
//          enumToken* penToken --- [OUT] token enum value found, if no token found, the value is undetermined
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////
bool CExpressionParser::fMapToken(TCHAR *pszToken,
								  int nSize,
								  TokenMapping grTokenMap[],
								  enumToken *penToken)
{
	for ( int index = 0; index < nSize; index++ )
	{
		if ( _tcscmp(pszToken, grTokenMap[index].pszToken) == 0 )
		{
			*penToken = grTokenMap[index].enToken;
			return true;
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectFileVer
//   Detect file version.
//
//	 Form: _E1=FileVer,sysdir,ntdll.dll,=,4.06.00.0407,4.06.00.0407
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fDetectFileVer
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if version of input files matched the file version in the system, FALSE otherwise
// Parameter
//          TCHAR* pszBuf --- [IN] the name of the input file
//////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unkown
// Modification --- UNICODE and Win64 ready
//
/////////////////////////////////////////////////////////////////////////////


const DWORD WU_MAX_COMPARISON_LEN = 3;
const DWORD WU_MAX_VERSION_LEN = 30;

bool CExpressionParser::fDetectFileVer(TCHAR * pszBuf)
{
	bool fResult = false;
	TCHAR szRootDir[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	TCHAR szFilePath[MAX_PATH];
	TCHAR szComparison[WU_MAX_COMPARISON_LEN];
	TCHAR szVersion[WU_MAX_VERSION_LEN];
	enumToken enComparisonToken;
	enumToken enRootDirToken;


	// Get reg root type (HKLM, etc)
	if ( (GetStringField2(pszBuf, 1, szRootDir, sizeof(szRootDir)/sizeof(TCHAR)) != 0) &&
		 (GetStringField2(pszBuf, 2, szFile, sizeof(szFile)/sizeof(TCHAR)) != 0) &&
		 fMapRootDirToken(szRootDir, &enRootDirToken) )
	{
		// create the file path
		if ( enRootDirToken == DIR_SYSTEM )
		{
			if ( GetSystemDirectory(szFilePath, sizeof(szFilePath)/sizeof(TCHAR)) == 0 )
				return false;
		}
		else // DIR_WINDOWS
		{
			if ( GetWindowsDirectory(szFilePath, sizeof(szFilePath)/sizeof(TCHAR)) == 0 )
				return false;
		}

		if (szFilePath[_tcslen(szFilePath)-1]!='\\') _tcscat(szFilePath, TEXT("\\"));
		_tcscat(szFilePath, szFile);
		
		if ( (GetStringField2(pszBuf, 3, szComparison, sizeof(szComparison)/sizeof(TCHAR)) != 0) &&
			 fMapComparisonToken(szComparison, &enComparisonToken) )
		{
			DWORD dwSize;
			DWORD dwReserved;
			DWORD dwVer, dwBuild;
			VS_FIXEDFILEINFO    *pVerInfo;
			UINT                uLen;
			

			dwSize = GetFileVersionInfoSize(szFilePath, &dwReserved);

			if ( dwSize > 0)
			{
				TCHAR *pbVerInfo = (TCHAR *)malloc(dwSize);

				if ( GetFileVersionInfo(szFilePath, dwReserved, dwSize, pbVerInfo) &&
					 (VerQueryValue(pbVerInfo, TEXT("\\"), (void **)&pVerInfo, &uLen) != 0) )
				{
					for ( int index = 4; 
						  !fResult && (GetStringField2(pszBuf, index, szVersion, sizeof(szVersion)/sizeof(TCHAR)) != 0); 
						  index++ )
					{
						fConvertDotVersionStrToDwords(szVersion, &dwVer, &dwBuild);

						// do version comparison
						switch ( enComparisonToken )
						{
						case COMP_EQUALS:
							fResult = (pVerInfo->dwProductVersionMS == dwVer) &&
									  (pVerInfo->dwProductVersionLS == dwBuild);
							break;
						case COMP_NOT_EQUALS:
							fResult = (pVerInfo->dwProductVersionMS != dwVer) ||
									  (pVerInfo->dwProductVersionLS != dwBuild);
							break;
						case COMP_LESS_THAN:
							fResult = (pVerInfo->dwProductVersionMS < dwVer) ||
									  ((pVerInfo->dwProductVersionMS == dwVer) &&
									   (pVerInfo->dwProductVersionLS < dwBuild));
							break;
						case COMP_LESS_THAN_EQUALS:
							fResult = (pVerInfo->dwProductVersionMS < dwVer) ||
									  ((pVerInfo->dwProductVersionMS == dwVer) &&
									   (pVerInfo->dwProductVersionLS <= dwBuild));
							break;
						case COMP_GREATER_THAN:
							fResult = (pVerInfo->dwProductVersionMS > dwVer) ||
									  ((pVerInfo->dwProductVersionMS == dwVer) &&
									   (pVerInfo->dwProductVersionLS > dwBuild));
							break;
						case COMP_GREATER_THAN_EQUALS:
							fResult = (pVerInfo->dwProductVersionMS > dwVer) ||
									  ((pVerInfo->dwProductVersionMS == dwVer) &&
									   (pVerInfo->dwProductVersionLS >= dwBuild));
							break;
						}
					}
				}
				free(pbVerInfo);
			}
		}
		else
		{
			// just a file existence check.
			fResult = (_taccess(szFilePath, 0) != -1);
		}
	}

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\regkeyexists.cpp ===
#include "wudetect.h"

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegKeyExists
//   Detect a substring in registry datum.
//
//	 Form: E=RegKeyExists,<root registry key>, <relative registry path>,[<value name>, [<data type>[, data]]]RegSubstr,<SubStr>,<RootKey>,<KeyPath>,<RegValue>,<RegData>
/////////////////////////////////////////////////////////////////////////////

const DWORD WU_MAX_COMPARISON_LEN = 3;
const DWORD WU_MAX_VERSION_LEN = 30;

bool CExpressionParser::fDetectRegKeyExists(TCHAR * pszBuf)
{
	bool fSuccess = false;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szRegRoot[MAX_PATH];
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	TCHAR szBuf[MAX_PATH];
	DWORD dwStatus;
	DWORD iToken = 0;

	// Get reg root type (HKLM, etc)
	if ( fMapRegRoot(pszBuf, ++iToken, &hKeyRoot) &&
		 (GetStringField2(pszBuf, ++iToken, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) != 0) )
	{
	   // see if the reg key is there.
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( GetStringField2(pszBuf, ++iToken, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0 )
			{
				TargetRegValue targetValue;
				

				dwStatus = dwParseValue(iToken, pszBuf, targetValue);

				if ( dwStatus == ERROR_SUCCESS )
				{
    				ActualKeyValue keyvalue;
					DWORD size = sizeof(keyvalue);

					if ( RegQueryValueEx(hKey,
										   targetValue.szName,
										   0,
										   &type,
										   (BYTE *)&keyvalue,
										   &size) == ERROR_SUCCESS )
					{
						switch ( targetValue.type )
						{
						case REG_NONE:
							{
								fSuccess = true;
								break;
							}
						case REG_DWORD:
							{
								if ( (type == REG_DWORD) || 
									 ((type == REG_BINARY) && (size >= sizeof(DWORD))) )
								{
									// see if we have a match
									if ( targetValue.dw == keyvalue.dw )
									{
										fSuccess = true;
									}
								}
								break;
							}
						case REG_SZ:
							{
								if ( type == REG_SZ )
								{
								   if ( lstrcmpi(targetValue.sz, keyvalue.sz) == 0 )
								   {
										fSuccess = true;
								   }
								}
								break;
							}
						} // switch
					}
				}
			}
			else
			{
				// no REG value so, REGPATH is sufficient to determine
				// installation.
				fSuccess = true;
			}
			RegCloseKey(hKey);
	   }
   }

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\regkeyversion.cpp ===
#include "wudetect.h"

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegKeyVersion
//   Detect a substring in registry datum.
//
//	 Form: E=RegKeyVersion,<root registry key>,<relative registry path>,<value name>,<comparison type>,[version]
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fDetectRegKeyVersion(TCHAR * pszBuf)
{
	bool fSuccess = false;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	//TCHAR szVersion[MAX_VERSION_STRING_LEN];
	TCHAR szBuf[MAX_PATH];
	//TCHAR szCompToken[MAX_PATH];
	//DWORD dwStatus;
	//DWORD dwLen;
	DWORD dwVer;
	DWORD dwBuild;
	DWORD iToken = 0;
	
	// Get reg root type (HKLM, etc)
	if ( fMapRegRoot(pszBuf, ++iToken, &hKeyRoot) &&
		 (GetStringField2(pszBuf, ++iToken, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) != 0) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
	        if ( GetStringField2(pszBuf, ++iToken, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0 )
			{
				DWORD size = sizeof(szBuf);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szBuf,
									   &size) == ERROR_SUCCESS )
				{
					enumToken enComparisonToken;

					if ( (type == REG_SZ) &&
						 fConvertDotVersionStrToDwords(szBuf, &dwVer, &dwBuild) &&
				         (GetStringField2(pszBuf, ++iToken, szBuf, sizeof(szBuf)/sizeof(TCHAR)) != 0) &&
						 // look at the type of the comparison
						 fMapComparisonToken(szBuf, &enComparisonToken) )
					{
						DWORD dwAskVer = m_pDetection->dwAskVer;
						DWORD dwAskBuild = m_pDetection->dwAskBuild;

						// now, the version can be either stated explicitely or come from 
						// the version key in the cif file.
				        if ( GetStringField2(pszBuf, ++iToken, szBuf, sizeof(szBuf)/sizeof(TCHAR)) != 0 )
						{
							fConvertDotVersionStrToDwords(szBuf, &dwAskVer, &dwAskBuild);
						}

						if ( fCompareVersion(dwVer, dwBuild, enComparisonToken, dwAskVer, dwAskBuild) )
						{
							fSuccess = true;
						}
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

//cleanup:
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\utils2.cpp ===
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

//#include <windows.h>
//#include <objbase.h>

//#include <inseng.h>
//#include "utils2.h"

#include "wudetect.h"

/////////////////////////////////////////////////////////////////////////////
// dwParseValue
//
//   Parses out the registry key name, value, and type that needs to
//   be opened to determine the installation status of the component.
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function dwParseValue
//---------------------------------------------------------------------------
//
// Return Value --- DWORD, if the function succeeded, return ERROR_SUCCESS
//                         if the function failed, return ERROR_BADKEY
// Parameters
//           DWORD iToken --- [IN] Index Number of Field to looking for
//           TCHAR* szBuf --- [IN] String to search for
//           TargetRegValue& targerValue --- [OUT] two (three) fields will be set if function succeeded,
//               szName field will be set to the Name in the String token
//               szType field will be set to either REG_DWORD, REG_SZ_TYPE or REG_BINARY_TYPE depends on the String Token
//               if szType is REG_DWORD, the dw field will be set to the value depends on the String
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
//////////////////////////////////////////////////////////////////////////////////////////////////                                  
DWORD CExpressionParser::dwParseValue(DWORD iToken, TCHAR * szBuf, TargetRegValue & targetValue)
{
	DWORD dwStatus = ERROR_BADKEY;
	TCHAR szType[MAX_PATH]; // BUGBUG - get real value
	TCHAR szValue[MAX_PATH]; // BUGBUG - get real value

	// get the data type
	if ( (GetStringField2(szBuf, iToken, targetValue.szName, sizeof(targetValue.szName)/sizeof(TCHAR)) != 0) &&
		 (GetStringField2(szBuf, ++iToken, szType, sizeof(szType)/sizeof(TCHAR)) != 0) )
	{
		if ( lstrcmpi(REG_NONE_TYPE, szType) == 0 )
		{
			targetValue.type = REG_NONE; 
			dwStatus = ERROR_SUCCESS;
		}
		else 
		{
			if ( GetStringField2(szBuf, ++iToken, szValue, sizeof(szValue)/sizeof(TCHAR)) != 0 )
			{
				if ( lstrcmpi(REG_DWORD_TYPE, szType) == 0 )
				{
					targetValue.type = REG_DWORD; 
					targetValue.dw = _ttol(szValue);
					dwStatus = ERROR_SUCCESS;
				}
				else if ( lstrcmpi(REG_SZ_TYPE, szType) == 0 )
				{
					targetValue.type = REG_SZ; 
					lstrcpy(targetValue.sz, szValue);
					dwStatus = ERROR_SUCCESS;
				}
				else if ( lstrcmpi(REG_BINARY_TYPE, szType) == 0 )
				{
					targetValue.type = REG_BINARY; 
					lstrcpy(targetValue.sz, szValue);
					dwStatus = ERROR_SUCCESS;
				}
			}
		}
	}

	return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////
// fCompareVersion
/////////////////////////////////////////////////////////////////////////////
//
// Class CExpressionParser
// Function fCompareVersion
//--------------------------------------------------------------------------
// Return Value --- TRUE if value equals, FALSE if value does not equal or 
//                  no Comparison type specified exist
// Parameter
//          DWORD dwVer1 --- [IN] version number of first value
//          DWORD dwBuild1 --- [IN] build number of first value
//          enumToken enComparisonToken --- [IN] reason to compare
//          DWORD dwVer2 --- [IN] version number of second value
//          DWORD dwBuild2 --- [IN] build number of second value
/////////////////////////////////////////////////////////////////////////////
//
// Original Creator Unknown
// No modification made at 03/08/00 by RogerJ
//
////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fCompareVersion(IN  DWORD dwVer1,
					 IN  DWORD dwBuild1,
					 IN  enumToken enComparisonToken,
			         IN  DWORD dwVer2,
					 IN  DWORD dwBuild2)
{				   
	bool fResult = false;

	switch ( enComparisonToken )
	{
	case COMP_EQUALS:
		fResult = (dwVer1 == dwVer2) && (dwBuild1 == dwBuild2);
		break;
	case COMP_NOT_EQUALS:
		fResult = (dwVer1 != dwVer2) ||	(dwBuild1 != dwBuild2);
		break;
	case COMP_LESS_THAN:
		fResult = (dwVer1 < dwVer2) || ((dwVer1 == dwVer2) && (dwBuild1 < dwBuild2));
		break;
	case COMP_LESS_THAN_EQUALS:
		fResult = (dwVer1 < dwVer2) || ((dwVer1 == dwVer2) && (dwBuild1 <= dwBuild2));
		break;
	case COMP_GREATER_THAN:
		fResult = (dwVer1 > dwVer2) || ((dwVer1 == dwVer2) && (dwBuild1 > dwBuild2));
		break;
	case COMP_GREATER_THAN_EQUALS:
		fResult = (dwVer1 > dwVer2) || ((dwVer1 == dwVer2) && (dwBuild1 >= dwBuild2));
		break;
	}

	return fResult;
}

/////////////////////////////////////////////////////////////////////////////
// fMapRegRoot
//   Determines the registry root (HKLM, HKCU, etc) that the key lies under.
/////////////////////////////////////////////////////////////////////////////
//
// Function fMapRegRoot
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if function succeeded, FALSE if can't find correct registry root 
// Parameter
//          TCHAR* pszBuf --- [IN] String to search for
//          DWORD index --- [IN] Index Number of Field to looking for
//          HKEY* phKey --- [OUT] key value found
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unkown
// Modification made --- UNICODE and Win64 Ready
//
/////////////////////////////////////////////////////////////////////////////

bool fMapRegRoot(TCHAR *pszBuf, DWORD index, HKEY *phKey)
{
	TCHAR szRootType[MAX_PATH];


	if ( GetStringField2(pszBuf, (UINT)index, szRootType, sizeof(szRootType)/sizeof(TCHAR)) == 0 )
		return false;

	if ( lstrcmpi(HKEY_LOCAL_MACHINE_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_LOCAL_MACHINE; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_USER_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_USER; 
	}
	else if ( lstrcmpi(HKEY_CLASSES_ROOT_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CLASSES_ROOT; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_CONFIG_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_CONFIG; 
	}
	else if ( lstrcmpi(HKEY_USERS_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_USERS; 
	}
	else if ( lstrcmpi(HKEY_PERFORMANCE_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_PERFORMANCE_DATA;
	}
	else if ( lstrcmpi(HKEY_DYN_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_DYN_DATA; 
	}
	else return false;


	return true;
}

//--------------------------------------------------------------------------
// GetStringField2
//--------------------------------------------------------------------------
//
// Function GetStringField2
//--------------------------------------------------------------------------
//
// Return Value: DWORD, the number of TCHAR copied, not including the NULL character
// Parameters:
//               LPTSTR szStr --- [IN] String to search for
//               UINT uField --- [IN] Index Number of Field to looking for
//               LPTSTR szBuf --- [IN,OUT] String buffer to copy to
//               UINT cBufSize --- [IN] Size of szBuf in TCHAR
//////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification made --- UNICODE and Win64 Compatbility
//
//////////////////////////////////////////////////////////////////////////////

#define WHITESPACE TEXT(" \t")

DWORD GetStringField2(LPTSTR szStr, UINT uField, LPTSTR szBuf, UINT cBufSize)
{
   LPTSTR pszBegin = szStr;
   LPTSTR pszEnd;
   UINT i;
   DWORD dwToCopy;

   if ( (cBufSize == 0) || (szStr == NULL) || (szBuf == NULL) )
   {
       return 0;
   }

   szBuf[0] = '\0';

   // look for fields based on commas but handle quotes.
   // check the ith Field, each field separated by either quote or comma
   for (i = 0 ;i < uField; i++ )
   {
		// skip spaces
	   pszBegin += _tcsspn(pszBegin, WHITESPACE);
	
	   // handle quotes
	   if ( *pszBegin == '"' )
	   {
		   pszBegin = _tcschr(++pszBegin, '"');

		   if ( pszBegin == NULL )
		   {
			   return 0; // invalid string
		   }
			pszBegin++; // skip trailing quote
			// find start of next string
	   	    pszBegin += _tcsspn(pszBegin, WHITESPACE);
			if ( *pszBegin != ',' )
			{
				return 0;
			}
	   }
	   else
	   {
		   pszBegin = _tcschr(++pszBegin, ',');
		   if ( pszBegin == NULL )
		   {
			   return 0; // field isn't here
		   }
	   }
	   pszBegin++;
   }


	// pszBegin points to the start of the desired string.
	// skip spaces
	pszBegin += _tcsspn(pszBegin, WHITESPACE);
	
   // handle quotes
   if ( *pszBegin == '"' )
   {
	   pszEnd = _tcschr(++pszBegin, '"');

	   if ( pszEnd == NULL )
	   {
		   return 0; // invalid string
	   }
   }
   else
   {
	   pszEnd = pszBegin + 1 + _tcscspn(pszBegin + 1, TEXT(","));
	   while ( (pszEnd > pszBegin) && 
			   ((*(pszEnd - 1) == ' ') || (*(pszEnd - 1) == '\t')) )
	   {
		   pszEnd--;
	   }
   }

   // length of buffer to copy should never exceed 32 bits.
   dwToCopy = (DWORD)(pszEnd - pszBegin + 1);
   
   if ( dwToCopy > cBufSize )
   {
      dwToCopy = cBufSize;
   }

   lstrcpyn(szBuf, pszBegin, dwToCopy);
   
   return dwToCopy - 1;
}



//--------------------------------------------------------------------------
// GetIntField
//--------------------------------------------------------------------------
//
// Function GetIntField 
//--------------------------------------------------------------------------
//
// Return Value: DWORD, Integer value of wanted field
// Parameters:
//             LPTSTR szStr --- [IN] String to search for
//             UINT uField --- [IN] Index Number of Field to looking for
//             DWORD dwDefault --- [IN] default value 
////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification made --- UNICODE and Win64 compatibility
// NOTE --- NOT used in current version
//
////////////////////////////////////////////////////////////////////////////
#if 0 // not used yet

DWORD GetIntField(LPTSTR szStr, UINT uField, DWORD dwDefault)
{
   TCHAR szNumBuf[16];

   if(GetStringField(szStr, uField, szNumBuf, sizeof(szNumBuf)/sizeof(TCHAR)) == 0)
      return dwDefault;
   else
      return _ttol(szNumBuf);
}
#endif 

//--------------------------------------------------------------------------
// ConvertVersionStrToDwords
//--------------------------------------------------------------------------
// 
// Function ConvertVersionStrToDwords
//--------------------------------------------------------------------------
//
// Return Value --- no return value
// Parameter
//          LPTSTR pszVer --- [IN] input string containing the version and build information
//          LPDWORD pdwVer --- [OUT] the version value extracted from pszVer
//          LPDWORD pdwBuild --- [OUT] the build value extracted from pszVer
////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
// NOTE --- NOT used in current version
//
////////////////////////////////////////////////////////////////////////////
#if 0 // not used yet

void ConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
   DWORD dwTemp1,dwTemp2;

   dwTemp1 = GetIntField(pszVer, 0, 0);
   dwTemp2 = GetIntField(pszVer, 1, 0);

   *pdwVer = (dwTemp1 << 16) + dwTemp2;

   dwTemp1 = GetIntField(pszVer, 2, 0);
   dwTemp2 = GetIntField(pszVer, 3, 0);

   *pdwBuild = (dwTemp1 << 16) + dwTemp2;
}
#endif 

//--------------------------------------------------------------------------
// ConvertDotVersionStrToDwords
//--------------------------------------------------------------------------
//
// Function fConvertDotVersionStrToDwords
//--------------------------------------------------------------------------
//
// Return Value --- always true
// Parameter
//          LPTSTR pszVer --- [IN] input version string, should have the format
//                            of x.x.x.x
//          LPDWORD pdwVer --- [OUT] version number extracted from pszVer
//          LPDWORD pdwBuild --- [OUT] build number extracted from pszVer
//
////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
////////////////////////////////////////////////////////////////////////////
bool fConvertDotVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
	DWORD grVerFields[4] = {0,0,0,0};
    TCHAR *pch = pszVer;

	grVerFields[0] = _ttol(pch);

	for ( int index = 1; index < 4; index++ )
	{
		while ( IsDigit(*pch) && (*pch != '\0') )
			pch++;

		if ( *pch == '\0' )
			break;
		pch++;
	
		grVerFields[index] = _ttol(pch);
   }

   *pdwVer = (grVerFields[0] << 16) + grVerFields[1];
   *pdwBuild = (grVerFields[2] << 16) + grVerFields[3];

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\wudetect.cpp ===
/////////////////////////////////////////////////////////////////////////////
// WUDetect.cpp
//
// Copyright (C) Microsoft Corp. 1998
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
//
// Description:
//   DLL loaded by the install engine that exposes entry points
//   that can determines the installation status of legacy or complex
//   components.  The dll name and entry points are specified for a
//   component in the CIF file.
/////////////////////////////////////////////////////////////////////////////

#include "wudetect.h"
//#include <stdio.h>
//#include <tTCHAR.h>

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

//#include <windows.h>
//#include <objbase.h>

//#include <inseng.h>
//#include <detdlls.h>
//#include <utils2.h>


/////////////////////////////////////////////////////////////////////////////
// dwKeyType
//   Determines the registry root (HKLM, HKCU, etc) that the key lies under.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

inline DWORD dwKeyType(TCHAR *szBuf, HKEY *phKey, TCHAR * szKeyName, DWORD dwSize)
{
	DWORD dwStatus = ERROR_SUCCESS;
	TCHAR szRootType[MAX_PATH];

	if ( (GetStringField2(szBuf, 0, szRootType, sizeof(szRootType)/sizeof(TCHAR)) == 0) ||
	     (GetStringField2(szBuf, 1, szKeyName, dwSize) == 0) )
	{
		dwStatus = ERROR_BADKEY;
	}
	else if ( lstrcmpi(HKEY_LOCAL_MACHINE_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_LOCAL_MACHINE; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_USER_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_USER; 
	}
	else if ( lstrcmpi(HKEY_CLASSES_ROOT_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CLASSES_ROOT; 
	}
	else if ( lstrcmpi(HKEY_CURRENT_CONFIG_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_CURRENT_CONFIG; 
	}
	else if ( lstrcmpi(HKEY_USERS_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_USERS; 
	}
	else if ( lstrcmpi(HKEY_PERFORMANCE_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_PERFORMANCE_DATA;
	}
	else if ( lstrcmpi(HKEY_DYN_DATA_ROOT, szRootType) == 0 )
	{
		*phKey = HKEY_DYN_DATA; 
	}
	else
	{
		dwStatus = ERROR_BADKEY;
	}

	return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////
// dwParseValue
//
//   Parses out the registry key name, value, and type that needs to
//   be opened to determine the installation status of the component.
/////////////////////////////////////////////////////////////////////////////

inline DWORD dwParseValue(TCHAR * szBuf, TargetRegValue & targetValue)
{
	DWORD dwStatus = ERROR_BADKEY;
	TCHAR szType[MAX_PATH]; // BUGBUG - get real value
	TCHAR szValue[MAX_PATH]; // BUGBUG - get real value

	// get the data type
	if ( (GetStringField2(szBuf, 0, targetValue.szName, sizeof(targetValue.szName)/sizeof(TCHAR)) != 0) &&
		 (GetStringField2(szBuf, 1, szType, sizeof(szType)/sizeof(TCHAR)) != 0) )
	{
		if ( lstrcmpi(REG_NONE_TYPE, szType) == 0 )
		{
			targetValue.type = REG_NONE; 
			dwStatus = ERROR_SUCCESS;
		}
		else 
		{
			if ( GetStringField2(szBuf, 2, szValue, sizeof(szValue)/sizeof(TCHAR)) != 0 )
			{
				if ( lstrcmpi(REG_DWORD_TYPE, szType) == 0 )
				{
					targetValue.type = REG_DWORD; 
					targetValue.dw = _ttol(szValue);
					dwStatus = ERROR_SUCCESS;
				}
				else if ( lstrcmpi(REG_SZ_TYPE, szType) == 0 )
				{
					targetValue.type = REG_SZ; 
					lstrcpy(targetValue.sz, szValue);
					dwStatus = ERROR_SUCCESS;
				}
			}
		}
	}

	return dwStatus;
}

/////////////////////////////////////////////////////////////////////////////
// fCompareVersion
//
// Returns: 1,0,-1 depending on whether dwVersion1 is greater than, equal, or
// less than dwVersion2.
/////////////////////////////////////////////////////////////////////////////

inline int nCompareVersion(IN  DWORD dwVer1,
						   IN  DWORD dwBuild1,
			               IN  DWORD dwVer2,
						   IN  DWORD dwBuild2)
{
	int nResult = 0;

	if ( dwVer1 > dwVer2 )
	{
		nResult = 1;
	}
	else if ( dwVer1 < dwVer2 )
	{
		nResult = -1;
	}
	else if ( dwBuild1 > dwBuild2 ) // dwVer1 == dwVer2
	{
		nResult = 1;
	}
	else if ( dwBuild1 < dwBuild2 ) // dwVer1 == dwVer2
	{
		nResult = -1;
	}

	return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// GetCifEntry
//   Get an entry from the CIF file.
//
// Comments :
//   We get the value differently depending on whether we are being
//   called by IE 4 or IE 5 Active Setup.
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Function FGetCifEntry
//---------------------------------------------------------------------------
//
// Return Value --- TRUE if Successfully retrieved CIF file value
//                  FALSE if failed
// Parameter 
//          TCHAR* pszParamName --- [IN] Name of the CIF file
//          TCHAR* pszParamValue --- [OUT] Value of the CIF file
//          DWORD cbParamValue --- size of the pszParamValue in TCHAR
// NOTE: This function calls GetCustomData to retrieve the value of CIF file
//       GetCustomData is defined in inseng.h which takes only ANSI strings.
//       Thus, UNICODE version of this function needed to convert parameters 
//       to and from ANSI compatibles.
// NOTE: This is a global function. Don't mixed with member function of 
//       CExpressionParser::fGetCifEntry
//
/////////////////////////////////////////////////////////////////////////////
//
// Modified by RogerJ, 03/09/00
// Original Creator Unknown (YanL?)
// Modification --- UNICODE and Win64 enabled
//
/////////////////////////////////////////////////////////////////////////////

inline bool FGetCifEntry(DETECTION_STRUCT* pDetection,
						 TCHAR *pszParamName,
						 TCHAR *pszParamValue, 
						 DWORD cbParamValue)
// pszParamName is [IN], pszParamValue is [OUT], the function GetCustomData requires
// LPSTR for both parameters, string conversion is necessary in the UNICODE case
{
#ifdef UNICODE	
	bool fSucceed;
	char pszParamNameANSI[MAX_PATH];
	char pszParamValueANSI[MAX_PATH];


	// do UNICODE to ANSI string conversion	
	// only pszParamName [IN] parameter need to be converted
	// wcstombs and mbstowcs do not ensure the last character is NULL
	// ensure manually
	wcstombs(pszParamNameANSI,pszParamName,MAX_PATH-1);
	pszParamNameANSI[MAX_PATH-1]=NULL;

	// make actual function call
    fSucceed= (ERROR_SUCCESS == pDetection->pCifComp->GetCustomData(pszParamNameANSI, 
														pszParamValueANSI, 
														cbParamValue));
	// do ANSI to UNICODE string conversion
	// only pszParamValue [OUT] parameter need to be converted
	mbstowcs(pszParamValue,pszParamValueANSI,cbParamValue-1);
	pszParamValue[cbParamValue-1]=(TCHAR)NULL;
	return fSucceed;


#else

	return (ERROR_SUCCESS == pDetection->pCifComp->GetCustomData(pszParamName, 
														pszParamValue, 
														cbParamValue));
#endif
}


/////////////////////////////////////////////////////////////////////////////
// RegKeyExists (EXPORT)
//   This API will determine if an application exists based on the
//   existence of a registry key and perhaps a value.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI RegKeyExists(DETECTION_STRUCT *pDetection)
{
	DWORD dwInstallStatus = DET_NOTINSTALLED;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	TCHAR szBuf[MAX_PATH];
	DWORD dwStatus;
	//DWORD dwLen;
	
    // make sure the struct is of the expected size
    if ( (pDetection->dwSize >= sizeof(DETECTION_STRUCT)) )
	{
		// get the registry key name from the components section of the
		// CIF file.
		if ( FGetCifEntry(pDetection, DETREG_KEY, szBuf, sizeof(szBuf)/sizeof(TCHAR)) )
		{
			if ( (dwStatus = dwKeyType(szBuf, &hKeyRoot, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR))) == ERROR_SUCCESS )
			{
			   // determine if we should log transmissions
			   if ( RegOpenKeyEx(  hKeyRoot,
									szTargetKeyName,
									0,
									KEY_QUERY_VALUE,
									&hKey) == ERROR_SUCCESS )
			   {
					if ( FGetCifEntry(pDetection, DETREG_VALUE, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) )
					{
						TargetRegValue targetValue;
						

						dwStatus = dwParseValue(szTargetKeyValue, targetValue);

						if ( dwStatus == ERROR_SUCCESS )
						{
    						ActualKeyValue keyvalue;
							DWORD size = sizeof(keyvalue);

							if ( RegQueryValueEx(hKey,
												   targetValue.szName,
												   0,
												   &type,
												   (BYTE *)&keyvalue,
												   &size) == ERROR_SUCCESS )
							{
								switch ( targetValue.type )
								{
								case REG_NONE:
									{
										dwInstallStatus = DET_INSTALLED;
										break;
									}
								case REG_DWORD:
									{
										if ( (type == REG_DWORD) || 
										     ((type == REG_BINARY) && (size >= sizeof(DWORD))) )
										{
											// see if we have a match
											if ( targetValue.dw == keyvalue.dw )
											{
												*pDetection->pdwInstalledVer = 1; 
												*pDetection->pdwInstalledBuild = 1; 
												dwInstallStatus = DET_INSTALLED;
											}
										}
										break;
									}
								case REG_SZ:
									{
										if ( type == REG_SZ )
										{
										   if ( lstrcmpi(targetValue.sz, keyvalue.sz) == 0 )
										   {
											   *pDetection->pdwInstalledVer = 1; 
											   *pDetection->pdwInstalledBuild = 1; 
											   dwInstallStatus = DET_INSTALLED;
										   }
										}
										break;
									}
								} // switch
							}
						}
					}
					else
					{
						// no REG value so, REGPATH is sufficient to determine
						// installation.
					   *pDetection->pdwInstalledVer = 1; 
					   *pDetection->pdwInstalledBuild = 1; 
					   dwInstallStatus = DET_INSTALLED;
					}
					RegCloseKey(hKey);
			   }
		   }
		}
	}

	return dwInstallStatus;
}


/////////////////////////////////////////////////////////////////////////////
// RegKeyVersion (EXPORT)
//
//   This API will determine if an application exists based on the
//   existence of a version number in the registry.
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI RegKeyVersion(DETECTION_STRUCT *pDetection)
{
	DWORD dwInstallStatus = DET_NOTINSTALLED;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	TCHAR szAskVersion[MAX_PATH];
	//TCHAR szVersion[MAX_VERSION_STRING_LEN];
	TCHAR szBuf[MAX_PATH];
	//DWORD dwStatus;
	//DWORD dwLen;
	DWORD dwVer;
	DWORD dwBuild;
	DWORD dwAskVer;
	DWORD dwAskBuild;
	
    // make sure the struct is of the expected size
    if ( pDetection->dwSize < sizeof(DETECTION_STRUCT) )
	{
		goto cleanup;
	}

	// get the registry key name from the components section of the
	// CIF file.
	if ( FGetCifEntry(pDetection, DETREG_KEY, szBuf, sizeof(szBuf)/sizeof(TCHAR)) &&
		 (dwKeyType(szBuf, &hKeyRoot, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) == ERROR_SUCCESS) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( FGetCifEntry(pDetection, DETREG_VERSION, szBuf, sizeof(szBuf)/sizeof(TCHAR)) &&
	            (GetStringField2(szBuf, 0, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0) )
			{
				DWORD size = sizeof(szBuf);

				if (GetStringField2(szBuf, 1, szAskVersion, sizeof(szAskVersion)/sizeof(TCHAR)) != 0)
				{
					fConvertDotVersionStrToDwords(szAskVersion, &dwAskVer, &dwAskBuild);
				}
				else
				{
					dwAskVer = pDetection->dwAskVer;
					dwAskBuild = pDetection->dwAskBuild;
				}

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szBuf,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						fConvertDotVersionStrToDwords(szBuf, &dwVer, &dwBuild);

						if ( nCompareVersion(dwVer, dwBuild, dwAskVer, dwAskBuild) >= 0 )
						{
							*pDetection->pdwInstalledVer = 1; 
							*pDetection->pdwInstalledBuild = 1; 
							dwInstallStatus = DET_INSTALLED;
						}
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

cleanup:
	return dwInstallStatus;
}


/////////////////////////////////////////////////////////////////////////////
// RegKeySubStr (EXPORT)
//
//   This API will determine if an application exists based on the
//   existence of one of a number of sub strings in the data.
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI RegKeySubStr(DETECTION_STRUCT *pDetection)
{
	DWORD dwInstallStatus = DET_NOTINSTALLED;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	TCHAR szKeyMissingStatus[MAX_PATH];
	TCHAR szData[MAX_PATH];
	TCHAR szSubStr[MAX_PATH];
	//TCHAR szTmp[MAX_PATH];
	TCHAR szBuf[MAX_PATH];
	//DWORD dwStatus;
	//DWORD dwLen;
	//DWORD dwVer;
	//DWORD dwBuild;
	
    // make sure the struct is of the expected size
    if ( pDetection->dwSize < sizeof(DETECTION_STRUCT) )
	{
		goto cleanup;
	}

	// get the registry key name from the components section of the
	// CIF file.
	if ( FGetCifEntry(pDetection, DETREG_KEY, szBuf, sizeof(szBuf)/sizeof(TCHAR)) &&
		 (dwKeyType(szBuf, &hKeyRoot, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) == ERROR_SUCCESS) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( FGetCifEntry(pDetection, DETREG_SUBSTR, szBuf, sizeof(szBuf)/sizeof(TCHAR)) &&
	            (GetStringField2(szBuf, 0, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0) &&
	            (GetStringField2(szBuf, 1, szKeyMissingStatus, sizeof(szKeyMissingStatus)/sizeof(TCHAR)) != 0) )
			{
				DWORD size = sizeof(szData);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szData,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						_tcslwr(szData);

						// iterate thru the substrings looking for a match.
						int index = 2;
						while ( GetStringField2(szBuf, index, szSubStr, sizeof(szSubStr)/sizeof(TCHAR)) != 0 )
						{
							_tcslwr(szSubStr);

							if ( _tcsstr(szData, szSubStr) != NULL )
							{
								*pDetection->pdwInstalledVer = 1; 
								*pDetection->pdwInstalledBuild = 1;
								dwInstallStatus = DET_INSTALLED;
								goto quit_while;
							}
							index++;
						}
quit_while:;
					}
				}
				else
				{
					// if we get an error, assume the key does not exist.  Note that if
					// the status is DETFIELD_NOT_INSTALLED then we don't have to do 
					// anything since that is the default status.
					if ( lstrcmpi(DETFIELD_INSTALLED, szKeyMissingStatus) == 0 )
					{
						dwInstallStatus = DET_INSTALLED;
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

cleanup:
	return dwInstallStatus;
}


/////////////////////////////////////////////////////////////////////////////
// MinFileVersion (EXPORT)
//   This API will determine if an application exists based on the
//   minimum version of a file.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI MinFileVersion(DETECTION_STRUCT *pDetection)
{
	DWORD dwInstallStatus = DET_INSTALLED;
	TCHAR szDllName[MAX_PATH];
	TCHAR szVersion[MAX_PATH];
    DWORD dwSize;
    DWORD dwHandle;
    TCHAR *pszVerInfo[MAX_PATH];
    VS_FIXEDFILEINFO	*vsVerInfo;
    UINT				uLen;
	
    // make sure the struct is of the expected size
    if ( pDetection->dwSize >= sizeof(DETECTION_STRUCT) )
	{
		// get the dll name and version from the components section of the
		// CIF file.
		if ( FGetCifEntry(pDetection, DETREG_KEY, szDllName, sizeof(szDllName)/sizeof(TCHAR)) )
		{
            if ( FGetCifEntry(pDetection, DETREG_VALUE, szVersion, sizeof(szVersion)/sizeof(TCHAR)) )
            {
                PTSTR pszPoint = szDllName;
                PTSTR pszPoint2 = szDllName;
                TCHAR szNewDllName[MAX_PATH];
                                        
                while (*pszPoint != '\0')
                {
                    if (*pszPoint == '%')
                    {
                        *pszPoint = '\0';
                        pszPoint += 1;

                        pszPoint2 = pszPoint;
                        
                        while (pszPoint2 != '\0')
                        {
                            if (*pszPoint2 == '%')
                            {
                                *pszPoint2 = '\0';
                                pszPoint2 += 1;
                                break;
                            }
                            pszPoint2 += 1;
                        }
                        break;
                    }
                    pszPoint += 1;
                }

                if (lstrcmpi(pszPoint, TEXT("11")) == 0)
                {
                    TCHAR szSystemDir[MAX_PATH];
                    GetSystemDirectory(szSystemDir, sizeof(szSystemDir)/sizeof(TCHAR));
                    lstrcpy(szNewDllName, szSystemDir);
                    if ((lstrlen(szSystemDir) + lstrlen(pszPoint2)) < sizeof(szNewDllName)/sizeof(TCHAR))
                    {
                        lstrcat(szNewDllName, pszPoint2);
                    }
                }

                dwSize = GetFileVersionInfoSize(szNewDllName, &dwHandle);
                if (dwSize > 0)
                {
		            if(dwSize > MAX_PATH)
			            dwSize = MAX_PATH;

		            GetFileVersionInfo(szNewDllName, dwHandle, dwSize, &pszVerInfo);
		            VerQueryValue(&pszVerInfo, TEXT("\\"), (void **) &vsVerInfo, &uLen);

                    DWORD dwDllVersion[4];
                    DWORD dwCheckVersion[4];

                    dwDllVersion[0] = HIWORD(vsVerInfo->dwProductVersionMS);
                    dwDllVersion[1] = LOWORD(vsVerInfo->dwProductVersionMS);
                    dwDllVersion[2] = HIWORD(vsVerInfo->dwProductVersionLS);
                    dwDllVersion[3] = LOWORD(vsVerInfo->dwProductVersionLS);

                    pszPoint = szVersion;
                    pszPoint2 = szVersion;

                    INT i = 0;

                    while (*pszPoint != '\0')
                    {
                        if (*pszPoint == ',')
                        {
                            *pszPoint = '\0';
                            dwCheckVersion[i] = _ttol(pszPoint2);
                            i += 1;
                            pszPoint2 = pszPoint + 1;
                        }
                        pszPoint += 1;
                    }
                    dwCheckVersion[i] = _ttol(pszPoint2);

                    for (i = 0; i < 4; i += 1)
                    {
                        if (dwDllVersion[i] < dwCheckVersion[i])
                        {
                            dwInstallStatus = DET_NOTINSTALLED;
                        }
                    }
                } else {
					dwInstallStatus = DET_NOTINSTALLED;
				}

                *pDetection->pdwInstalledVer = 1; 
                *pDetection->pdwInstalledBuild = 1; 
            }
		}
	}

	return dwInstallStatus;
}


/////////////////////////////////////////////////////////////////////////////
// Expression (EXPORT)
//
//   This API will evaluate a boolean expression where every operand is a
//   detection operation.
/////////////////////////////////////////////////////////////////////////////

const DWORD MAX_EXPRESSION_LEN = 1024;

DWORD WINAPI Expression(DETECTION_STRUCT *pDetection)
{
	DWORD dwInstallStatus = DET_NOTINSTALLED;
	//HKEY hKeyRoot;
	//HKEY hKey;
	//DWORD type;
	//TCHAR szTargetKeyName[MAX_PATH];
	//TCHAR szTargetKeyValue[MAX_PATH];
	//TCHAR szKeyMissingStatus[MAX_PATH];
	//TCHAR szData[MAX_PATH];
	//TCHAR szSubStr[MAX_PATH];
	//TCHAR szTmp[MAX_PATH];
	TCHAR szExpression[MAX_EXPRESSION_LEN];
	//DWORD dwStatus;
	//DWORD dwLen;
	//DWORD dwVer;
	//DWORD dwBuild;
	
    // make sure the struct is of the expected size
    if ( pDetection->dwSize < sizeof(DETECTION_STRUCT) )
	{
		goto cleanup;
	}

	// get the expression.
	if ( FGetCifEntry(pDetection, DET_EXPRESSION, szExpression, sizeof(szExpression)/sizeof(TCHAR)) )
	{
		CExpressionParser expression(pDetection);
		bool fResult = TRUE;
		HRESULT hr = expression.fEvalExpression(szExpression, &fResult);

		if ( SUCCEEDED(hr) && fResult)
		{
			*pDetection->pdwInstalledVer = 1; 
            *pDetection->pdwInstalledBuild = 1; 
			dwInstallStatus = DET_INSTALLED;
		}
	}

cleanup:
	return dwInstallStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\regkeysubstr.cpp ===
#include "wudetect.h"

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegSubStr
//   Detect a substring in registry datum.
//
//	 Form: E=RegSubstr,<SubStr>,<RootKey>,<KeyPath>,<RegValue>,<RegData>
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fDetectRegSubStr(TCHAR * pszBuf)
{
	bool fSuccess = false;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_PATH];
	TCHAR szKeyMissingStatus[MAX_PATH];
	TCHAR szData[MAX_PATH];
	TCHAR szSubStr[MAX_PATH];
	DWORD iToken = 0;
	

	// Get reg root type (HKLM, etc)
	if ( fMapRegRoot(pszBuf, ++iToken, &hKeyRoot) &&
		 (GetStringField2(pszBuf, ++iToken, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) != 0) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( (GetStringField2(pszBuf, ++iToken, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0) &&
	             (GetStringField2(pszBuf, ++iToken, szKeyMissingStatus, sizeof(szKeyMissingStatus)/sizeof(TCHAR)) != 0) )
			{
				DWORD size = sizeof(szData);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szData,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						_tcslwr(szData);

						// iterate thru the substrings looking for a match.
						while ( GetStringField2(pszBuf, ++iToken, szSubStr, sizeof(szSubStr)) != 0 )
						{
							_tcslwr(szSubStr);

							if ( _tcsstr(szData, szSubStr) != NULL )
							{
								fSuccess = true;
								goto quit_while;
							}
						}
quit_while:;
					}
				}
				else
				{
					// if we get an error, assume the key does not exist.  Note that if
					// the status is DETFIELD_NOT_INSTALLED then we don't have to do 
					// anything since that is the default status.
					if ( lstrcmpi(DETFIELD_INSTALLED, szKeyMissingStatus) == 0 )
					{
						fSuccess = true;
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}


	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\regkeybinary.cpp ===
#include <stdio.h>
#include "wudetect.h"


// a small utility to convert hexadecimal digits to numeric values in dec
static inline int hexa( TCHAR c )
{
    if( c >= '0' && c <='9' )
    {
        return (c - '0');
    }
    else if( c >= 'a' && c <= 'f' )
    {
        return (10 + (c - 'a') );
    }
    else if( c >= 'A' && c <= 'F' )
    {
        return (10 + (c - 'A') );
    }

    

    return -1;
}

static void StringToBin( LPTSTR lpData, DWORD& nSize )
{
    nSize = 0; // we will reassign the value on size of binary buffer
    BYTE * lpBinaryData = (BYTE*)lpData;

    //_strlwr( lpData );

    while( *lpData != '\0' )
    {
        while( ' ' == *lpData ) lpData++;

        *lpBinaryData++ = (hexa( *lpData++ ) * 16) + hexa( *lpData++ );
        nSize++;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CExpressionParser::fDetectRegBinary
//   Detect a substring in registry datum.
//
//	 Form: E=RegSubstr,<SubStr>,<RootKey>,<KeyPath>,<RegValue>,<RegData>
//   
// Comments :
/////////////////////////////////////////////////////////////////////////////

bool CExpressionParser::fDetectRegBinary(TCHAR * pszBuf)
{
    const int MAX_DATA_SIZE = 2000;

	bool fSuccess = false;
	HKEY hKeyRoot;
	HKEY hKey;
	DWORD type;
	TCHAR szTargetKeyName[MAX_PATH];
	TCHAR szTargetKeyValue[MAX_DATA_SIZE];
	TCHAR szKeyMissingStatus[MAX_DATA_SIZE];
	TCHAR szData[MAX_DATA_SIZE];
	TCHAR szSubStr[MAX_DATA_SIZE];
	DWORD iToken = 0;
	

	// Get reg root type (HKLM, etc)
	if ( fMapRegRoot(pszBuf, ++iToken, &hKeyRoot) &&
		 (GetStringField2(pszBuf, ++iToken, szTargetKeyName, sizeof(szTargetKeyName)/sizeof(TCHAR)) != 0) )
	{
	   if ( RegOpenKeyEx(  hKeyRoot,
							szTargetKeyName,
							0,
							KEY_QUERY_VALUE,
							&hKey) == ERROR_SUCCESS )
	   {
			if ( (GetStringField2(pszBuf, ++iToken, szTargetKeyValue, sizeof(szTargetKeyValue)/sizeof(TCHAR)) != 0) &&
	             (GetStringField2(pszBuf, ++iToken, szSubStr, sizeof(szSubStr)/sizeof(TCHAR)) != 0) )
			{
				DWORD size = sizeof(szData);

				if ( RegQueryValueEx(hKey,
									   szTargetKeyValue,
									   0,
									   &type,
									   (BYTE *)szData,
									   &size) == ERROR_SUCCESS )
				{
					if ( type == REG_SZ )
					{
						_tcslwr(szData);

						// iterate thru the substrings looking for a match.
						//while ( GetStringField2(pszBuf, ++iToken, szSubStr, sizeof(szSubStr)) != 0 )
						{
							_tcslwr(szSubStr);

							if ( _tcsstr(szData, szSubStr) != NULL )
							{
								fSuccess = true;
								goto quit_while;
							}
						}
					}
                    else if( REG_BINARY== type )
                    {
                        StringToBin( szSubStr, size );

                        int nRes = memcmp( szData, szSubStr, size ); 

                        //printf( "", nRes );

                         if( (int)0 == nRes )
                         {
                            fSuccess = true;
						    //goto quit_while;
                         }
                        
                         //printf( "", nRes );
                         
                    }
quit_while:;
				}
				else
				{
					// if we get an error, assume the key does not exist.  Note that if
					// the status is DETFIELD_NOT_INSTALLED then we don't have to do 
					// anything since that is the default status.
					if ( lstrcmpi(DETFIELD_INSTALLED, szKeyMissingStatus) == 0 )
					{
						fSuccess = true;
					}
				}
			}
			RegCloseKey(hKey);
	   }
	}

//cleanup:
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\utils2.h ===
//
// Modified by RogerJ, 03/08/00
// Original Creator Unknown
// Modification --- UNICODE and Win64 ready
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _UTILS2_H_
#define _UTILS2_H_

bool fMapRegRoot(TCHAR *pszBuf, DWORD index, HKEY *phKey);


#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
#define IsAlpha(c)  ( ((c) >= 'A'  &&  (c) <= 'Z') || ((c) >= 'a'  &&  (c) <= 'z'))

long AtoL(const TCHAR *nptr);

LPTSTR FindChar(LPTSTR, TCHAR);

DWORD GetStringField2(LPTSTR szStr, UINT uField, LPTSTR szBuf, UINT cBufSize);

bool fConvertDotVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);


//////////////////////////////////////////////////////
// not-in-use in the current version
//////////////////////////////////////////////////////
#if 0

DWORD GetIntField (LPTSTR szStr, UINT ufield, DWORD dwDefault);

void ConvertVersionStrToDwords(LPTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);

#endif

//////////////////////////////////////////////////////
// End of not-in-use section
//////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wudetect\wudetect.h ===
/////////////////////////////////////////////////////////////////////////////
// WUDetect.h
//
// Copyright (C) Microsoft Corp. 1998
// All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
//
// Description:
//   Global Header
/////////////////////////////////////////////////////////////////////////////
//
// Original Creator Unkown
// No modification made by RogerJ at 03/08/00
//
/////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <tchar.h>
#include <ole2.h>
#include <objbase.h>
#include <io.h>

#include <inseng.h>

#include "detdlls.h"
#include "utils2.h"
#include "detection.h"
#include "expression.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\cbitmask.cpp ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include "speed.h"

//create an empty bitmask
CBitmask::CBitmask()
{
	m_iTotalBitMasks	= 0;
	m_iMaskFileSize		= 0;
	m_pMask				= NULL;
}

//Create a bitmask of the specified size
CBitmask::CBitmask(
	int iMaxMasks,		//maximum number of bit masks to allocate space for
	int iMaxMaskBits,	//size of each individual mask in bits
	int	iTotalOEMs,		//total oem bitmask records
	int	iTotalLangs,	//total locale bitmask records
	int	iTotalPlatforms	//Total number of platforms defined.
	)
{
	m_iMaskFileSize = sizeof(BITMASK) + (iMaxMasks * sizeof(BITMASKID))
		+ ((iMaxMasks * ((iMaxMaskBits+7)/8)));

	m_pMask	= (PBITMASK)V3_malloc(m_iMaskFileSize);

	ZeroMemory(m_pMask, m_iMaskFileSize);

	m_pMask->iRecordSize = iMaxMaskBits;

	m_pMask->iBitOffset = sizeof(m_pMask->iRecordSize) + 
								 sizeof(m_pMask->iBitOffset) +
								 sizeof(m_pMask->iOemCount) + 
								 sizeof(m_pMask->iLocaleCount) + 
								 sizeof(m_pMask->iPlatformCount) + 
								 (iMaxMasks * sizeof(BITMASKID));

	m_pMask->iOemCount = iTotalOEMs;
	m_pMask->iLocaleCount = iTotalLangs;
	m_pMask->iPlatformCount = iTotalPlatforms;

	m_iTotalBitMasks = iMaxMasks;
}


CBitmask::~CBitmask()
{
	if (m_pMask)
		V3_free(m_pMask);
}


// downloads and uncompresses the file into memory
// Memory is allocated and returned in ppMem and size in pdwLen 
// ppMem and pdwLen cannot be null
// if the function succeeds the return memory must be freed by caller
static HRESULT DownloadFileToMem(CWUDownload* pDownload, LPCTSTR pszFileName, CDiamond* pDiamond, BYTE** ppMem, DWORD* pdwLen)
{
	byte_buffer bufTmp;
	byte_buffer bufOut;
	if (!pDownload->MemCopy(pszFileName, bufTmp))
		return HRESULT_FROM_WIN32(GetLastError());
	CConnSpeed::Learn(pDownload->GetCopySize(), pDownload->GetCopyTime());
	if (pDiamond->IsValidCAB(bufTmp))
	{
		if (!pDiamond->Decompress(bufTmp, bufOut))
			return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		//else the oem table is in uncompressed format.
		bufOut << bufTmp;
	}
	*pdwLen = bufOut.size();
	*ppMem = bufOut.detach();
	
	//Check if *pdwLen is 0 i.e. size is 0 
	//OR *ppMem is NULL, then return E_FAIL 

	if ((NULL == *ppMem) || (0 == *pdwLen))
	{
		return E_FAIL;
	}

	return S_OK;
}


void CBitmask::Read(
	IN	CWUDownload		*pDownload,		//pointer to internet server download class.
	IN	CDiamond		*pDiamond,		//pointer to diamond de-compression class.
	IN	PUID			puidCatalog,	//PUID id of catalog to be retrieved.
	IN	int				iType,			//type of bitmask to retrieve:
	IN  LPCTSTR		    pszBaseName     //required only for active setup
	)
{
	TCHAR	szPath[MAX_PATH];
	PBYTE	pMem;
	int		iMemLen;

	if ( m_pMask )
		V3_free(m_pMask);

	//puidCatalog 0 is a special case.
	//if the puidCatalog == 0 then we want
	//the list of catalogs. This list is contained
	//in the bitmask.plt file which is in the server root.

	if (!puidCatalog)
	{
		wsprintf(szPath, _T("bitmask.plt"));
	}
	else
	{

		if (iType == BITMASK_CDM_TYPE)
		{
			wsprintf(szPath, _T("%d/bitmask.cdm"), puidCatalog);
		}
		else
		{
			wsprintf(szPath, _T("%d/%s.bm"), puidCatalog, pszBaseName);
		}
	}

	DWORD dwSize;
	HRESULT hr = DownloadFileToMem(pDownload, szPath, pDiamond, (LPBYTE*)&m_pMask, (DWORD*)&m_iMaskFileSize);
	if (FAILED(hr))
	{
		throw hr;
	}

	//total bitmasks =	oem bitmask rcrds +
	//					locale bitmask rcrds +
	//					global bitmask rcrd +
	//					default oem bitmask rcrd
	if (m_pMask)
	{
		m_iTotalBitMasks = m_pMask->iOemCount + m_pMask->iLocaleCount + m_pMask->iPlatformCount + 2;
	}
}


//parse the memory bitmask buffer into a bitmask class
void CBitmask::Parse(
	IN	PBYTE	pBuffer,		//memory buffer that contains the bitmask file
	IN	int		iMaskFileSize	//file size of memory buffer file
	)
{
	m_iMaskFileSize = iMaskFileSize;

	//Note: This is necessary since this class manages the bitmask memory internally.

	m_pMask = (PBITMASK)V3_malloc(iMaskFileSize);

	memcpy(m_pMask, (PBITMASK)pBuffer, iMaskFileSize);

	m_iTotalBitMasks = m_pMask->iOemCount + m_pMask->iLocaleCount + m_pMask->iPlatformCount + 2;
}


//returns a pointer to a bitmask customized for the client computer that we are running on.
//Note: This bitmask only has one record. This record is the correctly anded bitmask for
//OEM and LOCALE.
PBYTE CBitmask::GetClientBits(
	DWORD	dwOemId,	// PnP ID for current machine
	DWORD	langid	//pointer to variable that receives the OS locale id
	)
{
	int		i;
	int		t;
	int		iMaskByteSize;
	PBYTE	pBits;

	//check if the member var m_pMask is not NULL
	if (NULL == m_pMask)
	{
		return NULL;
	}

	iMaskByteSize = ((m_pMask->iRecordSize+7)/8);

	pBits = (PBYTE)V3_malloc(iMaskByteSize);

	//check if memory was allocated successfully
	if (NULL == pBits)
	{
		return NULL;
	}

	memset(pBits, 0xFF, iMaskByteSize);

//	AndBitmasks(pBits, GetBitMaskPtr(BITMASK_GLOBAL_INDEX), iMaskByteSize);

	int nCurrentOEM = m_pMask->iOemCount; // out of range value
	if (dwOemId)
	{
		for (int nOEM = 0; nOEM < m_pMask->iOemCount; nOEM++)
		{
			if (dwOemId == m_pMask->bmID[nOEM])
				break;
		}
		nCurrentOEM = nOEM;
	}
	int nBitmapIndex = (m_pMask->iOemCount == nCurrentOEM 
		? BITMASK_OEM_DEFAULT	// if we did not find an OEM bitmask specific to this client then use the default OEM mask.
		: nCurrentOEM+2			// bitmask is offset from GLOBAL and DEFAULT bitmasks
	);
	AndBitmasks(pBits, GetBitMaskPtr(nBitmapIndex), iMaskByteSize);

	//And in LOCALE bitmask
	for(i=0; i<m_pMask->iLocaleCount; i++)
	{
		if ( m_pMask->bmID[m_pMask->iOemCount+i] == langid )
		{
			//We need to add in the oem count to get to the first local
			AndBitmasks(pBits, GetBitMaskPtr(m_pMask->iOemCount+i+2), iMaskByteSize);
			return pBits;
		}
	}
	V3_free(pBits);
	throw HRESULT_FROM_WIN32(ERROR_INSTALL_LANGUAGE_UNSUPPORTED);
	return NULL;
}


//This method is used to process the inventory.plt and bitmask.plt
PBYTE CBitmask::GetClientBits(
	PDWORD	pdwPlatformIdList,	//Array of Platform ids.
	int		iTotalPlatforms		//Total Platform ids in previous array.
	)
{
	int		i;
	int		t;
	int		iMaskByteSize;
	PBYTE	pBits;

	iMaskByteSize = ((m_pMask->iRecordSize+7)/8);

	pBits = (PBYTE)V3_malloc(iMaskByteSize);

	memset(pBits, 0xFF, iMaskByteSize);

	AndBitmasks(pBits, GetBitMaskPtr(BITMASK_GLOBAL_INDEX), iMaskByteSize);

	//AND in Platform bitmask for each platform in array that matches one in
	//the passed in list of platforms.

	BOOL bFound = FALSE;
	for(i=0; i<m_pMask->iPlatformCount; i++)
	{
		for(t=0; t<iTotalPlatforms && pdwPlatformIdList[t] != m_pMask->bmID[i]; t++)
			;
		if ( t < iTotalPlatforms )
		{
			//bitmask is offset from GLOBAL and DEFAULT bitmasks
			AndBitmasks(pBits, GetBitMaskPtr(i+2), iMaskByteSize);
			bFound = TRUE;
		}
	}
	if (!bFound)
		memset(pBits, 0x00, iMaskByteSize);

	return pBits;
}


//This method performs a logical AND operation between an array of bits and a bitmask bit array.
void CBitmask::AndBitmasks(
	PBYTE	pBitsResult,	//result array for the AND operation
	PBYTE	pBitMask,		//source array bitmask
	int		iMaskByteSize	//bitmask size in bytes
	)
{
	// check if the input arguments are valid
	if (NULL == pBitsResult || NULL == pBitMask)
	{
		return;
	}

	for (int i = 0; i<iMaskByteSize; i++)
		pBitsResult[i] &= pBitMask[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\applog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    applog.h
//
//  Purpose: Application logging 
//
//  History: 22-Feb-99   YAsmi    Created
//
//=======================================================================

#include <windows.h>
#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>
#include <stdarg.h>
#include <malloc.h>

#include "applog.h"


//
// CAppLog class
//


//--------------------------------------------------------------------------------
// CAppLog::CAppLog
//
// if the pszLogFileName=NULL, then the caller must set the log file name by
// calling SetLogFile before using
//--------------------------------------------------------------------------------
CAppLog::CAppLog(LPCTSTR pszLogFileName) :
	m_pszLine(NULL),
	m_pFileBuf(NULL),
	m_pszBuf(NULL),
	m_dwBufLen(0),
	m_pszFldParse(NULL)
{
	m_pszLogFN = NULL;
	SetLogFile(pszLogFileName);
}


//--------------------------------------------------------------------------------
// CAppLog::~CAppLog
//
// free resources
//--------------------------------------------------------------------------------
CAppLog::~CAppLog()
{
	if (m_pszLogFN != NULL)
		free(m_pszLogFN);

	if (m_pszBuf != NULL)
		free(m_pszBuf);

	if (m_pFileBuf != NULL)
		free(m_pFileBuf);
}


//--------------------------------------------------------------------------------
// CAppLog::Log
//
//--------------------------------------------------------------------------------
void CAppLog::Log(LPCSTR pszLogStr)
{
	HANDLE hFile;
	DWORD dwBytes;
	LPCSTR pszEOL = "\r\n";

	//
	// write to file
	//
	hFile = CreateFile(m_pszLogFN, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		//append to existing file
		SetFilePointer(hFile, NULL, NULL, FILE_END);   
		
		// write the string and end of line
		WriteFile(hFile, pszLogStr, strlen(pszLogStr), &dwBytes, NULL);
		WriteFile(hFile, pszEOL, strlen(pszEOL), &dwBytes, NULL);

		CloseHandle(hFile);
	}

}


//--------------------------------------------------------------------------------
// CAppLog::FormatMessage (static)
//
// formats an error message using the HR and returns it in pszBuf
//--------------------------------------------------------------------------------
void CAppLog::FormatErrMsg(HRESULT hr, LPSTR pszBuf, int cBufSize)
{
	USES_CONVERSION;

	LPTSTR pszMsg;
	int l;

	if (FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
		(LPTSTR)&pszMsg,
		0,
		NULL) != 0)
	{
		char *p = T2A(pszMsg);
		if (p)
		{
			strncpy(pszBuf, p, cBufSize);
		}
		LocalFree(pszMsg);

		//strip the end of line characters
		l = strlen(pszBuf);
		if (l >= 2 && pszBuf[l - 2] == '\r')
			pszBuf[l - 2] = '\0';
	}
	else
	{
		// no error message found for this hr
		pszBuf[0] = '\0';
	}
}


//--------------------------------------------------------------------------------
// CAppLog::CheckBuf
//
// allocates the internal buffer to be atleast dwSize big.  Does not do anything
// if the the buffer is already big enough
//--------------------------------------------------------------------------------
void CAppLog::CheckBuf(DWORD dwSize)
{
	if (m_dwBufLen >= dwSize)
		return;

	if (m_pszBuf != NULL)
		free(m_pszBuf);

	m_dwBufLen = dwSize + 16;   
	m_pszBuf = (LPSTR)malloc(m_dwBufLen);
}


//--------------------------------------------------------------------------------
// CAppLog::SetLogFile
//
// sets the log file name.  Use this function if you did not specify the file name
// in the ctor
//--------------------------------------------------------------------------------
void CAppLog::SetLogFile(LPCTSTR pszLogFileName)
{
	if (m_pszLogFN != NULL)
		free(m_pszLogFN);
	
	if (pszLogFileName != NULL)
		m_pszLogFN = _tcsdup(pszLogFileName);
	else
		m_pszLogFN = NULL;
}







//--------------------------------------------------------------------------------
// CAppLog::StartReading
//
// Reads the entire log in memory so we can read lines.  Following is an example:
//
//		CAppLog l("C:\\wuv3test.log", TRUE);
//		l.StartReading();
//		while (l.ReadLine())
//			printf("%s\n", l.GetLineStr());
//		l.StopReading();
//--------------------------------------------------------------------------------
void CAppLog::StartReading()
{
	HANDLE hFile;
	
	m_dwFileSize = 0;
	m_dwFileOfs = 0;
	m_pFileBuf = NULL;

	hFile = CreateFile(m_pszLogFN, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return;

	m_dwFileSize = GetFileSize(hFile, NULL);

	m_pFileBuf = (LPSTR)malloc(m_dwFileSize);
	if (m_pFileBuf == NULL)
	{
		m_dwFileSize = 0;
	}
	else
	{
		DWORD dwBytes;
		if (!ReadFile(hFile, m_pFileBuf, m_dwFileSize, &dwBytes, NULL))
		{
			free(m_pFileBuf);
			m_pFileBuf = NULL;
			m_dwFileSize = 0;
		}
	}

	CloseHandle(hFile);
}


//--------------------------------------------------------------------------------
// CAppLog::ReadLine
//
// reads a line from the memory buffer where the entire file was loaded
// moves the internal pointer to the next line. 
//--------------------------------------------------------------------------------
BOOL CAppLog::ReadLine()
{
	DWORD dwOrgOfs; 
	
	if (m_dwFileSize == 0 || (m_dwFileOfs + 1) >= m_dwFileSize)
		return FALSE;

	m_pszLine = &m_pFileBuf[m_dwFileOfs];

	dwOrgOfs = m_dwFileOfs;
	while (m_dwFileOfs < m_dwFileSize && m_pFileBuf[m_dwFileOfs] != '\r')
		m_dwFileOfs++;

	if ((m_dwFileOfs - dwOrgOfs) > 2048)
	{
		// self imposed limit of 2048 chars in a line
		// we consider a file with a longer line of text an invalid log file
		m_dwFileOfs	= m_dwFileSize;
		return FALSE;
	}

	// this is where we have the \r (13), we replace it with a 0 to create
	// end of string here
	m_pFileBuf[m_dwFileOfs] = '\0';

	// point the ofset to next line
	m_dwFileOfs += 2;

	// allocate enough memory to parse out fields when GetField is called
	CheckBuf(m_dwFileOfs - dwOrgOfs);

	// setup the start of field parsing
	m_pszFldParse = m_pszLine;

	return TRUE;
}


//--------------------------------------------------------------------------------
// CAppLog::GetLineStr
//
// returns the entire line read by ReadLine()
//--------------------------------------------------------------------------------
LPCSTR CAppLog::GetLineStr()
{
	return m_pszLine;
}


//--------------------------------------------------------------------------------
// CAppLog::CopyNextField
//
// parses out the current line separated by the LOG_FIELD_SEPARATOR
// and copies the string to pszBuf upto cBufSize long field and moves internal 
// pointer to next field.  When the end of line is reached, returns a blank string
// 
// RETURNS: TRUE if more fields are left, FALSE otherwise
//
// NOTES: Once you get a field you cannot get it again.  
//--------------------------------------------------------------------------------
BOOL CAppLog::CopyNextField(LPSTR pszBuf, int cBufSize)
{
	BOOL bMoreFields = FALSE;

	if (m_pszFldParse == NULL || *m_pszFldParse == '\0')
	{
		//there are no more fields 
		m_pszBuf[0] = '\0';
		m_pszFldParse = NULL;
	}
	else
	{
		LPCSTR p = strstr(m_pszFldParse, LOG_FIELD_SEPARATOR);
		if (p != NULL)
		{
			//copy the field to buffer but there are still more fields
			strncpy(m_pszBuf, m_pszFldParse, p - m_pszFldParse);
			m_pszBuf[p - m_pszFldParse] = '\0';		
			m_pszFldParse = const_cast<LPSTR>(p + strlen(LOG_FIELD_SEPARATOR));
			bMoreFields = TRUE;
		}
		else
		{
			//this is the last field, there are no more fields
			strcpy(m_pszBuf, m_pszFldParse);
			m_pszFldParse = NULL;
		}
	}

	//copy the string ensuring that we have a 0 at the end in all cases
	strncpy(pszBuf, m_pszBuf, cBufSize);
	pszBuf[cBufSize - 1] = 0;

	return bMoreFields;
}


//--------------------------------------------------------------------------------
// CAppLog::StopReading
//
// free up memory from allocated in StartReading
//--------------------------------------------------------------------------------
void CAppLog::StopReading()
{
	if (m_pFileBuf != NULL)
	{
		free(m_pFileBuf);
		m_pFileBuf = NULL;
	}
	m_dwFileSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\debug.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    debug.cpp
//
//  Purpose:
//
//  History: 15-jan-99   YAsmi    Created
//
//=======================================================================

#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>

#include "debug.h"

#ifdef _DEBUG

#include <stdarg.h>
#include <windows.h>

//#ifdef _WUV3TEST
#include <stdio.h>
#define LOGGING_LEVEL 3
#include <log.h>
//#endif

void _cdecl WUTrace(char* pszFormat, ...)
{
	USES_CONVERSION;

	TCHAR *ptszBuf = (TCHAR*)malloc(256 * sizeof(TCHAR));
	if(ptszBuf)
	{
		va_list ArgList;
		
		memset(ptszBuf, 0, 256 * sizeof(TCHAR));

		va_start(ArgList, pszFormat);
		_vsntprintf(ptszBuf, 255, A2T(pszFormat), ArgList);
		va_end(ArgList);
		
		OutputDebugString(_T("WUTRACE: "));
		OutputDebugString(ptszBuf);	
		OutputDebugString(_T("\r\n"));
		CLogger logger(0, LOGGING_LEVEL);
		logger.out("WUTRACE: %s", ptszBuf);
		free((void*)ptszBuf);
	}

}


void _cdecl WUTraceHR(unsigned long hr, char* pszFormat, ...)
{
	USES_CONVERSION;
	TCHAR szMsg[256];
	TCHAR *ptszBuf = (TCHAR*)malloc(256 * sizeof(TCHAR));

	if(ptszBuf)
	{
		va_list ArgList;
		LPTSTR pszMsg;
		int l;
		
		memset(ptszBuf, 0, 256 * sizeof(TCHAR));

		va_start(ArgList, pszFormat);
		_vsntprintf(ptszBuf, 255,  A2T(pszFormat), ArgList);
		va_end(ArgList);

		if (FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
			(LPTSTR)&pszMsg,
			0,
			NULL) != 0)
		{
			lstrcpyn(szMsg, pszMsg, sizeof(szMsg)/sizeof(szMsg[0]));
			LocalFree(pszMsg);

			//strip the end of line characters
			l = lstrlen(szMsg);
			if (l >= 2 && szMsg[l - 2] == '\r')
				szMsg[l - 2] = '\0';
		}
		else
		{
			// no error message found for this hr
			szMsg[0] = '\0';
		}


		WUTrace("%s [Error %#08x: %s]", ptszBuf, hr, szMsg);
		free((void*)ptszBuf);
	}
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\cstate.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    cstate.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <string.h>
#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>
#include <wuv3.h>
#include <CState.h>
#include <objbase.h>
#include "debug.h"
#include "newtrust.h"
#include "speed.h"


//
// CState class
//


// Note: The there is only one object of CState class for the entire V3 control 
CState::CState()
{
	m_iTotalCatalogs = 0;	// total catalogs
	
	// OEM Table has not been read yet.
	m_pOemInfoTable = NULL;
	
	// No platforms have been detected as yet.
	m_pdwPlatformList = NULL;
	m_iTotalPlatforms = 0;
	
	m_cTrustedServers = 0;
	m_bRebootNeeded = FALSE;
	
	m_DefPlat = (int)enV3_DefPlat;
	
	m_cDetDLLs = 0;
	m_bInsengChecked = FALSE;

	m_iCabPoolServer = 0; 
	m_iSiteServer = 0;
	m_iContentServer = 0;
	m_iIdentServer = 0;
	m_iRootServer = 0;

	m_szSiteURL[0] = _T('\0');
        m_nClient = WUV3_CLIENT_UNSPECIFIED;
}


void CState::Reset()
{
	//
	// free up any catalogs that are checked in to state storage.
	//
	for (int i = 0; i < m_iTotalCatalogs; i++)
		delete m_vState[i].pCatalog;
	m_iTotalCatalogs = 0;

	//
	// free up the OEM info table if it has been downloaded.
	//
	if (m_pOemInfoTable)
	{
		V3_free(m_pOemInfoTable);
		m_pOemInfoTable = NULL;
	}

	if (m_pdwPlatformList)
	{
		CoTaskMemFree(m_pdwPlatformList);
	}

	//
	//clear selection
	//
	m_selectedItems.Clear();

	m_pdwPlatformList = NULL;
	m_iTotalPlatforms = 0;
	m_cTrustedServers = 0;
	m_bRebootNeeded = FALSE;

	//we do not want to clear the detection DLLs array here
}


CState::~CState()
{
	Reset();
}



//This method retrieves a catalog from the state array. The catalog is
//retrieved by name. If the catalog name is not found NULL is returned.
CCatalog *CState::Get(
	PUID puid	//puid id of catalog to be retrieved.
	)
{
	int	index;
	char szName[32];
	
	if ( (index = Find(puid)) >= 0 )
		return m_vState[index].pCatalog;
	
	return NULL;
}


//This method adds a new pruned catalog into the state array. This method returns
//the total number of catalogs currently stored in the state array. This number
//includes the new catalog. Note: The application must not delete a catalog that
//is added to the state structure. Once the catalog is added it is the
//responsibility of this class to delete the catalog.
int CState::Add(
	PUID	puid,		//PUID of catalog to be added to state module.
	CCatalog *pCatalog	//Pointer to pruned catalog class to be added to state array.
	)
{
	int iRc;

	m_vState[m_iTotalCatalogs].puid = puid;
	m_vState[m_iTotalCatalogs].pCatalog = pCatalog;
	iRc = m_iTotalCatalogs;
	m_iTotalCatalogs++;

	return iRc;
}


//This method finds a catalog within the state store by name. If the catalog is
//not found then NULL is returned.
int CState::Find(
	PUID puid	//Puid of catalog to find within the state management module.
	)
{
	int i;

	for(i=0; i<m_iTotalCatalogs; i++)
	{
		if (puid == m_vState[i].puid)
			return i;
	}

	return -1;
}


//This function gets a catalog inventory item and or catalog within the state store
//by puid. The caller can retrieve the specific catalog item catalog or both. For
//info that is not needed pass in NULL to the parameter. For example, if you do not
//require the catalog parameter set the parameter to NULL.
BOOL CState::GetCatalogAndItem(
	IN				PUID			puid,		//puid of item to be returned.
	IN	OPTIONAL	PINVENTORY_ITEM	*ppItem,	//returned pointer to specific item that equates to this puid
	IN	OPTIONAL	CCatalog		**ppCatalog	//returned pointer to specific catalog that this puid is in.
	)
{
	int				rcrd;
	int				iCatalogIndex;
	int				iTotalrecords;
	CCatalog		*pCatalog;
	PINVENTORY_ITEM	pItem;

	for (iCatalogIndex=0; iCatalogIndex<m_iTotalCatalogs; iCatalogIndex++)
	{
		pCatalog = m_vState[iCatalogIndex].pCatalog;
		iTotalrecords = pCatalog->GetHeader()->totalItems;

		for (rcrd=0; rcrd<iTotalrecords; rcrd++)
		{
			//Note: This is specially coded for speed since this code is potentially run for
			//each record in each catalog in the state store.

			if (NULL == (pItem = pCatalog->GetItem(rcrd)))
				continue;
			switch( pItem->recordType )
			{
				case WU_TYPE_ACTIVE_SETUP_RECORD:
					if ( puid == pItem->pf->a.puid )
					{
						if ( ppCatalog )
							*ppCatalog = pCatalog;
						if ( ppItem )
							*ppItem = pItem;
						return TRUE;
					}
					break;
				case WU_TYPE_CDM_RECORD:
				case WU_TYPE_CDM_RECORD_PLACE_HOLDER:	//note cdm place holder record does not have an associated description record.
					if ( puid == pItem->pf->d.puid )
					{
						if ( ppCatalog )
							*ppCatalog = pCatalog;
						if ( ppItem )
							*ppItem = pItem;
						return TRUE;
					}
					break;
				case WU_TYPE_SECTION_RECORD:
				case WU_TYPE_SUBSECTION_RECORD:
				case WU_TYPE_SUBSUBSECTION_RECORD:
					if ( puid == pItem->pf->s.puid )
					{
						if ( ppCatalog )
							*ppCatalog = pCatalog;
						if ( ppItem )
							*ppItem = pItem;
						return TRUE;
					}
					break;
				case WU_TYPE_RECORD_TYPE_PRINTER:
					if (puid == pItem->pf->d.puid )
					{
						if ( ppCatalog )
							*ppCatalog = pCatalog;
						if ( ppItem )
							*ppItem = pItem;
						return TRUE;
					}
					break;
			}
		}
	}

	return FALSE;
}

//Retrieves the full list of items that have this puid. The return value is the number
//of returned items. If the case of an error 0 is returned. Note: This function is only
//called from the ChangeItemState method.
int CState::GetItemList(
	IN	PUID puid,				//puid of item to be returned.
	IN Varray<PINVENTORY_ITEM>& itemsList	//returned array of pointers to inventory items that match this puid
	)
{
	int rcrd;
	int iCatalogIndex;
	int iTotalrecords;
	int iTotalItems;
	CCatalog* pCatalog;
	PINVENTORY_ITEM pItem;

	iTotalItems = 0;

	for (iCatalogIndex=0; iCatalogIndex<m_iTotalCatalogs; iCatalogIndex++)
	{
		pCatalog = m_vState[iCatalogIndex].pCatalog;
		iTotalrecords = pCatalog->GetHeader()->totalItems;

		for (rcrd=0; rcrd<iTotalrecords; rcrd++)
		{
			//Note: This is specially coded for speed since this code is potentially run for
			//each record in each catalog in the state store.

			if (NULL == (pItem = pCatalog->GetItem(rcrd)))
			{
				continue;
			}
			switch (pItem->recordType)
			{
				case WU_TYPE_ACTIVE_SETUP_RECORD:
					if (puid == pItem->pf->a.puid)
						itemsList[iTotalItems++] = pItem;
					break;

				case WU_TYPE_CDM_RECORD:
					if (puid == pItem->pf->d.puid)
						itemsList[iTotalItems++] = pItem;
					break;

				case WU_TYPE_RECORD_TYPE_PRINTER:
					if (puid == pItem->pf->d.puid)
						itemsList[iTotalItems++] = pItem;
					break;

				case WU_TYPE_SECTION_RECORD:	
				case WU_TYPE_SUBSECTION_RECORD:
				case WU_TYPE_SUBSUBSECTION_RECORD:
					if (puid == pItem->pf->s.puid)
						itemsList[iTotalItems++] = pItem;
					break;
			}
		}
	}

	return iTotalItems;
}



//----------------------------------------------------------------------
// CState::CheckTrustedServer
//  Checks if the server provided in pDownload class is trusted by 
//  looking at the cache and/or ident.cab
//  
// Returns: 
//  No return value but throws exceptions if server is not trusted
//----------------------------------------------------------------------
void CState::CheckTrustedServer(LPCTSTR pszIdentServer, CDiamond* pDiamond)
{
	const TCHAR IDENTCABFN[] = _T("ident.cab");
	const TCHAR IDENTINIFN[] = _T("ident.ini");
	const TCHAR CABPOOL_SEC[] = _T("CabPools");
	const TCHAR SITE_SEC[] = _T("V3");
	const TCHAR CONTENT_SEC[] = _T("content31");
	
	BOOL bTrusted = FALSE;
	TCHAR szServer[MAX_PATH];
	int i;

	lstrcpy(szServer, pszIdentServer);
	if (szServer[0] == _T('\0'))
	{
		throw HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	}

	//
	// check in our cache to see if the server is already trusted
	//
	for (i = 0; i < m_cTrustedServers; i++)
	{
		if (lstrcmpi(szServer, m_vTrustedServers[i].szServerName) == 0)
		{
			bTrusted = TRUE;
			break;
		}
	}

	if (!bTrusted)
	{
		//
		// if not found in cache, download ident.cab from the server
		//
		CWUDownload	dlIdent(szServer, 8192);
		TCHAR szServerFile[MAX_PATH];
		TCHAR szLocalFile[MAX_PATH];

		lstrcpy(szServerFile, szServer);
		lstrcat(szServerFile, _T("/"));
		lstrcat(szServerFile, IDENTCABFN);


        GetWindowsUpdateDirectory(szLocalFile);
		lstrcat(szLocalFile, IDENTCABFN);

        if(!dlIdent.s_fOffline) // AU sets this static flag for offline detection
        {
            //
		    // always download a new ident.cab if we're not doing offline detection
		    //
		    
		    DeleteFile(szLocalFile);
        }

		if (!dlIdent.Copy(IDENTCABFN, NULL, NULL, NULL, CACHE_FILE_LOCALLY, NULL))
		{
			TRACE("Could not download ident.cab from %s", szServer);
			throw HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		}
		CConnSpeed::Learn(dlIdent.GetCopySize(), dlIdent.GetCopyTime());

		//
		// check trust using VerifyFile (see WU#12251)
		//
		HRESULT hr = S_OK;

        BOOL fIsAU = (WUV3_CLIENT_AUTOUPDATE == m_nClient);
                

		if (FAILED(hr = VerifyFile(szLocalFile, !fIsAU ))) // don't show UI for AU
		{
            TRACE("Trust failure on %s, code 0x%08x", szServerFile, hr);
			throw hr;
		}
		else
		{
			if (!pDiamond->IsValidCAB(szLocalFile))
			{
				TRACE("%s is not a valid CAB file", szServerFile);
				throw HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			}
			else
			{
				//
				// extract the .INI 
				//
				TCHAR szIniFile[MAX_PATH];
				TCHAR szKey[64];
				TCHAR szSecKey[64];
				int iServerCount;
				int iServerNo;
				int iDefaultNo;
				int iRootNo;
				TCHAR szValue[MAX_PATH];
				HRESULT hr;
				
				GetWindowsUpdateDirectory(szIniFile);
				lstrcat(szIniFile, IDENTINIFN);
				DeleteFile(szIniFile);

				if (!pDiamond->Decompress(szLocalFile, szIniFile))
					throw HRESULT_FROM_WIN32(GetLastError());

				//
				// process the the [CabPools] section in the .INI
				//
				iDefaultNo = (int)GetPrivateProfileInt(CABPOOL_SEC, _T("Default"), 1, szIniFile);
				iServerCount = (int)GetPrivateProfileInt(CABPOOL_SEC, _T("ServerCount"), 0, szIniFile);
				if (iServerCount > 0)
				{
					for (iServerNo = 1; iServerNo <= iServerCount; iServerNo++)
					{
						wsprintf(szKey, _T("Server%d"), iServerNo);
						if (GetPrivateProfileString(CABPOOL_SEC, szKey, _T(""), szValue, sizeof(szValue) / sizeof(TCHAR), szIniFile) == 0)
						{
							TRACE("Missing [%s]/%s in %s", CABPOOL_SEC, szKey, szServerFile);
							continue;
						}
						
						if (iServerNo == iDefaultNo)
						{
							m_iCabPoolServer = m_cTrustedServers;
						}

						m_vTrustedServers[m_cTrustedServers].iServerType = SERVERTYPE_CABPOOL;
						lstrcpy(m_vTrustedServers[m_cTrustedServers].szServerName, szValue);
						m_cTrustedServers++;
					}
				}

				//
				// process the the [V3] (this is the site) section in the .INI
				//
				iDefaultNo = (int)GetPrivateProfileInt(SITE_SEC, _T("Default"), 1, szIniFile);
				iServerCount = (int)GetPrivateProfileInt(SITE_SEC, _T("ServerCount"), 0, szIniFile);
				if (iServerCount > 0)
				{
					for (iServerNo = 1; iServerNo <= iServerCount; iServerNo++)
					{
						wsprintf(szKey, _T("Server%d"), iServerNo);
						if (GetPrivateProfileString(SITE_SEC, szKey, _T(""), szValue, sizeof(szValue) / sizeof(TCHAR), szIniFile) == 0)
						{
							TRACE("Missing [%s]/%s in %s", SITE_SEC, szKey, szServerFile);
							continue;
						}

						if (iServerNo == iDefaultNo)
						{
							m_iSiteServer = m_cTrustedServers;
						}
						
						m_vTrustedServers[m_cTrustedServers].iServerType = SERVERTYPE_SITE;
						lstrcpy(m_vTrustedServers[m_cTrustedServers].szServerName, szValue);
						m_cTrustedServers++;
					}
				}

				//
				// process the the [content31] section in the .INI
				//
				iDefaultNo = (int)GetPrivateProfileInt(CONTENT_SEC, _T("Default"), 1, szIniFile);
				iRootNo = (int)GetPrivateProfileInt(CONTENT_SEC, _T("Root"), 1, szIniFile);
				iServerCount = (int)GetPrivateProfileInt(CONTENT_SEC, _T("ServerCount"), 0, szIniFile);

				if (iServerCount > 0)
				{
					for (iServerNo = 1; iServerNo <= iServerCount; iServerNo++)
					{
						wsprintf(szKey, _T("Server%d"), iServerNo);
						if (GetPrivateProfileString(CONTENT_SEC, szKey, _T(""), szValue, sizeof(szValue) / sizeof(TCHAR), szIniFile) == 0)
						{
							TRACE("Missing [%s]/%s in %s", CONTENT_SEC, szKey, szServerFile);
							continue;
						}

						if (iServerNo == iDefaultNo)
						{
							m_iContentServer = m_cTrustedServers;
						}

						if (iServerNo == iRootNo)
						{
							m_iRootServer = m_cTrustedServers;
						}
						
						m_vTrustedServers[m_cTrustedServers].iServerType = SERVERTYPE_CONTENT;
						lstrcpy(m_vTrustedServers[m_cTrustedServers].szServerName, szValue);
						m_cTrustedServers++;
					}
				}

				if (m_iRootServer == 0 || m_iContentServer == 0)
				{
					TRACE("IDENT: Content or root server not specified");
				}
							
			}

		} // checktrust

		//
		// check in our cache again to see if the server is trusted
		//
		for (i = 0; i < m_cTrustedServers; i++)
		{
			if (lstrcmpi(szServer, m_vTrustedServers[i].szServerName) == 0)
			{
				bTrusted = TRUE;
				m_iIdentServer = i;
				break;
			}
		}

	}

	if (!bTrusted)
		throw HRESULT_FROM_WIN32(TRUST_E_FAIL);
}

//----------------------------------------------------------------------
// CState::ValidateSiteURL()
//  Checks if the hostname in the site url set with SetSiteURL()
//  matches any of the site hosts listed in ident.cab
//
// Returns: 
//  TRUE if the hostname matches one of the trusted sites
//  FALSE if the hostname doesn't match any of the trusted sites
//----------------------------------------------------------------------
BOOL CState::ValidateSiteURL()
{
	URL_COMPONENTS url;
	TCHAR szControlHost[128] = {_T('\0')};
	TCHAR szTrustedHost[128] = {_T('\0')};
	BOOL bRet = FALSE;

	// crack the site URL to host name 
	ZeroMemory(&url, sizeof(url)); 
	url.dwStructSize = sizeof(url); 
	url.lpszHostName = szControlHost;
	url.dwHostNameLength = sizeOfArray(szControlHost);

	if (InternetCrackUrl(m_szSiteURL, 0, 0, &url))
	{

		url.lpszHostName = szTrustedHost;
		url.dwHostNameLength = sizeOfArray(szTrustedHost);

		// loop through our trusted servers and check
		// each site server
		for (int i = 0; i < m_cTrustedServers; i++)
		{
			if (m_vTrustedServers[i].iServerType == SERVERTYPE_SITE)
			{
				// crack this url 
				if (InternetCrackUrl(m_vTrustedServers[i].szServerName, 0, 0, &url))
				{
					TRACE("ValidateSiteURL: comparing %s and %s", szTrustedHost, szControlHost);
					if (lstrcmpi(szTrustedHost, szControlHost) == 0)
					{
						i = m_cTrustedServers;
						bRet = TRUE;
					}
				}
			}
		}
	}

	return bRet;
}


//----------------------------------------------------------------------
// CState::CacheDLLName
//  Checks if the DLL provided was downloaded in this session, caches
//  the name if its not there
//  
// Returns: 
//  TRUE if already in cache
//  FALSE if not in cache (and adds to cache)
//----------------------------------------------------------------------
BOOL CState::CacheDLLName(LPCTSTR pszDLLName)
{
	BOOL bAlreadyDone = FALSE;
	for (int i = 0; i < m_cDetDLLs; i++)
	{
		if (lstrcmpi(pszDLLName, m_vDetDLLs[i].szDLLName) == 0)
		{
			bAlreadyDone = TRUE;
			break;
		}
	}
	if (bAlreadyDone)
	{
		return TRUE;
	}
	else
	{
		lstrcpy(m_vDetDLLs[m_cDetDLLs].szDLLName, pszDLLName);
		m_cDetDLLs++;
		return FALSE;
	}
}

// this function is used by CleanupAndReboot to determine
// if the message box needs to be flipped for Arabic & Hebrew systems
DWORD CState::GetBrowserLocale()
{
	DWORD dwLocale = 0;
	if ((m_iTotalCatalogs > 0) && (NULL != m_vState[0].pCatalog))
	{
		dwLocale = m_vState[0].pCatalog->GetBrowserLocaleDW();
	}

	return dwLocale;
}


//Selected for install class items constructor simply clear the total selected items.
CSelectItems::CSelectItems(void)
{
	//There are no selected items when control is first loaded.
	m_iTotalItems = 0;
}


//This method selects an item for installation.
void CSelectItems::Select(
	PUID puid,		//Inventory catalog item identifier to be selected.
	BOOL bInstall	//If TRUE then the item is being selected for installation.
					//If FALSE the item is being selected for installation.
	)
{

	//First see if item is in puid array
	for(int i = 0; i < m_iTotalItems; i++)
	{
		if ( m_info[i].puid == puid )
		{
			m_info[i].iCount++;
			if ( m_info[i].bInstall != bInstall )
			{
				//The state of the item needs to be changed however note
				//we do not add an additional item to the uninstall array.
				m_info[i].bInstall = bInstall;
				return;
			}
			else
				return;	//nothing to do item is already in array and is the correct state.
		}
	}

	m_info[m_iTotalItems].puid = puid;
	m_info[m_iTotalItems].iStatus = ITEM_STATUS_SUCCESS;
	m_info[m_iTotalItems].hrError = NOERROR;
	m_info[m_iTotalItems].iCount = 1;	//one item is currently using needing this item to be installed.

	ZeroMemory(&m_info[m_iTotalItems].stDateTime, sizeof(SYSTEMTIME));

	m_info[m_iTotalItems].bInstall = bInstall;

	m_iTotalItems++;

	return;
}

//This method unselects an item.
void CSelectItems::Unselect(
	PUID puid	//Inventory catalog item identifier to be un-selected.
	)
{
	int i;

	//if there are no items in puid array noting to do.
	if ( m_iTotalItems == 0 )
		return;

	//First see if item is in puid array
	for (i=0; i < m_iTotalItems; i++)
	{
		if ( m_info[i].puid == puid )
			break;
	}
	//if item is not in array then nothing to unselect.
	if ( i == m_iTotalItems )
		return;

	m_info[i].iCount--;

	//if no one is needing this item installed
	//removed it from the array.
	if ( m_info[i].iCount == 0 )
	{
		//move all items in array up beginning at this items index.
		if (m_iTotalItems > (i + 1))
		{
			memcpy(&m_info[i].puid, &m_info[i+1].puid, (m_iTotalItems - i) * sizeof(m_info[0]));
		}

		//Decrement total items in puid array.
		m_iTotalItems--;
	}
}


//This method is called when an installation is performed to remove the specified item from the
//selected items array.  It removes the item regardless of usage count. 
//
//If puid=0, all items are removed
void CSelectItems::Clear()
{
	m_iTotalItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\selection.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    Selection.cpp:
//
//  Purpose:implementation of the CSelections class.
//
//=======================================================================
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <atlconv.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSelections::CSelections()
{
	m_pSelections	= NULL;
	m_iSize			= 0;
	m_iCount		= 0;
}

CSelections::CSelections(int iSize)
{
	m_pSelections = NULL;
	SetCollectionSize(iSize);
}

CSelections::~CSelections()
{
	Clear();
}



HRESULT CSelections::SetCollectionSize(int iSize)
{
	Clear();

	m_pSelections = (PCORP_SELECTION) malloc(sizeof(CORP_SELECTION) * iSize);

	if (NULL == m_pSelections)
	{
		return E_OUTOFMEMORY;
	}

	ZeroMemory(m_pSelections, sizeof(m_pSelections));
	m_iSize	= iSize;

	return S_OK;
}

void CSelections::Clear()
{
	if (NULL != m_pSelections)
	{
		free(m_pSelections);
		m_iSize		= 0;
		m_iCount	= 0;
	}
	return;
}


HRESULT CSelections::AddItem(CORP_SELECTION Item)
{
	if (m_iCount >= m_iSize)
	{	
		return E_OUTOFMEMORY;
	}

	m_pSelections[m_iCount++] = Item;

	return S_OK;
}

HRESULT CSelections::AddItem(PUID puid, DWORD dwLocale, enumV3Platform platform, BOOL bSelected)
{
	CORP_SELECTION Item;
	Item.puid = puid;
	Item.dwLocale = dwLocale;
	Item.platform = platform;
	Item.bSelected = bSelected;

	return AddItem(Item);
}



PCORP_SELECTION CSelections::GetItem(int Index)
{
	if (Index < 0 || Index >= m_iCount)
	{
		//
		// bad index, return NULL ptr
		//
		return NULL;
	}
	else
	{
		return &(m_pSelections[Index]);
	}
}


HRESULT CSelections::SetItemSelection(int index, BOOL bSelected)
{
	if (index < 0 || index >= m_iCount)
	{
		return E_INVALIDARG;
	}

	m_pSelections[index].bSelected = bSelected;

	return S_OK;
}



HRESULT CSelections::SetItemErrorCode(int index, HRESULT hr)
{
	if (index < 0 || index >= m_iCount)
	{
		return E_INVALIDARG;
	}

	m_pSelections[index].hrError = hr;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\ccatalog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    ccatalog.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>
#include <string.h>
#include <findoem.h>
#include <search.h>   // for bsearch
#include "log.h"


#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include <speed.h>
#include <debug.h>

#ifndef ARRAYSIZE
    #define ARRAYSIZE(x)	(sizeof(x)/sizeof((x)[0]))
#endif


typedef struct _TPARAMS
{
    CCatalog   *lpCatalog;
    DWORD       dwIndex;
} TPARAMS, *LPTPARAMS;


struct GANGINDEX
{
	PUID puid;
	DWORD dwOfs;
};


ULONG WINAPI Worker(LPVOID lpThreadParams);
static int __cdecl CompareGANGINDEX(const void* p1, const void* p2);


CCatalog::CCatalog(
	LPCTSTR szServer,		// Server and share catalog is stored at.
	PUID  puidCatalog	// PUID identifier of catalog.
	)
{
	
	m_hdr.version		= 1;			//version of the catalog (this allows for future expansion)
	m_hdr.totalItems	= 0;
	m_hdr.sortOrder		= 0;			//catalog sort order. 0 is the default and means use the position value of the record within the catalog.
	m_pBuffer			= NULL;			//internal buffer allocated by and used by readcatalog().

	m_puidCatalog		= puidCatalog;

	if (szServer) 
	{
		lstrcpy(m_szServer, szServer);
		RemoveLastSlash(m_szServer);
	}
	else
	{
		m_szServer[0] = _T('\0');
	}

	m_szBrowserLocale[0] = _T('\0');
	m_szMachineLocale[0] = _T('\0');
    m_szUserLocale[0] = _T('\0');

	m_bLocalesDifferent = FALSE;

    m_bTerminateWorkers = FALSE;
    m_lpWorkQueue = NULL;
    m_mutexWQ = CreateMutex(NULL, FALSE, NULL);
    m_mutexDiamond = CreateMutex(NULL, FALSE, NULL);

    ZeroMemory((LPVOID)&m_hWorkers, sizeof(m_hWorkers));
    ZeroMemory((LPVOID)&m_hEvents, sizeof(m_hEvents));

	m_pGangDesc = NULL;

	m_szBaseName[0] = _T('\0');
	m_szBitmaskName[0] = _T('\0');
}


CCatalog::~CCatalog()
{

	// free up inventory pointers for state, description, 
	for (int i=0; i<m_hdr.totalItems;i++)
	{
		// before accessing m_items[i] check to see that it is not NULL
		if (NULL == m_items[i]) 
		{
			continue;
		}

		if (m_items[i]->ps)
			V3_free(m_items[i]->ps);

		// we only free pd if we have allocated it.  In case of ganged descriptions, we did not allocate
		if (m_pGangDesc == NULL)
		{
			if (m_items[i]->pd)
				V3_free(m_items[i]->pd);
		}

		if (m_items[i])
			V3_free((PVOID)m_items[i]);

		m_items[i] = (PINVENTORY_ITEM)NULL;
	}

	if ( m_pBuffer )
		V3_free(m_pBuffer);

	if (m_pGangDesc)
		V3_free(m_pGangDesc);

	TerminateWorkers();

    if (m_mutexWQ) {
        CloseHandle(m_mutexWQ);
        m_mutexWQ = NULL;
    }
    if (m_mutexDiamond) {
        CloseHandle(m_mutexDiamond);
        m_mutexDiamond = NULL;
    }

}


// adds a memory inventory item to a catalog
void CCatalog::AddItem(
	IN	PINVENTORY_ITEM	pItem		//Pointer to inventory item to be added to memory catalog file
	)
{
	m_items[m_hdr.totalItems++] = pItem;
}



// reads an inventory catalog's items from an http server
void CCatalog::Read(
	IN	CWUDownload		*pDownload,		//pointer to internet server download class.
	IN	CDiamond		*pDiamond		//pointer to diamond de-compression class.
	)
{
	LOG_block("CCatalog::Read"); 

	TCHAR	szPath[MAX_PATH];
	PBYTE	pMem;
	int		iMemLen;

	// if the buffer exists then do not allow the catalog to be read.
	if (m_pBuffer)
		throw HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);

	// The following 2 lines were added to avoid crashes
	if ((NULL == pDownload) || (NULL == pDiamond))
		return ;

	if (!m_puidCatalog)
	{
		// catalog list
		lstrcpy(szPath, _T("inventory.plt"));
	}
	else
	{
		// regular catalog

		// download the redir file based on machine language
		
		TCHAR szLocalFile[MAX_PATH];
		TCHAR szLocalPath[MAX_PATH];
		GetWindowsUpdateDirectory(szLocalFile);
		
		wsprintf(szPath, _T("%d/%s.as"), m_puidCatalog, GetMachineLocaleSZ());
		wsprintf(szLocalPath,_T("%s%d_%s.as"),szLocalFile,m_puidCatalog,GetMachineLocaleSZ());

        if(!pDownload->s_fOffline)
        {
		    DeleteFile(szLocalPath);
        }

		if (pDownload->Copy(szPath, NULL, NULL, NULL, CACHE_FILE_LOCALLY, NULL))
		{
			TCHAR szBaseName[64];

			// build locale redir file name
			wsprintf(szBaseName, _T("%d_%s.as"), m_puidCatalog, GetMachineLocaleSZ());

			GetWindowsUpdateDirectory(szLocalFile);
			lstrcat(szLocalFile, szBaseName);

			if (GetPrivateProfileString(_T("redir"), _T("invCRC"), _T(""), szBaseName, sizeof(szBaseName)/sizeof(TCHAR), szLocalFile) != 0)
			{
				TRACE("Catalog %d Redir CRC %s", m_puidCatalog, szBaseName);
				lstrcpy(m_szBaseName, szBaseName);
			}

			if (GetPrivateProfileString(_T("redir"), _T("bmCRC"), _T(""), szBaseName, sizeof(szBaseName)/sizeof(TCHAR), szLocalFile) != 0)
			{
				TRACE("Bitmask %d Redir CRC %s", m_puidCatalog, szBaseName);
				lstrcpy(m_szBitmaskName, szBaseName);
			}

		}

		if (m_szBaseName[0] == _T('\0') || m_szBitmaskName[0] == _T('\0'))
		{
			TRACE("Could not read inventory and bitmask CRC name from %s", szPath);
			throw HRESULT_FROM_WIN32(ERROR_CRC);
		}

		// build the file name for the inventory list
		wsprintf(szPath, _T("%d/%s.inv"), m_puidCatalog, m_szBaseName);
	}

	//
	// read the inventory list file
	//
	DWORD dwSize;
	HRESULT hr = DownloadFileToMem(pDownload, szPath, pDiamond, &m_pBuffer, &dwSize);
	if (FAILED(hr))
	{
		throw hr;
	}

	Parse(m_pBuffer);
	return;
}


//read and attaches a description file to an inventory catalog item record.
HRESULT CCatalog::ReadDescription(
	IN	CWUDownload	*pDownload,		//pointer to internet server download class.
	IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
	IN  PINVENTORY_ITEM	pItem,		//Pointer to item to attach description to.
	IN  CCRCMapFile* pIndex,
	OUT DWORD *pdwDisp
	)
{
	
	int	iMemOutLen;
	TCHAR szPath[MAX_PATH];
	TCHAR szBase[64];
	TCHAR szCRCName[64];
	PWU_DESCRIPTION	pd;
	HRESULT hr = S_OK;

	//check input arguments
	if (NULL == pDownload || NULL == pDiamond || NULL == pItem)
	{
		return E_INVALIDARG;
	}

	if (pItem->pd)
	{
		// if description already exists simply return
		return hr;
	}

	// 
	// build file name
	//
	wsprintf(szBase, _T("%d.des"), pItem->GetPuid());
	hr = pIndex->GetCRCName((DWORD)(pItem->GetPuid()), szBase, szCRCName, sizeof(szCRCName));

	if (FAILED(hr))
	{
		// if we didn't find the puid in the map file, we'll want to remove this item from the catalog
        if (NULL != pdwDisp)
        {
            *pdwDisp = DISP_PUID_NOT_IN_MAP;
        }
		return hr;
	}
	wsprintf(szPath, _T("CRCDesc/%s"), szCRCName);

	// download the file
	hr = DownloadFileToMem(pDownload, szPath, pDiamond, (BYTE**)&pd, (DWORD*)&iMemOutLen);

	if (SUCCEEDED(hr))
	{
		// fix up description variable field pointer
		pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION));
		pItem->pd = pd;
	}
	else
    {
        // if we failed to download this description, remove it from the catalog
        if (NULL != pdwDisp)
        {
            *pdwDisp = DISP_DESC_NOT_FOUND;
        }
    }

    return hr;
}


// attaches a blank description file to an inventory catalog item record.
HRESULT CCatalog::BlankDescription(
	IN  PINVENTORY_ITEM	pItem	
	)
{
	PWU_DESCRIPTION	pd;
	HRESULT hr = S_OK;

	// allocate and clear memory
	pd = (PWU_DESCRIPTION)V3_malloc(sizeof(WU_DESCRIPTION) + sizeof(WU_VARIABLE_FIELD));
	ZeroMemory(pd, (sizeof(WU_DESCRIPTION) + sizeof(WU_VARIABLE_FIELD)));

	// set up the location pointer for the VARIABLE_FIELD since its in a single block of memory. 
	// this will be realloced by AddVariableSizeField()
	pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION));
	pd->pv->id = WU_VARIABLE_END;
	pd->pv->len = sizeof(WU_VARIABLE_FIELD);

	pItem->pd = pd;

    return hr;
}




HRESULT CCatalog::ReadDescriptionGang(
	IN	CWUDownload	*pDownload,		//pointer to internet server download class.
	IN	CDiamond	*pDiamond		//pointer to diamond de-compression class.
	)
{
	HRESULT hr = S_OK;
	TCHAR szPath[MAX_PATH];
	PBYTE pMem;
	int	iMemLen;
	PINVENTORY_ITEM pItem;
	PWU_DESCRIPTION	pd;

	// build gang desciption file name
	wsprintf(szPath, _T("%d/%s.gng"), m_puidCatalog, GetBrowserLocaleSZ());

	CConnSpeed::Learn(pDownload->GetCopySize(), pDownload->GetCopyTime());

	DWORD dwSize;
	hr = DownloadFileToMem(pDownload, szPath, pDiamond, &m_pGangDesc, &dwSize);
	if (FAILED(hr))
	{
		return hr;
	}

	// gang description layout:
	//    DWORD version
	//    DWORD count
	//
	//    DWORD puid1, DWORD ofs1 
	//    DWORD puid2, DWORD ofs2
	//    ...
	//    DWORD 0xFFFFFFFF, DWORD sentinalofs
	//
	//    BLOB1
	//    BLOB2
	//    ...
	//    BLOB(count)

	// 
	// initialize variables from the memory buffer
	//	 count 
	//   begining offset of blobs, and
	//   pointer to the index of puid and ofs
	//
	DWORD dwCount = *(((DWORD*)m_pGangDesc) + 1);
	DWORD dwBlobOfs = (1 + 1) * 4 + ((dwCount + 1) * 8);
	GANGINDEX* pIndex = (GANGINDEX*)(((DWORD*)m_pGangDesc) + 2);
	int cFound = 0;

	if (dwCount == 0)
	{
		// we must have at least one item 
		return E_FAIL;
	}

	// 
	// go through the inventory list and read descriptions
	//
	for (int i = 0; i < m_hdr.totalItems; i++) 
	{

        pItem = GetItem(i);

	if(NULL == pItem || NULL == pItem->ps )
	{
		continue;
	}

        if (pItem->ps->state != WU_ITEM_STATE_PRUNED)
		{
			// if the item is not pruned we need to get description for it
			GANGINDEX* pEntry;
			GANGINDEX key;

			// binary search to find the item
			key.puid = pItem->GetPuid();

			// if GetPuid returned 0 or -1, the description is corrupted and we'll need tp get an individual description
			if(key.puid < 1)
			{
				continue;
			}

			pEntry = (GANGINDEX*)bsearch((void*)&key, (void*)pIndex, dwCount, sizeof(GANGINDEX), CompareGANGINDEX);

			if (pEntry != NULL)
			{
				//
				// found description for this puid, calculate the ofs and len of its blob
				// the len is calculated by subtracting this ofs from next ofs
				//
				DWORD dwOfs = (pEntry++)->dwOfs;
				DWORD dwLen = pEntry->dwOfs - dwOfs;

				// add begining blob ofs to the ofs
				dwOfs += dwBlobOfs;
	
				// 
				// attach the description (m_pGangDesc is PBYTE)
				//
				pd = (PWU_DESCRIPTION)(m_pGangDesc + dwOfs);

				if(NULL == pd || NULL == pd->pv)
				{
					continue;
				}

				pd->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pd) + sizeof(WU_DESCRIPTION));
				pItem->pd = pd;

				cFound++;
			}
			else
			{
				TRACE("GangDesc: PUID %d not found", key.puid);
				// NOTE: we don't error out in case we don't find a description for a PUID
				//       this allows us to revert back to loading individual description for 
				//		 this item later
			}
		}
	} // for

	TRACE("GangDesc Count=%d, InvCount=%d, Found=%d", dwCount, m_hdr.totalItems, cFound);

	return S_OK;
}




LPWORKERQUEUEENTRY CCatalog::DeQueue()
{
    WaitForSingleObject(m_mutexWQ, INFINITE); 

    LPWORKERQUEUEENTRY lptmp = m_lpWorkQueue;
    if (lptmp)
        m_lpWorkQueue = lptmp->Next;
    ReleaseMutex(m_mutexWQ);

    return lptmp;
}


LPWORKERQUEUEENTRY CCatalog::EnQueue(LPWORKERQUEUEENTRY lpwqe)
{
    if (m_bTerminateWorkers)
        return NULL;

    WaitForSingleObject(m_mutexWQ, INFINITE); 
    if (!m_lpWorkQueue) {
        m_lpWorkQueue = lpwqe;
        lpwqe->Next = NULL;
    } else {
        lpwqe->Next = m_lpWorkQueue;
        m_lpWorkQueue = lpwqe;
    }
    ReleaseMutex(m_mutexWQ);

    return m_lpWorkQueue;
}


void CCatalog::TerminateWorkers()
{
    m_bTerminateWorkers = TRUE;

    // Purge the queue
    PurgeQueue();

    for (int i=0;i < ARRAYSIZE(m_hWorkers); i++) {
        CloseHandle(m_hWorkers[i].hThread);
        CloseHandle(m_hEvents[i]);
        m_hWorkers[i].hThread = NULL;
        m_hEvents[i] = NULL;
    }
}


void CCatalog::PurgeQueue()
{
    LPWORKERQUEUEENTRY lpqe = NULL;

    while (lpqe = DeQueue()) {
        V3_free(lpqe);
    }

    m_lpWorkQueue = NULL;
}


ULONG WINAPI Worker(LPVOID lpThreadParams)
{

    LPTPARAMS          lptp = (LPTPARAMS) lpThreadParams;
    HRESULT            hr = S_OK;

    if (!lptp) {
        ExitThread(0);
        return 0;
    }

    CCatalog           *lpc = lptp->lpCatalog;
    DWORD               dwIndex = lptp->dwIndex;
    LPWORKERQUEUEENTRY  lpqe = NULL;

    // Not needed any more
    V3_free(lptp);

    if (!lpc) 
	{
        ExitThread(S_FALSE);
        return S_FALSE;
    }

    do {
        lpqe = lpc->DeQueue();

        if (lpqe) 
		{
			if (lpqe->pItem->ps->state != WU_ITEM_STATE_PRUNED) 
			{
                     hr = lpc->ReadDescription(lpqe->lpdl, lpqe->lpdm, lpqe->pItem, NULL);  //BUGBUG: we dont have a CRC index
					 TRACE ("Worker readdescription returned 0x%lx", hr);
			}
			
            V3_free(lpqe);

            // In the previous architecture, ReadDescription() would throw
            // an exception and terminate this thread.  As such, we will
            // maintain that same behavior.  We should change it soon, tho.
            if (FAILED(hr)) 
			{
                TRACE("Worker finished with work");
                SetEvent(lpc->m_hEvents[dwIndex]);
                ExitThread(hr);
                return hr;
            }
        } else 
		{

            TRACE("Worker finished with work");
            // No more work for this thread
            SetEvent(lpc->m_hEvents[dwIndex]);
            ExitThread(S_OK);
            return S_OK;
        }

    } while (!lpc->m_bTerminateWorkers);

    ExitThread(S_FALSE);
    return S_FALSE;

}

//
//
//  ReadDescriptionEx executes in the caller's main thread
//
//
HRESULT CCatalog::ReadDescriptionEx(
	IN	CWUDownload	*pDownload,		//pointer to internet server download class.
	IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
	IN  PINVENTORY_ITEM	pItem		//Pointer to item to attach description to.
	)
{
	int	iMemInLen;
	int	iMemOutLen;
	char szPath[MAX_PATH];
	PVOID pMemIn;
	DWORD dwPlat;
	PWU_DESCRIPTION	pd;
    HRESULT hr = S_OK;
        

    // if pItem is non-null, just use ReadDescription directly
    if (pItem) {
        hr = ReadDescription (pDownload, pDiamond, pItem, NULL);  // BUGBUG: we don't have CRC index
        if (FAILED(hr)) {
            throw (hr);
        }
        return hr;
    }

    if (!m_hWorkers[0].hThread) {
        DWORD   dwDummyTid;
//        UINT    uiDummyTid;

        // Grab the work queue mutex
        WaitForSingleObject (m_mutexWQ, INFINITE);

        // Start our worker threads
        for (int i = 0; i < ARRAYSIZE(m_hWorkers); i++) {
            LPTPARAMS lpTParams = (LPTPARAMS) V3_malloc(sizeof(TPARAMS));

            if (lpTParams) {
                lpTParams->lpCatalog = this;
                lpTParams->dwIndex = i;
                m_hEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
                m_hWorkers[i].dwIndex = i ;
                m_hWorkers[i].hThread = CreateThread(NULL, 0, 
                                             (LPTHREAD_START_ROUTINE)&Worker,
                                             lpTParams, 0, &dwDummyTid);


                if(m_hWorkers[i].hThread == NULL) {
                    V3_free(lpTParams);
                }

                TRACE("::CCatalog() created worker TID 0x%lx", dwDummyTid);
            }
        }
    }

    for (int i=0; i < m_hdr.totalItems; i++) {
        LPWORKERQUEUEENTRY lpwqe = (LPWORKERQUEUEENTRY) V3_malloc(sizeof(WORKERQUEUEENTRY));
        PINVENTORY_ITEM     pItem = NULL;

        pItem = GetItem(i);

		if (NULL == pItem)
		{
			TRACE ("ReadDescriptionEx():  GetItem returned NULL for index i = %d", i);	
			continue;
		}

		// check memory allocated, plus item pointers
        if ( lpwqe  && pItem && pItem->ps ) {

            if (pItem->ps->state != WU_ITEM_STATE_PRUNED) {

                lpwqe->lpdl = pDownload;
                lpwqe->lpdm = pDiamond;
                lpwqe->pItem = pItem;
                lpwqe->Next = NULL;

                if (!EnQueue(lpwqe)) {
                    V3_free(lpwqe);
                } else {
                    // Worker() now owns freeing the
                    // memory for the queue entries.
                    // lpwqe is invalid below here

                    continue; 
                }
            } else 
                continue;  // if we were just pruned, don't fall thru
        }

        // if we are here, we failed to enqueue, so we'll read on this thread

        if (pItem->ps->state != WU_ITEM_STATE_PRUNED) {
            TRACE ("ReadDescriptionEx():  Reading on main thread");
            ReadDescription(pDownload, pDiamond, pItem, NULL);   // BUGBUG: we dont have a CRC index
        }
    }

    // If we finished the loop and we have work to do, wait for it to finish

    if (i == m_hdr.totalItems && m_lpWorkQueue) {
		TRACE("Releasing Work Queue");
        ReleaseMutex(m_mutexWQ);   // Start the action
        WaitForMultipleObjects (ARRAYSIZE(m_hEvents), m_hEvents, TRUE, INFINITE);

        // if any workers threw an exception, it already killed itself and
        // returned the HRESULT as an exit code.  

        for (int i = 0; i < ARRAYSIZE(m_hWorkers) ; i ++) {
            BOOL    b;

            b = GetExitCodeThread(m_hWorkers[i].hThread, (LPDWORD)&hr);
            if (b) {
                if (FAILED(hr)) {
                    break;
                }
            }
        }
        // We don't need the workers any more; kill them.
        TerminateWorkers();
    }

    return hr;
}


// merges description from Machine Locale into the ALREADY LOADED Browser language description
// structure.  This function should be called only when the browser language is different than
// the machine language since this function will not do that check.  
HRESULT CCatalog::MergeDescription(
	CWUDownload* pDownload,		// internet server download class.
	CDiamond* pDiamond,			// diamond de-compression class.
	PINVENTORY_ITEM pItem,		// item to attach description to.
	CCRCMapFile* pIndex	        // must be for machine language	
	)
{
	LOG_block("CCatalog::MergeDescription");
	int	iMemOutLen;
	TCHAR szPath[MAX_PATH];
	PWU_DESCRIPTION	pMD;
	int iSize;
	PWU_DESCRIPTION pDesc;
	HRESULT hr = S_OK;
	TCHAR szBase[64];
	TCHAR szCRCName[64];

	if (pItem->pd == NULL)
	{
		return hr;
	}

	// 
	// build file name
	//
	wsprintf(szBase, _T("%d.des"), pItem->GetPuid());
	hr = pIndex->GetCRCName((DWORD)(pItem->GetPuid()), szBase, szCRCName, sizeof(szCRCName));

	if (FAILED(hr))
	{
		return hr;
	}
	wsprintf(szPath, _T("CRCDesc/%s"), szCRCName);

	// FOR TESTING WUV3IS, The following indicates the description item which is added to the variable field. It is logged in case of errors.
	DWORD dwDescriptionFileItem = 0;	

	//
	// clone the description to a new memory buffer since pd will be pointing into the gang
	// description array. 
	//
	try
	{
		iSize = sizeof(WU_DESCRIPTION) + pItem->pd->pv->GetSize();
		pDesc = (PWU_DESCRIPTION)V3_malloc(iSize);
		memcpy(pDesc, pItem->pd, iSize);
		pItem->pd = pDesc;

		TRACE("MergeDescription: %s", szPath);
		
		// download the file
		hr = DownloadFileToMem(pDownload, szPath, pDiamond, (BYTE**)&pMD, (DWORD*)&iMemOutLen);
		if (FAILED(hr))
		{
			return hr;
		}

		// fix up the variable length fields
		pMD->pv = (PWU_VARIABLE_FIELD)(((PBYTE)pMD) + sizeof(WU_DESCRIPTION));

		//
		// we have the description in pMD, merge the setup related fields into Item->pd
		// to merge we find the field that already exists and replace its id with WU_VARIABLE_MERGEINACTIVE
		//
		PWU_VARIABLE_FIELD pMDField;
		PWU_VARIABLE_FIELD pItemField;
		
		// WU_DESCRIPTION_UNINSTALL_KEY
		dwDescriptionFileItem = WU_DESCRIPTION_UNINSTALL_KEY;
		pItemField = pItem->pd->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);

 
		// WU_DESC_CIF_CRC
		dwDescriptionFileItem = WU_DESC_CIF_CRC;
		pItemField = pItem->pd->pv->Find(WU_DESC_CIF_CRC);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESC_CIF_CRC);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);


		// WU_DESCRIPTION_CABFILENAME
		dwDescriptionFileItem = WU_DESCRIPTION_CABFILENAME;
		pItemField = pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESCRIPTION_CABFILENAME);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);


		// WU_DESCRIPTION_SERVERROOT
		dwDescriptionFileItem = WU_DESCRIPTION_SERVERROOT;
		pItemField = pItem->pd->pv->Find(WU_DESCRIPTION_SERVERROOT);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESCRIPTION_SERVERROOT);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);


		// WU_DESC_CRC_ARRAY
		dwDescriptionFileItem = WU_DESC_CRC_ARRAY;
		pItemField = pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESC_CRC_ARRAY);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);


		// WU_KEY_DEPENDSKEY
		dwDescriptionFileItem = WU_KEY_DEPENDSKEY;
		pItemField = pItem->pd->pv->Find(WU_KEY_DEPENDSKEY);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_KEY_DEPENDSKEY);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);


#ifdef _WUV3TEST
		// WU_DESC_DIAGINFO
		dwDescriptionFileItem = WU_DESC_DIAGINFO;
		pItemField = pItem->pd->pv->Find(WU_DESC_DIAGINFO);
		if (pItemField != NULL)
			pItemField->id = WU_VARIABLE_MERGEINACTIVE;

		pMDField = pMD->pv->Find(WU_DESC_DIAGINFO);
		if (pMDField != NULL)
			AddVariableSizeField(&(pItem->pd), pMDField);
#endif
	}
	catch(HRESULT hr)
	{
		LOG_out("Failed in the description item : %d", dwDescriptionFileItem);
		LOG_error("error %08X", hr);

		if (NULL != pMD)
		{	
			V3_free(pMD);
		}
		return hr;
	}

	V3_free(pMD);

	return S_OK;
}




// parses a binary character memory array into a memory catalog file format.
void CCatalog::Parse(
	IN	PBYTE	pCatalogBuffer			//decompressed raw catalog memory image from server.
	)
{
	int					i;
	PINVENTORY_ITEM		pItem;
	
	if (NULL == pCatalogBuffer)
			return;

	memcpy(&m_hdr, pCatalogBuffer, sizeof(m_hdr));

	//update pointer to actual inventory records
	pCatalogBuffer += sizeof(WU_CATALOG_HEADER);

	//process each inventory item
	for(i=0; i<m_hdr.totalItems && NULL != pCatalogBuffer; i++)
	{
		pItem = (PINVENTORY_ITEM)V3_malloc(sizeof(INVENTORY_ITEM));
		if (NULL == pItem)
			continue;

		memset(pItem, 0, sizeof(INVENTORY_ITEM));

		pCatalogBuffer = GetNextRecord(pCatalogBuffer, i, pItem);

		//We don't add this record by the normal interface because the total
		//number of records have already been set.
		m_items[i] = pItem;
	}
}


//returns a pointer to the next inventory record in an inventory record memory file.
PBYTE CCatalog::GetNextRecord
	(
		IN	PBYTE			pRecord,		//pointer to current inventory record
		IN	int				iBitmaskIndex,	//bitmask index for the current record
		IN	PINVENTORY_ITEM	pItem			//pointer to item structure that will be filled in by this method.
	)
{
	LOG_block("CCatalog::GetNextRecord"); 
	LOG_out("iBitmaskIndex=%d", iBitmaskIndex);

	// validate the input argument
	if (NULL == pItem)
	{
		return NULL;
	}

	//first get the fixed length part of the record

	pItem->pf = (PWU_INV_FIXED)pRecord;

	//process the variable part of the record

	pRecord = pRecord + sizeof(WU_INV_FIXED);

	//check if pRecord is a valid pointer after its value has changed
	if (NULL == pRecord)
	{
		return NULL;
	}

	pItem->pv = (PWU_VARIABLE_FIELD)pRecord;

	//since there is no state information create an empty structure
	pItem->ps = (PWU_INV_STATE)V3_malloc(sizeof(WU_INV_STATE));

	//check if memory allocation is successful
	if (NULL == pItem->ps)
	{
		return NULL;
	}

	//new item is unknown detection, not selected and shown to user.
	pItem->ps->state	= WU_ITEM_STATE_UNKNOWN;
	pItem->ps->bChecked	= FALSE;
	pItem->ps->bHidden	= FALSE;
	pItem->ps->dwReason	= WU_STATE_REASON_NONE;

	//There is no description yet
	pItem->pd			= (PWU_DESCRIPTION)NULL;

	//we need to store the bitmap index (which is the sequential record index)
	//since this information will be lost when we add the driver records.
	// YanL: is not being used
	//	pItem->bitmaskIndex = iBitmaskIndex;

	//Get record type
	pItem->recordType = (BYTE)GetRecordType(pItem);
	
	//set record pointer to the beginning of the next record
	int iSize = 0;
	iSize = pItem->pv->GetSize();
	LOG_out("iSize=%d",iSize);
	pRecord += iSize;	

	return pRecord;
}


//This method applies the bitmask associated with this catalog. Bitmasks are applied
//based on OEM and machine language ID.
//Note: This method needs to be called before before any records are inserted
//into the inventory catalog as record insertions will change the physical
//location of inventory records.
void CCatalog::BitmaskPruning(
	IN CBitmask *pBm,			//bitmask to be used to prune inventory list
	IN PBYTE	pOemInfoTable	//OEM info table that OEM detection uses
	)
{
	//Note: We always detect the locale for bitmask pruning. This is because
	//we always install a package based on OS langauge.

	DWORD langid = GetMachineLangDW();

	PBYTE pBits = pBm->GetClientBits(GetMachinePnPID(pOemInfoTable), langid);

	//Pass one: hide all items that are turned off in the resultant bitmask.
	//Note: There is a one to one corispondence between bitmask items and
	//inventory items. This is position dependent.

	for (int i=0; i<m_hdr.totalItems; i++)
	{
		if ( GETBIT(pBits, i) == 0 )
		{
			m_items[i]->ps->bHidden	= TRUE;
			m_items[i]->ps->state	= WU_ITEM_STATE_PRUNED;
			m_items[i]->ps->dwReason = WU_STATE_REASON_BITMASK;
		}
		TRACE("BitmaskPruning (OEM) PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
	}

	//Once the bitmask is applied the next step is to perform active setup detection.
	//Since this involves creating an active setup detection cif and calling an ocx
	//control I've choosen to split the detection processes into several steps. This
	//allows me to stub the Active setup detection so that I can get the rest of the
	//code written first.

	V3_free(pBits);

	return;
}


//This method prunes the inventory.plt list with the bitmask.plt
void CCatalog::BitmaskPruning(
	IN CBitmask *pBm,		//bitmask to be used to prune inventory list
	IN PDWORD pdwPlatformId,		//platform id list to be used.
	IN long iTotalPlatforms	//platform id list to be used.
	)
{
	//First prune list based on bitmask
	//This is accomplished by anding the appropriate bitmasks to form a global bitmask.

	//Note: We always detect the locale for bitmask pruning. This is because
	//we always install a package based on OS langauge.

	PBYTE pBits = pBm->GetClientBits(pdwPlatformId, iTotalPlatforms);

	//Pass one: hide all items that are turned off in the resultant bitmask.
	//Note: There is a one to one corispondence between bitmask items and
	//inventory items. This is position dependent.

	for(int i=0; i<m_hdr.totalItems; i++)
	{
		if ( GETBIT(pBits, i) == 0 )
		{
			m_items[i]->ps->bHidden	= TRUE;
			m_items[i]->ps->state	= WU_ITEM_STATE_PRUNED;
			m_items[i]->ps->dwReason = WU_STATE_REASON_BITMASK;
		}
		TRACE("BitmaskPruning (PlatformId) PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
	}

	//Once the bitmask is applied the next step is to perform active setup detection.
	//Since this involves creating an active setup detection cif and calling an ocx
	//control I've choosen to split the detection processes into several steps. This
	//allows me to stub the Active setup detection so that I can get the rest of the
	//code written first.

	V3_free(pBits);

	return;
}


void CCatalog::ProcessExclusions(CWUDownload* pDownload)
{
	Varray<PUID> vPuids;
	int cPuids;
	int i;
	int j;

	//
	// registry hiding
	//
	RegistryHidingRead(vPuids, cPuids);

	for (j = 0; j < cPuids; j++)
	{
		for (i = 0; i < m_hdr.totalItems; i++)
		{
			if (m_items[i]->GetPuid() == vPuids[j])
			{
				m_items[i]->ps->bHidden = TRUE;
				m_items[i]->ps->dwReason = WU_STATE_REASON_PERSONALIZE;
				TRACE("ProcessExclusions1 PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
			}
		}
	}

	//
	// site global hiding
	//
	GlobalExclusionsRead(vPuids, cPuids, this, pDownload);
	
	for (j = 0; j < cPuids; j++)
	{
		for (i = 0; i < m_hdr.totalItems; i++)
		{
			if (m_items[i]->GetPuid() == vPuids[j])
			{
				m_items[i]->ps->state = WU_ITEM_STATE_PRUNED;
				m_items[i]->ps->bHidden = TRUE;
				m_items[i]->ps->dwReason = WU_STATE_REASON_BACKEND;
				TRACE("ProcessExclusions2 PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
			}
		}
	}

}


//This method performs the pruning of items in a catalog. This method can only be
//called after any additional records (link CDM records) are inserted into the
//inventory list and all active setup detection is performed.

//The correct calling order to prune an inventory catalog is:
//
// perform all bitmask pruning before inserting records from other sources.
//
//	catalog.BitmaskPruning();
//
//add any device driver records. Note: if there is not a device driver
//insertion record then this api simply returns. Also corporate catalogs
//do not call this API as their device driver records are already pre-inserted
//into an inventory list.
//
//	catalog.AddCDMRecords();
//
//Finally call the Prune() method. This method will perform all the rest of the
//pruning including registry item hiding and puid to index link conversion.
//
//  catalog.Prune()
//
//Once this method returns the inventory is ready to be reformatted into the
//array state that is returned to the ATL GetCatalog() caller.
void CCatalog::Prune()
{
	int		i;
	int		t;
	int		linkItemState;
	int		referenceItemIndex;
	GUID	referenceGuid;

	// We need to ensure that the puids are converted to physical indexes
	// before we can complete the pruning process.
	ConvertLinks();

	// Hide any active setup items that are marked as Update only and
	// are not detected as updates. Also hide any items that have been
	// marked as hidden.
	for (i = 0; i < m_hdr.totalItems; i++)
	{
		if (m_items[i]->recordType == WU_TYPE_ACTIVE_SETUP_RECORD)
		{
			// Note: hidden is special. The back end tool can create
			// special hidden records that do not offer installs but
			// are used to setup install item dependencies. In these
			// cases we don't want the record to show to the client
			// as available but we still need its linking logic so we
			// hide thre record but do not prune it from the
			// inventory list.
			if (m_items[i]->pf->a.flags & WU_HIDDEN_ITEM_FLAG)
			{

				m_items[i]->ps->bHidden = TRUE;
				m_items[i]->ps->dwReason = WU_STATE_REASON_BACKEND;

			}
			if (m_items[i]->pf->a.flags & WU_UPDATE_ONLY_FLAG)
			{
				if (m_items[i]->ps->state != WU_ITEM_STATE_UPDATE)
				{
					m_items[i]->ps->bHidden = TRUE;
					m_items[i]->ps->state = WU_ITEM_STATE_PRUNED;
					m_items[i]->ps->dwReason = WU_STATE_REASON_UPDATEONLY;
				}
			}
		}
		else if (m_items[i]->recordType == WU_TYPE_CDM_RECORD)
		{
			//
			// if we find an uninstall key in a CDM record, this indicates this
			// item is an installed driver, we need to change its status from Update to Install now
			//
			if (m_items[i]->pv->Find(WU_KEY_UNINSTALLKEY) != NULL)
			{
				if (m_items[i]->ps->state == WU_ITEM_STATE_UPDATE)
					m_items[i]->ps->state = WU_ITEM_STATE_CURRENT;
			}
		}
		TRACE("Prune processing0 PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
	}

	//
	// process patch (ndxLinkInstall) dependencies and other pruning
	//
	for (i = 0; i < m_hdr.totalItems; i++)
	{
		// if this is a place holder record then it is not shown by default.
		if (m_items[i]->recordType == WU_TYPE_CDM_RECORD_PLACE_HOLDER)
		{

			m_items[i]->ps->bHidden = TRUE;
			m_items[i]->ps->state = WU_ITEM_STATE_PRUNED;   //fixed bug#3631
			m_items[i]->ps->dwReason = WU_STATE_REASON_DRIVERINS;
			TRACE("Prune CDM Place Holder PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
			continue;
		}

		// sub sections are not included in link pruning.
		if (m_items[i]->recordType == WU_TYPE_SECTION_RECORD ||
			m_items[i]->recordType == WU_TYPE_SUBSECTION_RECORD ||
			m_items[i]->recordType == WU_TYPE_SUBSUBSECTION_RECORD)
		{
			continue;
		}

		// if this is a first level item then there
		// are no dependent links to process
		if (m_items[i]->ndxLinkInstall == WU_NO_LINK)
			continue;

		switch (m_items[i]->ps->state)
		{
			case WU_ITEM_STATE_INSTALL:
			case WU_ITEM_STATE_UPDATE:
			case WU_ITEM_STATE_CURRENT:
				//Inventory item has been detected as an Updatable item
				//This means that this item is a later version of something
				//that the user already has.  We now need to follow this items link and see if
				//the item it points to is marked as an update item.
				//If so then we need to hide this item as well.
				linkItemState = m_items[m_items[i]->ndxLinkInstall]->ps->state;

				if (linkItemState == WU_ITEM_STATE_UPDATE || linkItemState == WU_ITEM_STATE_INSTALL)
				{
					m_items[i]->ps->bHidden = TRUE;
					m_items[i]->ps->dwReason = WU_STATE_REASON_HIDDENDEP;
				}
				else if (linkItemState == WU_ITEM_STATE_PRUNED)
				{

					//If the item that this item is dependent on is pruned from the list
					//then this item needs to be hidden and pruned as well.
					m_items[i]->ps->bHidden = TRUE;
					m_items[i]->ps->state	= WU_ITEM_STATE_PRUNED;
					m_items[i]->ps->dwReason = WU_STATE_REASON_PRUNED;

				}
				break;
			
			case WU_ITEM_STATE_PRUNED:
			case WU_ITEM_STATE_UNKNOWN:
				break;
		}

		TRACE("Prune processing1 PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
	}

	//
	// Now we have to walk though the list and hide all update items
	// except the latest version.
	//
	for(i = 0; i < m_hdr.totalItems; i++)
	{
		//Device Driver records are not included as device driver
		//records are always an update of the current system so the
		//normal rules of hidding do not apply.
		if (m_items[i]->recordType != WU_TYPE_ACTIVE_SETUP_RECORD)
			continue;

		if (m_items[i]->ps->bHidden || (m_items[i]->ps->state != WU_ITEM_STATE_UPDATE))
			continue;


		//We now have an item that is an update item and is currently shown.
		//We need to walk though the inventory list only accept the highest
		//version of this update item.

		memcpy(&referenceGuid, &m_items[i]->pf->a.g, sizeof(GUID));
		referenceItemIndex = i;

		for(t=0; t<m_hdr.totalItems; t++)
		{
			if (t == referenceItemIndex || (m_items[t]->recordType != WU_TYPE_ACTIVE_SETUP_RECORD) )
				continue;

			if ( m_items[t]->ps->bHidden || (m_items[t]->ps->state != WU_ITEM_STATE_UPDATE) )
				continue;

			//If this item is not an update for the same package then
			//ignore it.
			if (!IsEqualGUID(referenceGuid, m_items[t]->pf->a.g))
				continue;

			PINVENTORY_ITEM p = m_items[t];

			//if this items version is more recent than the reference item's
			//version then hide the reference item and make this item the
			//reference item.
			if (CompareASVersions(&m_items[t]->pf->a.version, &m_items[referenceItemIndex]->pf->a.version) > 0)
			{
				m_items[referenceItemIndex]->ps->bHidden = TRUE;
				m_items[referenceItemIndex]->ps->dwReason = WU_STATE_REASON_OLDERUPDATE;
				TRACE("Prune processing2 PUID=%d Hidden=%d Reason=%d", m_items[i]->GetPuid(), m_items[i]->ps->bHidden, m_items[i]->ps->dwReason);
				break;
			}
		}

	}
}


//This method converts the links which are in PUID format into a set of
//memory indexes. This is a performance optimization since we do not want
//to have to perform a search for each PUID when we update the links. Note:
//This function converts both the detection and install dependency links.
void CCatalog::ConvertLinks
	(
		void
	)
{
	int i;
	int puidDetect;
	int puidInstall;

	//We need to update the total number of records in the catalog.
	//Note: The varray contains the total number of allocated elements
	//which is not the same thing as the total number of records in a
	//catalog.

	//walk though the inventory list and convert each PUID into it's
	//associated index entry.

	for(i=0; i<m_hdr.totalItems; i++)
	{
		puidDetect	= WU_NO_LINK;
		puidInstall	= WU_NO_LINK;	//sections do not get installed.
		switch( m_items[i]->recordType )
		{
			case WU_TYPE_ACTIVE_SETUP_RECORD:
				puidDetect	= m_items[i]->pf->a.link;
				puidInstall	= m_items[i]->pf->a.installLink;
				break;
			case WU_TYPE_CDM_RECORD_PLACE_HOLDER:
				//cdm place holders have no link as the link is on the
				//individually inserted cdm records.
				puidDetect	= WU_NO_LINK;
				puidInstall	= WU_NO_LINK;
				break;
			case WU_TYPE_CDM_RECORD:
				puidDetect	= WU_NO_LINK;
				puidInstall	= WU_NO_LINK;
				break;
		}

		if ( puidDetect != WU_NO_LINK )
			m_items[i]->ndxLinkDetect = FindPuid(puidDetect);
		else
			m_items[i]->ndxLinkDetect = WU_NO_LINK;

		if ( puidInstall != WU_NO_LINK )
			m_items[i]->ndxLinkInstall = FindPuid(puidInstall);
		else
			m_items[i]->ndxLinkInstall = WU_NO_LINK;
	}

	return;
}


//This method finds a particular index record in an inventory list based on
//the records PUID.
int CCatalog::FindPuid(PUID puid)
{
	int i;

	for(i=0; i<m_hdr.totalItems; i++)
	{
		if ( puid == m_items[i]->GetPuid() )
			return i;
	}

	return -1;	//record not found.
}

//This method finds the Driver insertion record if present in an inventory.
int CCatalog::GetRecordIndex
	(
		int iRecordType	//Record type to find.
	)
{
	int	i;

	//If there is a device driver insertion record in the inventory then we need
	//to insert the cdm records.

	for(i=0; i<m_hdr.totalItems; i++)
	{
		if (m_items[i]->recordType == iRecordType)
		{
			if ((m_items[i]->pf->d.flags & WU_HIDDEN_ITEM_FLAG) == 0)
				return i;
			else
				return -1;
		}
	}

	return -1;
}


void CCatalog::AddCDMRecords(
	IN CCdm	*pCdm					//cdm class to be used to add Device Driver
	)
{
	int				i;
	int				t;
	PINVENTORY_ITEM	pItem;

	//If there is a device driver insertion record in the inventory then we need
	//to insert the cdm records.
	i = GetRecordIndex(WU_TYPE_CDM_RECORD_PLACE_HOLDER);

	//If we do not have a device driver record in the inventory list then
	//nothing to do.
	if ( i == -1 )
		return;

	//device driver records are added after the device driver insertion record.
	i++;

	m_items.Insert(i, pCdm->m_iCDMTotalItems);

	m_hdr.totalItems += pCdm->m_iCDMTotalItems;

	for(t=0; t<pCdm->m_iCDMTotalItems; t++, i++)
	{
		pItem = pCdm->ConvertCDMItem(t);

		if ( m_items[i] )
			V3_free(m_items[i]);

		pItem->pf->d.g = WU_GUID_DRIVER_RECORD;

		m_items[i] = pItem;
	}

	return;
}

//Steps to add a new detection type
//1 - define a record type identifier and add it to the WUV3.H file.
//2 - Add the record detection method to the CCatalog::GetRecordType method.
//3 - Add a method to CCatalog class that adds the these new records to the client in
//memory inventory list. See the Ccdm class above for an example of how to do this.
//The two defined values that are added to wuv3.h file need to be a section record
//identifier and a record type identifier. The section type is stored in the type
//flag for inventory records that are not active setup records. The type defination
//is placed by the GetRecordType function into the in memory client inventory
//structure when the records are placed into the catalog inventory.
//
//make up a unique way of identifying the new detection record and place this
//identifier into the guid element of the inventory structure. This is necessary
//as the Registry hidding relies on the guid parameter to find items that the
//user manually requests hidden.
//
//	#define SECTION_RECORD_TYPE_PRINTER
//	#define	WU_TYPE_RECORD_TYPE_PRINTER

//Next add a new structure type that defines the fixed part of the new detection
//record to the _WU_INV_FIXED structure. Next add the type defination to the
//catalog GetItemInfo and GetPuid methods in the wufix.cpp file.
//Finally add an extension to the Read function above that reads the description.
//Note:  You will also need to add code to the InstallItem() function defined in
//the CV3.CPP file to install this new type of update.

//Helper function that returned the flags for an inventory item.
BYTE CCatalog::GetItemFlags(
	int index	//index of record for which to retrieve the item flags
	)
{
	BYTE	flags;

	m_items[index]->GetFixedFieldInfo(WU_ITEM_FLAGS, &flags);

	return flags;
}

//returns information about an inventory item.
BOOL CCatalog::GetItemInfo(
	int		index,		//index of inventory record
	int		infoType,	//type of information to be returned
	PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is
						// responsible for ensuring that the return buffer is large enough to
						// contain the requested information.
	)
{
	return m_items[index]->GetFixedFieldInfo(infoType, pBuffer);
}


//determine the type of record
//Note: The cdm place holder record is marked however the cdm detection
//piece will be responsible for updating the records that it inserts into
//the catalog inventory.
int CCatalog::GetRecordType(
	PINVENTORY_ITEM pItem
	)
{
	GUID	driverRecordId = WU_GUID_DRIVER_RECORD;
	int		iRecordType = 0;

	//check input arguments
	if (NULL == pItem)
	{
		return 0;
	}

	if ( memcmp((void *)&pItem->pf->d.g, (void *)&driverRecordId, sizeof(WU_GUID_DRIVER_RECORD)) )
	{
		//if the GUID field is not 0 then we have an active setup record.

		iRecordType = WU_TYPE_ACTIVE_SETUP_RECORD;//active setup record type
	}
	else
	{
		//else this is either a driver record place holder or a section - sub section
		//record. So we need to check the type field

		if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DEVICE_DRIVER_INSERTION )
		{
			//cdm driver place holder record
			iRecordType = WU_TYPE_CDM_RECORD_PLACE_HOLDER;	//cdm code download manager place holder record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_PRINTER )
		{
			//Note: We may need to use this to support printers on win 98.

			iRecordType = WU_TYPE_RECORD_TYPE_PRINTER;	//printer record
		}
		else if ( pItem->pf->d.type == SECTION_RECORD_TYPE_DRIVER_RECORD )
		{
			iRecordType = WU_TYPE_CDM_RECORD;	//Corporate catalog device driver
		}
		else if ( pItem->pf->s.type == SECTION_RECORD_TYPE_CATALOG_RECORD )
		{
			iRecordType = WU_TYPE_CATALOG_RECORD;
		}
		else
		{
			//we have either a section, sub section or sub sub section record

			switch ( pItem->pf->s.level )
			{
				case 0:
					iRecordType = WU_TYPE_SECTION_RECORD;
					break;
				case 1:
					iRecordType = WU_TYPE_SUBSECTION_RECORD;
					break;
				case 2:
					iRecordType = WU_TYPE_SUBSUBSECTION_RECORD;
					break;
			}
		}
	}

	return iRecordType;
}


// returns the machine language string
//
// Side effect: Calculates m_bLocalesDifferent
LPCTSTR CCatalog::GetMachineLocaleSZ()
{
	if (m_szMachineLocale[0] == _T('\0'))
	{
		wsprintf(m_szMachineLocale, _T("0x%8.8x"), GetMachineLangDW());

		m_bLocalesDifferent = (lstrcmpi(m_szBrowserLocale, m_szMachineLocale) != 0);
	}
	
	return m_szMachineLocale;
}

LPCTSTR CCatalog::GetUserLocaleSZ()
{
	if (m_szUserLocale[0] == _T('\0'))
	{
		wsprintf(m_szUserLocale, _T("0x%8.8x"), GetUserLangDW());
	}
	
	return m_szUserLocale;
}


void CCatalog::GetItemDirectDependencies(PINVENTORY_ITEM pItem, Varray<DEPENDPUID>& vDepPuids, int& cDepPuids)
{
	//check input arguments
	if (NULL == pItem)
	{
		return;
	}

	PWU_VARIABLE_FIELD pvDepKey = pItem->pv->Find(WU_KEY_DEPENDSKEY);
	if (pvDepKey == NULL)
	{
		// no dependencies for this item
		return;
	}

	//
	// parse the DependsKey
	//
	char szFrag[128];
	LPCSTR pNextFrag = (LPCSTR)pvDepKey->pData;

	while (pNextFrag)
	{
		// prepare for a next step
		pNextFrag = strcpystr(pNextFrag, ",", szFrag);
		if (szFrag[0] == '\0')
			continue;

		// get fields
		LPCSTR pNextFld = szFrag;
		char szPuid[32];
		pNextFld = strcpystr(pNextFld, ":", szPuid);

		char szType[32];
		pNextFld = strcpystr(pNextFld, ":", szType);

		char szVers[64];
		pNextFld = strcpystr(pNextFld, ":", szVers);

		if (szPuid[0] == '\0')
			continue;

		if ('N' == szType[0]) // ignore N dependancies for now
			continue;

		// set structure
		DEPENDPUID d = {0};
		d.puid = atoi(szPuid);

		bool fVerDep = szVers[0] != '\0';
		WU_VERSION verDep;
		
		if (szVers[0] != '\0')
			StringToVersion(szVers, &verDep);

		// Check if it's included by now
		for (int i = 0; i < cDepPuids; i++)
		{
			if (vDepPuids[i].puid == d.puid)
				break;
		}
		if (i != cDepPuids)
			continue; // didn't get to the very end

		// we need to add it.  make sure that the puid is in this catalog
		int iCatIndex = FindPuid(d.puid);
		if (-1 == iCatIndex)
		{
			// this is an error condition and we will not include this dependency
			// this should not happen
			TRACE("Dependency puid %d not found in catalog %d", d.puid, m_puidCatalog);
			continue;
		}

		// check to see if the item needs to be installed by looking at its current status
		// we don't need to install it if its up to date so we will not add it in the array
		BYTE state = m_items[iCatIndex]->ps->state; 
		if (state == WU_ITEM_STATE_INSTALL )
		{
			//ok
		}
		else if (state == WU_ITEM_STATE_UPDATE)
		{
			if (fVerDep && CompareASVersions(&verDep, &(m_items[iCatIndex]->ps->verInstalled)) <= 0)
				continue;
		}
		else
		{
			continue;
		}

		// look up priority and add the item to the array
		PWU_VARIABLE_FIELD pvPri = m_items[iCatIndex]->pd->pv->Find(WU_DESC_INSTALL_PRIORITY);
		if (pvPri != NULL)
			d.dwPriority = *((DWORD*)(pvPri->pData));


		// store the puid of the parent of this dependency.
		d.puidParent = pItem->GetPuid();

		vDepPuids[cDepPuids ++] = d;
	} //while (pNextFrag)

}



BOOL CCatalog::LocalesDifferent()
{
	// if machine language is not detected yet, then we don't know if its the same as browser language
	// therefore, we call GetMachineLocaleSZ which also compares the languages
	if (m_szMachineLocale[0] == _T('\0'))
		(void)GetMachineLocaleSZ();

	return m_bLocalesDifferent;
}


void RegistryHidingRead(Varray<PUID>& vPuids, int& cPuids)
{
	HKEY hKey = NULL;
	DWORD dwSize = 0;

	cPuids = 0;

	if (RegOpenKeyEx(HKEY_CURRENT_USER, REGISTRYHIDING_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if ((RegQueryValueEx(hKey, _T("Items"), NULL, NULL, NULL, &dwSize) == ERROR_SUCCESS))
		{
			cPuids = dwSize / sizeof(PUID);
			if (cPuids > 0)
			{
				vPuids[cPuids] = 0;

				if (RegQueryValueEx(hKey, _T("Items"), NULL, NULL, (LPBYTE)&vPuids[0], &dwSize) != ERROR_SUCCESS)
					cPuids = 0;
			}
		}
		RegCloseKey(hKey);
	}
}


BOOL RegistryHidingUpdate(PUID puid, BOOL bHide)
{
	HKEY hKey = NULL;
	DWORD dwDisposition;
	DWORD dwSize;
	BOOL bChanged = FALSE;

	Varray<PUID> vPuids;
	int cPuids;
	int x = -1;

	RegistryHidingRead(vPuids, cPuids);

	for (int i = 0; i < cPuids; i++)
	{
		if (vPuids[i] == puid)
		{
			x = i;
			break;
		}
	}

	if (bHide)
	{
		if (x == -1)
		{
			// not found, add it to the hidden list
			vPuids[cPuids++] = puid; // add at end
			bChanged = TRUE;
		}
	}
	else
	{
		if (x != -1)
		{
			// found, delete it from hidden list
			if (cPuids > 1)
				vPuids[x] = vPuids[cPuids - 1];
			cPuids--;
			bChanged = TRUE;
		}
		
	}

	//
	// write the array out to registry
	//
	if (bChanged)
	{
		if (RegCreateKeyEx(HKEY_CURRENT_USER, REGISTRYHIDING_KEY, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
		{
			if (cPuids == 0)
			{
				RegDeleteValue(hKey, _T("Items"));
			}
			else
			{
				RegSetValueEx(hKey, _T("Items"), 0, REG_BINARY, (LPBYTE)&vPuids[0], cPuids * sizeof(PUID));
			}
			RegCloseKey(hKey);
		}
	}

	return bChanged;
}



void GlobalExclusionsRead(Varray<PUID>& vPuids, int& cPuids, CCatalog* pCatalog, CWUDownload *pDownload)
{

	const TCHAR CATALOGINIFN[] = _T("catalog.ini");
	
	cPuids = 0;

	try
	{

		if (pDownload->Copy(CATALOGINIFN, NULL, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY, NULL))
		{

			TCHAR szPuid[128];
			TCHAR szLocalFile[MAX_PATH];
			TCHAR *szValue = (TCHAR*)malloc(MAX_CATALOG_INI * sizeof(TCHAR));
            if(NULL == szValue)
            {
                throw E_OUTOFMEMORY;
            }

			GetWindowsUpdateDirectory(szLocalFile);
			lstrcat(szLocalFile, CATALOGINIFN);

			// NOTE: The result may be truncated if too long
			if (GetPrivateProfileString(_T("exclude"), _T("puids"), _T(""), szValue, MAX_CATALOG_INI, szLocalFile) != 0)
			{

				TRACE("Global Exclusion(catalog.ini) PUIDS=%s", szValue);

				LPCTSTR pNext = szValue;
				while (pNext)
				{
					pNext = lstrcpystr(pNext, _T(","), szPuid);

					if (szPuid[0] != _T('\0'))
					{
						vPuids[cPuids] = _ttoi(szPuid);
						cPuids++;
					}
				} //while

			}
            if(NULL != szValue)
            {
                free(szValue);
            }
		}

	}
	catch(HRESULT hr)
	{
		cPuids = 0;
	}
}



// downloads and uncompresses the file into memory
// Memory is allocated and returned in ppMem and size in pdwLen 
// ppMem and pdwLen cannot be null
// if the function succeeds the return memory must be freed by caller
HRESULT DownloadFileToMem(CWUDownload* pDownload, LPCTSTR pszFileName, CDiamond* pDiamond, BYTE** ppMem, DWORD* pdwLen)
{
	byte_buffer bufTmp;
	byte_buffer bufOut;
	if (!pDownload->MemCopy(pszFileName, bufTmp))
		return HRESULT_FROM_WIN32(GetLastError());
	CConnSpeed::Learn(pDownload->GetCopySize(), pDownload->GetCopyTime());
	if (pDiamond->IsValidCAB(bufTmp))
	{
		if (!pDiamond->Decompress(bufTmp, bufOut))
			return HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		//else the oem table is in uncompressed format.
		bufOut << bufTmp;
	}
	*pdwLen = bufOut.size();
	*ppMem = bufOut.detach();
	
	//Check if *pdwLen is 0 i.e. size is 0 
	//OR *ppMem is NULL, then return E_FAIL 

	if ((NULL == *ppMem) || (0 == *pdwLen))
	{
		return E_FAIL;
	}

	return S_OK;
}


int __cdecl CompareGANGINDEX(const void* p1, const void* p2)
{
	PUID d1 = ((GANGINDEX*)p1)->puid;
	PUID d2 = ((GANGINDEX*)p2)->puid;

	if (d1 > d2)
		return +1;
	else if (d1 < d2)
		return -1;
	else
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\cwudload.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    cwudload.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <objbase.h>
#include <tchar.h>
#include <atlconv.h>
#include <log.h>
#include <v3stdlib.h>	
#include <cwudload.h>
#include <wuv3sys.h>
#include <debug.h>
#include <shlwapi.h>

//
// This structure is used locally when files are copied via the Copy method. It is used to
// pass specified information to a thread function that will process that actual reading
// of files from the internet. This complex process is necessary since the ReadInternetFile()
// API that wininet uses to read the file from the server blocks. If we were to call the API
// directory we would stop processing messages and run the risk of the browser terminating
// our control's thread.
//
typedef struct _IR_READINFO
{
	HINTERNET	hFile;		//wininet internet file handle for read.
	PBYTE		pBuffer;	//buffer where internet data is to be returned
	int			bReturn;	//return status TRUE = success, FALSE = error GetLastError() contains error code
	int			iReadSize;	//size of block to read
	HANDLE		exitEvent;	//request thread handler to exit
	HANDLE		readEvent;	//request internet block read
	HANDLE		finished;	//requested event (read or exit) is finished
} IR_READINFO, *PIR_READINFO;


static DWORD ReadThreadProc(LPVOID lpParameter);
TCHAR CWUDownload::m_szWUSessionID[MAX_TIMESTRING_LENGTH]; // unique session ID (SID)
int   CWUDownload::m_fIsSIDInitialized; // flag - has the static SID beein initialized?
void WaitMessageLoop(HANDLE hHandle);

BOOL CWUDownload::s_fOffline = FALSE;

CWUDownload::CWUDownload(
	LPCTSTR pszURL,
	int iBufferSize

) :	m_bCacheUsed(FALSE), 
	m_dwCopyTime(0), 
	m_dwCopySize(0),
	m_szServerPath(NULL),
	m_szRelURL(NULL),
	m_szBuffer(NULL),
	m_hSession(NULL),
	m_hConnection(NULL),
	m_exitEvent(INVALID_HANDLE_VALUE),
	m_readEvent(INVALID_HANDLE_VALUE),
	m_finished(INVALID_HANDLE_VALUE),
	m_iBufferSize(iBufferSize)
{
	HRESULT			hr;
	TCHAR			szServerName[INTERNET_MAX_HOST_NAME_LENGTH];
	URL_COMPONENTS	url; 

	TRACE("CWUDownload object created for %s", pszURL);

	if(SID_NOT_INITIALIZED == m_fIsSIDInitialized)
	{
		SYSTEMTIME	st;
		
		//grab a new time
		GetSystemTime(&st);

		// use the system time, tickcount, process ID and thread ID to create an anonymous unique session ID
		// (not using a GUID due to perceived privacy issues)
		wsprintf(m_szWUSessionID, _T("%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x") ,GetTickCount(),GetCurrentProcessId(),GetCurrentThreadId(),st.wMonth,st.wDay,st.wHour, st.wMinute,st.wSecond,st.wMilliseconds);
		m_fIsSIDInitialized = SID_INITIALIZED;
	}

	// allocate heap space for these buffers, since they're large (4k each)
	m_szServerPath = (TCHAR*)malloc(INTERNET_MAX_PATH_LENGTH * sizeof(TCHAR));
	if(NULL == m_szServerPath)
	{
		throw E_OUTOFMEMORY;
	}

	m_szRelURL = (TCHAR*)malloc(INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	if(NULL == m_szRelURL)
	{
		free(m_szServerPath);
		throw E_OUTOFMEMORY;
	}

	m_szServerPath[0] = _T('\0');
	m_szRelURL[0] = _T('\0');

	//
	// copy the server path as is (with directories) to m_szServerPath but this is not what
	// we will give to wininet
	//

	lstrcpy(m_szServerPath, pszURL);

	//
	// parse out the actual server name, port, service and url path
	//
	ZeroMemory(&url, sizeof(url)); 
	url.dwStructSize = sizeof(url); 

	url.lpszHostName = szServerName;
	url.dwHostNameLength = sizeof(szServerName)/sizeof(TCHAR);

	url.lpszUrlPath = m_szRelURL;
	url.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

	TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
	url.lpszUserName = szUserName;
	url.dwUserNameLength = sizeof(szUserName)/sizeof(TCHAR);

	TCHAR szPassword[INTERNET_MAX_PASSWORD_LENGTH];
	url.lpszPassword = szPassword;
	url.dwPasswordLength = sizeof(szPassword)/sizeof(TCHAR);

	if (!InternetCrackUrl(pszURL, 0, 0, &url))
	{
		free(m_szServerPath);
		free(m_szRelURL);
		throw HRESULT_FROM_WIN32(GetLastError());
	}

	if (url.nScheme != INTERNET_SCHEME_HTTP && url.nScheme != INTERNET_SCHEME_HTTPS)
	{
		free(m_szServerPath);
		free(m_szRelURL);
		throw E_INVALIDARG;
	}

	m_hSession = InternetOpen(_T("Windows Update"), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if ( !m_hSession )
	{
		free(m_szServerPath);
		free(m_szRelURL);
		throw HRESULT_FROM_WIN32(GetLastError());  
	}

	m_hConnection = InternetConnect(m_hSession, 
									szServerName, 
									url.nPort, 
									(szUserName[0] == _T('\0')) ? NULL : szUserName, 
									(szPassword[0] == _T('\0')) ? NULL : szPassword, 
									INTERNET_SERVICE_HTTP, 
									0, 
									1);

	if ( !m_hConnection )
	{
		InternetCloseHandle(m_hSession);
		free(m_szServerPath);
		free(m_szRelURL);		
		throw HRESULT_FROM_WIN32(GetLastError());	
	}

	m_szBuffer = (PSTR)V3_malloc(m_iBufferSize);

	m_exitEvent	= CreateEvent(NULL, TRUE, FALSE, NULL);
	m_readEvent	= CreateEvent(NULL, TRUE, FALSE, NULL);
	m_finished	= CreateEvent(NULL, TRUE, FALSE, NULL);

	if (m_exitEvent == INVALID_HANDLE_VALUE || 
		m_readEvent == INVALID_HANDLE_VALUE ||
		m_finished == INVALID_HANDLE_VALUE)
	{
		hr = GetLastError();
		
		// explicit destructor for cleanup
		CWUDownload::~CWUDownload();
		throw hr;
	}

	//ensure that m_szRelURL has a final slash
	if (m_szRelURL[0] != _T('\0'))
	{
		int l = lstrlen(m_szRelURL);
		if (m_szRelURL[l - 1] != _T('/'))
		{
			m_szRelURL[l] = _T('/');
			m_szRelURL[l + 1] = _T('\0');
		}
	}
}

						


CWUDownload::~CWUDownload()
{
	if (m_hConnection)
	{
		InternetCloseHandle(m_hConnection);
	}

	if (m_hSession)
	{
		InternetCloseHandle(m_hSession);
	}

	if (m_szBuffer != NULL)
	{
		V3_free(m_szBuffer);
	}

	m_szBuffer		= NULL;
	m_hSession		= NULL;
	m_hConnection	= NULL;

	if (m_exitEvent != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_exitEvent);
	}

	if (m_readEvent != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_readEvent);
	}

	if (m_finished != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_finished);
	}

	if (NULL != m_szServerPath)
	{
		free((void*)m_szServerPath);
	}

	if (NULL != m_szRelURL)
	{
		free((void*)m_szRelURL);
	}

	m_exitEvent = INVALID_HANDLE_VALUE;
	m_readEvent = INVALID_HANDLE_VALUE;
	m_finished  = INVALID_HANDLE_VALUE;
}




BOOL CWUDownload::Copy(
	IN				LPCTSTR	szSourceFile,
	IN	OPTIONAL	LPCTSTR	szDestFile,
	OUT	OPTIONAL	PVOID	*ppData,
	OUT	OPTIONAL	ULONG	*piDataLen,
	IN	OPTIONAL	BOOL	dwFlags,
	IN	OPTIONAL	IWUProgress* pProgress
	)
{
	MSG			msg;
	DWORD		bytes = 0;
	DWORD		iFileWritten = 0;
	DWORD		iFileLen = 0;
	DWORD		iReadSize = 0;
	DWORD		dwStatus;
	PBYTE		pData = NULL;
	HANDLE		hFileOut = NULL;
	HANDLE		hFileCache = INVALID_HANDLE_VALUE;
	HINTERNET	hFileIn = NULL;
	DWORD		dwError = ERROR_SUCCESS;
	IR_READINFO	readInfo;
	DWORD		idThread = 0;
	HANDLE		readThread = NULL;
	HANDLE		hLocalFile = INVALID_HANDLE_VALUE;
	TCHAR		*ptr;
	TCHAR		szCacheName[MAX_PATH];
	TCHAR		szCacheExt[MAX_PATH];
	TCHAR		szCacheFile[MAX_PATH];
	int			iLength = 0;
	DWORD		dwStartCopyTime;
	TCHAR		szServerFilePath[MAX_PATH];
	BOOL		bIMS = FALSE;
	SYSTEMTIME	sSysTime;
	FILETIME	ftFile;
	BOOL		bUpdateFileTime = FALSE;

	//
	// initialize member variables
	//
	ResetEvent(m_exitEvent);
	ResetEvent(m_readEvent);
	m_bCacheUsed = FALSE;
	m_dwCopyTime = 0;
	m_dwCopySize = 0;

	if (dwFlags & EXACT_FILENAME)
	{
		// construct Windows Update cache file name for the requested file.
		_tsplitpath(szSourceFile, NULL, NULL, szCacheName, szCacheExt);
	}
	else
	{
		// change each directory slash to an underscore. This ensures that the cache file
		// is unique since catalogs and puids are unique.
		lstrcpy(szCacheName, szSourceFile);
		ptr = szCacheName;
		while (*ptr)
		{
			if (*ptr == _T('/') || *ptr == _T('\\'))
			{
				*ptr = _T('_');
			}
			ptr++;
		}
		szCacheExt[0] = 0;
	}

	// record start time
	dwStartCopyTime = GetTickCount();

	GetWindowsUpdateDirectory(szCacheFile);
	lstrcat(szCacheFile, szCacheName);
	lstrcat(szCacheFile, szCacheExt);

	// prepend the relative URL (directory) to source file,
	// and append the WU session ID to the URL
	wsprintf(szServerFilePath, _T("%s%s?%s"), m_szRelURL, szSourceFile, m_szWUSessionID);

	TRACE("CWUDownload::Copy: %s to %s", szServerFilePath, szCacheFile);

	// Offline only
	if (s_fOffline)
	{
		// If we do have file in cache return it
		if (szDestFile)
		{
			return CopyFile(szCacheFile, szDestFile, FALSE);
		}
		else if (ppData)
		{
			HANDLE hCacheFile = CreateFile(szCacheFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if(INVALID_HANDLE_VALUE == hCacheFile)
				return FALSE;

			DWORD dwFileSize = GetFileSize(hCacheFile, NULL);
			*ppData = V3_malloc(dwFileSize);
			//check if memory allocation was successful
			if (NULL == *ppData)
			{
				return FALSE;
			}

			DWORD dwSizeWritten = 0;
			BOOL fRet = ReadFile(hCacheFile, *ppData, dwFileSize, piDataLen, NULL);
			CloseHandle(hCacheFile);
			return fRet;
		}
		else
		{
			return TRUE;	// If file there it's there
		}
	}
	//~ Offline only

	// open request
	hFileIn = HttpOpenRequest(m_hConnection, NULL, szServerFilePath, _T("HTTP/1.0"), NULL, NULL, INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION, 1);
	if (!hFileIn)
	{
		dwError = GetLastError();
		goto ErrorCase2;
	}

	// modify request
	if (dwFlags & DOWNLOAD_NEWER)
	{
		TCHAR szIMS[128];
	    TCHAR szHttpTime[INTERNET_RFC1123_BUFSIZE + 1];

		// add the if-modified-since header
		hLocalFile = CreateFile(szCacheFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hLocalFile != INVALID_HANDLE_VALUE)
		{
			GetFileTime(hLocalFile, NULL, NULL, &ftFile);
			FileTimeToSystemTime(&ftFile, &sSysTime);
			bUpdateFileTime = TRUE;

	        if (InternetTimeFromSystemTime(&sSysTime, INTERNET_RFC1123_FORMAT, szHttpTime, INTERNET_RFC1123_BUFSIZE)) 
			{
				wsprintf(szIMS, _T("If-Modified-Since: %s\r\n"), szHttpTime);

				if (!HttpAddRequestHeaders(hFileIn, szIMS, (DWORD)-1L, 0)) 
				{
					dwError = GetLastError();
					goto ErrorCase2;
				}
				bIMS = TRUE;

				iFileLen = GetFileSize(hLocalFile, NULL);
			}
		}

	}

	// send request
	if (!HttpSendRequest(hFileIn, NULL, 0, NULL, 0))
	{
		dwError = GetLastError();
		goto ErrorCase2;
	}

	// get status code
	iLength = sizeof(dwStatus);
	if (!HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwStatus, (ULONG *)&iLength, NULL))
	{
		dwError = GetLastError();
		goto ErrorCase2;
	}

	// if the status is not a 200 or 304 then we assume an error
	if (dwStatus != HTTP_STATUS_OK && dwStatus != HTTP_STATUS_NOT_MODIFIED)  
	{
		dwError = ERROR_FILE_NOT_FOUND;
		goto ErrorCase2;
	}

	// check to see if the file in our cache is what we want
	if (dwFlags & DOWNLOAD_NEWER)
	{
		if (bIMS && dwStatus == HTTP_STATUS_NOT_MODIFIED)   //304
		{
			// close the internet handle as we will copy the file from the
			// local Windows Update cache.
			InternetCloseHandle(hFileIn);
			hFileIn = NULL;

			// SetLastError to ERROR_ALREADY_EXISTS so that client
			// can tell that we did not need to download anything.
			// This is used by cdm.dll to tell if it needs to replace
			// the clients version of the DLL with the servers.
			SetLastError(ERROR_ALREADY_EXISTS);

			//we also set a member variable for CacheUsed method
			//this is the prefered way of check if the file was downloaded or cache was useed
			m_bCacheUsed = TRUE;
		}
		else if (hLocalFile != INVALID_HANDLE_VALUE)
		{
			// we are going to download the file
			CloseHandle(hLocalFile);
			hLocalFile = INVALID_HANDLE_VALUE;
		}
	}

	// if we still have an open request handle, read file time and length
	if (hFileIn != NULL)
	{
		// get file size
		iLength = sizeof(iFileLen);
		if (!HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, &iFileLen, (ULONG *)&iLength, NULL))
		{
			dwError = GetLastError();
			goto ErrorCase2;
		}

		// get last modified time
		iLength = sizeof(sSysTime);
		if (!HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_SYSTEMTIME  | HTTP_QUERY_LAST_MODIFIED, &sSysTime, (ULONG *)&iLength, NULL))
		{
			dwError = GetLastError();
			goto ErrorCase2;
		}
 		SystemTimeToFileTime(&sSysTime, &ftFile);
		bUpdateFileTime = TRUE;
	}

	// store file length in memory for progress and return it in piDataLen
	if (piDataLen)
		*piDataLen = iFileLen;

	m_dwCopySize = (DWORD)iFileLen;
	
	if (dwFlags & CACHE_FILE_LOCALLY)
	{
		//if cache requested and we are not downloading a file from the server
		if (!hFileIn)
		{
			//Special case optimization. If the caller has only requested that
			//the server file be downloaded to the cache and the cache file
			//is up to date with the server file we do not need to perform any
			//copying so we clean up and return success.
			if ( !ppData && !szDestFile )
			{
				if ( hLocalFile != INVALID_HANDLE_VALUE )
				{
					CloseHandle(hLocalFile);
					hLocalFile = INVALID_HANDLE_VALUE;
				}

				return TRUE;
			}
			//else we need to read the cache file either to another file or into memory.
		}
		else
		{
			//else the file is coming from the server so needs to be cached locally.
			hFileCache = CreateFile(szCacheFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		}
	}

	if (szDestFile)
	{
		hFileOut = CreateFile(szDestFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if ( hFileOut == INVALID_HANDLE_VALUE )
		{
			hFileOut = NULL;
			dwError = GetLastError();
			goto ErrorCase2;
		}
	}

	if (ppData)
	{
		try
		{
			*ppData = V3_malloc(iFileLen + 1);
			pData = (PBYTE)*ppData;
		}
		catch(HRESULT hr)
		{
			dwError = ERROR_NOT_ENOUGH_MEMORY;
			goto ErrorCase2;
		}
	}

	//If we are reading the file from the server then we need to create a light
	//weight thread to manage the the download. If we are reading from the cache
	//then this is not necessary.
	if (hFileIn)
	{
		//initialize thread read structure thread info structure
		//the thread read function will go to sleep unless it is
		//reading or exiting. These events are defined per download
		//class instance with makes this class thread safe even
		//though there is only 1 thread function per Copy()

		readInfo.exitEvent	= m_exitEvent;
		readInfo.readEvent	= m_readEvent;
		readInfo.finished	= m_finished;
		readInfo.hFile		= hFileIn;
		readInfo.pBuffer	= (PBYTE)m_szBuffer;

		//Start read thread this thread will exist until we specifically tell it to exit.
		//this allows us to do all of our internet reads on a single thread.

		//TODO: Check out reducing this size to 100K
		readThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReadThreadProc, &readInfo, 0, &idThread);
		if ( !readThread )
		{
			dwError = GetLastError();
			goto ErrorCase1;
		}
	}

	while (iFileWritten < iFileLen)
	{
		iReadSize = iFileLen - iFileWritten;
		iReadSize = min(iReadSize, (UINT)m_iBufferSize);

		readInfo.bReturn	= FALSE;
		readInfo.iReadSize	= iReadSize;

		//At this point we either have an internet file connection or
		//a local cache handle.
		if (hFileIn)
		{
			DWORD dwReadStartTime = GetTickCount();
			
			//
			// clear the finished event and tell the thread function to begin an Internet Read.
			//
			ResetEvent(m_finished);
			SetEvent(m_readEvent);


			//every .05 seconds wake up and process messages if read has not completed
			do
			{
				//if we called the CallBack routine then process any required window messages
				while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			} while (WaitForSingleObject(m_finished, 50) != WAIT_OBJECT_0);

			//if an error occured on read
			if ( !readInfo.bReturn )
			{
				dwError = GetLastError();
				goto ErrorCase1;
			}

			if (pProgress)
			{
				pProgress->SetDownloadAdd(readInfo.iReadSize, GetTickCount() - dwReadStartTime);

				//check for cancel
				if (WaitForSingleObject(pProgress->GetCancelEvent(), 0) == WAIT_OBJECT_0)
				{
					dwError = ERROR_CANCELLED; 
					goto ErrorCase1;
				}
			}
		
		}
		else
		{
			//Read file from local cache
			if ( !ReadFile(hLocalFile, m_szBuffer, readInfo.iReadSize, (ULONG *)&readInfo.iReadSize, NULL) )
			{
				dwError = GetLastError();
				goto ErrorCase1;
			}
		}

		if ( pData )
		{
			memcpy(pData, m_szBuffer, readInfo.iReadSize);
			pData += readInfo.iReadSize;
		}

		iFileWritten += readInfo.iReadSize;

		if (hFileOut)
		{
			if (!WriteFile(hFileOut, m_szBuffer, readInfo.iReadSize, (ULONG *)&readInfo.iReadSize, NULL))
			{
				dwError = GetLastError();
				goto ErrorCase1;
			}
		}

		if (hFileCache != INVALID_HANDLE_VALUE)
		{
			if (!WriteFile(hFileCache, m_szBuffer, readInfo.iReadSize, (ULONG *)&readInfo.iReadSize, NULL))
			{
				//Again on error remove cache file and continue with download.
				//We don't want to error the download because of an performance
				//enhancement.
				CloseHandle(hFileCache);
				DeleteFile(szCacheFile);
				hFileCache = INVALID_HANDLE_VALUE;
			}
		}
	}

	if (hLocalFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLocalFile);
		hLocalFile = INVALID_HANDLE_VALUE;
	}

	if (hFileOut)
	{
		if (bUpdateFileTime)
		{
			SetFileTime(hFileOut, NULL, NULL, &ftFile);
		}
		CloseHandle(hFileOut);
	}

	if (hFileCache != INVALID_HANDLE_VALUE)
	{
		if (bUpdateFileTime)
		{
			SetFileTime(hFileCache, NULL, NULL, &ftFile);
		}
		CloseHandle(hFileCache);
	}

	if (readThread)
	{
		//clear the finished event and tell the thread function to exit since we are finished.
		ResetEvent(m_finished);
		SetEvent(m_exitEvent);

		//Wake up Every .05 seconds wake up and process messages if thread function has not exited
		do
		{
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		} while (WaitForSingleObject(m_finished, 50) != WAIT_OBJECT_0);

		CloseHandle(readThread);
	}

	if (hFileIn)
	{
		InternetCloseHandle(hFileIn);

		//
		// set the time tracking member variable
		//
		m_dwCopyTime = GetTickCount() - dwStartCopyTime;
	}

	return TRUE;

ErrorCase1:
	if (readThread)
	{
		//clear the finished event and tell the thread function to exit since we are finished.
		ResetEvent(m_finished);
		SetEvent(m_exitEvent);

		//every .05 seconds wake up and process messages if thread function has not exited
		do
		{
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		} while (WaitForSingleObject(m_finished, 50) != WAIT_OBJECT_0);

		CloseHandle(readThread);
	}

ErrorCase2:

	TRACE("CWUDownload::Copy error (%d)", dwError);

	// this error trap is necessary because a failure can happen before the read thread
	// is actually created.
	if (hFileCache != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFileCache);
		DeleteFile(szCacheFile);
	}

	if (hLocalFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLocalFile);
		hLocalFile = INVALID_HANDLE_VALUE;
	}

	if (hFileOut)
	{
		CloseHandle(hFileOut);
		DeleteFile(szDestFile);
	}

	if (hFileIn)
		InternetCloseHandle(hFileIn);

	if (pData)
		V3_free(pData);

	SetLastError(dwError);
	
	return FALSE;
}


BOOL CWUDownload::QCopy(
	IN LPCTSTR szSourceFile,
	OUT OPTIONAL PVOID *ppData,
	OUT OPTIONAL ULONG *piDataLen
	)
{
	DWORD		bytes;
	DWORD		iFileLen;
	DWORD		dwStatus;
	DWORD		iReadSize;
	PBYTE		pData;
	HINTERNET	hFileIn;
	int			iLength;
	DWORD		dwError;

	bytes			= 0;
	iFileLen		= 0;
	iReadSize		= 0;
	iLength			= 0;
	pData			= NULL;
	hFileIn			= NULL;
	dwError			= ERROR_SUCCESS;
	hFileIn			= NULL;

	if ( !ppData )
	{
		dwError = ERROR_INVALID_PARAMETER;
		goto ErrorCase;
	}

	*ppData = NULL;

	//prepend the relative url (directory) to the given path
	TCHAR szServerFilePath[INTERNET_MAX_PATH_LENGTH];
 	lstrcpyn(szServerFilePath, m_szRelURL, INTERNET_MAX_PATH_LENGTH);   
 	StrCatBuff(szServerFilePath, szSourceFile, INTERNET_MAX_PATH_LENGTH);

	TRACE("CWUDownload::QCopy: %s", szServerFilePath);

	hFileIn = HttpOpenRequest(m_hConnection, NULL, szServerFilePath, _T("HTTP/1.0"), NULL, NULL, INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION, 1);

	if ( !HttpSendRequest(hFileIn, NULL, 0, NULL, 0) )
	{
		dwError = GetLastError();
		goto ErrorCase;
	}

	iLength = sizeof(dwStatus);

	if ( !HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwStatus, (ULONG *)&iLength, NULL) )
	{
		dwError = GetLastError();
		goto ErrorCase;
	}

	//If file was not found
	if ( dwStatus != HTTP_STATUS_OK )
	{
		dwError = ERROR_FILE_NOT_FOUND;
		goto ErrorCase;
	}

	iLength = sizeof(iFileLen);

	if ( !HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, &iFileLen, (ULONG *)&iLength, NULL) )
	{
		dwError = GetLastError();
		goto ErrorCase;
	}

	if ( iFileLen > 32767 )
	{
		dwError = ERROR_BUFFER_OVERFLOW;
		goto ErrorCase;
	}

	if ( piDataLen )
		*piDataLen = iFileLen;

	try
	{
		*ppData = V3_malloc(iFileLen+1);
	}
	catch(HRESULT hr)
	{
		dwError = hr;
		goto ErrorCase;
	}

	pData = (PBYTE)*ppData;

	if ( !InternetReadFile(hFileIn, pData, iFileLen, (PULONG)&iReadSize) )
	{
		dwError = GetLastError();
		goto ErrorCase;
	}

	if ( hFileIn )
		InternetCloseHandle(hFileIn);

	return TRUE;

ErrorCase:

	if ( hFileIn )
		InternetCloseHandle(hFileIn);

	if ( ppData && *ppData )
	{
		V3_free(*ppData);
		*ppData = NULL;
	}


	hFileIn		= NULL;
	iFileLen	= 0L;
	if ( ppData )
		*ppData	= NULL;

	SetLastError(dwError);

	return FALSE;
}


BOOL CWUDownload::MemCopy(
	IN	LPCTSTR	szSourceFile,
	OUT byte_buffer& bufDest
) {
	// NOTE: we use EXACT_FILENAME which means that cache filename will be the same as server filename
	PBYTE	pMemIn;
	ULONG	cnMemInLen;
	if (!Copy(szSourceFile, NULL, (VOID**)&pMemIn, &cnMemInLen, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY | EXACT_FILENAME, NULL))
		return FALSE;
	bufDest.resize(cnMemInLen);
	memcpy(bufDest, pMemIn, cnMemInLen);
	V3_free(pMemIn);
	return TRUE;
}


BOOL CWUDownload::PostCopy(LPCTSTR pszFormData, LPCTSTR szDestFile, IWUProgress* pProgress)
{
	static const TCHAR HEADERS[] = _T("Content-Type: application/x-www-form-urlencoded\r\n");
	static const TCHAR* ACCEPT[] = {_T("Accept: */*"), NULL};
	
	DWORD		iFileWritten = 0;
	DWORD		iFileLen = 0;
	DWORD		iReadSize = 0;
	DWORD		dwStatus;
	HANDLE		hFileOut = INVALID_HANDLE_VALUE;
	HINTERNET	hFileIn = NULL;
	DWORD		dwError = ERROR_SUCCESS;
	IR_READINFO readInfo;
	DWORD		idThread = 0;
	HANDLE		readThread = NULL;
	int 		iLength = 0;
	DWORD		dwStartCopyTime;
	TCHAR		szServerFilePath[MAX_PATH];
	
	// initialize member variables
	ResetEvent(m_exitEvent);
	ResetEvent(m_readEvent);
	m_bCacheUsed = FALSE;
	m_dwCopyTime = 0;
	m_dwCopySize = 0;
	
	// record start time
	dwStartCopyTime = GetTickCount();
	
	// we expect the entire URL to be passed to the class constructor.	The m_szRelURL will contain
	// the relative URL but with a final slash.  We remove the final slash in this case
	lstrcpy(szServerFilePath, m_szRelURL);
	iLength = lstrlen(szServerFilePath);
	if (iLength > 0)
		szServerFilePath[iLength - 1] = _T('\0');

	TRACE("CWUDownload::PostCopy: %s", szServerFilePath);

	// open request
	hFileIn = HttpOpenRequest(m_hConnection, _T("POST"), szServerFilePath, NULL, NULL, ACCEPT, 0, 1);
	if (!hFileIn)
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	
	// send request
	if (!HttpSendRequest(hFileIn, HEADERS, (DWORD)-1, (void*)pszFormData, lstrlen(pszFormData) + 1))
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	
	// get status code
	iLength = sizeof(dwStatus);
	if (!HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, &dwStatus, (ULONG *)&iLength, NULL))
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	
	// if the status is not a 200 then we assume an error
	if (dwStatus != HTTP_STATUS_OK)  
	{
		dwError = ERROR_FILE_NOT_FOUND;
		goto ErrorCase;
	}
	
	// get file size
	iLength = sizeof(iFileLen);
	if (!HttpQueryInfo(hFileIn, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, &iFileLen, (ULONG *)&iLength, NULL))
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	m_dwCopySize = (DWORD)iFileLen;
	
	
	// create the file
	hFileOut = CreateFile(szDestFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFileOut == INVALID_HANDLE_VALUE)
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	
	
	// start reading
	readInfo.exitEvent	= m_exitEvent;
	readInfo.readEvent	= m_readEvent;
	readInfo.finished	= m_finished;
	readInfo.hFile		= hFileIn;
	readInfo.pBuffer	= (PBYTE)m_szBuffer;
	
	readThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReadThreadProc, &readInfo, 0, &idThread);
	if (!readThread)
	{
		dwError = GetLastError();
		goto ErrorCase;
	}
	
	while (iFileWritten < iFileLen)
	{
		iReadSize = iFileLen - iFileWritten;
		iReadSize = min(iReadSize, (UINT)m_iBufferSize);
		
		readInfo.bReturn	= FALSE;
		readInfo.iReadSize	= iReadSize;
		
		DWORD dwReadStartTime = GetTickCount();
		
		// clear the finished event and tell the thread function to begin an Internet Read.
		ResetEvent(m_finished);
		SetEvent(m_readEvent);
		
		WaitMessageLoop(m_finished);
		
		// if an error occured on read
		if (!readInfo.bReturn)
		{
			dwError = GetLastError();
			goto ErrorCase;
		}
		
		if (pProgress)
		{
			pProgress->SetDownloadAdd(readInfo.iReadSize, GetTickCount() - dwReadStartTime);
			
			// check for cancel
			if (WaitForSingleObject(pProgress->GetCancelEvent(), 0) == WAIT_OBJECT_0)
			{
				dwError = ERROR_CANCELLED; 
				goto ErrorCase;
			}
		}
		
		iFileWritten += readInfo.iReadSize;
		
		if (!WriteFile(hFileOut, m_szBuffer, readInfo.iReadSize, (ULONG *)&readInfo.iReadSize, NULL))
		{
			dwError = GetLastError();
			goto ErrorCase;
		}
		
	}

	// clean up
	CloseHandle(hFileOut);
	
	if (readThread)
	{
		// clear the finished event and tell the thread function to exit since we are finished.
		ResetEvent(m_finished);
		SetEvent(m_exitEvent);
		WaitMessageLoop(m_finished);
		CloseHandle(readThread);
	}
	InternetCloseHandle(hFileIn);
	
	m_dwCopyTime = GetTickCount() - dwStartCopyTime;
	
	return TRUE;
	
ErrorCase:
	if (readThread)
	{
		//clear the finished event and tell the thread function to exit since we are finished.
		ResetEvent(m_finished);
		SetEvent(m_exitEvent);
		WaitMessageLoop(m_finished);
		CloseHandle(readThread);
	}
	
	if (hFileOut != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFileOut);
		DeleteFile(szDestFile);
	}
	
	if (hFileIn)
	{
		InternetCloseHandle(hFileIn);
	}
	
	SetLastError(dwError);
	
	return FALSE;
}




// There is only one of these even if you have 50 CWUDownload classes. Since
// InternetReadFile() blocks, this function wraps the reading of a block of
// data in a manner that will not block the processing of messages for the
// calling thread.
//
// ARGUMENTS:
//
//		LPVOID lpParameter	pointer to a IR_READINFO structure. This structure
// 							contains information that this function needs to
//							complete the read.
//
// COMMENTS:	This function is only called via a CreateThread() call.
static DWORD ReadThreadProc(LPVOID lpParameter)
{
	PIR_READINFO	pReadInfo;
	HANDLE			events[2];
	char			szBuff[MAX_PATH];
	DWORD			dwRet = 0;

	pReadInfo = (PIR_READINFO)lpParameter;

	while( TRUE )
	{
		events[0] = pReadInfo->readEvent;
		events[1] = pReadInfo->exitEvent;

		dwRet = WaitForMultipleObjects(2, events, FALSE, INFINITE);

		switch(dwRet)
		{
			case WAIT_OBJECT_0:
				//read has been requested
				if ( InternetReadFile(pReadInfo->hFile, pReadInfo->pBuffer, pReadInfo->iReadSize, (PULONG)&pReadInfo->iReadSize) )
					pReadInfo->bReturn = TRUE;	//read finished successfully
				else
					pReadInfo->bReturn = FALSE;	//error occured on read signal caller.
				ResetEvent(pReadInfo->readEvent);
				SetEvent(pReadInfo->finished);
				break;
			case WAIT_OBJECT_0+1:
				//reading is finished exit thread handler
				SetEvent(pReadInfo->finished);
				return 0;
				break;
			default:
				LOG_block("ReadThreadProc - unexpected error case");
				//if WFMO returned WAIT_ABANDONED_0 or WAIT_FAILED for any event, we would loop forever without this case
				SetEvent(pReadInfo->finished);
				wsprintfA(szBuff,"ReadThread Proc received 0x%x from WFMO", dwRet );
				LOG_out(szBuff);
				return 0;
				break;
					
		}
	}
	return 0;
}



void WaitMessageLoop(HANDLE hHandle) 
{
	BOOL bDone = FALSE;
	while (!bDone)
	{
		DWORD dwObject = MsgWaitForMultipleObjects(1, &hHandle, FALSE, INFINITE, QS_ALLINPUT);
		if (dwObject == WAIT_OBJECT_0 || dwObject == WAIT_FAILED)
		{
			bDone = TRUE;
		}
		else
		{
			MSG msg;
			while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
	}  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\locstr.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    locstr.cpp
//
//  Purpose: Localized strings and templates
//
//  History: 18-mar-99   YAsmi    Created
//		     4-apr-99    YAsmi    Added support for templates
//
//=======================================================================

#include <locstr.h>
#include <tchar.h>
#include <atlconv.h>

//
// storage for localized strings
//
static LPCTSTR s_pszLocStr[LOCSTR_COUNT] = 
{
	
	/*IDS_PROG_DOWNLOADCAP*/  _T(""),
	/*IDS_PROG_TIMELEFTCAP*/  _T(""),
	/*IDS_PROG_INSTALLCAP*/   _T(""),
	/*IDS_PROG_CANCEL*/		  _T(""),
	/*IDS_PROG_BYTES*/		  _T("%d KB/%d KB"),
	/*IDS_PROG_TIME_SEC*/	  _T("%d sec"),
	/*IDS_PROG_TIME_MIN*/	  _T("%d min"),
	/*IDS_PROG_TIME_HRMIN*/   _T("%d hr %d min"),
	/*IDS_APP_TITLE*/		  _T("Microsoft Windows Update"),
	/*IDS_REBOOT1*/ 		  _T("You must restart Windows so that installation can finish."),
	/*IDS_REBOOT2*/ 	      _T("Do you want to restart now?")
};


//
// storage for template strings
//
static LPCTSTR s_pszTemplateStr[TEMPLATESTR_COUNT] = 
{
	/*IDS_TEMPLATE_ITEM*/		NULL,  
	/*IDS_TEMPLATE_SEC*/		NULL,
	/*IDS_TEMPLATE_SUBSEC*/ 	NULL,
	/*IDS_TEMPLATE_SUBSUBSEC*/	NULL
};


//NOTE: do not call this function more then once for the same string
//      doing so will cause a memory leak since we do not free the string this
//      function replaces
void SetLocStr(int iNum, LPCTSTR pszStr)
{
	if (iNum >= 0 && iNum < LOCSTR_COUNT)
	{
		s_pszLocStr[iNum] = _tcsdup(pszStr);
	}	
}


LPCTSTR GetLocStr(int iNum)
{
	if (iNum >= 0 && iNum < LOCSTR_COUNT)
	{
		return s_pszLocStr[iNum];
	}
	else
	{
		return NULL;
	}
}



HRESULT SetStringsFromSafeArray(VARIANT* vStringsArr, int iStringType)
{
	static BOOL bLocStrSet = FALSE;

	USES_CONVERSION;

	//
	// We want the loc strings to be set only once to avoid memory leaks
	// its ok for template strings to be set more than once
	//
	if (iStringType == LOC_STRINGS)
	{
		if (bLocStrSet)
			return S_OK;
		bLocStrSet = TRUE;
	}
	
	SAFEARRAY* psa = NULL;
	HRESULT hr;
	long cLBound, cUBound;
	LPVARIANT rgElems;
	
	if (V_VT(vStringsArr) != (VT_ARRAY | VT_VARIANT))
		return E_INVALIDARG;

	psa = V_ARRAY(vStringsArr);
	
	if (SafeArrayGetDim(psa) != 1)
		return E_INVALIDARG;
	
	hr = SafeArrayGetLBound(psa, 1, &cLBound);
	if (FAILED(hr) || cLBound != 0)
		return E_INVALIDARG;
	
	hr = SafeArrayGetUBound(psa, 1, &cUBound);
	if (FAILED(hr))
		return E_INVALIDARG;
	
	hr = SafeArrayAccessData(psa, (LPVOID*)&rgElems);
	if (FAILED(hr))
		return hr;

	for (int i = 0; i <= cUBound; i++)
	{
		if (V_VT(&rgElems[i]) != VT_BSTR)
			continue;

		// set the string into the correct array based on type
		if (iStringType == LOC_STRINGS)
		{
			SetLocStr(i, OLE2T(rgElems[i].bstrVal));
		}
		else if (iStringType == TEMPLATE_STRINGS)
		{
			SetTemplateStr(i, OLE2T(rgElems[i].bstrVal));
		}
	}
	
	(void)SafeArrayUnaccessData(psa);
	
	return S_OK;
}



void SetTemplateStr(int iNum, LPCTSTR pszStr)
{
	if (iNum >= 0 && iNum < TEMPLATESTR_COUNT)
	{
		//
		// free the existing template
		//
		if (s_pszTemplateStr[iNum] != NULL)
			free((void*)s_pszTemplateStr[iNum]);

		//
		// allocate new template
		//
		s_pszTemplateStr[iNum] = _tcsdup(pszStr);
	}	
}


// NOTE: this function will return a NULL if the template has not been set
LPCTSTR GetTemplateStr(int iNum)
{
	if (iNum >= 0 && iNum < TEMPLATESTR_COUNT)
	{
		return s_pszTemplateStr[iNum];
	}
	else
	{
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\sources.inc ===
!IF 0

Copyright (c) 1998	Microsoft Corporation

Module Name:	WUV3

Abstract:		WUV3 is a common libarary for Windows Update V3.
				This libarary forms a reprository for commonly used
				function V3 catalog functions.

!ENDIF


MAJORCOMP =WUPPT
MINORCOMP =WUV3
TARGETNAME=WUV3
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY

INCLUDES= $(INCLUDES);..\..\cdminc;..\..\inc
USE_STATIC_ATL=1
USE_MSVCRT=1
# moving these into the unicode and ansi directories' sources files
#C_DEFINES=$(C_DEFINES) /D_UNICODE /DUNICODE

SOURCES   = ..\version.cpp  \
			..\wufix.cpp	 \
			..\wuvar.cpp	 \
			..\string.cpp	 \
			..\util.cpp	\
			..\cstate.cpp	 \
			..\CWUDload.cpp \
			..\ccatalog.cpp \
			..\cbitmask.cpp \
			..\selection.cpp \
			..\applog.cpp \
			..\debug.cpp \
			..\locstr.cpp \
			..\speed.cpp

USE_NATIVE_EH=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\speed.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    speed.cpp
//
//  Purpose: Connection speed tracker
//
//  History: 12-mar-99   YAsmi    Created
//
//======================================================================= 

#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>

#include "speed.h"
#include "debug.h"


#define DEFAULT_BYTES_PER_SEC   2048	  //default bytes per second for 28.8 K modem
#define MIN_BYTES_TO_CALC_FIRST	16384u    //minimum bytes desired to calculate reliable rate the first time
#define MIN_BYTES_TO_CALC		102400u   //minimum bytes desired to calculate reliable rate

#define CONNSPEED_KEY _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate")
#define CONNSPEED_VALNAME _T("BytesPerSec")

//
// CConnSpeed class
//
DWORD CConnSpeed::m_dwBytesSoFar = 0;
DWORD CConnSpeed::m_dwTimeSoFar = 0;
DWORD CConnSpeed::m_dwAverage = 0;
DWORD CConnSpeed::m_dwNewWeightPct = 20;


void CConnSpeed::Learn(DWORD dwBytes, DWORD dwTime)
{

	// don't do anything if dwTime is not available
	if (dwTime == 0)
		return;

	// accumulate
	m_dwBytesSoFar += dwBytes;
	m_dwTimeSoFar += dwTime;
	
	//
	// if we have enough bytes, calculate new average
	//
	if ((m_dwTimeSoFar != 0) && (m_dwBytesSoFar > ((m_dwAverage == 0) ? MIN_BYTES_TO_CALC_FIRST : MIN_BYTES_TO_CALC) ))
	{
		
		DWORD dwNewAvg = (DWORD)((double)m_dwBytesSoFar / ((double)m_dwTimeSoFar / 1000));
		DWORD dwOldWeightPct = 100 - m_dwNewWeightPct;

		if (m_dwAverage != 0)
		{
			// update the average using weighted average.  
			m_dwAverage = ((dwNewAvg * m_dwNewWeightPct) + (m_dwAverage * dwOldWeightPct)) / 100;

			// increase the weight percentage for the new average
			if (m_dwNewWeightPct <= 90)
			{
				m_dwNewWeightPct += 10;
			}
		}
		else
		{
			// set the average
			m_dwAverage = dwNewAvg;
		}

		//
		// reset counters
		//
		m_dwBytesSoFar = 0;
		m_dwTimeSoFar = 0;
	}
}


DWORD CConnSpeed::BytesPerSecond()
{
	if (m_dwAverage != 0)
		return m_dwAverage;
	else
		return DEFAULT_BYTES_PER_SEC;
}


void CConnSpeed::WriteToRegistry()
{
	HKEY hKey;
	DWORD dwDisposition;

	if (m_dwAverage == 0)
		return;

	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, CONNSPEED_KEY, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) == ERROR_SUCCESS)
	{
		RegSetValueEx(hKey, CONNSPEED_VALNAME, 0, REG_DWORD, (LPBYTE)&m_dwAverage, sizeof(DWORD));
		RegCloseKey(hKey);
	}
}


void CConnSpeed::ReadFromRegistry()
{
	HKEY hKey;
	DWORD dwType;
	DWORD dwValue;
	DWORD dwSize = sizeof(dwValue);

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, CONNSPEED_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		if (RegQueryValueEx(hKey, CONNSPEED_VALNAME, NULL, &dwType, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
		{
			m_dwAverage = dwValue;
		}
		RegCloseKey(hKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\string.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    string.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <string.h>
#include <ctype.h>
#include <v3stdlib.h>
#include <stdlib.h>
#include <malloc.h>
#include <tchar.h>


const char* strcpystr(const char* pszStr, const char* pszSep, char* pszTokOut)
{
	
	if (pszStr == NULL || *pszStr == '\0')
	{
		pszTokOut[0] = '\0';
		return NULL;
	}

	const char* p = strstr(pszStr, pszSep);
	if (p != NULL)
	{
		strncpy(pszTokOut, pszStr, p - pszStr);
		pszTokOut[p - pszStr] = '\0';		
		return p + strlen(pszSep);
	}
	else
	{
		strcpy(pszTokOut, pszStr);
		return NULL;
	}
}

LPCTSTR lstrcpystr(LPCTSTR pszStr, LPCTSTR pszSep, LPTSTR pszTokOut)
{
	
	if (pszStr == NULL || *pszStr == _T('\0'))
	{
		pszTokOut[0] = _T('\0');
		return NULL;
	}

	LPCTSTR p = _tcsstr(pszStr, pszSep);
	if (p != NULL)
	{
		lstrcpyn(pszTokOut, pszStr, (int)(p - pszStr) + 1);
		pszTokOut[p - pszStr] = _T('\0');		
		return p + lstrlen(pszSep);
	}
	else
	{
		lstrcpy(pszTokOut, pszStr);
		return NULL;
	}
}



/*
 *	FUNCTION:	char *stristr(const char *string1, const char *string2)
 *
 *	PURPOSE:	This is a case insensitive version of library strstr function.
 *
 *	PARAMETERS:
 *				const char *string1		Null-terminated string to search
 *				const char *string2		Null-terminated string to search for
 *
 *	RETURNS:	char *		This function returns a pointer to the first occurrence
 *							of string2 in string1 or NULL if string2 does not appear
 *							in string1. If string2 points to a string of zero length,
 *							the function returns string1.
 *
 *	COMMENTS:				The stristr function returns a pointer to the first occurrence
 *							of string2 in string1. The search does not include terminating
 *							null characters.
 */
char *stristr(const char *string1, const char *string2)
{
	char *pSave	= (char *)string1;
	char *ps1	= (char *)string1;
	char *ps2	= (char *)string2;

	if ( !*ps1 || !ps2 || !ps1 )
		return NULL;

	if ( !*ps2 )
		return ps1;

	while( *ps1 )
	{
		while( *ps2 && (toupper(*ps2) == toupper(*ps1)) )
		{
			ps2++;
			ps1++;
		}
		if ( !*ps2 )
			return pSave;
		if ( ps2 == string2 )
		{
			ps1++;
			pSave = ps1;
		}
		else
			ps2 = (char *)string2;
	}

	return NULL;
}

LPTSTR lstristr(LPCTSTR string1, LPCTSTR string2)
{
	LPTSTR pSave	= (LPTSTR)string1;
	LPTSTR ps1	= (LPTSTR)string1;
	LPTSTR ps2	= (LPTSTR)string2;

	if ( !*ps1 || !ps2 || !ps1 )
		return NULL;

	if ( !*ps2 )
		return ps1;

	while( *ps1 )
	{
		while( *ps2 && (CharUpper((LPTSTR)*ps2) == CharUpper((LPTSTR)*ps1)) )
		{
			ps2++;
			ps1++;
		}
		if ( !*ps2 )
			return pSave;
		if ( ps2 == string2 )
		{
			ps1++;
			pSave = ps1;
		}
		else
			ps2 = (LPTSTR)string2;
	}

	return NULL;
}

/*
 *	FUNCTION:	void AddBackSlash(char *szStr)
 *
 *	PURPOSE:	This function adds a trailing back slash to a string if one does not
 *				exist. Note: This is very usefull in file handling as this capability
 *				often needed to handle directory paths.
 */
void AddBackSlash(LPTSTR szStr)
{
	int i;
	
	i = lstrlen(szStr);
	if ( szStr[i-1] != _T('\\') )
	{
		szStr[i] = _T('\\');
		szStr[i+1] = 0;
	}

	return;
}


// removes the last slash or back slash from the end of the string if found
void RemoveLastSlash(LPTSTR szPath)
{
	int l = lstrlen(szPath);
	if (l > 0)
	{
		if ((szPath[l - 1] == _T('/')) || (szPath[l - 1] == _T('\\')))
		{
			szPath[l - 1] = _T('\0');
		}
	}
}




/*
 * FUNCTION: char *SkipSpaces(char *ptr)
 * 
 * PURPOSE:		This function skips white space.
 * 
 * PARAMETERS:
 *
 *				char *ptr	A pointer to current string location where white
 *							spaces is to be skipped
 * 
 * RETURNS:
 *
 *		char *		pointer to first location in string that is not white space.
 * 
 * COMMENTS:	if the string is all white space then the position of the NULL
 *				character will be returned. This function assumes that the passed
 *				in string is NULL terminated.
 * 
 */
char *SkipSpaces(char *ptr)
{
	if (ptr)
	{
		while ( *ptr && isspace(*ptr) )
			ptr++;
		return (*ptr) ? ptr : NULL;
	}
	return NULL;
}

/*
 * FUNCTION:		char *strzncpy( char *strDest, const char *strSource, size_t count )
 *
 * PURPOSE:			This function works the same as strncpy except it ensures that that
 *					the returned string is NULL terminated at count characters. This allows
 *					a safe way to perform a strcpy since the count can be set to the
 *					sizeof(strDest).
 * 
 * PARAMETERS:
 *					strDest Destination string
 *					strSource Source string
 *					count Number of characters to be copied including NULL terminator
 * 
 * RETURNS:			Pointer to strDest
 * 
 * COMMENTS:		None
 * 
 */
char * __cdecl strzncpy( char *strDest, const char *strSource, size_t count )
{
	strncpy(strDest, strSource, count);
	strDest[count - 1] = 0;              //fix bug#3790

	return strDest;
}

/*
 * FUNCTION:		int atoh(char *ptr)
 * 
 * PURPOSE:			This function converts an hexadecimal string into it's decimal value.
 * 
 * PARAMETERS:
 *
 *		char *ptr:	pointer to string to be converted
 * 
 * RETURNS:			The converted value.
 * 
 * COMMENTS:		Like atoi this function ends the conversion on the first innvalid
 *					hex digit.
 * 
 */
int atoh(LPCSTR ptr)
{
	int		i = 0;
	char	ch;

	//skip 0x if present
	if ( ptr[0] == '0' && (ptr[1] == 'x' || ptr[1] == 'X') )
		ptr += 2;

	while( 1 )
	{
		ch = (char)toupper(*ptr);
		if ( (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') )
		{
			ch -= '0';
			if ( ch > 10 )
				ch -= 7;
			i *= 16;
			i += (int)ch;
			ptr++;
			continue;
		}
		break;
	}
	return i;
}


// replaces a single instance of pszToken with the pszValue in pszStr.  The search is case insensitive.
// memory is allocated for the new string and is returned in ppszNewStr
// the caller must free the memory if the function returns TRUE (token was replace)
// of the function returns FALSE the token was not replaced and ppszNewStr is set to NULL
BOOL ReplaceSingleToken(LPSTR* ppszNewStr, LPCSTR pszStr, LPCSTR pszToken, LPCSTR pszValue)
{
	//check for input arguments
	if (NULL == pszStr || NULL == pszToken || NULL == pszValue)
	{
		return FALSE;
	}

	LPCSTR p = stristr(pszStr, pszToken);
	LPSTR pszNew;

	if (p == NULL)
	{
		*ppszNewStr = NULL;
		return FALSE;
	}
	
	// allocate memory
	pszNew = (LPSTR)malloc(strlen(pszStr) + strlen(pszValue) - strlen(pszToken) + 1);
	if (!pszNew)
	{
		*ppszNewStr = NULL;
		return FALSE;
	}
	// copy characters before the token
	if (p > pszStr)
	{
		strncpy(pszNew, pszStr, p - pszStr);
		pszNew[p - pszStr] = '\0';
	}
	else
	{
		pszNew[0] = '\0';
	}

	// copy the value
	strcat(pszNew, pszValue);

	// move pointer to location following token
	p += strlen(pszToken);
	
	if (*p != '\0')
	{
		strcat(pszNew, p);
	}

	*ppszNewStr = pszNew;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\util.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    util.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <malloc.h>
#include <objbase.h>
#include <atlconv.h>
#include <tchar.h>
#include <shlwapi.h>
#include <v3stdlib.h>
#include <ar.h>
#define LOGGING_LEVEL 3
#include <log.h>
#include <locstr.h>
#include <osdet.h>
#include <servpaus.h>

// contains the DWORD for the current machine language (set by CallOsDet())
static DWORD s_dwLangID = 0x00000409;

// contains the DWORD for the current MUI user language (set by CallOsDet())
static DWORD s_dwUserLangID = 0x00000409;


//---------------------------------------------------------------------
// Memory management wrappers
//
// main difference is that they will throw an exception if there is
// not enough memory available.  V3_free handles NULL value
//---------------------------------------------------------------------
void *V3_calloc(size_t num, size_t size)
{
	void *pRet;

	if (!(pRet = calloc(num, size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}
	return pRet;
}


void V3_free(void *p)
{
	if (p)
		free(p);
}


void *V3_malloc(size_t size)
{
	void *pRet;

	if (!(pRet = malloc(size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	return pRet;
}


void *V3_realloc(void *memblock, size_t size)
{
	void *pRet;

	if (!(pRet = realloc(memblock, size)))
	{
		throw HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	}

	return pRet;
}



//---------------------------------------------------------------------
//  V3_CreateDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
BOOL V3_CreateDirectory(LPCTSTR pszDir)
{
	BOOL bRc;
	TCHAR szPath[MAX_PATH];

	//
	// make a local copy and remove final slash
	//
	lstrcpy(szPath, pszDir);

	int iLast = lstrlen(szPath) - 1;
	if (szPath[iLast] == _T('\\'))
		szPath[iLast] = 0;

	//
	// check to see if directory already exists
	//
	DWORD dwAttr = GetFileAttributes(szPath);

	if (dwAttr != 0xFFFFFFFF)   
	{
		if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0)
			return TRUE;
	}

	//
	// create it
	//
    TCHAR* p = szPath;
	if (p[1] == _T(':'))
		p += 2;
	else 
	{
		if (p[0] == _T('\\') && p[1] == _T('\\'))
			p += 2;
	}
	
	if (*p == _T('\\'))
		p++;
    while (p = _tcschr(p, _T('\\')))
    {
        *p = 0;
		bRc = CreateDirectory(szPath, NULL);
		*p = _T('\\');
		p++;
		if (!bRc)
		{
			if (GetLastError() != ERROR_ALREADY_EXISTS)
			{
				return FALSE;
			}
		}
	}

	bRc = CreateDirectory(szPath, NULL);
	if ( !bRc )
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			return FALSE;
		}
	}

    return TRUE;
}



void GetCurTime(SYSTEMTIME* pstDateTime)
{
	GetLocalTime(pstDateTime);
}


//---------------------------------------------------------------------
//  FileExists
//      Checks if a file exists.  
//
//  Returns:  TRUE if false exists, FALSE otherwise
//---------------------------------------------------------------------
BOOL FileExists(LPCTSTR szFile)
{
	DWORD dwAttr = GetFileAttributes(szFile);

	if (dwAttr == 0xFFFFFFFF)   //failed
		return FALSE;

	return (BOOL)(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY));
}


//-----------------------------------------------------------------------------------
//  GetWindowsUpdateDirectory
//		This function returns the location of the WindowsUpdate directory. All local
//		files are store in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
void GetWindowsUpdateDirectory(LPTSTR pszPath)
{

	static TCHAR szCachePath[MAX_PATH] = {_T('\0')};

	if (szCachePath[0] == _T('\0'))
	{
		HKEY hkey;

		pszPath[0] = _T('\0');
		if (RegOpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = MAX_PATH;
			RegQueryValueEx(hkey, _T("ProgramFilesDir"), NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == _T('\0'))
		{
			TCHAR szWinDir[MAX_PATH];
			if (! GetWindowsDirectory(szWinDir, sizeof(szWinDir) / sizeof(TCHAR)))
			{
				lstrcpy(szWinDir, _T("C"));			//if GetWinDir fails, assume C:
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = _T('\0');
			lstrcat(pszPath, _T(":\\Program Files"));
		}	

		lstrcat(pszPath, _T("\\WindowsUpdate\\"));
		
		V3_CreateDirectory(pszPath);

		//
		// save it in the cache
		//
		lstrcpy(szCachePath, pszPath);
	}
	else
	{
		lstrcpy(pszPath, szCachePath);
	}

}


//-----------------------------------------------------------------------------------
// LaunchProcess
//   Launches pszCmd and optionally waits till the process terminates
//-----------------------------------------------------------------------------------
DWORD LaunchProcess(LPCTSTR pszCmd, LPCTSTR pszDir, UINT uShow, BOOL bWait)
{
	STARTUPINFO startInfo;
	PROCESS_INFORMATION processInfo;
	
	ZeroMemory(&startInfo, sizeof(startInfo));
	startInfo.cb = sizeof(startInfo);
	startInfo.dwFlags |= STARTF_USESHOWWINDOW;
	startInfo.wShowWindow = (USHORT)uShow;
	
	BOOL bRet = CreateProcess(NULL, (LPTSTR)pszCmd, NULL, NULL, FALSE,
		NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
	if (!bRet)
	{
		return GetLastError();
	}
	
	CloseHandle(processInfo.hThread);

	if (bWait)
	{
		BOOL bDone = FALSE;
		
		while (!bDone)
		{
			DWORD dwObject = MsgWaitForMultipleObjects(1, &processInfo.hProcess, FALSE,INFINITE, QS_ALLINPUT);
			if (dwObject == WAIT_OBJECT_0 || dwObject == WAIT_FAILED)
			{
				bDone = TRUE;
			}
			else
			{
				MSG msg;
				while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}
		}  // while

	} // bWait

	CloseHandle(processInfo.hProcess);
	
	return 0;
}


// delete the whole subtree starting from current directory
bool DeleteNode(LPCTSTR szDir)
{
	LOG_block("Delnode");
	LOG_out("%s", szDir);

	TCHAR szFilePath[MAX_PATH];
	lstrcpy(szFilePath, szDir);
	PathAppend(szFilePath, _T("*.*"));

    // Find the first file
    WIN32_FIND_DATA fd;
    auto_hfindfile hFindFile = FindFirstFile(szFilePath, &fd);
    return_if_false(hFindFile.valid());

	do 
	{
		if (
			!lstrcmpi(fd.cFileName, _T(".")) ||
			!lstrcmpi(fd.cFileName, _T(".."))
		) continue;
		
		// Make our path
		lstrcpy(szFilePath, szDir);
		PathAppend(szFilePath, fd.cFileName);

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
			(fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
		) {
			SetFileAttributes(szFilePath, FILE_ATTRIBUTE_NORMAL);
		}

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			return_if_false(DeleteNode(szFilePath));
		}
		else 
		{
			return_if_false(DeleteFile(szFilePath));
		}
	} 
	while (FindNextFile(hFindFile, &fd));// Find the next entry
	hFindFile.release();

	return_if_false(RemoveDirectory(szDir));
	return true;
}



//-----------------------------------------------------------------------------------
// CallOsDet
//    calls OSDET.DLL to perform language and platform detection
//-----------------------------------------------------------------------------------
BOOL CallOsDet(LPCTSTR pszOsDetFile, PDWORD* ppiPlatformIDs, PINT piTotalIDs)
{
	BOOL bRetVal = TRUE;
	HMODULE	hLib = LoadLibrary(pszOsDetFile);
	
	if (hLib)
	{
		//
		// os detection
		//
		PFN_V3_Detection pfnV3_Detection = (PFN_V3_Detection)GetProcAddress(hLib, "V3_Detection");
		if (pfnV3_Detection)
		{
			(*pfnV3_Detection)(ppiPlatformIDs, piTotalIDs);
		}

		//
		// language detection
		//
		PFN_V3_GetLangID pfnV3_GetLangID = (PFN_V3_GetLangID)GetProcAddress(hLib, "V3_GetLangID");
		if (pfnV3_GetLangID)
		{
			s_dwLangID = (*pfnV3_GetLangID)();
		}

        //
        // user language detection
        //
        PFN_V3_GetUserLangID pfnV3_GetUserLangID = (PFN_V3_GetUserLangID)GetProcAddress(hLib, "V3_GetUserLangID");
        if (pfnV3_GetUserLangID)
		{
			s_dwUserLangID = (*pfnV3_GetUserLangID)();
		}
		
		FreeLibrary(hLib);
	}
	else
	{
		bRetVal = FALSE;
		TRACE("Could not load %s", pszOsDetFile);
	}
	
	return bRetVal;
}


//-----------------------------------------------------------------------------------
// GetMachineLangDW
//   Returns the machine language DWORD for this machine that was set by CallOsDet
//
//   NOTE: You must call CallOsDet before using this function otherwise the functions
//         will always return En (00000409)
//-----------------------------------------------------------------------------------
DWORD GetMachineLangDW()
{
	return s_dwLangID;
}

//-----------------------------------------------------------------------------------
// GetUserLangDW
//   Returns the current MUI user language DWORD for this machine that was set by CallOsDet
//
//   NOTE: You must call CallOsDet before using this function otherwise the functions
//         will always return En (00000409)
//-----------------------------------------------------------------------------------
DWORD GetUserLangDW()
{
	return s_dwUserLangID;
}



// This function determines if this client machine is running NT or Windows 98.
BOOL IsWindowsNT()
{
	OSVERSIONINFO	versionInformation;

	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);

	return (BOOL) (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


// Used to check and see if the platform supports device driver installs.
BOOL DoesClientPlatformSupportDrivers()
{
	OSVERSIONINFO osverinfo;

	osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osverinfo))
	{
		if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		{
			if (osverinfo.dwMinorVersion > 0) // Windows 98
				return TRUE;
		}
		else if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
			if (osverinfo.dwMajorVersion > 4) // NT 5 
				return TRUE;
		}
	}

	return FALSE;
}



BOOL IsAlpha()
{
	SYSTEM_INFO	sysInfo;

	GetSystemInfo(&sysInfo);

	if (sysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA)
		return TRUE;
	return FALSE;
}


// appends an extention identifying this client OS ex W98
BOOL AppendExtForOS(LPTSTR pszFN)
{
	#ifdef _WIN64
		static const TCHAR szCacheExt[] = _T("w64");
	#else
		static const TCHAR szCacheExt[] = _T("w32");
	#endif
	lstrcat(pszFN, szCacheExt);
	return TRUE;
}

// Reboots the system WITHOUT any prompts
BOOL V3_RebootSystem()
{
	 
	if (IsWindowsNT())
	{
		//check shutdown privleges
		HANDLE hToken;
		TOKEN_PRIVILEGES tkp;

		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
		{
			return FALSE;
		}

		LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );

		tkp.PrivilegeCount = 1;
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
		{
			return FALSE;
		}
	}

	//
	// shutdown the system and force all applications to close
	//
	ExitWindowsEx(EWX_REBOOT, 0);
	return FALSE;   //we should not get here
}


int CServPauser::EnableSage(int iEnable)
{

	typedef long (__stdcall *PFNDLL)(int);

	int iRet = DISABLE_AGENT;   // return DISABLE_AGENT state on failure

    HINSTANCE hSageAPI = LoadLibrary(_T("SAGE.DLL"));

    if (hSageAPI != NULL)
    {
        PFNDLL pfnSageEnable = (PFNDLL)GetProcAddress(hSageAPI,"System_Agent_Enable");
        if (pfnSageEnable)
        {
			iRet = (pfnSageEnable)(GET_AGENT_STATUS);
			if (iRet != iEnable)
            {
                (pfnSageEnable)(iEnable);
            }
        }
        FreeLibrary(hSageAPI);
    }
	return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\version.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    version.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <string.h>
#include <stdlib.h>

#include <wuv3.h>

//Private function that finds either the next , or . in the version string.
//This function returns NULL if neither character is found.

static char *NextDelimiter(char *szStr);

///////////////////////////////////////////////////////////////////////////////////
// WU Library Version conversion functions, begins
///////////////////////////////////////////////////////////////////////////////////

void __cdecl StringToVersion(LPSTR szStr, PWU_VERSION pVersion)
{
	if ( !szStr || !szStr[0] )
	{
		ZeroMemory(pVersion, sizeof(WU_VERSION));
		return;
	}

	pVersion->major = (WORD)atoi(szStr);
	szStr = NextDelimiter(szStr);
	if ( !szStr )
		throw HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	szStr++;

	pVersion->minor = (WORD)atoi(szStr);
	szStr = NextDelimiter(szStr);
	if ( !szStr )
		throw HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	szStr++;

	pVersion->build = (WORD)atoi(szStr);
	szStr = NextDelimiter(szStr);
	if ( !szStr )
	{
		pVersion->ext = 0;
		return;

	}
	szStr++;

	pVersion->ext = (WORD)atoi(szStr);

	return;
}


void __cdecl VersionToString(PWU_VERSION pVersion, LPSTR szStr)
{
	_itoa(pVersion->major, szStr, 10);
	strcat(szStr, ",");
	szStr += (strlen(szStr));

	_itoa(pVersion->minor, szStr, 10);
	strcat(szStr, ",");
	szStr += (strlen(szStr));

	_itoa(pVersion->build, szStr, 10);
	strcat(szStr, ",");
	szStr += (strlen(szStr));

	_itoa(pVersion->ext, szStr, 10);

	return;
}

int __cdecl CompareASVersions(PWU_VERSION pV1, PWU_VERSION pV2)
{
	__int64 lv1;
	__int64 lv2;

	
	lv1 =	(((__int64)pV1->major) << (__int64)40) |
			(((__int64)pV1->minor) << (__int64)32) |
			(((__int64)pV1->build) << (__int64)16) |
			(__int64)pV1->ext;

	lv2 =	(((__int64)pV2->major) << (__int64)40) |
			(((__int64)pV2->minor) << (__int64)32) |
			(((__int64)pV2->build) << (__int64)16) |
			(__int64)pV2->ext;

	return (int)(((lv1 - lv2) > 0) ? 1 : ((lv1-lv2) == 0 ) ? 0 : -1);
}

static char *NextDelimiter(char *szStr)
{
	char *ptr;

	ptr = strchr(szStr, ',');
	if ( !ptr )
	{
		ptr = strchr(szStr, '.');
		if ( !ptr )
			return NULL;
	}
	return ptr;
}


BOOL IsValidGuid(GUID* pGuid)
{
	UNALIGNED DWORD *pdw = (UNALIGNED DWORD *) pGuid;
	return (pdw[0] != 0 || pdw[1] != 0 || pdw[2] != 0 || pdw[3] != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\wufix.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wifix.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <memory.h>
#include <objbase.h>
#include <atlconv.h>

#include <v3stdlib.h>
#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

//Perf function, Since puids are used by the control every where we
//provide a quick way of returning the puid information to a caller.

PUID _INVENTORY_ITEM::GetPuid(void)
{
	if(NULL == pf)
	{
		return 0; //clients must check for 0 return
	}

	switch( recordType )
	{
		case WU_TYPE_ACTIVE_SETUP_RECORD:
			return pf->a.puid;
			break;
		case WU_TYPE_CDM_RECORD:
		case WU_TYPE_CDM_RECORD_PLACE_HOLDER:
		case WU_TYPE_RECORD_TYPE_PRINTER:
		case WU_TYPE_CATALOG_RECORD:
			return pf->d.puid;
			break;
		case WU_TYPE_SECTION_RECORD:
		case WU_TYPE_SUBSECTION_RECORD:
		case WU_TYPE_SUBSUBSECTION_RECORD:
			return pf->s.puid;
			break;
		default:
			break;
	}

	return -1;	//Error invalid record type
}

//copies information about an inventory item to a user supplied buffer.
BOOL _INVENTORY_ITEM::GetFixedFieldInfo
	(
		int	infoType,	//type of information to be returned
		PVOID	pBuffer		//caller supplied buffer for the returned information. The caller is
					//responsible for ensuring that the return buffer is large enough to
					//contain the requested information.
	)
{

	if (NULL == pf) 
	{
		return FALSE;
	}

	switch( recordType )
	{
		case WU_TYPE_ACTIVE_SETUP_RECORD:
			switch(infoType)
			{
				case WU_ITEM_GUID:
					// Check if the buffer pBuffer is not NULL
					if (NULL == pBuffer)
					{
						return FALSE;
					}
					memcpy(pBuffer, &pf->a.g, sizeof(GUID));
					return TRUE;
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->a.puid;
					return TRUE;
				case WU_ITEM_FLAGS:
					*((PBYTE)pBuffer) = pf->a.flags;
					return TRUE;
				case WU_ITEM_LINK:
					pf->a.link;
					return TRUE;
				case WU_ITEM_INSTALL_LINK:
					pf->a.installLink;
					return TRUE;
				case WU_ITEM_LEVEL:
					break;
			}
			break;
		case WU_TYPE_CDM_RECORD:
		case WU_TYPE_CDM_RECORD_PLACE_HOLDER:	//note cdm place holder record does not have an associated description record.
		case WU_TYPE_RECORD_TYPE_PRINTER:
		case WU_TYPE_CATALOG_RECORD:
			switch(infoType)
			{
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->d.puid;
					return TRUE;
				case WU_ITEM_GUID:
				case WU_ITEM_FLAGS:
				case WU_ITEM_LINK:
				case WU_ITEM_INSTALL_LINK:
				case WU_ITEM_LEVEL:
					break;
			}
			break;
		case WU_TYPE_SECTION_RECORD:
		case WU_TYPE_SUBSECTION_RECORD:
		case WU_TYPE_SUBSUBSECTION_RECORD:
			switch(infoType)
			{
				case WU_ITEM_GUID:
					// Check if the buffer pBuffer is not NULL
					if (NULL == pBuffer)
					{
						return FALSE;
					}
					memcpy(pBuffer, &pf->s.g, sizeof(GUID));
					return TRUE;
				case WU_ITEM_PUID:
					*((PUID *)pBuffer) = pf->s.puid;
					return TRUE;
				case WU_ITEM_FLAGS:
					*((PBYTE)pBuffer) = pf->s.flags;
					return TRUE;
				case WU_ITEM_LEVEL:
					*((PBYTE)pBuffer) = pf->s.level;
					break;
				case WU_ITEM_LINK:
				case WU_ITEM_INSTALL_LINK:
					break;
			}
			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\autoupd.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   autoupd.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      AutoApdateSupport
//
//=======================================================================

#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>
#include <initguid.h>
#include <inseng.h>
#include <shlwapi.h>
#include <wininet.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include <winspool.h>
#include <cstate.h>
#include <wustl.h>
#include <osdet.h>
#include "CV3.h"
#include "detect.h"
#include "callback.h"
#include "locstr.h"
#include "safearr.h"
#include "install.h"
#include "log.h"
#include "filecrc.h"
#include "newtrust.h"

#define REGKEY_WUV3TEST		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\wuv3test")

extern CState g_v3state;   //defined in CV3.CPP
extern void ProcessInstallList(Varray<DEPENDPUID>& vFinalList, int& cFinalList);

static void Cleanup(PINVENTORY_ITEM pItem);

// find auto-update catalog and get all puids in dependency order
STDMETHODIMP CCV3::BuildCatalog(BOOL fGoOnline, DWORD dwType, BSTR bstrServerUrl)
{
	LOG_block("CCV3::BuildCatalog");
	if (fGoOnline) 
	{
		LOG_out("fGoOnline = true");
	}
	else
	{
		LOG_out("fGoOnline = false");
	}
	try
	{
		// we don't want to check the launch server from this interface
		m_bLaunchServChecked = TRUE;
		
		// Configure download
		CWUDownload::s_fOffline = ! fGoOnline;

		PUID puidCatalog = 0;

#ifdef _WUV3TEST
		// catalog spoofing
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUV3TEST, 0, KEY_READ, &hkey)) {
			DWORD dwPuidCatalog = 0;
			DWORD dwSize = sizeof(dwPuidCatalog);
			if (NO_ERROR == RegQueryValueEx(hkey, _T("AutoUpdateCatalog"), 0, 0, (LPBYTE)&dwPuidCatalog, &dwSize))
			{
				LOG_out("Test override to catalog %d", dwPuidCatalog);
				puidCatalog = dwPuidCatalog;
			}
		}
		// only then do normal
		if (0 == puidCatalog)
		{
#endif
			CCatalog* pCatalogList = ProcessCatalog(0, bstrServerUrl, 0, 0, WU_ALL_ITEMS, 0);
			if (NULL == pCatalogList)
			{
				LOG_error("Cannot open catalog list");
				return E_FAIL;
			}
			for(int nCatalog = 0; nCatalog < pCatalogList->GetHeader()->totalItems; nCatalog ++)
			{
				PINVENTORY_ITEM pItem = pCatalogList->GetItem(nCatalog);
				if (NULL == pItem)
				{
					continue;
				}
				if (pItem->ps->state != WU_ITEM_STATE_PRUNED && (pItem->pf->d.flags & dwType))
				{
					puidCatalog = pItem->pf->d.puid;
					LOG_out("Found AutoUpdate catalog %d", puidCatalog);
					break;
				}
			}
#ifdef _WUV3TEST
		}
#endif

		if (0 == puidCatalog)
		{
			LOG_error("Can't find AU catalog puid");
			return E_FAIL;
		}

		m_pCatalogAU = ProcessCatalog(puidCatalog, bstrServerUrl, 0, 0, WU_ALL_ITEMS, 0);
		if (NULL == m_pCatalogAU)
		{
			LOG_error("Cannot open catalog");
			return E_FAIL;
		}

		ReadHiddenPuids();
	
		// download common images and other files
		if (fGoOnline)
		{
			TCHAR szRtfDir[MAX_PATH];		
			GetWindowsUpdateDirectory(szRtfDir);
			PathAppend(szRtfDir, _T("RTF"));
			V3_CreateDirectory(szRtfDir);
			(void)DownloadCommonRTFFiles(FALSE, NULL);
		}

	}
	catch(HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}

// find auto-update catalog and get all puids in dependency order
STDMETHODIMP CCV3::GetPuidsList(LONG* pcnPuids, PUID** ppPuids)
{
	LOG_block("CCV3::GetPuidsList");
	HRESULT hrRet = S_OK;
	try
	{
		// Builds correct dependency array
		Varray<DEPENDPUID> vFinalList;
		int cFinalList = 0;
		ProcessInstallList(vFinalList, cFinalList);
		if (0 == cFinalList)
			return E_INVALIDARG;

		//output it
		m_apuids.resize(cFinalList);
		PUID* pPuids = m_apuids;
		for (int nPuid = 0; nPuid < cFinalList; nPuid++)
			pPuids[nPuid] = vFinalList[nPuid].puid;
		*pcnPuids = m_apuids.size();
		*ppPuids = m_apuids;
	}
	catch(HRESULT hr)
	{
		LOG_error("error %08X", hr);
		hrRet = hr;
	}
	return hrRet;
}

static void UrlAppend(LPTSTR pszURL, LPCTSTR pszPath)
{
	if (_T('/') != pszURL[lstrlen(pszURL) - 1])
		lstrcat(pszURL, _T("/"));
	lstrcat(pszURL, pszPath);
}

STDMETHODIMP CCV3::QueryDownloadFiles(long puid, void* pCallbackParam, PFN_QueryDownloadFilesCallback pCallback)
{
	LOG_block("CCV3::QueryDownloadFiles");
	LOG_out("puid %d", puid);
	try
	{
		USES_CONVERSION;

		PINVENTORY_ITEM pItem;
		if (!g_v3state.GetCatalogAndItem(puid, &pItem, NULL))
			return E_INVALIDARG;

		// Buffers that we will use
		TCHAR szURL[INTERNET_MAX_URL_LENGTH];
		TCHAR szLocalFile[MAX_PATH];		

		// CIF
		if (pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD)
		{
			PWU_VARIABLE_FIELD pvCif = pItem->pd->pv->Find(WU_DESC_CIF_CRC);
			if (NULL == pvCif)
				return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

			TCHAR szCifBaseName[16];
			wsprintf(szCifBaseName, _T("%d.cif"), puid); 

			TCHAR szCifCRCName[64];
			HRESULT hr = MakeCRCName(szCifBaseName, (WUCRC_HASH*)pvCif->pData, szCifCRCName, sizeof(szCifCRCName));
			if (FAILED(hr))
				return hr;

			GetWindowsUpdateDirectory(szLocalFile);
			PathAppend(szLocalFile, szCifBaseName);
	
			lstrcpy(szURL, g_v3state.GetRootServer());
			UrlAppend(szURL, _T("CRCCif"));
			UrlAppend(szURL, szCifCRCName);
			
			pCallback(pCallbackParam, puid, T2W(szURL), T2W(szLocalFile));
		}

		// read this first pages
		PWU_VARIABLE_FIELD pvRTFCRC = pItem->pd->pv->Find(WU_DESC_RTF_CRC_ARRAY);
		if (pvRTFCRC != NULL)
		{
			PWU_VARIABLE_FIELD pvRTFImages = pItem->pd->pv->Find(WU_DESC_RTF_IMAGES);

			// build a multisz string of file names
			BYTE mszFileNames[512];
			int iLen = sprintf((char*)mszFileNames, "%d.htm", pItem->GetPuid());
			mszFileNames[++iLen] = '\0';
			if (pvRTFImages != NULL)
			{
				// we have images
				memcpy(mszFileNames + iLen, pvRTFImages->pData, pvRTFImages->len - 4);
			}
	
			// local directory
			TCHAR szLocalDir[MAX_PATH];		
			GetWindowsUpdateDirectory(szLocalDir);
			wsprintf(szLocalFile, _T("RTF\\%d"), pItem->GetPuid());	// reuse szLocalFile as a temp buffer
			PathAppend(szLocalDir, szLocalFile);

			for(int iFileNo = 0; true; iFileNo++)
			{
				TCHAR szLocalName[128];
				TCHAR szServerName[128];
				if (FAILED(GetCRCNameFromList(iFileNo, mszFileNames, pvRTFCRC->pData, szServerName, sizeof(szServerName), szLocalName)))
				{
					// end of the list
					break;
				}

				// build full paths	
				lstrcpy(szLocalFile, szLocalDir);
				PathAppend(szLocalFile, szLocalName);

				lstrcpy(szURL, g_v3state.GetRootServer());
				UrlAppend(szURL, _T("CRCRtf"));
				UrlAppend(szURL, szServerName);

				LOG_out("%s  -  %s", szURL, szLocalFile);
				pCallback(pCallbackParam, puid, T2W(szURL), T2W(szLocalFile));

			} // for
		}

		// Cabs
		TCHAR szLocalDir[MAX_PATH];		
		GetWindowsUpdateDirectory(szLocalDir);
		wsprintf(szLocalFile, _T("Cabs\\%d"), puid);	// reuse szLocalFile as a temp buffer
		PathAppend(szLocalDir, szLocalFile);

		//See if the package has a server override defined.
		PWU_VARIABLE_FIELD pvServer = pItem->pd->pv->Find(WU_DESCRIPTION_SERVERROOT);
		LPCTSTR pszCabPoolServer = pvServer ? A2T((LPSTR)(pvServer->pData)) : g_v3state.GetCabPoolServer();

		PWU_VARIABLE_FIELD pvCabs = pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
		PWU_VARIABLE_FIELD pvCRCs = pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);

		if (NULL == pvCabs || NULL == pvCRCs)
		{
			// Active setup items can have no cabs
			if( pItem->recordType != WU_TYPE_ACTIVE_SETUP_RECORD)
				return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		}
		else
		{
			for(int iCabNo = 0; true; iCabNo++)
			{
				TCHAR szLocalCab[128];
				TCHAR szServerCab[128];
				if (FAILED(GetCRCNameFromList(iCabNo, pvCabs->pData, pvCRCs->pData, szServerCab, sizeof(szServerCab) , szLocalCab)))
					break;

				PathCombine(szLocalFile, szLocalDir, szLocalCab);

				lstrcpy(szURL, pszCabPoolServer);
				UrlAppend(szURL, _T("CabPool"));
				UrlAppend(szURL, szServerCab);

				LOG_out("%s  -  %s", szURL, szLocalFile);
				pCallback(pCallbackParam, puid, T2W(szURL), T2W(szLocalFile));
			}
		}

	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}

STDMETHODIMP CCV3::GetCatalogArray(VARIANT *pCatalogArray)
{
	LOG_block("CCV3::GetCatalogArray");
	try
	{
		return MakeReturnCatalogArray(m_pCatalogAU, WU_UPDATE_ITEMS, 0, pCatalogArray);
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;

}

STDMETHODIMP CCV3::SelectAllPuids()
{
	LOG_block("CCV3::SelectAllPuids");
	try
	{
		for(int nItem = 0; nItem < m_pCatalogAU->GetHeader()->totalItems; nItem ++)
		{
			PINVENTORY_ITEM pItem = m_pCatalogAU->GetItem(nItem);
			if (NULL == pItem)
			{
				continue;
			}
			if (! pItem->ps->bHidden &&	(
				WU_TYPE_ACTIVE_SETUP_RECORD == pItem->recordType ||
				WU_TYPE_CDM_RECORD == pItem->recordType ||
				WU_TYPE_RECORD_TYPE_PRINTER == pItem->recordType
			) && (
				WU_ITEM_STATE_INSTALL == pItem->ps->state || 
				WU_ITEM_STATE_UPDATE == pItem->ps->state
			)) {
				PUID puid = (WU_TYPE_ACTIVE_SETUP_RECORD == pItem->recordType) ? pItem->pf->a.puid : pItem->pf->d.puid;
				if (!IsPuidHidden(puid))
					g_v3state.m_selectedItems.Select(puid, TRUE);
			}
		}
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}


STDMETHODIMP CCV3::UnselectAllPuids()
{
	LOG_block("CCV3::UnselectAllPuids");
	try
	{
		g_v3state.m_selectedItems.Clear();
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}


STDMETHODIMP CCV3::SelectPuid(long puid)
{
	LOG_block("CCV3::SelectPuid");
	try
	{
		if (IsPuidHidden(puid))
			throw E_INVALIDARG;

		g_v3state.m_selectedItems.Select(puid, TRUE);
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}


STDMETHODIMP CCV3::UnselectPuid(long puid)
{
	LOG_block("CCV3::UnselectPuid");
	try
	{
		if (IsPuidHidden(puid))
			throw E_INVALIDARG;

		g_v3state.m_selectedItems.Unselect(puid);
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}

static void RemoveFiles(long puid, bool fCif)
{
	TCHAR szBaseName[16];
	TCHAR szLocalFile[MAX_PATH];
	if (fCif)
	{
		wsprintf(szBaseName, _T("%d.cif"), puid); 
		GetWindowsUpdateDirectory(szLocalFile);
		PathAppend(szLocalFile, szBaseName);
		DeleteFile(szLocalFile);
	}

	wsprintf(szBaseName, _T("Cabs\\%d"), puid);
	GetWindowsUpdateDirectory(szLocalFile);
	PathAppend(szLocalFile, szBaseName);
	DeleteNode(szLocalFile);

	wsprintf(szBaseName, _T("RTF\\%d"), puid);
	GetWindowsUpdateDirectory(szLocalFile);
	PathAppend(szLocalFile, szBaseName);
	DeleteNode(szLocalFile);
}

STDMETHODIMP CCV3::HidePuid(long puid)
{
	LOG_block("CCV3::HidePuid");
	try
	{
		PINVENTORY_ITEM pItem;
		if (!g_v3state.GetCatalogAndItem(puid, &pItem, NULL))
			return E_INVALIDARG;

		// Hide it in catalog
		pItem->ps->bHidden = TRUE;
		pItem->ps->dwReason = WU_STATE_REASON_BACKEND;

		// Unselect it
		g_v3state.m_selectedItems.Unselect(puid);
		HidePuidAndSave(puid);

		RemoveFiles(puid, pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD);
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}


STDMETHODIMP CCV3::InstallSelectedPuids(void* pCallbackParam, PFN_InstallCallback pCallback)
{
	LOG_block("CCV3::InstallSelectedPuids");

	try
	{
		// Builds correct dependency array
		Varray<DEPENDPUID> vFinalList;
		int cFinalList = 0;
		ProcessInstallList(vFinalList, cFinalList);

		//output it
		for (int nPuid = 0; nPuid < cFinalList; nPuid++)
		{		
			PINVENTORY_ITEM pItem;
			if (!g_v3state.GetCatalogAndItem(vFinalList[nPuid].puid, &pItem, NULL))
				throw E_FAIL;

			SELECTITEMINFO info;
			info.bInstall = TRUE;
			info.puid = vFinalList[nPuid].puid;
			info.iStatus = ITEM_STATUS_SUCCESS;
			info.hrError = S_OK;
			InstallItemAU(pItem, &info);
			LOG_out("%d status %d error %d(%08X)\n", info.puid, info.iStatus, info.hrError, info.hrError);
			pCallback(pCallbackParam, info.puid, info.iStatus, info.hrError);
		}
	}
	catch(HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}

STDMETHODIMP CCV3::CleanupCabsAndReadThis(void)
{
	LOG_block("CCV3::CleanupCabsAndReadThis");

	TCHAR szCabDir[MAX_PATH];		
	GetWindowsUpdateDirectory(szCabDir);
	PathAppend(szCabDir, _T("Cabs"));
	DeleteNode(szCabDir);

	CleanupReadThis();
	return S_OK;
}

STDMETHODIMP CCV3::UnhideAllPuids(void)
{
	LOG_block("CCV3::CleanupCabsAndReadThis");
	RegDeleteKey(HKEY_LOCAL_MACHINE, REGISTRYHIDING_KEY);
	return S_OK;
}

STDMETHODIMP CCV3::StatusReport(long puid, LPCSTR pszStatus)
{
	LOG_block("CCV3::StatusReport");
	try
	{
		PINVENTORY_ITEM pItem;
		if (!g_v3state.GetCatalogAndItem(puid, &pItem, NULL))
		{
			LOG_error("invalid arg");
			return E_INVALIDARG;
		}
		CWUDownload	dl(g_v3state.GetIdentServer(), 8192);

		// build the URL with parameters
		TCHAR szURL[INTERNET_MAX_PATH_LENGTH];
		wsprintf(szURL, _T("wutrack.bin?PUID=%d&PLAT=%d&LOCALE=%s&STATUS=%s&RID=%4.4x%4.4x"), 
						pItem->GetPuid(), 
						m_pCatalogAU->GetPlatform(),
						m_pCatalogAU->GetMachineLocaleSZ(),
						pszStatus,
						rand(),
						rand());

		// ping the URL and receive the response in memory
		PVOID pMemBuf;
		ULONG ulMemSize;
		if (dl.QCopy(szURL, &pMemBuf, &ulMemSize))
		{
			// we don't care about the response so we just free it
			LOG_error("%s", szURL);
			V3_free(pMemBuf);	
		}
		else
		{
			LOG_out("%s", szURL);
		}
	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
	}
	return S_OK;
}

STDMETHODIMP CCV3::DownloadReadThisPage(long puid)
{
	LOG_block("CCV3::DownloadReadThisPage");
	LOG_out("puid = %d", puid);
	try
	{
		PINVENTORY_ITEM pItem;
		if (!g_v3state.GetCatalogAndItem(puid, &pItem, NULL))
		{
			LOG_error("no item");
			return E_INVALIDARG;
		}

		return DownloadReadThis(pItem);

	}
	catch (HRESULT hr)
	{
		LOG_error("error %08X", hr);
		return hr;
	}
	return S_OK;
}


void CCV3::InstallItemAU(PINVENTORY_ITEM pItem, PSELECTITEMINFO pinfo)
{
	LOG_block("CCV3::InstallItemAU");
	try
	{
		GetCurTime(&(pinfo->stDateTime));

		CDiamond diamond;
	
		// local directory
		TCHAR szLocalDir[MAX_PATH];		
		GetWindowsUpdateDirectory(szLocalDir);

		TCHAR szTmp[40];		
		wsprintf(szTmp, _T("Cabs\\%d"), pinfo->puid);
		PathAppend(szLocalDir, szTmp);

		// Decompress cab files
		PWU_VARIABLE_FIELD pvCabs = pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
		PWU_VARIABLE_FIELD pvCRCs = pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);

		if (NULL != pvCabs && NULL != pvCRCs)
		{
			for(int iCabNo = 0; true; iCabNo++)
			{
				TCHAR szLocalCab[128];
				TCHAR szLocalFile[MAX_PATH]; // we don't care about server file name
				if (FAILED(GetCRCNameFromList(iCabNo, pvCabs->pData, pvCRCs->pData, szLocalFile, sizeof(szLocalFile), szLocalCab)))
					break;

				PathCombine(szLocalFile, szLocalDir, szLocalCab);
			
				// check signature of the download CAB file
				// Don't show MS cert.
                // use the VerifyFile function (see WU bug # 12251)
				HRESULT hr = VerifyFile(szLocalFile, FALSE);
				if (FAILED(hr))
					throw hr;

				if( pItem->recordType != WU_TYPE_ACTIVE_SETUP_RECORD && diamond.IsValidCAB(szLocalFile))
					diamond.Decompress(szLocalFile, _T("*"));
			}
		}

		switch (pItem->recordType)
		{
			case WU_TYPE_ACTIVE_SETUP_RECORD:
				{
					TCHAR szCIFFile[MAX_PATH];		
					TCHAR szCifBaseName[16];
					wsprintf(szCifBaseName, _T("%d.cif"), pItem->GetPuid()); 
					GetWindowsUpdateDirectory(szCIFFile);
					PathAppend(szCIFFile, szCifBaseName);

					// Decompress if we need to
					if (diamond.IsValidCAB(szCIFFile))
					{
						TCHAR szTmpCif[MAX_PATH];
						lstrcpy(szTmpCif, szCIFFile);
						lstrcpy(szTmpCif, _T(".cab"));
						MoveFile(szCIFFile, szTmpCif);
						diamond.Decompress(szTmpCif, szCIFFile);
						DeleteFile(szTmpCif);				
					}
					LOG_out("calling InstallActiveSetupItem(szLocalDir=%s, szCIFFile=%s) for puid %d", szLocalDir, szCIFFile, pinfo->puid);
					InstallActiveSetupItem(szLocalDir, szCIFFile, pinfo, NULL);
				}
				break;

			case WU_TYPE_CDM_RECORD:
				LOG_out("calling InstallDriverItem(szLocalDir=%s) for puid %d", szLocalDir, pinfo->puid);
				InstallDriverItem(szLocalDir, IsWindowsNT(), _T(""), pItem, pinfo);
				break;

			case WU_TYPE_RECORD_TYPE_PRINTER:
				{
					PWU_VARIABLE_FIELD  pvDriverName = pItem->pv->Find(WU_CDM_DRIVER_NAME); 
					PWU_VARIABLE_FIELD  pvArchitecture = pItem->pv->Find(WU_CDM_PRINTER_DRIVER_ARCH);
					if (NULL == pvDriverName || NULL == pvArchitecture)
						throw E_UNEXPECTED; // should never happen
					LOG_out("calling InstallPrinterItem(szDriverName=%s, szLocalDir=%s) for puid %d", (LPCTSTR)pvDriverName->pData, szLocalDir, pinfo->puid);
					InstallPrinterItem((LPCTSTR)pvDriverName->pData, szLocalDir, (LPCTSTR)pvArchitecture->pData);
				}
				break;

			case WU_TYPE_CDM_RECORD_PLACE_HOLDER:
			case WU_TYPE_SECTION_RECORD:
			case WU_TYPE_SUBSECTION_RECORD:
			case WU_TYPE_SUBSUBSECTION_RECORD:
			default:
				LOG_error(" cannot install recordtype %d for puid %d", pItem->recordType, pinfo->puid);
				throw E_UNEXPECTED;
		}
	}
	catch(HRESULT hr)
	{
		pinfo->iStatus = ITEM_STATUS_FAILED;
		pinfo->hrError = hr;
	}
	// Cleanup
	RemoveFiles(pItem->GetPuid(), pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD);
	UpdateInstallHistory(pinfo, 1);
}


void CCV3::ReadHiddenPuids()
{
	auto_hkey hKey;
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRYHIDING_KEY, 0, KEY_READ, &hKey))
	{
		DWORD dwSize;
		if (
			NO_ERROR == RegQueryValueEx(hKey, _T("AutoUpdateItems"), NULL, NULL, NULL, &dwSize)
			&& dwSize > 0
		) {
			m_abHiddenPuids.resize(dwSize);
			if (NO_ERROR != RegQueryValueEx(hKey, _T("AutoUpdateItems"), NULL, NULL, m_abHiddenPuids, &dwSize))
				m_abHiddenPuids.resize(0);
		}
	}
	PUID* ppuidHidden =(PUID*)(LPBYTE)m_abHiddenPuids;
	for(int nOffset = 0; nOffset < m_abHiddenPuids.size(); nOffset += sizeof(PUID))
	{
		PINVENTORY_ITEM pItem;
		if (g_v3state.GetCatalogAndItem(*ppuidHidden, &pItem, NULL))
		{
			// Hide it in catalog
			pItem->ps->bHidden = TRUE;
			pItem->ps->dwReason = WU_STATE_REASON_BACKEND;
		}
		ppuidHidden ++;
	}

}


bool CCV3::IsPuidHidden(PUID puid)
{
	PUID* ppuidHidden =(PUID*)(LPBYTE)m_abHiddenPuids;
	for(int nOffset = 0; nOffset < m_abHiddenPuids.size(); nOffset += sizeof(PUID))
	{
		if (*ppuidHidden == puid)
			return true;
		ppuidHidden ++;
	}
	return false;
}

void CCV3::HidePuidAndSave(PUID puid)
{
	// Bug 378289
	// The following block of reading the registry value and putting it into m_abHiddenPuids has been added.
	// This is because, in the earlier case the m_abHiddenPuids would be read the first time from the registry 
	// and would hold on to the registry values. 
	// Due to this it would not reflect the new changes made by the user (eg. Clear History), and would write back the old values in m_abHiddenPuids back onto the registry
	// By making the following change m_abHiddenPuids contains the updated registry values.

	m_abHiddenPuids.resize(0);
	auto_hkey hKey;
	if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRYHIDING_KEY, 0, KEY_READ, &hKey))
	{
		DWORD dwSize;
		if (
			NO_ERROR == RegQueryValueEx(hKey, _T("AutoUpdateItems"), NULL, NULL, NULL, &dwSize)
			&& dwSize > 0
		) {
			m_abHiddenPuids.resize(dwSize);
			if (NO_ERROR != RegQueryValueEx(hKey, _T("AutoUpdateItems"), NULL, NULL, m_abHiddenPuids, &dwSize))
				m_abHiddenPuids.resize(0);
		}
	}

	if (IsPuidHidden(puid))
		return;

	int cbSize = m_abHiddenPuids.size();
	m_abHiddenPuids.resize(cbSize + sizeof(PUID));
	*(PUID*)((LPBYTE)m_abHiddenPuids + cbSize) = puid;

	DWORD dwDisposition;
	if (NO_ERROR == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGISTRYHIDING_KEY, 0, _T(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition))
	{
		if (0 == m_abHiddenPuids.size())
		{
			RegDeleteValue(hKey, _T("AutoUpdateItems"));
		}
		else
		{
			RegSetValueEx(hKey, _T("AutoUpdateItems"), 0, REG_BINARY, m_abHiddenPuids, m_abHiddenPuids.size());
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\callback.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    callback.h
//
//  Purpose: INSENG callback implementation
//
//  History: 19-jan-99   YAsmi    Created
//
//=======================================================================
 
#ifndef _CALLBACK_H
#define _CALLBACK_H

#include "stdafx.h"
#include "inseng.h"
#include "cwudload.h"


class CInstallEngineCallback : public IInstallEngineCallback
{
public:
	CInstallEngineCallback();

	// IUnknown
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, void**); 

	// IInstallEngineCallback
	STDMETHOD(OnEngineStatusChange)(THIS_ DWORD dwEngStatus, DWORD substatus);
	STDMETHOD(OnStartInstall)(THIS_ DWORD dwDLSize, DWORD dwInstallSize);
	STDMETHOD(OnStartComponent)(THIS_ LPCSTR pszID, DWORD dwDLSize, 
										 DWORD dwInstallSize, LPCSTR pszString);
	STDMETHOD(OnComponentProgress)(THIS_ LPCSTR pszID, DWORD dwPhase, 
									LPCSTR pszString, LPCSTR pszMsgString, ULONG progress, ULONG themax);
	STDMETHOD(OnStopComponent)(THIS_ LPCSTR pszID, HRESULT hError, 
									DWORD dwPhase, LPCSTR pszString, DWORD dwStatus);
	STDMETHOD(OnStopInstall)(THIS_ HRESULT hrError, LPCSTR szError, 
									DWORD dwStatus); 
	STDMETHOD(OnEngineProblem)(THIS_ DWORD dwProblem, LPDWORD dwAction); 

	void Reset();
	
	DWORD GetStatus() 
	{
		return m_dwInstallStatus;
	}

	DWORD GetPhase() 
	{
		return m_dwPhase;
	}
	
	DWORD LastError() 
	{
		return m_hResult;
	}

	void SetProgressPtr(IWUProgress* pProgress)
	{
		m_pProgress = pProgress;
	}

	void SetEnginePtr(IInstallEngine2* pEngine)
	{
		m_pEngine = pEngine;
	}


private:
	ULONG m_cRef;

	DWORD m_dwPhase;
	HRESULT m_hResult;
	DWORD m_dwInstallStatus;
	IWUProgress* m_pProgress;
	IInstallEngine2* m_pEngine;
	BOOL m_bAborted;
};



#endif //_CALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\callback.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:	 callback.cpp	
//
//  Purpose: INSENG callback implementation
//
//  History: 19-jan-99	 YAsmi	 Created
//
//=======================================================================

#include "callback.h"
 

CInstallEngineCallback::CInstallEngineCallback()
{
	m_cRef = 0;
	m_pProgress = NULL;
	m_pEngine = NULL;
	Reset();
}


void CInstallEngineCallback::Reset()
{
	m_dwInstallStatus = 0;
	m_dwPhase = INSTALLSTATUS_INITIALIZING;
	m_hResult = NOERROR;
	m_bAborted = FALSE;
}



//
//IUnknown
//
STDMETHODIMP_(ULONG) CInstallEngineCallback::AddRef() 							
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CInstallEngineCallback::Release()
{
	if (--m_cRef != 0)
		return m_cRef;

	//we don't delete the object here because we want the client of the object to explicitly delete it
	return 0;
}


STDMETHODIMP CInstallEngineCallback::QueryInterface(REFIID riid, void** ppv)
{
	*ppv = NULL;

	if((riid == IID_IUnknown) || (riid == IID_IInstallEngineCallback))
		*ppv = this;
	
	if(*ppv == NULL)
		return E_NOINTERFACE;
	
	((LPUNKNOWN)*ppv)->AddRef();
	return NOERROR;
}


//
//IInstallEngineCallback
//
STDMETHODIMP CInstallEngineCallback::OnComponentProgress(LPCSTR pszID, DWORD dwPhase, LPCSTR pszString, LPCSTR pszMsgString, ULONG ulSofar, ULONG ulMax)
{

	/*
	if(dwPhase == INSTALLSTATUS_RUNNING)
		_pProgDlg->SetInsProgress(ulSofar);
	*/

	m_dwPhase = dwPhase;

	if (m_pProgress != NULL)
	{
		//
		// check for cancel
		//
		if (m_pEngine != NULL)
		{
			if (!m_bAborted)
			{
				if (WaitForSingleObject(m_pProgress->GetCancelEvent(), 0) == WAIT_OBJECT_0)
					m_bAborted = TRUE;
			}

			if (m_bAborted)
			{
				//
				// keep telling the engine to abort
				//
				m_pEngine->Abort(0);
			}

		}
	}

	return NOERROR;
}



STDMETHODIMP CInstallEngineCallback::OnStopComponent(LPCSTR pszID, HRESULT hrError, DWORD dwPhase, LPCSTR pszString, DWORD dwStatus)
{
	return NOERROR;
}


STDMETHODIMP CInstallEngineCallback::OnEngineStatusChange(DWORD dwEngineStatus, DWORD sub)
{

	return NOERROR;
}




STDMETHODIMP CInstallEngineCallback::OnStartInstall(DWORD dwDLSize, DWORD dwTotalSize)
{
	/*
	if(_pProgDlg)
		_pProgDlg->SetInsProgGoal(dwTotalSize);
	*/
	return NOERROR;
}


STDMETHODIMP CInstallEngineCallback::OnStartComponent(LPCSTR pszID, DWORD dwDLSize, 
														  DWORD dwInstallSize, LPCSTR pszName)
{
	/*
	_strCurrentName = BSTRFROMANSI(pszName);
	*/
	return NOERROR;
}



STDMETHODIMP CInstallEngineCallback::OnEngineProblem(DWORD dwProblem, LPDWORD pdwAction)
{
	return S_OK;
}


STDMETHODIMP CInstallEngineCallback::OnStopInstall(HRESULT hrError, LPCSTR szError, DWORD dwStatus)
{
  
	m_hResult = hrError;
	m_dwInstallStatus = dwStatus;

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3\wuvar.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    wuvar.cpp
//
//  Purpose:
//
//=======================================================================

#include <windows.h>
#include <v3stdlib.h>
#include <varray.h>
#include <wuv3.h>

//The GetNext function returns a pointer to the next variable array item in a
//variable chain. If the next variable item does not exit then this method
//return NULL.

PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::GetNext
	(
		void
	)
{
	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;
	if ( pv->id == WU_VARIABLE_END )
		return NULL;

	pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);

	return pv;
}

//find a variable item in a variable item chain.
PWU_VARIABLE_FIELD WU_VARIABLE_FIELD::Find
	(
		short id	//id of variable size field to search for in the variable size chain.
	)
{
	PWU_VARIABLE_FIELD	pv;

	//walk though the varaible field array associated with this data item
	//and return the requested item or NULL if the item is not found.
	pv = this;

	//If this variable record only contains an end record then we
	//need to handle it specially since the normal find loop
	//updates the pv pointer before the end check is made so if
	//end is the first field it can be missed.

	if ( pv->id == WU_VARIABLE_END )
		return ( id == WU_VARIABLE_END ) ? pv : (PWU_VARIABLE_FIELD)NULL;

	do
	{
		if ( pv->id == id )
			return pv;

        //NT Bug #255962 - this prevents a non-terminal loop if the len is 0
	    if(NULL == pv->len)
		    return (PWU_VARIABLE_FIELD)NULL;

		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	} while( (NULL != pv) && (pv->id != WU_VARIABLE_END) );
 
	//case where caller asked to search for the WU_VARIABLE_END field
	if ( (NULL != pv) && (pv->id == id) )
		return pv;

	return (PWU_VARIABLE_FIELD)NULL;
}

//Variable size field constructor.

_WU_VARIABLE_FIELD::_WU_VARIABLE_FIELD()
{
	id = WU_VARIABLE_END;
	len = sizeof(id) + sizeof(len);
}

//returns the total size of a variable field
int _WU_VARIABLE_FIELD::GetSize
	(
		void
	)
{
	PWU_VARIABLE_FIELD	pv;
	int					iSize;

	iSize = 0;
	pv = this;

	while( (NULL != pv) && (pv->id != WU_VARIABLE_END) )
	{
		//check if the len value is greater that 0 otherwise it might go in an infinite loop
		if (pv->len < 1)
		{
			return 0;
		}

		iSize += pv->len;
		pv = (PWU_VARIABLE_FIELD)((PBYTE)pv + pv->len);
	}

	if (NULL != pv)
	{
		iSize += pv->len;
	}

	return iSize;
}

//This function will seem tricky at first. The problem here is that the
//returned variable field array needs to be in a single block of memory.
//The reason that the memory must be contigous is that the variable field
//items that walk from one record to the next use the len parameter to find
//the beginning of the next variable record. This then prevents us from
//being able to simply take the pvNew pointer and add it to the variable
//field array. Instead we calulate the new needed size of the array and
//realloc the current pointer to this new size. We then copy the pvNew
//pointer into the newly sized array.

//The other problem here is that we cannot change the this pointer for the
//variable field array while inside a function handler for a variable field.
//So each structure that needs to manage variable fields needs one of these
//add functions. We could have set this up as a virtual function however this
//would have added a vtable to the structure. Since we are interested in the
//keeping the code size as small as possible this vtable is best avoided.

//This function has to be handled outside of the inventory item structure
//because the inventory item needs to be a continuous block of memory for
//file management. So when we add a variable field to the structure we also
//need to reallocate item structure. If we were to put this function into
//the inventory structure then we would not be able to do this because of
//this pointer semantics.

//Note: In order to use this function a valid pItem must already exist and
//since a pItem exits it must contain at least one variable type field which
//needs to be an end field.

void __cdecl AddVariableSizeField
	(
		PINVENTORY_ITEM *pItem,		//pointer to inventory item variable size field chain.
		PWU_VARIABLE_FIELD pvNew	//pointer to new variable size field to add.
	)
{
	int					iSize;
	PWU_VARIABLE_FIELD	pvTmp;

	//calculate the size needed by the new variable field array
	iSize = sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED) + (*pItem)->pv->GetSize() + pvNew->len;

	//realloc array and fix up variable pointer

	*pItem = (PINVENTORY_ITEM)V3_realloc(*pItem, iSize);

	(*pItem)->pf = (PWU_INV_FIXED)(((PBYTE)(*pItem)) + sizeof(INVENTORY_ITEM));

	//fix up the variable pointer since the underlying block
	//may have been moved.
	(*pItem)->pv = (PWU_VARIABLE_FIELD)(((PBYTE)*pItem) + sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED));

	pvTmp = (*pItem)->pv;

	//get a pointer to the last field in the variable field array
	pvTmp = (*pItem)->pv->Find(WU_VARIABLE_END);
	if ( !pvTmp )
	{
		//something is very wrong here the variable item array
		//links are messed up some how. This should never happen
		//in a production environment however we may see this
		//in the course of development and testing.
		throw (HRESULT)MEM_E_INVALID_LINK;
	}

	//copy over last field with new variable size field
	memcpy(pvTmp, pvNew, pvNew->len);

	//add new end type variable size field to end of array since
	//we destroyed the existing one with the copy of the new
	//variable size field.

	pvTmp = (PWU_VARIABLE_FIELD)((PBYTE)pvTmp + pvTmp->len);
	pvTmp->id = WU_VARIABLE_END;
	pvTmp->len = sizeof(WU_VARIABLE_FIELD);

	return;
}

//This function will seem tricky at first. The problem here is that the
//returned variable field array needs to be in a single block of memory.
//The reason that the memory must be contigous is that the variable field
//items that walk from one record to the next use the len parameter to find
//the beginning of the next variable record. This then prevents us from
//being able to simply take the pvNew pointer and add it to the variable
//field array. Instead we calulate the new needed size of the array and
//realloc the current pointer to this new size. We then copy the pvNew
//pointer into the newly sized array.

//The other problem here is that we cannot change the this pointer for the
//variable field array while inside a function handler for a variable field.
//So each structure that needs to manage variable fields needs one of these
//add functions. We could have set this up as a virtual function however this
//would have added a vtable to the structure. Since we are interested in the
//keeping the code size as small as possible this vtable is best avoided.

//This function has to be handled outside of the inventory item structure
//because the inventory item needs to be a continuous block of memory for
//file management. So when we add a variable field to the structure we also
//need to reallocate item structure. If we were to put this function into
//the inventory structure then we would not be able to do this because of
//this pointer semantics.

//Note: In order to use this function a valid pItem must already exist and
//since a pItem exits it must contain at least one variable type field which
//needs to be an end field.

void __cdecl AddVariableSizeField
	(
		PWU_DESCRIPTION *pDescription,	//pointer to description record type variable size field.
		PWU_VARIABLE_FIELD pvNew		//pointer to new variable size field to add.
	)
{
	int					iSize;
	PWU_VARIABLE_FIELD	pvTmp;

	//calculate the size needed by the new variable field array
	iSize = sizeof(WU_DESCRIPTION) + (*pDescription)->pv->GetSize() + pvNew->len;

	//realloc array and fix up variable pointer

	*pDescription = (PWU_DESCRIPTION)V3_realloc(*pDescription, iSize);

	//fix up the variable pointer since the underlying block may have been moved.
	(*pDescription)->pv = (PWU_VARIABLE_FIELD)(((PBYTE)*pDescription) + sizeof(WU_DESCRIPTION));

	pvTmp = (*pDescription)->pv;

	//get a pointer to the last field in the variable field array
	pvTmp = (*pDescription)->pv->Find(WU_VARIABLE_END);
	if ( !pvTmp )
	{
		//something is very wrong here the variable item array
		//links are messed up some how. This should never happen
		//in a production environment however we may see this
		//in the course of development and testing.
		throw (HRESULT)MEM_E_INVALID_LINK;
	}

	//copy over last field with new variable size field
	memcpy(pvTmp, pvNew, pvNew->len);

	//add new end type variable size field to end of array since
	//we destroyed the existing one with the copy of the new
	//variable size field.

	pvTmp = (PWU_VARIABLE_FIELD)((PBYTE)pvTmp + pvTmp->len);
	pvTmp->id = WU_VARIABLE_END;
	pvTmp->len = sizeof(WU_VARIABLE_FIELD);

	return;
}

//Adds a variable size field to a variable field chain.
//The format of a variable size field is:
//[(short)id][(short)len][variable size data]
//The variable field always ends with a WU_VARIABLE_END type.

PWU_VARIABLE_FIELD CreateVariableField
	(
		IN	short	id,			//id of variable field to add to variable chain.
		IN	PBYTE	pData,		//pointer to binary data to add.
		IN	int		iDataLen	//Length of binary data to add.
	)
{
	PWU_VARIABLE_FIELD	pVf;

	pVf = (PWU_VARIABLE_FIELD)V3_malloc(sizeof(WU_VARIABLE_FIELD) + iDataLen);

	if ( iDataLen )
		memcpy(pVf->pData, pData, iDataLen);

	pVf->id  = id;
	pVf->len = (short)(sizeof(WU_VARIABLE_FIELD) + iDataLen);

	return pVf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\ccdm.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   ccdm.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      CDM support from the site
//
//=======================================================================

#include "stdafx.h"
#include <winspool.h>
#include <setupapi.h>
#include <wustl.h>
#define LOGGING_LEVEL 1
#include <log.h>
#include <wuv3sys.h>
#include <drvinfo.h>
#include <ccdm.h>
#include <findoem.h>
#include <shlwapi.h>
#include "printers.h"

static DWORD OpenReinstallKey(HKEY* phkeyReinstall);
static DWORD GetReinstallString(LPCTSTR szHwID, tchar_buffer& bchReinstallString);
static DWORD DeleteReinstallKey(LPCTSTR szHwID);


bool DownloadToBuffer(
	IN LPCTSTR szPath,
	IN CWUDownload	*pDownload,		//pointer to internet server download class.
	IN CDiamond	*pDiamond,		//pointer to diamond de-compression class.
	OUT byte_buffer& bufOut
) {
	byte_buffer bufTmp;
	if (!pDownload->MemCopy(szPath, bufTmp))
		return false;
	if (pDiamond->IsValidCAB(bufTmp))
	{
		if (!pDiamond->Decompress(bufTmp, bufOut))
			return false;
	}
	else
	{
		//else the oem table is in uncompressed format.
		bufOut << bufTmp;
	}
	return true;
}



//Note: This method works specifically with a CCdm class. The CCdm class contains
//the returned inventory item array. So if multiple threads are used then
//multiple instances of the CCdm class will be required. This should not ever be a
//problem since we do not ever plan or have any reason to do single instance groveling
//for device drivers.

//This method adds CDM records to an internal CDM inventory list. The CCatalog
//prune method performs the final copy and insertion of these records into the
//final inventory catalog.

void CCdm::CreateInventoryList(
	IN		CBitmask	*pBm,			//bitmask to be used to prune the inventory list.
	IN		CWUDownload	*pDownload,		//pointer to internet server download class.
	IN		CDiamond	*pDiamond,		//pointer to diamond de-compression class.
	IN		PUID		puidCatalog,	//puid identifier of catalog where device drivers are stored.
	IN		PBYTE		pOemInfoTable	//Pointer OEM info table that OEM detection needs.
) {
	
	LOG_block("CCdm::CreateInventoryList");
	
	USES_CONVERSION;
	// Start
	m_iCDMTotalItems = 0;
	
	//check input arguments
	if (NULL == pBm || NULL == pDownload || NULL == pDiamond)
	{
		return;
	}

	//First prune list based on bitmask
	//This is accomplished by anding the appropriate bitmasks to form a global bitmask.


	DWORD langid = GetMachineLangDW();
	PBYTE pBitmaskBits =  pBm->GetClientBits(GetMachinePnPID(pOemInfoTable), langid);
	if (NULL == pBitmaskBits)
	{
		return;
	}
	{
		//Note: a cdm catalog cannot have a 0 puid since that the inventory.plt will
		//never have a device driver insertion record. So this function will not be
		//called for the inventory.plt catalog.

		TCHAR szPath[MAX_PATH];
		wsprintf(szPath, _T("%d/inventory.cdm"), puidCatalog);

		if (!DownloadToBuffer(szPath, pDownload, pDiamond, m_bufInventory))
			throw HRESULT_FROM_WIN32(GetLastError());
	}

	vector<SCdmItem> aitemUpdates;
	/* Regular drivers */ {
		CDrvInfoEnum DrvInfoEnum;
		auto_pointer<IDrvInfo> pDrvInfo;
		while (DrvInfoEnum.GetNextDrvInfo(&pDrvInfo))
		{
			tchar_buffer bufDeviceInstanceID;
			if (!pDrvInfo->GetDeviceInstanceID(bufDeviceInstanceID))
			{
				LOG_error("!pDrvInfo->GetDeviceInstanceID()");
				continue;
			}
			LOG_block(T2A(bufDeviceInstanceID));
			if (pDrvInfo->IsPrinter())
			{
				LOG_error("!pDrvInfo->IsPrinter()");
				continue;
			}
			tchar_buffer bufHardwareIDs;
			if (!pDrvInfo->GetAllHardwareIDs(bufHardwareIDs))
			{
				LOG_error("!pDrvInfo->GetAllHardwareIDs()");
				continue;
			}
			tchar_buffer bufMatchingDeviceId;
			pDrvInfo->GetMatchingDeviceId(bufMatchingDeviceId); // It's OK not to get it
//			#ifdef _WUV3TEST
				if (pDrvInfo.valid() && pDrvInfo->HasDriver())
				{
					if (bufMatchingDeviceId.valid())
						LOG_out("driver installed on MatchingDeviceId %s", (LPCTSTR)bufMatchingDeviceId);
					else
						LOG_error("driver installed, but HWID is not available");
				}
				else
				{
					if (bufMatchingDeviceId.valid())
						LOG_error("driver is not installed, but MatchingDeviceId is %s", (LPCTSTR)bufMatchingDeviceId);
					else
						LOG_out("no driver installed");
				}
//			#endif


			// Updates
			bool fMoreSpecific = true;
			for (LPCTSTR szHardwareId = bufHardwareIDs; fMoreSpecific && *szHardwareId; szHardwareId += lstrlen(szHardwareId) + 1)
			{
				// MatchingDeviceID is the last one to pay attention to
				fMoreSpecific = !bufMatchingDeviceId.valid() || 0 != lstrcmpi(szHardwareId, bufMatchingDeviceId); 
				
				ULONG ulHashIndex = IsInMap(szHardwareId);
				if (-1 == ulHashIndex)
					continue;

				//else download the server bucket file
				byte_buffer& bufBucket = ReadBucketFile(pDownload, pDiamond, puidCatalog, ulHashIndex);

				FILETIME ftDriverInstalled = {0,0};
				if (!fMoreSpecific)
				{
					// Then it has to have a driver - Matching device ID is set
					if (!pDrvInfo->GetDriverDate(ftDriverInstalled)) 
					{
						LOG_error("!pDrvInfo->GetDriverDate(ftDriverInstalled)");
						break;
					}
				}		
				DRIVER_MATCH_INFO DriverMatchInfo;
				PUID puid = CDM_FindUpdateInBucket(szHardwareId, fMoreSpecific ? NULL : &ftDriverInstalled, bufBucket, bufBucket.size(), pBitmaskBits, &DriverMatchInfo);
					// See if it's being added already
				if (0 == puid)
				{
					LOG_out("CDM_FindUpdateInBucket returns 0");
					continue;
				}
				
				// something has been found
				AddItem(aitemUpdates, puid, bufMatchingDeviceId.valid() ? CDM_UPDATED_DRIVER : CDM_NEW_DRIVER, A2T(DriverMatchInfo.pszHardwareID), A2T(DriverMatchInfo.pszDriverVer));
				break;
			}

			// Installed
			if (bufMatchingDeviceId.valid())
			{
				LPCTSTR szHardwareId = bufMatchingDeviceId;
				tchar_buffer bchReinstallString;
				if (NO_ERROR != GetReinstallString(szHardwareId, bchReinstallString))
				{
					LOG_out("No reinstall string for %s", szHardwareId);
					continue;
				}

				ULONG ulHashIndex = IsInMap(szHardwareId);
				if (-1 == ulHashIndex)
					continue;

				//else download the server bucket file
				byte_buffer& bufBucket = ReadBucketFile(pDownload, pDiamond, puidCatalog, ulHashIndex);
				DRIVER_MATCH_INFO DriverMatchInfo;
				PUID puid = CDM_FindInstalledInBucket(pDrvInfo, szHardwareId, bufBucket, 
					bufBucket.size(), pBitmaskBits, &DriverMatchInfo);
					// See if it's being added already
				if (0 == puid)
				{
					LOG_out("CDM_FindInstalledInBucket returns 0");
					continue;
				}
				// something has been found
				AddItem(aitemUpdates, puid, CDM_CURRENT_DRIVER, A2T(DriverMatchInfo.pszHardwareID), A2T(DriverMatchInfo.pszDriverVer));
			}
		} // while (DrvInfoEnum.GetNextDrvInfo(&pDrvInfo))
	}
	/* Printer drivers */ {
		CPrinterDriverInfoArray ainfo;
		for(DWORD dwDriverIdx = 0; dwDriverIdx < ainfo.GetNumDrivers(); dwDriverIdx ++)
		{
			LPDRIVER_INFO_6 pinfo = ainfo.GetDriverInfo(dwDriverIdx);
			if (NULL == pinfo)
				continue;

			tchar_buffer bufHardwareID;
			if (!ainfo.GetHardwareID(pinfo, bufHardwareID))
				continue;

			ULONG ulHashIndex = IsInMap(bufHardwareID);
			if (-1 == ulHashIndex)
				continue;

			//else download the server bucket file
			byte_buffer& bufBucket = ReadBucketFile(pDownload, pDiamond, puidCatalog, ulHashIndex);
			DRIVER_MATCH_INFO DriverMatchInfo;
			PUID puid = CDM_FindUpdateInBucket(bufHardwareID, &(pinfo->ftDriverDate), bufBucket, 
				bufBucket.size(), pBitmaskBits, &DriverMatchInfo);
			if (0 == puid)
			{
				LOG_out("CDM_FindInstalledInBucket returns 0");
				continue;
			}
			AddItem(aitemUpdates, puid, CDM_UPDATED_DRIVER, A2T(DriverMatchInfo.pszHardwareID), A2T(DriverMatchInfo.pszDriverVer), pinfo->pName, ainfo.GetArchitecture(pinfo));
		}
	}
	//Do converson
	AddInventoryRecords(aitemUpdates);
}


// Check if given PNPID is current hash table mapping.
//if PnpID is in hash table then return index

ULONG CCdm::IsInMap(
	IN LPCTSTR pHwID		//hardware id to be retrieved
) {
	LOG_block("CCdm::IsInMap");
	
	// check if the member variable m_bufInventory is not NULL and the input argument is not NULL
	if (NULL == (PCDM_HASHTABLE)(LPBYTE)m_bufInventory || NULL == pHwID)
	{
		return -1;
	}

	PCDM_HASHTABLE pHashTable = (PCDM_HASHTABLE)(LPBYTE)m_bufInventory;
	ULONG ulTableEntry = CDM_HwID2Hash(pHwID, pHashTable->hdr.iTableSize);

	if(GETBIT(pHashTable->pData, ulTableEntry))
	{
		LOG_out("%s (hash %d) is found", pHwID, ulTableEntry);
		return ulTableEntry;
	}

	LOG_out("%s (hash %d) is not found", pHwID, ulTableEntry);
	return -1;
}

//Reads and initializes a compressed CDM bucket file from an internet server.
//Returnes the array index where the bucket file is stored.

byte_buffer& CCdm::ReadBucketFile(
	IN	CWUDownload	*pDownload,		//pointer to internet server download class.
	IN	CDiamond	*pDiamond,		//pointer to diamond de-compression class.
	IN	PUID		puidCatalog,	//PUID id of catalog for which cdm hash table is to be retrieved.
	IN	ULONG		ulHashIndex		//Hash table index of bucket file to be retrieved
) {
	LOG_block("CCdm::ReadBucketFile");
	// If it there return it
	for(int i = 0; i < m_aBuckets.size(); i ++)
	{
		if (ulHashIndex == m_aBuckets[i].first)
			return m_aBuckets[i].second;
	}

	// download it
	byte_buffer bufBucket;
	{
		TCHAR szPath[MAX_PATH];
		wsprintf(szPath, _T("%d/%d.bkf"), puidCatalog, ulHashIndex);
		if (!DownloadToBuffer(szPath, pDownload, pDiamond, bufBucket))
			throw HRESULT_FROM_WIN32(GetLastError());
	}
	m_aBuckets.push_back(my_pair(ulHashIndex, bufBucket));
	return m_aBuckets[m_aBuckets.size() - 1].second;
}

PINVENTORY_ITEM CCdm::ConvertCDMItem(
	int index		//Index of cdm record to be converted
) {
	if ( index < 0 || index >= m_iCDMTotalItems )
		return NULL;

	// this is a no-op, we just hand off the existing pointer
	return m_items[index];
}

// add detected item to a list
void CCdm::AddItem(
	vector<SCdmItem>& acdmItem, 
	PUID puid, 
	enumDriverDisposition fDisposition,
	LPCTSTR szHardwareId, 
	LPCTSTR szDriverVer, 
	LPCTSTR szPrinterDriverName /*= NULL*/,
	LPCTSTR szArchitecture /*= NULL*/
) {
	LOG_block("CCdm::AddItem");
	LOG_out("%s PUID = %d, HardwareId = %s", szPrinterDriverName ? _T("Prt") : _T("Dev"), puid, szHardwareId);

	// First check if this puid is included
	bool fNew = true;
	for (int nItem = 0; nItem < acdmItem.size(); nItem ++)
	{
		if ((acdmItem[nItem].puid == puid) && (acdmItem[nItem].fInstallState == fDisposition))
		{
			fNew = false;
			break;
		}
	}

	if (fNew)
	{	// new item;
		LOG_out("Adding as a new item");
		acdmItem.push_back(SCdmItem());
		SCdmItem& item = acdmItem.back();
		item.puid = puid;
		item.fInstallState = fDisposition;

		item.sDriverVer = szDriverVer;
		if (szArchitecture)
			item.sArchitecture = szArchitecture;
		if (szPrinterDriverName)
			item.sPrinterDriverName = szPrinterDriverName;
		item.bufHardwareIDs.resize(lstrlen(szHardwareId) + 2);
		if(!item.bufHardwareIDs.valid())
			return; //out of memory
		lstrcpy(item.bufHardwareIDs, szHardwareId);
		((LPTSTR)item.bufHardwareIDs)[item.bufHardwareIDs.size() - 2] = 0;
		((LPTSTR)item.bufHardwareIDs)[item.bufHardwareIDs.size() - 1] = 0;
	}
	else
	{
		SCdmItem& item = acdmItem[nItem];
		// check if Hardware ID is already included
		for (LPCTSTR szCurHardwareId = acdmItem[nItem].bufHardwareIDs; *szCurHardwareId; szCurHardwareId += lstrlen(szCurHardwareId) + 1)
		{
			if (0 == lstrcmpi(szCurHardwareId, szHardwareId))
			{
				// Got It
				LOG_out("Already present");
				return;
			}
		}
		LOG_out("Appending hardware ID");
		int cnOldSize = item.bufHardwareIDs.size();
		item.bufHardwareIDs.resize(cnOldSize + lstrlen(szHardwareId) + 1);
		if(!item.bufHardwareIDs.valid())
			return; //out of memory
		lstrcpy((LPTSTR)item.bufHardwareIDs + cnOldSize - 1, szHardwareId);
		((LPTSTR)item.bufHardwareIDs)[item.bufHardwareIDs.size() - 2] = 0;
		((LPTSTR)item.bufHardwareIDs)[item.bufHardwareIDs.size() - 1] = 0;
	}

}


//This function is used to create a CDM inventory record. This record is initialized with
//the CDM bucket information.

void CCdm::AddInventoryRecords(
	vector<SCdmItem>& acdmItem
) {
	LOG_block("CCdm::AddInventoryRecords");
	for (int nItem = 0; nItem < acdmItem.size(); nItem ++)
	{
		PINVENTORY_ITEM pItem = 0;
		try
		{
			//allocate and initialize a new catalog item
			//note that this memory is never freed by this class
			//We rely on the fact that this pointer is going to be
			//handed off (in ConvertCDMItem()) and someone else will free it.

			pItem = (PINVENTORY_ITEM)V3_malloc(sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED) + sizeof(WU_VARIABLE_FIELD));

			//we need to set these up by the inventory catalog copy and insert routine.
			pItem->pd	= NULL;

			//first setup the fixed part of the inventory item
			pItem->pf = (PWU_INV_FIXED)(((PBYTE)pItem) + sizeof(INVENTORY_ITEM));

			//We need to fix the record type here as it has to be correct before it is
			//inserted into the inventory list.

			if (acdmItem[nItem].sPrinterDriverName.length())
			{	//printer
				pItem->pf->d.type = SECTION_RECORD_TYPE_PRINTER;
				pItem->recordType = WU_TYPE_RECORD_TYPE_PRINTER;
			}
			else
			{	// pnp device
				pItem->pf->d.type = SECTION_RECORD_TYPE_DRIVER_RECORD;
				pItem->recordType = WU_TYPE_CDM_RECORD;	//Corporate catalog device driver
			}
			pItem->pf->d.puid = acdmItem[nItem].puid;
			pItem->pf->d.flags	= 0;
			pItem->pf->d.link	= 0;

			//set up the state of the item.  This used to take place in ConvertCDMItem()
			//initialize and store the internal item state structure
			pItem->ps = (PWU_INV_STATE)V3_malloc(sizeof(WU_INV_STATE));

			//translate the internal CDM item states to the public WUV3IS item
			//states.  
			switch (acdmItem[nItem].fInstallState)
			{
			case CDM_NEW_DRIVER:
				pItem->ps->state = WU_ITEM_STATE_INSTALL;
				break;
			case CDM_UPDATED_DRIVER:
				pItem->ps->state = WU_ITEM_STATE_UPDATE;
				break;
			case CDM_CURRENT_DRIVER:
				pItem->ps->state = WU_ITEM_STATE_CURRENT;
				break;
			default:
				pItem->ps->state = WU_ITEM_STATE_UNKNOWN;
			};
			
			pItem->ps->bChecked	= FALSE;
			pItem->ps->bHidden	= FALSE;
			pItem->ps->dwReason	= WU_STATE_REASON_NONE;

			//setup the variable part of the item. In the main catalog inventory case this
			//is all that we need to do. In the case of the corporate catalog we will need
			//to add one more variable field. This field is the CDM bucket hashIndex id.
			//This allows the corporate catalog to perform defered detection on device
			//driver records.

			//We need to add the ending variable size record since the list needs to
			//be initialized before AddVariableSizeField() will work.

			pItem->pv = (PWU_VARIABLE_FIELD)((PBYTE)pItem + sizeof(INVENTORY_ITEM) + sizeof(WU_INV_FIXED));

			pItem->pv->id = WU_VARIABLE_END;
			pItem->pv->len = sizeof(WU_VARIABLE_FIELD);

			//Add in the needed variable field items. (Note: Only variable detection
			//items are placed in the catalog inventory list to mimimize download size).

			PWU_VARIABLE_FIELD pVf = CreateVariableField(WU_CDM_HARDWARE_ID, (PBYTE)(LPTSTR)acdmItem[nItem].bufHardwareIDs, 
				acdmItem[nItem].bufHardwareIDs.size() * sizeof(TCHAR));
			AddVariableSizeField(&pItem, pVf);
			V3_free(pVf);
			
			pVf = CreateVariableField(WU_VARIABLE_DRIVERVER, (PBYTE)(LPTSTR)acdmItem[nItem].sDriverVer.c_str(), 
				(acdmItem[nItem].sDriverVer.length() + 1) * sizeof(TCHAR));
			AddVariableSizeField(&pItem, pVf);
			V3_free(pVf);

			if (CDM_CURRENT_DRIVER == acdmItem[nItem].fInstallState)
			{
				pVf = CreateVariableField(WU_KEY_UNINSTALLKEY, (PBYTE)"Yes", 4); // Just to say that uninstall key is present
				AddVariableSizeField(&pItem, pVf);
				V3_free(pVf);
			}
			if ( acdmItem[nItem].sPrinterDriverName.length() )
			{
				pVf = CreateVariableField(WU_CDM_DRIVER_NAME, (PBYTE)(LPTSTR)acdmItem[nItem].sPrinterDriverName.c_str(), 
					(acdmItem[nItem].sPrinterDriverName.length() + 1) * sizeof(TCHAR));
				AddVariableSizeField(&pItem, pVf);
				V3_free(pVf);
			}
			if ( acdmItem[nItem].sArchitecture.length() )
			{
				pVf = CreateVariableField(WU_CDM_PRINTER_DRIVER_ARCH, (PBYTE)(LPTSTR)acdmItem[nItem].sArchitecture.c_str(), 
					(acdmItem[nItem].sArchitecture.length() + 1) * sizeof(TCHAR));
				AddVariableSizeField(&pItem, pVf);
				V3_free(pVf);
			}
		}
		catch(HRESULT hr)
		{
			if ( pItem )
			{
				V3_free(pItem);
				pItem = 0;
			}
		}
		if (pItem)
			m_items[m_iCDMTotalItems++] = pItem;
	}
}

//This function installs a driver on Windows NT.
//The active function that is called on NT to install a device driver resides in newdev.dll
//Its prototype is:
//BOOL
//InstallWindowsUpdateDriver(
//   HWND hwndParent,
//   LPCWSTR HardwareId,
//   LPCWSTR InfPathName,
//   LPCWSTR DisplayName,
//   BOOL Force,
//   BOOL Backup,
//   PDWORD pReboot
//   )
//This API takes a HardwareID.  Newdev will cycle through all devices that match this hardware ID
//and install the specified driver on them all.
//It also takes a BOOL value Backup which specifies whether or not to backup the current drivers.
// Note that newdev will only backup the drivers once if we find multiple matches for the HardwareID.
static DWORD InstallNT(
	EDriverStatus eds,
	LPCTSTR szHwIDs,		
	LPCTSTR szInfPathName,
	LPCTSTR szDisplayName,
	PDWORD pReboot		
						
) {
	LOG_block("InstallNT");

	USES_CONVERSION;

	typedef BOOL (*PFN_InstallWindowsUpdateDriver)(HWND hwndParent, LPCWSTR HardwareId, LPCWSTR InfPathName, LPCWSTR DisplayName, BOOL Force, BOOL Backup, PDWORD pReboot);

	// Load newdev.dll and get pointer to our function
	auto_hlib hlib = LoadLibrary(_T("newdev.dll"));
	return_error_if_false(hlib.valid());

	PFN_InstallWindowsUpdateDriver pfnInstallWindowsUpdateDriver = (PFN_InstallWindowsUpdateDriver)GetProcAddress(hlib,"InstallWindowsUpdateDriver");
	return_error_if_false(pfnInstallWindowsUpdateDriver);
	
	// make sure the hardware ID's are aligned
	LPCTSTR szTempHwIDs;
	TSTR_ALIGNED_STACK_COPY(&szTempHwIDs, szHwIDs);
	szHwIDs = szTempHwIDs;

	// walk through Hardware IDs
	DWORD dwRebootFinal = 0;
	for (LPCTSTR szHwID = szHwIDs; *szHwID; szHwID += lstrlen(szHwID) + 1)
	{
		tchar_buffer bchInfPathName;
		if (edsBackup == eds)
		{	// Old INF name is in the registry
			return_if_error(GetReinstallString(szHwID, bchInfPathName));
			TCHAR* ptr = _tcsrchr((LPCTSTR)bchInfPathName, _T('\\'));
			if (ptr) 
				*ptr = 0;	// cut file title

		}
		else
		{
			bchInfPathName.resize(lstrlen(szInfPathName) + 1);
			return_error_if_false(bchInfPathName.valid());
			lstrcpy(bchInfPathName, szInfPathName);
		}

		BOOL fForce = edsNew != eds;
		BOOL fBackup = edsNew == eds;
		LOG_out("InstallWindowsUpdateDriver(%s, %s, %s, fForce=%d, fBackup=%d)", 
			szHwID, (LPCTSTR)bchInfPathName, szDisplayName, fForce, fBackup);
		DWORD dwReboot = 0;
		BOOL bRc = (pfnInstallWindowsUpdateDriver)(GetActiveWindow(), 
			T2W((LPTSTR)szHwID), T2W(bchInfPathName), T2W((LPTSTR)szDisplayName), fForce, fBackup, &dwReboot);
		DWORD dwError = GetLastError();
		LOG_out("InstallWindowsUpdateDriver() returns %d, LastError = %d, need reboot = %d", bRc, dwError, dwReboot);
		if ( !bRc )
		{
			if (NO_ERROR == dwError)
				dwError = SPAPI_E_DI_DONT_INSTALL;
			return dwError;

		}
		// cleanup
		if ( edsBackup == eds )
		{
			DeleteReinstallKey(szHwID);
			
			// Delete directory
			DeleteNode(bchInfPathName);

			// Remove empty directory tree
			do
			{
				//remove *.*
				TCHAR* psz = _tcsrchr((LPTSTR)bchInfPathName, _T('\\'));
				if (NULL == psz)
					break;
				*psz = 0;
			} while (RemoveDirectory(bchInfPathName));
		}
		if (dwReboot)
			dwRebootFinal = 1;
	}
	*pReboot =  dwRebootFinal;
	return NO_ERROR;
}

void CdmInstallDriver(BOOL bWindowsNT, EDriverStatus eds, LPCTSTR szHwIDs, LPCTSTR szInfPathName, LPCTSTR szDisplayName, PDWORD pReboot)
{
	DWORD dwError = InstallNT(eds, szHwIDs, szInfPathName, szDisplayName, pReboot);
	if (NO_ERROR != dwError )
	{
		throw HRESULT_FROM_WIN32(dwError);
	}

}


//
//We need to create a unique backup directory for this device, so we will
//  use the unique Hardware ID to come up with this unique directory.
//Basically I will replace all of the illegal file/registry characters
//  \/:*?"<>| with # (for 98) , for NT will only do this with \
//
static void HwID2Key(LPCTSTR szHwID, tchar_buffer& bufKey)
{
	static TCHAR szIllegal[] = _T("\\/:*?\"<>|");
	if (IsWindowsNT())
		szIllegal[1] = 0;

	bufKey.resize(ua_lstrlen(szHwID) + 1);
	if (!bufKey.valid())
		return; // out of memory

	// use the macro to copy unligned strings
	ua_tcscpy(bufKey, szHwID);
	for (TCHAR* pch = bufKey; *pch; pch ++)
    {
		if (_tcschr(szIllegal, *pch) != NULL)
			*pch = _T('#');
    }
}

static DWORD RegQueryValueBuf(HKEY hKey, LPCTSTR szValue, tchar_buffer& buf)
{
	DWORD dwSize = 0;
	DWORD dwError = RegQueryValueEx(hKey, szValue, NULL, NULL, NULL, &dwSize);
	if (NO_ERROR != dwError)
		return dwError;

	buf.resize(dwSize/sizeof(TCHAR));
	if (!buf.valid())
		return ERROR_OUTOFMEMORY;
	return RegQueryValueEx(hKey, szValue, NULL, NULL, (LPBYTE)(LPTSTR)buf, &dwSize);
}


static DWORD OpenReinstallKey(HKEY* phkeyReinstall)
{
	return RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall"),
		0, KEY_ALL_ACCESS, phkeyReinstall);
}

static DWORD GetReinstallString(LPCTSTR szHwID, tchar_buffer& bchReinstallString)
{
	auto_hkey hkeyReinstall;
    DWORD dwError = OpenReinstallKey(&hkeyReinstall);
	if (NO_ERROR != dwError)
		return dwError;

	tchar_buffer bufKey;
	HwID2Key(szHwID, bufKey);
	
	auto_hkey hkeyHwID;
	dwError = RegOpenKeyEx(hkeyReinstall, bufKey, 0, KEY_READ, &hkeyHwID);
	if (NO_ERROR != dwError)
		return dwError;

	return RegQueryValueBuf(hkeyHwID, _T("ReinstallString"), bchReinstallString);
}

static DWORD DeleteReinstallKey(LPCTSTR szHwID)
{
	LOG_block("DeleteReinstallKey");

	auto_hkey hkeyReinstall;
	return_if_error(OpenReinstallKey(&hkeyReinstall));

	tchar_buffer bufKey;
	HwID2Key(szHwID, bufKey);
	return_if_error(RegDeleteKey(hkeyReinstall, bufKey));

	return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\cv3.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    cv3.cpp
//
//  Purpose: V3 control main code
//
//======================================================================= 

#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>
#include <initguid.h>
#include <inseng.h>
#include <shlwapi.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include <winspool.h>
#include <cstate.h>
#include <wustl.h>
#include <osdet.h>
#include "printers.h"
#include "progress.h"
#include "newtrust.h"
#include "history.h"
#include "CV3.h"
#include "detect.h"
#include "callback.h"
#include "locstr.h"
#include "safearr.h"
#include "install.h"
#include "log.h"
#include "template.h"
#include "filecrc.h"
#include <shlguid.h>
#include <wininet.h>
#include <servpaus.h>
#include "..\..\inc\wuverp.h"



const TCHAR REGPATH_EXPLORER[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR REGKEY_WINUPD_DISABLED[] = _T("NoWindowsUpdate");

#define  EXENAME_128BIT    _T("128BIT.EXE")


//
// State management class. All retrieved catalogs are stored here. When the
// control exits then this class cleans up the memory used by each catalog
// stored with the state module. So the application must not delete any catalogs
// that have been added to state storage.
//
CState	g_v3state;
TCHAR    CCV3::s_szControlVer[20] = _T("\0");


void DownloadDLL(CDiamond *pDiamond, CWUDownload *pDownload, LPCTSTR pszDLLName, LPCTSTR pszPath);
void DownloadFileVerInfo(CWUDownload* pDownload);
PBYTE DownloadOemInfo(CWUDownload *pDownload, CDiamond *pDiamond);;
void DownloadCabs(LPCTSTR szLocalDir, CWUDownload* pDownload, CDiamond* pDiamond, PBYTE pCabList, PBYTE pCRCList, IWUProgress* pProgress, BOOL bUnCab);
void DownloadCif(LPCTSTR szLocalDir, CDiamond* pDiamond, PINSTALLINFOSTRUCT pInstallInfo);
void Download128Bit(LPCTSTR pszLocalDir, PINVENTORY_ITEM pItem, IWUProgress* pProgress);


void DetectPlatAndLang();
void DetectActiveSetupWU(CWUDownload* pDownload, CDiamond* pDiamond, CCatalog* pCatalog);
void DownloadItem(LPCTSTR pszLocalDir, CWUDownload *pDownload, CDiamond *pDiamond, PINSTALLINFOSTRUCT pInstallInfo, IWUProgress* pProgress);
void InstallItem(LPCTSTR pszLocalDir, PSELECTITEMINFO pStatusInfo, PINSTALLINFOSTRUCT pInstallInfo, IWUProgress* pProgress);
DWORD WINAPI RebootThreadProc(LPVOID pv);
void CheckDescDiagInfo(CCatalog* pCatalog);

bool IsArabicOrHebrew()
{
	WORD wCurPrimeLang = PRIMARYLANGID(LOWORD(g_v3state.GetBrowserLocale()));
	return LANG_HEBREW == wCurPrimeLang || LANG_ARABIC == wCurPrimeLang;
}


//
// CDescriptionMerger class
//
// a local class used to merge description files
//
class CDescriptionMerger
{
public:
	CDescriptionMerger() 
		: m_pMap(NULL),
		  m_pDiamond(NULL)
	{
	}

	~CDescriptionMerger()
	{
		if (m_pMap != NULL)
			delete m_pMap;
		if (m_pDiamond != NULL)
			delete m_pDiamond;
	}

	HRESULT CheckMerge(PINSTALLINFOSTRUCT pInstallInfo);

private:
	CCRCMapFile* m_pMap;
	CDiamond* m_pDiamond;

	HRESULT ReadMapFile(CCatalog* pCatalog);
};


//
// CCV3 class
//

// this function is called when our ref count becomes zero
void CCV3::FinalRelease() 
{
	LOG_block("CCV3::FinalRelease"); 

	//
	// reset state
	//
	g_v3state.Reset();

	//
	// make sure we undo registration of MS trust key if we registred it
	//
	CConnSpeed::WriteToRegistry();
}


// this function is called after our object is created, this is the prefered 
// place to do initialization 
HRESULT CCV3::FinalConstruct()
{
	LOG_block("CCV3::FinalConstruct"); 
    wsprintf(CCV3::s_szControlVer, _T("5,04,%d,%d"), VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE);

	TCHAR szLogFN[MAX_PATH];
    TCHAR szDate[50];
    TCHAR szTime[50];
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, NULL, NULL, szDate, sizeof(szDate)/sizeof(szDate[0]));
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, NULL, NULL, szTime, sizeof(szTime)/sizeof(szTime[0]));
    
	LOG_out("Windows Update V3 Internet Site Control, Version %s",s_szControlVer);
	LOG_out("Session starting %s at %s", szDate, szTime);

	//
	// set up the application log
	//
	GetWindowsUpdateDirectory(szLogFN);
	lstrcat(szLogFN, HISTORY_FILENAME);
	g_v3state.AppLog().SetLogFile(szLogFN);

	CConnSpeed::ReadFromRegistry();

	m_bValidInstance = FALSE;

	//
	// seed the random number generator 
	//
	srand((int)GetTickCount());


	return S_OK;
}


// The get catalog method retrieves a catalog array from the server. The get catalog method only
// accesses the server if the catalog is not already resident on the clients computer system.
// This allows the VB script page call this method to quickly obtain filtered catalog record information.
STDMETHODIMP CCV3::GetCatalog(
	IN long puidCatalog,
	IN BSTR bstrServerUrl,
	IN long platformId,
	IN BSTR bstrBrowserLanguage, // BUGBUG - why is browser locale a string and not a long
	IN long lFilters,
	IN long lFlags,
	OUT RETVAL VARIANT *pCatalogArray
	)
{
	HRESULT	hr;
	CCatalog* pCatalog;
	
	LOG_block("CCV3::GetCatalog"); 
	try
	{
		pCatalog = ProcessCatalog(puidCatalog, bstrServerUrl, platformId, bstrBrowserLanguage, lFilters, lFlags);

		//If we are retrieving the sub-catalog list then the return VB script array
		//needs to be different.
		if (pCatalog->GetCatalogPuid() == WU_CATALOG_LIST_PUID)
		{
			hr = MakeReturnCatalogListArray(pCatalog, lFilters, lFlags, pCatalogArray);
			if (FAILED(hr))
				throw hr;
		}
		else
		{
			hr = MakeReturnCatalogArray(pCatalog, lFilters, lFlags, pCatalogArray);

			if (FAILED(hr))
				throw hr;
		}
	}
	catch(HRESULT hr)
	{
		// create an empty array so that script doesn't throw a UBound error
		LPSAFEARRAY			psa;
		SAFEARRAYBOUND		rgsabound[2];

		
		VariantInit(pCatalogArray);

		rgsabound[0].lLbound	= 0;
		rgsabound[0].cElements	= 0;

		rgsabound[1].lLbound	= 0;
		rgsabound[1].cElements	= 8;


		psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);

		V_VT(pCatalogArray) = VT_ARRAY | VT_VARIANT;
		V_ARRAY(pCatalogArray) = psa;

		// we can't return a failure code, because that prevents script from
		// honoring the return value.
		 return S_FALSE;

	}

	return S_OK;
}



STDMETHODIMP CCV3::GetCatalogHTML(
	IN long puidCatalog,
	IN BSTR bstrServerUrl,
	IN long platformId,
	IN BSTR bstrBrowserLanguage,
	IN long lFilters,
	IN long lFlags,
	OUT RETVAL VARIANT *pCatalogHTML
	)
{
	HRESULT	hr;
	CCatalog* pCatalog;
	
// we are currently not using the templates feature
// the code for this templates are wrapped in HTML_TEMPLATE define

#ifdef HTML_TEMPLATE


	TRACE("GetCatalogHTML: %d", puidCatalog); 
	try
	{
		pCatalog = ProcessCatalog(puidCatalog, bstrServerUrl, platformId, bstrBrowserLanguage, lFilters, lFlags);

		hr = MakeCatalogHTML(pCatalog, lFilters, pCatalogHTML);
		if (FAILED(hr))
			throw hr;
	}
	catch(HRESULT hr)
	{
		return hr;
	}

	return S_OK;

#endif

	return E_NOTIMPL;
}


/*
 * The process catalog function constructs or retireves the requested
 * V3 catalog. A pointer to the retrieved or constructed catalog is
 * returned to the caller if successfull or an HRESULT error code is
 * thrown if not.
 */
CCatalog *CCV3::ProcessCatalog(
	IN PUID puidCatalog,
	IN BSTR bstrServerUrl,
	IN long platformId,
	IN BSTR bstrBrowserLanguage,
	IN long lFilters,
	IN long lFlags
	)
{
	USES_CONVERSION;

	CCdm		cdm;
	BOOL		bCheckInNeeded;
	CDiamond	dm;
	CBitmask	bmAS;
	CBitmask	bmCDM;
	CCatalog*	pCatalog;
	TCHAR		szIdentServer[MAX_PATH];
	char      szBuffer[1024];
	PINVENTORY_ITEM pCatalogItem;
	int i;
	HRESULT hr;

	LOG_block("CCV3::ProcessCatalog");
	LOG_out("puidCatalog = %d, bstrServerUrl = %s", puidCatalog, OLE2T(bstrServerUrl));
	LOG_out("tick count is %d", GetTickCount());
	// assume that the catalog is in state storage.
	bCheckInNeeded = FALSE;

	// 
	// if catalog is not already in state storage go retrieve and prune it.
	//
	if ( !(pCatalog = g_v3state.Get(puidCatalog)) )
	{
        if (NULL == bstrBrowserLanguage) // AutoUpdate
        {
            // We'll use this flag to determine whether to show UI when we call VerifyFile
            g_v3state.m_nClient = WUV3_CLIENT_AUTOUPDATE;
            LOG_out("Client Set to AutoUpdate");
            LOG_out("Client is currently %s", (CWUDownload::s_fOffline) ? "Offline" : "Online");
        }

		//
		// check if the ident server is trusted as well as read the valid server
		// list from ident.cab into memory
		//
		lstrcpy(szIdentServer, OLE2T(bstrServerUrl));
		RemoveLastSlash(szIdentServer);
		g_v3state.CheckTrustedServer(szIdentServer, &dm);

		//
		// check the server the control was launch from.  At this point the
		// ident cab is already loaded
		// this function will do the work only once and it will throw if
		// the server is not valid
		//
		CheckLaunchServer();
	
		//
		// create a new catalog object
		// 
		pCatalog = new CCatalog(g_v3state.GetContentServer(), puidCatalog);

		if (NULL == pCatalog)
		{
			LOG_out("ProcessCatalog: Creation of new Catalog failed. GetLastError() = %d", GetLastError());			
			throw HRESULT_FROM_WIN32(GetLastError());
		}

		if (NULL != bstrBrowserLanguage) // AutoUpdate whould set it to NULL
		{
			pCatalog->SetBrowserLocale(OLE2T(bstrBrowserLanguage));
		}
		
		//
		// Create a download object for the content
		//
		CWUDownload	dl(pCatalog->GetCatalogServer(), 8192);

		//
		// read the catalog
		//
		pCatalog->Read(&dl, &dm);

		//
		// read the bitmask file
		//
		bmAS.Read(&dl, &dm, puidCatalog, BITMASK_ACTIVESETUP_TYPE, pCatalog->GetBitmaskName());

		if (!g_v3state.m_pdwPlatformList)
		{
			TCHAR szOsdetServer[MAX_PATH];
			lstrcpy(szOsdetServer, _T("OSDET."));
			AppendExtForOS(szOsdetServer);

			DownloadFileVerInfo(&dl);
			DownloadDLL(&dm, &dl, szOsdetServer, NULL);
			DetectPlatAndLang();
			LOG_out("Platform %d", g_v3state.m_pdwPlatformList[0]);
			LOG_out("Machine Language 0x%8.8x", GetMachineLangDW());
            LOG_out("User UI Language 0x%8.8x", GetUserLangDW());
		}

		if (NULL == bstrBrowserLanguage) // AutoUpdate
		{
            // For Windows XP, AU can't use the system language - we need to use the MUI user language
			//pCatalog->SetBrowserLocale(pCatalog->GetMachineLocaleSZ());
            pCatalog->SetBrowserLocale(pCatalog->GetUserLocaleSZ());
            
		}

		if (puidCatalog == WU_CATALOG_LIST_PUID)
		{
			// inventory.plt is platform 0 by convention
			pCatalog->SetPlatform(g_v3state.m_pdwPlatformList[0]);
		}
		else
		{
			// normal inventory item sub catalog.
			if (!platformId)
			{
				// if the caller did not pass in a platformId then we
				// need to detect the current platform and use that value
				// in the catalog. In this case we luck out since the first
				// platform id returned from osdet.dll is the client machines platform.
				pCatalog->SetPlatform(g_v3state.m_pdwPlatformList[0]);
			}
			else
			{
				pCatalog->SetPlatform(platformId);
			}
		}

		// inventory.plt catalog only does bitmask pruning
		if ( puidCatalog == WU_CATALOG_LIST_PUID )
		{
			// if puidCatalog is 0 then we are retrieving the inventory.plt list of
			// catalogs. We need to handle this catalog differently.
			pCatalog->BitmaskPruning(&bmAS, g_v3state.m_pdwPlatformList, g_v3state.m_iTotalPlatforms);
		}
		else
		{
			// we are retrieving a normal inventory catalog.

			// since we need the OEM table to perform bitmask detection on an inventory catalog
			// we first check to see if the oem table has already been read. If it has not we
			// download. Note: We use full local caching on the OEM table. This is important for
			// maximum performance.
			if ( !g_v3state.m_pOemInfoTable ) //Pointer OEM info table that OEM detection needs.
			{
				byte_buffer bufOemInfo;
				if (! DownloadToBuffer( _T("oeminfo.bin"), &dl, &dm, bufOemInfo))
					throw HRESULT_FROM_WIN32(GetLastError());
				g_v3state.m_pOemInfoTable = bufOemInfo.detach();
			}

			// perform active setup record bitmask pruning.
			pCatalog->BitmaskPruning(&bmAS, g_v3state.m_pOemInfoTable);


			// since windows 95 & NT4.0 do not support PnP drivers we cannot add any device driver records.
			//
			// NOTE: The catalog.Prune() method hides the device driver insertion record. So we do not need
			// to do anything if the OS does not allow device driver installations.
			if (DoesClientPlatformSupportDrivers())
			{
				LOG_out("Support drivers on this platform");

				// if there are device driver records to be added.
				if ( pCatalog->GetRecordIndex(WU_TYPE_CDM_RECORD_PLACE_HOLDER) != -1 )
				{
					LOG_out("Have drivers on this platform");

					// if there are no drivers for this platform
					// the bitmask will be missing and the Read()
					// method will throw.  In this case, we do nothing.
					try
					{
						bmCDM.Read(&dl, &dm, puidCatalog, BITMASK_CDM_TYPE, NULL);
						cdm.CreateInventoryList(&bmCDM, &dl, &dm, puidCatalog, g_v3state.m_pOemInfoTable);
						pCatalog->AddCDMRecords(&cdm);
					}
					catch(HRESULT hr)
					{
						LOG_out("ProcessCatalog: bitmask.cdm or inventory.cdm missing.");
					}
				}
				else
				{
					LOG_out("Don't have drivers on this platform");
				}
			}
			else
			{
				LOG_out("Don't support drivers on this platform");
			}

			pCatalog->ProcessExclusions(&dl);

			//
			// do active setup detection
			//
			DetectActiveSetupWU(&dl, &dm, pCatalog);

			// perform catalog inventory link processing and use selected registry item hiding.
			pCatalog->Prune();
		}


		if (puidCatalog == WU_CATALOG_LIST_PUID)
		{

			// description files for catalog list
			//
			// NOTE: With 3.1 we dropped the description fields for catalog list
			//		 we fill the structure with blank descriptions
			for (i = 0; i < pCatalog->GetHeader()->totalItems; i++)
			{
				if (NULL == (pCatalogItem = pCatalog->GetItem(i)))
				{
					continue;
				}
				if (pCatalogItem->ps->state != WU_ITEM_STATE_PRUNED)
                {
					(void)pCatalog->BlankDescription(pCatalogItem);
                }
			}
		}
		else
		{
			//
			// read descriptions for the catalog items
			//    1. read gang description file
			//    2. (pass 1) read individual descriptions for items that did not get descriptions by
			//       by using browser language
			//    3. (pass 2) read individual descriptions for itmes that still did not get descriptions
			//       by using machine language
			//

			hr = pCatalog->ReadDescriptionGang(&dl, &dm);

			// check to see if we need to download any individual descriptions
			BOOL bNeedIndividual = FALSE;
			if (FAILED(hr))
			{
				bNeedIndividual = TRUE;
			}
			else
			{
				for (i = 0; i < pCatalog->GetHeader()->totalItems; i++)
				{
					if (NULL == (pCatalogItem = pCatalog->GetItem(i)))
					{
						continue;
					}
					if ((pCatalogItem->ps->state != WU_ITEM_STATE_PRUNED) && (pCatalogItem->pd == NULL))
					{
						// need to download it
						bNeedIndividual = TRUE;
						break;
					}
				} // for
			}

			for (int iPass = 1; iPass <= 2; iPass++)
			{
				if (!bNeedIndividual)
				{
					break;
				}

				hr = S_OK;
				bNeedIndividual = FALSE;

				//
				// we need to download individual description files
				//
				TCHAR szMapFile[MAX_PATH];
				TCHAR szMapFileLocal[MAX_PATH];
				BYTE* pMapMem;
				DWORD dwMapLen;
				
				// build path for crc map file
				wsprintf(szMapFile, _T("%d_%s.des"), 
						pCatalog->GetPlatform(), 
						(iPass == 1) ? pCatalog->GetBrowserLocaleSZ() : pCatalog->GetMachineLocaleSZ());

				//because the map file name isn't a CRC, we can't guarantee that it is the right one - always delete and re-download
				GetWindowsUpdateDirectory(szMapFileLocal);
				lstrcat(szMapFileLocal, szMapFile);

                if(!CWUDownload::s_fOffline)
                {
				    DeleteFile(szMapFileLocal);
                }

				hr = DownloadFileToMem(&dl, szMapFile, &dm, &pMapMem, &dwMapLen);

				if (SUCCEEDED(hr))
				{
					// create a crc map object with the memory image of the file
					CCRCMapFile DescMap(pMapMem, dwMapLen);
					CWUDownload dlRoot(g_v3state.GetRootServer(), 8192);

					for (i = 0; i < pCatalog->GetHeader()->totalItems; i++)
					{
						if (NULL == (pCatalogItem = pCatalog->GetItem(i)))
						{
							continue;
						}
						if ((pCatalogItem->ps->state != WU_ITEM_STATE_PRUNED) && (pCatalogItem->pd == NULL))
						{
							DWORD dwDisp = 0;
							hr = pCatalog->ReadDescription(&dlRoot, &dm, pCatalogItem, &DescMap, &dwDisp);
							if (FAILED(hr))
							{
									// description not found
									if (iPass == 1)
									{
										bNeedIndividual = TRUE;
										hr = S_OK;
									}
									else
									{
	                                    switch(dwDisp)
	                                    {
		                                    case DISP_PUID_NOT_IN_MAP:
		                                        wsprintfA(szBuffer, "Puid #%d not found in map file - removing from catalog", pCatalogItem->GetPuid());
		                                        LOG_out(szBuffer);
		                                        pCatalogItem->ps->state = WU_ITEM_STATE_PRUNED;
		                                        hr = S_OK;
		                                        break;
		                                    case DISP_DESC_NOT_FOUND:
		                                        wsprintfA(szBuffer, "Missing description file for puid #%d - removing from catalog", pCatalogItem->GetPuid());
		                                        LOG_out(szBuffer);
		                                        pCatalogItem->ps->state = WU_ITEM_STATE_PRUNED;
		                                        hr = S_OK;
		                                        break;
	                                    }
	                                    
	                                    break;
										}
								}


						}
					} // for i

					V3_free(pMapMem);
					}
				else
				{
					if (iPass == 1)
					{
						bNeedIndividual = TRUE;
						hr = S_OK;
					}
				}


			} // for iPass

			if (FAILED(hr)) 
			{
				throw hr;
			}

#ifdef _WUV3TEST
			// validate descriptions
			CheckDescDiagInfo(pCatalog);
#endif // _WUV3TEST

		}

		bCheckInNeeded = TRUE;
		LOG_out("catalog for %d NOT found in state cache, create it", puidCatalog);//added by wei
	}
	else //added by wei
	{
		LOG_out("catalog for %d found in state cache, return it", puidCatalog);
	}

	// in the case where the catalog is already in state storage we simply make
	// the catalog array and return.

	// NOTE: if this catalog came from state storage then there is no reason to check it in.
	if (bCheckInNeeded)
	{
		// finally check the pruned catalog into state storage.
		g_v3state.Add(puidCatalog, pCatalog);
	}


	// if we got here that also means that CheckLaunchServer has validated us
	// mark this instance as a valid one
	m_bValidInstance = TRUE;

	return pCatalog;
}



STDMETHODIMP CCV3::ChangeItemState(
	IN long	puid,
	IN long lNewItemState
	)
{
	HRESULT hrRet = S_OK;

	try
	{
		hrRet = ProcessChangeItemState(puid, lNewItemState);
	}
	catch (HRESULT hr)
	{
		hrRet = hr;
	}

	return hrRet;
}



HRESULT CCV3::ProcessChangeItemState(
	IN long	puid,
	IN long lNewItemState
	)
{
	HKEY	hKey;
	BOOL	bChanged;
	int		i;
	int		iTotalItems;

	Varray<PINVENTORY_ITEM>	pItemList;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	//if the requested state is SELECT by itself, we default to SELECT | INSTAL
	if (lNewItemState == ITEM_STATE_SELECT_ITEM)
	{
		lNewItemState = ITEM_STATE_SELECT_ITEM | ITEM_STATE_INSTALL_ITEM;
	}

	if (!(iTotalItems = g_v3state.GetItemList(puid, pItemList)))
	{
		TRACE("ChangeItemState called with invalid PUID %d", puid);
		return E_INVALIDARG;
	}

	bChanged = FALSE;

	for (i = 0; i < iTotalItems; i++)
	{

		//
		// show/hide
		//
		if (lNewItemState & ITEM_STATE_HIDE_ITEM)
		{
			if ( !pItemList[i]->ps->bHidden )
			{
				pItemList[i]->ps->bHidden = TRUE;
				bChanged = TRUE;
			}
		}
		else if (lNewItemState & ITEM_STATE_SHOW_ITEM)
		{
			if ( pItemList[i]->ps->bHidden )
			{
				pItemList[i]->ps->bHidden = FALSE;
				bChanged = TRUE;
			}
		}

		//
		// select
		//
		if (lNewItemState & ITEM_STATE_SELECT_ITEM)
		{
			// default is to select the item for install.
			if (lNewItemState & ITEM_STATE_INSTALL_ITEM)
			{

				if (!pItemList[i]->ps->bChecked )
				{
					pItemList[i]->ps->bChecked = TRUE;
					bChanged = TRUE;

					g_v3state.m_selectedItems.Select(puid, TRUE);
				}
			}
			if ( lNewItemState & ITEM_STATE_REMOVE_ITEM )
			{
				// remove only removes requested item.
				g_v3state.m_selectedItems.Select(puid, FALSE);
				bChanged = TRUE;
			}
		}

		//
		// unselect
		//
		if ( lNewItemState & ITEM_STATE_UNSELECT_ITEM )
		{
			if ( pItemList[i]->ps->bChecked )
			{

				if (pItemList[i]->ps->bChecked )
				{
					pItemList[i]->ps->bChecked = FALSE;
					bChanged = TRUE;
				}

				// add item and all of its dependent items to selected items array.

				// remove item from selected items array.
				//
				// NOTE: This will only remove the item
				// if the select count is 0.
				g_v3state.m_selectedItems.Unselect(puid);

			}
		}

		//
		// personalize hide/unhide
		//
		if (lNewItemState & ITEM_STATE_PERSONALIZE_HIDE)
		{
			pItemList[i]->ps->bHidden = TRUE;
			pItemList[i]->ps->dwReason = WU_STATE_REASON_PERSONALIZE;
			bChanged = RegistryHidingUpdate(puid, TRUE);

		}
		if (lNewItemState & ITEM_STATE_PERSONALIZE_UNHIDE)
		{
			bChanged = RegistryHidingUpdate(puid, FALSE);
			if (bChanged)
			{
				pItemList[i]->ps->bHidden = FALSE;
				pItemList[i]->ps->dwReason = WU_STATE_REASON_NONE;
			}
		}

	}

	if (!bChanged)
		return E_INVALIDARG;

	return S_OK;
}



int __cdecl SortComparePriority(const void* p1, const void* p2)
{
	
	DWORD d1 = ((DEPENDPUID*)p1)->dwPriority;
	DWORD d2 = ((DEPENDPUID*)p2)->dwPriority;

	// reverse order compare
	if (d1 > d2)
		return -1;
	else if (d1 < d2)
		return +1;
	else
		return 0;
}

// Now sort if by priority

static Varray<PUID> g_vPuidParent;
static int g_cPuidParent;

void ListDependenciesFirst(Varray<DEPENDPUID>& vInitList, int cInitList, Varray<DEPENDPUID>& vFinalList, int& cFinalList)
{
	// sort initial list
	if (cInitList > 1)
		qsort((void *)(&vInitList[0]), cInitList, sizeof(DEPENDPUID), SortComparePriority);

	for (int iInitList = 0; iInitList < cInitList; iInitList++)
	{
		// check if we are in the parent array;
		for (int i = 0; i < g_cPuidParent; i++)
		{
			if (g_vPuidParent[i] == vInitList[iInitList].puid)
				break;
		}
		if (i != g_cPuidParent)
			continue; // didn't get to the very end

		// Get catalog
		CCatalog* pCatalog;
		PINVENTORY_ITEM	pItem;
		if (!g_v3state.GetCatalogAndItem(vInitList[iInitList].puid, &pItem, &pCatalog))
		{
			continue;
		}
		
		// Get dependancies
		Varray<DEPENDPUID> vTmpList;
		int cTmpList = 0;
		pCatalog->GetItemDirectDependencies(pItem, vTmpList, cTmpList);

		if (cTmpList)
		{
			// set vInitList[iList].pTopLevelItem, for them
			for(int j = 0; j < cTmpList; j ++)
			{
				if (NULL == vInitList[iInitList].pTopLevelItem)
					vTmpList[j].pTopLevelItem = pItem;
				else
					vTmpList[j].pTopLevelItem = vInitList[iInitList].pTopLevelItem;
			}

			// prepend them
			g_vPuidParent[g_cPuidParent ++] = vInitList[iInitList].puid;
			ListDependenciesFirst(vTmpList, cTmpList, vFinalList, cFinalList);
			g_cPuidParent --;
		}

		// Check if it's included by now
		for (i = 0; i < cFinalList; i++)
		{
			if (vFinalList[i].puid == vInitList[iInitList].puid)
				break;
		}
		if (i != cFinalList)
			continue; // didn't get to the very end

		// now add the item if it's not there
		vFinalList[cFinalList ++] = vInitList[iInitList];
	}
}

void ProcessInstallList(Varray<DEPENDPUID>& vFinalList, int& cFinalList)
{
	LOG_block("CCV3::ProcessInstallList");

	PSELECTITEMINFO	pSel = g_v3state.m_selectedItems.GetItems();
	int	cSel = g_v3state.m_selectedItems.GetTotal();
	if (cSel == 0)
		return;

	// Build selection list
	Varray<DEPENDPUID> vSelectList;
	int cSelectList = 0;
	DEPENDPUID d = {0};
	for (int iSel = 0; iSel < cSel; iSel++)
	{

		d.puid = pSel[iSel].puid;
		d.puidParent = 0;
		d.pTopLevelItem = NULL; // that is important

		CCatalog* pCatalog;
		PINVENTORY_ITEM	pItem;
		if (!g_v3state.GetCatalogAndItem(d.puid, &pItem, &pCatalog))
		{
			continue;
		}

		// look up priority and add the item to the array
		d.dwPriority = 0;
		PWU_VARIABLE_FIELD pvPri = pItem->pd->pv->Find(WU_DESC_INSTALL_PRIORITY);
		if (pvPri != NULL)
			d.dwPriority = *((DWORD*)(pvPri->pData));

		vSelectList[cSelectList ++] = d;
	}

	// build final list
	g_cPuidParent = 0;
	ListDependenciesFirst(vSelectList, cSelectList, vFinalList, cFinalList);

	//
	// now, clear the select and reselect the items (including dependendcies) for installation in order
	//
	g_v3state.m_selectedItems.Clear();

	for (int i = 0; i < cFinalList; i++)
	{
		LOG_out("Final List %d Pri=%d Parent=%d TopLevel=%s", 
			vFinalList[i].puid, vFinalList[i].dwPriority, 
			vFinalList[i].puidParent, (vFinalList[i].pTopLevelItem == NULL ? "NULL" : "Not NULL"));
		
		// select the item
		g_v3state.m_selectedItems.Select(vFinalList[i].puid, TRUE);

	}
}


STDMETHODIMP CCV3::InstallSelectedItems(
	IN BSTR bstrUnused,		//Server Directory if blank then the server used with the catalog was retrieved is used.
	IN long lFlags,			//Flags currently only WU_NOSPECIAL_FLAGS and WU_COPYONLY_NO_INSTALL supported.
	IN BSTR bstrNotUsed,
	OUT RETVAL VARIANT *pResultsArray
	)
{
	LOG_block("CCV3::InstallSelectedItems");

	int iTotalItems = 0;
	TCHAR szTempDir[MAX_PATH];
	TCHAR szLocalDir[MAX_PATH];
	CDiamond dm;
	PSELECTITEMINFO pInfo = NULL;
	Varray<INSTALLINFOSTRUCT> InstallArr;   
	int InstallCnt = 0;   
	DWORD dwTotalBytes = 0;
	Varray<DEPENDPUID> vFinalList;
	int cFinalList = 0;
	int i;
	int t;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	try
	{
		CWUProgress Progress(_Module.GetModuleInstance());
		CServPauser ServPauser;
		CDescriptionMerger DescMerger;

		g_v3state.m_bRebootNeeded = FALSE;

		//
		// process depenendencies and priorities of the item
		//
		ProcessInstallList(vFinalList, cFinalList);				

		iTotalItems = g_v3state.m_selectedItems.GetTotal();
		pInfo = g_v3state.m_selectedItems.GetItems();


		// pause task scheduler
		ServPauser.PauseTaskScheduler();

		//
		// go thru all the selected items and build the InstallArr
		//
		for (i = 0, InstallCnt = 0; i < iTotalItems; i++)
		{
			if (pInfo[i].bInstall)
			{
				if (!g_v3state.GetCatalogAndItem(pInfo[i].puid, &InstallArr[InstallCnt].pItem, &InstallArr[InstallCnt].pCatalog))
				{
					continue;
				}

				//
				// remove the "Checked" status from the item
				//
				InstallArr[InstallCnt].pItem->ps->bChecked = FALSE;

				dwTotalBytes += (InstallArr[InstallCnt].pItem->pd->size * 1024);


				//
				// create download objects.  We use the GetCabPoolServer to get the server.for cabpool
				// we create objects for only one element and assign pdl of each install element to this object
				//
				// NOTE: We are ignoring the szServer passed in and we will eventually remove it from interface
				//
				if (InstallCnt == 0)
				{
					TRACE("InstallSelectedItems: creating download objects for %s and %s", g_v3state.GetCabPoolServer(), InstallArr[0].pCatalog->GetCatalogServer());
					InstallArr[0].bServerNew = TRUE;
					InstallArr[0].pdl = new CWUDownload(g_v3state.GetCabPoolServer(), 8192);
					InstallArr[0].pdlRoot = new CWUDownload(g_v3state.GetRootServer(), 8192);
				}
				else
				{
					InstallArr[InstallCnt].pdl = InstallArr[0].pdl;
					InstallArr[InstallCnt].pdlRoot = InstallArr[0].pdlRoot;
					InstallArr[InstallCnt].bServerNew = FALSE;
				}

				InstallArr[InstallCnt].pInfo = &pInfo[i];

				GetCurTime(&(InstallArr[InstallCnt].pInfo->stDateTime));
				InstallArr[InstallCnt].pInfo->iStatus = ITEM_STATUS_FAILED;   //init to failed
				
				InstallArr[InstallCnt].iSelIndex = i;
				InstallArr[InstallCnt].dwLocaleID = 0;  // use systems
				InstallArr[InstallCnt].dwPlatform = 0;  // use systems
				
				InstallArr[InstallCnt].bHistoryWritten = FALSE;
				InstallArr[InstallCnt].bDownloaded = FALSE;
				InstallArr[InstallCnt].pTopLevelItem = NULL;

				//
				// if the item is hidden, set the pTopLevelItem using the dependcies list
				//
				if (InstallArr[InstallCnt].pItem->ps->bHidden)
				{
					PUID puidDep = InstallArr[InstallCnt].pItem->GetPuid();
					//
					//check puidDep, i.e. check if the function GetPuid() is returning valid info
					//
					if (puidDep > 0)
					{						
						for (int iDep = 0; iDep < cFinalList; iDep++)
						{
							if (vFinalList[iDep].puid == puidDep)
							{
								InstallArr[InstallCnt].pTopLevelItem = vFinalList[iDep].pTopLevelItem;
								break;
							}
						}
					}
				}

				//
				// merge the descriptions if machine/browser languages are different so that
				// we have the correct installation information based on machine language
				//
				BLOCK
				{
					HRESULT hr = DescMerger.CheckMerge(&InstallArr[InstallCnt]);
					if (FAILED(hr))
					{
						TRACE("Failed while mergeing description");
						throw hr;
					}
				}

				InstallCnt++;	
			}
		}

		//
		// get the directory where we will download CABs
		//
		GetWindowsUpdateDirectory(szTempDir);
		AddBackSlash(szTempDir);

		Progress.StartDisplay();
		Progress.SetDownloadTotal(dwTotalBytes);
		Progress.SetInstallTotal(InstallCnt * 3);

		//
		// Create directory for and download each item
		//
		for (i = 0; i < InstallCnt; i++)
		{
			wsprintf(szLocalDir, _T("%sCabs\\%d"), szTempDir, InstallArr[i].pInfo->puid);

			V3_CreateDirectory(szLocalDir);
			
			InstallArr[i].bDownloaded = TRUE;  //assume the download will be fine
			try
			{
				DownloadItem(szLocalDir, InstallArr[i].pdl, &dm, &InstallArr[i], &Progress);
			}
			catch (HRESULT hr)
			{
				InstallArr[i].pInfo->iStatus = ITEM_STATUS_FAILED;
				InstallArr[i].bDownloaded = FALSE;

				//
				// check to see if the Cancel button was pressed
				//
				if (WaitForSingleObject(Progress.GetCancelEvent(), 0) == WAIT_OBJECT_0)
					throw hr;
			}

			// even though the download for this item has succeeded, we reset the status to 'failed'
			// until we actually finish the installation
			InstallArr[i].pInfo->iStatus = ITEM_STATUS_FAILED;

		}
		Progress.SetDownload();  //100%


		//
		// Install each package and delete its directory
		//
		for (i = 0; i < InstallCnt; i++)
		{
			wsprintf(szLocalDir, _T("%sCabs\\%d"), szTempDir, InstallArr[i].pInfo->puid);

			Progress.SetInstallAdd(1);
			
			if (InstallArr[i].bDownloaded)
			{
				// if this is an exclusive component, hide the install progress.  We assume
				// that, apart from dependencies, this will be the only component being installed
				// since it is by definition exclusive.  In that case, this will be the last component
				// and install progress will be hidden so that the component's own setup UI is displayed
				if (InstallArr[i].pItem->pd->flags & DESCRIPTION_EXCLUSIVE)
				{
					Progress.SetStyle(CWUProgress::ProgStyle::OFF);
				}

				// install the item
				InstallItem(szLocalDir, InstallArr[i].pInfo, &InstallArr[i], &Progress);
			}
			
			Progress.SetInstallAdd(1); 

			DeleteNode(szLocalDir);

			UpdateInstallHistory(InstallArr[i].pInfo, 1);
			InstallArr[i].bHistoryWritten = TRUE;
			
			if ((InstallArr[i].pInfo->iStatus == ITEM_STATUS_SUCCESS) || (InstallArr[i].pInfo->iStatus == ITEM_STATUS_SUCCESS_REBOOT_REQUIRED))
			{
				//update item status to CURRENT
				InstallArr[i].pItem->ps->state = WU_ITEM_STATE_CURRENT;

				//indicate that a reboot is required
				if (InstallArr[i].pInfo->iStatus == ITEM_STATUS_SUCCESS_REBOOT_REQUIRED)
					g_v3state.m_bRebootNeeded = TRUE;
			}

			//remove the selected flag from the item
			InstallArr[i].pItem->ps->bChecked = FALSE;

			Progress.SetInstallAdd(1); 
		}
		Progress.SetInstall();  //100%

		// create return array
		MakeInstallStatusArray(pInfo, iTotalItems, pResultsArray);

		// remove all items from selected items
		g_v3state.m_selectedItems.Clear();


		// close server connections
		for (i = 0; i < iTotalItems; i++)
		{
			if (InstallArr[i].bServerNew)
			{
				delete InstallArr[i].pdl;
				delete InstallArr[i].pdlRoot;
			}
		}

		Progress.EndDisplay();

		// delete any cached readthisfirst pages
		CleanupReadThis();

	}
	catch (HRESULT hr)
	{
		if (pInfo != NULL)
		{
			// create return array
			MakeInstallStatusArray(pInfo, iTotalItems, pResultsArray);
		}
		else
		{
			return hr;
		}

		//
		// if there was an error, we don't want to reboot
		//
		g_v3state.m_bRebootNeeded = FALSE;

		//
		// remove all items from m_selected
		//
		g_v3state.m_selectedItems.Clear();


		// close server connections
		for (i = 0; i < iTotalItems; i++)
		{
			if (InstallArr[i].bServerNew)
			{
				delete InstallArr[i].pdl;
				delete InstallArr[i].pdlRoot;
			}

			if (!InstallArr[i].bHistoryWritten)
				UpdateInstallHistory(InstallArr[i].pInfo, 1);
		}

		// delete any cached readthisfirst pages
		CleanupReadThis();

		return S_FALSE;
	}
	return S_OK;
}




STDMETHODIMP CCV3::GetInstallMetrics(
	OUT RETVAL VARIANT *pMetricsArray
	)
{
	PSELECTITEMINFO	pInfo;
	PINVENTORY_ITEM	pItem;
	int				iTotalSelectedItems;

	try
	{
		iTotalSelectedItems = g_v3state.m_selectedItems.GetTotal();
		pInfo = g_v3state.m_selectedItems.GetItems();

		MakeInstallMetricArray(pInfo, iTotalSelectedItems, pMetricsArray);
	}
	catch(HRESULT hr)
	{
		return hr;
	}

	return S_OK;
}




STDMETHODIMP CCV3::GetEula(
	OUT RETVAL VARIANT *pEulaArray
	)
{
	PSELECTITEMINFO	pInfo;
	PINVENTORY_ITEM	pItem;
	int				i;
	int				iTotalSelectedItems;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	try
	{
		//
		// Walk though item array for each install item. Each item selected for installation
		// is store in a puid array that is part of the g_v3state class. This is a performance
		// enhancement. If we did not do this then we would need to walk through the entire
		// state structure for each catalog for every item and check it's installation state.
		//
		iTotalSelectedItems = g_v3state.m_selectedItems.GetTotal();
		pInfo = g_v3state.m_selectedItems.GetItems();

		MakeEulaArray(pInfo, iTotalSelectedItems, pEulaArray);
	}
	catch(HRESULT hr)
	{
		return hr;
	}

	return S_OK;
}



STDMETHODIMP CCV3::GetInstallHistory(
	OUT RETVAL VARIANT *pHistoryArray
	)
{
	int						i;
	int						iTotalItems;
	Varray<HISTORYSTRUCT>	History;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	try
	{
		//
		// Walk though item array for each install item. Each item selected for installation
		// is store in a puid array that is part of the g_v3state class. This is a performance
		// enhancement. If we did not do this then we would need to walk through the entire
		// state structure for each catalog for every item and check it's installation state.
		//
		ReadHistory(History, iTotalItems);

		MakeInstallHistoryArray(History, iTotalItems, pHistoryArray);
	}
	catch(HRESULT hr)
	{
		return hr;
	}

	return S_OK;
}


STDMETHODIMP CCV3::GetDependencyList(
	IN long puid,
	OUT RETVAL VARIANT *pDependentItemsArray
	)
{
	return E_NOTIMPL;
}



STDMETHODIMP CCV3::GetCatalogItem(
	IN long puid,
	OUT RETVAL VARIANT *pCatalogItem
	)
{
	PINVENTORY_ITEM pItem;
	HRESULT 		hrRet = S_OK;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	try
	{
		if (!g_v3state.GetCatalogAndItem(puid, &pItem, NULL))
			hrRet = E_INVALIDARG;
		else		
			hrRet = MakeReturnItemArray(pItem, pCatalogItem);
	}
	catch (HRESULT hr)
	{
		hrRet = hr;
	}
	
	return hrRet;
}

BOOL ConfirmUninstall(PINVENTORY_ITEM pItem)
{
	USES_CONVERSION;

	PWU_VARIABLE_FIELD pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE);

	//
	// Prefix bug NTBUG9#114181  warning (25): bounds violation (overflow) using buffer 'szResStr'
	//
	TCHAR szResStr[512];
	if (LoadString(_Module.GetModuleInstance(), IDS_UNINSTALLCHECK, szResStr, sizeof(szResStr)/sizeof(TCHAR)) == 0)
	{
		TRACE("Unable to get resource string for uninstall check");
		return FALSE;
	}

	TCHAR szMsg[1024];
	wsprintf(szMsg, szResStr, pvTitle ? W2T((LPWSTR)(pvTitle->pData)) : _T(""));
	
	DWORD dwMBFlags = MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2 | MB_SETFOREGROUND;

	if (IsArabicOrHebrew())
		dwMBFlags |= MB_RTLREADING | MB_RIGHT;

	if (MessageBox(GetActiveWindow(), szMsg, GetLocStr(IDS_APP_TITLE), dwMBFlags) != IDOK)
	{
		return FALSE;
	}

	return TRUE;
}

// confirms reboot, cleans up and reboot using a thread
BOOL CleanupAndReboot()
{
	TCHAR szBuf[512];
	// NOTE: we assume that GetLocStr will not return strings that will overflow this buffer		
	wsprintf(szBuf, _T("%s\n\n%s"), GetLocStr(IDS_REBOOT1), GetLocStr(IDS_REBOOT2));

	// adadi Oct 6, 1999: arabic + hebrew hack
	// we need to add the RTL flag if we're running on loc, but not enabled BIDI systems
	// we don't want the dialog flipped with EN text on an enabled system
	DWORD dwMBFlags = MB_ICONQUESTION | MB_YESNO | MB_TASKMODAL | MB_SETFOREGROUND;

	if (IsArabicOrHebrew())
		dwMBFlags |= MB_RTLREADING | MB_RIGHT;

	UINT id = MessageBox(GetActiveWindow(), szBuf, GetLocStr(IDS_APP_TITLE), dwMBFlags);

	if (id == IDNO)
		return FALSE;

	// cleanup
	g_v3state.Reset();
	CConnSpeed::WriteToRegistry();


	// create a thread to reboot	
	DWORD dwThreadID;
	HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RebootThreadProc, NULL, 0, &dwThreadID);
	if (hThread != NULL)
	{
		// we close the handle because we don't need it.  The thread will be destroyed after threadproc terminates
		CloseHandle(hThread);
	}

	return TRUE;
}



DWORD WINAPI RebootThreadProc(LPVOID pv)
{
	// Wait for 1 second and reboot the system
	Sleep(1000);

	(void)V3_RebootSystem();

	return 0;
}



STDMETHODIMP CCV3::RemoveSelectedItems()
{
	USES_CONVERSION;

	PSELECTITEMINFO		pInfo;
	PINVENTORY_ITEM		pItem;
	PWU_VARIABLE_FIELD	pvUninstall;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	try
	{
		//we need the os type for any device driver installs.
		int iTotalItems = g_v3state.m_selectedItems.GetTotal();
		HRESULT hr = NOERROR;

		g_v3state.m_bRebootNeeded = FALSE;

		pInfo = g_v3state.m_selectedItems.GetItems();

		for (int i=0; i<iTotalItems; i++)
		{
			if (!pInfo[i].bInstall)
			{
				//
				// if item has been selected for removal...
				// confirm that the user wants to install the item.  The user will be prompted
				// for each uninstall
				//
				if (!g_v3state.GetCatalogAndItem(pInfo[i].puid, &pItem, NULL))
				{
					continue;
				}

				if (!ConfirmUninstall(pItem))
				{
					// do not uninstall this item
					continue;
				}

				GetCurTime(&(pInfo[i].stDateTime));
				
				if (pItem->recordType == WU_TYPE_CDM_RECORD)
				{
					hr = UninstallDriverItem(pItem, &pInfo[i]);
				}
				else
				{
					pvUninstall = pItem->pd->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY);
					if (pvUninstall != NULL)
					{
						//
						// its possible that uninstall will reboot.  We have no way of knowing that
						// so we set the status initially to ITEM_STATUS_UNINSTALL_STARTED which
						// gets translated to "Started" entry in the log
						//
						pInfo[i].iStatus = ITEM_STATUS_UNINSTALL_STARTED;
						UpdateRemoveHistory(&pInfo[i], 1);
	
						hr = UninstallActiveSetupItem(A2T((LPSTR)pvUninstall->pData));
					}
					else
					{
						hr = E_UNEXPECTED;
					}
				}
				
				if (SUCCEEDED(hr))
				{
					pInfo[i].iStatus = ITEM_STATUS_SUCCESS;
					pInfo[i].hrError = NOERROR;
					pItem->ps->state = WU_ITEM_STATE_INSTALL;
				}
				else
				{
					pInfo[i].iStatus = ITEM_STATUS_INSTALLED_ERROR;
					pInfo[i].hrError = hr;

					//Fix #736: we leave the item state unchanged if the uninstall fails
				}

				pItem->ps->bChecked = FALSE;

				// 
				// write history log for final status.  We will write only the error case for active setup
				// items which have already written "Started".  For drivers we do not write the "Started"
				// entry so we will write the history now for both success and failure
				//
				if (pItem->recordType == WU_TYPE_CDM_RECORD || pInfo[i].iStatus == ITEM_STATUS_INSTALLED_ERROR)
				{
					UpdateRemoveHistory(&pInfo[i], 1);
				}
			}
		}

		//
		// remove all items from m_selected
		//
		g_v3state.m_selectedItems.Clear();

		// 
		// reboot if an uninstall has indicated that we have to reboot
		//
		if (g_v3state.m_bRebootNeeded)
		{
			(void)CleanupAndReboot();
		}
		g_v3state.m_bRebootNeeded = FALSE;
		
	}
	catch(HRESULT _hr)
	{
		g_v3state.m_bRebootNeeded = FALSE;
		return _hr;
	}

	return S_OK;
}


//
// NOTE: This method is no longer supported.  We simply return S_OK for compatibility.  We will remove
//       this method
//
STDMETHODIMP CCV3::IsCatalogAvailable(
	IN long	puidCatalog,	//Name of catalog to be read from the server.
	IN BSTR bstrServerUrl	//The http://servername/share location for the catalog to be retrieved.
	)
{
	HRESULT hr = S_OK;
	
	return hr;
}


STDMETHODIMP CCV3::FinalizeInstall(IN long lFlags)
{
	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	if (lFlags & FINALIZE_DOREBOOT)
	{
		if (g_v3state.m_bRebootNeeded)
		{
			(void)CleanupAndReboot();
		}
	}
	g_v3state.m_bRebootNeeded = FALSE;
	return NOERROR;
}


STDMETHODIMP CCV3::SetStrings(IN VARIANT* vStringsArr, IN long lType)
{
	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	return SetStringsFromSafeArray(vStringsArr, lType);
}


STDMETHODIMP CCV3::FixCompatRollbackKey(VARIANT_BOOL *pbRegModified)
{
	const TCHAR*		pszIEVersionRegKey				= _T("Software\\Microsoft\\Internet Explorer");
	const TCHAR*		pszIEUserAgentCompatKey			= _T("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\User Agent\\Post Platform");
	const TCHAR*		pszIEVersionRegValueName 		= _T("Version");
	const TCHAR*		pszIEUserAgentCompatValueName  	= _T("compat");
	TCHAR				szIEVersionValue[40];
	DWORD				dwDataType						= 0;
	DWORD				dwDataLength					= sizeof(szIEVersionValue);

	HKEY				IEVerKey						= NULL;
	HKEY				IEUserAgentKey					= NULL;

	*pbRegModified = FALSE;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}


	//check the version key first - we don't care what the UA string says unless we have rolled back to IE4
	if(ERROR_SUCCESS ==  RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszIEVersionRegKey, 0, KEY_QUERY_VALUE, &IEVerKey))
	{
		if(ERROR_SUCCESS == RegQueryValueEx(IEVerKey,pszIEVersionRegValueName,0,&dwDataType, (LPBYTE)szIEVersionValue,&dwDataLength))
		{
			if (szIEVersionValue[0] == '4') //check whether the first character is "4"
			{
				if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,pszIEUserAgentCompatKey,0,KEY_SET_VALUE, &IEUserAgentKey))
				{
					if(ERROR_SUCCESS == RegDeleteValue(IEUserAgentKey,pszIEUserAgentCompatValueName))
					{
						*pbRegModified = TRUE;					
					}
					RegCloseKey(IEUserAgentKey);
				}	
			}
			else  // otherwise, this is IE5 - we'll piggyback another reg change onto this function
            		{
                		UpdateToolsURL();
            		}
		}
		RegCloseKey(IEVerKey);
	}

	return S_OK;
}

void CCV3::UpdateToolsURL()
{
    LOG_block("UpdateToolsURL");

    const TCHAR DEFAULT_WU_URL[] = _T("http://windowsupdate.microsoft.com/");
    const TCHAR WU_TOOLMENU_PARAM[] = _T("IE");
    const TCHAR REGKEY_IE_URLS[] = _T("Software\\Microsoft\\Internet Explorer\\Help_Menu_Urls");
    const TCHAR REGVALUENAME_WU_URL[] = _T("3");
    const TCHAR REGKEY_WU_URL[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
    const TCHAR REGVALUENAME_WU_Start_URL[] = _T("URL");
    const TCHAR WU_STARTMENU_PARAM[] = _T("Start");


    HKEY    hkIEURLKey = 0;
    HKEY    hkWUURLKey = 0;

    DWORD   dwDisposition = REG_OPENED_EXISTING_KEY;

    TCHAR   tszUpdateURL[INTERNET_MAX_URL_LENGTH] = _T("\0");
    TCHAR   tszStartMenuURL[INTERNET_MAX_URL_LENGTH] = _T("\0");
    TCHAR   tszNewStartMenuURL[INTERNET_MAX_URL_LENGTH] = _T("\0");

    wsprintf( tszUpdateURL, _T("%s?%s"), DEFAULT_WU_URL, WU_TOOLMENU_PARAM );

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_IE_URLS, 0, (LPTSTR)NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkIEURLKey, &dwDisposition ) )
    {
       
       if( ERROR_SUCCESS == RegSetValueEx( hkIEURLKey, REGVALUENAME_WU_URL, 0, REG_SZ, (LPBYTE) tszUpdateURL, lstrlen(tszUpdateURL) * sizeof(TCHAR) ) )
       {
           LOG_out("Updated Tools URL to %s", tszUpdateURL);
       }

       RegCloseKey( hkIEURLKey );
    }

    //take the existing WU regkey and make sure it has "?Start" appended to it 
    // this will misbehave in the following two cases:
    // 1) if the URL key exists but is invalid (such as spaces) - can only hapen if a user manually edits the key
    // 2) if the URL contains a fragment (# + parameter)
    // both of these will result in a start menu URL that is invalid.  (the Start Menu link would be broken already if either of these cases existed)
    if (NO_ERROR == RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WU_URL, 0, (LPTSTR)NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE | KEY_READ, NULL, &hkWUURLKey, &dwDisposition )) 
	{
		DWORD dwSize = sizeof(tszStartMenuURL);
		(void) RegQueryValueEx(hkWUURLKey, REGVALUENAME_WU_Start_URL, 0, 0, (LPBYTE)&tszStartMenuURL, &dwSize);

		
		if(0 != lstrcmp(tszStartMenuURL, _T(""))) // if the reg value isn't blank
	    {
            LOG_out("Current Start Menu URL: %s", tszStartMenuURL);
		    if( NULL == _tcsstr(tszStartMenuURL, _T("?"))) // if there isn't already a querystring on the URL, make the url currenturl?param
		    {
                wsprintf(tszNewStartMenuURL, _T("%s?%s"), tszStartMenuURL, WU_STARTMENU_PARAM);
                RegSetValueEx(hkWUURLKey, REGVALUENAME_WU_Start_URL, 0, REG_SZ, (LPBYTE)tszNewStartMenuURL, lstrlen(tszNewStartMenuURL) * sizeof(TCHAR));
                LOG_out("Updating Start Menu URL To %s", tszNewStartMenuURL);
		    }
            else // if there's already a parameter
            {
                if(NULL != _tcsstr(tszStartMenuURL, WU_STARTMENU_PARAM))//if it already has "Start", bail
                {
                    // do nothing
                }
                else//otherwise make the url currenturl?param&newparam
                {
                    wsprintf(tszNewStartMenuURL, _T("%s&%s"), tszStartMenuURL, WU_STARTMENU_PARAM);
                    RegSetValueEx(hkWUURLKey, REGVALUENAME_WU_Start_URL, 0, REG_SZ, (LPBYTE)tszNewStartMenuURL, lstrlen(tszNewStartMenuURL) * sizeof(TCHAR));
                    LOG_out("Updating Start Menu URL To %s", tszNewStartMenuURL);
                }
            }
	    }
        else // if the reg value is blank, use the default WU URL + "?Start"
        {
            wsprintf(tszNewStartMenuURL, _T("%s?%s"), DEFAULT_WU_URL, WU_STARTMENU_PARAM);
            RegSetValueEx(hkWUURLKey, REGVALUENAME_WU_Start_URL, 0, REG_SZ, (LPBYTE)tszNewStartMenuURL, lstrlen(tszNewStartMenuURL) * sizeof(TCHAR));
            LOG_out("Updated Start Menu URL to %s", tszNewStartMenuURL);
        }
	    
	    RegCloseKey(hkWUURLKey);
	}
}


// This function converts our internal V3 catalog structure into a safearray of variants
// that the VBScript web page uses. The format of the safe array will be:
//    array(i,0) = NUMBER puid
//    array(i,1) = STRING TITLE
//    array(i,2) = STRING Description
//    array(i,3) = NUMBER Item Status
//    array(i,4) = NUMBER Download Size in Bytes
//    array(i,5) = NUMBER Download Time in seconds
//    array(i,6) = STRING Uninstall Key
//    array(i,7) = STRING Read This Url
HRESULT CCV3::MakeReturnCatalogArray(
	CCatalog *pCatalog,	//Pointer to catalog structure to be converted.
	long	lFilters,	//Filters to apply, see GetCatalog for the actual descriptions.
	long	lFlags,		//Flags that control the amount of information returned in each array record.
	VARIANT *pvaVariant	//pointer to returned safearray.
	)
{
	USES_CONVERSION;

	PUID				puid;
	PWSTR				pTitle;
	PWSTR				pDescription;
	PSTR				pUninstall;
	PWSTR				pReadThisUrl;
	HRESULT				hr;
	LPVARIANT			rgElems;
	LPSAFEARRAY			psa;
	SAFEARRAYBOUND		rgsabound[2];
	PINVENTORY_ITEM		pItem;
	PWU_VARIABLE_FIELD	pv;
	PWU_VARIABLE_FIELD	pvTitle;
	PWU_VARIABLE_FIELD	pvDescription;
	PWU_VARIABLE_FIELD	pvUninstall;
	PWU_VARIABLE_FIELD	pvRTF;
	PWU_VARIABLE_FIELD	pvAltName;
	int					i;
	int					t;
	int					size;
	int					downloadTime;
	TCHAR				szRTF[MAX_PATH];

	if ( !pvaVariant )
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	hr = NOERROR;

	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= 0;

	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 8;

	// count number records to return
	for(i=0; i<pCatalog->GetHeader()->totalItems; i++)
	{
		pItem = pCatalog->GetItem(i);
		if (NULL == pItem)
		{
			continue;
		}

		if ( !FilterCatalogItem(pItem, lFilters) )
			continue;
		rgsabound[0].cElements++;
	}

	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if (!psa)
		return E_OUTOFMEMORY;

	// plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	for(i = 0, t = 0; i < pCatalog->GetHeader()->totalItems; i++)
	{
		pItem = pCatalog->GetItem(i);
		if (NULL == pItem)	
		{
			continue;
		}

		if (!FilterCatalogItem(pItem, lFilters))
		{
			TRACE("Filtering (%d) skipped PUID %d while building SaveArray", lFilters, pItem->GetPuid());
			continue;
		}

		if (!pItem->pd)
		{
			TRACE("PUID %d skipped while building SaveArray - no description", pItem->GetPuid());
			continue;
		}

		size = pItem->pd->size;
		downloadTime = CalcDownloadTime(size, pItem->pd->downloadTime);


		pItem->GetFixedFieldInfo(WU_ITEM_PUID, (PVOID)&puid);

		if ( pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE) )
			pTitle = (PWSTR)pvTitle->pData;
		else
			pTitle = _T("");		// SafeArray should return empty string, not NULL BSTR

		if (pvDescription = pItem->pd->pv->Find(WU_DESCRIPTION_DESCRIPTION))
			pDescription = (PWSTR)pvDescription->pData;
		else
			pDescription = _T("");		// SafeArray should return empty string, not NULL BSTR

		// uninstall/altname field
		pUninstall = "";		// SafeArray should return empty string, not NULL BSTR
		if (pItem->recordType == WU_TYPE_CDM_RECORD)
		{
			//NOTE: we are simply returning a key that says script should put the uninstall button
			//      currently we will always display this button but we will change this to only 
			//      display it when the driver can be uninstalled
			pUninstall = "DriverUninstall";
		}
		else if (pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD)
		{
			if ((pvUninstall = pItem->pd->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY)))
			{
				pUninstall = (char *)pvUninstall->pData;
			}
		}
		else 
		{
			// for everything else, we pass the AltName field if provided
			if ((pvAltName = pItem->pd->pv->Find(WU_DESC_ALTNAME)))
			{
				pUninstall = (char *)pvAltName->pData;
			}
		}

		// read this first page
		if ((pvRTF = pItem->pd->pv->Find(WU_DESC_RTF_CRC_ARRAY)))
		{
			TCHAR szTemp[MAX_PATH];

			GetWindowsUpdateDirectory(szTemp);

			wsprintf(szRTF, _T("file://%sRTF\\%d\\%d.htm"), szTemp, pItem->GetPuid(), pItem->GetPuid());
			pReadThisUrl = szRTF;
		}
		else
		{
			pReadThisUrl = _T("");		// SafeArray should return empty string, not NULL BSTR
		}

		try
		{
			TRACE("PUID %d added to SaveArray with ReturnStatus %d", pItem->GetPuid(), GetItemReturnStatus(pItem));
/*
			// Noisy Debug Only
			TRACE("\t%S",pTitle);
			TRACE("\t%S", pDescription); 
			TRACE("\t%d", GetItemReturnStatus(pItem)); 
			TRACE("\t%d", size);
			TRACE("\t%d", downloadTime);
			TRACE("\t%s", pUninstall);
			TRACE("\t%s", pReadThisUrl);
*/
			AddSafeArrayRecord(rgElems, t, (int)rgsabound[0].cElements, 
				"%d%s%s%d%d%d%s%s",
				puid, 
				pTitle, 
				pDescription, 
				GetItemReturnStatus(pItem), 
				size,
				downloadTime, 
				A2W(pUninstall), 
				pReadThisUrl);
			t++;
		}
		catch(HRESULT hr)
		{
			TRACE("Exception thrown calling AddSafeArrayRecord");
			for (; t; t--)
				DeleteSafeArrayRecord(rgElems, t, (int)rgsabound[0].cElements, "%d%s%s%d%d%d%s%s");

			SafeArrayUnaccessData(psa);

			VariantInit(pvaVariant);

			throw hr;
		}
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}


// This function converts our internal V3 catalog structure for inventory.plt catalogs into a
// safearray of variants that the VBScript web page uses. The format of the safe array will be:
//    array(i,0) = NUMBER puid
//    array(i,1) = STRING TITLE
//    array(i,2) = STRING Description
//    array(i,3) = NUMBER Item Status
HRESULT CCV3::MakeReturnCatalogListArray(
	CCatalog *pCatalog,	//Pointer to catalog structure to be converted.
	long	lFilters,	//Filters to apply, see GetCatalog for the actual descriptions.
	long	lFlags,		//Flags that control the amount of information returned in each array record.
	VARIANT *pvaVariant	//pointer to returned safearray.
	)
{
	PUID				puid;
	PWSTR				pTitle;
	PWSTR				pDescription;
	HRESULT				hr;
	LPVARIANT			rgElems;
	LPSAFEARRAY			psa;
	SAFEARRAYBOUND		rgsabound[2];
	PINVENTORY_ITEM		pItem;
	PWU_VARIABLE_FIELD	pv;
	PWU_VARIABLE_FIELD	pvTitle;
	PWU_VARIABLE_FIELD	pvDescription;
	PWU_VARIABLE_FIELD	pvUninstall;
	int					i;
	int					t;
	int					size;
	int					downloadTime;


	if ( !pvaVariant )
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	hr = NOERROR;

	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= 0;

	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 4;

	// count number records to return
	for(i=0; i<pCatalog->GetHeader()->totalItems; i++)
	{
		if (NULL == (pItem = pCatalog->GetItem(i)))
		{
			continue;
		}
		if ( !FilterCatalogItem(pItem, lFilters) )
			continue;
		rgsabound[0].cElements++;
	}

	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if ( !psa )
		return E_OUTOFMEMORY;

	// plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	for(i=0,t=0; i<pCatalog->GetHeader()->totalItems; i++)
	{
		if (NULL == (pItem = pCatalog->GetItem(i)))
		{
			continue;
		}
		if ( !FilterCatalogItem(pItem, lFilters) )
			continue;

		//array(i,0) = NUMBER puid
		//array(i,1) = STRING TITLE
		//array(i,2) = STRING Description
		//array(i,3) = NUMBER Item Status

		pItem->GetFixedFieldInfo(WU_ITEM_PUID, (PVOID)&puid);

		if ( pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE) )
			pTitle = (PWSTR)pvTitle->pData;
		else
			pTitle = _T("");		// SafeArray should return empty string, not NULL BSTR

		if ( pvDescription = pItem->pd->pv->Find(WU_DESCRIPTION_DESCRIPTION) )
			pDescription = (PWSTR)pvDescription->pData;
		else
			pDescription = _T("");		// SafeArray should return empty string, not NULL BSTR

		try
		{
			AddSafeArrayRecord(rgElems, t, (int)rgsabound[0].cElements, "%d%s%s%d",
				puid, pTitle, pDescription, GetItemReturnStatus(pItem));
			t++;
		}
		catch(HRESULT hr)
		{
			for (; t; t--)
				DeleteSafeArrayRecord(rgElems, t, (int)rgsabound[0].cElements, "%d%s%s%d");

			SafeArrayUnaccessData(psa);

			VariantInit(pvaVariant);

			throw hr;
		}
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}



void DetectActiveSetupWU(
	CWUDownload* pDownload,	// CWUDLOAD download class to be used to download detection DLLs.
	CDiamond* pDiamond,		// Diamond Expansion class.
	CCatalog* pCatalog		// catalog that detection CIF is to be created from.
	)
{
	USES_CONVERSION;

	int		cItemsDetected = 0;
	PWU_VARIABLE_FIELD pVar;
	DWORD dwDetectStatus;
	CComponentDetection CompDet;

	LOG_block("DetectActiveSetupWU");
	
	//check input argument if valid
	if (NULL == pCatalog)
	{
		return ;
	}

	for (int i = 0; i < pCatalog->GetHeader()->totalItems; i++)
	{
		PINVENTORY_ITEM pItem = pCatalog->GetItem(i);
		//check if the function GetItem has returned valid value
		if (NULL == pItem)
		{
			continue;
		}

		if (pItem->recordType != WU_TYPE_ACTIVE_SETUP_RECORD || (pItem->ps->state == WU_ITEM_STATE_PRUNED))
			continue;

		if (!IsValidGuid(&pItem->pf->a.g))
			continue;

		WCHAR	wszGuid[64];
		if (StringFromGUID2(pItem->pf->a.g, wszGuid, sizeof(wszGuid)/sizeof(wszGuid[0])) == 0) 
			continue;

		PUID puid = pItem->GetPuid();
		LOG_out("puid %d", puid);
		if (puid <= 0)
		{
			continue;
		}

		//
		// we have a valid component to detect
		//
		cItemsDetected++;

		// guid
		CompDet.SetValue(CComponentDetection::ccGUID, W2A(wszGuid));

		// version
		char szVersion[64];
		VersionToString(&pItem->pf->a.version, szVersion);
		CompDet.SetValue(CComponentDetection::ccVersion, szVersion);

		//
		// detection dll variable fields
		//
		char	szDllName[128];
		szDllName[0] = '\0';

		if (pItem->pv->Find(WU_DETECT_DLL_REG_KEY_EXISTS))
		{
			// WUDETECT.DLL,RegKeyExists special case
			CompDet.SetValue(CComponentDetection::ccDetectVersion, "wudetect.dll,RegKeyExists");
			
			strcpy(szDllName, "wudetect.bin");
		}

		if ((pVar = pItem->pv->Find(WU_DETECT_DLL_GENERIC)))
		{
			LPSTR ptr;
			
			// generic detection DLL including WUDETECT.DLL,RegKeyVersion case
			CompDet.SetValue(CComponentDetection::ccDetectVersion, (LPCSTR)pVar->pData);

			// parse out detection dll name from DetectVersion= value
			if ((ptr = (PSTR)_memccpy(szDllName, (char *)pVar->pData, '.', sizeof(szDllName))))
			{
				*(ptr - 1) = 0;
			}
			strcat(szDllName, ".bin");

		}

		//
		// download the dll.  Download DLL takes care of caching
		//
		if (szDllName[0] != '\0')
		{
			TCHAR szPath[MAX_PATH];

			// construct full path for the detection dll
			wsprintf(szPath, _T("Detect/%d/%s"), pCatalog->GetPlatform(), A2T(szDllName));

			DownloadDLL(pDiamond, pDownload, A2T(szDllName), szPath);
		}


		//
		// other variable length fields
		//

		if ((pVar = pItem->pv->Find(WU_KEY_CUSTOMDETECT)))
		{
			// custom data
			CompDet.SetValue(CComponentDetection::ccCustomData, (LPCSTR)pVar->pData);
		}



		if ((pVar = pItem->pv->Find(WU_KEY_UNINSTALLKEY)))
		{
			// UninstallKey, remove quotes first
			char szKeyVal[MAX_PATH];
			LPCSTR pszKeyDat = (LPCSTR)pVar->pData;

			if (pszKeyDat[0] == '"')
			{
				strcpy(szKeyVal, (pszKeyDat + 1));
				int iKenLen = strlen(szKeyVal);
				if (iKenLen > 0)
					szKeyVal[iKenLen - 1] = '\0';
			}
			else
			{
				strcpy(szKeyVal, pszKeyDat);
			}

			CompDet.SetValue(CComponentDetection::ccUninstallKey, szKeyVal);
		}

		// locale
		if (!(pVar = pItem->pv->Find(WU_DET_CIF_LOCALE)))
		{
			CompDet.SetValue(CComponentDetection::ccLocale, "*");
		}
		else
		{
			CompDet.SetValue(CComponentDetection::ccLocale, (LPCSTR)pVar->pData);
		}


/* 
DEBUG CODE ONLY

		LOG_out("[%d]", pItem->GetPuid());
		char buf[512];
		if (CompDet.GetValue(CComponentDetection::ccGUID, buf, sizeof(buf))) LOG_out("%s=%s", "GUID", buf);
		if (CompDet.GetValue(CComponentDetection::ccVersion, buf, sizeof(buf))) LOG_out("%s=%s", "Version", buf); 
		if (CompDet.GetValue(CComponentDetection::ccUninstallKey , buf, sizeof(buf))) LOG_out("%s=%s", "UninstallKey", buf);
		if (CompDet.GetValue(CComponentDetection::ccDetectVersion, buf, sizeof(buf))) LOG_out("%s=%s", "DetectVersion", buf);
		if (CompDet.GetValue(CComponentDetection::ccRegKeyVersion , buf, sizeof(buf))) LOG_out("%s=%s", "RegKeyVersion", buf);
		if (CompDet.GetValue(CComponentDetection::ccLocale , buf, sizeof(buf))) LOG_out("%s=%s", "Locale", buf);
		if (CompDet.GetValue(CComponentDetection::ccQFEVersion , buf, sizeof(buf))) LOG_out("%s=%s", "QFEVersion", buf);
		if (CompDet.GetValue(CComponentDetection::ccCustomData , buf, sizeof(buf))) LOG_out("%s=%s", "CustomData", buf);
*/

		//
		// now detect the item
		//
		dwDetectStatus = CompDet.Detect();
		switch (dwDetectStatus)
		{
			case ICI_NOTINSTALLED:	// 0 = item not installed(INSTALL)
				pItem->ps->state = WU_ITEM_STATE_INSTALL;
				LOG_out("puid %d not installed", pItem->GetPuid());
				break;
			case ICI_INSTALLED:		// 1	= this item is curretly installed
				pItem->ps->state = WU_ITEM_STATE_CURRENT;
				LOG_out("puid %d installed current version", pItem->GetPuid());
				break;
			case ICI_NEWVERSIONAVAILABLE:	// 2 Items is installed but newer available
				pItem->ps->state = WU_ITEM_STATE_UPDATE;
				{ // we want to save currently installed version
					DWORD dwInstalledVer;
					DWORD dwInstalledBuild;
					CompDet.GetInstalledVersion(&dwInstalledVer, &dwInstalledBuild);
					pItem->ps->verInstalled.major	= HIWORD(dwInstalledVer);
					pItem->ps->verInstalled.minor	= LOWORD(dwInstalledVer); 
					pItem->ps->verInstalled.build	= HIWORD(dwInstalledBuild); 
					pItem->ps->verInstalled.ext  	= LOWORD(dwInstalledBuild);
					LOG_out("puid %d installed version %d.%d.%d.%d and new version available ", pItem->GetPuid(),
						pItem->ps->verInstalled.major, pItem->ps->verInstalled.minor, pItem->ps->verInstalled.build, pItem->ps->verInstalled.ext);
				}
				break;
			case ICI_UNKNOWN:				// 3 cannot be determined
			case ICI_OLDVERSIONAVAILABLE:	// 4 Why would anyone want to install the older version?
			case ICI_NOTINITIALIZED:		// 0xffffffff
			default:
				pItem->ps->bHidden = TRUE;
				pItem->ps->state = WU_ITEM_STATE_PRUNED;
				LOG_out("puid %d should be ignored and hidden", pItem->GetPuid());
				break;
		}


	} // each item

	LOG_out("%d items were detected", cItemsDetected);
}



void DownloadItem(
	LPCTSTR pszLocalDir,					//directory to download to.  Must be created by caller
	CWUDownload* pDownload,				//Pointer to internet download class
	CDiamond* pDiamond,					//Pointer to compression class
	PINSTALLINFOSTRUCT pInstallInfo,	//Pointer to installation information structure.
	IWUProgress* pProgress
	)
{
	USES_CONVERSION;

	BYTE				itemFlags = 0;
	BOOL				bCloseConnection = FALSE;
	DWORD				platformId;
	HRESULT 			hrError;
	PWU_VARIABLE_FIELD	pvCabs = NULL;
	PWU_VARIABLE_FIELD	pvCRCs = NULL;
	PWU_VARIABLE_FIELD	pvServer;
	PWU_VARIABLE_FIELD	pvTmp;
	TCHAR				szLocale[64];
	BOOL				b128Bit;

	//Check if the input argument is not NULL
	if ( (NULL == pInstallInfo) || (NULL == pInstallInfo->pItem) )
	{
		return ;
	}

	//See if the package has a server override defined.
	if ((pvServer = pInstallInfo->pItem->pd->pv->Find(WU_DESCRIPTION_SERVERROOT)))
	{
		pDownload = new CWUDownload((LPCTSTR)pvServer->pData);
		bCloseConnection = TRUE;
	}

	try
	{

		if (pvTmp = pInstallInfo->pItem->pd->pv->Find(WU_DESCRIPTION_TITLE))
		{
			// if the item is hidden, look for the title in the TopLevel item
			if (pInstallInfo->pItem->ps->bHidden && (pInstallInfo->pTopLevelItem != NULL) && (pInstallInfo->pTopLevelItem->pd != NULL))
			{
				PWU_VARIABLE_FIELD pvTopLvl = pInstallInfo->pTopLevelItem->pd->pv->Find(WU_DESCRIPTION_TITLE);
				if (pvTopLvl)
				{
					pvTmp = pvTopLvl;
				}
			}
			pProgress->SetStatusText(W2T((LPWSTR)(pvTmp->pData)));

		}
		
		// 
		// Calculate CIF path
		//
		pInstallInfo->pItem->GetFixedFieldInfo(WU_ITEM_FLAGS, &itemFlags);

		// locale
		if (pInstallInfo->dwLocaleID == 0)
		{
			if (itemFlags & WU_BROWSER_LANGAUGE_FLAG)
			{
				lstrcpy(szLocale, pInstallInfo->pCatalog->GetBrowserLocaleSZ());
			}
			else
			{
				wsprintf(szLocale, _T("0x%8.8x"), GetMachineLangDW());
			}
		}
		else
		{
			wsprintf(szLocale, _T("0x%8.8x"), pInstallInfo->dwLocaleID);
		}

		// platform
		if (pInstallInfo->dwPlatform == 0)
			platformId = pInstallInfo->pCatalog->GetPlatform();
		else
			platformId = pInstallInfo->dwPlatform;


		pInstallInfo->pInfo->iStatus = ITEM_STATUS_DOWNLOAD_COMPLETE;
		pInstallInfo->pInfo->hrError = NOERROR;

		//
		// download files 
		//
		if (pInstallInfo->pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD ||
			 pInstallInfo->pItem->recordType == WU_TYPE_CDM_RECORD ||
			 pInstallInfo->pItem->recordType == WU_TYPE_RECORD_TYPE_PRINTER)
		{
			b128Bit = FALSE;

			if (pInstallInfo->pItem->recordType == WU_TYPE_ACTIVE_SETUP_RECORD)
			{
				//download CIF
				DownloadCif(pszLocalDir, pDiamond, pInstallInfo);

				// check for 128 bit
				if ((pvTmp = pInstallInfo->pItem->pd->pv->Find(WU_DESC_128BIT_PRODID)))
				{
					b128Bit = TRUE;
				}

			}

			if (b128Bit)
			{
				// download 128 bit components
				Download128Bit(pszLocalDir, pInstallInfo->pItem, pProgress);
			}
			else
			{
				// download install CABs
				pvCabs = pInstallInfo->pItem->pd->pv->Find(WU_DESCRIPTION_CABFILENAME);
				pvCRCs = pInstallInfo->pItem->pd->pv->Find(WU_DESC_CRC_ARRAY);

				if (NULL == pvCabs || NULL == pvCRCs)
				{
					// Active setup items can have no cabs
					if( pInstallInfo->pItem->recordType != WU_TYPE_ACTIVE_SETUP_RECORD)
						throw HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
				}
				else
				{

					DownloadCabs(pszLocalDir, 
								 pDownload, 
								 pDiamond, 
								 (PBYTE)pvCabs->pData, 
								 (PBYTE)pvCRCs->pData, 
								 pProgress,
								 pInstallInfo->pItem->recordType != WU_TYPE_ACTIVE_SETUP_RECORD);
				}
			}
		}
		else
		{
			throw E_UNEXPECTED;
		}

	}
	catch(HRESULT hr)
	{
		//
		// download failed
		//
		pInstallInfo->pInfo->hrError = hr;
		pInstallInfo->pInfo->iStatus = ITEM_STATUS_FAILED;
		
		if (bCloseConnection)
		{
			delete pDownload;
		}


		//
		// ping URL to report failure
		//
		if (pInstallInfo->pTopLevelItem == NULL)
		{
			// for top level components only
			URLPingReport(pInstallInfo->pItem, pInstallInfo->pCatalog, pInstallInfo->pInfo, (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)) ? URLPING_CANCELED : URLPING_FAILED);
		}

		throw hr;
	}

	if (bCloseConnection)
	{
		delete pDownload;
	}

	// 
	// ping URL to report success
	//
	if (pInstallInfo->pTopLevelItem == NULL)
	{
		URLPingReport(pInstallInfo->pItem, pInstallInfo->pCatalog, pInstallInfo->pInfo, URLPING_SUCCESS);
	}

}



// this function perform and installation of a catalog item. This function takes care
// of ensuring that the correct installer is called based on the package type.
void InstallItem(
	LPCTSTR pszLocalDir,					//Local client machine root directory the temp storage
	PSELECTITEMINFO pStatusInfo,		//Pointer to installation status array
	PINSTALLINFOSTRUCT pInstallInfo,	//Pointer to installation information structure.
	IWUProgress* pProgress
	)
{
	HRESULT				hrError;
	PWU_VARIABLE_FIELD	pvTitle;
	PWU_VARIABLE_FIELD  pvTmp;
	TCHAR				szCIFFile[MAX_PATH];
	BOOL				bWindowsNT;

	//check the input arguments
	if (NULL == pszLocalDir || NULL == pStatusInfo || NULL == pInstallInfo)
	{
		return;
	}

	bWindowsNT = IsWindowsNT();
	try
	{
		if (pvTitle = pInstallInfo->pItem->pd->pv->Find(WU_DESCRIPTION_TITLE))
		{
			// if the item is hidden, look for the title in the TopLevel item
			if (pInstallInfo->pItem->ps->bHidden && (pInstallInfo->pTopLevelItem != NULL) && (pInstallInfo->pTopLevelItem->pd != NULL))
			{
				PWU_VARIABLE_FIELD pvTopLvl = pInstallInfo->pTopLevelItem->pd->pv->Find(WU_DESCRIPTION_TITLE);
				if (pvTopLvl)
				{
					pvTitle = pvTopLvl;
				}
			}
			pProgress->SetStatusText(W2T((LPWSTR)(pvTitle->pData)));
		}


		GetCurTime(&(pStatusInfo->stDateTime));
		pStatusInfo->iStatus = ITEM_STATUS_SUCCESS;
		pStatusInfo->hrError = NOERROR;

		TRACE("InstallItem, puid=%d, recordtype: %d", pInstallInfo->pItem->GetPuid(), (DWORD)pInstallInfo->pItem->recordType);

		switch (pInstallInfo->pItem->recordType)
		{
			case WU_TYPE_ACTIVE_SETUP_RECORD:
				BLOCK
				{
					TCHAR szCifBaseName[16];

					wsprintf(szCifBaseName, _T("%d.cif"), pInstallInfo->pItem->GetPuid()); 
					GetWindowsUpdateDirectory(szCIFFile);
					lstrcat(szCIFFile, szCifBaseName);
				}

				//
				// check to see if inseng is up to date (only done once)
				//
				CheckDllsToJit(pInstallInfo->pCatalog->GetCatalogServer());

				//
				// install active setup item
				//
				if ((pvTmp = pInstallInfo->pItem->pd->pv->Find(WU_DESC_128BIT_PRODID)))
				{
					// 128 bit
					TCHAR szCmd[MAX_PATH];
					long lRet;

					lstrcpy(szCmd, pszLocalDir);
					AddBackSlash(szCmd);
					lstrcat(szCmd, EXENAME_128BIT);

					lRet = LaunchProcess(szCmd, NULL, SW_NORMAL, TRUE);
				}
				else
				{
					InstallActiveSetupItem(pszLocalDir, szCIFFile, pStatusInfo, pProgress);
				}

				// delete CIF file
				DeleteFile(szCIFFile);
				break;

			case WU_TYPE_CDM_RECORD:
	
				InstallDriverItem(pszLocalDir, bWindowsNT, pvTitle ? W2T((LPWSTR)(pvTitle->pData)) : _T(""), pInstallInfo->pItem, pStatusInfo);
				break;

			case WU_TYPE_RECORD_TYPE_PRINTER:
				{
					PWU_VARIABLE_FIELD  pvDriverName = pInstallInfo->pItem->pv->Find(WU_CDM_DRIVER_NAME); 
					PWU_VARIABLE_FIELD  pvArchitecture = pInstallInfo->pItem->pv->Find(WU_CDM_PRINTER_DRIVER_ARCH);
					if (NULL == pvDriverName)
						throw E_UNEXPECTED; // should never happen
					InstallPrinterItem((LPCTSTR)pvDriverName->pData, pszLocalDir, 
						NULL == pvArchitecture ? NULL : (LPCTSTR)pvArchitecture->pData);
				}
				break;

			case WU_TYPE_CDM_RECORD_PLACE_HOLDER:
			case WU_TYPE_SECTION_RECORD:
			case WU_TYPE_SUBSECTION_RECORD:
			case WU_TYPE_SUBSUBSECTION_RECORD:
			default:
				throw E_UNEXPECTED;
		}
	        if(ITEM_STATUS_FAILED == pStatusInfo->iStatus)
                {
                     URLPingReport(pInstallInfo->pItem, pInstallInfo->pCatalog, pStatusInfo, URLPING_INSTALL_FAILED);
                }
                else
                {
                     URLPingReport(pInstallInfo->pItem, pInstallInfo->pCatalog, pStatusInfo, URLPING_INSTALL_SUCCESS);
                }
	}
	catch(HRESULT hr)
	{
		pStatusInfo->hrError = hr;
		pStatusInfo->iStatus = ITEM_STATUS_FAILED;
		URLPingReport(pInstallInfo->pItem, pInstallInfo->pCatalog, pStatusInfo, URLPING_INSTALL_FAILED);
	}
}

//
// Download128Bit
// this shouldn't get called anymore since the US lifted export restrictions on 128 bit items:
// we don't create items with the 128 bit flag anymore
//
void Download128Bit(LPCTSTR pszLocalDir, PINVENTORY_ITEM pItem, IWUProgress* pProgress)
{
	USES_CONVERSION;

	static const TCHAR FAILUREURL[] = _T("about:blank");
	static const TCHAR FORMDATA[] = _T("selProdID=%s&Next=Download+Now%%21&failureURL=%s");

	CWUDownload* pDL = NULL;
	TCHAR szFormData[MAX_PATH];
	TCHAR szLocalFile[MAX_PATH];
	PWU_VARIABLE_FIELD pvTmp;
	DWORD dwErr = ERROR_SUCCESS;

	// get product id
	if (!(pvTmp = pItem->pd->pv->Find(WU_DESC_128BIT_PRODID)))
		throw HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

	// build form data
	wsprintf(szFormData, FORMDATA, A2T((LPSTR)pvTmp->pData), FAILUREURL);

	// get URL
	if (!(pvTmp = pItem->pd->pv->Find(WU_DESC_128BIT_URL)))
		throw HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

	// build local file name
	lstrcpy(szLocalFile, pszLocalDir);
	AddBackSlash(szLocalFile);
	lstrcat(szLocalFile, EXENAME_128BIT);

	// create download class
	pDL = new CWUDownload(A2T((LPSTR)pvTmp->pData), 8192);
	if (!pDL)
	{
		dwErr = GetLastError();
		throw HRESULT_FROM_WIN32(dwErr);
	}

	if (!pDL->PostCopy(szFormData, szLocalFile, pProgress))
	{
		dwErr = GetLastError();
	}
	delete pDL;

	if (dwErr != ERROR_SUCCESS)
		throw HRESULT_FROM_WIN32(dwErr);
}



void DownloadCabs(
	LPCTSTR szLocalDir,			//Local client machine directory to use for temp storage
	CWUDownload *pDownload,		//Pointer to internet download class
	CDiamond *pDiamond,			//Pointer to compression class
	PBYTE pCabList,				//Multi SZ list of cabs to be downloaded.
	PBYTE pCRCList,				//array to CRC hash structures
	IWUProgress* pProgress,
	BOOL bUnCab
	)
{

	TCHAR szLocalFile[MAX_PATH];
	TCHAR szServerFile[MAX_PATH];
	TCHAR szLocalCab[128];
	TCHAR szServerCab[128];
	int iCabNo = 0;
	

	V3_CreateDirectory(szLocalDir);

	for (;;)
	{
		
		if (FAILED(GetCRCNameFromList(iCabNo, pCabList, pCRCList, szServerCab, sizeof(szServerCab), szLocalCab)))
			break;

		// build full paths	
		lstrcpy(szLocalFile, szLocalDir);
		AddBackSlash(szLocalFile);
		lstrcat(szLocalFile, szLocalCab);

		lstrcpy(szServerFile, _T("CabPool/"));
		lstrcat(szServerFile, szServerCab);

		TRACE("Downloading %s", szServerFile);

		if (!pDownload->Copy(szServerFile, szLocalFile, NULL, NULL, 0, pProgress))
		{
			TRACE("Download of cab %s failed", szServerFile);			
			throw HRESULT_FROM_WIN32(GetLastError());
		}

		//
		// check signature of the download CAB file
		// Don't show an MS cert
        // use VerifyFile (see WU bug # 12251)
		//
		HRESULT hr = VerifyFile(szLocalFile, TRUE);
	    TRACE("VerifyFile(%s) Result: %x (%s)", szLocalFile, hr, SUCCEEDED(hr) ? "SUCCESS" : "FAILURE");
		if (FAILED(hr))
			throw hr;

		if (bUnCab)
		{
			if (pDiamond->IsValidCAB(szLocalFile))
			{
				TCHAR szUnCompFn[MAX_PATH];
				
				lstrcpy(szUnCompFn, szLocalDir);
				AddBackSlash(szUnCompFn);
				lstrcat(szUnCompFn, _T("*"));

				pDiamond->Decompress(szLocalFile, szUnCompFn);

				//
				// delete the CAB file after uncompressing
				//
				DeleteFile(szLocalFile);
			}
		}

		iCabNo++;

	} 
}


void DownloadCif(
	LPCTSTR szLocalDir,			// Local client machine directory to use for temp storage
	CDiamond *pDiamond,			// Pointer to compression class
	PINSTALLINFOSTRUCT pInstallInfo
	)
{
	V3_CreateDirectory(szLocalDir);

	PWU_VARIABLE_FIELD pvCif = pInstallInfo->pItem->pd->pv->Find(WU_DESC_CIF_CRC);
	if (!pvCif)
	{
		TRACE("CIF CRC field missing");
		throw HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	TCHAR szCifBaseName[16];
	wsprintf(szCifBaseName, _T("%d.cif"), pInstallInfo->pItem->GetPuid()); 
	TCHAR szCifCRCName[64];
	HRESULT hr = MakeCRCName(szCifBaseName, (WUCRC_HASH*)pvCif->pData, szCifCRCName, sizeof(szCifCRCName));
	if (FAILED(hr))
		throw hr;

	// create a temp file name for the .CIF file with .CI$ 
	TCHAR szLocalFile[MAX_PATH];
	TCHAR szServerFile[MAX_PATH];
	lstrcpy(szLocalFile, szLocalDir);
	AddBackSlash(szLocalFile);
	lstrcat(szLocalFile, szCifBaseName);
	LPTSTR pszDot = _tcschr(szLocalFile, _T('.'));
	if (pszDot)
		*pszDot = _T('\0');
	lstrcat(szLocalFile, _T(".CI$"));

	// server file name
	wsprintf(szServerFile, _T("CRCCif/%s"), szCifCRCName);

	if (!pInstallInfo->pdlRoot->Copy(szServerFile, szLocalFile, NULL, NULL, 0, NULL))
	{
		TRACE("Download of CIF cab %s failed", szServerFile);			
		throw HRESULT_FROM_WIN32(GetLastError());
	}

	// copy or uncompress to a .CIF file name
	TCHAR szTemp[MAX_PATH];
	GetWindowsUpdateDirectory(szTemp);
	lstrcat(szTemp, szCifBaseName);
	if (pDiamond->IsValidCAB(szLocalFile))
	{
		pDiamond->Decompress(szLocalFile, szTemp);
	}
	else
	{
		CopyFile(szLocalFile, szTemp, FALSE);
	}

	// NOTE:we don't delete the .CI$ file because all the files in the directory get deleted later
}


// download and save the FileVer.ini file in the cache
//
// NOTE: For 3.1 filever.ini file contains image download information as well
void DownloadFileVerInfo(CWUDownload* pDownload)
{

	// if the file is missing, we don't have version information but we do not abort
	(void)pDownload->Copy(FILEVERINI_FN, NULL, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY, NULL);
}



void DownloadDLL(CDiamond *pDiamond, CWUDownload *pDownload, LPCTSTR pszDLLName, LPCTSTR pszPath)
{
	//
	// check our state detection dlls array to see if we downloaded
	// this dll in this session already
	//
	// NOTE: We store the file name of the DLL as it is on the server OSDET.W98, wudetect.bin etc
	//

    TCHAR szDLLIn[MAX_PATH];
	GetWindowsUpdateDirectory(szDLLIn);
	lstrcat(szDLLIn, pszDLLName);

	TCHAR szDLLOut[MAX_PATH];
	lstrcpy(szDLLOut, szDLLIn);

	TCHAR* ptr = _tcschr(szDLLOut, _T('.'));
	if (ptr)
		*ptr = 0;

	lstrcat(szDLLOut, _T(".dll"));

	if (g_v3state.CacheDLLName(pszDLLName)) 
        {
		//added by wei for test
		TRACE("%s found in state cache", pszDLLName);

               // doublecheck to make sure the DLL hasn't been deleted before we bail
              if (FileExists(szDLLOut))
              {
			return;
              }
	}


	//
	// download the file
	//
	if (pszPath != NULL)
	{
		if (!pDownload->Copy(pszPath, NULL, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY | EXACT_FILENAME, NULL))
			throw HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		if (!pDownload->Copy(pszDLLName, NULL, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY, NULL))
			throw HRESULT_FROM_WIN32(GetLastError());
	}


	CConnSpeed::Learn(pDownload->GetCopySize(), pDownload->GetCopyTime());

	

	//
	// check to see if we download the file or the cached copy was used.  If cache was used
	// we just check to see if the DLL itself also exists, if yes then we return otherwise we
	// will copy the or decompress the compressed file into the DLL
	//
	if (pDownload->CacheUsed())
	{
		if (FileExists(szDLLOut))
			return;
	}

	if (pDiamond->IsValidCAB(szDLLIn))
		pDiamond->Decompress(szDLLIn, szDLLOut);
	else
		CopyFile(szDLLIn, szDLLOut, FALSE);
}


void DetectPlatAndLang()
{
	TCHAR szOSDETDLL[MAX_PATH];
	
	GetWindowsUpdateDirectory(szOSDETDLL);
	lstrcat(szOSDETDLL, _T("osdet.dll"));

	//
	// do platform and langauge detection using Osdet
	//
	CallOsDet(szOSDETDLL, &g_v3state.m_pdwPlatformList, &g_v3state.m_iTotalPlatforms);

	//If we fail for any reason then use the default platform def_plat.
	if ( !g_v3state.m_pdwPlatformList )
	{
		g_v3state.m_pdwPlatformList = (PULONG)&g_v3state.m_DefPlat;
		g_v3state.m_iTotalPlatforms	= 1;
	}

}


//
// IObjectSafety
//
STDMETHODIMP CCV3::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;
	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}


STDMETHODIMP CCV3::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	// If we're being asked to set our safe for scripting option then oblige
	if (riid == IID_IDispatch)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}
	return E_NOINTERFACE;
}

//
// IWUpdateCatalog interface
//

STDMETHODIMP CCV3::WUIsCatalogAvailable(long puidCatalog,BSTR bstrServerUrl)
{
	return IsCatalogAvailable(puidCatalog, bstrServerUrl);
}


STDMETHODIMP CCV3::WUGetCatalog(long puidCatalog, BSTR bstrServerUrl, long platformId, 
		 			 		           BSTR bstrBrowserLanguage, CCatalog** ppCatalogArray)
{
	// we don't want to check the launch server from this interface
	m_bLaunchServChecked = TRUE;

	*ppCatalogArray = ProcessCatalog(puidCatalog, bstrServerUrl, platformId, bstrBrowserLanguage, WU_ALL_ITEMS, WU_NO_PRUNING);

	return S_OK;
}
		


STDMETHODIMP CCV3::WUDownloadItems(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCV3::WUInstallItems(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCV3::WURemoveItems(CSelections* pSelections)
{
	return E_NOTIMPL;
}
        


STDMETHODIMP CCV3::WUCopyInstallHistory(HISTORYARRAY** ppHistoryArray)
{
	int						iTotalItems;
	Varray<HISTORYSTRUCT>	History;
	PHISTORYARRAY			pRetArray;

	//Walk though item array for each install item. Each item selected for installation
	//is store in a puid array that is part of the g_v3state class. This is a performance
	//enhancement. If we did not do this then we would need to walk through the entire
	//state structure for each catalog for every item and check it's installation state.

	ReadHistory(History, iTotalItems);

	//Since we must use the OLE allocator we now need to allocate the correct
	//type of return memory and copy the existing history structure to it.

	pRetArray = (PHISTORYARRAY)CoTaskMemAlloc(sizeof(HISTORYARRAY)+(iTotalItems * sizeof(HISTORYSTRUCT)));
	if (NULL == pRetArray)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	pRetArray->iTotalItems = iTotalItems;

	memcpy((char *)pRetArray->HistoryItems, &History[0], (iTotalItems * sizeof(HISTORYSTRUCT)));

	*ppHistoryArray = pRetArray;

	return S_OK;
}



STDMETHODIMP CCV3::WUCopyDependencyList(long puidItem, long** ppDepPui)
{
	return E_NOTIMPL;
}



STDMETHODIMP CCV3::WUProgressDlg(BOOL bOn)
{
	return E_NOTIMPL;
}


STDMETHODIMP CCV3::IsWinUpdDisabled(VARIANT_BOOL * pfDisabled)
{
	
	*pfDisabled = FALSE;

	if (!m_bValidInstance)
	{
		return E_ACCESSDENIED;
	}

	bool fDisabled = false;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;
	HKEY hkeyRoot = IsWindowsNT() ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

	if ( RegOpenKeyEx(	hkeyRoot,
						REGPATH_EXPLORER,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WINUPD_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled != 0) )
			{
				*pfDisabled = TRUE;
			}
		}

		RegCloseKey(hKey);
	}

	return S_OK;
}



STDMETHODIMP CCV3::IsReady(VARIANT_BOOL* pbYes)
{
	*pbYes = TRUE;
	return S_OK;
}


STDMETHODIMP CCV3::GetContentURL(OUT RETVAL VARIANT* pURL)
{
	USES_CONVERSION;

	VariantInit(pURL);

	V_VT(pURL) = VT_BSTR;
	pURL->bstrVal = SysAllocString(T2OLE((LPTSTR)g_v3state.GetContentServer()));

	return S_OK;
}


// downloads the readthis first page and images for the puid locally
// script can then navigate to this page
STDMETHODIMP CCV3::GetReadThisPage(IN long puid)
{
	CCatalog* pCatalog;
	PINVENTORY_ITEM	pItem;

	if (!m_bValidInstance)
	{
		// the control is not launched from a trusted location
		return E_ACCESSDENIED;
	}

	if (!g_v3state.GetCatalogAndItem(puid, &pItem, &pCatalog))
	{
		return E_INVALIDARG;
	}

	return DownloadReadThis(pItem);
}



STDMETHODIMP CCV3::GetPrintAllPage(OUT RETVAL VARIANT* pURL)
{
	USES_CONVERSION;
	
	const char READTHISLIST[] = "%READTHISLIST%"; // a semi-colon separated list of read this pages.  For instance "readthis1.htm;readthis2.htm;readthis3.htm"
	const char READTHISPATH[] = "%READTHISPATH%"; // the URL to the read this pages.  For instance "file://d:\windowsupdate\"

	TCHAR szSourceFile[MAX_PATH];
	HRESULT hr;
    DWORD dwFileSize = 0;
    PBYTE pFileBuf = NULL;
    HANDLE hFile;
    DWORD dwBytes;
	LPTSTR pszReadThisList = NULL;

	if (!m_bValidInstance)
	{
		// the control is not launched from a trusted location
		return E_ACCESSDENIED;
	}

	// download the printall page
	GetWindowsUpdateDirectory(szSourceFile);
	lstrcat(szSourceFile, _T("RTF"));
	V3_CreateDirectory(szSourceFile);
	hr = DownloadCommonRTFFiles(TRUE, szSourceFile);
	if (FAILED(hr))
	{
		return hr;
	}

	// build a list of readthis first page names for all selected items
	PSELECTITEMINFO	pSel = g_v3state.m_selectedItems.GetItems();
	int	cSel = g_v3state.m_selectedItems.GetTotal();
	if (cSel == 0)
	{
		// no items are selected
		return S_OK;
	}


	// allocate enough memory for names of format puid\puid.htm;
	pszReadThisList = (LPTSTR)malloc(cSel * 80);

    if(!pszReadThisList)
    {
        return E_OUTOFMEMORY;
    }

	pszReadThisList[0] = _T('\0');
	for (int iSel = 0; iSel < cSel; iSel++)
	{
		CCatalog* pCatalog;
		PINVENTORY_ITEM	pItem;

		if (g_v3state.GetCatalogAndItem(pSel[iSel].puid, &pItem, &pCatalog))
		{

			if SUCCEEDED(DownloadReadThis(pItem))
			{
				TCHAR szTemp[24];
				
				wsprintf(szTemp, _T("%d\\%d.htm"), pItem->GetPuid(), pItem->GetPuid());
	
				if (pszReadThisList[0] != _T('\0'))
				{
					lstrcat(pszReadThisList, _T(";"));
				}
				lstrcat(pszReadThisList, szTemp);
			}
		}
	} //for

	if (pszReadThisList[0] == _T('\0'))
	{
		// no items selected with readthisfirst pages
		free(pszReadThisList);
		return S_OK;
	}
    
	// read the file in memory with a null appended at the end
    hFile = CreateFile(szSourceFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwFileSize = GetFileSize(hFile, NULL);
        if (dwFileSize > 0)
        {
            pFileBuf = (PBYTE)malloc(dwFileSize + 1);
            if (pFileBuf != NULL)
            {
                if (!ReadFile(hFile, pFileBuf, dwFileSize, &dwBytes, NULL))
                {
                    free(pFileBuf);
					pFileBuf = NULL;
                    dwFileSize = 0;
                }
				pFileBuf[dwFileSize] = 0;
            }
        }
        CloseHandle(hFile);
    }
	
	if (pFileBuf != NULL)
	{
		LPSTR pNewBuf;
		TCHAR szDest[MAX_PATH];
		
		GetWindowsUpdateDirectory(szDest);
		lstrcat(szDest, _T("RTF\\"));

		// replace tokens
		if (ReplaceSingleToken(&pNewBuf, (LPSTR)pFileBuf, READTHISLIST, T2A(pszReadThisList)))
		{
			free(pFileBuf);
			pFileBuf = (PBYTE)pNewBuf;
		}
		if (ReplaceSingleToken(&pNewBuf, (LPSTR)pFileBuf, READTHISPATH, T2A(szDest)))
		{
			free(pFileBuf);
			pFileBuf = (PBYTE)pNewBuf;
		}

		// create the directory
		lstrcat(szDest, _T("0\\"));
		V3_CreateDirectory(szDest);

		// write out the file
		lstrcat(szDest, _T("printall.htm"));
		hFile = CreateFile(szDest, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
	    if (hFile != INVALID_HANDLE_VALUE)
		{
			if (!WriteFile(hFile, pFileBuf, strlen((LPSTR)pFileBuf), &dwBytes, NULL))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
			}
			CloseHandle(hFile);
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}

		free(pFileBuf);

		// return the path
		TCHAR szRTF[MAX_PATH];
		VariantInit(pURL);
		wsprintf(szRTF, _T("file://%s"), szDest);
		V_VT(pURL) = VT_BSTR;
		pURL->bstrVal = SysAllocString(T2OLE(szRTF));
	}	
	else
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}



HRESULT DownloadReadThis(PINVENTORY_ITEM pItem)
{
	LOG_block("DownloadReadThis"); 

	BYTE mszFileNames[512];
	TCHAR szBaseName[64];
	TCHAR szLocalName[64];
	TCHAR szServerName[64];
	TCHAR szServerFile[MAX_PATH];
	TCHAR szLocalFile[MAX_PATH];
	TCHAR szLocalDir[MAX_PATH];

	if (NULL == pItem->pd)
	{
		LOG_error("NULL == pItem->pd");
		return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	PWU_VARIABLE_FIELD pvRTFCRC = pItem->pd->pv->Find(WU_DESC_RTF_CRC_ARRAY);
	PWU_VARIABLE_FIELD pvRTFImages = pItem->pd->pv->Find(WU_DESC_RTF_IMAGES);
	if (pvRTFCRC == NULL)
	{
		LOG_error("pvRTFCRC == NULL");
		return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	// build a multisz string of file names
	int iLen = sprintf((char*)mszFileNames, "%d.htm", pItem->GetPuid());
	mszFileNames[++iLen] = '\0';
	if (pvRTFImages != NULL)
	{
		// we have images
		memcpy(mszFileNames + iLen, pvRTFImages->pData, pvRTFImages->len - 4);
	}

	// build local directory
	GetWindowsUpdateDirectory(szLocalDir);
	wsprintf(szBaseName, _T("RTF\\%d"), pItem->GetPuid());
	lstrcat(szLocalDir, szBaseName);
	V3_CreateDirectory(szLocalDir);

	// download common images and other files
	(void)DownloadCommonRTFFiles(FALSE, NULL);

	// create a download object
	CWUDownload dlRoot(g_v3state.GetRootServer(), 8192);

	int iFileNo = 0;
	for (;;)
	{
		if (FAILED(GetCRCNameFromList(iFileNo, mszFileNames, pvRTFCRC->pData, szServerName, sizeof(szServerName), szLocalName)))
		{
			// end of the list
			break;
		}

		// build full paths	
		lstrcpy(szLocalFile, szLocalDir);
		AddBackSlash(szLocalFile);
		lstrcat(szLocalFile, szLocalName);

		lstrcpy(szServerFile, _T("CRCRtf/"));
		lstrcat(szServerFile, szServerName);

		TRACE("Downloading RTF %s", szServerFile);

		if (!dlRoot.Copy(szServerFile, szLocalFile, NULL, NULL, 0, NULL))
		{
			LOG_error("Download of RTF %s failed", szServerFile);			
			return HRESULT_FROM_WIN32(GetLastError());
		}

		iFileNo++;

	} // for
	
	return S_OK;
}


// deletes any cached readthisfirst pages
bool CleanupReadThis()
{
	LOG_block("CleanupReadThis");

	// build local directory
	TCHAR szRtfPath[MAX_PATH];
	GetWindowsUpdateDirectory(szRtfPath);
	PathAppend(szRtfPath, _T("RTF"));

	return_if_false(DeleteNode(szRtfPath));

	return true;
}



// download common images for read-this-first pages and the printall page
//
// if bPrintAll=TRUE, only printall.htm page is downloaded, pszPrintAllFN returns locale filename
// if bPrintAll=FALSE, mages are downloaded, pszPrintAllFN is not used and can be null
// 
// NOTE: The function downloads images in WinUpdDir/RTF folder and expects it to exist
HRESULT DownloadCommonRTFFiles(BOOL bPrintAll, LPTSTR pszPrintAllFN)
{


	const TCHAR SECNAME[] = _T("RTF");
	const TCHAR COUNT[] = _T("Count");
	const TCHAR IMGENTRY[] = _T("Img%d");
	const TCHAR PRINTALL[] = _T("PrintAll");

	TCHAR szLocalDir[MAX_PATH];
	TCHAR szIniFile[MAX_PATH];
	int iCount;
	int iNo;
	CWUDownload* pDownload = NULL;
	TCHAR szBaseName[64];
	TCHAR szServerFile[MAX_PATH];
	TCHAR szLocalFile[MAX_PATH];

	static BOOL bDoneImages = FALSE;
	static BOOL bDonePrintAll = FALSE;

	// build paths
	GetWindowsUpdateDirectory(szLocalDir);
	lstrcpy(szIniFile, szLocalDir);
	lstrcat(szLocalDir, _T("RTF\\"));
	lstrcat(szIniFile, FILEVERINI_FN);

	if (GetPrivateProfileString(SECNAME, PRINTALL, _T(""), szBaseName, sizeof(szBaseName) / sizeof(TCHAR), szIniFile) != 0)
	{
		lstrcpy(szLocalFile, szLocalDir);
		lstrcat(szLocalFile, szBaseName);
	}
	else
	{
		szLocalFile[0] = _T('\0');
	}

	if (bPrintAll && pszPrintAllFN != NULL)
	{
		lstrcpy(pszPrintAllFN, szLocalFile);
	}

	// if we are asked to downloaded the printall page and we have not done it in this sesssion
	if (bPrintAll && !bDonePrintAll)
	{
		bDonePrintAll = TRUE;

		// 
		// get the printall page
		//
		lstrcpy(szServerFile, g_v3state.GetSiteURL());

		// find the last slash
		int l = lstrlen(szServerFile);
		while (l > 0 && szServerFile[l - 1] != _T('\\') && szServerFile[l - 1] != _T('/'))
			l--;
		if (l == 0)
			return E_FAIL;
		
		// put a null following the last slash
		szServerFile[l] = _T('\0');

		// create the download object using the site URL without the file name
		try
		{
			pDownload = new CWUDownload(szServerFile, 8192);
		}
		catch(HRESULT hr)
		{
			return hr;
		}

		// download the file
		(void)pDownload->Copy(szBaseName, szLocalFile, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY | EXACT_FILENAME, NULL);

		delete pDownload;
	}

	// if we are asked to download images and we have not yet done them in this session
	if (!bPrintAll && !bDoneImages)
	{
		bDoneImages = FALSE;

		// 
		// download the images
		//
		iCount = (int)GetPrivateProfileInt(SECNAME, COUNT, 0, szIniFile);
		if (iCount == 0)
		{
			return S_OK;
		}

		for (iNo = 1; iNo <= iCount; iNo++)
		{
			TCHAR szKey[32];

			wsprintf(szKey, IMGENTRY, iNo);
			if (GetPrivateProfileString(SECNAME, szKey, _T(""), szBaseName, sizeof(szBaseName) / sizeof(TCHAR), szIniFile) == 0)
			{
				// try next one
				continue;
			}

			if (pDownload == NULL)
			{
				// we don't have a download object, create one
				try
				{
					pDownload = new CWUDownload(g_v3state.GetContentServer(), 8192);
				}
				catch(HRESULT hr)
				{
					return hr;
				}
			}

			// build file names
			wsprintf(szServerFile, _T("images/%s"), szBaseName);
			lstrcpy(szLocalFile, szLocalDir);
			lstrcat(szLocalFile, szBaseName);

			// download the file
			(void)pDownload->Copy(szServerFile, szLocalFile, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY | EXACT_FILENAME, NULL);
		}
		if (pDownload != NULL)
		{
			delete pDownload;
		}
	}

	return S_OK;
}

// this function validates the server the control was instantiated from
void CCV3::CheckLaunchServer()
{
	USES_CONVERSION;

	BOOL bValid;
	HRESULT hr;
    BSTR bstrURL;
	TCHAR szURL[MAX_PATH];

	if (m_bLaunchServChecked)
	{
		// we only want to do this check once
		return;
	}

	m_bLaunchServChecked = TRUE;

	bValid = FALSE;

	// check to see we have a client site.  This will be NULL if the contrainer has not
	// called our IObjectWithSimpleSite interface to set the site.  
	if (m_spUnkSite != NULL)
	{
		// NOTE: We are using ATL smart pointers here which call release upon destruction

		// QI for IServiceProvider from IUnknown of client site
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServProv(m_spUnkSite);

		if (spServProv)
		{
			CComPtr<IWebBrowser2> spBrowser;

			// QueryService for the IWebBrowser2
			hr = spServProv->QueryService(SID_SInternetExplorer, IID_IWebBrowser2, (LPVOID*)&spBrowser);
			if (SUCCEEDED(hr))
			{
				
				// get the location URL of the page that instantiated us
				hr = spBrowser->get_LocationURL(&bstrURL);
				if (SUCCEEDED(hr) && bstrURL)
				{
					lstrcpy(szURL, OLE2T(bstrURL));
				
					SysFreeString(bstrURL);

					// copy the entire site URL into the state structure
					g_v3state.SetSiteURL(szURL);
					
					// check to see if the host server matches
					// any of the site urls specified in ident.cab
					// this function will crack the site url and all
					// the site server urls to compare the hosts
					bValid = g_v3state.ValidateSiteURL();

				}
			} // queryservice
		
		} // spServProv

	} // m_spUnkSite


	if (!bValid)
	{
		TRACE("CheckLauncServer: The control is launced from an untrusted server--aborting");
		throw E_ACCESSDENIED;		
	}
}



//
// CDescriptionmMerger class
//

HRESULT CDescriptionMerger::CheckMerge(PINSTALLINFOSTRUCT pInstallInfo)
{
	HRESULT hr = S_OK;

	if (!pInstallInfo->pCatalog->LocalesDifferent())
	{
		// if the browser/machine locales are not different then we don't need to do anything
		return hr;
	}

	if (pInstallInfo->pItem->pd->pv->Find(WU_VARIABLE_MERGEINACTIVE) != NULL)
	{
		// there is a WU_VARIABLE_MERGEINACTIVE which means we have already merged
		return hr;
	}

	//
	// we need merge the descriptions
	//

	if (m_pMap == NULL || m_pDiamond == NULL)
	{
		// create CCRCMapFile and CDiamond objects for this and future use for this object
		// this method also sets m_pDiamond
		hr = ReadMapFile(pInstallInfo->pCatalog);
	}

	if (SUCCEEDED(hr))
	{
		hr = pInstallInfo->pCatalog->MergeDescription(pInstallInfo->pdlRoot, m_pDiamond, pInstallInfo->pItem, m_pMap);
	}

	return hr;
}	


HRESULT CDescriptionMerger::ReadMapFile(CCatalog* pCatalog)
{

	HRESULT hr = S_OK;
	TCHAR szMapFile[MAX_PATH];
	BYTE* pMapMem;
	DWORD dwMapLen;

	// create download object for content server and a diamond object
	CWUDownload dl(g_v3state.GetContentServer(), 8192);
	m_pDiamond = new CDiamond;

	// build path for crc map file for machine language
	wsprintf(szMapFile, _T("%d_%s.des"), 
			pCatalog->GetPlatform(), 
			pCatalog->GetMachineLocaleSZ());
	
	hr = DownloadFileToMem(&dl, szMapFile, m_pDiamond, &pMapMem, &dwMapLen);

	if (SUCCEEDED(hr))
	{
		// create a crc map object with the memory image of the file
		m_pMap = new CCRCMapFile(pMapMem, dwMapLen);
	}

	return hr;
}


#ifdef _WUV3TEST
// validates the description using diagnosis variable length fields
void CheckDescDiagInfo(CCatalog* pCatalog)
{
	
	PINVENTORY_ITEM pItem;
	PWU_VARIABLE_FIELD pvDiag;
	DESCDIAGINFO* pDiagInfo;
	int cGood = 0;
	int cItems = 0;

	for (int i = 0; i < pCatalog->GetHeader()->totalItems; i++)
	{
		if (NULL == (pItem = pCatalog->GetItem(i)))
		{
			continue;
		}
		if ((pItem->ps->state != WU_ITEM_STATE_PRUNED))
		{
			pvDiag = pItem->pd->pv->Find(WU_DESC_DIAGINFO);
			if (pvDiag != NULL)
			{
				pDiagInfo = (DESCDIAGINFO*)pvDiag->pData;

				if (pDiagInfo->puid != pItem->GetPuid() ||
					pDiagInfo->dwPlat != pCatalog->GetPlatform() ||
					pDiagInfo->dwLocale != pCatalog->GetBrowserLocaleDW())
				{
					TRACE("CheckDescDiagInfo: puid=%d has invalid description", pItem->GetPuid());
				}
				else
				{
					cGood++;
				}
			}
			else
			{
				TRACE("CheckDescDiagInfo: diagnosis information not found in descriptions");
				break;
			}
		}
		cItems++;
	}

	TRACE("CheckDescDiagInfo: %d good found for %d items compared", cGood, cItems);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\cv3.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
// CV3.h : Declaration of the CCV3

#ifndef __CV3_H_
#define __CV3_H_

#include "resource.h"       // main symbols

#include <wuv3ctl.h>
#include <cstate.h>


#ifndef RETVAL
	#define RETVAL
#endif

class ATL_NO_VTABLE CCV3 : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCV3, &CLSID_CV3>,
	public IDispatchImpl<ICV3, &IID_ICV3, &LIBID_WUV3ISLib>,
	public IObjectSafety,
    public IObjectWithSiteImpl<CCV3>,
	public IWUpdateCatalog,
	public IAutoUpdate
{
public:
	CCV3()
		: m_dwSafety(0),
		  m_bValidInstance(FALSE),
		  m_bLaunchServChecked(FALSE)
	{
	}
	
	void FinalRelease();
	HRESULT FinalConstruct();
    static TCHAR s_szControlVer[20];

DECLARE_REGISTRY_RESOURCEID(IDR_CV3)

BEGIN_COM_MAP(CCV3)
	COM_INTERFACE_ENTRY(ICV3)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
	COM_INTERFACE_ENTRY_IID(__uuidof(IWUpdateCatalog), IWUpdateCatalog)
	COM_INTERFACE_ENTRY_IID(__uuidof(IAutoUpdate), IAutoUpdate)
END_COM_MAP()

// ICV3
public:

	/* The get catalog method retrieves a catalog array from the server. The get catalog method only
	 * accesses the server if the catalog is not already resident on the clients computer system.
	 * This allows the VB script page call this method to quickly obtain filtered catalog record information.
	 *
	 * HRESULT GetCatalog
	 *		(
	 *			IN long	puid				Name of catalog to be read from the server.
	 *			IN BSTR bstrServerUrl 		The http://servername/share location for the catalog to be retrieved.
	 *			IN long platformId			The platform id to be used to purne the catalog list.
	 *										This parameter matches the server side OS directory. If this parameter
	 *										is a blank string then the control will determine the OS directory based
	 *										on the detected OS version.
	 *			IN BSTR bstrBrowserLangauge		A String in 0x409 format that specifies the browser locale.
	 *			IN long lFilters			Filters that are to be applied to the retrieved catalog array. This may
	 *										be any of the following:
	 *								WU_ALL_ITEMS			This filter is a sumation of all filters. It will cause
	 *														all items in the catalog to be retrieved, however the
	 *														normal pruning logic will still apply.
	 *								WU_HIDDEN_ITEMS			This filter retrieves only items marked as hidden.
	 *								WU_SELECTED_ITEMS		This filter retrieves selected items.
	 *								WU_NOT_SELECTED_ITEMS	This filter retrieves items that are not currently selected.
	 *								WU_NEW_ITEMS			This filter retrieves items that are marked as new
	 *								WU_POWER_ITEMS			This filter retrieves items that are marked as power user items
	 *								WU_REGISTER_ITEMS		This filter retrieves items that are marked as needing registration before installation.
	 *								WU_COOL_ITEMS			This filter retrieves items that are marked as cool
	 *								WU_EUAL_ITEMS			This filter retrieves items that are marked as having a End user license agreement.
	 *								WU_PATCH_ITEMS			This filter retrieves items that are marked as a patch.
	 *								WU_NO_DEVICE_DRIVERS	This filter will cause CDM device driver records if present
	 *														to not be included in the returned catalog array.
	 *			IN long	lFlags
	 *								WU_NO_SPECIAL_FLAGS		This flag is only valid if used by itself. It is used to
	 *														indicate that no special record processing other than the
	 *														default pruning is to be applied.
	 *								WU_NO_PRUNING			This flag is mainly used for corporate catalog as well as
	 *														internal debugging and testing, it will cause the pruning
	 *														logic to not be applied to the retrieved catalog.
	 *			OUT RETVAL VARIANT *pCatalogArray	A Multi-dimensional VB script array. This array is filled with the
	 *												catalog information upon return. The first dimension is the
	 *												returned index record. The second index is the specific data. See
	 *												the comments section for the layout of this array.
	 *
	 *	This method returns S_OK if the catalog is retrieved or an error code that indicates the reason that
	 *	the catalog could not be obtained.
	 *
	 *	Comments:
	 *
	 *	The first time a catalog is requested from the server it is downloaded to the client machine and
	 *	processed into the global catalog structure. This means that if this method is called to download
	 *	"Catalog one", "Catalog two", "Catalog three" then the returned array will contain all of the entries
	 *	for catalogs one, two and three.
	 *
	 *	The VBScript syntax for accessing this method is different than accessing this method from with a C++
	 *	application. In VB Script the catalog array is returned though the return value and the error return
	 *	can be trapped with an ON ERROR statement. For example, to get retrieve the catalog named Catalog One
	 *	for the Win98 OS, from the server someserver and use browser language English the following script
	 *	syntax would be used:
	 *
	 *		CatalogOne = GetCatalog(1, "http://someserver//V3", 1, "0x409", WU_ALL_ITEMS)
	 *		or
	 *		CatalogOne = GetCatalog(1, "http://someserver//V3", 1, "0x409", WU_ALL_ITEMS)
	 *
	 *		The layout of the returned catalog array is illustrated below:
	 *
	 *		'Inventory Record 1
	 *			array(0, 0)	= NUMBER puid
	 *			array(0, 1)	= STRING Display Text
	 *			array(0, 2)	= STRING Description
	 *			array(0, 3)	= NUMBER Item Status one or more of	GETCATALOG_STATUS_xxxx
	 *			array(0,4)	= NUMBER Download Size in Bytes
	 *			array(0,5)	= NUMBER Download Time in minutes
	 *			array(0,6)	= STRING Uninstall Key
	 *		'Inventory record 2
	 *			array(1,0)	= Number puid
	 */
	STDMETHOD(GetCatalog)
		(
			IN long puidCatalog,
			IN BSTR bstrServerUrl,
			IN long platformId,
			IN BSTR bstrBrowserLangauge,
			IN long lFilters,
			IN long lFlags,
			OUT RETVAL VARIANT *pCatalogArray
		);

	STDMETHOD(GetCatalogHTML)
		(
			IN long puidCatalog,
			IN BSTR bstrServerUrl,
			IN long platformId,
			IN BSTR bstrBrowserLangauge,
			IN long lFilters,
			IN long lFlags,
			OUT RETVAL VARIANT *pCatalogHTML
		);


	/*	The ChangeItemState method returns S_OK if the catalog item's state is successfully changed or
	 *	an error code that indicates the reason that the catalog item's state could not be changed.
	 *	The catalog item must have been previously read with the GetCatalog method. This method only
	 *	changes the item state on the local client it does not change the item on the server.
	 *
	 *	HRESULT ChangeItemState
	 *		(
	 *				IN long puid			Catalog item identifier that uniquely identifies the catalog
	 *										item to be changed. Note: puid's are unique across catalogs.
	 *				IN long lNewItemState	The item's new state. This parameter can be one or more
	 *										of the following:
	 *	ITEM_STATE_HIDE_ITEM
	 *	ITEM_STATE_SHOW_ITEM
	 *	ITEM_STATE_SELECT_ITEM
	 *	ITEM_STATE_UNSELECT_ITEM
	 *
	 */
	STDMETHOD(ChangeItemState)
		(
			IN long	puid,
			IN long lNewItemState
		);


	/*
	 *	The install selected items method installs all of the inventory items that
	 *	have been marked for installation.
	 * 
	 *	HRESULT InstallSelectedItems
	 *		(
	 *			IN BSTR bstrServer,			Server Directory if blank then the server
	 *										used with the catalog was retrieved is used.
	 *			IN long lFlags				May be one of the following:
	 *				WU_NOSPECIAL_FLAGS		This flag is only valid if used by itself. It is used to indicate
	 *										that the default installer should be used.
	 *
	 *				WU_COPYONLY_NO_INSTALL	This flag is used to indicate that the selected packages should
	 *										be copied to the client machine but not installed.
	 *		IN BSTR bstrTempDir				The name of a temporary directory where the install cabs are to
	 *										be copied on the local machine. If this parameter is a NULL string
	 *										then the system uses the local system temporary directory.
	 *										This option is only valid if WU_COPYONLY_NO_INSTALL is specified.
	 *		)
	 *
	 *	This method returns S_OK if all of the selected items were successfully installed. A non 0 return
	 *	indicates that one or more package was not installed successfully. The GetInstallStatus() method
	 *	is used to find out which packages were not installed as well as the reason the install failed.
	 *
	 */
	STDMETHOD(InstallSelectedItems)
		(
			IN BSTR bstrServer,
			IN long lFlags,
			IN BSTR bstrTempDir,
			OUT RETVAL VARIANT *pResultsArray
		);



	/*
	 *	HRESULT GetInstallMetrics
	 *		(
	 *			OUT RETVAL VARIANT *pMetricsArray	A Multi-dimensional VB script array. The first dimension
	 *												is the returned index record. The second index is the specific
	 *												data. See the comments section for this array layout.
	 *		)
	 *
	 * Comments:
	 *
	 *		'Record 1
	 *			array(0, 0)	= NUMBER puid		The identifier for this catalog item.
	 *			array(0,1)	= NUMBER DownloadSize	Total download size of all selected items in bytes.
	 *			array(0,2)	= NUMBER Downloadtime	Total download time for all currently selected items at 28.8 this
	 *												will need to change in the future to take the connection speed into
	 *												account.
	 *
	 *		'Record 2
	 *
	 *	This method returns information about what would happen if the InstallSelectedItems method is called.
	 *
	 *	The VBScript syntax for accessing this method is different than accessing this method from with a C++
	 *	application. In VB Script the results array is returned though the return value and the error return
	 *	can be trapped with an ON ERROR statement. For example, to retrieve the installation metric information
	 *	for the items that will be installed if the InstallSelectedItems method is called the syntax is:
	 *	installMetrics = GetInstallMetrics
	 *
	 */

	STDMETHOD(GetInstallMetrics)
		(
			OUT RETVAL VARIANT *pMetricsArray
		);


	/*
	 * The GetFirstEula method returns a list of puid identifiers and Urls that the EULA page is stored at.
	 * The caller is responsible for retrieving and displaying the EULA.
	 *
	 *	HRESULT GetEula
	 *		(
	 *			OUT RETVAL VARIANT *pEulaArray	A Multi-dimensional VB script array. The first dimension is
	 *											the returned index record. The second index is the specific
	 *											data. See the comments section for this array layout:
	 *		)
	 *
	 *	This method returns S_OK if the Eulas array is successfully retrieved. Note: The returned array
	 *	information is the same order as the array returned from the GetInstallMetrics method.
	 *
	 *	Comments:
	 *		'Record 1
	 *			array(0,0)	= NUMBER eurla number	Number of eurla. This number changes when the eurla
	 *												url changes. This makes it possible for the caller
	 *												to construct a list of items that this eurla applies
	 *												to simply be checking when this field changes value.
	 *			array(0,1)	= NUMBER puid			The identifier for this catalog item.
	 *			array(0,2)	= STRING  url         	Url of eurl page to display for this item. Note: If three
	 *												items have the same url then this field is filled in for
	 *												the first item and blank for the remaining two items.
	 *		'Record 2
	 *
	 *	The VBScript syntax for accessing this method is different than accessing this method from with a
	 *	C++ application. In VB Script the results array is returned though the return value and the error
	 *	return can be trapped with an ON ERROR statement. For example, to retrieve the first applicable
	 *	eurla Installation metric information for the items that will be installed if the InstallSelectedItems
	 *	method is called the syntax is: installMetrics = GetEula
	 */
	STDMETHOD(GetEula)
		(
			OUT RETVAL VARIANT *pEulaArray
		);

	/*
	 * HRESULT GetInstallHistory
	 *		(
	 *			OUT RETVAL VARIANT *pszHistoryArray	A Multi-dimensional VB script array. This array is filled
	 *												with the catalog information upon return. The first dimension
	 *												is the returned index record. The second index is the specific
	 *												data. See the comments section for the layout of this array.
	 *		)
	 *	This returns S_OK if the catalog is retrieved or an error code that indicates the reason that the catalog
	 *	could not be obtained.
	 *
	 *	Comments:
	 *
	 *		The layout of the returned catalog item array is illustrated below:
	 *
	 *		'Inventory Record 1
	 *			array(0, 0)	= NUMBER puid
	 *			array(0, 1)	= STRING Display Text
	 *			array(0, 2)	= STRING Description
	 *			array(0, 3)	= NUMBER Item Status one or more of:
	 *				GETCATALOG_STATUS_HIDDEN
	 *				GETCATALOG_STATUS_SELECTED
	 *				GETCATALOG_STATUS_NEW
	 *				GETCATALOG_STATUS_POWER
	 *				GETCATALOG_STATUS_REGISTRATION
	 *				GETCATALOG_STATUS_COOL
	 *				GETCATALOG_STATUS_PATCH
	 *				GETCATALOG_STATUS_SECTION
	 *				GETCATALOG_STATUS_SUBSECTION
	 *			array(0,4)	= NUMBER Download Size in Bytes
	 *			array(0,5)	= NUMBER Download Time in seconds
	 *			array(0,6)	= STRING Uninstall Key
	 *		'Inventory record 2
	 *			array(1,0)	= Number puid
	 *
	 *	The Install & Uninstall History is handled differently between NT and Win 98 & 95. In the Win 98 OS
	 *	history logging will be to a hidden file on the disk. In the NT OS logging will be to an event log.
	 *	The current History log can be retrieved and formatted into a DHTL template with the GetHistory method
	 *	shown below.
	 *
	 *	For either OS this method will return the install & uninstall history.
	 */
	STDMETHOD(GetInstallHistory)
		(
			OUT RETVAL VARIANT *pHistoryArray
		);


	/*
	 *	HRESULT GetDependencyList
	 *		(
	 *				IN long puid		Catalog item identifier that uniquely identifies the catalog item for which
	 *									dependencies are to be retrieved.
	 *				OUT RETVAL VARIANT *pDependentItemsArray	A Single-dimensional VB script array. This array
	 *															contains a list of puids that are dependent on
	 *															this item.
	 *		)
	 *
	 *	This method returns a list of items that must be installed before the provided item can be installed.
	 *	The item is identified by the puid parameter.
	 */

	STDMETHOD(GetDependencyList)
		(
			IN long puid,
			OUT RETVAL VARIANT *pDependentItemsArray
		);


	/*
	 *	HRESULT GetCatalogItem
	 *		(
	 *			IN long puid,						Catalog item identifier that uniquely identifies the catalog
	 *												item to be retrieved.
	 *			OUT RETVAL VARIANT *pCatalogItem	A Single-dimensional VB script array. This array is filled with
	 *												the requested catalog item's information upon return.
	 *		)
	 *
	 *		This method returns S_OK if the catalog item is successfully retrieved or an error code that
	 *		indicates the reason that the catalog item could not be obtained.
	 *
	 *	Comments:
	 *		A Catalog must have been retrieved with the GetCatalog method before this method will work.
	 *
	 *		The layout of the returned catalog item array is illustrated below:
	 *
	 *			array(0)	= NUMBER puid
	 *			array(1)	= STRING Display Text
	 *			array(2)	= STRING Description
	 *			array(3)	= NUMBER Item Status one or more of:
	 *				GETCATALOG_STATUS_HIDDEN
	 *				GETCATALOG_STATUS_SELECTED
	 *				GETCATALOG_STATUS_NEW
	 *				GETCATALOG_STATUS_POWER
	 *				GETCATALOG_STATUS_REGISTRATION
	 *				GETCATALOG_STATUS_COOL
	 *				GETCATALOG_STATUS_PATCH
	 *				GETCATALOG_STATUS_SECTION
	 *				GETCATALOG_STATUS_SUBSECTION
	 *			array(4)	= NUMBER Download Size in Bytes
	 *			array(5)	= NUMBER Download Time in seconds
	 *			array(6)	= STRING Uninstall Key
	 *			array(7)	= STRING catalog name containing this item.
	 *			array(8)	= NUMBER index of catalog item in array returned from GetCatalog method.
	 */
	STDMETHOD(GetCatalogItem)
		(
			IN long puid,
			OUT RETVAL VARIANT *pCatalogItem
		);

	STDMETHOD(RemoveSelectedItems)
		(
			void
		);

	//Returns S_TRUE | S_OK  if catalog is available, S_FALSE if catalog is not available
	//or E_FAIL if an error occurs
	STDMETHOD(IsCatalogAvailable)
		(
			IN long	puidCatalog,	//Name of catalog to be read from the server.
			IN BSTR bstrServerUrl	//The http://servername/share location for the catalog to be retrieved.
		);

	STDMETHOD(FinalizeInstall) (IN long lFlags);


//--------------------------------------------------------------------
//  SetString metods sets strings based on the type
//
//	lType: LOC_STRINGS=0, TEMPLATE_STRINGS=1   
//
//  Following is VBScript sample to call this function
//	
//	Dim Strs
//
//	Strs = Array( _
//	"Download*progress:", _
//	"Download*time*remaining:", _
//	"Install*progress:", _
//	"Cancel*", _
//	"%d KB/%d KB*", _
//	"%d sec*", _
//	"%d min*", _
//	"%d hr %d min*", _
//	"Microsoft*Windows*Update", _
//	"You*must*restart Windows so that installation can finish.", _
//	"Do*you want*to restart now?")
//
//	WUV3IS.SetStrings Strs, 0 
//--------------------------------------------------------------------
	STDMETHOD(SetStrings)(IN VARIANT* vStringsArr, IN long lType);



    /*
     *  HRESULT FixCompatRollbackKey(VARIANT_BOOL *pbRegModified)
     *       
     *          for IE4 machines, detects and removes the "compat" value from the following registry key:
     *  		HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\User Agent\Post Platform
     *          This key is added by IE5 when running in IE4 compatibility mode, but is not removed when
     *          IE5 is uninstalled.
     *          For IE5 machines, this function runs the UpdateToolsURL function.
     *          
     *          ARGUMENTS:  None
     *          OUT PARAMS: A boolean value indicating whether the registry was changed by the function.  Script will
     *                      use this to determine whether restarting the browser is necessary to pick up the change
     *                      and display the correct catalog.
     *          RETURNS:    Always returns S_OK 
     *
     */
     
	STDMETHOD(FixCompatRollbackKey)(OUT RETVAL VARIANT_BOOL *pbRegModified);

    /*
     *  void UpdateToolsURL()
     *          Updates the "Tools\Windows Update" menu item in IE to pass a parameter which allows us to determine
     *          how the user linked to WU.
     *          The Whistler version also updates the Start Menu -->Windows Update link in the registry to pass a parameter there as well.
     *          
     *          
     *          ARGUMENTS:  None
     *          OUT PARAMS: None
     *          RETURNS:    None
     *
     */
    void UpdateToolsURL();
		
	//
	//IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
	
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
	
	//
	//IWUpdateCatalog
	//
	STDMETHOD(WUIsCatalogAvailable)(long puidCatalog,BSTR bstrServerUrl);
	
	STDMETHOD(WUGetCatalog)(long puidCatalog, BSTR bstrServerUrl, long platformId, BSTR bstrBrowserLangauge, CCatalog** ppCatalogArray);
	
	STDMETHOD(WUDownloadItems)(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir);
	
	STDMETHOD(WUInstallItems)(CSelections* pSelections, BSTR bstrServer, BSTR bstrTempDir);
	
	STDMETHOD(WURemoveItems)(CSelections* pSelections);
	
	STDMETHOD(WUCopyInstallHistory)(HISTORYARRAY** ppHistoryArray);
	
	STDMETHOD(WUCopyDependencyList)(long puidItem, long** ppDepPuid);
	
	STDMETHOD(WUProgressDlg)(BOOL bOn);

	STDMETHOD(IsWinUpdDisabled)(OUT RETVAL VARIANT_BOOL *pfDisabled);

	STDMETHOD(IsReady)(OUT RETVAL VARIANT_BOOL* pbYes);

	STDMETHOD(GetContentURL)(OUT RETVAL VARIANT* pURL);

	STDMETHOD(GetReadThisPage)(IN long puid);

	STDMETHOD(GetPrintAllPage)(OUT RETVAL VARIANT* pURL);
	
	//
	// IAutoUpdate interface
	//
	IAUTOUPDATE_METHODS(IMPLEMENTED)


private:
	//Construct and return a catalog in the internal control format.
	CCatalog* ProcessCatalog(
		IN PUID puidCatalog,
		IN BSTR bstrServerUrl,
		IN long platformId,
		IN BSTR bstrBrowserLangauge,
		IN long lFilters,
		IN long lFlags
		);
	
	//This method processes a change in a catalog item's state
	HRESULT ProcessChangeItemState(
		IN long	puid,
		IN long lNewItemState
		);
	
	//Return a two dimensional VARIANT safe array of VARIANTS which holds
	//the returned VBScript catalog representation.
	HRESULT MakeReturnCatalogArray(
		CCatalog *pCatalog,		//Pointer to catalog structure to be converted.
		long	lFilters,		//Filters to apply, see GetCatalog for the actual descriptions.
		long	lFlags,			//Flags that control the amount of information returned in each array record.
		VARIANT *pvaVariant		//pointer to returned safearray.
		);
	
	HRESULT MakeReturnCatalogListArray(
		CCatalog *pCatalog,	//Pointer to catalog structure to be converted.
		long	lFilters,	//Filters to apply, see GetCatalog for the actual descriptions.
		long	lFlags,		//Flags that control the amount of information returned in each array record.
		VARIANT *pvaVariant	//pointer to returned safearray.
		);
	
	//Return a CATALOG32 structure array of CATALOG32ITEM's which holds
	//the returned C++ catalog representation.
	PCATALOG32 MakeReturnCatalogArray(
		CCatalog *pCatalog,	//Pointer to catalog structure to be converted.
		long	lFilters,	//Filters to apply, see GetCatalog for the actual descriptions.
		long	lFlags		//Flags that control the amount of information returned in each array record.
		);

	void CheckLaunchServer();        

	DWORD m_dwSafety;
	BOOL m_bValidInstance;
	BOOL m_bLaunchServChecked;
private:
	// for IAutoUpdate support
	void InstallItemAU(PINVENTORY_ITEM pItem, PSELECTITEMINFO pinfo);
	void ReadHiddenPuids();
	bool IsPuidHidden(PUID puid);
	void HidePuidAndSave(PUID puid);

	CCatalog* m_pCatalogAU;
	safe_buffer<PUID> m_apuids;
	byte_buffer m_abHiddenPuids;

};

HRESULT DownloadReadThis(PINVENTORY_ITEM pItem);
HRESULT DownloadCommonRTFFiles(BOOL bPrintAll, LPTSTR pszPrintAllFN);
bool CleanupReadThis();
bool IsArabicOrHebrew();
bool DownloadToBuffer( IN LPCTSTR szPath, IN CWUDownload *pDownload, IN CDiamond *pDiamond, OUT byte_buffer& bufOut);

#endif //__CV3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\history.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    history.cpp
//
//  Purpose: History log
//
//=======================================================================

#include "history.h"

#define DATE_RTLREADING           0x00000020  // add marks for right to left reading order layout


extern CState g_v3state;   //defined in CV3.CPP

static void CheckMigrateV2Log();
static void EscapeSep(LPSTR pszStr, BOOL bEscape);

//This function reads and returns the clients installation history. This history is
//returned as an array of History structures. The caller is responsible for passing
//in a reference to the the History Variable array.
void ReadHistory(
	Varray<HISTORYSTRUCT> &History,	//Returned History array.
	int &iTotalItems				//total number of items returned in history array.
	)
{
	USES_CONVERSION;

	const int browserLocale = LOCALE_USER_DEFAULT;

	HISTORYSTRUCT his;
	char szLineType[32];
	char szTemp[32];
	SYSTEMTIME st;

	// check to see if we have to migrate V2 log
	CheckMigrateV2Log();

	iTotalItems = 0;

	g_v3state.AppLog().StartReading();

	while (g_v3state.AppLog().ReadLine())
	{
		ZeroMemory(&his, sizeof(his));

		// get line type (first field)
		g_v3state.AppLog().CopyNextField(szLineType, sizeof(szLineType));

		if (_stricmp(szLineType, LOG_PSS) == 0)
		{
			//
			// skip this line since it is only meant for PSS
			//
			continue;
		}
		else if (_stricmp(szLineType, LOG_V2) == 0)
		{
			//
			// line was migrated from V2
			//
			his.bV2 = TRUE;
			g_v3state.AppLog().CopyNextField(his.szDate, sizeof(his.szDate));
			g_v3state.AppLog().CopyNextField(his.szTime, sizeof(his.szTime));
			g_v3state.AppLog().CopyNextField(his.szTitle, sizeof(his.szTitle));
			EscapeSep(his.szTitle, FALSE);
		}
		else if ((_stricmp(szLineType, LOG_V3CAT) == 0) || (_stricmp(szLineType, LOG_V3_2) == 0)) 
		{

			//
			// V3 line
			//
			int iV3LineVer = 1;

			if (_stricmp(szLineType, LOG_V3_2) == 0)
			{
				iV3LineVer = 2;
			}

			// puid
			g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));
			his.puid = atoi(szTemp);

			// installed/uninstalled
			g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));
			his.bInstall = (_stricmp(szTemp, LOG_INSTALL) == 0);

			// title
			g_v3state.AppLog().CopyNextField(his.szTitle, sizeof(his.szTitle));
			EscapeSep(his.szTitle, FALSE);
			
			// version
			g_v3state.AppLog().CopyNextField(his.szVersion, sizeof(his.szVersion));

			// date and time
			if (iV3LineVer == 1)
			{
				// V3 Beta had two fields for date and time, we simly read these fields

				// date
				g_v3state.AppLog().CopyNextField(his.szDate, sizeof(his.szDate));

				// time
				g_v3state.AppLog().CopyNextField(his.szTime, sizeof(his.szTime));
			}
			else 
			{
				// read the timestamp and convert

				// timestamp
				g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));

				// if time stamp is a valid format, convert and populate the structure
				// if its not we will have blank values since we initialized the structure to zero
				if (ParseTimeStamp(szTemp, &st))
				{
					TCHAR szTmp[256];
					GetDateFormat(browserLocale, DATE_LONGDATE, &st, NULL, szTmp, sizeof(szTmp)/sizeof(szTmp[0]));
					strcpy(his.szDate, T2A(szTmp));
					GetTimeFormat(browserLocale, LOCALE_NOUSEROVERRIDE, &st, NULL, szTmp, sizeof(szTmp)/sizeof(szTmp[0]));
					strcpy(his.szTime, T2A(szTmp));
				}
				
			}

			// record type
			g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));
			his.RecType = (BYTE)atoi(szTemp);

			// result
			g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));
			if (_stricmp(szTemp, LOG_SUCCESS) == 0)
			{
				his.bResult = OPERATION_SUCCESS;
			}
			else if (_stricmp(szTemp, LOG_STARTED) == 0)
			{
				his.bResult = OPERATION_STARTED;
			}
			else
			{
				his.bResult = OPERATION_ERROR;
			}

			
			// error code
			g_v3state.AppLog().CopyNextField(szTemp, sizeof(szTemp));
			his.hrError = atoh(szTemp);
		}

		History[iTotalItems] = his;
		iTotalItems++;

	}
	g_v3state.AppLog().StopReading();
}



void UpdateHistory(
	PSELECTITEMINFO	pInfo,	//Pointer to selected item information.
	int iTotalItems,		//Total selected items
	BOOL bInstall			//TRUE for InstallSelectedItems, FALSE for RemoveSelectedItems.
	)
{
	PINVENTORY_ITEM	pItem = NULL;
	PWU_VARIABLE_FIELD pvTitle;
	PWU_VARIABLE_FIELD pvDriverVer;
	char szLine[1024];
	char szTemp[256];
	BOOL bSuccess;
	SYSTEMTIME* pst;
	BOOL bPSS;
	BOOL bItem = FALSE; // used to check if the function GetCatalogAndItem return value and accordingly to decide pItem

	// check to see if we have to migrate V2 log
	CheckMigrateV2Log();

	for (int i = 0; i < iTotalItems; i++)
	{
		if (pInfo[i].bInstall != bInstall)
			continue;

		if (pInfo[i].iStatus == ITEM_STATUS_SUCCESS || 
			pInfo[i].iStatus == ITEM_STATUS_SUCCESS_REBOOT_REQUIRED || 
			pInfo[i].iStatus == ITEM_STATUS_UNINSTALL_STARTED)
		{
			bSuccess = TRUE;
		}
		else
		{
			bSuccess = FALSE;
		}

		//
		// NTBUG9#161018 PREFIX:dereferencing NULL pointer 'pItem'  - waltw 8/16/00
		//		If GetCatalogAndItem returns FALSE, pItem is invalid. 
		//
		if (bItem = g_v3state.GetCatalogAndItem(pInfo[i].puid, &pItem, NULL))
		{
			// we write hidden dependencies only as PSS entries
                        if(NULL != pItem) // pItem should never be NULL, but just to be anal...
                        {
			    bPSS = pItem->ps->bHidden;
                        }
		}
		else
		{
                        // if GetCatalogAndItem returns False, the pItem is NULL and we shouldn't dereference the pointer
			//continue;
			//Can be continued as the string can be formed with the other elements, only thing requied is to check for validity of pItem before using it
			bPSS = FALSE;
		}

		//
		// start building a line for the log
		//

		// line type
		strcpy(szLine, bPSS ? LOG_PSS : LOG_V3_2);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// puid
		_itoa(pInfo[i].puid, szTemp, 10);
		strcat(szLine, szTemp);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// install/uninstall
		if (pInfo[i].bInstall)
			strcat(szLine, LOG_INSTALL);
		else
			strcat(szLine, LOG_UNINSTALL);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// title
		if (bItem)
		{
			if (pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE))
			{
				WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)(pvTitle->pData), -1, szTemp, sizeof(szTemp), NULL, NULL);
			}
			EscapeSep(szTemp, TRUE);
			strcat(szLine, szTemp);
			strcat(szLine, LOG_FIELD_SEPARATOR);
			
			// version
			szTemp[0] = '\0';
			switch( pItem->recordType )
			{
				case WU_TYPE_ACTIVE_SETUP_RECORD:
					VersionToString(&pItem->pf->a.version, szTemp);
					break;
					
				case WU_TYPE_CDM_RECORD:
				case WU_TYPE_RECORD_TYPE_PRINTER:
					if ((pvDriverVer = pItem->pv->Find(WU_VARIABLE_DRIVERVER)))
						strzncpy(szTemp, (char *)pvDriverVer->pData, sizeof(szTemp));
					break;
			}
			strcat(szLine, szTemp);
			strcat(szLine, LOG_FIELD_SEPARATOR);
		}

		// timestamp
		pst = &(pInfo[i].stDateTime);

		// we expect the date/time format to be (TIMESTAMP_FMT) as follows:
//		01234567890123456789
//		YYYY-MM-DD HH:MM:SS
		sprintf(szTemp, TIMESTAMP_FMT, 
			pst->wYear, pst->wMonth, pst->wDay,
			pst->wHour, pst->wMinute, pst->wSecond);		

		strcat(szLine, szTemp);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		if (bItem)
		{
			// record type
			_itoa(pItem->recordType, szTemp, 10);
			strcat(szLine, szTemp);
			strcat(szLine, LOG_FIELD_SEPARATOR);
		}

		// result
		if (bSuccess)
		{
			if (pInfo[i].iStatus == ITEM_STATUS_UNINSTALL_STARTED)
				strcat(szLine, LOG_STARTED);
			else
				strcat(szLine, LOG_SUCCESS);
		}
		else
		{
			strcat(szLine, LOG_FAIL);
		}
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// hresult
		if (!bSuccess)
		{
			sprintf(szTemp, "%#08x", pInfo[i].hrError);
			strcat(szLine, szTemp);
		}
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// error message
		if (!bSuccess)
		{
			CAppLog::FormatErrMsg(pInfo[i].hrError, szTemp, sizeof(szTemp));
			strcat(szLine, szTemp);
		}
		strcat(szLine, LOG_FIELD_SEPARATOR);


		//
		// write out the log 
		//

		g_v3state.AppLog().Log(szLine);
	}  

}


// This function updates the local client installation history
void UpdateInstallHistory(PSELECTITEMINFO pInfo, int iTotalItems)
{
	UpdateHistory(pInfo, iTotalItems, TRUE);
}


// This function updates the local client removal history
void UpdateRemoveHistory(PSELECTITEMINFO pInfo,	int iTotalItems)
{
	UpdateHistory(pInfo, iTotalItems, FALSE);
}


// migrates V2 log into the V3 log.  This only happens if V3 log does not exist yet
// this is the condition we use to see we are running for the first time.
static void CheckMigrateV2Log()
{
	USES_CONVERSION;

	static BOOL bChecked = FALSE;
	char szBuf[MAX_PATH];
	VARIANT vDate;
	SYSTEMTIME st;

	if (bChecked)
		return;

	bChecked = TRUE;

	if (FileExists(g_v3state.AppLog().GetLogFile()))
	{
		// V3 file exists, we will not migrate V2
		return;
	}

	// build V2 log file name
	TCHAR szFile[MAX_PATH];
	if (! GetWindowsDirectory(szFile, sizeof(szFile) / sizeof(TCHAR)))
	{
		lstrcat(szFile, _T("C:\\Windows"));
	}
	AddBackSlash(szFile);
	lstrcat(szFile, _T("WULog.txt"));

	if (!FileExists(szFile))
	{
		// V2 file does not exists
		return;
	}

	CAppLog V2Log(szFile);
	char szLine[1024];


	V2Log.StartReading();
	while (V2Log.ReadLine())
	{
		// line type
		strcpy(szLine, LOG_V2);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// v2 log starts out with | so we want to skip the first field
		V2Log.CopyNextField(szBuf, sizeof(szBuf));

		// date
		V2Log.CopyNextField(szBuf, sizeof(szBuf));
		
		// 
		// fixup date to ensure 4 digit year.  We use OLE to intelligently parse out the date
		// that will most probably be with 2 digit year code.  OLE takes care of making sence
		// out of it.  Then we write the date out with a 4 digit year back to the same buffer
		//
		VariantInit(&vDate);
		vDate.vt = VT_BSTR;
		vDate.bstrVal = SysAllocString(A2OLE(szBuf));
		if SUCCEEDED(VariantChangeType(&vDate, &vDate, VARIANT_NOVALUEPROP, VT_DATE))
		{
			if (VariantTimeToSystemTime(vDate.date, &st))
			{
				sprintf(szBuf, "%4d-%02d-%02d", st.wYear, st.wMonth, st.wDay);
			}
		}

		strcat(szLine, szBuf);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// time
		V2Log.CopyNextField(szBuf, sizeof(szBuf));
		strcat(szLine, szBuf);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// title
		V2Log.CopyNextField(szBuf, sizeof(szBuf));
		EscapeSep(szBuf, TRUE);
		strcat(szLine, szBuf);
		strcat(szLine, LOG_FIELD_SEPARATOR);

		// write out the log line
		g_v3state.AppLog().Log(szLine);

	}
	V2Log.StopReading();


}




//
// we expect the date/time format to be (TIMESTAMP_FMT) as follows:
//		01234567890123456789
//		YYYY-MM-DD HH:MM:SS
//
BOOL ParseTimeStamp(LPCSTR pszDateTime, SYSTEMTIME* ptm)
{
	
	char szBuf[20];
	
	if (strlen(pszDateTime) != 19)
	{
		return FALSE;
	}
	
	strcpy(szBuf, pszDateTime);
	
	// 
	// validate format
	//
	for (int i = 0; i < 19; i++)
	{
		switch (i)
		{
		case 4:
		case 7:
			if (szBuf[i] != '-')
			{
				return FALSE;
			}
			break;
			
		case 10:
			if (szBuf[i] != ' ')
			{
				return FALSE;
			}
			break;
			
		case 13:
		case 16:
			if (szBuf[i] != ':')
			{
				return FALSE;
			}
			break;
			
		default:
			if (szBuf[i] < '0' || pszDateTime[i] > '9')
			{
				return FALSE;
			}
			break;
		}
	}
	
	//
	// get values
	//
	szBuf[4]			= '\0';
	ptm->wYear			= (WORD)atoi(szBuf);
	szBuf[7]			= '\0';
	ptm->wMonth 		= (WORD)atoi(szBuf + 5);
	szBuf[10]			= '\0';
	ptm->wDay			= (WORD)atoi(szBuf + 8);
	szBuf[13]			= '\0';
	ptm->wHour			= (WORD)atoi(szBuf + 11);
	szBuf[16]			= '\0';
	ptm->wMinute		= (WORD)atoi(szBuf + 14);
	ptm->wSecond		= (WORD)atoi(szBuf + 17); 
	ptm->wMilliseconds	= 0;
	ptm->wDayOfWeek     = 0;
	
	//
	// convert to file time and back.  This will calculate the week day as well as tell us
	// if all the fields are set to valid values
	//
	BOOL bRet;	
	FILETIME ft;
	bRet = SystemTimeToFileTime(ptm, &ft);
	if (bRet)
	{
		bRet = FileTimeToSystemTime(&ft, ptm);
	}

	return bRet;
}



static void EscapeSep(LPSTR pszStr, BOOL bEscape)
{
	char szBuf[256];
	char* ps;
	char* pb;

	if (bEscape)
	{
		// escape
		if (strchr(pszStr, '|') != NULL)
		{
			ps = pszStr;
			pb = szBuf;
			for (;;)
			{
				if (*ps == '|')
				{
					*pb++ = '~';
					*pb++ = '1';
				}
				else 
				{
					*pb++ = *ps;
				}
				if (*ps == '\0')
				{
					break;
				}
				ps++;
			}
			strcpy(pszStr, szBuf);
		}
	}
	else
	{
		// unescape
		if (strstr(pszStr, "~1") != NULL)
		{
			ps = pszStr;
			pb = szBuf;
			for (;;)
			{
				if (*ps == '~' && *(ps + 1) == '1')
				{
					*pb++ = '|';
					ps++;
				}
				else 
				{
					*pb++ = *ps;
				}
				if (*ps == '\0')
				{
					break;
				}
				ps++;
			}
			strcpy(pszStr, szBuf);

		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\detect.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    detect.h
//
//  Purpose: Component Detection
//
//  History: 3/9/99   YAsmi    Created
//
//=======================================================================

#ifndef _DETECT_H
#define _DETECT_H
 
#include "stdafx.h"
#include <v3stdlib.h>
#include <inseng.h>


#define COMPONENT_KEY		_T("Software\\Microsoft\\Active Setup\\Installed Components")
#define UNINSTALL_BRANCH	_T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")

#define DEFAULT_LOCALE      _T("en")
#define ISINSTALLED_KEY     _T("IsInstalled")
#define LOCALE_KEY          _T("Locale")
#define VERSION_KEY         _T("Version")
#define BUILD_KEY           _T("Build")
#define QFE_VERSION_KEY     _T("QFEVersion")

#define ISINSTALLED_YES      1
#define ISINSTALLED_NO       0


void ConvertVersionStrToDwords(LPCTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild);
BOOL GetFileVersionDwords(LPCTSTR pszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer);


//
// CComponentDetection class
//
class CComponentDetection : public ICifComponent
{
public:
	enum enumCCValue
	{	
		ccGUID = 0,
		ccVersion = 1,
		ccUninstallKey = 2,
		ccDetectVersion = 3,
		ccRegKeyVersion = 4,
		ccLocale = 5,
		ccQFEVersion = 6,
		ccCustomData = 7,
		
		ccLastValue = 7      
	};

	CComponentDetection();
	virtual ~CComponentDetection();

	BOOL SetValue(enumCCValue cc, LPCSTR pszValue);
	BOOL GetValue(enumCCValue cc, LPSTR pszValue, DWORD dwSize);
	DWORD Detect();
	DWORD GetLastDetectStatus();
	DWORD GetLastDLLReturnValue();
	void GetInstalledVersion(LPDWORD pdwVer, LPDWORD pdwBuild);

	// 
	// ICifComponent interface (not a COM interface)
	//
	STDMETHOD(GetID)(LPSTR pszID, DWORD dwSize);
	STDMETHOD(GetGUID)(LPSTR pszGUID, DWORD dwSize);
	STDMETHOD(GetDescription)(LPSTR pszDesc, DWORD dwSize);
	STDMETHOD(GetDetails)(LPSTR pszDetails, DWORD dwSize);
	STDMETHOD(GetUrl)(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags);
	STDMETHOD(GetFileExtractList)(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize);
	STDMETHOD(GetUrlCheckRange)(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax);
	STDMETHOD(GetCommand)(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, LPSTR pszSwitches, 
						  DWORD dwSwitchSize, LPDWORD pdwType);
	STDMETHOD(GetVersion)(LPDWORD pdwVersion, LPDWORD pdwBuild);
	STDMETHOD(GetLocale)(LPSTR pszLocale, DWORD dwSize);
	STDMETHOD(GetUninstallKey)(LPSTR pszKey, DWORD dwSize);
	STDMETHOD(GetInstalledSize)(LPDWORD pdwWin, LPDWORD pdwApp);
	STDMETHOD_(DWORD, GetDownloadSize)();
	STDMETHOD_(DWORD, GetExtractSize)();
	STDMETHOD(GetSuccessKey)(LPSTR pszKey, DWORD dwSize);
	STDMETHOD(GetProgressKeys)(LPSTR pszProgress, DWORD dwProgSize, 
							   LPSTR pszCancel, DWORD dwCancelSize);
	STDMETHOD(IsActiveSetupAware)();
	STDMETHOD(IsRebootRequired)();
	STDMETHOD(RequiresAdminRights)();
	STDMETHOD_(DWORD, GetPriority)();
	STDMETHOD(GetDependency)(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild);
	STDMETHOD_(DWORD, GetPlatform)();
	STDMETHODIMP_(BOOL) DisableComponent();
	STDMETHOD(GetMode)(UINT uModeNum, LPSTR pszModes, DWORD dwSize);
	STDMETHOD(GetGroup)(LPSTR pszID, DWORD dwSize);
	STDMETHOD(IsUIVisible)();
	STDMETHOD(GetPatchID)(LPSTR pszID, DWORD dwSize);
	STDMETHOD(GetDetVersion)(LPSTR pszDLL, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize);
	STDMETHOD(GetTreatAsOneComponents)(UINT uNum, LPSTR pszID, DWORD dwBuf);
	STDMETHOD(GetCustomData)(LPSTR pszKey, LPSTR pszData, DWORD dwSize);
	STDMETHOD_(DWORD, IsComponentInstalled)();
	STDMETHOD(IsComponentDownloaded)();
	STDMETHOD_(DWORD, IsThisVersionInstalled)(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild);
	STDMETHOD_(DWORD, GetInstallQueueState)();
	STDMETHOD(SetInstallQueueState)(DWORD dwState);
	STDMETHOD_(DWORD, GetActualDownloadSize)();
	STDMETHOD_(DWORD, GetCurrentPriority)();
	STDMETHOD(SetCurrentPriority)(DWORD dwPriority);

protected:
	enum {ccValueCount = (ccLastValue + 1), ccMaxSize = 256, ccDLLCount = 4};

	struct DLLCACHE
	{
		char szDLLName[32];
		HINSTANCE hLib;
		BOOL bUsed;
	};

	LPSTR m_ppValue[ccValueCount];
	DLLCACHE m_pDLLs[ccDLLCount];

	DWORD m_dwCustomDataSize;
	
	DWORD m_dwDetectStatus;
	DWORD m_dwDLLReturnValue;

	DWORD m_dwInstalledVer;
	DWORD m_dwInstalledBuild;

	void ClearValues();
	HRESULT CallDetectDLL(LPCSTR pszDll, LPCSTR pszEntry);
	HINSTANCE CacheLoadLibrary(LPCSTR pszDLLName, LPCTSTR pszDLLFullPath);
};


#endif //_DETECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\detect.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    detect.cpp
//
//  Purpose: Component Detection
//
//  History: 3/9/99   YAsmi    Created
//
//=======================================================================
 
#include "stdafx.h"

#include "detect.h"
#include "debug.h"
#include <wustl.h>
#include "log.h"


LPCSTR ParseField(LPCSTR pszStr, LPSTR pszTokOut, int cTokSize);
BOOL UninstallKeyExists(LPCSTR pszUninstallKey);
static int CompareLocales(LPCSTR pszLoc1, LPCSTR pszLoc2);


//
// CComponentDetection
//
CComponentDetection::CComponentDetection() :
	m_dwDetectStatus(ICI_NOTINITIALIZED),
	m_dwDLLReturnValue(0),
	m_dwInstalledVer(0),
	m_dwInstalledBuild(0)
{
	int i;

	for (i = 0; i < (int)ccValueCount; i++)
	{
		m_ppValue[i] = (char*)malloc(ccMaxSize);
	}

	// custom data has its own size and can be longer than MaxSize
	m_dwCustomDataSize = ccMaxSize;

	for (i = 0; i < (int)ccDLLCount; i++)
	{
		m_pDLLs[i].bUsed = FALSE;
	}

	ClearValues();
}


CComponentDetection::~CComponentDetection()
{
	int i;

	//
	// free cached libraries
	//
	for (i = 0; i < (int)ccDLLCount; i++)
	{
		if (m_pDLLs[i].bUsed)
			FreeLibrary(m_pDLLs[i].hLib);
	}

	for (i = 0; i < (int)ccValueCount; i++)
	{
		free(m_ppValue[i]);
	}
}


void CComponentDetection::ClearValues()
{
	for (int i = 0; i < (int)ccValueCount; i++)
	{
		m_ppValue[i][0] = '\0';
	}
}


BOOL CComponentDetection::SetValue(enumCCValue cc, LPCSTR pszValue)
{
	if (cc <= ccLastValue)
	{
		if (cc == ccCustomData)
		{
			// we allow custom data to be as long as possible so we will reallocate if neccessory
			DWORD l = strlen(pszValue) + 1;

			if (l > m_dwCustomDataSize)
			{
				free(m_ppValue[cc]);
				m_ppValue[cc] = _strdup(pszValue);
				m_dwCustomDataSize = l;
			}
			else
			{
				strncpy(m_ppValue[cc], pszValue, m_dwCustomDataSize);
			}
			return TRUE;

		}
		else
		{
			// we don't copy more than ccMaxSize
			strncpy(m_ppValue[cc], pszValue, ccMaxSize - 1);
			return TRUE;
		}
	}
	return FALSE;
}


BOOL CComponentDetection::GetValue(enumCCValue cc, LPSTR pszValue, DWORD dwSize)
{
	if (cc <= ccLastValue)
	{
		strncpy(pszValue, m_ppValue[cc], dwSize);
		if (pszValue[0] != '\0')
			return TRUE;
	}
	return FALSE;
}


// detects using the current values specified by SetValue 
// clears all the values after detection but we can still retrieve the
// status of last detection using GetLastDetectStatus
//
// Returns the status of detection ICI_INSTALLED etc
DWORD CComponentDetection::Detect()
{
	DWORD dwDetStat;
	
	m_dwDLLReturnValue = 0;
	
	dwDetStat = IsComponentInstalled();

	ClearValues();

	return dwDetStat;
}


DWORD CComponentDetection::GetLastDetectStatus()
{
	return m_dwDetectStatus;
}


DWORD CComponentDetection::GetLastDLLReturnValue()
{
	return m_dwDLLReturnValue;
}

void CComponentDetection::GetInstalledVersion(LPDWORD pdwVer, LPDWORD pdwBuild)
{
	*pdwVer = m_dwInstalledVer;
	*pdwBuild = m_dwInstalledBuild;
}



HINSTANCE CComponentDetection::CacheLoadLibrary(LPCSTR pszDLLName, LPCTSTR pszDLLFullPath)
{
	int iAvailable = -1;
	int iFound = -1;

	//
	// check the cache to see if we already have loaded it
	//
	for (int i = 0; i < (int)ccDLLCount; i++)
	{
		if (m_pDLLs[i].bUsed)
		{
			if (_stricmp(pszDLLName, m_pDLLs[i].szDLLName) == 0)
			{
				iFound = i;
				break;
			}
		}
		else
		{
			if (iAvailable == -1)
				iAvailable = i;
		}
	}

	if (iFound != -1)
	{
		//
		// returned the cached libary instance
		//
		return m_pDLLs[iFound].hLib;
	}
	else
	{
		//
		// load and cache the libary
		//
		if (iAvailable == -1)
		{
			iAvailable = 0;

			if (m_pDLLs[iAvailable].bUsed)
			{
				FreeLibrary(m_pDLLs[iAvailable].hLib);
				m_pDLLs[iAvailable].bUsed = FALSE;
			}
		}
		
		m_pDLLs[iAvailable].hLib = LoadLibrary(pszDLLFullPath);
		
		if (m_pDLLs[iAvailable].hLib != NULL)
		{
			strcpy(m_pDLLs[iAvailable].szDLLName, pszDLLName);
			m_pDLLs[iAvailable].bUsed = TRUE;
		}
        else
        {
		    TRACE_HR(HRESULT_FROM_WIN32(GetLastError()), "Could not load %s (%d)", pszDLLFullPath, HRESULT_FROM_WIN32(GetLastError()));
        }
		
		return m_pDLLs[iAvailable].hLib;
	}
}



HRESULT CComponentDetection::CallDetectDLL(LPCSTR pszDll, LPCSTR pszEntry)
{
	USES_CONVERSION;

	HRESULT hr = E_FAIL;
	HINSTANCE hLib;
	DETECTION_STRUCT Det;
	DWORD dwCifVer, dwCifBuild;
	char szLocale[8];
	char szGUID[128];
	
	m_dwDetectStatus = ICI_NOTINSTALLED;

	GetValue(ccGUID, szGUID, sizeof(szGUID));
	GetLocale(szLocale, sizeof(szLocale));
	GetVersion(&dwCifVer, &dwCifBuild);

	//
	// init the Detection structure
	//
	Det.dwSize = sizeof(DETECTION_STRUCT);
	Det.pdwInstalledVer = &m_dwInstalledVer;
	Det.pdwInstalledBuild = &m_dwInstalledBuild;
	Det.pszLocale = szLocale;
	Det.pszGUID = szGUID;
	Det.dwAskVer = dwCifVer;
	Det.dwAskBuild = dwCifBuild;
	Det.pCifFile = NULL;
	Det.pCifComp = (ICifComponent*)this; 
	
	TCHAR szDllFile[MAX_PATH];
	GetWindowsUpdateDirectory(szDllFile);
	lstrcat(szDllFile, A2T(pszDll));

	//
	// load the detection dll
	//
	hLib = CacheLoadLibrary(pszDll, szDllFile);
	if (hLib)
	{
		DETECTVERSION fpDetVer = (DETECTVERSION)GetProcAddress(hLib, pszEntry);
		if (fpDetVer)
		{
			//
			// call the entry point
			//
			m_dwDLLReturnValue = fpDetVer(&Det);
			
			switch(m_dwDLLReturnValue)
			{
			case DET_NOTINSTALLED:
				m_dwDetectStatus = ICI_NOTINSTALLED;
				break;
				
			case DET_INSTALLED:
				m_dwDetectStatus = ICI_INSTALLED;
				break;
				
			case DET_NEWVERSIONINSTALLED:
				m_dwDetectStatus = ICI_OLDVERSIONAVAILABLE;
				break;
				
			case DET_OLDVERSIONINSTALLED:
				m_dwDetectStatus = ICI_NEWVERSIONAVAILABLE;
				break;
				
			}
			hr = NOERROR;

		}
		else
		{
			TRACE_HR(HRESULT_FROM_WIN32(GetLastError()), "Detection DLL call failed %s %s", pszDll, pszEntry);
		}
	}

	return hr;
}



STDMETHODIMP_(DWORD) CComponentDetection::IsComponentInstalled()
{
	USES_CONVERSION;

	char szDllName[32];
	char szDllEntry[32];
	DWORD dwUnused;
	DWORD dwIsInstalled;
	char szGUID[128];
	HKEY hComponentKey = NULL;
	
	m_dwDetectStatus = ICI_NOTINSTALLED;
	
	//
	// if we need to call detection dll, call it
	//
	if (SUCCEEDED(GetDetVersion(szDllName, sizeof(szDllName), szDllEntry, sizeof(szDllEntry))))
	{
		if (SUCCEEDED(CallDetectDLL(szDllName, szDllEntry)))
		{
			if (m_dwDetectStatus == ICI_OLDVERSIONAVAILABLE)
				m_dwDetectStatus = ICI_INSTALLED;
			return m_dwDetectStatus;
		}
	}

	//
	// build GUID registry key
	//
	GetValue(ccGUID, szGUID, sizeof(szGUID));

	TCHAR szKeyName[MAX_PATH];
	lstrcpy(szKeyName, COMPONENT_KEY);
	lstrcat(szKeyName, _T("\\"));
	lstrcat(szKeyName, A2T(szGUID));
	
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hComponentKey) == ERROR_SUCCESS)
	{
		//
		// first check for the IsInstalled valuename
		// if the valuename is there AND equals zero, we say not installed.
		// otherwise continue.
		//
		// NOTE: We default to ISINSTALLED_YES if valuename not present to be Back-compatible
		//
		dwUnused = sizeof(dwIsInstalled);
		if (RegQueryValueEx(hComponentKey, ISINSTALLED_KEY, 0, NULL, (LPBYTE) (&dwIsInstalled), &dwUnused) != ERROR_SUCCESS)
			dwIsInstalled = ISINSTALLED_YES;
		
		if (dwIsInstalled == ISINSTALLED_YES)
		{
			// 
			// next check for a locale match (no locale entry uses default)
			//
			DWORD dwType;
			TCHAR szRegLocale[8];
			
			dwUnused = sizeof(szRegLocale);
			if (RegQueryValueEx(hComponentKey, LOCALE_KEY, 0, NULL, (LPBYTE)szRegLocale, &dwUnused) != ERROR_SUCCESS)
				lstrcpy(szRegLocale, DEFAULT_LOCALE);
			
			char szAskLocale[8];
			GetValue(ccLocale, szAskLocale, sizeof(szAskLocale));

			if (CompareLocales(T2A(szRegLocale), szAskLocale) == 0)
			{
				// 
				// locales match so go check the QFEversio, version in that order
				//
				BOOL bVersionFound = FALSE;
				TCHAR szRegVer[128];
				DWORD dwCifVer, dwCifBuild;
				
				dwUnused = sizeof(szRegVer);
				bVersionFound = (RegQueryValueEx(hComponentKey, QFE_VERSION_KEY, 0, &dwType, (LPBYTE)szRegVer, &dwUnused) == ERROR_SUCCESS);
				
				if (!bVersionFound)
				{
					dwUnused = sizeof(szRegVer);
					bVersionFound = (RegQueryValueEx(hComponentKey, VERSION_KEY, 0, &dwType, (LPBYTE)szRegVer, &dwUnused) == ERROR_SUCCESS);
				}
				
				if (bVersionFound)
				{
					if (dwType == REG_SZ)
					{
						ConvertVersionStrToDwords(szRegVer, &m_dwInstalledVer, &m_dwInstalledBuild);
						
						GetVersion(&dwCifVer, &dwCifBuild);
						
						if ((m_dwInstalledVer >  dwCifVer) ||
							((m_dwInstalledVer == dwCifVer) && (m_dwInstalledBuild >= dwCifBuild)))
						{
							m_dwDetectStatus = ICI_INSTALLED;
						}
						else
						{
							m_dwDetectStatus = ICI_NEWVERSIONAVAILABLE;
						}
					}
					else
					{
						// if a string field is not found assume we have a newer version
						m_dwDetectStatus = ICI_NEWVERSIONAVAILABLE;
					}

				} //version found

			} //locales match

		} // installed key 
	}
	
	if (hComponentKey)
		RegCloseKey(hComponentKey);
	
	// 
	// we think its installed, now try to verify using uninstall key
	//
	if (m_dwDetectStatus != ICI_NOTINSTALLED)
	{
		char szUninstallKey[ccMaxSize];
		
		if (GetValue(ccUninstallKey, szUninstallKey, sizeof(szUninstallKey)))
		{
			if (!UninstallKeyExists(szUninstallKey))
			{	
				m_dwDetectStatus = ICI_NOTINSTALLED;
			}
		}
	}
	return m_dwDetectStatus;
}


STDMETHODIMP CComponentDetection::GetDetVersion(LPSTR pszDll, DWORD dwdllSize, LPSTR pszEntry, DWORD dwentSize)
{
	char szBuf[ccMaxSize];
	
	if (pszDll && pszEntry)
		*pszDll = *pszEntry = '\0';
	else
		return E_FAIL;
	
	if (GetValue(ccDetectVersion, szBuf, sizeof(szBuf)))
	{
		LPCSTR pszParse = szBuf;
		pszParse = ParseField(pszParse, pszDll, dwdllSize);
		pszParse = ParseField(pszParse, pszEntry, dwentSize);
	}
	if (pszDll[0] == '\0' || pszEntry[0] == '\0')
		return E_FAIL;
	else
		return NOERROR;
}


STDMETHODIMP CComponentDetection::GetCustomData(LPSTR pszKey, LPSTR pszData, DWORD dwSize)
{
	USES_CONVERSION;

	if (_stricmp(pszKey, "DetectVersion") == 0)
	{
		strncpy(pszData, m_ppValue[ccDetectVersion], dwSize);
		return NOERROR;
	}
	char szKeyName[128];
	LPCSTR pCus = m_ppValue[ccCustomData];
	LPCSTR pBeg = pCus;
	LPCSTR pEq;
	
	strcpy(szKeyName, "_");
	strcat(szKeyName, pszKey);

	// look for the _ key name
	pBeg = stristr(pBeg, szKeyName);
	while (pBeg != NULL)
	{
		// we found a match ensure that its at the begining of a line
		if ((pBeg == pCus) || (*(pBeg - 1) == '\n'))
		{
			// point to equal sign
			pEq = pBeg + strlen(szKeyName);
			
			// skip spaces
			while (*pEq == ' ')
				pEq++;

			if (*pEq == '=')
			{
				// skip the equal sign
				pEq++;
				
				// copy the value into pszData
				LPSTR p = pszData;
				int i = dwSize - 1;
				while ((*pEq != '\n') && (i > 0))
				{
					*p++ = *pEq++;
					i--;
				}
				*p = '\0';


				TRACE("Detect GetCustomData %s returns %s", A2T(pszKey), A2T(pszData));
				return NOERROR;
			}
		}  // not the begining of the line
	}

	TRACE("Detect GetCustomData %s not found", A2T(pszKey));
	return E_FAIL;

}


STDMETHODIMP CComponentDetection::GetVersion(LPDWORD pdwVersion, LPDWORD pdwBuild)
{
	USES_CONVERSION;
	char szBuf[ccMaxSize];
	
	if (GetValue(ccVersion, szBuf, sizeof(szBuf)))
	{
		ConvertVersionStrToDwords(A2T(szBuf), pdwVersion, pdwBuild);
		return NOERROR;
	}
	else
		return E_FAIL;
}


STDMETHODIMP CComponentDetection::GetGUID(LPSTR pszGUID, DWORD dwSize)
{
	if (GetValue(ccGUID, pszGUID, dwSize))
		return NOERROR;
	else
		return E_FAIL;
}

STDMETHODIMP CComponentDetection::GetLocale(LPSTR pszLocale, DWORD dwSize)
{
	if (GetValue(ccLocale, pszLocale, dwSize))
		return NOERROR;
	else
		return E_FAIL;
}

STDMETHODIMP CComponentDetection::GetUninstallKey(LPSTR pszKey, DWORD dwSize)
{
	if (GetValue(ccUninstallKey, pszKey, dwSize))
		return NOERROR;
	else
		return E_FAIL;
}


STDMETHODIMP CComponentDetection::GetID(LPSTR pszID, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetDescription(LPSTR pszDesc, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetDetails(LPSTR pszDetails, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetUrl(UINT uUrlNum, LPSTR pszUrl, DWORD dwSize, LPDWORD pdwUrlFlags)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetFileExtractList(UINT uUrlNum, LPSTR pszExtract, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetUrlCheckRange(UINT uUrlNum, LPDWORD pdwMin, LPDWORD pdwMax)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetCommand(UINT uCmdNum, LPSTR pszCmd, DWORD dwCmdSize, 
											 LPSTR pszSwitches, DWORD dwSwitchSize, LPDWORD pdwType)
{
	return E_NOTIMPL;
}


STDMETHODIMP CComponentDetection::GetInstalledSize(LPDWORD pdwWin, LPDWORD pdwApp)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetDownloadSize()
{
	return E_NOTIMPL;
}	

STDMETHODIMP_(DWORD) CComponentDetection::GetExtractSize()
{
	return E_NOTIMPL;
}	

STDMETHODIMP CComponentDetection::GetSuccessKey(LPSTR pszKey, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetProgressKeys(LPSTR pszProgress, DWORD dwProgSize, LPSTR pszCancel, DWORD dwCancelSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::IsActiveSetupAware()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::IsRebootRequired()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::RequiresAdminRights()
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetPriority()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetDependency(UINT uDepNum, LPSTR pszID, DWORD dwBuf, char *pchType, LPDWORD pdwVer, LPDWORD pdwBuild)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetPlatform()
{
	return E_NOTIMPL;
}

STDMETHODIMP_(BOOL) CComponentDetection::DisableComponent()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetMode(UINT uModeNum, LPSTR pszMode, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetGroup(LPSTR pszID, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::IsUIVisible()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetPatchID(LPSTR pszID, DWORD dwSize)
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::GetTreatAsOneComponents(UINT uNum, LPSTR pszID, DWORD dwBuf)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetCurrentPriority()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::SetCurrentPriority(DWORD dwPriority)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetActualDownloadSize()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::IsComponentDownloaded()
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::IsThisVersionInstalled(DWORD dwAskVer, DWORD dwAskBld, LPDWORD pdwVersion, LPDWORD pdwBuild)
{
	return E_NOTIMPL;
}

STDMETHODIMP_(DWORD) CComponentDetection::GetInstallQueueState()
{
	return E_NOTIMPL;
}

STDMETHODIMP CComponentDetection::SetInstallQueueState(DWORD dwState)
{
	return E_NOTIMPL;
}


LPCSTR ParseField(LPCSTR pszStr, LPSTR pszTokOut, int cTokSize)
{
	LPCSTR pszRetVal = NULL;
	LPSTR p;
	LPSTR p2;

	if (pszStr == NULL || *pszStr == '\0')
	{
		pszTokOut[0] = '\0';
		return NULL;
	}

	// look for a comma separator
	p = strstr(pszStr, ",");
	if (p != NULL)
	{
		int l = p - pszStr;
		if (l >= cTokSize)
			l = cTokSize - 1;

		strncpy(pszTokOut, pszStr, l);
		pszTokOut[l] = '\0';		
		pszRetVal = p + 1;
	}
	else
	{
		strncpy(pszTokOut, pszStr, cTokSize - 1);
	}

	//strip spaces
	p = pszTokOut;
	p2 = pszTokOut;
	while (*p2)
	{
		if (*p2 != ' ')
			*p++ = *p2++;
		else
			p2++;
	}
	*p = '\0';

	return pszRetVal;
}


static int CompareLocales(LPCSTR pszLoc1, LPCSTR pszLoc2)
{
   if (pszLoc1[0] == '*' || pszLoc2[0] == '*')
      return 0;
   else
      return _stricmp(pszLoc1, pszLoc2);
}


void ConvertVersionStrToDwords(LPCTSTR pszVer, LPDWORD pdwVer, LPDWORD pdwBuild)
{
	USES_CONVERSION;

	DWORD dwTemp1,dwTemp2;
	LPCSTR pszParse = T2A(pszVer);
	char szBuf[20];

	pszParse = ParseField(pszParse, szBuf, sizeof(szBuf));
	dwTemp1 = atoi(szBuf);
	pszParse = ParseField(pszParse, szBuf, sizeof(szBuf));
	dwTemp2 = atoi(szBuf);

	*pdwVer = (dwTemp1 << 16) + dwTemp2;

	pszParse = ParseField(pszParse, szBuf, sizeof(szBuf));
	dwTemp1 = atoi(szBuf);
	pszParse = ParseField(pszParse, szBuf, sizeof(szBuf));
	dwTemp2 = atoi(szBuf);

	*pdwBuild = (dwTemp1 << 16) + dwTemp2;
}


BOOL UninstallKeyExists(LPCSTR pszUninstallKey)
{
	USES_CONVERSION;

	HKEY hUninstallKey = NULL;
	TCHAR szUninstallKey[MAX_PATH];
	
	if (!pszUninstallKey)	 //if the pointer is NULL, assume installed
		return TRUE;
	
	lstrcpy(szUninstallKey, UNINSTALL_BRANCH);
	lstrcat(szUninstallKey, _T("\\"));
	lstrcat(szUninstallKey, A2T(pszUninstallKey));
	
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUninstallKey, 0, KEY_READ, &hUninstallKey) == ERROR_SUCCESS)
	{
		RegCloseKey(hUninstallKey);
		return TRUE;
	}
	else
		return FALSE;
}


//reterives file version
BOOL GetFileVersionDwords(LPCTSTR pszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer)
{
	BOOL bRetVal = FALSE;
	DWORD dwHandle;
	DWORD dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)pszFilename, &dwHandle);
	if (dwVerInfoSize)
	{
		LPVOID lpBuffer = LocalAlloc(LPTR, dwVerInfoSize);
		if (lpBuffer)
		{
			// Read version stamping info
			if (GetFileVersionInfo((LPTSTR)pszFilename, dwHandle, dwVerInfoSize, lpBuffer))
			{
				// Get the value for Translation
				UINT uiSize;
				VS_FIXEDFILEINFO* lpVSFixedFileInfo;

				if (VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize))
				{
					*pdwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
					*pdwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
					bRetVal = TRUE;
				}
			}
			LocalFree(lpBuffer);
		}
	}

	if (!bRetVal)
	{
		*pdwMSVer = *pdwLSVer = 0L;
	}
	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\history.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    history.h
//
//  Purpose: History log
//
//=======================================================================
 
#ifndef _HISTORY_H
#define _HISTORY_H


#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>
#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES
#include <cstate.h>
#include "CV3.h"


#define HISTORY_FILENAME	_T("wuhistv3.log")	 // created in WindowsUpdate directory

//
// Log line types
//
#define LOG_V2				"V2"             // line format for items migrated from V2
#define LOG_V3CAT			"V3CAT"			 // V3 Beta format (version 1)
#define LOG_V3_2			"V3_2"			 // V3 log line format (version 2)
#define LOG_PSS				"PSS"			 // Entry for PSS

// LOG_V2 format
//    V2|DATE|TIME|LOGSTRING|
//
// LOG_V3CAT format
//    V3CAT|PUID|OPERATION|TITLE|VERSION|DATESTRING|TIMESTRING|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_V3_2 format
//    V3_2|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_PSS format
//    PSS|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//

//
// operation type
//
#define LOG_INSTALL         "INSTALL"
#define LOG_UNINSTALL       "UNINSTALL"

//
// result
//
#define LOG_SUCCESS         "SUCCESS"
#define LOG_FAIL            "FAIL"
#define LOG_STARTED			"STARTED"      // started but reboot was required

//
// print format for timestamp
//
#define TIMESTAMP_FMT	"%4d-%02d-%02d %02d:%02d:%02d"


void ReadHistory(Varray<HISTORYSTRUCT>& History, int &iTotalItems);
void UpdateInstallHistory(PSELECTITEMINFO pInfo, int iTotalItems);
void UpdateRemoveHistory(PSELECTITEMINFO pInfo, int iTotalItems);

BOOL ParseTimeStamp(LPCSTR pszDateTime, SYSTEMTIME* ptm);

 
#endif //_HISTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\install.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    install.h
//
//  Purpose: Install/uninstall components
//
//======================================================================= 

#ifndef _INSTALL_H
#define _INSTALL_H

#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>
#include <initguid.h>
#include <inseng.h>
#include <winspool.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include <osdet.h>
#include "printers.h"
#include "progress.h"
//#include "trust.h"
#include "history.h"
#include "detect.h"
#include "callback.h"
#include "log.h"
#include "locstr.h"


#define FILEVERINI_FN		_T("FileVer.INI")    // contains version information

// 
// URLPING status codes (cannot contain spaces)
//
const TCHAR URLPING_CANCELED[] =	_T("DLOAD_CANCEL");
const TCHAR URLPING_FAILED[] =		_T("DLOAD_FAILURE");
const TCHAR URLPING_SUCCESS[] =	_T("DLOAD_SUCCESS");

const TCHAR URLPING_INSTALL_FAILED[] =		_T("INSTALL_FAILURE");
const TCHAR URLPING_INSTALL_SUCCESS[] =		_T("INSTALL_SUCCESS");



typedef struct _INSTALLINFOSTRUCT
{
	PINVENTORY_ITEM	pItem;			// inventory item for this record
	CCatalog*		pCatalog;		// catalog pointer for this item
	CWUDownload*	pdl;			// CabPool download object for this item
	BOOL			bServerNew;		// TRUE if this is a new download class, FALSE otherwise
	PSELECTITEMINFO	pInfo;			// pointer to the the selected item
	int				iSelIndex;		// selection index
	DWORD			dwLocaleID;
	DWORD			dwPlatform;
	BOOL			bHistoryWritten;
	BOOL			bDownloaded;
	CWUDownload*    pdlRoot;		// download object for this item which points to the content root
	PINVENTORY_ITEM pTopLevelItem;  // contains NULL or a pointer to top level item of a dependency
} INSTALLINFOSTRUCT, *PINSTALLINFOSTRUCT;


void InstallActiveSetupItem(LPCTSTR szLocalDir, LPCTSTR pszCifFile, PSELECTITEMINFO pStatusInfo, IWUProgress* pProgress);
HRESULT UninstallActiveSetupItem(LPCTSTR pszUninstallKey);    
HRESULT GetUninstallCmdFromKey(LPCSTR pszUninstallKey, LPSTR pszCmdValue);

void InstallDriverItem(LPCTSTR szLocalDir, BOOL bWindowsNT, LPCTSTR pszTitle, PINVENTORY_ITEM pItem, PSELECTITEMINFO pStatusInfo);
HRESULT UninstallDriverItem(PINVENTORY_ITEM pItem, PSELECTITEMINFO pStatusInfo);

void InstallPrinterItem(LPCTSTR pszDriverName, LPCTSTR pszInstallFolder, LPCTSTR pszArchitecture);

void CheckDllsToJit(LPCTSTR pszServer);

void URLPingReport(PINVENTORY_ITEM pItem, CCatalog* pCatalog, PSELECTITEMINFO pSelectItem, LPCTSTR pszStatus);


#endif // _INSTALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\printers.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   printers.cpp
//
//  Owner:  YanL
//
//  Description:
//
//      Printing support
//
//
//=======================================================================

#include "stdafx.h"

#include <winspool.h>
#include <malloc.h>
#include <shlwapi.h>

#include <wustl.h>
#include <wuv3.h>
#include <bucket.h>
#define LOGGING_LEVEL 1
#include <log.h>
#include "printers.h"
#include <winsprlp.h>	// private header containing EPD_ALL_LOCAL_AND_CLUSTER define

/*** CPrinterDriverInfoArray::CPrinterDriverInfoArray 
 *		Does all the work on constructing array of IDs for all available
 *		printer/environment combinations
 */
CPrinterDriverInfoArray::CPrinterDriverInfoArray() : m_dwNumDrivers(0)
{
	LOG_block("CPrinterDriverInfoArray::CPrinterDriverInfoArray");
	// Only works on NT 5 and Millennium
	bool fNT;
	OSVERSIONINFO	osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId && 4 == osvi.dwMajorVersion && 90 == osvi.dwMinorVersion)
	{
		// Millennium
		fNT = false;
	}
	else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && 5 == osvi.dwMajorVersion)
	{
		// W2K
		fNT = true;
	}
	else
	{
		LOG_error("ERROR_INVALID_FUNCTION");
		SetLastError(ERROR_INVALID_FUNCTION);
		return;
	}
	LPTSTR pszEnvironment = fNT ? EPD_ALL_LOCAL_AND_CLUSTER : NULL;

	// Get current processor architecture
	SYSTEM_INFO	si;
	GetSystemInfo(&si);
	m_wCurArchitecture = si.wProcessorArchitecture;

    DWORD dwNumDrivers = 0;
    DWORD dwBytesNeeded = 0;
    EnumPrinterDrivers(NULL, pszEnvironment, 6, NULL, 0, &dwBytesNeeded, &dwNumDrivers);
	if (0 == dwBytesNeeded)
	{
		LOG_out("No printers");
		return; // No printers
	}

    // reserve memory for the data
	m_bufInfo.resize(dwBytesNeeded);
	if (!m_bufInfo.valid())
		return;

    // get driver info
	if (!EnumPrinterDrivers(NULL, pszEnvironment, 6, m_bufInfo, dwBytesNeeded, &dwBytesNeeded, &dwNumDrivers))
	{
		LOG_error("Fail to get printer drivers");
		return;
	}
	LOG_out("%d drivers found", dwNumDrivers);
	m_dwNumDrivers = dwNumDrivers;
}

LPDRIVER_INFO_6 CPrinterDriverInfoArray::GetDriverInfo(DWORD dwDriverIdx) 
{ 
	if (m_dwNumDrivers <= dwDriverIdx)
		return NULL;
	LPDRIVER_INFO_6 pinfo = (LPDRIVER_INFO_6)(LPBYTE)m_bufInfo;
	return &pinfo[dwDriverIdx]; 
}

static const struct SEnv {
	LPCTSTR szEnv;
	LPCTSTR szEnvID;
	WORD wArchitecture;
	LPCTSTR szArchtecture;
} asEnv[] = {
	_T("Windows NT x86"),		PRINT_ENVIRONMENT_INTEL,	PROCESSOR_ARCHITECTURE_INTEL,  _T("Intel"),
	_T("Windows NT Alpha_AXP"),	PRINT_ENVIRONMENT_ALPHA,	PROCESSOR_ARCHITECTURE_ALPHA,  _T("Alpha"),
	_T("Windows 4.0"),			PRINT_ENVIRONMENT_INTEL,	PROCESSOR_ARCHITECTURE_INTEL,  _T("Intel"),
};

typedef const SEnv * PCENV;

static PCENV GetEnv(LPDRIVER_INFO_6 pinfo)
{
	if (NULL == pinfo->pEnvironment || 0 == pinfo->pEnvironment[0]) 
		return NULL;
	for (int iEnv = 0; iEnv < sizeOfArray(asEnv); iEnv ++)
	{
		if (0 == lstrcmpi(asEnv[iEnv].szEnv, pinfo->pEnvironment))
			return &asEnv[iEnv];
	}
	return NULL;
}

LPCTSTR CPrinterDriverInfoArray::GetArchitecture(LPDRIVER_INFO_6 pinfo)
{
	PCENV penv = GetEnv(pinfo);
	if (NULL == penv)
		return NULL;
	return penv->szArchtecture;
}

bool CPrinterDriverInfoArray::GetHardwareID(LPDRIVER_INFO_6 pinfo, tchar_buffer& bufHardwareID)
{
	LOG_block("CPrinterDriverInfoArray::GetHardwareID");
	if (NULL == pinfo->pszHardwareID || 0 == pinfo->pszHardwareID[0])
	{
		LOG_error("printer doesn't have Hardware ID");
		return false;
	}
	if (NULL == pinfo->pName || 0 == pinfo->pName[0]) 
	{
		LOG_error("printer %s doesn't have a name", pinfo->pszHardwareID);
		return false;
	}
	PCENV penv = GetEnv(pinfo);
	if (NULL == penv)
	{
		LOG_error("printer %s doesn't have a environment", pinfo->pszHardwareID);
		return false;
	}

	// We need this driver - make shure that id is correct
	if (penv->wArchitecture == m_wCurArchitecture)
	{
		// reserve memory for the data
		bufHardwareID.resize(lstrlen(pinfo->pszHardwareID) + 1);
		if (!bufHardwareID.valid())
			return false;
		lstrcpy(bufHardwareID, pinfo->pszHardwareID);
	}
	else
	{
		// reserve memory for the data
		bufHardwareID.resize(lstrlen(penv->szEnvID) + lstrlen(pinfo->pszHardwareID) + 1);
		if (!bufHardwareID.valid())
			return false;
		lstrcpy(bufHardwareID, penv->szEnvID);
		lstrcat(bufHardwareID, pinfo->pszHardwareID);
	}
//	#ifdef _WUV3TEST
		LPCTSTR szCorrectID = bufHardwareID;
		SYSTEMTIME st;
 		FileTimeToSystemTime(&(pinfo->ftDriverDate), &st);
		LOG_out("%s \t %s \t %2d/%02d/%04d", pinfo->pName, szCorrectID, (int)st.wMonth, (int)st.wDay, (int)st.wYear);
//	#endif
	return true;
}


/*** InstallPrinterDriver - 
 *
 */
DWORD InstallPrinterDriver(
	IN LPCTSTR szDriverName,		// Printer driver model name
	IN LPCTSTR szInstallFolder,
	IN LPCTSTR szArchitecture
	)
{
	USES_CONVERSION;

	LOG_block("InstallPrinterDriver");
	LOG_out("szDriverName = %s, szInstallFolder = %s, szArchitecture = %s", szDriverName, szInstallFolder, szArchitecture);
	TCHAR szFileName[MAX_PATH];

	/*find .inf*/
	lstrcpy(szFileName, szInstallFolder);
	PathAppend(szFileName, TEXT("*.inf"));
	WIN32_FIND_DATA ffd;
	auto_hfindfile hfind = FindFirstFile(szFileName, &ffd);
	return_error_if_false(hfind.valid());
	
	//construct .inf
	lstrcpy(szFileName, szInstallFolder);
	PathAppend(szFileName, ffd.cFileName);
	
	DWORD dwError;
	/*** printui.h access (from NT sources)
	 *   We cannot include printui.h couse printui.dll compliled in UNICODE and we are in MBCS
	 */
	typedef DWORD (*PFN_PrintUIEntryW)(
		IN HWND        hwnd,
		IN HINSTANCE   hInstance,
		IN LPCWSTR     pszCmdLine,
		IN UINT        nCmdShow
		);

	const TCHAR szCmdLineFormat[] = _T("/ia /U /m \"%s\" /h \"%s\" /v \"Windows 2000\" /f \"%s\" /q");
	tchar_buffer bufCmd(lstrlen(szCmdLineFormat) + lstrlen(szDriverName) + lstrlen(szArchitecture) + lstrlen(szFileName) + 1);
	wsprintf(bufCmd, szCmdLineFormat, szDriverName, szArchitecture, szFileName);

	// Load printui.dll
	auto_hlib hlib = LoadLibrary(_T("printui.dll"));
	return_error_if_false(hlib.valid());

	PFN_PrintUIEntryW pfnPrintUIEntryW = (PFN_PrintUIEntryW)GetProcAddress(hlib, "PrintUIEntryW");
	return_error_if_false(NULL != pfnPrintUIEntryW);


	dwError = pfnPrintUIEntryW(GetActiveWindow(), 0, T2W((LPTSTR)bufCmd), SW_HIDE);
	LOG_out( "pfnPrintUIEntryW(%s) returns %d", (LPTSTR)bufCmd, dwError);
	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\printers.h ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:   printers.h
//
//  Owner:  YanL
//
//  Description:
//
//      Printer detection and installation
//			During detection printer
//
//=======================================================================

#ifndef _PRINTERS_H

	class CPrinterDriverInfoArray
	{
	public:
		CPrinterDriverInfoArray();
		DWORD GetNumDrivers() { return m_dwNumDrivers; }

		LPDRIVER_INFO_6 GetDriverInfo(DWORD dwDriverIdx);
		bool GetHardwareID(LPDRIVER_INFO_6 pinfo, tchar_buffer& bufHardwareID);
		LPCTSTR GetArchitecture(LPDRIVER_INFO_6 pinfo);
	private:
		DWORD m_dwNumDrivers;
		byte_buffer m_bufInfo;
		WORD m_wCurArchitecture;
	};

	DWORD InstallPrinterDriver(
		IN LPCTSTR szDriverName,
		IN LPCTSTR szInstallFolder,
		IN LPCTSTR szArchitecture
	);

	#define _PRINTERS_H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\progress.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    progress.h
//
//  Purpose: Progress dialog
//
//=======================================================================

#ifndef _PROGRESS_H
#define _PROGRESS_H

#include <wuv3ctl.h>
#include <windows.h>
#include <commctrl.h>
#include "speed.h"
#include "resource.h"


class CWUProgress : public IWUProgress  
{
public:
	enum ProgStyle {NORMAL, DOWNLOADONLY, OFF};

	CWUProgress(HINSTANCE hInst);
	~CWUProgress();	
	void Destroy();

	void SetStyle(ProgStyle style);

	void StartDisplay();
	void EndDisplay();
	void ResetAll();

	//IWUProgress
	void SetDownloadTotal(DWORD dwTotal);
	void SetDownload(DWORD dwDone = 0xffffffff);
	void SetDownloadAdd(DWORD dwAddSize, DWORD dwTime = 0);
	
	void SetInstallTotal(DWORD dwTotal);
	void SetInstall(DWORD dwDone = 0xffffffff);
	void SetInstallAdd(DWORD dwAdd);

	void SetStatusText(LPCTSTR pszStatus);

	HANDLE GetCancelEvent();

private:

	HWND m_hDlg;
	HINSTANCE m_hInst;
	
	DWORD m_dwDownloadTotal;
	DWORD m_dwDownloadLast;
	DWORD m_dwDownloadVal;
	
	DWORD m_dwInstallTotal;
	DWORD m_dwInstallLast;
	DWORD m_dwInstallVal;
	
	DWORD m_style;
	
	HANDLE m_hCancelEvent;
	
	CWUProgress() {}

	void UpdateTime(DWORD dwBytesLeft);
	void UpdateBytes(DWORD dwDone);
	void UpdateLocStr(int iDlg, int iStr);

protected:
	static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

};



#endif // _PROGRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\install.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    install.cpp
//
//  Purpose: Install/uninstall components
//
//======================================================================= 

#include "stdafx.h"

#include "install.h"
#include <advpub.h>


extern CState g_v3state;   //defined in CV3.CPP


// This function installs an active setup catalog item.
void InstallActiveSetupItem(LPCTSTR szLocalDir, LPCTSTR pszCifFile, PSELECTITEMINFO pStatusInfo, IWUProgress* pProgress)
{
	USES_CONVERSION;

	MSG 				msg;
	HRESULT 			hr;
	DWORD				dwEngineStatus;
	IInstallEngine2*	pInsEng = NULL;
	ICifFile*			picif = NULL;
	ICifComponent*		pcomp = NULL;
	IEnumCifComponents* penum = NULL;
	CInstallEngineCallback* pCallback = NULL;

	try
	{
		//
		// Create active setup engine
		//
		hr = CoCreateInstance(CLSID_InstallEngine, NULL, CLSCTX_INPROC_SERVER, IID_IInstallEngine2,(void **)&pInsEng);
		if (FAILED(hr))
			throw hr;

		// Tell active setup the direct and directory to use. This is the directory
		// where we downloaded the files previously.
		hr = pInsEng->SetDownloadDir(T2A(szLocalDir));
		if (FAILED(hr))
			throw hr;
		
		hr = pInsEng->SetLocalCif(T2A(pszCifFile));
		if (FAILED(hr))
			throw hr;

		//
		// Create the callback object and register the install engines callback interface
		//
		pCallback = new CInstallEngineCallback;
		if (!pCallback)
		{
			throw HRESULT_FROM_WIN32(GetLastError());
		}
		pCallback->SetProgressPtr(pProgress);

		pInsEng->RegisterInstallEngineCallback((IInstallEngineCallback *)pCallback);

		pCallback->SetEnginePtr(pInsEng);

		//
		// Get a pointer to the CIF interface we need in order to enum the
		// CIF components and we need to do that on this single item CIF
		// becuase we need to tell the install engine what action to perform.
		//
		hr = pInsEng->GetICifFile(&picif);
		if (FAILED(hr))
			throw hr;

		hr = picif->EnumComponents(&penum, 0, NULL);
		if (FAILED(hr))
			throw hr;

		hr = penum->Next(&pcomp);
		if (FAILED(hr))
			throw hr;

		// Set action to install and then install the component.
		pcomp->SetInstallQueueState(SETACTION_INSTALL);

		hr = pInsEng->InstallComponents(EXECUTEJOB_IGNORETRUST | EXECUTEJOB_IGNOREDOWNLOADERROR);
		if (FAILED(hr))
		{
			TRACE_HR(hr, "InstallActiveSetupItem: inseng.InstallComponents failed");
			throw hr;
		}

		do
		{
			pInsEng->GetEngineStatus(&dwEngineStatus);

			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
			SleepEx(50, TRUE);
		} while (dwEngineStatus != ENGINESTATUS_READY);

		if (pcomp->IsComponentInstalled() != ICI_INSTALLED)
		{
			hr = pCallback->LastError();

			//
			// if we don't know the exact error from the callback, use E_FAIL
			//
			if (hr == NOERROR)
				hr = E_FAIL;

			TRACE_HR(hr, "InstallActiveSetupItem: inseng failed to install");
			throw hr;
		}


		//
		// get the return status
		//
		if (pCallback->GetStatus() & STOPINSTALL_REBOOTNEEDED)
			pStatusInfo->iStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
		else
			pStatusInfo->iStatus = ITEM_STATUS_SUCCESS;
		pStatusInfo->hrError = NOERROR;

		// 
		// release interfaces
		//
		if (penum)
			penum->Release();

		if (picif)
			picif->Release();

		if (pInsEng)
			pInsEng->Release();

		if (pCallback)
			delete pCallback;
	}
	catch(HRESULT hr)
	{
		pStatusInfo->iStatus = ITEM_STATUS_FAILED;
		pStatusInfo->hrError = hr;

		if (penum)
			penum->Release();

		if (picif)
			picif->Release();

		if (pInsEng)
			pInsEng->Release();

		if (pCallback)
			delete pCallback;

		throw hr;
	}

}


//This function handles installation of a Device driver package.
void InstallDriverItem(
	LPCTSTR szLocalDir,					//Local directory where installation files are.
	BOOL bWindowsNT,					//TRUE if client machine is NT else FALSE.
	LPCTSTR pszTitle,					//Description of package, Device Manager displays this in its install dialog.
	PINVENTORY_ITEM pItem,				//Install Item Information
	PSELECTITEMINFO pStatusInfo			//Returned status information.
	)
{
	LOG_block("InstallDriverItem");

	try
	{
		//Note: GetCatalog automatically prunes any drivers if the system is
		//not either NT 5 or Windows 98 since we only support installation
		//of drivers on these platforms.

		//If we do not have a hardware id then we cannot install the device.
		PWU_VARIABLE_FIELD	pvTmp = pItem->pv->Find(WU_CDM_HARDWARE_ID);
		if (!pvTmp)
		{
			pStatusInfo->iStatus = ITEM_STATUS_FAILED;
			pStatusInfo->hrError = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
			return;
		}

		BOOL reboot = FALSE;
		CdmInstallDriver(bWindowsNT, 
			(WU_ITEM_STATE_CURRENT == pItem->ps->state) ? edsCurrent : edsNew, 
			(LPCTSTR)pvTmp->pData, szLocalDir, pszTitle, (PULONG)&reboot);

		if (reboot)
			pStatusInfo->iStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
		else
			pStatusInfo->iStatus = ITEM_STATUS_SUCCESS;
		pStatusInfo->hrError = NOERROR;
	}
	catch(HRESULT hr)
	{
		pStatusInfo->iStatus = ITEM_STATUS_FAILED;
		pStatusInfo->hrError = hr;

		throw hr;
	}
}


HRESULT UninstallDriverItem(PINVENTORY_ITEM pItem, PSELECTITEMINFO pStatusInfo)
{
	
	PBYTE pTitle;
	PWU_VARIABLE_FIELD pvTitle;
	PWU_VARIABLE_FIELD pvTmp;
	BOOL bWindowsNT;
	TCHAR szLocalDir[MAX_PATH];
	BOOL bReboot = FALSE;
	

	bWindowsNT = IsWindowsNT();

	if (!(pvTmp = pItem->pv->Find(WU_CDM_HARDWARE_ID)) )
	{
		pStatusInfo->iStatus = ITEM_STATUS_FAILED;
		pStatusInfo->hrError = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		return E_UNEXPECTED;
	}

	if (pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE))
	{
		pTitle = (PBYTE)pvTitle->pData;
	}
	else
	{
		pTitle = (PBYTE)"";
	}

				
	pStatusInfo->iStatus = ITEM_STATUS_SUCCESS;

	//we will call UpdateCDMDriver with our cache directory but this directory should not
	//really be used by UpdateCDMDriver in case of an uninstall since the uninstall case
	//reads the correct directory from the registry
	GetWindowsUpdateDirectory(szLocalDir);

	try
	{
		CdmInstallDriver(bWindowsNT, edsBackup, (LPCTSTR)pvTmp->pData, szLocalDir, (LPCTSTR)pTitle, (PULONG)&bReboot);
		if (bReboot)
		{
			g_v3state.m_bRebootNeeded = TRUE;
		}

	}
	catch(HRESULT hr)
	{
		pStatusInfo->iStatus = ITEM_STATUS_FAILED;
		pStatusInfo->hrError = hr;
		return hr;
	}

	return S_OK;
}



HRESULT GetUninstallCmdFromKey(LPCTSTR pszUninstallKey, LPTSTR pszCmdValue)                
{
	
	const TCHAR UNINSTALLKEY[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\");
	const TCHAR UNINSTALLVALUE[] = _T("UninstallString");
	const TCHAR QUIETUNINSTALLVALUE[] = _T("QuietUninstallString");

	HKEY hRegKey = NULL;
	DWORD dwRegType;
	DWORD dwRegSize;
	TCHAR szRegKey[256];
	LONG lRet;
	TCHAR szValue[256];

	if (pszUninstallKey == NULL)
		return E_FAIL;

	if (pszUninstallKey[0] == _T('"'))
	{
		//strip quotes from the key
		lstrcpy(szValue, (pszUninstallKey + 1));
		int l = lstrlen(szValue);
		if (l > 0)
			szValue[l - 1] = _T('\0');
	}
	else
	{
		lstrcpy(szValue, pszUninstallKey);
	}
	

	lstrcpy(szRegKey, UNINSTALLKEY);
	lstrcat(szRegKey, szValue);

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, KEY_READ, &hRegKey);
	if (lRet != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lRet);

	//check the uninstall value
	dwRegSize = sizeof(szValue);
	lRet = RegQueryValueEx(hRegKey, UNINSTALLVALUE, NULL, &dwRegType, (LPBYTE)szValue, &dwRegSize);

	if (lRet != ERROR_SUCCESS)
	{
		// try to find quiteuninstall value
		dwRegSize = sizeof(szValue);
		lRet = RegQueryValueEx(hRegKey, QUIETUNINSTALLVALUE, NULL, &dwRegType, (LPBYTE)szValue, &dwRegSize);
	}

	if (lRet != ERROR_SUCCESS)
	{
		HRESULT hr = HRESULT_FROM_WIN32(lRet);
		RegCloseKey(hRegKey);
		return hr;
	}
	RegCloseKey(hRegKey);

	//
	// copy the key to the output parameter
	//
	lstrcpy(pszCmdValue, szValue);

	return S_OK;
}


//Given an uninstall key, looks up in the registry to find the uninsall command and launches it
//If quotes are found around the uninstall key, they are striped.  This is done to make it 
//compatible with the value specified in the AS CIF file.  This function also understands the
//special INF syntax of the uninstall key.
HRESULT UninstallActiveSetupItem(LPCTSTR pszUninstallKey)
{
	const TCHAR INFUNINSTALLCOMMAND[] = _T("RunDll32 advpack.dll,LaunchINFSection ");
	const TCHAR INFDIRECTORY[] = _T("INF\\");

	
	TCHAR szCmd[256] = {_T('\0')};
	TCHAR szActualKey[128] = {_T('\0')};
	LONG lRet;
	LPCTSTR pszParse;

	HRESULT hr = S_OK;

	if (pszUninstallKey == NULL)
		return E_FAIL;
	
	if (lstristr(pszUninstallKey, _T(".inf")) != NULL)
	{
		//
		// we have .INF syntax: frontpad,fpxpress.inf,uninstall, start parsing
		// 
		pszParse = lstrcpystr(pszUninstallKey, _T(","), szActualKey);  // get actual uninstall key
	}
	else
	{
		lstrcpy(szActualKey, pszUninstallKey);
		pszParse = NULL;
	}

	//
	// get the uninstall command from the registry
	//
	hr = GetUninstallCmdFromKey(szActualKey, szCmd);
	
	if (SUCCEEDED(hr))
	{
		// we have the uninstall command, try to launch it
		lRet = LaunchProcess(szCmd, NULL, SW_NORMAL, TRUE);

		TRACE("Uninstall: %s, %d", szCmd, lRet);

		if (lRet != 0)
		{
			hr = HRESULT_FROM_WIN32(lRet);
		}
	}
	else
	{
		// we did not get the uninstall command from registry, launch INF
		if (pszParse != NULL)
		{
	
			TCHAR szTemp[MAX_PATH];

			hr = S_OK;

			//get INF directory
            if (! GetWindowsDirectory(szTemp, sizeof(szTemp) / sizeof(TCHAR)))
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
				TRACE("Uninstall: GetWindowsDirectory failed, hr=0x%x", hr);
				return hr;
			}
			AddBackSlash(szTemp);
			lstrcat(szTemp, INFDIRECTORY);

			//start building the command
			lstrcpy(szCmd, INFUNINSTALLCOMMAND);
			lstrcat(szCmd, szTemp);

			pszParse = lstrcpystr(pszParse, _T(","), szTemp);  // get INF file name
			lstrcat(szCmd, szTemp);

			lstrcat(szCmd, _T(","));

			pszParse = lstrcpystr(pszParse, _T(","), szTemp);  // get INF section
			lstrcat(szCmd, szTemp);

			lRet = LaunchProcess(szCmd, NULL, SW_NORMAL, TRUE);
			if (lRet != 0)
			{
				hr = HRESULT_FROM_WIN32(lRet);
			}

			TRACE("Uninstall: %s, %d", szCmd, lRet);

			if (SUCCEEDED(hr))
			{
				//
				// reboot handling after uninstall only if uninstall was successful
				//
				pszParse = lstrcpystr(pszParse, _T(","), szTemp);  // get the reboot key
				if (lstrcmpi(szTemp, _T("reboot")) == 0)
				{
					g_v3state.m_bRebootNeeded = TRUE;
				}
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}

	return hr;
}


void InstallPrinterItem(LPCTSTR pszDriverName, LPCTSTR pszInstallFolder, LPCTSTR pszArchitecture)
{
	DWORD dw = InstallPrinterDriver(pszDriverName, pszInstallFolder, pszArchitecture);
	HRESULT hr = HRESULT_FROM_WIN32(dw);

	if (FAILED(hr))
		throw hr;
}



HRESULT AdvPackRunSetupCommand(HWND hwnd, LPCSTR pszInfFile, LPCSTR pszSection, LPCSTR pszDir, DWORD dwFlags)
{
	HRESULT 		hr = E_FAIL;
	RUNSETUPCOMMAND pfRunSetupCommand;
	
	HINSTANCE hAdvPack = LoadLibrary(_T("advpack.dll"));
	
	if (hAdvPack != NULL)
	{
		pfRunSetupCommand = (RUNSETUPCOMMAND)GetProcAddress(hAdvPack, "RunSetupCommand");
		if (pfRunSetupCommand)
		{
			dwFlags |= (RSC_FLAG_INF | RSC_FLAG_NGCONV | RSC_FLAG_QUIET);
			hr = pfRunSetupCommand(hwnd, pszInfFile, pszSection, pszDir, NULL, NULL, dwFlags, NULL);
		}
		FreeLibrary(hAdvPack);
	}
	
	return hr;
}




// checks to see if inseng is up to date
void CheckLocalDll(LPCTSTR pszServer, LPCTSTR pszDllName, LPCTSTR pszServDllName, LPCTSTR pszDllVersion)
{
	USES_CONVERSION;

	const TCHAR TEMPINFFN[] = _T("temp.inf");
	const TCHAR PERIOD[] = _T(".");

	TCHAR szServDllName[32] = _T("\0");
	TCHAR szValue[256] = _T("\0");
	TCHAR szTempFN[MAX_PATH] = _T("\0");
	TCHAR szDllFN[MAX_PATH] = _T("\0");
	TCHAR szInfDir[MAX_PATH] = _T("\0");
	TCHAR szDllName[MAX_PATH] = _T("\0");
	TCHAR szDllVersion[64] = _T("\0");
	TCHAR *pszToken = NULL;
	DWORD dwIniMSVer = 0;
	DWORD dwIniLSVer = 0;
	DWORD dwFileMSVer = 0;
	DWORD dwFileLSVer = 0;
	LPTSTR p = NULL;
	HRESULT hr = S_OK;

	//check input arguments
	if (NULL == pszDllName || NULL == pszServDllName || NULL == pszDllVersion)
	{
		return ;
	}

	if (!GetSystemDirectory(szDllFN, sizeof(szDllFN) / sizeof(TCHAR)))
	{
		return;
	}

	AddBackSlash(szDllFN);
	lstrcat(szDllFN, pszDllName);
	
	lstrcpy(szDllVersion, pszDllVersion);
	lstrcpy(szServDllName, pszServDllName);

	if (FileExists(szDllFN))
	{
		// convert file version 
		ConvertVersionStrToDwords(szDllVersion, &dwIniMSVer, &dwIniLSVer);

		// get file version of the DLL
		if (!GetFileVersionDwords(szDllFN, &dwFileMSVer, &dwFileLSVer))
		{
			TRACE("Could not check file version: %s", szDllFN);
			return;
		}

		// compare the versions
		if ((dwFileMSVer > dwIniMSVer) || ((dwFileMSVer == dwIniMSVer) && (dwFileLSVer >= dwIniLSVer)))
		{
			// install version is up to date
			return;
		}
	}
	
	// 
	// we need to download and install it!
	//
	BLOCK
	{
		CWUDownload	dl(pszServer, 8192);
		
		if (!dl.Copy(szServDllName, NULL, NULL, NULL, DOWNLOAD_NEWER | CACHE_FILE_LOCALLY, NULL))
		{
			throw HRESULT_FROM_WIN32(GetLastError());
		}
		
		// filename with OS ext
		GetWindowsUpdateDirectory(szTempFN);
		lstrcat(szTempFN, szServDllName);
		
		// filename with .dll
		lstrcpy(szDllFN, szTempFN);
		p = _tcschr(szDllFN, _T('.'));
		if (p)
			*p = _T('\0');
		lstrcat(szDllFN, _T(".dll"));
		
		CDiamond dm;
		
		// decompress or copy to .dll name
		if (dm.IsValidCAB(szTempFN)) 
		{
			hr = dm.Decompress(szTempFN, szDllFN);
			if (FAILED(hr)) 
			{
				throw hr;
			}
		}
		else
		{
			if (!CopyFile(szTempFN, szDllFN, FALSE))
			{
				return;
			}
		}
	}
	
	//
	// write out an INF file
	//
	HANDLE hFile;
	DWORD dwBytes;
	char szInfText[1024];


	sprintf (szInfText, 
		"[Version]\r\n\
		Signature=\"$Chicago$\"\r\n\
		AdvancedINF=2.5\r\n\
		[DestinationDirs]\r\n\
		WUSysDirCopy=11\r\n\
		[InstallControl]\r\n\
		CopyFiles=WUSysDirCopy\r\n\
		RegisterOCXs=WURegisterOCXSection\r\n\
		[WUSysDirCopy]\r\n\
		%s,,,32\r\n\
		[WURegisterOCXSection]\r\n\
		%%11%%\\%s\r\n\
		[SourceDisksNames]\r\n\
		55=\"Disk\",,0\r\n\
		[SourceDisksFiles]\r\n\
		%s=55\r\n", 
		T2A(pszDllName), T2A(pszDllName), T2A(pszDllName));

	GetWindowsUpdateDirectory(szTempFN);
	lstrcat(szTempFN, TEMPINFFN);
	
	hFile = CreateFile(szTempFN, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		WriteFile(hFile, (LPCVOID)szInfText, strlen(szInfText), &dwBytes, NULL);
		
		CloseHandle(hFile);
	}

	//
	// RunSetupCommand to install the .INF
	//
	GetWindowsUpdateDirectory(szInfDir);

	hr = AdvPackRunSetupCommand(NULL, T2A(szTempFN), "InstallControl", T2A(szInfDir), 0);

	if (FAILED(hr))
	{
		throw hr;
	}
}

void CheckDllsToJit(LPCTSTR pszServer)
{
	const TCHAR SEPS[] = _T("=");
	TCHAR szValue[1024];
	TCHAR szTempFN[MAX_PATH];
	TCHAR szKey[256];
	TCHAR szDllBaseName[64];
	TCHAR szDllExt[32];
	TCHAR szKeyLhs[64];
	TCHAR szDllName[64];
	TCHAR szDllTempName[64];
	TCHAR szDllVersion[64];
	TCHAR *pszValue;
	long len;

	if (g_v3state.m_bInsengChecked)
		return;

	g_v3state.m_bInsengChecked = TRUE;

	GetWindowsUpdateDirectory(szTempFN);
	lstrcat(szTempFN, FILEVERINI_FN);

	if (0 == GetPrivateProfileSection(_T("version"), szValue, sizeof(szValue) / sizeof(TCHAR), szTempFN))
	{
		// version not available for this file
		TRACE("Section: version is missing from FileVer.ini");
		return;
	}

	pszValue = szValue;
	while (0 != (len = lstrlen(pszValue))) 
	{
	lstrcpyn(szKey, pszValue, len+1);
	lstrcat(szKey, _T("\0"));
	pszValue += len + 1;

	_stscanf(szKey, _T("%[^=]=%s"), szKeyLhs, szDllVersion);
	_stscanf(szKeyLhs, _T("%[^.].%s"), szDllBaseName, szDllExt);
	wsprintf(szDllName, _T("%s.dll"), szDllBaseName);

	wsprintf(szDllTempName, _T("%s."), szDllBaseName);
	AppendExtForOS(szDllTempName);
	if (0 == lstrcmpi(szDllTempName, szKeyLhs))
		CheckLocalDll(pszServer, szDllName, szKeyLhs, szDllVersion);
	}


}

// Pings a URL for tracking purposes
// 
// NOTE: pszStatus must not contain spaces and cannot be null
void URLPingReport(PINVENTORY_ITEM pItem, CCatalog* pCatalog, PSELECTITEMINFO pSelectItem, LPCTSTR pszStatus)
{
	LOG_block("URLPingReport");

	//check for input arguments
	if (NULL == pItem || NULL == pCatalog)
	{
		return;
	}




	// create a download object
	try
	{
		CWUDownload	dl(g_v3state.GetIdentServer(), 8192);

		// build the URL with parameters
		TCHAR szURL[INTERNET_MAX_PATH_LENGTH];
		wsprintf(szURL, _T("wutrack.bin?VER=%s&PUID=%d&PLAT=%d&LOCALE=%s&STATUS=%s&ERR=0x%x&SESSID=%s"), 
            CCV3::s_szControlVer,
						pItem->GetPuid(), 
						pCatalog->GetPlatform(),
						pCatalog->GetMachineLocaleSZ(),
						pszStatus,
						pSelectItem->hrError,
                        CWUDownload::m_szWUSessionID);

        LOG_out("Sending %s", szURL);

		// ping the URL and receive the response in memory
		PVOID pMemBuf;
		ULONG ulMemSize;
		if (dl.QCopy(szURL, &pMemBuf, &ulMemSize))
		{
			// we don't care about the response so we just free it
			V3_free(pMemBuf);	
		}
	}
	catch(HRESULT hr)
	{
		return;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WUV3IS.rc
//
#define IDS_PROJNAME                    100
#define IDR_CV3                         101
#define IDD_PROGRESS                    102
#define IDA_FILECOPY                    103
#define IDS_UNINSTALLCHECK		104

#define IDC_PROG_DOWNLOAD               1000
#define IDC_PROG_INSTALL                1001
#define IDC_STATUS                      1002
#define IDC_DOWNLOADCAP                 1003
#define IDC_ANIM                        1004
#define IDC_INSTALLCAP                  1005
#define IDC_TIMELEFT                    1006
#define IDC_TIMELEFTCAP                 1007
#define IDC_BYTES                       1008


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\progress.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    progress.cpp
//
//  Purpose: Progress dialog and connection speed
//
//  History: 12-dec-98   YAsmi    Created
//
//=======================================================================


#include "stdafx.h"
#include "progress.h"
#include "locstr.h"



//
// CWUProgress class
//
CWUProgress::CWUProgress(HINSTANCE hInst) 
	:m_hInst(hInst), 
	 m_hDlg(NULL),
	 m_dwDownloadTotal(0),
	 m_dwDownloadVal(0),
	 m_dwInstallVal(0),
	 m_dwInstallTotal(0),
	 m_style(ProgStyle::NORMAL)
{
	m_hCancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
}

CWUProgress::~CWUProgress()
{
	Destroy();
	if (m_hCancelEvent != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hCancelEvent);
		m_hCancelEvent = INVALID_HANDLE_VALUE;
	}
}


void CWUProgress::SetStyle(ProgStyle style)
{
	m_style = style;
	if (m_style == ProgStyle::OFF)
	{
		Destroy();
	}
}


HANDLE CWUProgress::GetCancelEvent() 
{
	return m_hCancelEvent;
}


void CWUProgress::Destroy()
{
	if (m_hDlg != NULL)
	{
		::DestroyWindow(m_hDlg);
		m_hDlg = NULL;
	}
	m_style = ProgStyle::OFF;
}


void CWUProgress::StartDisplay()
{
	if (m_style == ProgStyle::OFF)
		return;
	
	if (m_hDlg == NULL)
	{
		// create the dialog window
		m_hDlg = CreateDialogParam(m_hInst, MAKEINTRESOURCE(IDD_PROGRESS), 0,
								   CWUProgress::DlgProc, (LPARAM)this);
	}
	ShowWindow(m_hDlg, SW_SHOWNORMAL);

	if (m_style == ProgStyle::DOWNLOADONLY)
	{
		ShowWindow(GetDlgItem(m_hDlg, IDC_PROG_INSTALL), SW_HIDE);
		ShowWindow(GetDlgItem(m_hDlg, IDC_INSTALLCAP), SW_HIDE);
	}

	//
	// update localized strings
	//
	UpdateLocStr(IDC_DOWNLOADCAP, IDS_PROG_DOWNLOADCAP);
	UpdateLocStr(IDC_TIMELEFTCAP, IDS_PROG_TIMELEFTCAP);
	UpdateLocStr(IDC_INSTALLCAP, IDS_PROG_INSTALLCAP);
	UpdateLocStr(IDCANCEL, IDS_PROG_CANCEL);

	SetWindowText(m_hDlg, GetLocStr(IDS_APP_TITLE));

	ResetAll();
}


void CWUProgress::ResetAll()
{
	SetInstall(0);
	SetDownload(0);
	ResetEvent(m_hCancelEvent);
}


void CWUProgress::UpdateLocStr(int iDlg, int iStr)
{
	LPCTSTR pszStr = GetLocStr(iStr);

	if (NULL != pszStr && pszStr[0] != _T('\0'))
	{
		//update the control with loc string only if its not an empty string
		if (m_style != ProgStyle::OFF)
		{
			SetDlgItemText(m_hDlg, iDlg, pszStr);
		}
	}
}


void CWUProgress::SetDownloadTotal(DWORD dwTotal)
{
	m_dwDownloadTotal = dwTotal;
	m_dwDownloadLast = 0;
	m_dwDownloadVal = 0;
	
	if (m_style != ProgStyle::OFF)
	{
		UpdateBytes(0);
		UpdateTime(m_dwDownloadTotal);
	}
}



void CWUProgress::SetInstallTotal(DWORD dwTotal)
{
	m_dwInstallTotal = dwTotal;
	m_dwInstallLast = 0;
	m_dwInstallVal = 0;
}


void CWUProgress::SetDownload(DWORD dwDone)
{
	if (m_dwDownloadTotal == 0 || m_style == ProgStyle::OFF)
		return;
	
	if (dwDone > m_dwDownloadTotal)
		dwDone = m_dwDownloadTotal;

	m_dwDownloadVal = dwDone;

	// update bytes display
	UpdateBytes(dwDone);

	// update progress bar and time
	DWORD dwProgress = (int)((double)dwDone / m_dwDownloadTotal * 100);
	if (dwProgress != m_dwDownloadLast || dwDone == m_dwDownloadTotal)
	{
		m_dwDownloadLast = dwProgress;		

		SendMessage(GetDlgItem(m_hDlg, IDC_PROG_DOWNLOAD), PBM_SETPOS, dwProgress, 0);
		
		if (dwDone == m_dwDownloadTotal)
		{
			ShowWindow(GetDlgItem(m_hDlg, IDC_TIMELEFTCAP), SW_HIDE);
			ShowWindow(GetDlgItem(m_hDlg, IDC_TIMELEFT), SW_HIDE);
		}
		else
		{
			UpdateTime(m_dwDownloadTotal - dwDone);
		} 
	}
}


void CWUProgress::SetDownloadAdd(DWORD dwAddSize, DWORD dwTime)
{

	//
	// add size and time to the connection speed tracker
	//
	CConnSpeed::Learn(dwAddSize, dwTime);

	SetDownload(m_dwDownloadVal + dwAddSize);
}


void CWUProgress::SetInstallAdd(DWORD dwAdd)
{
	SetInstall(m_dwInstallVal + dwAdd);	
}


void CWUProgress::SetInstall(DWORD dwDone)
{
	if (m_hDlg == NULL || m_dwInstallTotal == 0 || m_style == ProgStyle::OFF)
		return;

	if (dwDone > m_dwInstallTotal)
		dwDone = m_dwInstallTotal;

	m_dwInstallVal = dwDone;

	DWORD dwProgress = (int)((double)dwDone / m_dwInstallTotal * 100);
	if (dwProgress != m_dwInstallLast || dwDone == m_dwInstallTotal)
	{
		m_dwInstallLast = dwProgress;		
		SendMessage(GetDlgItem(m_hDlg, IDC_PROG_INSTALL), PBM_SETPOS, dwProgress, 0);
	}
}

void CWUProgress::SetStatusText(LPCTSTR pszStatus)
{
	if (m_hDlg == NULL || m_style == ProgStyle::OFF)
		return;
	
	SetDlgItemText(m_hDlg, IDC_STATUS, pszStatus);
}


void CWUProgress::EndDisplay()
{
	if (m_hDlg == NULL || m_style == ProgStyle::OFF)
		return;
	ShowWindow(m_hDlg, SW_HIDE);
}


void CWUProgress::UpdateBytes(DWORD dwDone)
{
	TCHAR szBuf[128];
	
	wsprintf(szBuf, _T("%d KB/%d KB"), dwDone / 1024, m_dwDownloadTotal / 1024);
	SetDlgItemText(m_hDlg, IDC_BYTES, szBuf);
}


void CWUProgress::UpdateTime(DWORD dwBytesLeft)
{
	DWORD dwBPS = CConnSpeed::BytesPerSecond();
	TCHAR szBuf[128];

	if (dwBPS != 0)
	{
		DWORD dwSecs;
		DWORD dwMinutes;
		DWORD dwHours;
		DWORD dwSecsLeft = 0;

		dwSecsLeft = (dwBytesLeft / dwBPS) + 1;
		
		// convert secs to hours, minutes, and secs
		dwSecs = dwSecsLeft % 60;
		dwMinutes = (dwSecsLeft % 3600) / 60;
		dwHours = dwSecsLeft / 3600;

		if (dwHours == 0)
		{
			if (dwMinutes == 0)
				wsprintf(szBuf, GetLocStr(IDS_PROG_TIME_SEC), dwSecs);
			else
				wsprintf(szBuf, GetLocStr(IDS_PROG_TIME_MIN), dwMinutes);
		}
		else
		{
			wsprintf(szBuf, GetLocStr(IDS_PROG_TIME_HRMIN), dwHours, dwMinutes);
		}
	}
	else
	{
		szBuf[0] = _T('\0');
	} //bps is zero

	SetDlgItemText(m_hDlg, IDC_TIMELEFT, szBuf);
}


INT_PTR CALLBACK CWUProgress::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
			SetWindowLongPtr(hwnd, DWLP_USER, lParam);

			Animate_Open(GetDlgItem(hwnd, IDC_ANIM), MAKEINTRESOURCE(IDA_FILECOPY));
			Animate_Play(GetDlgItem(hwnd, IDC_ANIM), 0, -1, -1);
			return FALSE;
        
		case WM_COMMAND:
		{
			switch (wParam)
			{
				case IDCANCEL:
					{
						CWUProgress* pProgress = (CWUProgress*)GetWindowLongPtr(hwnd, DWLP_USER);
						pProgress->Destroy();
						SetEvent(pProgress->GetCancelEvent());
					}
					break;
				default:
					return FALSE;
			}
		}
		break;

	 default:
		return(FALSE);
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\safearr.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    safearr.h
//
//  Purpose: Safe array creation
//
//======================================================================= 

#ifndef _SAFEARR_H
#define _SAFEARR_H

#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>

#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES

#include <cstate.h>
#include "progress.h"
#include "history.h"
#include "install.h"
#include "locstr.h"


void AddSafeArrayRecord(LPVARIANT rgElems, int record, int nRcrds, LPSTR szFmt, ...);
void DeleteSafeArrayRecord(LPVARIANT rgElems, int record, int nRcrds, LPSTR szFmt);
int GetItemReturnStatus(PINVENTORY_ITEM pItem);
int CalcDownloadTime(int size, int downloadTime);
BOOL FilterCatalogItem(PINVENTORY_ITEM pItem, long lFilters);


HRESULT MakeReturnItemArray(PINVENTORY_ITEM pItem, VARIANT *pvaVariant);
HRESULT MakeDependencyArray(Varray<DEPENDPUID>& vDepPuids, const int cDepPuids, VARIANT *pvaVariant);
HRESULT MakeInstallMetricArray(PSELECTITEMINFO pSelInfo, int iSelItems, VARIANT *pvaVariant);
HRESULT MakeEulaArray(PSELECTITEMINFO pInfo, int iTotalItems, VARIANT *pvaVariant);
HRESULT MakeInstallStatusArray(PSELECTITEMINFO pInfo, int iTotalItems, VARIANT *pvaVariant);
HRESULT MakeInstallHistoryArray(Varray<HISTORYSTRUCT>& History, int iTotalItems, VARIANT *pvaVariant);

#endif // _SAFEARR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\sources.inc ===
#!include ..\..\..\wu.inc

MAJORCOMP=wuppt
MINORCOMP=wuv3is

TARGETNAME=WUV3IS
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

UMTYPE=windows
USE_STATIC_ATL=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\wuv3is.def
USE_NATIVE_EH=1
#DEBUG_CRTS=1
USE_STL=1
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
USE_MSVCRT=1

C_DEFINES=$(C_DEFINES) /D_UNICODE /DUNICODE

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\wininet.lib	\
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\cabinet.lib	\
    $(SDK_LIB_PATH)\setupapi.lib \
    $(SDK_LIB_PATH)\rpcrt4.lib	\
    $(SDK_LIB_PATH)\version.lib	\
    $(SDK_LIB_PATH)\ole32.lib	\
    $(SDK_LIB_PATH)\user32.lib	\
    $(SDK_LIB_PATH)\winspool.lib   \
    $(SDK_LIB_PATH)\uuid.lib 	\
    $(SDK_LIB_PATH)\wintrust.lib        \
    $(SDK_LIB_PATH)\crypt32.lib			\
    $(SDK_LIB_PATH)\shlwapi.lib

INCLUDES=..\..\cdminc;..\..\inc;$(BASEDIR)\public\internal\windows\inc

SOURCES=\
    ..\WUV3IS.rc \
    ..\WUV3IS.idl \
    ..\StdAfx.cpp \
    ..\WUV3IS.cpp \
    ..\progress.cpp \
    ..\history.cpp \
    ..\callback.cpp \
    ..\ccdm.cpp \
    ..\printers.cpp \
    ..\detect.cpp \
    ..\safearr.cpp \
    ..\install.cpp \
    ..\template.cpp \
    ..\autoupd.cpp \
    ..\CV3.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\safearr.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    safearr.cpp
//
//  Purpose: Safe array creation
//
//======================================================================= 

#include "stdafx.h"

#include "safearr.h"
#include "speed.h"


extern CState g_v3state;   //defined in CV3.CPP


//This function adds a record to a safe array. The format of the
//record is given by the szFmt parameter and can contain either
//%d or %s for NUMBER or STRING data types. This function is used
//with safe arrays that are 2 dimensional.
void AddSafeArrayRecord(
	LPVARIANT rgElems,	//pointer to locked safe array
	int record,			//record (first dimension) for which the fields are to be set.
	int nRcrds,			//number of records in safe array
	LPSTR szFmt,		//printf style format string that describes the order and type of the fields. Currently we support %d for NUMBER and %s for string.
	 ...				//The actual data for the records fields.
	)
{
	va_list	marker;
	char	ch;
	char	*ptr;
	int		iField;

	USES_CONVERSION;

	//Initialize variable arguments.
	va_start(marker, szFmt);

	iField = record;

	while( ch = *szFmt++ )
	{
		if ( ch != '%' )
			continue;

		if ( *szFmt == 'd' || *szFmt == 'D' )
		{
			rgElems[iField].vt = VT_I4;
			rgElems[iField].lVal = va_arg( marker, int);
			iField += nRcrds;
			continue;
		}

		if ( *szFmt == 's' || *szFmt == 'S' )
		{
            PWSTR wptr = va_arg( marker, PWSTR);
			PCWSTR waptr;

			// this macro will allocate stack space for an aligned
			// copy of the string (if it's unaligned)  We'll allocate
			// room on the stack for each unaligned string parameter,
			// which may be problematic if we ever call this function
			// with lots of string arguments

			waptr = wptr;
			if (waptr)
			{
				WSTR_ALIGNED_STACK_COPY(&waptr, wptr);
			}

			rgElems[iField].vt = VT_BSTR;

			rgElems[iField].bstrVal = ( waptr ) ? ::SysAllocString(waptr) : NULL;

			iField += nRcrds;
			continue;
		}

	}

	//Reset variable arguments.
	va_end( marker );

	return;
}

//This function cleans up the memory allocated by the AddSafeArrayRecord
//function. The szFmt parameter needs to match the szFmt parameter passed
//to the AddSafeArrayRecord function. This function is only called needed
//if an error occurs during the construction of the safe array. Otherwise
//the memory for array will belong to the IE VBscript engine.

void DeleteSafeArrayRecord(
	LPVARIANT rgElems,	//locked pointer to safe array data
	int record,			//record index to delete
	int nRcrds,			//number for records (dim 1) in safearray
	LPSTR szFmt	//printf style format string that describes the order and type of the fields. Currently we support %d for NUMBER and %s for string.
	)
{
	char	ch;
	int		iField;

	iField = record;

	while( ch = *szFmt++ )
	{
		if ( ch != '%' )
			continue;

		if ( *szFmt == 'd' || *szFmt == 'D' )
		{
			iField += nRcrds;
			continue;
		}

		if ( *szFmt == 's' || *szFmt == 'S' )
		{
			VariantClear(&rgElems[iField]);
			iField += nRcrds;
			continue;
		}
	}

	return;
}


//This function converts our internal V3 item structure into a safearray of variants
//that the VBScript web page uses. The format of the safe array will be:
//array(0) = NUMBER puid
//array(1) = STRING TITLE
//array(2) = STRING Description
//array(3) = NUMBER Item Status
//array(4) = NUMBER Download Size in Bytes
//array(5) = NUMBER Download Time in minutes
//array(6) = STRING Uninstall Key
//array(7) = STRING Read This Url
HRESULT MakeReturnItemArray(
	PINVENTORY_ITEM	pItem,	//Item to copy to returned safe array.
	VARIANT *pvaVariant		//pointer to returned safe array.
	)
{
	USES_CONVERSION;

	HRESULT hr = NOERROR;

	LPVARIANT			rgElems;
	LPSAFEARRAY			psa;
	SAFEARRAYBOUND		rgsabound;

	if (!pvaVariant  || !pItem)
	{
		return E_INVALIDARG;
	}

	VariantInit(pvaVariant);

	
	rgsabound.lLbound = 0;
	rgsabound.cElements = 8;

	psa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);
	if ( !psa )
		return E_OUTOFMEMORY;

	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	PUID puid;
	pItem->GetFixedFieldInfo(WU_ITEM_PUID, (PVOID)&puid);

	PWU_VARIABLE_FIELD	pvTitle = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE);
	PWU_VARIABLE_FIELD	pvDescription = pItem->pd->pv->Find(WU_DESCRIPTION_DESCRIPTION);
	PWU_VARIABLE_FIELD	pvUninstall = pItem->pd->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY);
	PWU_VARIABLE_FIELD	pvReadThisUrl = pItem->pd->pv->Find(WU_DESCRIPTION_READTHIS_URL);

	try
	{
		AddSafeArrayRecord(rgElems, 0, (int)1, 
			"%d%s%s%d%d%d%s%s",
			puid, 
			pvTitle ? (PWSTR)pvTitle->pData : NULL, 
			pvDescription ? (PWSTR)pvDescription->pData : NULL, 
			GetItemReturnStatus(pItem), 
			pItem->pd->size,
			CalcDownloadTime(pItem->pd->size, pItem->pd->downloadTime), 
			pvUninstall ? A2W((char*)pvUninstall->pData) : NULL,
			pvReadThisUrl ? A2W((char*)pvReadThisUrl->pData) : NULL);
	}
	catch(HRESULT hr)
	{
		DeleteSafeArrayRecord(rgElems, 0, (int)rgsabound.cElements, "%d%s%s%d%d%d%s%s");

		SafeArrayUnaccessData(psa);
		VariantInit(pvaVariant);

		throw hr;
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}

//array(0) = NUMBER puid

//This function creates the dependency puid safe array.
HRESULT MakeDependencyArray(
	Varray<DEPENDPUID>& vDepPuids, 
	const int cDepPuids,
	VARIANT *pvaVariant		//returned safe array pointer.
	)
{
	int				i;
	HRESULT			hr;
	LPVARIANT		rgElems;
	LPSAFEARRAY		psa;
	SAFEARRAYBOUND	rgsabound;


	if (!pvaVariant)
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	hr = NOERROR;

	rgsabound.lLbound = 0;
	rgsabound.cElements = cDepPuids;

	psa = SafeArrayCreate(VT_VARIANT, 1, &rgsabound);
	if (!psa)
		return E_OUTOFMEMORY;

	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	for (i=0; i  <cDepPuids; i++)
	{
		rgElems[i].vt = VT_I4;
		rgElems[i].lVal = vDepPuids[i].puid;
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}


//This function creates the safe array that is returned to the GetInstallMetrics
//array.

//array(0,0)	= NUMBER puid			The identifier for this catalog item.
//array(0,1)	= NUMBER DownloadSize	Total download size of all selected items in bytes.
//array(0,2)	= NUMBER Downloadtime	Total download time for all currently selected items at 28.8 this
HRESULT MakeInstallMetricArray(
	PSELECTITEMINFO pSelInfo,	//Pointer to selected item information array.
	int iSelItems,		//Total selected items
	VARIANT *pvaVariant		//Pointer to returned safe array.
	)
{
	HRESULT				hr;
	LPVARIANT			rgElems;
	LPSAFEARRAY			psa;
	SAFEARRAYBOUND		rgsabound[2];
	PINVENTORY_ITEM	pItem = NULL;
	int j;
	int cInstallItems = 0;
	PSELECTITEMINFO pInfo;

	if ( !pvaVariant )
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	//we have to calculate the number of items for install and not for removal
	pInfo = pSelInfo;
	for (j = 0; j < iSelItems; j++)
	{
		if (pInfo[j].bInstall)
			cInstallItems++;
	}	

	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= cInstallItems;

	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 3;

	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if (!psa)
		return E_OUTOFMEMORY;

	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	hr = NOERROR;

	//For each item in puid array get download size and time
	
	int isa = 0;  //index into the safe array
	pInfo = pSelInfo;
	for (j = 0; j < iSelItems; j++)
	{
		if (!pInfo[j].bInstall)
			continue;

		//Note: we had better have only valid items here. The ChangeItemState
		//method is responsible for only selecting items for installation that
		//are valid.

		if ((FALSE == g_v3state.GetCatalogAndItem(pInfo[j].puid, &pItem, NULL)) || (NULL == pItem))
			continue;
		


		//array(0,0)	= NUMBER puid
		//array(0,1)	= NUMBER DownloadSize
		//array(0,2)	= NUMBER Downloadtime
		try
		{
			AddSafeArrayRecord(rgElems, isa, (int)rgsabound[0].cElements, "%d%d%d",
				pInfo[j].puid, pItem->pd->size, CalcDownloadTime(pItem->pd->size, pItem->pd->downloadTime));
		}
		catch(HRESULT hr)
		{
			for (; isa; isa--)
				DeleteSafeArrayRecord(rgElems, isa, (int)rgsabound[0].cElements, "%d%d%d");

			SafeArrayUnaccessData(psa);
			VariantInit(pvaVariant);

			throw hr;
		}

		isa++;
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}


//This function makes the returned eula safe array. The Eula array is
//setup to be sorted by Eula.
//
//array(0,0)	= NUMBER eula number	Number of eula. This number changes when the eula
//										url changes. This makes it possible for the caller
//										to construct a list of items that this eula applies
//										to simply be checking when this field changes value.
//array(0,1)	= NUMBER puid			The identifier for this catalog item.
//array(0,2)	= STRING  url         	Url of eurl page to display for this item. Note: If
//										three items have the same url then this field is filled
//										in for the first item and blank for the remaining two
//										items.
HRESULT MakeEulaArray(
	PSELECTITEMINFO pInfo,	//Pointer to selected item information array.
	int iTotalItems,		//Total selected items
	VARIANT *pvaVariant		//Pointer to returned safe array.
	)
{
	USES_CONVERSION;

	Varray<PUID>		puids;	//array of selected item puids.
	HRESULT				hr;
	LPVARIANT			rgElems;
	LPSAFEARRAY			psa;
	SAFEARRAYBOUND		rgsabound[2];
	PINVENTORY_ITEM		pItem;
	PWU_VARIABLE_FIELD	pvTmp;
	int					i;
	int					n;
	int					iEulaNumber;
	int					iEulaArrayIndex;
	char				szLastEula[64];
	char				szCurrEula[64];
	char				szFullEula[MAX_PATH];
	BOOL				bEulaChanged;
	CCatalog * pCatalog;

	if (!pvaVariant || !pInfo)
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	hr = NOERROR;

	//Copy puid array so we can overwrite it
	for(i=0; i<iTotalItems; i++)
	{
		if (pInfo[i].bInstall)
			puids[i] = pInfo[i].puid;
		else
			puids[i] = WU_NO_LINK;
	}

	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= 0;

	//Count the number of eula's to return
	for(i=0; i<iTotalItems; i++)
	{
		if (puids[i] != WU_NO_LINK)
		{
			if (!g_v3state.GetCatalogAndItem(puids[i], &pItem, NULL))
			{
				continue;
			}

			if (pItem->pd->pv->Find(WU_DESC_EULA))
				rgsabound[0].cElements++;
		}
	}

	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 3;

	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if ( !psa )
		return E_OUTOFMEMORY;

	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	iEulaNumber = -1;
	iEulaArrayIndex = 0;

	szLastEula[0] = '\0';

	for(i = 0; i < iTotalItems; i++)
	{
		//if this record has not already been processed
		if (puids[i] != WU_NO_LINK)
		{
			if (!g_v3state.GetCatalogAndItem(puids[i], &pItem, &pCatalog))
			{
				continue;
			}

			//if there is not a Eula for this item then continue to next item.
			if (!(pvTmp = pItem->pd->pv->Find(WU_DESC_EULA)))
				continue;

			//if this is the default eula (eula.htm), there'll be
			//no data in the field
			if (sizeof(WU_VARIABLE_FIELD) == pvTmp->len || !*(pvTmp->pData)) // second test is for 64-bit, since we pad this structure to fix alignment problems
			{
				strcpy(szCurrEula, "eula.htm");
			}
			else
			{
				strcpy(szCurrEula, (LPCSTR) pvTmp->pData);
			}

			bEulaChanged = (_stricmp(szLastEula, szCurrEula) != 0);

			if (bEulaChanged)
			{
				iEulaNumber++;
				strcpy(szLastEula, szCurrEula);

				//the actual EULA filename is of the form PLAT_LOC_fn
				sprintf(szFullEula, "/eula/%d_%s_%s", pCatalog->GetPlatform(), T2A(pCatalog->GetBrowserLocaleSZ()), szCurrEula);
			}
			
			try
			{
				AddSafeArrayRecord(rgElems, iEulaArrayIndex, (int)rgsabound[0].cElements, "%d%d%s",
					iEulaNumber, puids[i], bEulaChanged ? A2W(szFullEula) : L"");
			}
			catch(HRESULT hr)
			{
				// cleanup
				for (n = iEulaArrayIndex-1; n >= 0; n--)
					DeleteSafeArrayRecord(rgElems, n, (int)rgsabound[0].cElements, "%d%d%s");

				SafeArrayUnaccessData(psa);

				VariantInit(pvaVariant);

				throw hr;
			}

			//Set to next safe array index
			iEulaArrayIndex++;

		}
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}

//This function makes the InstallStatus safe array.

//array(0, 0)	= NUMBER puid	The identifier for this record.
//array(0,1)	= NUMBER Status	This field is one of the following:
//		ITEM_STATUS_SUCCESS			The package was installed successfully.
//		ITEM_STATUS_INSTALLED_ERROR	The package was Installed however there were some minor problems that did not prevent installation.
//		ITEM_STATUS_FAILED			The packages was not installed.
//array(0,2)	= NUMBER Error	Error describing the reason that the package did not install if the Status field is not equal to SUCCESS.
HRESULT MakeInstallStatusArray(
	PSELECTITEMINFO	pInfo,	//Pointer to selected item information.
	int iTotalItems,		//Total selected items
	VARIANT *pvaVariant		//Pointer to returned safe array.
	)
{
	HRESULT			hr;
	LPVARIANT		rgElems;
	LPSAFEARRAY		psa;
	SAFEARRAYBOUND	rgsabound[2];
	int				i;
	Varray<SELECTITEMINFO> vNonHidden;		
	int	cNonHidden = 0;


	if (!pvaVariant)
		return E_INVALIDARG;

	VariantInit(pvaVariant);

	//
	// copy the nonhidden items into a new varray.  we have to make a new copy since the SELECTEDITEMS
	// structure does not tell us if the item is hidden.  So we need to call the GetCatalogAndItem call
	// to get the pointer to the item and check the hidden state
	//
	for (i = 0; i < iTotalItems; i++)
	{
		PINVENTORY_ITEM	pItem;

		if (g_v3state.GetCatalogAndItem(pInfo[i].puid, &pItem, NULL))
		{
			if (!pItem->ps->bHidden)
			{	
				vNonHidden[cNonHidden] = pInfo[i];
				cNonHidden++;
			}
		}		
	}


	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= cNonHidden;

	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 3;

	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if ( !psa )
		return E_OUTOFMEMORY;

	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;

	hr = NOERROR;

	//For each item in puid array get download size and time
	for (i = 0; i < cNonHidden; i++)
	{
		// array(0,0) = NUMBER puid
		// array(0,1) = NUMBER Status
		// array(0,2) = NUMBER Error
		try
		{
			AddSafeArrayRecord(rgElems, i, (int)rgsabound[0].cElements, "%d%d%d",
				vNonHidden[i].puid, vNonHidden[i].iStatus, vNonHidden[i].hrError);
		}
		catch(HRESULT hr)
		{
			for (; i; i--)
				DeleteSafeArrayRecord(rgElems, i, (int)rgsabound[0].cElements, "%d%d%d");

			SafeArrayUnaccessData(psa);

			VariantInit(pvaVariant);

			throw hr;
		}
	}

	SafeArrayUnaccessData(psa);

	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;

	return NOERROR;
}


//This function reads and converts our internal Install History into a safe array
//format for the VBScript caller.
//
//array(0,0) = NUMBER puid
//array(0,1) = STRING date
//array(0,2) = STRING time
//array(0,3) = STRING item title
//array(0,4) = STRING version string
//array(0,5) = NUMBER flags = INSTALL_OPERATION, REMOVE_OPERATION, OPERATION_ERROR, OPERATION_SUCCESS, OPERATION_STARTED
//array(0,6) = NUMBER error code if OPERATION_ERROR
HRESULT MakeInstallHistoryArray(
	Varray<HISTORYSTRUCT> &History,	//History Array
	int iTotalItems,		//Total items in history array.
	VARIANT *pvaVariant		//Pointer to returned safe array.
	)
{
	USES_CONVERSION;

	DWORD			dwFlags;
	HRESULT			hr;
	LPVARIANT		rgElems;
	LPSAFEARRAY		psa;
	SAFEARRAYBOUND	rgsabound[2];
	int				i;

	if (!pvaVariant)
		return E_INVALIDARG;
	
	VariantInit(pvaVariant);
	
	rgsabound[0].lLbound	= 0;
	rgsabound[0].cElements	= iTotalItems;
	
	rgsabound[1].lLbound	= 0;
	rgsabound[1].cElements	= 7;
	
	psa = SafeArrayCreate(VT_VARIANT, 2, rgsabound);
	if (!psa)
		return E_OUTOFMEMORY;
	
	//Plug references to the data into the SAFEARRAY
	if (FAILED(hr = SafeArrayAccessData(psa,(LPVOID*)&rgElems)))
		return hr;
	
	hr = NOERROR;
	
	//For each item in puid array get download size and time
	for (i = 0; i < iTotalItems; i++)
	{
		if (History[i].bV2)
		{
			// no flags for V2
			dwFlags = 0;
		}
		else
		{
			// flags for V3
			if (History[i].bInstall)
			{
				dwFlags = INSTALL_OPERATION;
			}
			else
			{
				dwFlags = REMOVE_OPERATION;
			}
			
			if (History[i].bResult == OPERATION_SUCCESS)
			{
				dwFlags |= OPERATION_SUCCESS;
			}
			else if (History[i].bResult == OPERATION_STARTED)
			{
				dwFlags |= OPERATION_STARTED;
			}
			else
			{
				dwFlags |= OPERATION_ERROR;
			}
		}

		try
		{
			AddSafeArrayRecord(rgElems, i, (int)rgsabound[0].cElements, "%d%s%s%s%s%d%d",
				History[i].puid, A2W(History[i].szDate), A2W(History[i].szTime), A2W(History[i].szTitle), A2W(History[i].szVersion), 
				dwFlags, (int)History[i].hrError);
			
		}
		catch(HRESULT hr)
		{
			for (; i; i--)
				DeleteSafeArrayRecord(rgElems, i, (int)rgsabound[0].cElements, "%d%s%s%s%s%d%d");
			
			SafeArrayUnaccessData(psa);
			
			VariantInit(pvaVariant);
			
			throw hr;
		}
	}
	
	SafeArrayUnaccessData(psa);
	
	V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pvaVariant) = psa;
	
	return NOERROR;
}


//This function converts the internal status for a catalog item into the formated that is
//returned by GetCatalog() and GetCatalogItem() safe arrays.
int GetItemReturnStatus(PINVENTORY_ITEM pItem)
{
	int		status = 0;
	BYTE	itemFlags = 0;


	if (pItem->ps->bHidden)
	{
		if (pItem->ps->dwReason == WU_STATE_REASON_PERSONALIZE)
			status |= GETCATALOG_STATUS_PERSONALIZE_HIDDEN;
		else
			status |= GETCATALOG_STATUS_HIDDEN;
	}
	
	if (pItem->ps->bChecked )
		status |= GETCATALOG_STATUS_SELECTED;
	
	if (pItem->pd->flags & DESCRIPTION_FLAGS_NEW)
		status |= GETCATALOG_STATUS_NEW;
	
	if (pItem->pd->flags & DESCRIPTION_FLAGS_POWER)
		status |= GETCATALOG_STATUS_POWER;
	
	if (pItem->pd->flags & DESCRIPTION_FLAGS_REGISTRATION)
		status |= GETCATALOG_STATUS_REGISTRATION;
	
	if (pItem->pd->flags & DESCRIPTION_FLAGS_COOL)
		status |= GETCATALOG_STATUS_COOL;
	
	if (pItem->pd->flags & DESCRIPTION_EXCLUSIVE)
		status |= GETCATALOG_STATUS_EXCLUSIVE;

	if (pItem->pd->flags & DESCRIPTION_WARNING_SCARY)
		status |= GETCATALOG_STATUS_WARNING_SCARY;

	pItem->GetFixedFieldInfo(WU_ITEM_FLAGS, &itemFlags);
	
	if (itemFlags & WU_PATCH_ITEM_FLAG )
		status |= GETCATALOG_STATUS_PATCH;
	
	if (pItem->recordType == WU_TYPE_SECTION_RECORD )
		status |= GETCATALOG_STATUS_SECTION;
	else if (pItem->recordType == WU_TYPE_SUBSECTION_RECORD )
		status |= GETCATALOG_STATUS_SUBSECTION;
	else if (pItem->recordType == WU_TYPE_SUBSUBSECTION_RECORD )
		status |= GETCATALOG_STATUS_SUBSUBSECTION;
	else
	{
		//flag the current install status
		switch( pItem->ps->state )
		{
		case WU_ITEM_STATE_INSTALL:
			status |= GETCATALOG_STATUS_INSTALL;
			break;
		case WU_ITEM_STATE_UPDATE:
			status |= GETCATALOG_STATUS_UPDATE;
			break;
		case WU_ITEM_STATE_PRUNED:
			break;
		case WU_ITEM_STATE_CURRENT:
			status |= GETCATALOG_STATUS_CURRENT;
			break;
		default:
			status |= GETCATALOG_STATUS_UNKNOWN;
			break;
		}
	}

	return status;
}



int CalcDownloadTime(int size, int downloadTime)
{
	if (size != 0)
	{
		DWORD dwBPS = CConnSpeed::BytesPerSecond();
		if (dwBPS != 0)
		{
			// calculate size (in KB) based on modem speed
			downloadTime = size * 1024 / dwBPS;
		}
		else
		{
			// time in the inventory list is in minutes, convert it to seconds
			downloadTime *= 60;
		}
	}
	else
		downloadTime = 0;
		
	if (downloadTime == 0)
		downloadTime = 1;

	return downloadTime;
}




//This function checks to see if the inventory item matches the filter specification
//supplied by the user in the GetCatalog function.
BOOL FilterCatalogItem(
	PINVENTORY_ITEM pItem,	//Pointer to inventory item to be checked.
	long lFilters			//Filter specification to check item against.
	)
{
	BYTE	itemFlags = 0;
	
	pItem->GetFixedFieldInfo(WU_ITEM_FLAGS, &itemFlags);

	//
	// we never return pruned items
	//
	if ( pItem->ps->state == WU_ITEM_STATE_PRUNED )
		return FALSE;

	//
	// BEGIN special cases with WU_ALL_ITEMS (=0)
	//
	if (lFilters == WU_ALL_ITEMS)
	{
		if (pItem->ps->bHidden)
			return FALSE;
		else
			return TRUE;
	}
	if ((lFilters == WU_NO_DEVICE_DRIVERS))   //WU_ALL_ITEMS | WU_NO_DEVICE_DRIVERS
	{
		if (pItem->recordType == WU_TYPE_CDM_RECORD || pItem->recordType == WU_TYPE_CDM_RECORD_PLACE_HOLDER)
			return FALSE;
		else
			return TRUE;
	}
	if ((lFilters == WU_PERSONALIZE_HIDDEN))   //WU_ALL_ITEMS | WU_PERSONALIZE_HIDDEN
	{
		if (pItem->ps->bHidden && pItem->ps->dwReason != WU_STATE_REASON_PERSONALIZE)
			return FALSE;
		else
			return TRUE;
	}
	//
	// END special case with WU_ALL_ITEMS
	//

	// Special case for WU_UPDATE_ITEMS (used by AutoUpdate)
	// This will not return sections, and will return drivers
	// only if there's no driver currently installed for the device
	if (lFilters == WU_UPDATE_ITEMS)
	{
		if (pItem->ps->bHidden)
			return FALSE;

		if (WU_TYPE_CDM_RECORD_PLACE_HOLDER == pItem->recordType)
			return FALSE;

		if ((WU_TYPE_ACTIVE_SETUP_RECORD == pItem->recordType)
		  &&
			(
			WU_ITEM_STATE_INSTALL == pItem->ps->state || 
			WU_ITEM_STATE_UPDATE == pItem->ps->state
		))
			return TRUE;

		if ((WU_TYPE_CDM_RECORD == pItem->recordType ||
			WU_TYPE_RECORD_TYPE_PRINTER == pItem->recordType)
		  &&
			(
			WU_ITEM_STATE_INSTALL == pItem->ps->state
		))
			return TRUE;

		return FALSE;
	}
	// end case for WU_UPDATE_ITEMS

	if ((lFilters & WU_NO_DEVICE_DRIVERS))
	{
		if (pItem->recordType == WU_TYPE_CDM_RECORD || pItem->recordType == WU_TYPE_CDM_RECORD_PLACE_HOLDER)
			return FALSE;
	}
	if ( (lFilters & WU_PATCH_ITEMS) && (itemFlags & WU_PATCH_ITEM_FLAG) )
		return TRUE;

	if ( (lFilters & WU_HIDDEN_ITEMS) && pItem->ps->bHidden )
		return TRUE;

	if ( (lFilters & WU_SELECTED_ITEMS) && pItem->ps->bChecked )
		return TRUE;

	if ( (lFilters & WU_NOT_SELECTED_ITEMS) && !pItem->ps->bChecked )
		return TRUE;

	if ( (lFilters & WU_NEW_ITEMS) && (pItem->pd->flags & DESCRIPTION_FLAGS_NEW) )
		return TRUE;
	
	if ( (lFilters & WU_POWER_ITEMS) && (pItem->pd->flags & DESCRIPTION_FLAGS_POWER) )
		return TRUE;

	if ( (lFilters & WU_REGISTER_ITEMS) && (pItem->pd->flags & DESCRIPTION_FLAGS_REGISTRATION) )
		return TRUE;

	if ( (lFilters & WU_COOL_ITEMS) && (pItem->pd->flags & DESCRIPTION_FLAGS_COOL) )
		return TRUE;

	if ( (lFilters & WU_EUAL_ITEMS) && pItem->pd->pv->Find(WU_DESC_EULA) )
		return TRUE;

	if ( (lFilters & WU_PATCH_ITEMS) && (itemFlags & WU_CRITICAL_UPDATE_ITEM_FLAG) )
		return TRUE;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _STDAFX_H
#define _STDAFX_H

#define STRICT


#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <objsafe.h>

extern CComModule _Module;

#undef _MAC
#include <atlcom.h>


#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\wuv3is.cpp ===
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
// WUV3IS.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f WUV3ISps.mk in the project directory.

#undef _MAC
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "WUV3IS.h"

#include "WUV3IS_i.c"
#include "CV3.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CV3, CCV3)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}

HMODULE GetModule()
{
	return _Module.GetModuleInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\template.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    template.h
//
//  Purpose: DHTML template support
//
//======================================================================= 

#ifndef _TEMPLATE_H
#define _TEMPLATE_H

#include "stdafx.h"
#include "WUV3IS.h"
#include <stdio.h>
#define USEWUV3INCLUDES
#include <wuv3.h>
#undef USEWUV3INCLUDES
#include "safearr.h"

//
// we are currently not using this feature
// the code has been wrapped in this the following define
//
#undef HTML_TEMPLATE

#ifdef HTML_TEMPLATE

HRESULT MakeCatalogHTML(CCatalog *pCatalog, long lFilters, VARIANT *pvaVariant);
 
class CParseTemplate
{
public:
	CParseTemplate(LPCSTR pszTemplate);
	~CParseTemplate();

	BOOL Invalid()
	{
		return m_bInvalid;
	}

	BOOL MakeItemString(PINVENTORY_ITEM	pItem);

	LPCSTR GetString()
	{
		return m_pszStrBuf;
	}

	DWORD GetStringLen()
	{
		return m_cStrUsed;
	}


private:

	enum FRAG_TYPE {FRAG_STR, FRAG_REPLACE, FRAG_CONDITION};
	enum {FRAG_EXPAND = 16, STR_EXPAND = 2048};

	struct FRAGMENT
	{
		FRAG_TYPE FragType;
		char chCode;
		DWORD dwVal;
		LPSTR pszStrVal;
		DWORD dwStrLen;
	};

	LPSTR m_pTemplateBuf;
	BOOL m_bInvalid;

	// fragment
	FRAGMENT* m_pFrag;
	int m_cFragAlloc;
	int m_cFragUsed;
	
	// internal string
	LPSTR m_pszStrBuf;
	DWORD m_cStrAlloc;
	DWORD m_cStrUsed;


	CParseTemplate() {}
	void AddFrag(FRAGMENT* pfrag);

	void ClearStr();
	void AppendStr(LPCSTR pszStr, DWORD cLen);
};

#endif


#endif // _TEMPLATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\template.cpp ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    template.cpp
//
//  Purpose: DHTML template support
//
//  History: 4/3/99   YAsmi    Created
//
//======================================================================= 

#include "template.h"

// we are currently not using the templates feature
// the code for templates is wrapped in HTML_TEMPLATE define 
#ifdef HTML_TEMPLATE

//
// CParseTemplate class
//

CParseTemplate::CParseTemplate(LPCSTR pszTemplate)
	: m_pFrag(NULL),
	  m_cFragAlloc(0),
	  m_cFragUsed(0),
	  m_bInvalid(FALSE),
	  m_pszStrBuf(NULL),
	  m_cStrAlloc(0),
	  m_cStrUsed(0)
{
	LPCSTR pszReplacementCodes = "012345";
	LPCSTR pszConditionalCodes = "6789AB";
	
	LPSTR pszNext;
	FRAGMENT frag;
	BOOL bInvalid = FALSE;

	// copy the template in our buffer
	m_pTemplateBuf = _strdup(pszTemplate);

	// 
	// parse the template
	//
	pszNext = m_pTemplateBuf;
	for (;;)
	{
		LPSTR p = strchr(pszNext, '^');

		ZeroMemory(&frag, sizeof(frag));

		if (p != NULL)
		{
			// delimiter found check to see if next character is a delimiter so we can escape it
			if (*(p + 1) == '^')
			{
				// escape it
				p++;

				// insert a null to make the preceeding string a null terminated string
				*p = '\0';
				frag.FragType = FRAG_STR;
				frag.pszStrVal = pszNext;

				AddFrag(&frag);
			}
			else
			{
				//
				// we have a non escape character following the delimiter
				// add the preceeding string fragment and process the token fragment
				//

				// insert a null to make the preceeding string a null terminated string
				*p = '\0';
				frag.FragType = FRAG_STR;
				frag.pszStrVal = pszNext;
				
				AddFrag(&frag);
				
				// we are at the begining of a token, skip to code
				p++;
				
				if (strchr(pszReplacementCodes, *p) != NULL)
				{
					// we have a replacement code
					frag.FragType = FRAG_REPLACE;
					frag.chCode = *p;  
				}
				else if (strchr(pszConditionalCodes, *p) != NULL)
				{
					// we have a conditional code, read the paranthesis
					frag.FragType = FRAG_CONDITION;
					frag.chCode = *p;  
					frag.dwVal = 0;
					frag.pszStrVal = NULL;  // if not changed in the following code we have an error

					// skip over code
					p++;

					if (*(p++) == '(')
					{
						// read numeric parameter between paranthesis
						while (isdigit(*p))
						{
							frag.dwVal = frag.dwVal * 10 + (DWORD)(*(p++) - '0');
						}

						if (*(p++) == ')')
						{
							if (*(p++) == '^')
							{
								// we are looking at the begining of the replace value, skip to next delimiter
								LPSTR p2 = p;
								p = strchr(p2, '^');
								if (p != NULL)
								{
									// we now have complete syntax of condition token
									*p = '\0';
									frag.pszStrVal = p2;
								}
								
							}							
						}
					}

					// if we did not set pszStrVal, then we have an invalid conditional token
					if (frag.pszStrVal == NULL)
					{
						bInvalid = TRUE;
					}
				}
				else
				{
					// the character following the delimter was not valid
					bInvalid = TRUE;
				}
				
				// add the token faragment, we dont check for invalid before adding 
				// if invalid, everything is discard in the end anyway
				AddFrag(&frag);
		
			}  // not escaped delimter

			// now, we are looking at the end of the token, assign pszNext to process
			// the next fragment
			pszNext = ++p;

			// exit the loop if we are at the end of the template or there was an error
			if (bInvalid || (*p == '\0'))
			{
				break;
			}
			
		} // delimiter found
		else
		{
			// delimiter not found, copy the rest of string as FRAG_STR
			frag.FragType = FRAG_STR;
			frag.pszStrVal = pszNext;

			AddFrag(&frag);

			// we are done, exit loop
			break;
		}

	} // for loop

	m_bInvalid = bInvalid;
	
}


CParseTemplate::~CParseTemplate()
{
	free(m_pTemplateBuf);
	if (m_pFrag != NULL)
		free(m_pFrag);
	if (m_pszStrBuf != NULL)
		free(m_pszStrBuf);

}


void CParseTemplate::AddFrag(FRAGMENT* pfrag)
{
	if ((m_cFragUsed + 1) > m_cFragAlloc)
	{
		// not enough entries allocated, allocate current count + a delta
		FRAGMENT* pNew = (FRAGMENT*)malloc((m_cFragAlloc + FRAG_EXPAND) * sizeof(FRAGMENT));
								
		if (m_pFrag != NULL)
		{
			memcpy(pNew, m_pFrag, m_cFragAlloc * sizeof(FRAGMENT));
			free(m_pFrag);
		}
		m_pFrag = pNew;
		m_cFragAlloc += FRAG_EXPAND;
	}

	// fill in the length field
	if (pfrag->pszStrVal != NULL)
		pfrag->dwStrLen = strlen(pfrag->pszStrVal);

	memcpy(&m_pFrag[m_cFragUsed++], pfrag, sizeof(FRAGMENT));

}

void CParseTemplate::ClearStr()
{
	if (m_pszStrBuf == NULL)
		return;

	*m_pszStrBuf = '\0';
	m_cStrUsed = 0;
}


void CParseTemplate::AppendStr(LPCSTR pszStr, DWORD cLen)
{
	if (cLen == 0)
	{
		return;
	}

	if ((m_cStrUsed + cLen + 1) > m_cStrAlloc)
	{
		// not enough memory allocated, allocate current + delta
		LPSTR pNew = (LPSTR)malloc(m_cStrAlloc + STR_EXPAND);
								
		if (m_pszStrBuf != NULL)
		{
			memcpy(pNew, m_pszStrBuf, m_cStrAlloc);
			free(m_pszStrBuf);
		}
		else
		{
			*pNew = '\0';
			m_cStrUsed = 0;
		}
		m_pszStrBuf = pNew;
		m_cStrAlloc += STR_EXPAND;
	}

	// append the string
	strcpy((m_pszStrBuf + m_cStrUsed), pszStr);
	m_cStrUsed += cLen;
}



//	^0       PUID
//	^1       Title
//	^2       Description
//	^3       Size number in KB
//	^4       Formated download time (1 hr 2 min  OR  < 1 min)
//	^5       Line break
//	^6(n)^d^ Got read-this-page?
//	           n=0 -> if yes, insert DHTML d (@ in d replaced with URL)
//	^7(n)^d^ Can be uninstalled?
//	           n=0 -> if yes, insert DHTML d
//	^8(n)^d^ Is installed?
//	           n=0 -> if yes, insert DHTML d
//	^9(n)^d^ Is item currently selected (checked)?
//	           n=0 -> if yes, insert DHTML d
//	^A(n)^d^ Does section has items under it?
//	           n=0 -> if yes, insert DHTML d
//	^B(n)^d^ Is icon flag on?
//	           n=4 -> if 'new' flag is set, insert DHTML d
//	           n=8 -> if 'power' flag is set, insert DHTML d
//	           n=16 -> if 'registration' flag is set, insert DHTML d
//	           n=32 -> if 'cool' flag is set, insert DHTML d
//	           n=64 -> if 'patch' flag is set, insert DHTML d
BOOL CParseTemplate::MakeItemString(PINVENTORY_ITEM	pItem)
{
	FRAGMENT frag;

	ClearStr();

	if (m_bInvalid)
	{
		return FALSE;
	}

	for (int i = 0; i < m_cFragUsed; i++)
	{
		frag = m_pFrag[i];

		if (frag.FragType == FRAG_STR)
		{
			// 
			// just a string, copy it as is
			//
			AppendStr(frag.pszStrVal, frag.dwStrLen);
		}
		
		else if (frag.FragType == FRAG_REPLACE)
		{
			//
			// replacement token
			// 
			switch (frag.chCode)
			{
				case '0': 
					// puid
					BLOCK 
					{
						PUID puid;
						char szPuid[16];

						pItem->GetFixedFieldInfo(WU_ITEM_PUID, (PVOID)&puid);
						_itoa(puid, szPuid, 10);
						AppendStr(szPuid, strlen(szPuid));
					}
					break;
					
				case '1':
					// title
					BLOCK
					{
						PWU_VARIABLE_FIELD pvar;
						if (pvar = pItem->pd->pv->Find(WU_DESCRIPTION_TITLE))
						{
							LPCSTR pszTitle = (LPCSTR)pvar->pData;
							AppendStr(pszTitle, strlen(pszTitle));
						}
					}
					break;
					
				case '2':
					// description
					BLOCK
					{
						PWU_VARIABLE_FIELD pvar;
						if (pvar = pItem->pd->pv->Find(WU_DESCRIPTION_DESCRIPTION))
						{
							LPCSTR pszDesc = (LPSTR)pvar->pData;
							AppendStr(pszDesc, strlen(pszDesc));
						}
					}
					break;
					
				case '3':
					// size 
					BLOCK
					{
						char szBuf[16];

						_itoa(pItem->pd->size, szBuf, 10);
						AppendStr(szBuf, strlen(szBuf));
					}
					break;
					
				case '4':
					// download time
					BLOCK
					{
						DWORD dwSecsTotal = pItem->pd->downloadTime;
						DWORD dwSecs = dwSecsTotal % 60;
						DWORD dwMinutes = (dwSecsTotal % 3600) / 60;
						DWORD dwHours = dwSecsTotal / 3600;
						char szBuf[128];
						int cBuf = 0;

						if (dwHours == 0)
						{
							if (dwMinutes == 0)
								cBuf = sprintf(szBuf, GetLocStr(IDS_PROG_TIME_SEC), dwSecs);
							else
								cBuf = sprintf(szBuf, GetLocStr(IDS_PROG_TIME_MIN), dwMinutes);
						}
						else
						{
							cBuf = sprintf(szBuf, GetLocStr(IDS_PROG_TIME_HRMIN), dwHours, dwMinutes);
						}
						AppendStr(szBuf, cBuf);
					}
					break;
					
				case '5':
					// line break
					BLOCK
					{
						LPCSTR pszNL = "\r\n";
						AppendStr(pszNL, strlen(pszNL));
					}
					break;
			}


		}
		else if (frag.FragType == FRAG_CONDITION)
		{
			//
			// conditional token
			// 
			switch (frag.chCode)
			{
				case '6': 
					// read this first
					BLOCK 
					{
						PWU_VARIABLE_FIELD pvar;
						if (pvar = pItem->pd->pv->Find(WU_DESCRIPTION_READTHIS_URL))
						{
							LPCSTR pszReadThisURL = (LPCSTR)pvar->pData;
							// TODO: replace @ with the URL in a copy of pszStrVal
							AppendStr(frag.pszStrVal, frag.dwStrLen);
						}
					}
					break;

				case '7': 
					// Can be uninstalled
					BLOCK 
					{
						BOOL bUninstall = FALSE;
						if (pItem->recordType == WU_TYPE_CDM_RECORD)
						{
							bUninstall = TRUE;
						}
						else if (pItem->pd->pv->Find(WU_DESCRIPTION_UNINSTALL_KEY))
						{
							bUninstall = TRUE;
						}

						if (bUninstall)
						{
							AppendStr(frag.pszStrVal, frag.dwStrLen);
						}
					}
					break;

				case '8': 
					// Is installed
					BLOCK 
					{
					}
					break;

				case '9': 
					// currently selected
					BLOCK 
					{
					}
					break;

				case 'A': 
					// section has items
					BLOCK 
					{
					}
					break;

				case 'B': 
					// icon flags
					BLOCK 
					{
					}
					break;

			}
		}

	}
	
	return TRUE;
}



HRESULT MakeCatalogHTML(
	CCatalog* pCatalog,	
	long lFilters,	
	VARIANT* pvaVariant	
	)
{
	LPCSTR pszItemTemp = GetTemplateStr(IDS_TEMPLATE_ITEM);
	LPCSTR pszSecTemp = GetTemplateStr(IDS_TEMPLATE_SEC);
	LPCSTR pszSubsecTemp = GetTemplateStr(IDS_TEMPLATE_SUBSEC);
	LPCSTR pszSubsubsecTemp = GetTemplateStr(IDS_TEMPLATE_SUBSUBSEC);

	VariantInit(pvaVariant);

	if (pszItemTemp == NULL || pszSecTemp == NULL || pszSubsecTemp == NULL || pszSubsubsecTemp == NULL)
	{
		// all templates are not specified 
		return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
	}

	//
	// create template objects
	//
	CParseTemplate ItemTemp(pszItemTemp);
	CParseTemplate SecTemp(pszSecTemp);
	CParseTemplate SubsecTemp(pszSubsecTemp);
	CParseTemplate SubsubsecTemp(pszSubsubsecTemp);

	if (ItemTemp.Invalid() || SecTemp.Invalid() || SubsecTemp.Invalid() || SubsubsecTemp.Invalid())
	{
		// all templates are not valid
		return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
	}
	
	PINVENTORY_ITEM	pItem;
	LPSTR pszHTM;
	int	lenHTM = 0;

	pszHTM = (char*)malloc(200 * 1024);
	pszHTM[0] = '\0';

	for (int i = 0; i < pCatalog->GetHeader()->totalItems; i++)
	{
		if (NULL == (pItem = pCatalog->GetItem(i)))
		{
			continue;
		}
		if (!FilterCatalogItem(pItem, lFilters))
			continue;

		if (!pItem->pd)
			continue;

		//
		// based on item type select the correct template to create the string from
		//
		LPCSTR pszGenStr = NULL;
		int cGenLen = 0;

		if (pItem->recordType == WU_TYPE_SECTION_RECORD)
		{
			SecTemp.MakeItemString(pItem);
			pszGenStr = SecTemp.GetString();
			cGenLen = SecTemp.GetStringLen();
		}
		else if (pItem->recordType == WU_TYPE_SUBSECTION_RECORD)
		{
			SubsecTemp.MakeItemString(pItem);
			pszGenStr = SubsecTemp.GetString();
			cGenLen = SubsecTemp.GetStringLen();
		}
		else if (pItem->recordType == WU_TYPE_SUBSUBSECTION_RECORD)
		{
			SubsubsecTemp.MakeItemString(pItem);
			pszGenStr = SubsubsecTemp.GetString();
			cGenLen = SubsubsecTemp.GetStringLen();
		}
		else
		{
			ItemTemp.MakeItemString(pItem);
			pszGenStr = ItemTemp.GetString();
			cGenLen = ItemTemp.GetStringLen();
		}

		//
		// append the generated to string to the main string
		//
		strcpy(pszHTM + lenHTM, pszGenStr);
		lenHTM += cGenLen;
	}

	//
	// return the string in buffer
	//
	V_VT(pvaVariant) = VT_BSTR;
	pvaVariant->bstrVal = SysAllocString(T2OLE(pszHTM));

	free(pszHTM);

	return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\common.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################
#
# Common include file 'sources' files in the getconn project.
#
#
# Required definitions:
#
#     GETCONN_DIR
#        Path to root containing this inc file.
#
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     USE_LEGO
#        Define lego macros
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT.
#
#     TARGET_BOTH
#        Build component so it will run in both environments.
#

!if !defined(GETCONN_DIR)
!error  GETCONN_DIR must be defined in sources file
!endif

# Set the IE version
#WIN32_IE_VERSION=0x0500

#
# In case you have an old makefile.def
#
!if "$(_OBJ_DIR)" == ""
_OBJ_DIR        = obj
!endif
!if "$(O)" == ""
O               = $(_OBJ_DIR)\$(TARGET_DIRECTORY)
!endif

#
# Set private paths
#

INCLUDES        = .;$(GETCONN_DIR)\inc;$(GETCONN_DIR)\mapi\inc;$(SDK_INC_PATH);$(INCLUDES)

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to NT libs
# USE_NOLIBS      = 1
NO_NTDLL =1

!if !defined(SXS_MANIFEST)
#!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 0

#  Since CHICAGO_PRODUCT is defined, we need to define WIN32_DEFINE correctly
#WIN32_DEFINE    = -DWIN32=100 -D_WIN32_WINNT=0x0400
!endif

#CBSTRING        = -cbstring
# RegisB, 05/30/97:  BryanT strongly recommends to remove the CBSTRING entry

UMTYPE          = windows
#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif
#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif

# Backwards compatibility with some personal command files
!if "$(SHELLDBG)" == "1"
C_DEFINES       = $(C_DEFINES) -DDEBUG -DFULL_DEBUG

!elseif "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG

!endif

# Assume we're building for Nashville only right now
C_DEFINES       = $(C_DEFINES) -DNASHVILLE

# This define helps us distinguish our development environment
C_DEFINES       = $(C_DEFINES) -DWINNT_ENV

# IE40-only features
!ifdef FEATURE_IE40
C_DEFINES       = $(C_DEFINES) -DFEATURE_IE40 -DNASH
!endif
# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

#
# Additional linker flags
#
#Not Needed

LINKER_FLAGS    = $(LINKER_FLAGS) -map
!if !$(IA64)
386_STDCALL     = 2
!endif

DEFBASEADDR     = 0x60000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\windows.com\wuv3\wuv3is\testctl\testctl.cpp ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <shlwapi.h>
#include <autoupd.h>
#include <malloc.h>
#include <wustl.h>
#include <download.h>
#include <tchar.h>
#include <comdef.h>

// needed to resolve references to AtlA2WHelper() in cdmlib.lib
#include <atlconv.h>
#define _ASSERTE(expr) ((void)0)
#include <atlconv.cpp>

#define GETCATALOG_STATUS_EXCLUSIVE				(long)0x00008000	//Catalog item is exclusive it cannot be selected with other components.
#define CATLIST_AUTOUPDATE			((DWORD)0x04)

const CLSID CLSID_CV3 = {0xCEBC955E,0x58AF,0x11D2,{0xA3,0x0A,0x00,0xA0,0xC9,0x03,0x49,0x2B}};

bool g_fOnline = true;

// delete the whole subtree starting from current directory
void DeleteNode(LPTSTR szDir)
{
	TCHAR szFilePath[MAX_PATH];
	lstrcpy(szFilePath, szDir);
	PathAppend(szFilePath, TEXT("*.*"));

    // Find the first file
    WIN32_FIND_DATA fd;
    auto_hfindfile hFindFile = FindFirstFile(szFilePath, &fd);
    if(!hFindFile.valid())
		return;
	do 
	{
		if (
			!lstrcmpi(fd.cFileName, TEXT(".")) ||
			!lstrcmpi(fd.cFileName, TEXT(".."))
		) continue;
		
		// Make our path
		lstrcpy(szFilePath, szDir);
		PathAppend(szFilePath, fd.cFileName);

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
			(fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
		) {
			SetFileAttributes(szFilePath, FILE_ATTRIBUTE_NORMAL);
		}

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		{
			DeleteNode(szFilePath);
		}
		else 
		{
			DeleteFile(szFilePath);
		}
	} 
	while (FindNextFile(hFindFile, &fd));// Find the next entry
	hFindFile.release();

	RemoveDirectory(szDir);
}


void RemoveWindowsUpdateDirectory()
{
	TCHAR szWinUpDir[MAX_PATH] = {0};
	auto_hkey hkey;
	if (RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion"), &hkey) == ERROR_SUCCESS)
	{
		DWORD cbPath = MAX_PATH;
		RegQueryValueEx(hkey, _T("ProgramFilesDir"), NULL, NULL, (LPBYTE)szWinUpDir, &cbPath);
	}
	if (szWinUpDir[0] == _T('\0'))
	{
		GetWindowsDirectory(szWinUpDir, sizeof(szWinUpDir));
		szWinUpDir[1] = _T('\0');
		_tcscat(szWinUpDir, _T(":\\Program Files"));
	}	
	_tcscat(szWinUpDir, _T("\\WindowsUpdate"));
	DeleteNode(szWinUpDir);
}

void QueryDownloadFilesCallback( void* pCallbackParam, long puid, LPCTSTR pszURL, LPCTSTR pszLocalFile)
{
	if (g_fOnline)
	{
		wprintf(_T("   %s - %s\n"), pszURL, pszLocalFile);
		// download file
		CDownload download;

		TCHAR szURL[INTERNET_MAX_PATH_LENGTH];
		_tcscpy(szURL, pszURL);
		TCHAR* pszServerFile = _tcsrchr(szURL, _T('/'));
		*pszServerFile = 0;
		pszServerFile ++;

		TCHAR szDir[MAX_PATH];
		_tcscpy(szDir, pszLocalFile);
		*_tcsrchr(szDir, _T('\\')) = 0;

		TCHAR szDirCabs[MAX_PATH];
		_tcscpy(szDirCabs, szDir);
		*_tcsrchr(szDirCabs, _T('\\')) = 0;

		CreateDirectory(szDirCabs, NULL);
		CreateDirectory(szDir, NULL);

		if(!download.Connect(szURL))
		{
			wprintf(_T("      ERROR - Connect(%s) fails\n"), szURL);
			return;
		}
		if(!download.Copy(pszServerFile, pszLocalFile))
		{
			wprintf(_T("      ERROR - Copy(%s, %s) fails\n"), pszServerFile, pszLocalFile);
			return;
		}
	}
	else
	{
		// verify file exists
		auto_hfile hFileOut = CreateFile(pszLocalFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (!hFileOut.valid()) 
			wprintf(_T("   ERROR - %s doesn't exist\n"), pszLocalFile);
		else
			wprintf(_T("   %s\n"), pszLocalFile);
	}
}

void InstallCallback(void* pCallbackParam, long puid, int iStatus, HRESULT hrError)
{
	if (0 == iStatus)
	{
		wprintf(_T("puid %d installed OK \n"), puid);
	}
	else
	{
		wprintf(_T("ERROR - puid %d status %d, error %08X \n"), puid, iStatus, hrError);
	}
}

void DoIt(LPCTSTR pszContentServer)
{
	IAutoUpdate* pAutoUpdate = NULL;
	try
	{
		if (FAILED(CoCreateInstance(CLSID_CV3, NULL, CLSCTX_ALL, __uuidof(IAutoUpdate), (void**)&pAutoUpdate)))
		{
			printf("ERROR - CoCreateInstance() failed.\n");
			throw 0;
		}
		if (FAILED(pAutoUpdate->BuildCatalog(g_fOnline, CATLIST_AUTOUPDATE, _bstr_t(pszContentServer))))
		{
			printf("ERROR - pAutoUpdate->BuildCatalog() failed.\n");
			throw 0;
		}
		VARIANT vCatalogArray;
		if (FAILED(pAutoUpdate->GetCatalogArray(&vCatalogArray)))
		{
			printf("ERROR - pAutoUpdate->GetCatalogArray() failed.\n");
			throw 0;
		}
		bool fHasExclusive = false;
        LPSAFEARRAY psaCatalogArray = V_ARRAY(&vCatalogArray);
		LONG lCatUBound;
        SafeArrayGetUBound(psaCatalogArray, 1, &lCatUBound);
		for(int i = 0; i <= lCatUBound; i++) 
		{
		    long rgIndices[] = { i, 3 };
			VARIANT var;
			
			//Get status
			VariantClear(&var);
			SafeArrayGetElement(psaCatalogArray, rgIndices, &var);
			if (GETCATALOG_STATUS_EXCLUSIVE & var.lVal)
			{
				fHasExclusive = true;

				// Get PUID
				rgIndices[1] = 0;
				VariantClear(&var);
				SafeArrayGetElement(psaCatalogArray, rgIndices, &var);
				if (FAILED(pAutoUpdate->SelectPuid(var.lVal)))
				{
					wprintf(_T("ERROR - pAutoUpdate->SelectPuid() failed.\n"));
					throw 0;
				}
				break;
			}
		}

		if (!fHasExclusive)
		{
			if (FAILED(pAutoUpdate->SelectAllPuids()))
			{
				printf("ERROR - pAutoUpdate->SelectAllPuids() failed.\n");
				throw 0;
			}
		}
		LONG cnPuids = 0;
		LONG* pPuids;
		if (FAILED(pAutoUpdate->GetPuidsList(&cnPuids, &pPuids)))
		{
			printf("ERROR - pAutoUpdate->GetPuidsList() failed.\n");
			throw 0;
		}
		for(LONG l = 0; l < cnPuids; l ++)
		{
			printf("puid %d\n", pPuids[l]);
 			pAutoUpdate->QueryDownloadFiles(pPuids[l], 0, QueryDownloadFilesCallback);
		}

		if (!g_fOnline)
		{
			pAutoUpdate->InstallSelectedPuids(0, InstallCallback);
			pAutoUpdate->CleanupCabsAndReadThis();
		}
	}
	catch(...){}
	if(pAutoUpdate)
		pAutoUpdate->Release();
}

int _cdecl main(int argc, char** argv)
{
	wprintf(_T("--------------- download -----------------------------------\n"));
	CoInitialize(NULL);

	TCHAR szContentServer[INTERNET_MAX_URL_LENGTH] = {0};
	{	
		auto_hkey hkey;
		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update"), 0, KEY_READ, &hkey))
		{
			DWORD dwSize = sizeof(szContentServer);
			RegQueryValueEx(hkey, _T("ContentServer"), 0, 0, (LPBYTE)&szContentServer, &dwSize);
		}
	}
	if (0 == lstrlen(szContentServer))
	{
		wprintf(_T("ERROR - content server is not set.\n"));
		return 0;
	}

	RemoveWindowsUpdateDirectory();
	DoIt(szContentServer);
	g_fOnline = false;
	printf("--------------- install offline ----------------------------\n");
	DoIt(szContentServer);
	CoUninitialize();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icfgnt5\tapi.cpp ===
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <tapi.h>


//
// The code below is stolen from private/net/ras/src/ui/setup/src/tapiconf.cxx
//

#define REGISTRY_INSTALLED_TAPI  SZ("HARDWARE\\DEVICEMAP\\TAPI DEVICES\\")
#define REGISTRY_ALTERNATE_TAPI  SZ("SOFTWARE\\MICROSOFT\\TAPI DEVICES\\")

// note that this definition DOES NOT have trailing \\, because DeleteTree
// doesn't like it.
#define REGISTRY_CONFIGURED_TAPI SZ("SOFTWARE\\MICROSOFT\\RAS\\TAPI DEVICES")

#define TAPI_MEDIA_TYPE          SZ("Media Type")
#define TAPI_PORT_ADDRESS        SZ("Address")
#define TAPI_PORT_NAME           SZ("Friendly Name")
#define TAPI_PORT_USAGE          SZ("Usage")

#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define MAX_DEVICE_TYPES 64

VOID FAR PASCAL RasTapiCallback (HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPTSTR szPortsBuf, 
								BOOL bWithDelay = FALSE);



DWORD
EnumerateTapiModemPorts(DWORD dwBytes, LPTSTR szPortsBuf, BOOL bWithDelay) {
    LINEINITIALIZEEXPARAMS params;
    LINEADDRESSCAPS        *lineaddrcaps ;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               RasLine ;
    HINSTANCE              RasInstance = GetModuleHandle(TEXT("ICFGNT.DLL"));
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i, k ;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    DWORD                  totaladdress = 0;
    TCHAR                  *address ;
    TCHAR                  szregkey[512];
    LONG                   lerr;
    DWORD                  dwApiVersion = HIGH_VERSION;
    LPTSTR                 szPorts = szPortsBuf;

    *szPorts = '\0';
    dwBytes--;

    ZeroMemory(&params, sizeof(params));

    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

    /* the sleep is necessary here because if this routine is called just after a modem
    ** has been added from modem.cpl & unimdm.tsp is running,
    ** then a new modem added doesn't show up in the tapi enumeration.
    */

    //
	// We should not always sleep here - should sleep only if ModemWizard was
	// launched recently  -- VetriV
	//
	if (bWithDelay)
		Sleep(1000L);

    if (lerr = lineInitializeExW (&RasLine,
                                 RasInstance,
                                 (LINECALLBACK) RasTapiCallback,
                                 NULL,
                                 &lines,
                                 &dwApiVersion,
                                 &params))
    {
         return lerr;
    }

    // Go through all lines to see if we can find a modem
    for (i=0; i<lines; i++)
    {  // for all lines we are interested in get the addresses -> ports

       if (lineNegotiateAPIVersion(RasLine, i, LOW_VERSION, HIGH_VERSION, &NegotiatedApiVersion, &extensionid))
       {
           continue ;
       }

       memset (buffer, 0, sizeof(buffer)) ;

       linedevcaps = (LINEDEVCAPS *)buffer ;
       linedevcaps->dwTotalSize = sizeof (buffer) ;

       // Get a count of all addresses across all lines
       //
       if (lineGetDevCapsW (RasLine, i, NegotiatedApiVersion, NegotiatedExtVersion, linedevcaps))
       {
           continue ;
       }

       // is this a modem?
       if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )  {
            // first convert all nulls in the device class string to non nulls.
            //
            DWORD  j ;
            WCHAR *temp ;

            for (j=0, temp = (WCHAR*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset); j<linedevcaps->dwDeviceClassesSize; j++, temp++)
            {
              if (*temp == L'\0')
                 *temp = L' ' ;
            }

            //
            // select only those devices that have comm/datamodem as a device class
            //

            LPWSTR wszClassString = wcsstr((WCHAR*)((CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset), L"comm/datamodem");
            if(wszClassString == NULL)
                continue;
        }

        LONG lRet;
        HLINE lhLine = 0;

        lRet = lineOpen(RasLine, i, &lhLine, dwApiVersion, 0, 0, LINECALLPRIVILEGE_NONE, 0, NULL);
        if(lRet != 0)
            continue;

        LPVARSTRING lpVarString;
        TCHAR buf[1000];
        lpVarString = (LPVARSTRING) buf;
        lpVarString->dwTotalSize = 1000;

        lRet = lineGetID(lhLine, 0, 0, LINECALLSELECT_LINE,
                (LPVARSTRING) lpVarString, TEXT("comm/datamodem/portname"));

        if(lRet != 0)
            continue;

        LPTSTR szPortName;

        if (lpVarString->dwStringSize)
            szPortName = (LPTSTR) ((LPBYTE) lpVarString + ((LPVARSTRING) lpVarString) -> dwStringOffset);
        //
        // Append port name to port list
        //

        UINT len = lstrlen(szPortName) + 1;
        if(dwBytes < len)
            return(ERROR_SUCCESS);

        lstrcpy(szPorts, szPortName);
        szPorts += len;
        *szPorts = '\0';

        if (lhLine) lineClose(lhLine);
    }

    lineShutdown(RasLine);
    return ERROR_SUCCESS ;
}

VOID FAR PASCAL
RasTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
   // dummy callback routine because the full blown TAPI now demands that
   // lineinitialize provide this routine.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icfgnt5\cfgapi.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions.
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004


// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD WINAPI IcfgGetLastInstallErrorText(LPTSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);


//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,
                        DWORD cbEntryName);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetSetAutodialAddress();

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetGetSupportedPlatform(LPDWORD pdwPlatform);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI IcfgStartServices();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icfgnt5\icfg32.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *  7/3/97  ShaunCo Modfied for NT5
 *  5/1/98  donaldm Brought over from NT tree to ICW tree as part of NTCFG95.DLL
 ***************************************************************************/
#define INITGUID
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"
#include "icwunicd.h"

#include <netcfgx.h>


#define REG_DATA_EXTRA_SPACE 255

DWORD g_dwLastError = ERROR_SUCCESS;


ULONG ReleaseObj
(
    IUnknown* punk
)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      szwClientDesc   [in]   See INetCfg::AcquireWriteLock
//      ppszwClientDesc [out]  See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT HrCreateAndInitializeINetCfg
(
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR*     ppszwClientDesc
)
{
    Assert (ppnc);

    // Initialize the output parameter.
    *ppnc = NULL;

    if (ppszwClientDesc)
    {
       *ppszwClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, reinterpret_cast<void**>(&pnc));
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, szwClientDesc,
                                               ppszwClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef ();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
//+---------------------------------------------------------------------------
HRESULT HrUninitializeAndUnlockINetCfg
(
    INetCfg*    pnc
)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
//+---------------------------------------------------------------------------
HRESULT HrUninitializeAndReleaseINetCfg
(
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock
)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class guid of the component to install.
//      pszwComponentId [in] Component id to install.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
//+---------------------------------------------------------------------------
HRESULT HrInstallComponent
(
    INetCfg*                        pnc,
    const GUID*                     pguidClass,
    LPCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc
)
{
    Assert (pnc);
    Assert (pszwComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        OBO_TOKEN OboToken;
        ZeroMemory (&OboToken, sizeof(OboToken));
        OboToken.Type = OBO_USER;


        hr = pncclasssetup->Install (pszwComponentId,
                                     &OboToken, 0, 0, NULL, NULL, ppncc);

        ReleaseObj (pncclasssetup);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgSetInstallSourcePath
//
//  Synopsis:   Set the path that will be used to install system components
//
//  Arguments:  lpszSourcePath - path to be used as install source (ANSI)
//
//  Returns:    HRESULT - S_OK is success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgSetInstallSourcePath(LPTSTR lpszSourcePath)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgSetInstallSourcePath\n");
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateProductSuite
//
//  Synopsis:   Check registry for a particular Product Suite string
//
//  Arguments:  SuiteName - name of product suite to look for
//
//  Returns:    TRUE - the suite exists
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
BOOL
ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    TraceMsg(TF_GENERAL, "ICFGNT: ValidateProductSuite\n");
    //
    // Determine the size required to read registry values
    //
    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    Rslt = RegQueryValueExA(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    if (!Size)
    {
        goto exit;
    }

    ProductSuite = (LPTSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite)
    {
        goto exit;
    }

    //
    // Read ProductSuite information
    //
    Rslt = RegQueryValueExA(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    if (Type != REG_MULTI_SZ)
    {
        goto exit;
    }

    //
    // Look for a particular string in the data returned
    // Note: data is terminiated with two NULLs
    //
    p = ProductSuite;
    while (*p) {
        if (_tcsstr( p, SuiteName ))
        {
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

exit:
    if (ProductSuite)
    {
        GlobalFree( ProductSuite );
    }

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    return rVal;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRegValue
//
//  Synopsis:   Dynamically allocate memory and read value from registry
//
//  Arguments:  hKey - handle to key to be read
//              lpValueName - pointer to value name to be read
//              lpData - pointer to pointer to data
//
//  Returns:    Win32 error, ERROR_SUCCESS is it worked
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline LONG GetRegValue(HKEY hKey, LPTSTR lpValueName, LPBYTE *lpData)
{
    LONG dwError;
    DWORD cbData;

    TraceMsg(TF_GENERAL, "ICFGNT: GetRegValue\n");
    dwError = RegQueryValueEx(hKey,
                              lpValueName,
                              NULL,
                              NULL,
                              NULL,
                              &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        return(dwError);
    }

    //
    // Allocate space and buffer incase we need to add more info later
    // see turn off the printing binding
    //
    *lpData = (LPBYTE) GlobalAlloc(GPTR,cbData + REG_DATA_EXTRA_SPACE);
    if(*lpData == 0)
    {
        return(ERROR_OUTOFMEMORY);
    }

    dwError = RegQueryValueEx(hKey,
                              lpValueName,
                              NULL,
                              NULL,
                              *lpData,
                              &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        GlobalFree(*lpData);
    }

    return(dwError);
}

//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizard(HWND hwnd)
   /* call the Modem.Cpl install wizard to enable the user to install one or
   ** more modems
   **
   ** Return TRUE if the wizard was successfully invoked, FALSE otherwise
   **
   */
{
   HDEVINFO hdi;
   BOOL     fReturn = FALSE;
   // Create a modem DeviceInfoSet

   TraceMsg(TF_GENERAL, "ICFGNT: CallModemInstallWizard\n");
   hdi = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_MODEM, hwnd);
   if (hdi)
   {
      SP_INSTALLWIZARD_DATA iwd;

      // Initialize the InstallWizardData

      ZeroMemory(&iwd, sizeof(iwd));
      iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
      iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
      iwd.hwndWizardDlg = hwnd;

      // Set the InstallWizardData as the ClassInstallParams

      if (SetupDiSetClassInstallParams(hdi, NULL,
            (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
      {
         // Call the class installer to invoke the installation
         // wizard.
         if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hdi, NULL))
         {
            // Success.  The wizard was invoked and finished.
            // Now cleanup.
            fReturn = TRUE;

            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hdi, NULL);
         }
      }

      // Clean up
      SetupDiDestroyDeviceInfoList(hdi);
   }
   return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModem (DWORD dwfOptions, LPBOOL lpfNeedModem)
{
    //
    // Ras is installed, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    // Get the device info set for modems.
    //
    HDEVINFO hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_MODEM,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);
    if (hdevinfo)
    {
        SP_DEVINFO_DATA diData;
        diData.cbSize = sizeof(diData);

        // Look for at least one modem.
        //
        if (SetupDiEnumDeviceInfo(hdevinfo, 0, &diData))
        {
            *lpfNeedModem = FALSE;
        }

        SetupDiDestroyDeviceInfoList (hdevinfo);
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart)
{
    //$ BUGBUG (shaunco) 3 Jul 1997: See if we need to install a modem, or
    // just install it?

    //
    // Fire up the modem install wizard
    //
    if (!CallModemInstallWizard(hwndParent))
    {
        return(g_dwLastError = GetLastError());
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgNeedInetComponents\n");

    //
    // Assume we have what we need.
    //
    *lpfNeedComponents = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc,
                FALSE, 0, NULL, NULL);
    }

    // Look for TCP/IP using the INetCfg interface.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        Assert (pnc);

        hr = pnc->FindComponent (NETCFG_TRANS_CID_MS_TCPIP, NULL);
        if (S_FALSE == hr)
        {
            *lpfNeedComponents = TRUE;
        }
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, FALSE);
    }

    if (dwfOptions & ICFG_INSTALLMAIL)
    {
        // How do we do this?
        Assert (0);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponents
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgInstallInetComponents\n");

    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        BSTR bstrClient;
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc, TRUE,
                0, L"", &bstrClient);
    }

    // Install TCP/IP on behalf of the user.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        hr = HrInstallComponent (pnc, &GUID_DEVCLASS_NETTRANS,
                    NETCFG_TRANS_CID_MS_TCPIP, NULL);
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        // Apply the changes if everything was successful.
        //
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply ();

            if (NETCFG_S_REBOOT == hr)
            {
                *lpfNeedsRestart = TRUE;
            }
        }
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, TRUE);
    }

    if (dwfOptions & ICFG_INSTALLMAIL)
    {
        // How do we do this?
        Assert (0);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgGetLastInstallErrorText
//
//  Synopsis:   Format error message for most recent error
//
//  Arguments:  none
//
//  Returns:    DWORD - win32 error code
//              lpszErrorDesc - string containing error message
//              cbErrorDesc - size of lpszErrorDesc
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD WINAPI
IcfgGetLastInstallErrorText(LPTSTR lpszErrorDesc, DWORD cbErrorDesc)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgGetLastInstallErrorText\n");
    return(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             g_dwLastError,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                             lpszErrorDesc,
                             cbErrorDesc,
                             NULL));
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsFileSharingTurnedOn
//
//  Synopsis:   Always returns false for NT 5 because file sharing is controlled
//              at the RAS connectoid level, and is always turned off for ICW
//              generated connectoids
//
//  Arguments:  dwfDriverType -
//
//  Returns:    HRESULT - S_OK is success
//              lpfSharingOn - TRUE if sharing is bound
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgIsFileSharingTurnedOn
(
    DWORD dwfDriverType,
    LPBOOL lpfSharingOn
)
{
    HRESULT hr = ERROR_SUCCESS;

    TraceMsg(TF_GENERAL, "ICFGNT: IcfgIsFileSharingTurnedOn\n");
    Assert(lpfSharingOn);
    if (NULL == lpfSharingOn)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgIsFileSharingTurnedOnExit;
    }

    *lpfSharingOn = FALSE;

IcfgIsFileSharingTurnedOnExit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgTurnOffFileSharing
//
//  Synopsis;   For NT 5, this is handed as a RAS property, so we just return
//              success here.
//
//
//  Arguments:  dwfDriverType -
//              hwndParent - parent window
//
//  Returns:    HRESULT - ERROR_SUCCESS
//
//  History:    6/5/97      ChrisK  Inherited
//              07/21/98    donaldm
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgTurnOffFileSharing
(
    DWORD dwfDriverType,
    HWND hwndParent
)
{
    return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgStartServices
//
//  Synopsis:   Start all services required by system
//
//  Arguments:  none
//
//  Returns:    HRESULT - S_OK if success
//
//  History:    6/5/97  ChrisK  Iherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgStartServices()
{
    //This stuff is handled auto-magically by the RAS API.
    //but since there so much code that calls this function we'll
    //be simple and fake success
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsGlobalDNS
//
//  Note: these functions are not needed on an NT system and it therefore not
//  implemented
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
    *lpfGlobalDNS = FALSE;
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
IcfgRemoveGlobalDNS()
{
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
InetGetSupportedPlatform(LPDWORD pdwPlatform)
{
    *pdwPlatform = VER_PLATFORM_WIN32_NT;
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
InetSetAutodial(BOOL fEnable, LPCTSTR lpszEntryName) {
    return(ERROR_INVALID_FUNCTION);
}

HRESULT WINAPI
InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,  DWORD cbEntryName) {
    return(ERROR_INVALID_FUNCTION);
}

HRESULT WINAPI
InetSetAutodialAddress(DWORD dwDialingLocation, LPTSTR szEntry) {
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\acfgnoff.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  08/05/98    vyung     created
//
//*********************************************************************

#include "pre.h"
extern BOOL g_bSkipSelPage;
extern int  iNumOfAutoConfigOffers;
/*******************************************************************

  NAME:    ACfgNoofferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ACfgNoofferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    if (fFirstInit)
    {   
        TCHAR    szTemp[MAX_MESSAGE_LEN];
        // If user selected Other on the previous page.
        if (iNumOfAutoConfigOffers > 0)
        {
            LoadString(ghInstanceResDll, IDS_AUTOCFG_EXPLAIN_OTHER, szTemp, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);
        }
        else
        {
            if (gpWizardState->bISDNMode)
            {
                LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
                SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);

                TCHAR*   pszParagraph = new TCHAR[MAX_MESSAGE_LEN * 2];
                if (pszParagraph)
                {
                    LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER2, pszParagraph, MAX_MESSAGE_LEN * 2);
                    LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER3, szTemp, sizeof(szTemp));
                    lstrcat(pszParagraph, szTemp);
                    SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER2), pszParagraph);
                    delete [] pszParagraph;
                }
            }
            else
            {
                LoadString(ghInstanceResDll, IDS_AUTOCFG_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
                SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);
            }
        }
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
    }        
    
    return bRet;
}


/*******************************************************************

  NAME:    ACfgNoofferOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ACfgNoofferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        // go to the manual phone page
        *pfKeepHistory = FALSE;
        if (iNumOfAutoConfigOffers > 0) 
        {
            g_bSkipSelPage = TRUE;
        }
        gpWizardState->cmnStateData.bPhoneManualWiz = TRUE;
        *puNextPage = g_uExternUINext;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ccsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// ############################################################################
// INCLUDES
#include "pre.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    AssertMsg(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCTSTR pszFileName)
{
    AssertMsg(!m_hFile, "a file is already open.");
        
    m_hFile = CreateFile((LPCTSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPSTR psz, DWORD cbMax)
{
    CHAR*    pszLast;
    int      ch;

    ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    pszLast = psz + (cbMax - 1);
    while ( psz < pszLast &&
            chComma != ch &&
            chNewline != ch &&
            chReturn != ch &&
            -1 != ch)
    {
        *psz++ = (CHAR)ch;
        ch = ChNext(); //Read in the next character
    }

    *psz++ = '\0';

    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::SkipTillEOL()
{
    int ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    while ( chNewline != ch &&
            -1 != ch)
    {
        ch = ChNext(); //Read in the next character
    }
    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);
#ifdef DEBUG
    if (!m_hFile) TraceMsg(TF_GENERAL, "CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
   if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        return FALSE;     //nothing more to read
 
    m_pchBuf = m_rgchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for comma seperated files
class CCSVFile 
{
    
    public: 
        void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
        void operator delete( void far * p ) {GlobalFree(p); };

        CCSVFile();
        ~CCSVFile();
        BOOLEAN Open(LPCTSTR pszFileName);
        BOOLEAN ReadToken(LPSTR psz, DWORD cbMax);  // reads up to comma or newline, returns fFalse on EOF
        BOOLEAN SkipTillEOL(void);  // reads up to EOL
        void Close(void);
        inline int ILastRead(void)
            {
            return m_iLastRead;
            }

    private:
        BOOL    FReadInBuffer(void);
        inline int  ChNext(void);
        CHAR    m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
        LPSTR   m_pchBuf;           //pointer to the next item in the buffer to read
        LPSTR   m_pchLast;          //pointer to the last item in the buffer
        int     m_iLastRead;        //the character last read.
        DWORD   m_cchAvail;
        HANDLE  m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\billopt.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  BILLOPT.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"

const TCHAR cszBillOpt[] = TEXT("BILLOPT");

/*******************************************************************

  NAME:   BillingOptInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK BillingOptInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_BILLINGOPT;
    if (!fFirstInit)
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);
        
        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_BILLINGOPT_INTRO), IDS_BILLINGOPT_INTROFMT, NULL);
    
        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_BILLINGOPT_HTML), PAGETYPE_BILLING);
        
        // Navigate to the Billing HTML
        gpWizardState->lpSelectedISPInfo->DisplayHTML(gpWizardState->lpSelectedISPInfo->get_szBillingFormPath());
        
        // Load any previsouly saved state data for this page
        gpWizardState->lpSelectedISPInfo->LoadHistory((BSTR)A2W(cszBillOpt));
    }
    return TRUE;
}


/*******************************************************************

  NAME:    BillingOptOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK BillingOptOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // Save any data data/state entered by the user
    gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszBillOpt));

    if (fForward)
    {
        // Need to form Billing Query String
        TCHAR   szBillingOptionQuery [INTERNET_MAX_URL_LENGTH];    
        
        // Clear the Query String.
        memset(szBillingOptionQuery, 0, sizeof(szBillingOptionQuery));
        
        // Attach the walker to the curent page
        // Use the Walker to get the query string
        IWebBrowser2 *lpWebBrowser;
        
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
        gpWizardState->pHTMLWalker->get_FirstFormQueryString(szBillingOptionQuery);
        
        // Add the billing query to the ISPData object
        gpWizardState->pISPData->PutDataElement(ISPDATA_BILLING_OPTION, szBillingOptionQuery, ISPDATA_Validate_None);    
        
        // detach the walker
        gpWizardState->pHTMLWalker->Detach();
        
       
        DWORD dwFlag = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        if (ICW_CFGFLAG_SIGNUP_PATH & dwFlag)
        {
            if (ICW_CFGFLAG_PAYMENT & dwFlag)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                return TRUE;
            }
            *puNextPage = ORD_PAGE_ISPDIAL; 
            return TRUE;
        }
   }
 
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\connect.h ===
#define DISPID_RasDialStatus       0x1
#define DISPID_DownloadProgress    0x2
#define DISPID_DownloadComplete    0x3
#define DISPID_RasConnectComplete  0x4

class CRefDialEvent : public _RefDialEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CRefDialEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        ~CRefDialEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};

#define DISPID_WEBGATE_DownloadComplete 0x1
#define DISPID_WEBGATE_DownloadProgress 0x2
class CWebGateEvent : public _WebGateEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CWebGateEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        
        ~CWebGateEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};

#define RunningCustomExecutable             0x1
#define DISPID_INSHandler_KillConnection    0x2
class CINSHandlerEvent : public _INSHandlerEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CINSHandlerEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        
        ~CINSHandlerEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\dllsrcs.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN

TARGETNAME=ICWCONN
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwconn.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1

C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES= \
    ..\icwconn.rc          \
    ..\icwhelp.cpp         \
    ..\icwconn.cpp         \
    ..\dllentry.cpp        \
    ..\icwaprtc.cpp        \
    ..\gendlg.cpp          \
    ..\util.cpp            \
    ..\factory.cpp         \
    ..\ispsel.cpp          \
    ..\nooffer.cpp         \
    ..\userinfo.cpp        \
    ..\billopt.cpp         \
    ..\payment.cpp         \
    ..\ispdial.cpp         \
    ..\isppage.cpp         \
    ..\ccsv.cpp            \
    ..\ispcsv.cpp          \
    ..\paycsv.cpp          \
    ..\connect.cpp         \
    ..\storage.cpp         \
    ..\ols.cpp             \
    ..\dialerr.cpp         \
    ..\serverr.cpp         \
    ..\acfgnoff.cpp        \
    ..\ispasel.cpp         \
    ..\isdnnoff.cpp        \
    ..\oemoffer.cpp        \
    ..\timeout.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\htmlhelp.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\vfw32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pre.h
PRECOMPILED_PCH=pre.pch
PRECOMPILED_OBJ=pre.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\dialerr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  DIALERR.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    DialErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DialErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{  
    HideProgressAnimation();

    if (!fFirstInit)
    {
        KillIdleTimer();

        // Show the phone Number
        BSTR    bstrPhoneNum = NULL; 
        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
        SysFreeString(bstrPhoneNum);

        // Fill in the support number
        BSTR    bstrSupportPhoneNum = NULL; 
       
        //Let the isp file override this in IEAK with SupportPhoneNumber=
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            gpWizardState->pRefDial->get_ISPSupportPhoneNumber(&bstrSupportPhoneNum);
        }
        
        if (!bstrSupportPhoneNum)
            gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);

        if (bstrSupportPhoneNum)
        {
            ASSERT(gpWizardState->lpSelectedISPInfo);
            gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_SERVERR_HELP), IDS_DIALERR_HELP, W2A(bstrSupportPhoneNum));
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
            SysFreeString(bstrSupportPhoneNum);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
        }

        // Display the error text message
        BSTR bstrErrMsg = NULL;
        gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_TEXT), W2A(bstrErrMsg));;
        SysFreeString(bstrErrMsg);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_DIALERROR;
    }
    return TRUE;
}

/*******************************************************************

  NAME:    DialErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK DialErrorOKProc
(
    HWND hMdmCmb,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    // Set the new phone Number weather the user goes forward or back
    TCHAR   szPhone[MAX_RES_LEN];
    GetWindowText(GetDlgItem(hMdmCmb, IDC_DIALERR_PHONENUMBER), szPhone, sizeof(szPhone));
    gpWizardState->pRefDial->put_DialPhoneNumber(A2W(szPhone));
    
    if (fForward)
    {
        // We always dial the exact number that is in the phonenumber field.
        gpWizardState->bDialExact = TRUE;
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_ISPDIAL; 
    }
    else
    {
        BOOL bRetVal;
        // Clear the dial Exact state var so that when we get to the dialing
        // page, we will regenerate the dial string
        gpWizardState->bDialExact = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}






/*******************************************************************

  NAME:    DialErrorCmdProc

  SYNOPSIS:  Called when a command is generated from  page

  ENTRY:    hDlg - dialog window
            wParam - wParam
            lParam - lParam
          
  EXIT: returns TRUE 

********************************************************************/
BOOL CALLBACK DialErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
    {
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        { 
            case IDC_DIALERR_PROPERTIES:   
            {
                BOOL    bRetVal;
                gpWizardState->pRefDial->ShowDialingProperties(&bRetVal);
                if (bRetVal)
                {
                    // Show the phone Number as it may be changed after the popup
                    BSTR    bstrPhoneNum = NULL; 
                    gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                    SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                    SysFreeString(bstrPhoneNum);
                }
                break;
            }
            case IDC_DIAL_HELP:
            {
                HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
                break;
            }
            default:
                break;
        }           
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\connect.cpp ===
//**********************************************************************
// File name: connect.cpp
//
//      Implementation of connection point sink objects
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <ras.h>

BOOL DoOfferDownload();
extern BOOL g_bWebGateCheck;
extern BOOL g_bConnectionErr;

/*
 * CRefDialEvent::QueryInterface
 * CRefDialEvent::AddRef
 * CRefDialEvent::Release
 *
 * Purpose:
 *  IUnknown members for CRefDialEvent object.
 */

STDMETHODIMP CRefDialEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__RefDialEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//IDispatch
STDMETHODIMP CRefDialEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{
    HRESULT hr = S_OK;

    switch(dispIdMember)
    {
        case DISPID_RasDialStatus:
        {
            ASSERT(pDispParams->rgvarg);
            switch(pDispParams->rgvarg->iVal)
            {
                //Dialing 
                case RASCS_OpenPort:
                case RASCS_PortOpened:
                case RASCS_ConnectDevice: 
                {
                    if(!gpWizardState->iRedialCount)
                        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                                 IDS_ISPDIAL_STATUSDIALINGFMT, NULL);
                    else
                        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                                 IDS_ISPDIAL_STATUSREDIALINGFMT, NULL);
                    break;
                }
                //Connecting to network
                case RASCS_DeviceConnected:
                case RASCS_AllDevicesConnected:
                case RASCS_Authenticate:
                case RASCS_StartAuthentication:
                case RASCS_LogonNetwork:
                {
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSCONNECTINGFMT, NULL);
                    break;
                }
                case RASCS_Disconnected:
                {
                    BSTR bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_ISPDIAL_STATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                    break;
                }
                default:
                   break;
            }
            break;
        }
    
        case DISPID_RasConnectComplete: /* Incomplete */
        {
            if (pDispParams && !gfISPDialCancel)
            {
                if( gpWizardState->bDoneWebServRAS = pDispParams->rgvarg[0].lVal )
                {
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                         IDS_ISPDIAL_STATUSCONNECTINGFMT, NULL);
                    if (!DoOfferDownload())
                        hr = E_FAIL;
                }
            }
            if( !gfISPDialCancel )
                PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
            break;
        }            
    }
    return hr;
}

BOOL DoOfferDownload()
{
    // If Ras is complete 
    if (gpWizardState->bDoneWebServRAS)
    {
        ShowProgressAnimation();
        
        // Download the first page from Webgate
        BSTR    bstrURL = NULL;
        BSTR    bstrQueryURL = NULL;
        BOOL    bRet;

        TCHAR   szTemp[10];      // Big enough to format a WORD
        
        // Add the PID, GIUD, and Offer ID to the ISP data object
        gpWizardState->pRefDial->ProcessSignedPID(&bRet);
        if (bRet)
        {
            BSTR    bstrSignedPID = NULL;
            gpWizardState->pRefDial->get_SignedPID(&bstrSignedPID);
            gpWizardState->pISPData->PutDataElement(ISPDATA_SIGNED_PID, W2A(bstrSignedPID), FALSE);                
            
            SysFreeString(bstrSignedPID);                
        }
        else
        {
            gpWizardState->pISPData->PutDataElement(ISPDATA_SIGNED_PID, NULL, FALSE);                
        }

        // GUID comes from the ISPCSV file
        gpWizardState->pISPData->PutDataElement(ISPDATA_GUID, 
                                                gpWizardState->lpSelectedISPInfo->get_szOfferGUID(),
                                                FALSE);

        // Offer ID comes from the ISPCSV file as a WORD
        // NOTE: This is the last one, so besure AppendQueryPair does not add an Ampersand
        wsprintf (szTemp, TEXT("%d"), gpWizardState->lpSelectedISPInfo->get_wOfferID());
        gpWizardState->pISPData->PutDataElement(ISPDATA_OFFERID, szTemp, FALSE);                

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            // BUGBUG: If ISDN get the ISDN Autoconfig URL
            if (gpWizardState->bISDNMode)
            {
                gpWizardState->pRefDial->get_ISDNAutoConfigURL(&bstrURL);
            }
            else
            {
                gpWizardState->pRefDial->get_AutoConfigURL(&bstrURL);
            }
        }
        else
        {
            // Get the signup URL
            if (gpWizardState->bISDNMode)
            {
                gpWizardState->pRefDial->get_ISDNURL(&bstrURL);
            }
            else
            {
                gpWizardState->pRefDial->get_SignupURL(&bstrURL);
            }

        }

        //This flag is only to be used by ICWDEBUG.EXE
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_ISPURLOVERRIDE)
            gpWizardState->pISPData->GetQueryString(A2W(gpWizardState->cmnStateData.ispInfo.szIspURL), &bstrQueryURL);
        else
            // Get the full signup url with Query string params added to it
            gpWizardState->pISPData->GetQueryString(bstrURL, &bstrQueryURL);
            
        // Setup WebGate         
        gpWizardState->pWebGate->put_Path(bstrQueryURL);
        gpWizardState->pWebGate->FetchPage(0,0,&bRet);           
        
        // Memory cleanup
        SysFreeString(bstrURL);

        // If the fetch failed, then return the error code
        if (!bRet)
            return FALSE;
            
        // Wait for the fetch to complete                
        WaitForEvent(gpWizardState->hEventWebGateDone);
        
        // Start the Idle Timer
        StartIdleTimer();
        
        // Now that webgate is done with it, free the queryURL
        SysFreeString(bstrQueryURL);
        
        HideProgressAnimation();
        
    }
    return TRUE;
}


/*
 * CWebGateEvent::QueryInterface
 * CWebGateEvent::AddRef
 * CWebGateEvent::Release
 *
 * Purpose:
 *  IUnknown members for CWebGateEvent object.
 */

STDMETHODIMP CWebGateEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__WebGateEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP CWebGateEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_WEBGATE_DownloadComplete:
        {
            gpWizardState->bDoneWebServDownload = pDispParams->rgvarg[0].lVal;
            g_bWebGateCheck = FALSE;
            SetEvent(gpWizardState->hEventWebGateDone);
            break;
        }            
        case DISPID_WEBGATE_DownloadProgress:
        {
            if (g_bWebGateCheck)
            {
                BOOL bConnected = FALSE;
                
                //This flag is only to be used by ICWDEBUG.EXE
                if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    bConnected = TRUE;
                else
                    gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);

                if (!bConnected)
                {
                    g_bWebGateCheck = FALSE;
                    g_bConnectionErr = TRUE;
                    SetEvent(gpWizardState->hEventWebGateDone);
                }
            }
            break;
        }            
    }
    return S_OK;
}


/*
 * CINSHandlerEvent::QueryInterface
 * CINSHandlerEvent::AddRef
 * CINSHandlerEvent::Release
 *
 * Purpose:
 *  IUnknown members for CINSHandlerEvent object.
 */

STDMETHODIMP CINSHandlerEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__INSHandlerEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP CINSHandlerEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_INSHandler_KillConnection:
        {
            gpWizardState->pRefDial->DoHangup();
            break;
        }            
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\dllentry.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  DLLENTRY.CPP - 
//

//  HISTORY:
//  
//  05/14/98  donaldm   created
//

#include "pre.h"

// instance handle must be in per-instance data segment
HINSTANCE  ghInstance       = NULL;
HINSTANCE  ghInstanceResDll = NULL;

typedef UINT RETERR;

INT             _convert;               // For string conversion

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        ghInstance = hInstDll;
        
        ghInstanceResDll = LoadLibrary(ICW_RESOURCE_ONLY_DLL);
        ASSERT(ghInstanceResDll);
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        ASSERT(ghInstanceResDll);
        FreeLibrary(ghInstanceResDll);
    }
    return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\gendlg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"
#include "icwaprtc.h"

#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458

/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
    if( uPageIndex <= MAX_PAGE_INDEX )
    {
        ASSERT(uPageIndex < NUM_WIZARD_PAGES);

        return PageInfo[uPageIndex].uDlgID;
    }
    else
    {
        return(uPageIndex);
    }
}

//
//  GENDLG.C - 
//  Generic DLG proc for common wizard functions
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//


// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;
    
    if (!LoadString(ghInstanceResDll, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

/*******************************************************************

    Function:    PaintWithPaletteBitmap

    Arguments:   lprc is the target rectangle.
                 cy is the putative dimensions of hbmpPaint.
                 If the target rectangle is taller than cy, then 
                 fill the rest with the pixel in the upper left 
                 corner of the hbmpPaint.

    Returns:     void

    History:      10-29-98    Vyung    Stole from prsht.c

********************************************************************/

void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}
/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}

//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc
(
    HWND hDlg, 
    BOOL fFirstInit, 
    UINT uDlgID
)
{
//    switch( uDlgID )
//    {
//    }
    return TRUE;
}

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:         back and next buttons enabled
          next btn:     switches to page following current page
          back btn:     switches to previous page
          cancel btn:   prompts user to confirm, and cancels the wizard
          dlg ctrl:     does nothing (in response to WM_COMMANDs)
          
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    static HCURSOR  hcurOld = NULL;
    PAGEINFO        *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    ASSERT(pPageInfo);

    switch (uMsg) 
    {
        case WM_ERASEBKGND:
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                // Set ICW completed bit and remove the getconn icon
                if (gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground)
                    (*gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground)(hDlg, (HDC) wParam);

                return TRUE;
            }
            else
            {
                // Only paint the external page 
                if ((!pPageInfo->nIdTitle) && (IDD_PAGE_ISPSELECT != pPageInfo->uDlgID))
                {
                    Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                    return TRUE;
                }
            } 
            break;
        }
        
        GENDLG_CTLCOLOR:
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        {
            // Only paint the external page and except the ISP sel page
            if ((!pPageInfo->nIdTitle) && (IDD_PAGE_ISPSELECT != pPageInfo->uDlgID))
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        
        // We need to make sure static controls draw transparently
        // on the background bitmap.  This is done by painting in
        // the appropriate portion of the background, and then 
        // returning a NULL brush so the control just draws the text    
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
                {
                    SetBkMode((HDC)wParam, TRANSPARENT);
                    return (INT_PTR) GetStockObject(NULL_BRUSH);   
                }
                break;                    
            }                
            else
            {
                // Not in modeless opperation so just do the default cltcolor
                // handling
                goto GENDLG_CTLCOLOR;
            }

        case WM_INITDIALOG:
        {
            // get propsheet page struct passed in
            LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT(lpsp);
            
            // fetch our private page info from propsheet struct
            pPageInfo = (PAGEINFO *)lpsp->lParam;
            ASSERT(pPageInfo);

            // store pointer to private page info in window data for later
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

            // Make the title text bold
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc)
            {
                if (!( pPageInfo->InitProc(hDlg,TRUE, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
            // Before we return, lets send another message to ourself so
            // we have a second chance of initializing stuff that the 
            // property sheet wizard doesn't normally let us do.
            PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


            return TRUE;
        }
        
        break;  // WM_INITDIALOG

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        case WM_MYINITDIALOG:
        {
            // reset the state so that we can download data.
            gfUserCancelled = FALSE;

            if (pPageInfo->PostInitProc)
            {
                if (!( pPageInfo->PostInitProc(hDlg,(BOOL)wParam, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // wParam tells whether this is the first initialization or not
            MiscInitProc(hDlg, (BOOL)wParam, pPageInfo->uDlgID);
            return TRUE;
        }


        case WM_DESTROY:
            ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
            break;

#ifdef HAS_HELP
        case WM_HELP:
        {
            DWORD dwData = 1000;

            WinHelp(hDlg,"connect.hlp>proc4",HELP_CONTEXT, dwData);
            break;
        }
#endif
        
        case WM_NOTIFY:
        {
            BOOL fRet,fKeepHistory=TRUE;
            NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
            int iNextPage = NEXTPAGEUNITIALIZED;
            switch (lpnm->code) 
            {
                case PSN_TRANSLATEACCELERATOR:    
                {
                    // If the WEBOC is active, then we should let if have a crack as
                    // the accelerator
                    if ((pPageInfo->bIsHostingWebOC) || g_bCustomPaymentActive)
                    {     
                        //SUCEEDED macro will not work here cuz ret maybe S_FALSE
                        if (S_OK == gpWizardState->pICWWebView->HandleKey((LPMSG)((PSHNOTIFY*)lParam)->lParam)) 
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        else
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    return TRUE;
                }
                case PSN_SETACTIVE:
                    // If a fatal error occured in first call to init proc
                    // from WM_INITDIALOG, don't call init proc again.
                    if (FALSE == gfQuitWizard)
                    {
                        // For modeless operation, we are suppressing the painting
                        // of the wizard page background to get the effect of
                        // transparency, so we need to for an update of the 
                        // app's client area after hiding the current page.
                        if(gpWizardState->cmnStateData.bOEMCustom)
                        {
                            // Set the position of the page that is being activated
                            SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                
                            // Set the page title
                            if (pPageInfo->nIdTitle)
                            {
                                SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, (WPARAM)ghInstanceResDll, MAKELONG(pPageInfo->nIdTitle, 0));
                            }
                        }    
                        // initialize 'back' and 'next' wizard buttons, if
                        // page wants something different it can fix in init proc below
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                        // call init proc for this page if one is specified
                        if (pPageInfo->InitProc)
                        {
                            pPageInfo->InitProc(hDlg,FALSE, (UINT*)&iNextPage);
                            if (NEXTPAGEUNITIALIZED != iNextPage)
                            {
                                // Skipping
                                SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                                return (iNextPage);
                            }
                        }
                    }

                    // If we set the wait cursor, set the cursor back
                    if (hcurOld)
                    {
                        SetCursor(hcurOld);
                        hcurOld = NULL;
                    }

                    PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    // Change cursor to an hour glass
                    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // call OK proc for this page if one is specified
                    if (pPageInfo->OKProc) 
                    {
                        if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK), (UINT*)&iNextPage,&fKeepHistory))
                        {
                            // If a fatal error occured, quit the wizard.
                            // Note: gfQuitWizard is also used to terminate the wizard
                            // for non-error reasons, but in that case TRUE is returned
                            // from the OK proc and the case is handled below.
                            if (gfQuitWizard)
                            {
                                // Don't reboot if error occured.
                                gpWizardState->fNeedReboot = FALSE;
                
                                // send a 'cancel' message to ourselves (to keep the prop.
                                // page mgr happy)
                                //
                                // ...Unless we're serving as an Apprentice.  In which case, let
                                // the Wizard decide how to deal with this.

                                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                            }
                            
                            // stay on this page
                            SetPropSheetResult(hDlg,-1);
                            return TRUE;
                        }
                    }
                    
                    if (lpnm->code != PSN_WIZBACK) 
                    {
                        // 'next' pressed
                        ASSERT(gpWizardState->uPagesCompleted < NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory) 
                        {
                            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
                            TraceMsg(TF_GENDLG, "GENDLG: added page %d (IDD %d) to history list",
                                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                            gpWizardState->uPagesCompleted++;
                        }
                        else
                        {
                            TraceMsg(TF_GENDLG, "GENDLG: not adding %d (IDD: %d) to the history list",
                            gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                        }


                        // if no next page specified or no OK proc,
                        // advance page by one
                        if (0 > iNextPage)
                            iNextPage = gpWizardState->uCurrentPage + 1;

                    }
                    else
                    {
                        // 'back' pressed
                    
                        // If we have completed no pages, then we are on the first page 
                        // of the DLL process, so back really means go to the
                        // external prev. page.
                        if (0 == gpWizardState->uPagesCompleted)
                        {
                            iNextPage = g_uExternUIPrev;
                        }
                        
                        // See if we need to get the page from the history list
                        if( NEXTPAGEUNITIALIZED == iNextPage )
                        {
                            ASSERT(gpWizardState->uPagesCompleted > 0);

                            // get the last page from the history list
                            gpWizardState->uPagesCompleted --;
                            iNextPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
                            TraceMsg(TF_GENDLG, "GENDLG:  extracting page %d (IDD %d) from history list",iNextPage, GetDlgIDFromIndex(iNextPage));
                        }
                                                    
                    }

                    // if we need to exit the wizard now (e.g. launching
                    // signup app and want to terminate the wizard), send
                    // a 'cancel' message to ourselves (to keep the prop.
                    // page mgr happy)
                    if (gfQuitWizard) 
                    {
       
                        //
                        // if we are going from manual to conn1 then
                        // then do not show the  REBOOT dialog but
                        // still preserve the gpWizardState -MKarki Bug #404
                        //
                        if (lpnm->code ==  PSN_WIZBACK)
                        {
                            gfBackedUp = TRUE;
                            gfReboot = gpWizardState->fNeedReboot;
                        }

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                        SetPropSheetResult(hDlg,-1);
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed
                    if (lpnm->code != PSN_WIZFINISH) 
                    {

                        // set the next current page index
                        gpWizardState->uCurrentPage = iNextPage;
                        TraceMsg(TF_GENDLG, "GENDLG: going to page %d (IDD %d)", iNextPage, GetDlgIDFromIndex(iNextPage));

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                        return TRUE;
                    }
                    break;

                case PSN_QUERYCANCEL:
                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...
                    if (gfQuitWizard) 
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
                        return TRUE;
                    }

                                    
                    //Dialing is a super special case cuz we wanna skip all the UI and 
                    //go striaght to a dialing error page
                    if (gpWizardState->uCurrentPage == ORD_PAGE_ISPDIAL)
                    {
                        gfISPDialCancel = TRUE;
                        gfUserCancelled = TRUE;  // Just in case 

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                        // if this page has a special cancel proc, call it
                        if (pPageInfo->CancelProc)
                        {
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,pPageInfo->CancelProc(hDlg));
                            SetEvent(gpWizardState->hEventWebGateDone);
                        }
                    }
                    else
                    {
                        // default behavior: pop up a message box confirming
                        // the cancel...
                        // ... unless we're serving as an Apprentice, in which case
                        // we should let the Wizard handle things
                        fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                                           MB_ICONQUESTION,MB_YESNO |
                                           MB_DEFBUTTON2) == IDYES);
                        gfUserCancelled = fRet;
                        
                        if (gfUserCancelled)
                        {
                            // if this page has a special cancel proc, call it
                            if (pPageInfo->CancelProc)
                                fRet = pPageInfo->CancelProc(hDlg);
                             
                            SetEvent(gpWizardState->hEventWebGateDone);
                        }   
                        // return the value thru window data
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
                    }
                    return TRUE;
                    break;
                    
                default:
                    // See if the page has a notify proc
                    if (pPageInfo->NotifyProc) 
                    {
                        pPageInfo->NotifyProc(hDlg,wParam,lParam);
                    }
                    break;                        
            }
            break;
        }

        case WM_COMMAND:
        {
            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc) 
            {
                pPageInfo->CmdProc(hDlg, wParam, lParam);
            }
        }
        
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\factory.cpp ===
/****************************************************************************
 *
 *  FACTORY.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CFactory class, which is used by COM's CoCreateInstance
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  05/14/98    donaldm     migrated from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "icwconn.h"
// #include "icwextsn.h"
#include "icwaprtc.h"

// Friendly name of component
const TCHAR g_szFriendlyName[] = TEXT("CLSID_ApprenticeICWCONN") ;

// Version-independent ProgID
const TCHAR g_szVerIndProgID[] = TEXT("ICWCONN.Apprentice") ;

// ProgID
const TCHAR g_szProgID[] = TEXT("ICWCONN.Apprentice.1") ;

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

///////////////////////////////////////////////////////////
//
// Class factory
//
class CFactory : public IClassFactory
{
public:
    // IUnknown
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;         
    virtual ULONG   __stdcall AddRef() ;
    virtual ULONG   __stdcall Release() ;

    // Interface IClassFactory
    virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
                                             const IID& iid,
                                             void** ppv) ;
    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

    // Constructor
    CFactory() : m_cRef(1) {}

    // Destructor
    ~CFactory() { TraceMsg(TF_CLASSFACTORY, "Class factory:\t\tDestroy self.") ;}

private:
    long m_cRef ;
} ;

//
// Class factory IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(const IID& iid, void** ppv)
{    
    TraceMsg(TF_CLASSFACTORY, "CFactory::QueryInterface");
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IClassFactory*>(this) ; 
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall CFactory::AddRef()
{
    TraceMsg(TF_CLASSFACTORY, "CFactory::AddRef %d", m_cRef + 1);
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    TraceMsg(TF_CLASSFACTORY, "CFactory::Release %d", m_cRef);
    return m_cRef ;
}

//
// IClassFactory implementation
//
HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance:\t\tCreate component.") ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.  Since there's no direct IUnknown implementation,
    // use CICWApprentice.
    CICWApprentice *pApprentice = new CICWApprentice;
    
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance CICWApprentice->AddRef");
    pApprentice->AddRef();
    
    if( NULL == pApprentice )
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance About to QI on CICWApprentice");
    HRESULT hr = pApprentice->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance done with CICWApprentice, releasing (aprtc should have ct of 1)");
    pApprentice->Release() ;
    
    return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ; 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}


///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject:\tCreate class factory.") ;

    // Can we create this component?
    if (clsid != CLSID_ApprenticeICWCONN)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    CFactory* pFactory = new CFactory ;  // No AddRef in constructor
    if (pFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject about to QI on CFactory");
    HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject done with CFactory, releasing");
    pFactory->Release() ;



    return hr ;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//

typedef BOOL (WINAPI * REGISTERSERVER)(HMODULE hModule, 
                                       const CLSID& clsid, 
                                       const LPTSTR szFriendlyName,
                                       const LPTSTR szVerIndProgID,
                                       const LPTSTR szProgID);

typedef BOOL (WINAPI * UNREGISTERSERVER)(const CLSID& clsid,
                                         const LPTSTR szVerIndProgID,
                                         const LPTSTR szProgID);

STDAPI DllRegisterServer()
{
    // Use the register server function that is in ICWUTIL.DLL
    HINSTANCE       hInstUtilDLL = LoadLibrary(ICW_UTIL);
    REGISTERSERVER  lpfnRegisterServer = NULL;
    HRESULT         hr = E_FAIL;
    
    if (hInstUtilDLL)
    {
        lpfnRegisterServer = (REGISTERSERVER)GetProcAddress(hInstUtilDLL, "RegisterServer");
        if (NULL != lpfnRegisterServer)
        {
            if (lpfnRegisterServer(ghInstance, 
                                  CLSID_ApprenticeICWCONN,
                                  (LPTSTR)g_szFriendlyName,
                                  (LPTSTR)g_szVerIndProgID,
                                  (LPTSTR)g_szProgID))
                hr = S_OK;                                  
        }
        FreeLibrary(hInstUtilDLL);
    }
    return (hr);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    // Use the un-register server function that is in ICWUTIL.DLL
    HINSTANCE           hInstUtilDLL = LoadLibrary(ICW_UTIL);
    UNREGISTERSERVER    lpfnUnregisterServer = NULL;
    HRESULT             hr = E_FAIL;
    
    if (hInstUtilDLL)
    {
        lpfnUnregisterServer = (UNREGISTERSERVER)GetProcAddress(hInstUtilDLL, "UnregisterServer");
        if (NULL != lpfnUnregisterServer)
        {
            if (lpfnUnregisterServer(CLSID_ApprenticeICWCONN,
                                    (LPTSTR)g_szVerIndProgID,
                                    (LPTSTR)g_szProgID))
                hr = S_OK;                                  
        }
        FreeLibrary(hInstUtilDLL);
    }
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\icwhelp.cpp ===
#include "pre.h"


// Include the interface file for the ICWHELP Dll
#include "..\inc\icwhelp_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\icwaprtc.h ===
#include "icwconn.h"

extern  IICW50Extension *g_pExternalIICWExtension;
extern  BOOL            g_fConnectionInfoValid;


class CICWApprentice : public IICW50Apprentice
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICW50Extension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll(LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe(LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags(DWORD dwFlags);


        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWApprentice( void );
        ~CICWApprentice( void );

        IICW50Extension     *m_pIICW50Ext;

    private:
        LONG                m_lRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\icwaprtc.cpp ===
/****************************************************************************
 *
 *  ICWAPRTC.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *  5/13/98     donaldm     adapted from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include <vfw.h>
#include "initguid.h"
#include "icwaprtc.h"
#include "icwconn.h"
#include "webvwids.h"

#define PROGRESSANIME_XPOS      10      // Default offset from the left side
#define PROGRESSANIME_YPOS      40      // Default height plus border at bottom
#define PROGRESSANIME_YBORDER   10      // default border at bottom

UINT    g_uExternUIPrev, g_uExternUINext;

//defined/allocated in icwconn.cpp
extern PAGEINFO PageInfo[NUM_WIZARD_PAGES];

// In GENDLG.CPP
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern BOOL InitWizardState(WIZARDSTATE * pWizardState);
extern BOOL CleanupWizardState(WIZARDSTATE * pWizardState);
extern DWORD WINAPI GetICWCONNVersion(void);

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Initialize
//
//  Synopsis    Called by the main Wizard to initialize class members and
//              globals
//
//  Arguments   [in] pExt -- pointer the Wizard's IICW50Extension interface, which
//                          encapsulates the functionality needed to add wizard
//                          pages.
//
//  Returns     E_OUTOFMEMORY -- unable to allocate global vars.
//              S_OK indicates success
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Initialize(IICW50Extension *pExt)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::Initialize");

    ASSERT( pExt );
    m_pIICW50Ext = pExt;

    m_pIICW50Ext->AddRef();

    if( !gpWizardState)
    {
        gpWizardState = new WIZARDSTATE;
    }

    if( !gpWizardState )
    {
        TraceMsg(TF_APPRENTICE, "CICWApprentice::Initialize couldn't initialize the globals!");
        return E_OUTOFMEMORY;
    }

    // initialize the app state structure
    if (!InitWizardState(gpWizardState))
        return E_FAIL;

    // Since we now have the ISPData object (created during InitWizardState), this is a good time to
    // initialize the ISPData object, since we cannot be sure when it will be
    // used for data validation
    gpWizardState->hWndWizardApp = pExt->GetWizardHwnd();
    gpWizardState->pISPData->Init(gpWizardState->hWndWizardApp);
 
    
    return S_OK;

}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::AddWizardPages
//
//  Synopsis    Creates a series of Property Sheet pages, and adds them to the
//              main wizard via the m_pIICW50Ext interface pointer.  Note that
//              we add every page in the global PageInfo struct, even though the
//              Apprentice may not use some pages (eg, CONNECTEDOK)
//
//  Arguments   [] dwFlags -- currently unused
//
//  Returns     S_OK indicates success
//              E_FAIL indicates failure.  If for any reason all pages can not be
//                      added, we will attempt to remove any pages that had been
//                      added prior to the failure.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::AddWizardPages(DWORD dwFlags)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    UINT nPageIndex;
    HRESULT hr = S_OK;
    unsigned long ulNumItems = 0;

    TraceMsg(TF_APPRENTICE, "CICWApprentice::AddWizardPages");

    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));

    // fill out common data property sheet page struct
    psPage.dwSize     = sizeof(psPage);
    psPage.hInstance  = ghInstanceResDll;
    psPage.pfnDlgProc = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
    {
        UINT    uDlgID;
        psPage.dwFlags     = PSP_DEFAULT  | PSP_USETITLE;
        psPage.pszTitle    = gpWizardState->cmnStateData.szWizTitle;
        uDlgID             = PageInfo[nPageIndex].uDlgID;
        psPage.pszTemplate = MAKEINTRESOURCE(uDlgID);
                 
        // set a pointer to the PAGEINFO struct as the private data for this
        // page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        if (PageInfo[nPageIndex].nIdTitle)
        {
            psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
            psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
            psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
        }
        else
        {
            psPage.dwFlags |= PSP_HIDEHEADER;
        }
        
        hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

        if (!hWizPage[nPageIndex])
        {
            ASSERT(0);
            MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);

            hr = E_FAIL;
            // creating page failed, free any pages already created and bail
            goto AddWizardPagesErrorExit;
        }

        hr = m_pIICW50Ext->AddExternalPage( hWizPage[nPageIndex], uDlgID);

        if( FAILED(hr) )
        {
            // free any pages already created and bail
            goto AddWizardPagesErrorExit;
        }

        // Load the accelerator table for this page if necessary
        if (PageInfo[nPageIndex].idAccel)
            PageInfo[nPageIndex].hAccel = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(PageInfo[nPageIndex].idAccel));      
    }

    // of course, we have no idea what the last page will really be.
    // so make a guess here, and update it later when we know for sure.
    ProcessCustomFlags(dwFlags);

    return S_OK;


AddWizardPagesErrorExit:
    UINT nFreeIndex;
    for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
    {
        UINT    uDlgID;
        uDlgID = PageInfo[nPageIndex].uDlgID;
    
        DestroyPropertySheetPage(hWizPage[nFreeIndex]);
        m_pIICW50Ext->RemoveExternalPage( hWizPage[nFreeIndex], uDlgID );
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Save
//
//  Synopsis    Called by the Wizard to commit changes
//
//  Arguments   [in] hwnd -- hwnd of Wizard window, used to display modal msgs
//              [out] pdwError -- implementation specfic error code.  Not used.
//
//  Returns     S_OK indicates success
//              Otherwise, returns E_FAIL.
//
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Save(HWND hwnd, DWORD *pdwError)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::Save");
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::SetPrevNextPage
//
//  Synopsis    Lets the apprentice notify the wizard of the dialog IDs of the
//              first and last pages in the apprentice
//
//
//  Arguments   uPrevPageDlgID -- DlgID of wizard page to back up to
//              uNextPageDlgID -- DlgID of wizard page to go forwards into
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  Notes:      If either variable is set to 0, the function will not update
//              that information, i.e. a value of 0 means "ignore me".  If both
//              variables are 0, the function immediately returns FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::SetPrevNextPage: updating prev = %d, next = %d",
        uPrevPageDlgID, uNextPageDlgID);

    if( (0 == uPrevPageDlgID) && (0 == uNextPageDlgID) )
    {
        TraceMsg(TF_APPRENTICE, "SetFirstLastPage: both IDs are 0!");
        return( E_INVALIDARG );
    }

    if( 0 != uPrevPageDlgID )
        g_uExternUIPrev = uPrevPageDlgID;
    if( 0 != uNextPageDlgID )
        g_uExternUINext = uNextPageDlgID;


    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::ProcessCustomFlags
//
//  Synopsis    Lets the apprentice know that there is a special modification
//              to this set of apprentice pages after it is loaded
//
//  Arguments   dwFlags -- info needed to pass to the external pages
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  History     5/23/97 vyung     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::ProcessCustomFlags(DWORD dwFlags)
{
    if( m_pIICW50Ext )
    {
    
        if(dwFlags & ICW_CFGFLAG_IEAKMODE)
        {          
            CISPCSV     *pcISPCSV = new CISPCSV;
            
            // Set the Current selected ISP to this one.
            gpWizardState->lpSelectedISPInfo = pcISPCSV;
                
            // Initialize the new Selected ISP info object                
            gpWizardState->lpSelectedISPInfo->set_szISPName(gpWizardState->cmnStateData.ispInfo.szISPName);
            gpWizardState->lpSelectedISPInfo->set_szISPFilePath(gpWizardState->cmnStateData.ispInfo.szISPFile);
            gpWizardState->lpSelectedISPInfo->set_szBillingFormPath(gpWizardState->cmnStateData.ispInfo.szBillHtm);
            gpWizardState->lpSelectedISPInfo->set_szPayCSVPath(gpWizardState->cmnStateData.ispInfo.szPayCsv);
            gpWizardState->lpSelectedISPInfo->set_bCNS(FALSE);
            gpWizardState->lpSelectedISPInfo->set_bIsSpecial(FALSE);
            gpWizardState->lpSelectedISPInfo->set_dwCFGFlag(dwFlags);
            gpWizardState->lpSelectedISPInfo->set_dwRequiredUserInputFlags(gpWizardState->cmnStateData.ispInfo.dwValidationFlags);
            
            // What page do we display first?
            if (dwFlags & ICW_CFGFLAG_USERINFO)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_USERINFO, IDD_PAGE_USERINFO );
            else if (dwFlags & ICW_CFGFLAG_BILL)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_BILLINGOPT, IDD_PAGE_BILLINGOPT );
            else if (dwFlags & ICW_CFGFLAG_PAYMENT)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_PAYMENT, IDD_PAGE_PAYMENT );
            else
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ISPDIAL, IDD_PAGE_ISPDIAL );
        }
        else
        {
            if (dwFlags & ICW_CFGFLAG_AUTOCONFIG)
            {
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ACFG_ISP, IDD_PAGE_ACFG_ISP );
            }
            else
            {
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ISPSELECT, IDD_PAGE_ISPSELECT );
            }
        }    
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::SetStateData
//
//  Synopsis    Lets the apprentice set wizard state data
//
//  Arguments   LPCMNSTATEDATA Pointer to state data to be set
//
//  Returns     
//  History     5/22/98 donaldm     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) 
{
    TCHAR       szTemp[MAX_RES_LEN];
    HWND        hWndAnimeParent = gpWizardState->hWndWizardApp;
    int         xPosProgress = PROGRESSANIME_XPOS;
    int         yPosProgress = -1;
    RECT        rect;
    LPTSTR      lpszAnimateFile =  MAKEINTRESOURCE(IDA_PROGRESSANIME);
    
    ASSERT(gpWizardState);
    
    memcpy(&gpWizardState->cmnStateData, lpData, sizeof(CMNSTATEDATA));
    
    
    // Set values in the ISP Data object that are part of the cmnstatedata, or are not 
    // specific to user data entry
    wsprintf (szTemp, TEXT("%ld"), gpWizardState->cmnStateData.dwCountryCode);
    gpWizardState->pISPData->PutDataElement(ISPDATA_COUNTRYCODE, szTemp, ISPDATA_Validate_None);
    gpWizardState->pISPData->PutDataElement(ISPDATA_AREACODE, gpWizardState->cmnStateData.szAreaCode, ISPDATA_Validate_None);
    wsprintf (szTemp, TEXT("%ld"), GetICWCONNVersion());
    gpWizardState->pISPData->PutDataElement(ISPDATA_ICW_VERSION, szTemp, ISPDATA_Validate_None);
        
    // If we are in modeless operation, (aka OEM custom) then we need
    // to set the HTML background color for some pages
    if(gpWizardState->cmnStateData.bOEMCustom)
    {
        gpWizardState->pICWWebView->SetHTMLColors(gpWizardState->cmnStateData.szclrHTMLText,
                                                  gpWizardState->cmnStateData.szHTMLBackgroundColor);
        
        if (!gpWizardState->cmnStateData.bHideProgressAnime)
        {
            // Set the progress animation parent to the App window
            hWndAnimeParent = gpWizardState->cmnStateData.hWndApp;
            
            // see if the oem has specified an x Position for the animation
            if (-1 != gpWizardState->cmnStateData.xPosBusy)
                xPosProgress = gpWizardState->cmnStateData.xPosBusy;
               
            // see if the oem has specified an differen animation file            
            if ('\0' != gpWizardState->cmnStateData.szBusyAnimationFile[0])
            {
                PAVIFILE    pFile;
                AVIFILEINFO fi;
                
                lpszAnimateFile = gpWizardState->cmnStateData.szBusyAnimationFile;
                
                // Compute the y-Position based on the height of the AVI file
                // and the size of the parent window
                AVIFileInit();
                AVIFileOpen(&pFile,     
                            gpWizardState->cmnStateData.szBusyAnimationFile,        
                            OF_READ,             
                            NULL);
                AVIFileInfo(pFile, &fi, sizeof(fi));
                AVIFileRelease(pFile);
                AVIFileExit();
                        
                GetClientRect(hWndAnimeParent, &rect);
                yPosProgress = rect.bottom - fi.dwHeight - PROGRESSANIME_YBORDER;
            }            
        }            
    }
    
    // Setup the progress animation
    if (!gpWizardState->hwndProgressAnime && !gpWizardState->cmnStateData.bHideProgressAnime)
    {
        // calculate the y-position of the progress animation
        if (-1 == yPosProgress)
        {
            GetClientRect(hWndAnimeParent, &rect);
            yPosProgress = rect.bottom - PROGRESSANIME_YPOS;
        }
        
        //Create the animation / progress control    
        gpWizardState->hwndProgressAnime = CreateWindow(ANIMATE_CLASS,
                                              TEXT(""),
                                              ACS_TRANSPARENT | WS_CHILD,
                                              xPosProgress, 
                                              yPosProgress,
                                              0, 0,
                                              hWndAnimeParent,
                                              NULL,
                                              ghInstanceResDll,
                                              NULL);  
        //Set the avi
        Animate_Open (gpWizardState->hwndProgressAnime, lpszAnimateFile);
    }    
        
    return (S_OK);
}

//converse of the previous function
HRESULT CICWApprentice::SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    
    memcpy(lpData, &gpWizardState->cmnStateData, sizeof(CMNSTATEDATA));
    
    return (S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWApprentice
    if (IID_IICW50Apprentice == riid)
        *ppv = (void *)(IICW50Apprentice *)this;
    // IID_IICW50Extension
    else if (IID_IICW50Extension == riid)
        *ppv = (void *)(IICW50Extension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::AddRef
//
//  Synopsis    This is the standard AddRef
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::AddRef( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Release
//
//  Synopsis    This is the standard Release
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_APPRENTICE, "CICWApprentice::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        m_pIICW50Ext->Release();
        m_pIICW50Ext = NULL;

        delete( this );
        return( 0 );
    }
    else
    {
        return( m_lRefCount );
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::CICWApprentice
//
//  Synopsis    This is the constructor, nothing fancy
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWApprentice::CICWApprentice( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice constructor called");
    m_lRefCount = 0;
    m_pIICW50Ext = NULL;

}


//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::~CICWApprentice
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWApprentice::~CICWApprentice( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice destructor called with ref count of %d", m_lRefCount);
    
    if( m_pIICW50Ext )
    {
        m_pIICW50Ext->Release();
        m_pIICW50Ext = NULL;
    }

    if( gpWizardState)
    {
        CleanupWizardState(gpWizardState);
        delete gpWizardState;
        gpWizardState = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\icwres.cpp ===
// Insert your headers here
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers

#include <windows.h>

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  dwReason, 
                       LPVOID lpReserved
                     )
{
    return TRUE; // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\icwconn.cpp ===
//**********************************************************************
// File name: ICWCONN.cpp
//
//      Main source file for the Internet Connection Wizard extension DLL
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"
#include "webvwids.h"

// local function prototypes
BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

#pragma data_seg(".data")

WIZARDSTATE     *gpWizardState=NULL;   // pointer to global wizard state struct
IICWWebView     *gpICWWebView[2];

#ifdef NEED_EXTENSION
DWORD           *g_pdwDialogIDList = NULL;
DWORD           g_dwDialogIDListSize = 0;
UINT            g_uICWCONN1UIFirst, g_uICWCONN1UILast; 
BOOL            g_fICWCONN1UILoaded = FALSE;
CICWExtension   *g_pCICW50Extension = NULL;
#endif

//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

PAGEINFO PageInfo[NUM_WIZARD_PAGES] =
{
    { IDD_PAGE_ISPSELECT,    TRUE,  ISPSelectInitProc,          NULL,                   ISPSelectOKProc,    NULL,               NULL,              ISPSelectNotifyProc,     0,                      0, IDA_ISPSELECT, NULL, NULL },
    { IDD_PAGE_NOOFFER,      TRUE,  NoOfferInitProc,            NULL,                   NoOfferOKProc,      NULL,               NULL,              NULL,                    0,                      0, 0, NULL, NULL },
    { IDD_PAGE_USERINFO,     FALSE, UserInfoInitProc,           NULL,                   UserInfoOKProc,     NULL,               NULL,              NULL,                    IDS_STEP2_TITLE,        0, 0, NULL, NULL },
    { IDD_PAGE_BILLINGOPT,   TRUE,  BillingOptInitProc,         NULL,                   BillingOptOKProc,   NULL,               NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_BILLINGOPT, NULL, NULL },
    { IDD_PAGE_PAYMENT,      FALSE, PaymentInitProc,            NULL,                   PaymentOKProc,      PaymentCmdProc,     NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_PAYMENT, NULL, NULL },
    { IDD_PAGE_ISPDIAL,      FALSE, ISPDialInitProc,            ISPDialPostInitProc,    ISPDialOKProc,      NULL,               ISPDialCancelProc, NULL,                    IDS_STEP2_TITLE,        0, 0, NULL, NULL },
    { IDD_PAGE_ISPDATA,      TRUE,  ISPPageInitProc,            NULL,                   ISPPageOKProc,      ISPCmdProc,         NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_ISPDATA, NULL, NULL },
    { IDD_PAGE_OLS,          TRUE,  OLSInitProc,                NULL,                   OLSOKProc,          NULL,               NULL,              NULL,                    IDS_OLS_TITLE,          0, 0, NULL, NULL },
    { IDD_PAGE_DIALERROR,    FALSE, DialErrorInitProc,          NULL,                   DialErrorOKProc,    DialErrorCmdProc,   NULL,              NULL,                    IDS_DIALING_ERROR_TITLE,0, IDA_DIALERROR, NULL, NULL },
    { IDD_PAGE_SERVERROR,    FALSE, ServErrorInitProc,          NULL,                   ServErrorOKProc,    ServErrorCmdProc,   NULL,              NULL,                    IDS_SERVER_ERROR_TITLE, 0, IDA_SERVERROR, NULL, NULL },
    { IDD_PAGE_ACFG_ISP,     TRUE,  ISPAutoSelectInitProc,      NULL,                   ISPAutoSelectOKProc,NULL,               NULL,              ISPAutoSelectNotifyProc, IDS_STEP1_TITLE,        0, IDA_ACFG_ISP, NULL, NULL },
    { IDD_PAGE_ACFG_NOOFFER, TRUE,  ACfgNoofferInitProc,        NULL,                   ACfgNoofferOKProc,  NULL,               NULL,              NULL,                    IDS_MANUAL_TITLE,       0, 0, NULL, NULL },
    { IDD_PAGE_ISDN_NOOFFER, TRUE,  ISDNNoofferInitProc,        NULL,                   ISDNNoofferOKProc,  NULL,               NULL,              NULL,                    0,                      0, 0, NULL, NULL },
    { IDD_PAGE_OEMOFFER,     TRUE,  OEMOfferInitProc,           NULL,                   OEMOfferOKProc,     OEMOfferCmdProc,    NULL,              NULL,                    IDS_STEP1_TITLE,        0, IDA_OEMOFFER, NULL, NULL }
};

BOOL        gfQuitWizard     = FALSE;    // global flag used to signal that we want to terminate the wizard ourselves
BOOL        gfUserCancelled  = FALSE;    // global flag used to signal that the user cancelled
BOOL        gfISPDialCancel  = FALSE;    // global flag used to signal that the user cancelled
BOOL        gfUserBackedOut  = FALSE;    // global flag used to signal that the user pressed Back on the first page
BOOL        gfUserFinished   = FALSE;    // global flag used to signal that the user pressed Finish on the final page
BOOL        gfBackedUp       = FALSE;
BOOL        gfReboot         = FALSE;
BOOL        g_bMalformedPage = FALSE;

#pragma data_seg()

BOOL CleanupWizardState(WIZARDSTATE * pWizardState);

/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL InitWizardState(WIZARDSTATE * pWizardState)
{
    HRESULT hr;
    
    ASSERT(pWizardState);

    //register the Native font control so the dialog won't fail
    //although it's registered in the exe this is a "just in case"
    INITCOMMONCONTROLSEX iccex;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    if (!InitCommonControlsEx(&iccex))
        return FALSE;

    // zero out structure
    ZeroMemory(pWizardState,sizeof(WIZARDSTATE));

    // set starting page
    pWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;
    pWizardState->fNeedReboot = FALSE;
    pWizardState->bISDNMode = FALSE;
    pWizardState->himlIspSelect = NULL; 
    pWizardState->uNumTierOffer = 0;
    for (UINT i=0; i < MAX_OEM_MUTI_TIER; i++)
        pWizardState->lpOEMISPInfo[i] = NULL;

    // Instansiate ICWHELP objects
    hr = CoCreateInstance(CLSID_UserInfo,NULL,CLSCTX_INPROC_SERVER,
                     IID_IUserInfo,(LPVOID *)&pWizardState->pUserInfo);
    if (FAILED(hr))
        goto InitWizardStateError;
    
    hr = CoCreateInstance(CLSID_RefDial,NULL,CLSCTX_INPROC_SERVER,
                          IID_IRefDial,(LPVOID *)&pWizardState->pRefDial);
    if (FAILED(hr))
        goto InitWizardStateError;
                          
    hr = CoCreateInstance(CLSID_WebGate,NULL,CLSCTX_INPROC_SERVER,
                          IID_IWebGate,(LPVOID *)&pWizardState->pWebGate);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_INSHandler,NULL,CLSCTX_INPROC_SERVER,
                          IID_IINSHandler,(LPVOID *)&pWizardState->pINSHandler);
    if (FAILED(hr))
        goto InitWizardStateError;
        
    hr = CoCreateInstance(CLSID_ICWWEBVIEW,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWebView,(LPVOID *)&pWizardState->pICWWebView);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWalker,(LPVOID *)&pWizardState->pHTMLWalker);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWGIFCONVERT,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWGifConvert,(LPVOID *)&pWizardState->pGifConvert);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWISPDATA,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWISPData,(LPVOID *)&pWizardState->pISPData);
    if (FAILED(hr))
        goto InitWizardStateError;

    if ( !pWizardState->pUserInfo   ||
         !pWizardState->pWebGate    ||
         !pWizardState->pINSHandler ||
         !pWizardState->pHTMLWalker ||
         !pWizardState->pRefDial    ||
         !pWizardState->pICWWebView ||
         !pWizardState->pGifConvert ||
         !pWizardState->pISPData    ||
         !pWizardState->pHTMLWalker)
    {
        goto InitWizardStateError;
    }

    // Init the walker for use with trident
    hr = pWizardState->pHTMLWalker->InitForMSHTML();
    if (FAILED(hr))
        goto InitWizardStateError;

    if ((pWizardState->pStorage = new CStorage) == NULL)
    {
        goto InitWizardStateError;
    }
    
    pWizardState->hEventWebGateDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!pWizardState->hEventWebGateDone)
        goto InitWizardStateError;
    
    // Success error return path    
    return TRUE;

InitWizardStateError:
    // Free any co-created objects
    CleanupWizardState(pWizardState);
    return FALSE;
}

BOOL CleanupWizardState(WIZARDSTATE * pWizardState)
{
    if (pWizardState->pHTMLWalker)
    {
        pWizardState->pHTMLWalker->TermForMSHTML();
        pWizardState->pHTMLWalker->Release();
        pWizardState->pHTMLWalker = NULL;
    }        

    if (pWizardState->pICWWebView)
    {
        pWizardState->pICWWebView->Release();
        pWizardState->pICWWebView = NULL;
    }
    
    if (gpICWWebView[0])
    {
        gpICWWebView[0]->Release();
        gpICWWebView[0] = NULL;
    }

    if (gpICWWebView[1])
    {
        gpICWWebView[1]->Release();
        gpICWWebView[1] = NULL;
    }

    if (NULL != gpWizardState->himlIspSelect)
    {
        ImageList_Destroy(gpWizardState->himlIspSelect);
        gpWizardState->himlIspSelect = NULL;
    }

    if (pWizardState->pGifConvert)
    {
        pWizardState->pGifConvert->Release();
        pWizardState->pGifConvert = NULL;
    }            

    if (pWizardState->pISPData)
    {
        pWizardState->pISPData->Release();
        pWizardState->pISPData = NULL;
    }            
    
    if (pWizardState->pUserInfo)
    {
        BOOL    bRetVal;
        // Before releasing the userinfo object, we should persist the user data if 
        // necessary
        if (!gfUserCancelled && gpWizardState->bWasNoUserInfo && gpWizardState->bUserEnteredData)
            pWizardState->pUserInfo->PersistRegisteredUserInfo(&bRetVal);
        
        pWizardState->pUserInfo->Release();
        pWizardState->pUserInfo  = NULL;
    }

    if (pWizardState->pRefDial)
    {
        pWizardState->pRefDial->Release();
        pWizardState->pRefDial = NULL;
    }
    
    if (pWizardState->pWebGate)
    {
        pWizardState->pWebGate->Release();
        pWizardState->pWebGate = NULL;
    }
    
    if (pWizardState->pINSHandler)
    {
        pWizardState->pINSHandler->Release();
        pWizardState->pINSHandler = NULL;
    }

    if (pWizardState->pStorage)
    {
        delete pWizardState->pStorage;
    }
    
    for (UINT i=0; i < pWizardState->uNumTierOffer; i++)
    {
        if (pWizardState->lpOEMISPInfo[i])
        {
            // Prevent deleting it twice
            if (pWizardState->lpOEMISPInfo[i] != pWizardState->lpSelectedISPInfo)
            {
                delete pWizardState->lpOEMISPInfo[i];
                pWizardState->lpOEMISPInfo[i] = NULL;
            }
        }
    }

    if (pWizardState->lpSelectedISPInfo)
    {
        delete pWizardState->lpSelectedISPInfo;
    }
    
    if (pWizardState->hEventWebGateDone)
    {
        CloseHandle(pWizardState->hEventWebGateDone);
        pWizardState->hEventWebGateDone = 0;
    }

    // Kill the idle timer just in case.
    KillIdleTimer();
        
    return TRUE;
}

#ifdef NEED_EXTENSION
//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN,"ICWCONN: AllocDialogIDList called with non-null g_pdwDialogIDList!");
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN,"ICWCONN: AllocDialogIDList unable to allocate space for g_pdwDialogIDList!");
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN,"ICWCONN: DialogIDAlreadyInUse received an out of range DialogID, %d", uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN,"ICWCONN: SetDialogIDInUse received an out of range DialogID, %d", uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
    }


    return TRUE;
}

#endif

DWORD WINAPI GetICWCONNVersion()
{
    return ICW_DOWNLOADABLE_COMPONENT_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ispcsv.h ===
//**********************************************************************
// File name: ISPCSV.H
//
//      Definition of CISPCSV
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _ISPCSV_H_ )
#define _ISPCSV_H_

#define MAX_GUID            50
#define MAX_ISP_NAME        100
#define TEMP_BUFFER_LENGTH  1024

#define NUM_ISPCSV_FIELDS   14

class CISPCSV
{
    private:
        int     iISPLogoIndex;
        
        // The following members represent the content of a single line from the CSV file.

        int     iSpecialVal;                        // if bIsSpecial is TRUE, then 0 = NO Offers and -1 = OLS offer
        BOOL    bCNS;
        BOOL    bIsSpecial;                         // If true, then CNS value was "special"
        BOOL    bSecureConnection;
        WORD    wOfferID;
        DWORD   dwCfgFlag;
        DWORD   dwRequiredUserInputFlags;
        TCHAR   m_szISPLogoPath         [MAX_PATH];
        TCHAR   m_szISPTierLogoPath     [MAX_PATH];
        TCHAR   m_szISPTeaserPath       [MAX_PATH];
        TCHAR   m_szISPMarketingHTMPath [MAX_PATH];
        TCHAR   m_szISPFilePath         [MAX_PATH];
        TCHAR   m_szISPName             [MAX_ISP_NAME];
        TCHAR   m_szCNSIconPath         [MAX_PATH];
        TCHAR   m_szBillingFormPath     [MAX_PATH];
        TCHAR   m_szPayCSVPath          [MAX_PATH];
        TCHAR   m_szOfferGUID           [MAX_GUID];
        TCHAR   m_szMir                 [MAX_ISP_NAME];
        WORD    wLCID;
        HICON   hbmTierIcon;
        
        IStorage    *m_lpStgHistory;      // Pointer to stuctured storage object
                                          // for storing page history information
           
        IStorage    *m_lpStgIspPages;     // Pointer to stuctured storage object
                                          // that will be used to track the ISP page cache
                                                 
    public:

        CISPCSV(void) 
        {
            memset(this, 0, sizeof(CISPCSV));            
            
            // Allocate a temporary structured storage object
            StgCreateDocfile(NULL, 
                             STGM_DIRECT | 
                             STGM_READWRITE | 
                             STGM_SHARE_EXCLUSIVE | 
                             STGM_DELETEONRELEASE |
                             STGM_CREATE,
                             0, 
                             &m_lpStgHistory);
                             
            // Attempt to allocate a new storage object for the page cache
            StgCreateDocfile(NULL, 
                             STGM_DIRECT | 
                             STGM_READWRITE | 
                             STGM_SHARE_EXCLUSIVE | 
                             STGM_DELETEONRELEASE |
                             STGM_CREATE,
                             0, 
                             &m_lpStgIspPages);
        }
        
        ~CISPCSV(void);
         
        HRESULT ReadOneLine             (CCSVFile far *pcCSVFile);      
        HRESULT ReadFirstLine           (CCSVFile far *pcCSVFile);
        HRESULT DisplayHTML             (LPTSTR szFile);
        HRESULT DisplayTextWithISPName  (HWND hDlgCtrl, int iMsgString,  TCHAR* pszExtra);
        void    StripQuotes             (LPSTR   lpszDst, LPSTR   lpszSrc);
        BOOL    ReadDW                  (DWORD far *pdw, CCSVFile far *pcCSVFile);
        BOOL    ReadW                   (WORD far *pw, CCSVFile far *pcCSVFile);
        BOOL    ReadWEx                 (WORD far *pw, CCSVFile far *pcCSVFile); //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
        BOOL    ReadB                   (BYTE far *pb, CCSVFile far *pcCSVFile);
        BOOL    ReadBOOL                (BOOL far *pbool, CCSVFile far *pcCSVFile);
        BOOL    ReadSPECIAL             (BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile);
        BOOL    ReadSZ                  (LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
        BOOL    ReadToEOL               (CCSVFile far *pcCSVFile);
        BOOL    ValidateFile            (TCHAR* pszFile);
        void    MakeCompleteURL         (LPTSTR lpszURL, LPTSTR  lpszSRC);

        // Functions for managing IPersistHistory streams
        HRESULT SaveHistory(BSTR  bstrStreamName);
        HRESULT LoadHistory(BSTR  bstrStreamName);
        
//        HRESULT DeleteHistory(BSTR  bstrStreamName);
        
        // functions for managing the ISP Page cache
        HRESULT GetCacheFileNameFromPageID(BSTR bstrPageID, LPTSTR lpszCacheFile, ULONG cbszCacheFile);
        void    CleanupISPPageCache(BOOL bReleaseStorage);
        HRESULT CopyFiletoISPPageCache(BSTR bstrPageID, LPTSTR lpszTempFile);
        
        
        LPTSTR   get_szISPLogoPath(void)
        {
            return m_szISPLogoPath;
        }   

        LPTSTR   get_szISPTierLogoPath(void)
        {
            return m_szISPTierLogoPath;
        } 
        
        void set_ISPTierLogoIcon(HICON hIcon)
        {
            hbmTierIcon = hIcon;
        }   

        HICON get_ISPTierLogoIcon(void)
        {
            return hbmTierIcon;
        }   
      
        LPTSTR   get_szISPTeaserPath(void)
        {
            return m_szISPTeaserPath;
        } 

        LPTSTR   get_szISPMarketingHTMPath(void)
        {
            return m_szISPMarketingHTMPath;
        }   

        DWORD get_dwCFGFlag() 
        {
            return dwCfgFlag;
        }

        void set_dwCFGFlag(DWORD dwNewCfgFlag) 
        {
            dwCfgFlag = dwNewCfgFlag;
        }

        DWORD get_dwRequiredUserInputFlags() 
        {
            return dwRequiredUserInputFlags;
        }

        void set_dwRequiredUserInputFlags(DWORD dwFlags) 
        {
            dwRequiredUserInputFlags = dwFlags;
        }

        void set_szBillingFormPath(TCHAR* pszFile)
        {
            lstrcpy(m_szBillingFormPath, pszFile);
        }   
        
        LPTSTR   get_szBillingFormPath(void)
        {
            return m_szBillingFormPath;
        }   

        void set_ISPLogoImageIndex(int iImage)  
        {
            iISPLogoIndex = iImage;
        }

        void set_szISPName(TCHAR* pszName)
        {
            lstrcpy(m_szISPName, pszName);
        }
        
        LPTSTR   get_szISPName()
        {
            return m_szISPName;
        }
        
        int get_ISPLogoIndex()
        {
            return iISPLogoIndex;
        }
        
        void set_bCNS(BOOL bVal)
        {
            bCNS = bVal;
        }
        
        BOOL get_bCNS()
        {
            return bCNS;
        }

        void set_bIsSpecial(BOOL bVal) 
        {
            bIsSpecial = bVal;
        }
       
        
        BOOL get_bIsSpecial() 
        {
            return bIsSpecial;
        }
        
        int get_iSpecial()
        {
            return iSpecialVal;
        }
        
        void set_szPayCSVPath(TCHAR* pszFile)
        {
            lstrcpy(m_szPayCSVPath, pszFile);
        }            
        

        LPTSTR get_szPayCSVPath()
        {
            return m_szPayCSVPath;
        }            
        
         
        void set_szISPFilePath(TCHAR* pszFile)
        {
            lstrcpy(m_szISPFilePath, pszFile);
        }

        LPTSTR get_szISPFilePath()
        {
            return m_szISPFilePath;
        }
        
        LPTSTR get_szOfferGUID()
        {
            return m_szOfferGUID;
        }
        
        WORD    get_wOfferID()
        {
            return wOfferID;
        }

        LPTSTR  get_szMir()
        {
            return m_szMir;
        }

        WORD    get_wLCID()
        {
            return wLCID;
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ispdial.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  ISPDIAL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include <raserror.h>

BOOL            DoOfferDownload();

/*******************************************************************

  NAME:    ISPDialInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPDialInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // Disable Back and Next
    PropSheet_SetWizButtons(GetParent(hDlg), 0);
    gpWizardState->bRefDialTerminate = FALSE;
    gfISPDialCancel = FALSE;

    if (fFirstInit)
    {
      //Are we in IEAK Mode
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {          
            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !(*gpWizardState->cmnStateData.lpfnConfigSys)(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
        }
        
        CRefDialEvent *pRefDialEvent;
        CWebGateEvent *pWebGateEvent;
    
        // Blank out the status text initially
        SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_STATUS), TEXT(""));
        
        gpWizardState->iRedialCount = 0;

        // Setup an Event Handler for RefDial and Webgate
        pRefDialEvent = new CRefDialEvent(hDlg);
        if (NULL != pRefDialEvent)
        {
            HRESULT hr;
            gpWizardState->pRefDialEvents = pRefDialEvent;
            gpWizardState->pRefDialEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pRefDialEvents, 
                                            DIID__RefDialEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pRefDial, 
                                            &gpWizardState->pRefDialEvents->m_dwCookie, 
                                            NULL);     
        }    
        pWebGateEvent = new CWebGateEvent(hDlg);
        if (NULL != pWebGateEvent)
        {
            HRESULT hr;
            gpWizardState->pWebGateEvents = pWebGateEvent;
            gpWizardState->pWebGateEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pWebGateEvents, 
                                            DIID__WebGateEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pWebGate, 
                                            &gpWizardState->pWebGateEvents->m_dwCookie, 
                                            NULL);     
        }    
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPDIAL;

        ResetEvent(gpWizardState->hEventWebGateDone);
        // Cleanup the ISPPageCache for this ISP, since we are about to connect
        gpWizardState->lpSelectedISPInfo->CleanupISPPageCache(FALSE);
        
        TCHAR    szTemp[MAX_MESSAGE_LEN];
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            // hide this text for autoconfig
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDIAL_INSTRUCT),  SW_HIDE);
            LoadString(ghInstanceResDll, IDS_STEP2A_TITLE, szTemp, MAX_MESSAGE_LEN);
        }
        else
        {
            // show this text for new signup
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDIAL_INSTRUCT),  SW_SHOW);
            LoadString(ghInstanceResDll, IDS_STEP2_TITLE, szTemp, MAX_MESSAGE_LEN);
        }
        PropSheet_SetHeaderTitle(GetParent(hDlg), EXE_NUM_WIZARD_PAGES +  ORD_PAGE_ISPDIAL, szTemp);


        // Initialize the RefDial Object before we dial
        gpWizardState->pRefDial->DoInit();
    }     
    return TRUE;
}

/*******************************************************************

  NAME:    ISPDialPostInitProc

  SYNOPSIS:  

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPDialPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet;
    
    if (!fFirstInit)
    {
        // Force the Window to update
        UpdateWindow(GetParent(hDlg));

        if(!gpWizardState->iRedialCount)
        {
            // Clear the phone number and status fields
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_STATUS), TEXT(""));    
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), TEXT(""));
        }
            
        // Set the intro text
        ASSERT(gpWizardState->lpSelectedISPInfo);
        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_INTRO), IDS_ISPDIAL_INTROFMT, NULL);

        
        if (!gpWizardState->bDialExact)
        {
            BSTR    bstrPhoneNum = NULL;
            BOOL    bRetVal;

           
            // Setup for Dialing.  This will ensure that we are ready to dial.
            gpWizardState->pRefDial->SetupForDialing(A2W(gpWizardState->lpSelectedISPInfo->get_szISPFilePath()), //
                                                     gpWizardState->cmnStateData.dwCountryCode,
                                                     A2W(gpWizardState->cmnStateData.szAreaCode),
                                                     0,
                                                     &bRetVal);
            if (bRetVal)
            {            
                // Show the phone Number
                gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), W2A(bstrPhoneNum));

                // Initialize all the variables
                gpWizardState->bDoneWebServDownload = FALSE;
                gpWizardState->bDoneWebServRAS = FALSE;
            
                // Show the Initial Status
            
                if(!gpWizardState->iRedialCount)
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSDIALINGFMT, NULL);
                else
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSREDIALINGFMT, NULL);
               
                //This flag is only to be used by ICWDEBUG.EXE
                if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    gpWizardState->pRefDial->put_ModemOverride(TRUE);
                    
                gpWizardState->pRefDial->DoConnect(&bRetVal);
            }
            else 
            {
                gpWizardState->pRefDial->get_QuitWizard(&bRetVal);
                if (bRetVal)
                {
                    gfQuitWizard = TRUE;
                   bRet = FALSE;

                }
                else 
                {
                    gpWizardState->pRefDial->get_TryAgain(&bRetVal);
                    if (bRetVal)
                    {
                        PropSheet_PressButton(GetParent(hDlg),PSBTN_BACK);
                    }
                    else
                    {
                        PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                    }
                }
            }   
            SysFreeString(bstrPhoneNum);
        }
        else // Dialing exact.  We get here if the user changes the number on the dial error page
        {
            BSTR    bstrPhoneNum = NULL; 
            BOOL    bRet;
            int     iCurrent = 0;
          
            // Show the phone Number
            gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), W2A(bstrPhoneNum));
            SysFreeString(bstrPhoneNum);

            //This flag is only to be used by ICWDEBUG.EXE
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    gpWizardState->pRefDial->put_ModemOverride(TRUE);
                
            gpWizardState->pRefDial->DoConnect(&bRet);
        }
    }
    return bRet;
}

/*******************************************************************

  NAME:    ISPDialOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPDialOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    *pfKeepHistory  = FALSE;

    if (fForward)
    {
        if (!gpWizardState->bDoneWebServRAS)
        {          
            //OK so we had a dialing error but let's figure out which one...
            HRESULT hrDialErr;
            
            gpWizardState->pRefDial->get_DialError(&hrDialErr);
                
            switch (hrDialErr)
            {
                case ERROR_LINE_BUSY: //Line is engaged
                {     
                    if (gpWizardState->iRedialCount < NUM_MAX_REDIAL)
                    {   
                        //Redial
                        *puNextPage = ORD_PAGE_ISPDIAL;
                        gpWizardState->iRedialCount++;
                        break;
                    }
                    gpWizardState->iRedialCount = 0;
                }
                default:
                {
                    // nothing special just goto the dialing error page
                    *puNextPage = ORD_PAGE_DIALERROR;
                    break;
                }
            }              
        }
        else if (!gpWizardState->bDoneWebServDownload)
        {           
            gpWizardState->pRefDial->DoHangup();
            *puNextPage = ORD_PAGE_SERVERR;
        }
    }
    else // a retry is simulated when BACK is pressed
    {
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    return TRUE;
}

BOOL CALLBACK ISPDialCancelProc(HWND hDlg)
{
    //User has canceled so reset the redial count
    gpWizardState->iRedialCount = 0;
              
    if (gpWizardState->pRefDial)
    {
        gpWizardState->pRefDial->DoHangup();
        //We should make sure the wiz thinks it's a dialerr to avoid
        //the server error page
        gpWizardState->bDoneWebServDownload = FALSE;
        gpWizardState->bDoneWebServRAS      = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\isdnnoff.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISDNNOFF.CPP - Functions for ISDN nooffer page
//

//  HISTORY:
//  
//  08/05/98    vyung     created
//
//*********************************************************************

#include "pre.h"

/*******************************************************************

  NAME:    ISDNNoofferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISDNNoofferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        TCHAR    szTemp[MAX_MESSAGE_LEN];

        LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
        SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER1), szTemp);

        TCHAR*   pszPageIntro = new TCHAR[MAX_MESSAGE_LEN * 2];
        if (pszPageIntro)
        {
            LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER2, pszPageIntro, MAX_MESSAGE_LEN * 2);
            LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER3, szTemp, sizeof(szTemp));
            lstrcat(pszPageIntro, szTemp);
            SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER2), pszPageIntro);
            delete [] pszPageIntro;
        }
        LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER4, szTemp, MAX_MESSAGE_LEN);
        SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER3), szTemp);

    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_ISDN_NOOFFER;

    //Twiddle the buttons to do a finish page
    HWND hwndSheet = GetParent(hDlg);
    PropSheet_SetWizButtons(hwndSheet, PSWIZB_FINISH | PSWIZB_BACK);
    PropSheet_Changed(hDlg, hwndSheet);    
    
    return TRUE;
}


/*******************************************************************

  NAME:    ISDNNoofferOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ISDNNoofferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\isppage.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPPAGE.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "shlobj.h"
#include "webvwids.h"

TCHAR   szHTMLFile[MAX_PATH]; //Name of html file
BOOL    bOKToPersist = TRUE;
DWORD   g_dwPageType = 0;
BOOL    g_bWebGateCheck = TRUE;
BOOL    g_bConnectionErr = FALSE;

//PROTOTYPES
BOOL SaveISPFile( HWND hwndParent, TCHAR* szSrcFileName, DWORD dwFileType);

#if defined (DBG)
BOOL HtmlSaveAs( HWND hwndParent, TCHAR* szFileName, TCHAR* szTargetFileName);
void AskSaveISPHTML(HWND hWnd, LPTSTR lpszHTMLFile)
{
    HKEY hKey = NULL;
    DWORD dwTemp = 0;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(dwTemp);

    RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ISignup\\Debug"), &hKey);
    if (hKey)
    {
        RegQueryValueEx(hKey,TEXT("SaveIspHtmLocally"),0,&dwType,(LPBYTE)&dwTemp, &dwSize);
    
        if (dwTemp)
        {        
            if (IDYES == MessageBox(hWnd, TEXT("Would you like to save this ISP HTML file?"), TEXT("ICW -- DEBUG"), MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL))
                HtmlSaveAs(hWnd, lpszHTMLFile, NULL);
        }
    }
}
#endif      // dbg

void  InitPageControls
(
    HWND hDlg, 
    DWORD dwPageType,
    DWORD dwPageFlag
)
{
    TCHAR    szTemp[MAX_MESSAGE_LEN];
    switch (dwPageType)    
    {
        // TOS, has the Accept, Don't Accept UI
        case PAGETYPE_ISP_TOS:
        {    
            // Show the TOS controls
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSINSTRT),     SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML),       SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),       SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),     SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),    SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_TOS_TOSSAVE),           SW_SHOW);
            //hide "normal weboc"
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),          SW_HIDE);
            //hide the save check box controls
            ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),      SW_HIDE);
            // Reset the TOS page
            Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),BST_UNCHECKED);

            // Set tab focus
            SetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), GWL_STYLE, GetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),GWL_STYLE)|WS_TABSTOP);            
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),  TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),   TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),     TRUE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            break;
        }    
        
        // Finish, Custom Finish, and Normal are the same from a UI perspective (Also default)            
        case PAGETYPE_ISP_CUSTOMFINISH:
        case PAGETYPE_ISP_FINISH:
        case PAGETYPE_ISP_NORMAL:
        default:
        {
            BOOL bIsQuickFinish = FALSE;
            // Need to see if this is a Quick Finish page
            gpWizardState->pHTMLWalker->get_IsQuickFinish(&bIsQuickFinish);
        
            // Hide the TOS controls
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSINSTRT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML),       SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),    SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_TOS_TOSSAVE),           SW_HIDE);
    
            if (dwPageFlag & PAGEFLAG_SAVE_CHKBOX)
            {
                // Show check box controls 
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),  SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),   SW_SHOW);
                // Hide the normal controls
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),      SW_HIDE);
                //Reenable the UI
                EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), TRUE);
            }
            else
            {
                //show "normal" web oc
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),      SW_SHOW);
                // Hide the Checkbox controls
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),   SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),  SW_HIDE);
            }
            
            //set the wizard buttons
            // If we are on a Custom Finish, or Quick finish page then
            // use Active the Finish button
            PropSheet_SetWizButtons(GetParent(hDlg), 
                                   ((bIsQuickFinish || (PAGETYPE_ISP_CUSTOMFINISH == dwPageType)) ? PSWIZB_FINISH : PSWIZB_NEXT) | PSWIZB_BACK);
            break;
        }
    }

    // Change the title for the finish page
    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
    {
        LoadString(ghInstanceResDll, IDS_STEP3_TITLE, szTemp, MAX_MESSAGE_LEN);
    }
    else
    {
        if((PAGETYPE_ISP_CUSTOMFINISH == dwPageType ) || (PAGETYPE_ISP_FINISH == dwPageType))
            LoadString(ghInstanceResDll, IDS_STEP3_TITLE, szTemp, MAX_MESSAGE_LEN);
        else
            LoadString(ghInstanceResDll, IDS_STEP2_TITLE, szTemp, MAX_MESSAGE_LEN);
    }
    PropSheet_SetHeaderTitle(GetParent(hDlg), EXE_NUM_WIZARD_PAGES + ORD_PAGE_ISPDATA, szTemp);
}    


HRESULT InitForPageType
(
    HWND    hDlg
)
{
    DWORD   dwPageType = 0;
    DWORD   dwPageFlag = 0;
    BOOL    bRetVal    = FALSE;
    HRESULT hRes       = E_FAIL;
    BSTR    bstrPageID = NULL;
    BSTR    bstrHTMLFile = NULL;
    
    //make sure these are disabled here incase getpagetype fails
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),    FALSE);

    // Get webgate to dump the HTML into a file            
    gpWizardState->pWebGate->DumpBufferToFile(&bstrHTMLFile, &bRetVal);

    // Use the Walker to get the page type
    gpWizardState->pHTMLWalker->AttachToMSHTML(bstrHTMLFile);
    gpWizardState->pHTMLWalker->Walk();
    
    // Setup the controls based on the page type
    if (FAILED(hRes = gpWizardState->pHTMLWalker->get_PageType(&dwPageType)))
    {
        gpWizardState->pRefDial->DoHangup();
        g_bMalformedPage = TRUE; //used by server error to get correct msg
    }
    else
    {    
        if (dwPageType == PAGETYPE_ISP_TOS)
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(NULL, NULL);
            }
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML), PAGETYPE_ISP_TOS);
        }
        else        
        {
            RECT    rcHTML;
            HWND    hWndHTML;
            
            gpWizardState->pHTMLWalker->get_PageFlag(&dwPageFlag);
    
            if (dwPageFlag & PAGEFLAG_SAVE_CHKBOX) 
            {
                hWndHTML = GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML);
                // See if we need to display the app background bitmap in the HTML
                // window
                if(gpWizardState->cmnStateData.bOEMCustom)
                {
                    GetWindowRect(hWndHTML, &rcHTML);
                    MapWindowPoints(NULL, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcHTML, 2);
                    gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &rcHTML);
                }
                gpWizardState->pICWWebView->ConnectToWindow(hWndHTML, PAGETYPE_ISP_NORMAL);
            }
            else
            {
                hWndHTML = GetDlgItem(hDlg, IDC_ISPDATA_HTML);
                // See if we need to display the app background bitmap in the HTML
                // window
                if(gpWizardState->cmnStateData.bOEMCustom)
                {
                    GetWindowRect(hWndHTML, &rcHTML);
                    MapWindowPoints(NULL, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcHTML, 2);
                    gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &rcHTML);
                }
                gpWizardState->pICWWebView->ConnectToWindow(hWndHTML, PAGETYPE_ISP_NORMAL);
            }
        }

        // Custom finish means that the ISP wants us to show some special text
        // and then finish the wizard
        if (dwPageType == PAGETYPE_ISP_CUSTOMFINISH)
        {
            BOOL bRetVal;
            
            // Show the page. no need to cache it    
            bOKToPersist = FALSE;
            lstrcpy(szHTMLFile, W2A(bstrHTMLFile));
            gpWizardState->pICWWebView->DisplayHTML(szHTMLFile);
            
            // Kill the idle timer and connection, since there are no more pages
            ASSERT(gpWizardState->pRefDial);
            
            KillIdleTimer();
            gpWizardState->pRefDial->DoHangup();
            gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
            gpWizardState->bDialExact = FALSE;
                
        }
        else
        {
            // In order to persist data entered by the user, we have to 
            // effectivly "cache" the pages, so that when the user goes back
            // we make MSHTML think that we are loading a page that it has seen
            // before, and it will then reload the persisted history.
            
            // This will be done by using the PAGEID value in the HTML to form a
            // temp file name, so that we can re-load the page date from that file
            // each time we see the same page ID value.
            
            // Get the Page ID.
            gpWizardState->pHTMLWalker->get_PageID(&bstrPageID);
            if (bOKToPersist && SUCCEEDED( gpWizardState->lpSelectedISPInfo->CopyFiletoISPPageCache(bstrPageID, W2A(bstrHTMLFile))))
            {
                // We have a "cache" file, so we can use it and persist data
                // Get the cache file name now, since we will need it later
                gpWizardState->lpSelectedISPInfo->GetCacheFileNameFromPageID(bstrPageID, szHTMLFile, sizeof(szHTMLFile));
            }        
            else
            {
                bOKToPersist = FALSE;
                lstrcpy(szHTMLFile, W2A(bstrHTMLFile));
            }
            
            // Display the page we just "cached"
            gpWizardState->pICWWebView->DisplayHTML(szHTMLFile);
            
            if (bOKToPersist)
            {
                // Restore any persisted data on this page.
                gpWizardState->lpSelectedISPInfo->LoadHistory(bstrPageID);
            }
            
            // Cleanup
            SysFreeString(bstrPageID);
        }
        
#if defined(DBG)
        AskSaveISPHTML(hDlg, szHTMLFile);
#endif

        InitPageControls(hDlg, dwPageType, dwPageFlag);
        g_dwPageType = dwPageType;
    }                                                
    // Detach the walker
    gpWizardState->pHTMLWalker->Detach();

    HideProgressAnimation();
    
    SysFreeString(bstrHTMLFile);
    
    return hRes;
}


/*******************************************************************

  NAME:    ISPPageInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPPageInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // Setup an Event Handler for RefDial and Webgate
        CINSHandlerEvent *pINSHandlerEvent;
        pINSHandlerEvent = new CINSHandlerEvent(hDlg);
        if (NULL != pINSHandlerEvent)
        {
            HRESULT hr;
            gpWizardState->pINSHandlerEvents = pINSHandlerEvent;
            gpWizardState->pINSHandlerEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pINSHandlerEvents, 
                                            DIID__INSHandlerEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pINSHandler, 
                                            &gpWizardState->pINSHandlerEvents->m_dwCookie, 
                                            NULL);     
        }    
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {      

        if (FAILED(InitForPageType(hDlg)))    
        {
            //The page type isn't recognized which means there's a problem
            //with the data. goto the serverr page
            gpWizardState->pRefDial->DoHangup();
            *puNextPage = ORD_PAGE_SERVERR;
        }
        
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPDATA;
    }
    return TRUE;
}


// Returns FALSE if we should stay on this page, TRUE if we should change pages
// the param bError indicates we should proceed to the server Error Page.
BOOL ProcessNextBackPage
(
    HWND    hDlg,
    BOOL    fForward,
    BOOL    *pfError
)
{           
    BOOL    bRet = FALSE;
    TCHAR   szURL[2*INTERNET_MAX_URL_LENGTH + 1] = TEXT("\0");
    
    *pfError = FALSE;
    
    gpWizardState->pHTMLWalker->get_URL(szURL, fForward);
         
    // See if a URL is Specified        
    if (lstrcmp(szURL, TEXT("")) == 0)
    {
        //Stop the animation
        HideProgressAnimation();
    
        //Reenable the UI
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
        
        // If forward, we want to force our way to the server error page,
        // since we cannot go forward to a blank URL
        if (fForward)
        {
            KillIdleTimer();
            gpWizardState->pRefDial->DoHangup();
            *pfError = TRUE;
        }
        else
        {
            // We are backing out of ISP page land, so lets hangup.
            if(gpWizardState->pRefDial)
            {
                BOOL bRetVal;
                KillIdleTimer();
                gpWizardState->pRefDial->DoHangup();
                gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
                gpWizardState->bDialExact = FALSE;
            }                
        }
        // We will need to navigate away from the ISP page
        bRet = TRUE;
    }
    else
    {
        
        BOOL    bRetWebGate;
        BOOL    bConnected = FALSE;
        g_bWebGateCheck = TRUE;
        g_bConnectionErr = FALSE;
        
        // Do not go to the next page. Also valid for the cancel case
        bRet = FALSE;
    
        // Kill the idle Timer
        KillIdleTimer();
        
        // Tell webgate to go fetch the page
        gpWizardState->pWebGate->put_Path(A2W(szURL));
        gpWizardState->pWebGate->FetchPage(0,0,&bRetWebGate);
    
        //This flag is only to be used by ICWDEBUG.EXE
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
            bConnected = TRUE;
        else
            gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);
        
        if (bConnected)
        {
            WaitForEvent(gpWizardState->hEventWebGateDone);
        }
        else
        {
            g_bConnectionErr = TRUE;
        }
        // See if the user canceled.  If so we want to force the wizard to bail.
        // this can be hacked by forcing the return value to be FALSE and
        // setting the gfQuitWizard flag to TRUE. Gendlg will check this flag
        // when the OK proc returns, and process appropriatly
        if (!gfUserCancelled)
        {
            if (g_bConnectionErr)
            {
                // Make it go to server error page
                bRet = TRUE;
                *pfError = TRUE;
            }
            else
            {

                // Restart the Idle Timer
                StartIdleTimer();
            
                // detach the walker, since Init for page type needs it
                gpWizardState->pHTMLWalker->Detach();
            
                // Setup for this page
                if (FAILED(InitForPageType(hDlg)))    
                {
                    //The page type isn't recognized which means there's a problem
                    //with the data. goto the serverr page
                    *pfError = TRUE;
                     bRet    = TRUE;
                }
            }

        }
        else
        {
            // Force the wizard to quit, since the user canceled
            gfQuitWizard = TRUE;
        }                    
    }
    
    return bRet;
}    
/*******************************************************************

  NAME:    ISPPageOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPPageOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    DWORD           dwPageType;
    TCHAR           szURL[2*INTERNET_MAX_URL_LENGTH + 1] = TEXT("\0");
    BOOL            bRetVal = TRUE;
    BSTR            bstrPageID = NULL;
    IWebBrowser2    *lpWebBrowser;

    // We don't want to keep any of the ISP pages in the history list
    *pfKeepHistory = FALSE;
    
    // If we are going forward, and if the user has been autodisconnected, then
    // we want to automatically navigate to the server error page.
    if (fForward && gpWizardState->bAutoDisconnected)
    {
        gpWizardState->bAutoDisconnected = FALSE;
        *puNextPage = ORD_PAGE_SERVERR;
        return TRUE;
    }
    
    // Attach the walker to the curent page to get the page type
    gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
    gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
    gpWizardState->pHTMLWalker->Walk();
    gpWizardState->pHTMLWalker->get_PageType(&dwPageType);
    
    // Custom finish means we just exit, so we just need to return TRUE
    if (PAGETYPE_ISP_CUSTOMFINISH == dwPageType)
    {
        gpWizardState->pHTMLWalker->Detach();
        return TRUE;
    }
    
    // Check the TOS settings. If the users decline, don't allow them to proceed
    if (IsWindowVisible(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE)) )
    {
        if (fForward)
        {
            if (Button_GetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE)))
            {
                if (MsgBox(hDlg,IDS_ERR_TOS_DECLINE,MB_ICONSTOP,MB_OKCANCEL) != IDOK)
                {
                    gfQuitWizard = TRUE;
                }
                Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), 0);
                Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), 0);
                // Set tab focus
                SetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), GWL_STYLE, GetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),GWL_STYLE)|WS_TABSTOP);            
                SetFocus(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML));
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                return FALSE;
            }
        }
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), FALSE);
    }    


    //Show the progress animation 
    ShowProgressAnimation();
    
    //Disable the UI
    PropSheet_SetWizButtons(GetParent(hDlg), 0);

    if (bOKToPersist)
    {
        // Persist any data on this page.
        gpWizardState->pHTMLWalker->get_PageID(&bstrPageID);
        gpWizardState->lpSelectedISPInfo->SaveHistory(bstrPageID);
        SysFreeString(bstrPageID);
    }
    
    // User going back?
    if (fForward)
    {
        // Depending on the page type, we do different things
        switch (dwPageType)    
        {
            // The finish page types, mean that what we fetch next is an INS file
            case PAGETYPE_ISP_FINISH:
            {
                BSTR    bstrINSFile;
                BSTR    bstrStartURL;
                BOOL    bRet;
                BOOL    bIsQuickFinish = FALSE;
                long    lBrandingFlags;
            
                gpWizardState->pHTMLWalker->get_URL(szURL, TRUE);
            
                // Kill the idle timer
                KillIdleTimer();
            
                gpWizardState->pHTMLWalker->get_IsQuickFinish(&bIsQuickFinish);
                
                if(!bIsQuickFinish)
                {
                    BOOL bConnected = FALSE;
                    g_bWebGateCheck = TRUE;
                    g_bConnectionErr = FALSE;

                    // Tell webgate to go fetch the page
                    gpWizardState->pWebGate->put_Path(A2W(szURL));
                    gpWizardState->pWebGate->FetchPage(1,0,&bRet);
        
                    //This flag is only to be used by ICWDEBUG.EXE
                    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                        bConnected = TRUE;
                    else
                        // Check for connection status before proceed
                        gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);
                    
                    if (bConnected)
                    {
                        WaitForEvent(gpWizardState->hEventWebGateDone);
                    }
                    else
                    {
                        bConnected = TRUE;
                    }

                    if (g_bConnectionErr)
                    {
                        gpWizardState->pRefDial->DoHangup();
                        *puNextPage = ORD_PAGE_SERVERR;
                        break;
                    }
            
                    // Can't allow the user to cancel now
                    PropSheet_CancelToClose(GetParent(hDlg));       
                    PropSheet_SetWizButtons(GetParent(hDlg),0);
                    UpdateWindow(GetParent(hDlg));
                
                     //Stop the animation
                     HideProgressAnimation();

                    // See if the user canceled while downloading the INS file
                    if (!gfUserCancelled)
                    {   
                        // OK process the INS file.
                        gpWizardState->pWebGate->get_DownloadFname(&bstrINSFile);
                
                        // Get the Branding flags
                        gpWizardState->pRefDial->get_BrandingFlags(&lBrandingFlags);
                
                        // Tell the INSHandler about the branding flags
                        gpWizardState->pINSHandler->put_BrandingFlags(lBrandingFlags);

                        // Process the inf file.
                        gpWizardState->pINSHandler->ProcessINS(bstrINSFile, &bRet);

                        //hang on to whether or not this failed.
                        gpWizardState->cmnStateData.ispInfo.bFailedIns = !bRet;

                        // Get the Start URL from INS file.
                        gpWizardState->pINSHandler->get_DefaultURL(&bstrStartURL);
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szStartURL, 
                                 W2A(bstrStartURL));
                    
                        // Time to retun to the main wizard
                        *puNextPage = g_uExternUINext;
                
                        // Detach the walker before we go
                        gpWizardState->pHTMLWalker->Detach();
                
                        //Copy over the isp name and support number for the last page.
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szISPName, 
                                 gpWizardState->lpSelectedISPInfo->get_szISPName());
                    
                        BSTR bstrSupportPhoneNum;
                        gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);
                    
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szSupportNumber, 
                                 W2A(bstrSupportPhoneNum));
                             
                    }
                    else
                    {
                        // The user canceled while we were donwloading the INS, so lets bail
                        gpWizardState->pHTMLWalker->Detach();
                        gfQuitWizard = TRUE;
                        bRetVal = FALSE;
                    } 
                }
                else
                    HideProgressAnimation();

                // Let the wizard Continue/Finish
                break;
            }
           
            // These page types mean that we need to form a new URL, and get the next page
            case PAGETYPE_ISP_TOS:
            case PAGETYPE_ISP_NORMAL:
            {
                BOOL    bError;
                
                bRetVal = ProcessNextBackPage(hDlg, TRUE, &bError);
                
                if (bError)
                {
                    // Go to the server error page
                    gpWizardState->pRefDial->DoHangup();
                    *puNextPage = ORD_PAGE_SERVERR;
                }
                break;
            }
            default:
            {
                //Stop the animation
                HideProgressAnimation();

                gpWizardState->pRefDial->DoHangup();
                // Goto the server error page, since we surely did not recognize this page type
                *puNextPage = ORD_PAGE_SERVERR;
                break;        
            }
        }            
    }
    else
    {
        // Going Backwards.
        BOOL    bError;
                
        bRetVal = ProcessNextBackPage(hDlg, FALSE, &bError);
                
        if (bError)
        {
            // Go to the server error page
            *puNextPage = ORD_PAGE_SERVERR;
        }
    }
    
    return bRetVal;
}

/*******************************************************************

  NAME:    ISPCmdProc

********************************************************************/
BOOL CALLBACK ISPCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_ISPDATA_TOSACCEPT: 
                case IDC_ISPDATA_TOSDECLINE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    break;
                }
                case IDC_ISPDATA_TOSSAVE:
                {
                    if  (SaveISPFile(hDlg, szHTMLFile, g_dwPageType))
                    {        
                        SetFocus(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML));
                        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), FALSE);
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_ISPDATA_TOSACCEPT: 
                case IDC_ISPDATA_TOSDECLINE:
                {
                    // somebody double-clicked a radio button
                    // auto-advance to the next page
                    PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
                default:
                    break;
            }
            break;
        }
        case BN_SETFOCUS:
        {
            if ((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ISPDATA_TOSACCEPT) )
            {
                CheckDlgButton(hDlg, IDC_ISPDATA_TOSACCEPT, BST_CHECKED);

                // Uncheck the decline checkbox make sure no two radio button
                // selected at the same time.
                CheckDlgButton(hDlg, IDC_ISPDATA_TOSDECLINE, BST_UNCHECKED);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }
            break;
        }
        default:
            break;
    }
    return 1;
}



/*******************************************************************

  NAME:     DisplayConfirmationDialog

  SYNOPSIS: Display a confirmation dialog for the file being written

  ENTRY:    hwndParent - dialog window
            dwFileType - current isp page type
            szFileName - source file name

  EXIT:     returns TRUE when save successfully; FALSE otherwise.

********************************************************************/
BOOL DisplayConfirmationDialog(HWND hwndParent, DWORD dwFileType, TCHAR* szFileName)
{
    TCHAR   szFinal [MAX_MESSAGE_LEN] = TEXT("\0");
    TCHAR   szFmt   [MAX_MESSAGE_LEN];
    TCHAR   *args   [1];
    LPVOID  pszIntro;
    BOOL    bRet = TRUE;
    UINT    uMsgID;

    args[0] = (LPTSTR) szFileName;
    
    if (PAGETYPE_ISP_TOS == dwFileType)
    {
        uMsgID = IDS_SAVE_COPY_CONFIRM_MSG;
    }
    else 
    {
        uMsgID = IDS_SAVE_ISP_CONFIRM_MSG;
    }

    LoadString(ghInstanceResDll, uMsgID, szFmt, ARRAYSIZE(szFmt));
                
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                  szFmt, 
                  0, 
                  0, 
                  (LPTSTR)&pszIntro, 
                  0,
                  (va_list*)args);
                  
    lstrcpy(szFinal, (LPTSTR)pszIntro);
        
    LoadString(ghInstanceResDll, IDS_APPNAME, szFmt, ARRAYSIZE(szFmt));

    MessageBox(hwndParent, szFinal, szFmt, MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);

    LocalFree(pszIntro);
    
    return(bRet);
}



/*******************************************************************

  NAME:     SaveISPFile

  SYNOPSIS: Called want to save html file to desktop without dialog

  ENTRY:    hwndParent - dialog window
            szSrcFileName - source file name
            uFileType - Type of files embedded in the htm file

  EXIT:     returns TRUE when save successfully; FALSE otherwise.

********************************************************************/
BOOL SaveISPFile( HWND hwndParent, TCHAR* szSrcFileName, DWORD dwFileType)
{
    
    TCHAR         szNewFileBuff [MAX_PATH + 1];
    TCHAR         szWorkingDir  [MAX_PATH + 1];     
    TCHAR         szDesktopPath [MAX_PATH + 1];     
    TCHAR         szLocalFile   [MAX_PATH + 1];   
    TCHAR         szISPName     [MAX_ISP_NAME + 1];  
    TCHAR         szFmt         [MAX_MESSAGE_LEN];
    TCHAR         szNumber      [MAX_MESSAGE_LEN];
    TCHAR         *args         [2];
    DWORD         dwFileFormatOrig;
    DWORD         dwFileFormatCopy;
    LPTSTR        pszInvalideChars             = TEXT("\\/:*?\"<>|");
    LPVOID        pszIntro                     = NULL;
    LPITEMIDLIST  lpItemDList                  = NULL;
    HRESULT       hr                           = E_FAIL; //don't assume success
    IMalloc      *pMalloc                      = NULL;
    BOOL          ret                          = FALSE;
    
    ASSERT(hwndParent);
    ASSERT(szFileName);

    // Validate page type, return false if page type is unknown
    if (PAGETYPE_ISP_TOS == dwFileType)
    {
        dwFileFormatOrig = IDS_TERMS_FILENAME;
        dwFileFormatCopy = IDS_TERMS_FILENAME_COPY;
    }
    else if ((PAGETYPE_ISP_CUSTOMFINISH == dwFileType) ||
          (PAGETYPE_ISP_FINISH == dwFileType) ||
          (PAGETYPE_ISP_NORMAL == dwFileType))
    {
        dwFileFormatOrig = IDS_ISPINFO_FILENAME;
        dwFileFormatCopy = IDS_ISPINFO_FILENAME_COPY;
    }
    else
    {
        return FALSE;
    }

    GetCurrentDirectory(ARRAYSIZE(szWorkingDir), szWorkingDir);
    
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList);
 
    //Get the "DESKTOP" dir 
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, szDesktopPath);
        
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }


    // Replace invalid file name char in ISP name with underscore
    lstrcpy(szISPName, gpWizardState->lpSelectedISPInfo->get_szISPName());
    for( int i = 0; szISPName[i]; i++ )
    {
        if(_tcschr(pszInvalideChars, szISPName[i])) 
        {
            szISPName[i] = '_';
        }
    }

    // Load the default file name
    args[0] = (LPTSTR) szISPName;
    args[1] = NULL;
    LoadString(ghInstanceResDll, dwFileFormatOrig, szFmt, ARRAYSIZE(szFmt));
        
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                  szFmt, 
                  0, 
                  0, 
                  (LPTSTR)&pszIntro, 
                  0,
                  (va_list*)args);

    lstrcat(szDesktopPath, TEXT("\\"));
    wsprintf(szLocalFile, TEXT("\"%s\""), (LPTSTR)pszIntro);
    lstrcpy(szNewFileBuff, szDesktopPath);
    lstrcat(szNewFileBuff, (LPTSTR)pszIntro);
    LocalFree(pszIntro);

    // Check if file already exists
    if (0xFFFFFFFF != GetFileAttributes(szNewFileBuff))
    {
        // If file exists, create new filename with paranthesis
        int     nCurr = 1;
        do
        {
            wsprintf(szNumber, TEXT("%d"), nCurr++);
            args[1] = (LPTSTR) szNumber;

            LoadString(ghInstanceResDll, dwFileFormatCopy, szFmt, ARRAYSIZE(szFmt));
                
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                          szFmt, 
                          0, 
                          0, 
                          (LPTSTR)&pszIntro, 
                          0,
                          (va_list*)args);
            lstrcpy(szNewFileBuff, szDesktopPath);
            wsprintf(szLocalFile, TEXT("\"%s\""), (LPTSTR)pszIntro);
            lstrcat(szNewFileBuff, (LPTSTR)pszIntro);
            LocalFree(pszIntro);
        } while ((0xFFFFFFFF != GetFileAttributes(szNewFileBuff)) && (nCurr <= 100));

    }

    // Copy the file to permanent location
    HANDLE hFile = CreateFile(szNewFileBuff, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        IICWWalker* pHTMLWalker = NULL;
        BSTR bstrText           = NULL;
        DWORD dwByte            = 0;

        if (SUCCEEDED(CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                                       IID_IICWWalker,(LPVOID*)&pHTMLWalker)))
        {
            pHTMLWalker->InitForMSHTML();
            pHTMLWalker->AttachToMSHTML(A2W(szSrcFileName));
            if (SUCCEEDED(pHTMLWalker->ExtractUnHiddenText(&bstrText)) && bstrText)
            {
                #ifdef UNICODE
                BYTE UNICODE_BYTE_ORDER_MARK[] = {0xFF, 0xFE};
                WriteFile(hFile, 
                          UNICODE_BYTE_ORDER_MARK,
                          sizeof(UNICODE_BYTE_ORDER_MARK),
                          &dwByte,
                          NULL);
                #endif
                ret = WriteFile(hFile, W2A(bstrText), lstrlen(W2A(bstrText))* sizeof(TCHAR), &dwByte, NULL);  
                SysFreeString(bstrText);
            }
            pHTMLWalker->TermForMSHTML();
            pHTMLWalker->Release();
        }
        CloseHandle(hFile);
    
    }

    // Display message according to the state of CopyFile
    if (!ret)
    {
        DeleteFile(szNewFileBuff);

        //let the user know there was not enough disk space
        TCHAR szTemp    [MAX_RES_LEN] = TEXT("\0"); 
        TCHAR szCaption [MAX_RES_LEN] = TEXT("\0"); 

        LoadString(ghInstanceResDll, IDS_NOT_ENOUGH_DISKSPACE, szTemp, ARRAYSIZE(szTemp));
        LoadString(ghInstanceResDll, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption));
        MessageBox(hwndParent, szTemp, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    }
    else
    {
        // Display the confirmation
        DisplayConfirmationDialog(hwndParent, dwFileType, szLocalFile);
    }

    return ret;
}

#if defined (DBG)
BOOL HtmlSaveAs( HWND hwndParent, TCHAR* szFileName, TCHAR* szTargetFileName)
{
    ASSERT(hwndParent);
    ASSERT(szFileName);
    
    OPENFILENAME  ofn;                                              
    TCHAR         szNewFileBuff [MAX_PATH + 1];
    TCHAR         szDesktopPath [MAX_PATH + 1] = TEXT("\0");     
    TCHAR         szWorkingDir  [MAX_PATH + 1] = TEXT("\0");     
    TCHAR         szFilter      [255]          = TEXT("\0");
    LPITEMIDLIST  lpItemDList                  = NULL;
    HRESULT       hr                           = E_FAIL; //don't assume success
    IMalloc      *pMalloc                      = NULL;
    BOOL          ret = TRUE;
    
    GetCurrentDirectory(ARRAYSIZE(szWorkingDir), szWorkingDir);
    
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList);
 
    //Get the "DESKTOP" dir 
       ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, szDesktopPath);
        
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }

    if (szTargetFileName != NULL)
    {
        lstrcpy(szNewFileBuff, szDesktopPath);
        lstrcat(szNewFileBuff, TEXT("\\"));
        lstrcat(szNewFileBuff, szTargetFileName);
       
        // Copy temporary file to permanent location
        ret = CopyFile(szFileName, szNewFileBuff, FALSE);
    }
    else
    {
        //Setup the filter
        LoadString(ghInstanceResDll, IDS_DEFAULT_TOS_FILTER, szFilter, sizeof(szFilter)); // "HTML Files"
        
        //Setup the default file name
        if(!LoadString(ghInstanceResDll, IDS_DEFAULT_TOS_FILENAME, szNewFileBuff, sizeof(szNewFileBuff))) // "terms"
            lstrcpy(szNewFileBuff, TEXT("terms"));
        lstrcat(szNewFileBuff, TEXT(".htm"));

        //init the filename struct
        ofn.lStructSize       = sizeof(OPENFILENAME); 
        ofn.hwndOwner         = hwndParent; 
        ofn.lpstrFilter       = szFilter; 
        ofn.lpstrFile         = szNewFileBuff;  
        ofn.nMaxFile          = sizeof(szNewFileBuff); 
        ofn.lpstrFileTitle    = NULL; 
        ofn.lpstrInitialDir   = szDesktopPath; 
        ofn.lpstrTitle        = NULL;
        ofn.lpstrCustomFilter = (LPTSTR) NULL;
        ofn.nMaxCustFilter    = 0L;
        ofn.nFileOffset       = 0;
        ofn.nFileExtension    = 0;
        ofn.lpstrDefExt       = TEXT("*.htm");
        ofn.lCustData         = 0;
        ofn.nFilterIndex      = 1L;
        ofn.nMaxFileTitle     = 0;
        ofn.Flags             = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY |
                                OFN_EXPLORER      | OFN_LONGNAMES | OFN_OVERWRITEPROMPT;  
   
        //Call the SaveAs common dlg
        if(TRUE == GetSaveFileName(&ofn))
        {
            HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                IICWWalker* pHTMLWalker = NULL;
                BSTR bstrText           = NULL;
                DWORD dwByte            = 0;

                if (SUCCEEDED(CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                                               IID_IICWWalker,(LPVOID*)&pHTMLWalker)))
                {
                    pHTMLWalker->InitForMSHTML();
                    pHTMLWalker->AttachToMSHTML(A2W(szFileName));
                    if (SUCCEEDED(pHTMLWalker->ExtractUnHiddenText(&bstrText)) && bstrText)
                    {
                        ret = WriteFile(hFile, W2A(bstrText), lstrlen(W2A(bstrText)), &dwByte, NULL);  
                        SysFreeString(bstrText);
                    }
                    pHTMLWalker->TermForMSHTML();
                    pHTMLWalker->Release();
                }
                CloseHandle(hFile);
            
            }
            if (!ret)
            {
                DeleteFile(ofn.lpstrFile);

                //let the user know there was not enough disk space
                TCHAR szTemp    [MAX_RES_LEN] = TEXT("\0"); 
                TCHAR szCaption [MAX_RES_LEN] = TEXT("\0"); 

                LoadString(ghInstanceResDll, IDS_NOT_ENOUGH_DISKSPACE, szTemp, ARRAYSIZE(szTemp));
                LoadString(ghInstanceResDll, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption));
                MessageBox(hwndParent, szTemp, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
            }
        }
    }    
    SetCurrentDirectory(szWorkingDir);
    return ret;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ispasel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPSEL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "exdisp.h"
#include "shldisp.h"
#include <htiframe.h>
#include <mshtml.h>

const TCHAR cszISPINFOPath[] = TEXT("download\\ispinfo.csv");
int  iNumOfAutoConfigOffers = 0;
BOOL g_bSkipSelPage = FALSE;


// Convert a supplied icon from it's GIF format to an ICO format

extern void ConvertISPIcon(LPTSTR lpszLogoPath, HICON* hIcon);
extern BOOL AddItemToISPList
(
    HWND        hListView,
    int         iItemIndex,
    LPTSTR      lpszIspName,
    int         iIspLogoIndex,
    BOOL        bCNS,
    LPARAM      lParam,
    BOOL        bFilterDupe
);
extern BOOL InitListView(HWND  hListView);
extern BOOL ResetListView(HWND  hListView);
extern BOOL CALLBACK ValidateISP(HWND hDlg);

/*******************************************************************

  NAME:    ParseISPInfo

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ParseISPInfo
(
    HWND hDlg, 
    TCHAR *pszCSVFileName,
    BOOL bCheckDupe
)
{
    // On the first init, we will read the ISPINFO.CSV file, and populate the ISP LISTVIEW

    CCSVFile    far *pcCSVFile;
    CISPCSV     far *pcISPCSV;
    BOOL        bRet = TRUE;
    BOOL        bHaveCNSOffer = FALSE;
    HICON       hISPLogo;
    int         iImage;
    HRESULT     hr;
                

    // Open and process the CSV file
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        // BUGBUG: Show Error Message
    
        return (FALSE);
    }            

    if (!pcCSVFile->Open(pszCSVFileName))
    {
        // BUGBUG: Show Error Message          
        AssertMsg(0,"Can not open ISPINFO.CSV file");
        delete pcCSVFile;
        pcCSVFile = NULL;
    
        return (FALSE);
    }

    // Read the first line, since it contains field headers
    pcISPCSV = new CISPCSV;
    if (!pcISPCSV)
    {
        // BUGBUG Show error message
        delete pcCSVFile;
        //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
        return (FALSE);
    }

    if (ERROR_SUCCESS != (hr = pcISPCSV->ReadFirstLine(pcCSVFile)))
    {
        // Handle the error case
        delete pcCSVFile;
        //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
        pcCSVFile = NULL;
    
        return (FALSE);
    }
    delete pcISPCSV;        // Don't need this one any more

    do {
        // Allocate a new ISP record
        pcISPCSV = new CISPCSV;
        if (!pcISPCSV)
        {
            // BUGBUG Show error message
            bRet = FALSE;
            //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
            break;
        
        }
    
        // Read a line from the ISPINFO file
        hr = pcISPCSV->ReadOneLine(pcCSVFile);
        if (hr == ERROR_SUCCESS)
        {
            // If this line contains a nooffer flag, then leave now
            if (!(pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OFFERS)) 
            {
                //iNumOfAutoConfigOffers = 0;
                break;
            }
            if ((pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_AUTOCONFIG) &&
                (gpWizardState->bISDNMode ? (pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_ISDN_OFFER) : TRUE) )
            {
                    // Convert the ISP logo from a GIF to an ICON, and add it to the Image List
                    ConvertISPIcon(pcISPCSV->get_szISPLogoPath(), &hISPLogo);   
                    iImage =  ImageList_AddIcon(gpWizardState->himlIspSelect, hISPLogo);
            
                    DestroyIcon(hISPLogo);
                    pcISPCSV->set_ISPLogoImageIndex(iImage);

                    // Add the entry to the list view
                    if (AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                      iNumOfAutoConfigOffers, 
                                      pcISPCSV->get_szISPName(), 
                                      pcISPCSV->get_ISPLogoIndex(),
                                      FALSE,
                                      (LPARAM)pcISPCSV,
                                      bCheckDupe))
                    {
                       ++iNumOfAutoConfigOffers;
                    }

            }
            else
            {
                delete pcISPCSV;
            }
        }
        else if (hr == ERROR_NO_MORE_ITEMS)
        {   
            delete pcISPCSV;        // We don't need this one
            break;
        }
        else if (hr == ERROR_FILE_NOT_FOUND) 
        {   
            // do not show this ISP when its data is invalid
            // we don't want to halt everything. Just let it contine
            delete pcISPCSV;
        }
        else
        {
            // Show error message Later
            delete pcISPCSV;
            //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
            bRet = FALSE;
            break;
        }           
    
    } while (TRUE);

    delete pcCSVFile;

    return bRet;
}
/*******************************************************************

  NAME:    ISPAutoSelectInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPAutoSelectInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // Initialize the List View
        InitListView(GetDlgItem(hDlg, IDC_ISPLIST));
        gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    }
    else
    {
        gpWizardState->bISDNMode = gpWizardState->cmnStateData.bIsISDNDevice;
        if (g_bSkipSelPage)
        {
            g_bSkipSelPage = FALSE;
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
        }
        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            // If there are items in the list view, clear them
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

            // Initialize the number of autocfg offers to zero
            iNumOfAutoConfigOffers = 0;
            gpWizardState->lpSelectedISPInfo = NULL;

            // Always try to parse offline folder.  If there is nothing there, 
            // it will simple return FALSE.
            if (gpWizardState->cmnStateData.bOEMOffline)
                ParseISPInfo(hDlg, ICW_OEMINFOPath, TRUE);

            // Read and parse the download folder.
            ParseISPInfo(hDlg, ICW_ISPINFOPath, TRUE);

            // Create a "other" selection in the list view for unlisted ISPs
            if (iNumOfAutoConfigOffers > 0 )
            {
                // Adding Other
                TCHAR szOther  [MAX_RES_LEN+1] = TEXT("\0");
                LoadString(ghInstanceResDll, IDS_ISP_AUTOCONFIG_OTHER, szOther, sizeof(szOther));
                AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                  iNumOfAutoConfigOffers, 
                                  szOther, 
                                  -1,
                                  FALSE,
                                  (LPARAM)NULL,
                                  FALSE);                         
                ResetListView(GetDlgItem(hDlg, IDC_ISPLIST));
            }
        }
        // The following 3 Cases can happen at this point:
        // 1) The ispinfo.csv contains a line says no offer, we go to nooffer page
        // 2) The ispinfo.csv contains no line of valid offer and no no-offer entry
        //    This may happen in calling the old referral.dll that ICW 3 client calls
        // 3) There are many offers but no ISDN offers, we go to ISDN offer pages
        // 4) Normal situation, some valid offers where we're in ISDN or not

        if (0 == iNumOfAutoConfigOffers)
        {
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
        }
        else if (ISP_INFO_NO_VALIDOFFER == iNumOfAutoConfigOffers)
        {
            // Error in ISPINFO.CSV if there is no offers and no no-offer entry
            // critical error
            *puNextPage = g_uExternUINext;
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            return FALSE;
        }
        else
        {
            if (0 == ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_ISPLIST)))
            {
                // Select the First Item in the Listview
                ListView_SetItemState(GetDlgItem(hDlg, IDC_ISPLIST), 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        
        gpWizardState->cmnStateData.bParseIspinfo = FALSE;
        gpWizardState->uCurrentPage = ORD_PAGE_ISP_AUTOCONFIG;

    }
    return TRUE;
}



/*******************************************************************

  NAME:    ISPAutoSelectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPAutoSelectOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        if (gpWizardState->lpSelectedISPInfo == NULL)
        {
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER; 
            return TRUE;
        }
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    return TRUE;
}


BOOL CALLBACK ISPAutoSelectNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CISPCSV     *pcISPCSV;

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - NM_DBLCLK");
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;

        case LVN_ITEMCHANGED:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - LVN_ITEMCHANGED");

            if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
                ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
            {
                // IF an Item just became selected, then render it's HTML content
                pcISPCSV = (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;

                // Remember the selected item for later use
                gpWizardState->lpSelectedISPInfo = pcISPCSV;
            }
            break;
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo 
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            gpWizardState->lpSelectedISPInfo = NULL;
            SetPropSheetResult(hDlg,TRUE);
            break;
        
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
                delete  (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
            break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ispsel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPSEL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "exdisp.h"
#include "shldisp.h"
#include <htiframe.h>
#include <mshtml.h>

#define FIRST_CTL_OFFSET    1      // offset of the first control
                                   // in DLUs. This is used when in 
                                   // OEM custom mode to determin how 
                                   // much to shift up the other controls
BOOL    gbHaveCNSOffer = FALSE;
int     g_nIndex = 0;

/*******************************************************************

  NAME:         SetHeaderFonts

  SYNOPSIS:     Set the font of the header title

  ENTRY:        hDlg - dialog window
                phFont - font we needed

********************************************************************/
BOOL SetHeaderFonts(HWND hDlg, HFONT *phFont)
{
    HFONT   hFont;
    LOGFONT LogFont;

    GetObject(GetWindowFont(hDlg), sizeof(LogFont), &LogFont);

    LogFont.lfWeight = FW_BOLD;
    if ((hFont = CreateFontIndirect(&LogFont)) == NULL)
    {
        *phFont = NULL;
        return FALSE;
    }
    *phFont = hFont;
    return TRUE;
}


/*******************************************************************

  NAME:         WriteISPHeaderTitle

  SYNOPSIS:     Write the header on the ISP sel page

  ENTRY:        hDlg - dialog window
                hdc - device context
                uTitle - IDS constant for the title

********************************************************************/
void WriteISPHeaderTitle(HWND hDlg, UINT uDlgItem)
{
    HGDIOBJ     hFontOld = NULL;
    HFONT       hFont = NULL;

    if (!SetHeaderFonts(hDlg, &hFont))
    {
        hFont = GetWindowFont(hDlg);
    }

    HDC hdc = GetDC(hDlg);
    if (hdc)
    {
        hFontOld = SelectObject(hdc, hFont);

        SendMessage(GetDlgItem(hDlg, uDlgItem),WM_SETFONT,(WPARAM)hFont,MAKELPARAM(TRUE,0));
    
        if (hFontOld)
            SelectObject(hdc, hFontOld);
        ReleaseDC(hDlg, hdc);
    }

    return;
}

// Convert a supplied icon from it's GIF format to an ICO format
void ConvertISPIcon(LPTSTR lpszLogoPath, HICON* hIcon)
{
    ASSERT(gpWizardSatet->pGifConvert);
    
    TCHAR szPath[MAX_PATH+1] = TEXT("\0");
    GetCurrentDirectory(MAX_PATH+1, szPath);
    lstrcat(szPath, TEXT("\\"));
    lstrcat(szPath, lpszLogoPath);

    gpWizardState->pGifConvert->GifToIcon(szPath, 16, hIcon);
}    

// Insert an element into the ISP select list view
BOOL AddItemToISPList
(
    HWND        hListView,
    int         iItemIndex,
    LPTSTR      lpszIspName,
    int         iIspLogoIndex,
    BOOL        bCNS,
    LPARAM      lParam,
    BOOL        bFilterDupe
)
{

    LVITEM  LVItem;
    LVItem.mask         = LVIF_IMAGE | LVIF_TEXT | LVIF_PARAM;
    LVItem.iItem        = iItemIndex;
    LVItem.iSubItem     = 0;
    LVItem.iImage       = iIspLogoIndex;
    LVItem.pszText      = lpszIspName;
    LVItem.lParam       = lParam;
    BOOL bOKToAdd       = TRUE;
    int  nMatch         = 0;

    if (bFilterDupe)
    {
        // Find the duplicate
        LVITEM     CurLVItem;
        CISPCSV     *pcISPCSV;
        int iNum = ListView_GetItemCount(hListView);
        LPTSTR szMirCode = ((CISPCSV*)lParam)->get_szMir();
        WORD   wLCID = ((CISPCSV*)lParam)->get_wLCID();
        memset(&CurLVItem, 0, sizeof(CurLVItem));
        for ( int i = 0; i < iNum; i++)
        {
            CurLVItem.mask         = LVIF_TEXT | LVIF_PARAM;
            CurLVItem.iItem        = i;
            if (ListView_GetItem(hListView, &CurLVItem))
            {
                if (NULL != (pcISPCSV = (CISPCSV*) CurLVItem.lParam) )
                {
                    // check for Mir code for duplicate
                    if (0 == lstrcmp(pcISPCSV->get_szMir(), szMirCode))
                    {
                        // Check for LCID, if different LCID, show both offers
                        if (pcISPCSV->get_wLCID() == wLCID)
                        {
                            bOKToAdd = FALSE;
                            // Replace this one with the current one
                            nMatch = i; 
                            if (gpWizardState->lpSelectedISPInfo == pcISPCSV)
                            {
                                gpWizardState->lpSelectedISPInfo = (CISPCSV*)lParam;
                            }
                            delete pcISPCSV;
                            break;
                        }
                    }
                }
            }
        }

    }

    
    // Insert the Item if it is not a dupe
    if (bOKToAdd)
    {
        ListView_InsertItem(hListView, &LVItem);
    }
    else
    {
        iItemIndex = nMatch;
        LVItem.iItem = iItemIndex;
        ListView_SetItem(hListView, &LVItem);
    }

    // Set the ISP name into column 1
    ListView_SetItemText(hListView, iItemIndex, 1, lpszIspName);

    // If this dude is click and surf, then turn on the CNS graphic, in column 2
    if (bCNS)
    {  
        LVItem.mask        = LVIF_IMAGE;
        LVItem.iItem       = iItemIndex;
        LVItem.iSubItem    = 2;
        LVItem.iImage      = 0;
        ListView_SetItem(hListView, &LVItem);
    }
    
    return bOKToAdd;
}        
    
/*******************************************************************

  NAME:         ParseISPCSV

  SYNOPSIS:     Called when page is displayed

  ENTRY:        hDlg - dialog window
                fFirstInit - TRUE if this is the first time the dialog
                is initialized, FALSE if this InitProc has been called
                before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ParseISPCSV
(
    HWND hDlg, 
    TCHAR *pszCSVFileName,
    BOOL bCheckDupe
)
{
    // we will read the ISPINFO.CSV file, and populate the ISP LISTVIEW

    CCSVFile    far *pcCSVFile;
    CISPCSV     far *pcISPCSV;
    BOOL        bRet = TRUE;
    HICON       hISPLogo;
    int         iImage;
    HRESULT     hr;

    // Open and process the CSV file
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        // BUGBUG: Show Error Message
    
        goto ISPFileParseError;
    }            

    if (!pcCSVFile->Open(pszCSVFileName))
    {
        // BUGBUG: Show Error Message          
        AssertMsg(0,"Can not open ISPINFO.CSV file");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto ISPFileParseError; 
    }

    // Read the first line, since it contains field headers
    pcISPCSV = new CISPCSV;
    if (!pcISPCSV)
    {
        // BUGBUG Show error message
        delete pcCSVFile;
        goto ISPFileParseError;
    }

    if (ERROR_SUCCESS != (hr = pcISPCSV->ReadFirstLine(pcCSVFile)))
    {
        // Handle the error case
        delete pcCSVFile;
        pcCSVFile = NULL;
        gpWizardState->iNumOfValidOffers = 0;
        //*puNextPage = g_uExternUINext;
        bRet = TRUE;
        goto ISPFileParseError;
    }
    delete pcISPCSV;        // Don't need this one any more

    do 
    {
        // Allocate a new ISP record
        pcISPCSV = new CISPCSV;
        if (!pcISPCSV)
        {
            // BUGBUG Show error message
            bRet = FALSE;
            break;               
        }

        // Read a line from the ISPINFO file
        hr = pcISPCSV->ReadOneLine(pcCSVFile);

        if (hr == ERROR_SUCCESS)               
        { 
            // If this line contains a nooffer flag, then leave now
            if (!(pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OFFERS)) 
            {
                // Empty the list view, in case this is not the first line.
                // This should always be the first line
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

                // Add the entry to the list view
                AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                  0, 
                                  pcISPCSV->get_szISPName(), 
                                  -1,
                                  FALSE,
                                  (LPARAM)pcISPCSV,
                                  bCheckDupe);

                // Set the Current selected ISP to this one.  We need this because
                // this contains the path to no-offer htm
                gpWizardState->lpSelectedISPInfo = pcISPCSV;

                // Assigning ISP_INFO_NO_VALIDOFFER means the ispinfo.csv
                // contains a no-offer line pointing to the ISP no-offer htm
                gpWizardState->iNumOfValidOffers = ISP_INFO_NO_VALIDOFFER;
                break;
            }

            // Increments the number of offers htm
            gpWizardState->iNumOfValidOffers++;

            if (gpWizardState->bISDNMode ? (pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_ISDN_OFFER) : TRUE)
            {
        
                // See if this is an OEM tier 1 offer, and if we don't already have
                // an OEM tier 1 offer, then set it.
                if ((NULL == gpWizardState->lpOEMISPInfo[gpWizardState->uNumTierOffer]) && 
                    (gpWizardState->uNumTierOffer < MAX_OEM_MUTI_TIER) &&
                    pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OEM_SPECIAL )
                {
                    gpWizardState->lpOEMISPInfo[gpWizardState->uNumTierOffer] = pcISPCSV;
                    gpWizardState->uNumTierOffer++;

                    // Add the Tier logo to the image list
                    if (pcISPCSV->get_szISPTierLogoPath())
                    {
                        TCHAR   szURL[INTERNET_MAX_URL_LENGTH];

                        // Form the URL
                        pcISPCSV->MakeCompleteURL(szURL, pcISPCSV->get_szISPTierLogoPath());

                        // Convert GIF to ICON 
                        gpWizardState->pGifConvert->GifToIcon(szURL, 0, &hISPLogo);
                        pcISPCSV->set_ISPTierLogoIcon(hISPLogo);                   
                    }
                }
                else
                {
                    // Convert the ISP logo from a GIF to an ICON, and add it to the Image List
                    ConvertISPIcon(pcISPCSV->get_szISPLogoPath(), &hISPLogo);   
                    iImage =  ImageList_AddIcon(gpWizardState->himlIspSelect, hISPLogo);
        
                    DestroyIcon(hISPLogo);
                    pcISPCSV->set_ISPLogoImageIndex(iImage);
    
                    // Add the entry to the list view
                    if (AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                      g_nIndex, 
                                      pcISPCSV->get_szISPName(), 
                                      pcISPCSV->get_ISPLogoIndex(),
                                      pcISPCSV->get_bCNS(),
                                      (LPARAM)pcISPCSV,
                                      bCheckDupe))
                    {
                        g_nIndex++;
                        if (pcISPCSV->get_bCNS())
                            gbHaveCNSOffer = TRUE;
        
                        // Assign a default selection
                        if (NULL == gpWizardState->lpSelectedISPInfo)
                        {
                            gpWizardState->lpSelectedISPInfo = pcISPCSV;
                        }
                    }

                }       
            
                // if we are in ISDN mode, then increment the ISDN offer count
                if (gpWizardState->bISDNMode)
                    gpWizardState->iNumOfISDNOffers++;
                                 
            }
            else
            {
                // Since this obj is not added to the listview, we need to free
                // it here. Listview items are free when message LVN_DELETEITEM
                // is posted
                delete pcISPCSV;
            }

        }
        else if (hr == ERROR_FILE_NOT_FOUND) 
        {   
            // do not show this  ISP when its data is invalid
            // we don't want to halt everything. Just let it contine
            delete pcISPCSV;      
        }
        else if (hr == ERROR_NO_MORE_ITEMS)
        {   
            // There is no more to read.  No an error condition.
            delete pcISPCSV;        
            break;
        }
        else if (hr != ERROR_INVALID_DATA)
        {
            // Show error message later.
            // This should not happen unless we called ICW3's referral or
            // a corrupted copy of ispinfo.csv
            gpWizardState->iNumOfValidOffers = 0;
            delete pcISPCSV;
            bRet = FALSE;               
            break;  
        }

    } while (TRUE);

    pcCSVFile->Close();

    delete pcCSVFile;

    return bRet;

ISPFileParseError:

    // Set bParseIspinfo so next time, we'll reparse the CSV file
    gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    return bRet;
}
    
// Initialize the ISP select list view
BOOL InitListView(HWND  hListView)
{
    LV_COLUMN   col;
    
    // Set the necessary extended style bits
    ListView_SetExtendedListViewStyle(hListView, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);
    
    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    for(int i=0; i<3; i++)
    {
        if(ListView_InsertColumn(hListView, i, &col) == (-1))
            return(FALSE);
    }

    if (NULL == gpWizardState->himlIspSelect)
    {
        // Setup the image list
        if((gpWizardState->himlIspSelect = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                                            GetSystemMetrics(SM_CYSMICON), 
                                                            ILC_COLORDDB  , 0, 8)) == (HIMAGELIST)NULL)
            return(FALSE);
    }

    ListView_SetImageList(hListView, gpWizardState->himlIspSelect, LVSIL_SMALL);
    
    // Add the CNS graphic.  We add it first, so that it is always image index 0
    ImageList_AddIcon(gpWizardState->himlIspSelect, LoadIcon(ghInstanceResDll, MAKEINTRESOURCE(IDI_CNS)));
    
    return(TRUE);
}

    
// Reset the column size of the ISP select list view
BOOL ResetListView(HWND  hListView)
{
    LV_COLUMN   col;
    RECT        rc;
    
    // reset 3 columns. ISP LOGO, ISP Name, CNS
    GetClientRect(hListView, &rc);
    
    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = GetSystemMetrics(SM_CXSMICON) + 2;
    if(ListView_SetColumn(hListView, 0, &col) == (-1))
        return(FALSE);

    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = (rc.right - rc.left) - (2*GetSystemMetrics(SM_CXSMICON)) - 4;
    if(ListView_SetColumn(hListView, 1, &col) == (-1))
        return(FALSE);

    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = GetSystemMetrics(SM_CXSMICON) + 2;
    if(ListView_SetColumn(hListView, 2, &col) == (-1))
        return(FALSE);
    return TRUE;
}

/*******************************************************************

  NAME:    ISPSelectInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPSelectInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL bRet = TRUE;
    if (fFirstInit)
    {
        // If we are in modeless operation, then we want the app
        // to show the title, not the dialog
        SetWindowLongPtr(GetDlgItem(hDlg, IDC_ISPLIST_CNSICON), GWLP_USERDATA, 202);

        if(gpWizardState->cmnStateData.bOEMCustom)
        {
            TCHAR   szTitle[MAX_RES_LEN];
            RECT    rcCtl, rcDLU;
            HWND    hWndCtl = GetDlgItem(hDlg, IDC_ISP_SEL_TITLE);
            int     iCtlIds[7] = { IDC_ISPSELECT_INTRO,
                                   IDC_ISPLIST_CNSICON,
                                   IDC_ISPLIST_CNSINFO,
                                   IDC_ISPSELECT_LBLISPLIST,
                                   IDC_ISPLIST,
                                   IDC_ISPSELECT_LBLMARKET,
                                   IDC_ISPMARKETING };
            int     i, iOffset;            
            
            // Get the Title
            GetWindowText(hWndCtl, szTitle, sizeof(szTitle));
            
            // Hide the title
            ShowWindow(hWndCtl, SW_HIDE);
            
            // The offset to shift will be based on the number of DLU's from
            // top that the controls should be.  That amount is converted to 
            // pixels, and then the top of the first controls is used to compute
            // the final offset
            rcDLU.top = rcDLU.left = 0;
            rcDLU.bottom = rcDLU.right = FIRST_CTL_OFFSET;
            MapDialogRect(hDlg, &rcDLU);
            
            // Get the window of the 1st control
            hWndCtl = GetDlgItem(hDlg, iCtlIds[0]);
            // Get its screen position
            GetWindowRect(hWndCtl, &rcCtl);
            // Map to client coordinates for the parent
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCtl, 2);
            // compute the offset
            iOffset = rcCtl.top - rcDLU.bottom;
            
            // for each control, move the window up by iOffset           
            for (i = 0; i < ARRAYSIZE(iCtlIds); i++)            
            {
                // Get the window of the control to move
                hWndCtl = GetDlgItem(hDlg, iCtlIds[i]);
                
                // Get its screen position
                GetWindowRect(hWndCtl, &rcCtl);
                
                // Map to client coordinates for the parent
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCtl, 2);
                
                // Compute the new position
                rcCtl.top -= iOffset;
                rcCtl.bottom -= iOffset;
                
                // Move the control window
                MoveWindow(hWndCtl,
                           rcCtl.left,
                           rcCtl.top,
                           RECTWIDTH(rcCtl),
                           RECTHEIGHT(rcCtl),
                           FALSE);
            }
            
            // Set the title
            SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, 0, (LPARAM)szTitle);
        }
        else
        {
            WriteISPHeaderTitle(hDlg, IDC_ISP_SEL_TITLE);
        }
        
        // Initialize the List View
        InitListView(GetDlgItem(hDlg, IDC_ISPLIST));
        gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;

        gpWizardState->bISDNMode = gpWizardState->cmnStateData.bIsISDNDevice;
        

        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            TCHAR       szTemp[MAX_RES_LEN];

            // If there are items in the list view, clear them
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

            for (UINT i=0; i < gpWizardState->uNumTierOffer; i++)
            {
                if (gpWizardState->lpOEMISPInfo[i])
                {
                    delete gpWizardState->lpOEMISPInfo[i];
                    gpWizardState->lpOEMISPInfo[i] = NULL;
                }
            }
            gpWizardState->lpSelectedISPInfo = NULL;

            // Initialize the number of offers
            gpWizardState->iNumOfValidOffers = 0;
            gpWizardState->iNumOfISDNOffers = 0;
            gpWizardState->uNumTierOffer = 0;
            g_nIndex = 0;

            // Do not need to reparse next time
            gpWizardState->cmnStateData.bParseIspinfo = FALSE;

            // When we are in OEM mode, we need to read offline folder no matter where
            // we are launched from.
            if (gpWizardState->cmnStateData.bOEMOffline)
                ParseISPCSV(hDlg, ICW_OEMINFOPath, TRUE);

            // Not running from OEM Entry and not offline in oeminfo.ini means we didn't call 
            // Referral server.  We can skip parsing of CSV.
            if (!(gpWizardState->cmnStateData.bOEMOffline && gpWizardState->cmnStateData.bOEMEntryPt))
                ParseISPCSV(hDlg, ICW_ISPINFOPath, TRUE);
            
            if( gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS )
                LoadString(ghInstanceResDll, IDS_ISPSELECT_ONLISTSIGNUP, szTemp, MAX_RES_LEN);
            else
                LoadString(ghInstanceResDll, IDS_ISPSELECT_CNS, szTemp, MAX_RES_LEN);

            SetWindowText(GetDlgItem(hDlg, IDC_ISPLIST_CNSINFO), szTemp);
            // Hide the CNS legend if there are no CNSoffers
            if (!gbHaveCNSOffer)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_ISPLIST_CNSINFO), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPLIST_CNSICON), SW_HIDE);
            }

            ResetListView(GetDlgItem(hDlg, IDC_ISPLIST));
        }

        // The following 4 Cases can happen at this point:
        // 1) The ispinfo.csv contains a line says no offer, we go to nooffer page
        // 2) The ispinfo.csv contains no line of valid offer and no no-offer entry
        //    This may happen in calling the old referral.dll that ICW 3 client calls
        // 3) There are many offers but no ISDN offers, and we are in ISDN mode
        //    we go to ISDN offer pages
        // 4) Normal situation, some valid offers where we're in ISDN or not
        
        if (ISP_INFO_NO_VALIDOFFER == gpWizardState->iNumOfValidOffers)
        {
            // ISPINFO CSV contains a line saying NOOFFER!
            // if there are no offers, then we can just go directly to the NoOffers page
            ASSERT(gpWizardState->lpSelectedISPInfo);
            *puNextPage = ORD_PAGE_NOOFFER;
            bRet = TRUE;
        }
        else if (0 == gpWizardState->iNumOfValidOffers)
        {
            // Error in ISPINFO.CSV if there is no valid offers and no no-offer entry
            // critical error
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));
            *puNextPage = g_uExternUINext;
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            bRet = TRUE;
        }
        else if ((0 == gpWizardState->iNumOfISDNOffers) && gpWizardState->bISDNMode)
        {
            // if we are in ISDN mode and there is no ISDN offers
            // go to the ISDN nooffer age
            *puNextPage = ORD_PAGE_ISDN_NOOFFER;
            bRet = TRUE;
        }
        else
        {
            // See if we have an OEM tier 1 offer, and if we should NOT be showing
            // the "more" list, then jump to the OEM offer page
            if ((gpWizardState->uNumTierOffer > 0) && !gpWizardState->bShowMoreOffers)
            {
                *puNextPage = ORD_PAGE_OEMOFFER;
            }
            else
            {
                gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_ISPMARKETING), PAGETYPE_MARKETING);
                
                // If there are no selected items, select the first one, otherwise just navigate
                // the marketing window to the selected one
                if (0 == ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_ISPLIST)))
                {
                    ASSERT(gpWizardState->lpSelectedISPInfo);
                    // Select the First Item in the Listview
                    ListView_SetItemState(GetDlgItem(hDlg, IDC_ISPLIST), 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                {
                    CISPCSV     *pcISPCSV = NULL;
                    int         nCurrSel = ListView_GetSelectionMark(GetDlgItem(hDlg, IDC_ISPLIST));
                    if (-1 != nCurrSel)
                    {
                        LVITEM     CurLVItem;

                        memset(&CurLVItem, 0, sizeof(CurLVItem));
                        CurLVItem.mask         = LVIF_TEXT | LVIF_PARAM;
                        CurLVItem.iItem        = nCurrSel;
                        if (ListView_GetItem(GetDlgItem(hDlg, IDC_ISPLIST), &CurLVItem))
                        {
                            if (NULL != (pcISPCSV = (CISPCSV*) CurLVItem.lParam) )
                            {
                                gpWizardState->lpSelectedISPInfo = pcISPCSV;

                                // Navigate, since we are re-activating
                                pcISPCSV->DisplayHTML(pcISPCSV->get_szISPMarketingHTMPath());
                            }
                        }
                    }
        
                }                

                // Clear the dial Exact state var so that when we get to the dialing
                // page, we will regenerate the dial string
                gpWizardState->bDialExact = FALSE;
            }   
            
            // Set the return code
            bRet = TRUE;
        }
    }
    return bRet;
}

/*******************************************************************

  NAME:         ValidateISP

  SYNOPSIS:     checks if the ISP provides a valid offer by checking
                the existence of the CSV file
  ENTRY:        hDlg - Window handle

  EXIT:         returns TRUE if the ISP provides valid CSP, 
                FALSE otherwise
                
********************************************************************/
BOOL CALLBACK ValidateISP(HWND hDlg)
{
    CCSVFile    far *pcCSVFile;
    BOOL        bRet = TRUE;
        
    // Read the payment .CSV file.
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        return FALSE;
    }          

    if (!pcCSVFile->Open(gpWizardState->lpSelectedISPInfo->get_szPayCSVPath()))
    {
        TCHAR szErrMsg      [MAX_RES_LEN+1] = TEXT("\0");
        TCHAR szCaption     [MAX_RES_LEN+1] = TEXT("\0");
        LPVOID  pszErr;
        TCHAR   *args[1];
        args[0] = (LPTSTR) gpWizardState->lpSelectedISPInfo->get_szISPName();

        if (!LoadString(ghInstanceResDll, IDS_ISPSELECT_INVALID, szErrMsg,  sizeof(szErrMsg)  ))
            return FALSE;
        if (!LoadString(ghInstanceResDll, IDS_APPNAME,           szCaption,    sizeof(szCaption)     ))
            return FALSE;
        
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                      szErrMsg, 
                      0, 
                      0, 
                      (LPTSTR)&pszErr, 
                      0,
                      (va_list*)args);
        // Show Error Message
        MessageBox(hDlg, (LPTSTR)pszErr, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
        LocalFree(pszErr);
    
        delete pcCSVFile;
        pcCSVFile = NULL;
        bRet = FALSE;
    }

    if (pcCSVFile)
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    return bRet;
   
}


/*******************************************************************

  NAME:    ISPSelectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPSelectOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        DWORD dwFlag = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        if (ICW_CFGFLAG_SIGNUP_PATH & dwFlag)
        {           
            if (ICW_CFGFLAG_USERINFO & dwFlag)
            {
                *puNextPage = ORD_PAGE_USERINFO; 
                return TRUE;
            }
            if (ICW_CFGFLAG_BILL & dwFlag)
            {
                *puNextPage = ORD_PAGE_BILLINGOPT; 
                return TRUE;
            }
            if (ICW_CFGFLAG_PAYMENT & dwFlag)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                return TRUE;
            }
            *puNextPage = ORD_PAGE_ISPDIAL; 
            return TRUE;           
        }
        else
        {
            *puNextPage = ORD_PAGE_OLS; 
        }
       
    }
    return TRUE;
}

/*******************************************************************

  NAME:    ISPSElectNotifyProc

********************************************************************/
BOOL CALLBACK ISPSelectNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CISPCSV     *pcISPCSV;

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;

        case LVN_ITEMCHANGED:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - LVN_ITEMCHANGED");

            if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
                ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
            {
                // IF an Item just became selected, then render it's HTML content
                pcISPCSV = (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
                pcISPCSV->DisplayHTML(pcISPCSV->get_szISPMarketingHTMPath());

                // Remember the selected item for later use
                gpWizardState->lpSelectedISPInfo = pcISPCSV;
                
                //Set the intro text based on the number of isp'
                int iNum = ListView_GetItemCount(GetDlgItem(hDlg,IDC_ISPLIST));
                if (iNum > 1)
                   gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPSELECT_INTRO), IDS_ISPSELECT_INTROFMT_MULTIPLE, NULL);
                else if (iNum > 0)
                   gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPSELECT_INTRO), IDS_ISPSELECT_INTROFMT_SINGLE, NULL);
               
            }
            break;
            
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo 
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            gpWizardState->lpSelectedISPInfo = NULL;
            SetPropSheetResult(hDlg,TRUE);
            break;
        
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
                delete  (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
            break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ispcsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"
#include "perhist.h"
#include "shlobj.h"

const VARIANT c_vaEmpty = {0};
const LARGE_INTEGER c_li0 = { 0, 0 };


CHAR szTempBuffer[TEMP_BUFFER_LENGTH];

#define ReadVerifyDW(x)     if (!ReadDW(&(x),pcCSVFile))                        \
                            {                                                   \
                                AssertMsg(0,"Invalid DWORD in CSV file");       \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyW(x)      if (!ReadW(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
#define ReadVerifyWEx(x)    if (!ReadWEx(&(x),pcCSVFile))                       \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyB(x)      if (!ReadB(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid BYTE in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyBOOL(x)   if (!ReadBOOL(&(x),pcCSVFile))                      \
                            {                                                   \
                                AssertMsg(0,"Invalid BOOL in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySPECIAL(x, y, z) if (!ReadSPECIAL(&(x), &(y), &(z), pcCSVFile))   \
                            {                                                   \
                                AssertMsg(0,"Invalid SPECIAL in CSV file");     \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySZ(x,y)   if (!ReadSZ(&x[0],y+sizeof('\0'),pcCSVFile))        \
                            {                                                   \
                                AssertMsg(0,"Invalid STRING in CSV file");      \
                                goto ReadOneLineError;                          \
                            }

CISPCSV::~CISPCSV(void)
{
    if(m_lpStgHistory)
    {
        // Release the storage
        m_lpStgHistory->Release();
        m_lpStgHistory = NULL;
    }
    
    if (hbmTierIcon)
        DeleteObject(hbmTierIcon);
    
    CleanupISPPageCache(TRUE);
}

// Do an strip of Single Quotes from a source string.  The source is formatted as:
// 'some text', and the dest string ends up being
// some text
void CISPCSV::StripQuotes
(
    LPSTR   lpszDst,
    LPSTR   lpszSrc
)
{
    //strcpy(lpszDst, lpszSrc + 1, strlen(lpszSrc) - 1);
    strcpy(lpszDst, lpszSrc + 1);
    lpszDst[strlen(lpszDst) - 1] = '\0';
}


BOOL CISPCSV::ValidateFile(TCHAR* pszFile)
{
    ASSERT(pszFile);
  
    if (!lstrlen(pszFile))
        return FALSE;

    if (GetFileAttributes(pszFile) == 0xFFFFFFFF)
        return FALSE;

    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CISPCSV::ReadW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL CISPCSV::ReadWEx(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2WEx(szTempBuffer,pw));
}

// ############################################################################
BOOL CISPCSV::ReadB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CISPCSV::ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2BOOL(szTempBuffer,pbool));
}

// ############################################################################
// A special int can be either a BOOL (TRUE,FALSE) or a int, 0 or -1
// if the value is 0 or -1, then the pbIsSpecial bool is set to TRUE
BOOL CISPCSV::ReadSPECIAL(BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2SPECIAL(szTempBuffer,pbool, pbIsSpecial, pInt));
}

// ############################################################################
BOOL CISPCSV::ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadToEOL(CCSVFile far *pcCSVFile)
{
    return pcCSVFile->SkipTillEOL();
}

HRESULT CISPCSV::ReadOneLine
(
    CCSVFile    far *pcCSVFile
)
{
    HRESULT     hr = ERROR_SUCCESS;
    CHAR    szTemp                [MAX_ISP_NAME];
    CHAR    szISPLogoPath         [MAX_PATH] = "\0";
    CHAR    szISPTierLogoPath     [MAX_PATH];
    CHAR    szISPTeaserPath       [MAX_PATH];
    CHAR    szISPMarketingHTMPath [MAX_PATH];
    CHAR    szISPFilePath         [MAX_PATH];
    CHAR    szISPName             [MAX_ISP_NAME];
    //CHAR    szCNSIconPath         [MAX_PATH];
    CHAR    szBillingFormPath     [MAX_PATH];
    CHAR    szPayCSVPath          [MAX_PATH];
    CHAR    szOfferGUID           [MAX_GUID];
    CHAR    szMir                 [MAX_ISP_NAME];

    if (!ReadSZ(szTemp, sizeof(szTemp), pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto ReadOneLineExit;
    }
    // Strip the single quotes from the isp Name
    StripQuotes(szISPName, szTemp);
    
    ReadVerifyW(wOfferID);   
    ReadVerifySZ(szISPLogoPath, sizeof(szISPLogoPath));
    ReadVerifySZ(szISPMarketingHTMPath, sizeof(szISPMarketingHTMPath));
    ReadVerifySZ(szISPTierLogoPath, sizeof(szISPTierLogoPath));
    ReadVerifySZ(szISPTeaserPath, sizeof(szISPTeaserPath));
    ReadVerifySZ(szISPFilePath, sizeof(szISPFilePath)); 
    ReadVerifyDW(dwCfgFlag);
    ReadVerifyDW(dwRequiredUserInputFlags);
    ReadVerifySZ(szBillingFormPath, sizeof(szBillingFormPath));
    ReadVerifySZ(szPayCSVPath, sizeof(szPayCSVPath));
    ReadVerifySZ(szOfferGUID, sizeof(szOfferGUID));
    ReadVerifySZ(szMir, sizeof(szMir));   
    ReadVerifyWEx(wLCID);   //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
    ReadToEOL(pcCSVFile);

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPName,              MAX_ISP_NAME,   m_szISPName,            MAX_ISP_NAME);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPLogoPath,          MAX_PATH,       m_szISPLogoPath,        MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPMarketingHTMPath,  MAX_PATH,       m_szISPMarketingHTMPath,MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPTierLogoPath,      MAX_PATH,       m_szISPTierLogoPath,    MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPTeaserPath,        MAX_PATH,       m_szISPTeaserPath,      MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPFilePath,          MAX_PATH,       m_szISPFilePath,        MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBillingFormPath,      MAX_PATH,       m_szBillingFormPath,    MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPayCSVPath,           MAX_PATH,       m_szPayCSVPath,         MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szOfferGUID,            MAX_GUID,       m_szOfferGUID,          MAX_GUID);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szMir,                  MAX_ISP_NAME,   m_szMir,                MAX_ISP_NAME);
#else

    lstrcpy(m_szISPName, szISPName);
    lstrcpy(m_szISPLogoPath, szISPLogoPath);
    lstrcpy(m_szISPMarketingHTMPath, szISPMarketingHTMPath);
    lstrcpy(m_szISPTierLogoPath, szISPTierLogoPath);
    lstrcpy(m_szISPTeaserPath, szISPTeaserPath);
    lstrcpy(m_szISPFilePath, szISPFilePath);
    lstrcpy(m_szBillingFormPath, szBillingFormPath);
    lstrcpy(m_szPayCSVPath, szPayCSVPath);
    lstrcpy(m_szOfferGUID, szOfferGUID);
    lstrcpy(m_szMir, szMir);
#endif


    bCNS = (ICW_CFGFLAG_CNS & dwCfgFlag) ? TRUE : FALSE;
    bSecureConnection = (ICW_CFGFLAG_SECURE & dwCfgFlag) ? TRUE : FALSE;

    //If this is nooffer we won't try to validate
    if (!(dwCfgFlag & ICW_CFGFLAG_OFFERS))
    {
        if (!ValidateFile(m_szISPMarketingHTMPath))
            hr = ERROR_FILE_NOT_FOUND;
        return hr;
    }

    if (!(dwCfgFlag & ICW_CFGFLAG_AUTOCONFIG))
    {
        if (!ValidateFile(m_szISPMarketingHTMPath))
            return ERROR_FILE_NOT_FOUND;
    }

    if (dwCfgFlag & ICW_CFGFLAG_OEM_SPECIAL)
    {
        if (!ValidateFile(m_szISPTierLogoPath) || !ValidateFile(m_szISPTeaserPath))
            dwCfgFlag &= ~ICW_CFGFLAG_OEM_SPECIAL ;
    }

    //Try and validate the integrity of various offers
    //based on type.

    //OLS, CNS, NO-CNS   
    if (!ValidateFile(m_szISPLogoPath))
        return ERROR_FILE_NOT_FOUND;
    if (!ValidateFile(m_szISPFilePath))
        return ERROR_FILE_NOT_FOUND;

    // Validate the billing path only when billing option is set
    if (dwCfgFlag & ICW_CFGFLAG_BILL)
    {
        if(!ValidateFile(m_szBillingFormPath))
            return ERROR_FILE_NOT_FOUND;
    }

    // Validate the payment path only when payment option is set
    if (dwCfgFlag & ICW_CFGFLAG_PAYMENT)
    {
        if(!ValidateFile(m_szPayCSVPath))
            return ERROR_FILE_NOT_FOUND;
    }        
ReadOneLineExit:
    return hr;
    
ReadOneLineError:
    hr = ERROR_INVALID_DATA;
    goto ReadOneLineExit;
}

HRESULT CISPCSV::ReadFirstLine
(
    CCSVFile    far *pcCSVFile
)
{
    CHAR   szTemp[TEMP_BUFFER_LENGTH];

    for (int i = 0; i < NUM_ISPCSV_FIELDS; i++)
    {
        if (!ReadSZ(szTemp, sizeof(szTemp), pcCSVFile))
        {
            return(ERROR_INVALID_DATA);
        }            
    }          
    ReadToEOL(pcCSVFile);
    return (ERROR_SUCCESS);
}

void CISPCSV::MakeCompleteURL(LPTSTR   lpszURL, LPTSTR  lpszSRC)    
{
    TCHAR   szCurrentDir[MAX_PATH];

    // Form the URL
    GetCurrentDirectory(sizeof(szCurrentDir), szCurrentDir);
    wsprintf (lpszURL, TEXT("FILE://%s\\%s"), szCurrentDir, lpszSRC);        

}

// Display this object's HTML page
HRESULT CISPCSV::DisplayHTML(LPTSTR szFile)
{    
    TCHAR           szURL[INTERNET_MAX_URL_LENGTH];
    HRESULT         hr;
            
    // Make the URL
    MakeCompleteURL(szURL, szFile);
    hr = gpWizardState->pICWWebView->DisplayHTML(szURL);

    return (hr);
}

//Takes RES ID
HRESULT CISPCSV::DisplayTextWithISPName
(
    HWND    hDlgCtrl, 
    int     iMsgString,
    TCHAR*  pszExtra    //sticks something on the very end of the string if needed.
)
{
    TCHAR   szFinal [MAX_MESSAGE_LEN*3] = TEXT("\0");
    TCHAR   szFmt   [MAX_MESSAGE_LEN];
    TCHAR   *args   [1];
    LPVOID  pszIntro;

    args[0] = (LPTSTR) m_szISPName;
    
    // BUGBUG should probably check for error return from LoadString
    LoadString(ghInstanceResDll, iMsgString, szFmt, ARRAYSIZE(szFmt));
                
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                  szFmt, 
                  0, 
                  0, 
                  (LPTSTR)&pszIntro, 
                  0,
                  (va_list*)args);
                  
    lstrcpy(szFinal, (LPTSTR)pszIntro);
    if (pszExtra)
        lstrcat(szFinal, pszExtra);
    
    SetWindowText(hDlgCtrl, szFinal);
    LocalFree(pszIntro);
    
    return(S_OK);
}

#if 0
// Delete a Persisted History stream
HRESULT CISPCSV::DeleteHistory
(
    BSTR    bstrStreamName
)
{
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;

    // Delete the stream
    return (m_lpStgHistory->DestroyElement(bstrStreamName));
}
#endif

// Save the history of current lpBrowser using the provided name
HRESULT CISPCSV::SaveHistory
(
    BSTR bstrStreamName
)
{
    IStream         *lpStream;
    IPersistHistory *pHist;
    IWebBrowser2    *lpWebBrowser;
    HRESULT         hr = S_OK;
    
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;
            
    // Create a new Stream
    if (SUCCEEDED(hr = m_lpStgHistory->CreateStream(bstrStreamName, 
                                                    STGM_DIRECT | 
                                                    STGM_READWRITE | 
                                                    STGM_SHARE_EXCLUSIVE | 
                                                    STGM_CREATE,
                                                    0, 
                                                    0, 
                                                    &lpStream)))
    {
        // Get an IPersistHistory interface pointer on the current WebBrowser object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        if ( SUCCEEDED(lpWebBrowser->QueryInterface(IID_IPersistHistory, (LPVOID*) &pHist)))
        {
            // Save the history
            pHist->SaveHistory(lpStream);
            pHist->Release();
            
            // Reset the stream pointer to the beginning
            lpStream->Seek(c_li0, STREAM_SEEK_SET, NULL);
        }
        lpStream->Release();
    }
    
    return (hr);
}

HRESULT CISPCSV::LoadHistory
(
    BSTR   bstrStreamName
)
{
    IStream         *lpStream;
    IPersistHistory *pHist;
    IWebBrowser2    *lpWebBrowser;
    HRESULT         hr = S_OK;
    
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;
        
    // Open the Stream
    if (SUCCEEDED(hr = m_lpStgHistory->OpenStream(bstrStreamName, 
                                                  NULL, 
                                                  STGM_DIRECT | 
                                                  STGM_READWRITE | 
                                                  STGM_SHARE_EXCLUSIVE,
                                                  0, 
                                                  &lpStream)))
    {
        // Get an IPersistHistory interface pointer on the current WebBrowser object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        if ( SUCCEEDED(lpWebBrowser->QueryInterface(IID_IPersistHistory, (LPVOID*) &pHist)))
        {
            // Save the history
            pHist->LoadHistory(lpStream, NULL);
            pHist->Release();
            
            // Reset the stream pointer to the beginning
            lpStream->Seek(c_li0, STREAM_SEEK_SET, NULL);
        }
        lpStream->Release();
    }
    return (hr);
}


// This funtion will get the name of a ISP page cache filen from the page's ID
HRESULT CISPCSV::GetCacheFileNameFromPageID
(
    BSTR    bstrPageID,
    LPTSTR  lpszCacheFile,
    ULONG   cbszCacheFile
)
{
    HRESULT     hr = S_OK;
    IStream     *lpStream;
    ULONG       cbRead;
    
    if (!m_lpStgIspPages)
        return E_FAIL;
        
    // Open the stream
    if (SUCCEEDED(hr = m_lpStgIspPages->OpenStream(bstrPageID, 
                                                   NULL, 
                                                   STGM_DIRECT | 
                                                   STGM_READWRITE | 
                                                   STGM_SHARE_EXCLUSIVE,
                                                   0, 
                                                   &lpStream)))
    {
        // Read the file name
        lpStream->Read(lpszCacheFile, cbszCacheFile, &cbRead);
        
        // release the stream
        lpStream->Release();
    }   
    
    return hr;
}

// This function will cleanup the ISP Page cache.  This means deleting all temp files created
// and cleaning up the structured storage object used to store the file names
void CISPCSV::CleanupISPPageCache(BOOL bReleaseStorage)
{
    IEnumSTATSTG    *pEnum;
    STATSTG         StreamInfo;
    IMalloc         *pMalloc = NULL;
    
    // If we have a storage object already created, then enumerate the streams
    // in it, and free the underlying cache files.
    if (m_lpStgIspPages)
    {
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            if (SUCCEEDED(m_lpStgIspPages->EnumElements(0, NULL, 0, &pEnum)))
            {
                while(S_OK == pEnum->Next(1, &StreamInfo, NULL))
                {
                    if (StreamInfo.pwcsName)
                    {
                        TCHAR       szPath[MAX_PATH];
                        
                        if (SUCCEEDED(GetCacheFileNameFromPageID(StreamInfo.pwcsName,
                                                                 szPath,
                                                                 sizeof(szPath))))
                        {    
                            // delete the file
                            DeleteFile(szPath);

                            m_lpStgIspPages->DestroyElement(StreamInfo.pwcsName);
                            if(m_lpStgHistory)
                                m_lpStgHistory->DestroyElement(StreamInfo.pwcsName);
                            
                            // Free the memory allocated by the enumerator
                            pMalloc->Free (StreamInfo.pwcsName);
                        }   
                    }                        
                }
                // Release the enumerator
                pEnum->Release();
            }   
            // release the Shell Memory allocator
            pMalloc->Release ();
        }            
        
        if (bReleaseStorage)
        {
            // Release the storage
            m_lpStgIspPages->Release();
            m_lpStgIspPages= NULL;
        }            
    }
}

// This function will create a new page cache entry if necessary using the PageID as an
// index.  If an entry does not exists, and temp file will be create, then name stored,
// and the data in lpszTempFile will be copied into the new file.
// If the page already exists, this function will just return.
HRESULT CISPCSV::CopyFiletoISPPageCache
(
    BSTR    bstrPageID,
    LPTSTR  lpszTempFile
)
{
    HRESULT hr = S_OK;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szISPCacheFile[MAX_PATH];
    IStream *lpStream;
    ULONG   cbWritten;
        
    if (!m_lpStgIspPages)
        return E_FAIL;
    
    if (SUCCEEDED(GetCacheFileNameFromPageID(bstrPageID,
                                             szISPCacheFile,
                                             sizeof(szISPCacheFile))))
    {
        // The pageID already has a file in the cache, so we can just return success
        return S_OK;
    }      

    if (!GetTempPath(sizeof(szTempPath), szTempPath))
        return E_FAIL;
    
    // No file yet, so we have to create one
    if (!GetTempFileName(szTempPath, TEXT("ICW"), 0, szISPCacheFile))
        return E_FAIL;
        
    // Create a stream using the passed in page ID
    if (SUCCEEDED(hr = m_lpStgIspPages->CreateStream(bstrPageID, 
                                                     STGM_DIRECT | 
                                                     STGM_READWRITE | 
                                                     STGM_SHARE_EXCLUSIVE | 
                                                     STGM_CREATE,
                                                     0, 
                                                     0, 
                                                     &lpStream)))
    {
        // Write the file name to the stream, including the NULL terminator
#ifdef UNICODE
        DWORD dwSize = (lstrlen(szISPCacheFile)+1) * sizeof(TCHAR);
        if (SUCCEEDED(hr = lpStream->Write(szISPCacheFile, dwSize, &cbWritten)))
#else

        if (SUCCEEDED(hr = lpStream->Write(szISPCacheFile, lstrlen(szISPCacheFile)+1, &cbWritten)))
#endif
        {
            // Copy the passed in temp file
            if (!CopyFile(lpszTempFile, szISPCacheFile, FALSE))
                hr = E_FAIL;
        }
        // Release the stream
        lpStream->Release();
    }            
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\nooffer.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  NOOFFER.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"

/*******************************************************************

  NAME:    NoOfferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK NoOfferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_NOOFFER;

    TCHAR    szTemp[MAX_MESSAGE_LEN * 2];
    LoadString(ghInstanceResDll, IDS_NOOFFER, szTemp, MAX_MESSAGE_LEN * 2);
    SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER), szTemp);

    //Twiddle the buttons to do a finish page
    HWND hwndSheet = GetParent(hDlg);
    PropSheet_SetWizButtons(hwndSheet, PSWIZB_FINISH | PSWIZB_BACK);
    PropSheet_Changed(hDlg, hwndSheet);    

    return TRUE;
}

BOOL CALLBACK NoOfferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    if (!fForward)
    {
        //If were going backward we want to trick the
        //wizard into thinking we were the isp select page
        gpWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\oemoffer.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  OEMOFFER.CPP - Functions for 
//

//  HISTORY:
//  
//  09/03/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "webvwids.h"

#define  NO_TIER_SELECT -1
UINT IDC_OEM_TIER[] =
{
    IDC_OEM_TIER1,
    IDC_OEM_TIER2,
    IDC_OEM_TIER3
};
UINT IDC_OEM_TEASER_HTML[] =
{
    IDC_OEM_TEASER_HTML1,
    IDC_OEM_TEASER_HTML2,
    IDC_OEM_TEASER_HTML3
};

int g_nCurrOEMTier = NO_TIER_SELECT;
extern IICWWebView         *gpICWWebView[2];


/*******************************************************************

  NAME:         DoCreateTooltip

  SYNOPSIS:     creates a tooltip control

  ENTRY:        hDlg - dialog window

********************************************************************/
void DoCreateTooltip(HWND hWnd) 
{ 
    HWND hwndToolTip;       // handle of tooltip 
    TOOLINFO ti;            // tool information 

    //  create a tooltip control. 
    hwndToolTip = CreateWindowEx(   0, 
                                    TOOLTIPS_CLASS, 
                                    NULL, 
                                    WS_POPUP | TTS_ALWAYSTIP, 
                                    CW_USEDEFAULT, 
                                    CW_USEDEFAULT, 
                                    10, 
                                    10, 
                                    hWnd, 
                                    NULL, 
                                    ghInstanceResDll, //g_hInst, 
                                    NULL);

    // add the OK button to the tooltip. TTF_SUBCLASS causes the 
    // tooltip to automatically subclass the window and look for the 
    // messages it is interested in. 
    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(ti);
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = hWnd;

    TCHAR    szTemp[MAX_MESSAGE_LEN];
    LoadString(ghInstanceResDll, IDS_OEM_TIER_TOOLTIP, szTemp, MAX_MESSAGE_LEN);
    ti.lpszText = szTemp;

    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER1);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER2);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER3);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

}

/*******************************************************************

  NAME:         DisplayTierOffer

  SYNOPSIS:     Display Current controls for the tier page

  ENTRY:        hDlg - dialog window

********************************************************************/
void DisplayTierOffer(HWND    hDlg)
{

    if (NO_TIER_SELECT == g_nCurrOEMTier)
    {
        // Hide the marketing page
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_HIDE);

        // Show Teaser htm
        for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML[i]), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TEASER_HTML[i]), SW_SHOW);
        }

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML1), PAGETYPE_ISP_NORMAL);
        gpWizardState->lpOEMISPInfo[0]->DisplayHTML(gpWizardState->lpOEMISPInfo[0]->get_szISPTeaserPath());

        TCHAR           szURL[INTERNET_MAX_URL_LENGTH];

        
        if (gpWizardState->uNumTierOffer > 1)
        {
            // Make the URL
            gpWizardState->lpOEMISPInfo[1]->MakeCompleteURL(szURL, gpWizardState->lpOEMISPInfo[1]->get_szISPTeaserPath());
            gpICWWebView[0]->DisplayHTML(szURL);
        }
    
        if (gpWizardState->uNumTierOffer > 2)
        {
            gpWizardState->lpOEMISPInfo[2]->MakeCompleteURL(szURL, gpWizardState->lpOEMISPInfo[2]->get_szISPTeaserPath());
            gpICWWebView[1]->DisplayHTML(szURL);
        }
    
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {
        // Hide all the teaser htmls
        for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML[i]), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TEASER_HTML[i]), SW_HIDE);
        }

        // Show the marketing page
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), TRUE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_SHOW);

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), PAGETYPE_MARKETING);

        CISPCSV *pISPInfo;
        pISPInfo = gpWizardState->lpOEMISPInfo[g_nCurrOEMTier];
        pISPInfo->DisplayHTML(pISPInfo->get_szISPMarketingHTMPath());
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
    }


}

/*******************************************************************

  NAME:    OEMOfferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK OEMOfferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_OEMOFFER;
    if (fFirstInit)
    {
        DoCreateTooltip(hDlg);
        if (gpWizardState->uNumTierOffer > 1)
        {
            HRESULT hr;
            for(UINT i = 0; i < MAX_OEM_MUTI_TIER - 1; i++)
            {
                hr = CoCreateInstance(CLSID_ICWWEBVIEW,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWebView,(LPVOID *)&gpICWWebView[i]);
                if (FAILED(hr))
                    return FALSE;
            }
        }
    }
    else
    {
        // initialize this state variable
        gpWizardState->bShowMoreOffers = FALSE;
        
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER1), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER1), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER2), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER2), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER3), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER3), SW_HIDE);

        // If more than one tier offer, show the multi tier page
        if (1 == gpWizardState->uNumTierOffer)
        {

            // Hide multi tier controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_INTRO), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_INTRO), SW_HIDE);

            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_HIDE);
            
            // Show Tier one controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEMOFFER_HTML), SW_SHOW);

            CISPCSV FAR *lpISP;
            g_nCurrOEMTier = 0;
      
            // Use a local reference for convienience
            lpISP = gpWizardState->lpOEMISPInfo[0];
            ASSERT(lpISP);
        
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), PAGETYPE_MARKETING);
        
            // Navigate to the OEM offer marketing HTML
            lpISP->DisplayHTML(lpISP->get_szISPMarketingHTMPath());

            // Set the text for the instructions
            if ((gpWizardState->bISDNMode && (1 == gpWizardState->iNumOfISDNOffers)) ||
                (1 == gpWizardState->iNumOfValidOffers) )
            {
                lpISP->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), IDS_OEMOFFER_INSTFMT_SINGLE, NULL);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_HIDE);
            }
            else
            {
                lpISP->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), IDS_OEMOFFER_INSTFMT_MULTIPLE, NULL);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_SHOW);
            }
        }
        else
        {

            // Hide Tier one controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEMOFFER_HTML), SW_HIDE);

            // Show common multi tier controls - intro text
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_INTRO), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_INTRO), SW_SHOW);
            for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER[i]), TRUE);
                ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER[i]), SW_SHOW);

                SendMessage(GetDlgItem(hDlg, IDC_OEM_TIER[i]), 
                            BM_SETIMAGE, 
                            IMAGE_ICON, 
                            (LPARAM)gpWizardState->lpOEMISPInfo[i]->get_ISPTierLogoIcon());

            }

            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML1), PAGETYPE_ISP_NORMAL);

            switch (gpWizardState->uNumTierOffer)
            {
                case 3:
                    gpICWWebView[1]->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML3), PAGETYPE_ISP_NORMAL);
                case 2:
                    gpICWWebView[0]->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML2), PAGETYPE_ISP_NORMAL);
                    break;
            }

            DisplayTierOffer(hDlg);

            if ((gpWizardState->bISDNMode && (gpWizardState->iNumOfISDNOffers <= (int)gpWizardState->uNumTierOffer)) ||
                (gpWizardState->iNumOfValidOffers <= (int)gpWizardState->uNumTierOffer) )
            {
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_INSTRUCTION), SW_HIDE);
                EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), FALSE);
            }
            else
            {
                TCHAR szTemp    [MAX_RES_LEN];
                LoadString(ghInstanceResDll, IDS_OEMOFFER_INSTR_MULTITIER, szTemp, ARRAYSIZE(szTemp));
                SetWindowText(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), szTemp);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_SHOW);
                EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), TRUE);
            }

        }

    }

    return TRUE;
}

BOOL CALLBACK OEMOfferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    if (fForward)
    {
        // We will keep this page in the history
        *pfKeepHistory = TRUE;
        
        // We either need to go to the true ISP select page because the more button was pressed
        // or we move on based on the selected ISP settings
        if (gpWizardState->bShowMoreOffers)
        {
            *puNextPage = ORD_PAGE_ISPSELECT;
        }
        else
        {
            // Get the config flags, and figure out where to go next
            gpWizardState->lpSelectedISPInfo = gpWizardState->lpOEMISPInfo[g_nCurrOEMTier];

            DWORD dwFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

            if (ICW_CFGFLAG_SIGNUP_PATH & dwFlags)
            {           
                if (ICW_CFGFLAG_USERINFO & dwFlags)
                {
                    *puNextPage = ORD_PAGE_USERINFO; 
                    return TRUE;
                }
                if (ICW_CFGFLAG_BILL & dwFlags)
                {
                    *puNextPage = ORD_PAGE_BILLINGOPT; 
                    return TRUE;
                }
                if (ICW_CFGFLAG_PAYMENT & dwFlags)
                {
                    *puNextPage = ORD_PAGE_PAYMENT; 
                    return TRUE;
                }
                *puNextPage = ORD_PAGE_ISPDIAL; 
                return TRUE;           
            }
            else
            {
                *puNextPage = ORD_PAGE_OLS; 
            }
        }
    }
    else
    {
        // Reset the current selection
        g_nCurrOEMTier = NO_TIER_SELECT;
    }
    return  TRUE;
}

/*******************************************************************

  NAME:    OEMOfferCmdProc

********************************************************************/
BOOL CALLBACK OEMOfferCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_OEMOFFER_MORE: 
                {
                    // Set the state variable so that we can shore more offers
                    gpWizardState->bShowMoreOffers = TRUE;
        
                    // Fake a press of the next button
                    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                    break;
                }
                case IDC_OEM_TIER1: 
                {
                    g_nCurrOEMTier = 0;
                    DisplayTierOffer(hDlg);
                    break;
                }
                case IDC_OEM_TIER2: 
                {
                    g_nCurrOEMTier = 1;
                    DisplayTierOffer(hDlg);
                    break;
                }
                case IDC_OEM_TIER3: 
                {
                    g_nCurrOEMTier = 2;
                    DisplayTierOffer(hDlg);
                    break;
                }
            }
		    break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ols.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  OLS.CPP - Functions for 
//

//  HISTORY:
//  
//  06/02/98  vyung  Created.
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:   OLSInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg        - dialog window
            fFirstInit  - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK OLSInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{

    // This is the very last page
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_FINISH);

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_OLS;
    if (!fFirstInit)
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OLS_HTML), PAGETYPE_OLS_FINISH);
        
        // Navigate to the Billing HTML
        gpWizardState->lpSelectedISPInfo->DisplayHTML(gpWizardState->lpSelectedISPInfo->get_szBillingFormPath());
           
    }    
    return TRUE;
}

BOOL CALLBACK OLSOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)   
{
    if (fForward)
    {
        IWebBrowser2 *lpWebBrowser;
        
        // Get the Browser Object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        
        // Process the OLS file items (like registry update, and short cut creation
        gpWizardState->pHTMLWalker->ProcessOLSFile(lpWebBrowser);

        // Set ICW completed bit and remove the getconn icon
        if (gpWizardState->cmnStateData.lpfnCompleteOLS)
            (*gpWizardState->cmnStateData.lpfnCompleteOLS)();
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\paycsv.h ===
//**********************************************************************
// File name: PAYCSV.H
//
//      Definition of CISPCSV
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _PAYCSV_H_ )
#define _PAYCSV_H_

#define MAX_DISPLAY_NAME    100

#define NUM_PAYCSV_FIELDS   4           // Might only be 3


#define PAYMENT_TYPE_INVALID        0
#define PAYMENT_TYPE_CREDITCARD     1
#define PAYMENT_TYPE_INVOICE        2
#define PAYMENT_TYPE_PHONEBILL      3
#define PAYMENT_TYPE_CUSTOM         4


class CPAYCSV
{
    private:
        // The following members represent the content of a single line from the CSV file.
        TCHAR   m_szDisplayName[MAX_DISPLAY_NAME];
        WORD    m_wPaymentType;
        TCHAR   m_szCustomPayURLPath[MAX_PATH];
        BOOL    m_bLUHNCheck;                      
                
    public:

         CPAYCSV(void) 
         {
            memset(this, 0, sizeof(CPAYCSV));            
         }
         ~CPAYCSV(void) {}
         
        HRESULT ReadOneLine(CCSVFile far *pcCSVFile,BOOL bLUHNFormat);      
        HRESULT ReadFirstLine(CCSVFile far *pcCSVFile, BOOL far *pbLUHNFormat);
       
        void StripQuotes(LPSTR   lpszDst, LPSTR   lpszSrc);
        BOOL    ReadW(WORD far *pw, CCSVFile far *pcCSVFile);
        BOOL    ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile);
        BOOL    ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
        BOOL    ReadToEOL(CCSVFile far *pcCSVFile);
   
        LPTSTR   get_szDisplayName(void)
        {
            return m_szDisplayName;
        }   

        LPTSTR   get_szCustomPayURLPath(void)
        {
            return m_szCustomPayURLPath;
        }  

        WORD   get_wPaymentType()
        {
            return m_wPaymentType;
        }
        BOOL   get_bLUHNCheck()
        {
            return m_bLUHNCheck;
        }
        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <exdisp.h>
#include <mshtmdid.h>

#include "icwunicd.h"
#include "webview.h"
#include "icwcmn.h"
#include "icwhelp.h"
#include "connect.h"
#include "ccsv.h"
#include "ispcsv.h"
#include "paycsv.h"
#include "resource.h"
#include "storage.h"
#include "wizdef.h"
#include "wizard.h"
#include "pagefcns.h"
#include "appdefs.h"
#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\payment.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAYMENT.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98    donaldm     Created.
//  08/19/98    donaldm     BUGBUG: The code to collect and save the user
//                          entered data is not optimal in terms of size
//                          and can/should be cleaned up at some future time
//
//*********************************************************************


#include "pre.h"

// Dialog handles for the different payment methods, which will be nested into our mail dialog
HWND hDlgCreditCard         = NULL;
HWND hDlgInvoice            = NULL;
HWND hDlgPhoneBill          = NULL;
HWND hDlgCustom             = NULL;
HWND hDlgCurrentPaymentType = NULL;
BOOL g_bCustomPaymentActive = FALSE;
WORD wCurrentPaymentType    = PAYMENT_TYPE_INVALID;  // NOTE: this must be initialize to a value 
       
HACCEL hAccelCreditCard         = NULL;
HACCEL hAccelInvoice            = NULL;
HACCEL hAccelPhoneBill          = NULL;

#define NUM_EXPIRE_YEARS  38
#define BASE_YEAR         1998
#define MAX_YEAR_LEN      5
#define NUM_EXPIRE_MONTHS 12

const TCHAR cszCustomPayment[] = TEXT("CUSTOMPAYMENT");

INT_PTR CALLBACK CreditCardPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
     // in order not to corrupt mem this guy must be big enough to hold 
    // fmax_firstname + "" + max last name
    TCHAR           szTemp[MAX_RES_LEN*2 + 4] = TEXT("\0");
    
    switch (uMsg) 
    {
        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
    
        case WM_INITDIALOG:
        {
            int i;
                            
            // Initialize the fields we know about
            SYSTEMTIME SystemTime;   // system time structure
            GetLocalTime(&SystemTime);

            // Populate the Expires year listbox
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR));
            TCHAR   szYear[MAX_YEAR_LEN];
            for (i = 0; i < NUM_EXPIRE_YEARS; i++)
            {
                wsprintf (szYear, TEXT("%4d"), i + BASE_YEAR);
                ComboBox_AddString(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR), szYear);
            }                
            // Select the first year in the list if unselected
            if (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR)) == -1)
            {
                ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR), 
                                    SystemTime.wYear - BASE_YEAR);
            }
            
            // Populate the Expires Month listbox
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH));
            for (i = 0; i < NUM_EXPIRE_MONTHS; i++)
            {
                LoadString(ghInstanceResDll, IDS_JANUARY + i, szTemp, ARRAYSIZE(szTemp));
                ComboBox_AddString(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH), szTemp);
            }    
            // Select the first Month in the list if unselected               
            if (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH)) == -1)
            {
                ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH), SystemTime.wMonth - 1);
            }
            
            if (pISPData->GetDataElement(ISPDATA_USER_FE_NAME))
            {
                lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FE_NAME));
                SetDlgItemText(hDlg, IDC_PAYMENT_CCNAME, szTemp);
            }
            else
            {
                lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FIRSTNAME));
                lstrcat(szTemp, TEXT(" "));
                lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_LASTNAME));
                SetDlgItemText(hDlg, IDC_PAYMENT_CCNAME, szTemp);
            }
            
            lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_ADDRESS));
            
            if (LCID_JPN != GetUserDefaultLCID())
            {
                lstrcat(szTemp, TEXT(" "));
                lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_MOREADDRESS));
            } 
            SetDlgItemText(hDlg, IDC_PAYMENT_CCADDRESS, szTemp);

            SetDlgItemText(hDlg, IDC_PAYMENT_CCZIP, pISPData->GetDataElement(ISPDATA_USER_ZIP));
            
            break;
        }
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {
            CPAYCSV far *pcPAYCSV = (CPAYCSV far *)lParam;
            UINT        uCtrlID;
    
            // If the ISP support LUHN, validate the content
            if (pcPAYCSV->get_bLUHNCheck())
            {
                uCtrlID = IDC_PAYMENT_CCNUMBER;
                GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
                if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDNUMBER, szTemp, ISPDATA_Validate_Content))
                    goto CreditCardPaymentOKError;
            }
            else
            {
                // no content validate, so just do data present validation
                uCtrlID = IDC_PAYMENT_CCNUMBER;
                GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
                if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDNUMBER, szTemp, ISPDATA_Validate_DataPresent))
                    goto CreditCardPaymentOKError;
            }
            
            uCtrlID = IDC_PAYMENT_CCNAME;                    
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDHOLDER, szTemp, ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;

            uCtrlID = IDC_PAYMENT_CCADDRESS;
            GetDlgItemText(hDlg, IDC_PAYMENT_CCADDRESS, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;
            
            uCtrlID = IDC_PAYMENT_CCZIP;
            GetDlgItemText(hDlg, IDC_PAYMENT_CCZIP, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLZIP, szTemp , ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;

            // Month must be converted into numeric equivalent
            _itot(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH)) + 1, szTemp, 10);
            pISPData->PutDataElement(ISPDATA_PAYMENT_EXMONTH, szTemp , ISPDATA_Validate_None);

            uCtrlID = IDC_PAYMENT_EXPIREYEAR;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_EXYEAR, szTemp , ISPDATA_Validate_Content))
                goto CreditCardPaymentOKError;

            // OK to move on
            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
CreditCardPaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK InvoicePaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
    TCHAR           szTemp[MAX_RES_LEN] = TEXT("\0");
    
    switch (uMsg) 
    {

        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
        case WM_INITDIALOG:
        {
            SetDlgItemText(hDlg, IDC_PAYMENT_IVADDRESS1, pISPData->GetDataElement(ISPDATA_USER_ADDRESS));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVADDRESS2, pISPData->GetDataElement(ISPDATA_USER_MOREADDRESS));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVCITY, pISPData->GetDataElement(ISPDATA_USER_CITY));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVSTATE, pISPData->GetDataElement(ISPDATA_USER_STATE));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVZIP, pISPData->GetDataElement(ISPDATA_USER_ZIP));
            
            break;
        }
        
        
        // User clicked next, so we need to collect entered data
        case WM_USER_NEXT:
        {   
            UINT    uCtrlID;
            
            uCtrlID = IDC_PAYMENT_IVADDRESS1;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVADDRESS2;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLEXADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVCITY;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLCITY, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;
          
            uCtrlID = IDC_PAYMENT_IVSTATE;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLSTATE, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVZIP;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLZIP, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
InvoicePaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
            
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK PhoneBillPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
    TCHAR           szTemp[MAX_RES_LEN] = TEXT("\0");
    
    switch (uMsg) 
    {

        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;

        case WM_INITDIALOG:
        {
            TCHAR    szTemp[MAX_RES_LEN];
               
            lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FIRSTNAME));
            lstrcat(szTemp, TEXT(" "));
            lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_LASTNAME));
            SetDlgItemText(hDlg, IDC_PAYMENT_PHONEIV_BILLNAME, szTemp);
                
            SetDlgItemText(hDlg, IDC_PAYMENT_PHONEIV_ACCNUM, pISPData->GetDataElement(ISPDATA_USER_PHONE));
            break;
        }
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {       
            UINT    uCtrlID;
            
            uCtrlID = IDC_PAYMENT_PHONEIV_BILLNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLNAME, szTemp, ISPDATA_Validate_DataPresent))
                goto PhoneBillPaymentOKError;

            uCtrlID = IDC_PAYMENT_PHONEIV_ACCNUM;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLPHONE, szTemp, ISPDATA_Validate_DataPresent))
                goto PhoneBillPaymentOKError;

            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
PhoneBillPaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
            
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK CustomPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg) 
    {     
        // This is custom, because for the custom page, we must connect to the window
        // and browse everytime the custom pay page is activated, since an intervening
        // step may have connected the browser to a different window
        case WM_USER_CUSTOMINIT:
        {
            CPAYCSV     far *pcPAYCSV = (CPAYCSV far *)lParam;
            
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_PAYMENT_CUSTOM_INV), PAGETYPE_CUSTOMPAY);

            // Navigate to the Custom Payment HTML
            gpWizardState->lpSelectedISPInfo->DisplayHTML(pcPAYCSV->get_szCustomPayURLPath());
            
            // Load any persisted data
            gpWizardState->lpSelectedISPInfo->LoadHistory((BSTR)A2W(cszCustomPayment));
            return TRUE;
        }            
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {
            TCHAR   szQuery[INTERNET_MAX_URL_LENGTH];

            memset(szQuery, 0, sizeof(szQuery));

            // Attach the walker to the curent page
            // Use the Walker to get the query string
            IWebBrowser2 *lpWebBrowser;
        
            gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
            gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
            
            gpWizardState->pHTMLWalker->get_FirstFormQueryString(szQuery);
            
            gpWizardState->pISPData->PutDataElement(ISPDATA_PAYMENT_CUSTOMDATA, szQuery, ISPDATA_Validate_None);    
            
            // detach the walker
            gpWizardState->pHTMLWalker->Detach();
                
            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            


/*******************************************************************

  NAME:    SwitchPaymentType

********************************************************************/

void SwitchPaymentType
(
    HWND    hDlg, 
    WORD    wPaymentType
)
{
    TCHAR       szTemp[MAX_RES_LEN];
    PAGEINFO    *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    

    // nothing to do if the payment type has not changed
    if (wPaymentType == wCurrentPaymentType)
        return;
    
    // set the current payment type    
    wCurrentPaymentType = wPaymentType;
            
    // If the custom payment DLG is currently active, then we
    // need to persist any data the user may have entered.
    if (g_bCustomPaymentActive && IsWindowVisible(hDlgCurrentPaymentType))
    {
        gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszCustomPayment));
    }

    // Hide the current payment type window if there is one
    if (hDlgCurrentPaymentType)
    {
        ShowWindow(hDlgCurrentPaymentType, SW_HIDE);
    }
    //assume false for the weboc event handling
    g_bCustomPaymentActive = FALSE;
    gpWizardState->pISPData->PutDataElement(ISPDATA_PAYMENT_CUSTOMDATA, NULL, ISPDATA_Validate_None);    

    // Create a new payment type DLG if necessary
    switch (wPaymentType)
    {
        case PAYMENT_TYPE_CREDITCARD:
        {
            if (NULL == hDlgCreditCard)
            {
                hDlgCreditCard = CreateDialog(ghInstanceResDll, 
                                              MAKEINTRESOURCE(IDD_PAYMENTTYPE_CREDITCARD), 
                                              hDlg, 
                                              CreditCardPaymentDlgProc);
                // Also load the accelerator
                hAccelCreditCard = LoadAccelerators(ghInstanceResDll, 
                                                    MAKEINTRESOURCE(IDA_PAYMENTTYPE_CREDITCARD));      
            }            
            hDlgCurrentPaymentType = hDlgCreditCard;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelCreditCard;
            LoadString(ghInstanceResDll, IDS_PAYMENT_CREDITCARD, szTemp, ARRAYSIZE(szTemp));
            break;
        }
        
        case PAYMENT_TYPE_INVOICE:
        {
            if (NULL == hDlgInvoice)
            {
                hDlgInvoice = CreateDialog(ghInstanceResDll, 
                                           MAKEINTRESOURCE(IDD_PAYMENTTYPE_INVOICE), 
                                           hDlg, 
                                           InvoicePaymentDlgProc);
                // Also load the accelerator
                hAccelInvoice = LoadAccelerators(ghInstanceResDll, 
                                                 MAKEINTRESOURCE(IDA_PAYMENTTYPE_INVOICE));      
                                           
            }
            hDlgCurrentPaymentType = hDlgInvoice;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelInvoice;
            LoadString(ghInstanceResDll, IDS_PAYMENT_INVOICE, szTemp, ARRAYSIZE(szTemp));
            break;
        }

        case PAYMENT_TYPE_PHONEBILL:
        {
            if (NULL == hDlgPhoneBill)
            {
                hDlgPhoneBill = CreateDialog(ghInstanceResDll, 
                                             MAKEINTRESOURCE(IDD_PAYMENTTYPE_PHONEBILL), 
                                             hDlg, 
                                             PhoneBillPaymentDlgProc);
                // Also load the accelerator
                hAccelPhoneBill = LoadAccelerators(ghInstanceResDll, 
                                                   MAKEINTRESOURCE(IDA_PAYMENTTYPE_PHONEBILL));      
            }                
            hDlgCurrentPaymentType = hDlgPhoneBill;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelPhoneBill;
            LoadString(ghInstanceResDll, IDS_PAYMENT_PHONE, szTemp, ARRAYSIZE(szTemp));
            break;
        }

        case PAYMENT_TYPE_CUSTOM:
        {
            g_bCustomPaymentActive = TRUE;

            if (NULL == hDlgCustom)
            {
                hDlgCustom = CreateDialog(ghInstanceResDll, 
                                          MAKEINTRESOURCE(IDD_PAYMENTTYPE_CUSTOM), 
                                          hDlg, 
                                          CustomPaymentDlgProc);
            }
            hDlgCurrentPaymentType = hDlgCustom;
            // Set the acclerator table to the nested dialog. There is not one
            // in this case
            pPageInfo->hAccelNested = NULL;
            
            // We must force the custom payment type dialog to connect and browse
            CPAYCSV     far *pcPAYCSV;
            HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
                
            // Get the currently selected item's PAYCSV obhect
            pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, ComboBox_GetCurSel( hWndPayment ));
            ASSERT(pcPAYCSV);
            
            SendMessage(hDlgCustom, WM_USER_CUSTOMINIT, 0, (LPARAM)pcPAYCSV);            
            LoadString(ghInstanceResDll, IDS_PAYMENT_CUSTOM, szTemp, ARRAYSIZE(szTemp));
            break;
        }
    }
    
    // Set the combo box string
    SetDlgItemText(hDlg, IDC_PAYMENT_GROUP, szTemp);
    
    // Show the new payment type window
    ShowWindowWithParentControl(hDlgCurrentPaymentType);
}

/*******************************************************************

  NAME:   PaymentInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK PaymentInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL        bRet = TRUE;
    BOOL        bLUHN = FALSE;
    HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
    CPAYCSV     far *pcPAYCSV;
    
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_PAYMENT;
    ASSERT(gpWizardState->lpSelectedISPInfo);
    
    // invalidate the current payment type, so that we refresh everthing
    // in the event that we are reloading this page
    wCurrentPaymentType    = PAYMENT_TYPE_INVALID;
    
    if (fFirstInit || !(gpWizardState->pStorage->Compare(ICW_PAYMENT, 
                                                         gpWizardState->lpSelectedISPInfo->get_szPayCSVPath(), 
                                                         MAX_PATH)))
    {
        CCSVFile    far *pcCSVFile;
        HRESULT     hr;
        int         iIndex;

        // Read the payment .CSV file.
        pcCSVFile = new CCSVFile;
        if (!pcCSVFile) 
        {
            MsgBox(hDlg, IDS_ERR_OUTOFMEMORY, MB_ICONEXCLAMATION,MB_OK);
            return (FALSE);
        }          
        
        gpWizardState->pStorage->Set(ICW_PAYMENT, gpWizardState->lpSelectedISPInfo->get_szPayCSVPath(), MAX_PATH);

        if (!pcCSVFile->Open(gpWizardState->lpSelectedISPInfo->get_szPayCSVPath()))
        {          
            AssertMsg(0, "Cannot open payment .CSV file");
            delete pcCSVFile;
            pcCSVFile = NULL;
            
            return (FALSE);
        }

        // Read the first line, since it contains field headers
        pcPAYCSV = new CPAYCSV;
        if (!pcPAYCSV)
        {
            // BUGBUG Show error message
            return (FALSE);
        }
        
        // Reading the first line also determines whether the csv file is contains
        // the LUHN format.  If it does, we need to keep a record of bLUHN so that the
        // subsequent line can be read correctly.
        if (ERROR_SUCCESS != (hr = pcPAYCSV->ReadFirstLine(pcCSVFile, &bLUHN)))
        {
            // Handle the error case
            delete pcCSVFile;
            pcCSVFile = NULL;
            
            return (FALSE);
        }
        
        delete pcPAYCSV;        // Don't need this one any more
        
        ComboBox_ResetContent(hWndPayment);

        // Read the Payment CSV file
        do {
            // Allocate a new Payment record
            pcPAYCSV = new CPAYCSV;
            if (!pcPAYCSV)
            {
                // BUGBUG Show error message
                bRet = FALSE;
                break;
                
            }
            
            // Read a line from the ISPINFO file
            hr = pcPAYCSV->ReadOneLine(pcCSVFile, bLUHN);
            if (hr == ERROR_NO_MORE_ITEMS)
            {   
                delete pcPAYCSV;        // We don't need this one
                break;
            }
            else if (hr == ERROR_FILE_NOT_FOUND)
            {
                // BUGBUG Show error message
                delete pcPAYCSV;
                pcPAYCSV = NULL;
            }
            else if (hr != ERROR_SUCCESS)
            {
                // BUGBUG Show error message
                delete pcPAYCSV;
                bRet = FALSE;
                break;
            }
            
            // Add the entry to the comboBox
            if (pcPAYCSV)
            {
                iIndex = ComboBox_AddString(hWndPayment, pcPAYCSV->get_szDisplayName());
                ComboBox_SetItemData(hWndPayment, iIndex, pcPAYCSV);
            }
        } while (TRUE);

        // Select the first payment type in the list
        ComboBox_SetCurSel(hWndPayment, 0);

        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, 0);
        ASSERT(pcPAYCSV);
        SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());

        pcCSVFile->Close();
        delete pcCSVFile;
        pcCSVFile = NULL;
    }
    else
    {
        // Get the currently selected item
        int         iIndex = ComboBox_GetCurSel( hWndPayment );
     
        // Get the payment type, and update the payment area
        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
        
        ASSERT(pcPAYCSV);

        SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());
     
        // Setup the ISPData object so that is can apply proper validation based on the selected ISP
        // this is necessary here, because the user info page might have been skiped
        gpWizardState->pISPData->PutValidationFlags(gpWizardState->lpSelectedISPInfo->get_dwRequiredUserInputFlags());
        
    } 

    if (!fFirstInit)
    {
        TCHAR       szTemp[MAX_RES_LEN];
        if (LoadString(ghInstanceResDll,
                       ((gpWizardState->lpSelectedISPInfo->get_dwCFGFlag() & ICW_CFGFLAG_SECURE) ? IDS_PAYMENT_SECURE : IDS_PAYMENT_UNSECURE),
                       szTemp,
                       MAX_RES_LEN))
        {
            SetWindowText (GetDlgItem(hDlg,IDC_PAYMENT_SECURE), szTemp);
        }
    }   
    
    return bRet;
}


/*******************************************************************

  NAME:    PaymentOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK PaymentOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)   
{
    // If the custom payment DLG has been shown, then we
    // need to persist any data the user may have entered.
    // We have shown the custom payment DLG, it hDlgCustom is not NULL
    if (NULL != hDlgCustom && IsWindowVisible(hDlgCustom))
    {
        gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszCustomPayment));
    }
    
    // NOTE that we are leaving the payment page, so the custom payment
    // WEBOC is no longer active
    g_bCustomPaymentActive = FALSE;
    
    if (fForward)
    {
        TCHAR       szTemp[MAX_RES_LEN];
        HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
        CPAYCSV     far *pcPAYCSV;
        int         iIndex;
        
        // Create a local reference for the ISPData object
        IICWISPData *pISPData = gpWizardState->pISPData;    
        
        // Get the payment type
        iIndex = ComboBox_GetCurSel(hWndPayment);
        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
        wsprintf (szTemp, TEXT("%d"), pcPAYCSV->get_wPaymentType());
        pISPData->PutDataElement(ISPDATA_PAYMENT_TYPE, szTemp, ISPDATA_Validate_None);
        
        // Set the display name
        pISPData->PutDataElement(ISPDATA_PAYMENT_DISPLAYNAME, pcPAYCSV->get_szDisplayName(), ISPDATA_Validate_None);
   
        switch(pcPAYCSV->get_wPaymentType())
        {
            case PAYMENT_TYPE_CREDITCARD:
                if (!SendMessage(hDlgCreditCard, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;
                
            case PAYMENT_TYPE_INVOICE:
                if (!SendMessage(hDlgInvoice, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;

            case PAYMENT_TYPE_PHONEBILL:
                if (!SendMessage(hDlgPhoneBill, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;

            case PAYMENT_TYPE_CUSTOM:
                if (!SendMessage(hDlgCustom, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;
        }     
    }
    return TRUE;
}

/*******************************************************************

  NAME:    PaymentCmdProc

********************************************************************/
BOOL CALLBACK PaymentCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    WORD wNotifyCode = HIWORD (wParam);
            
    switch(LOWORD(wParam))
    {
        case IDC_PAYMENTTYPE:
        {
            if (wNotifyCode == CBN_SELENDOK || wNotifyCode == CBN_CLOSEUP)
            {
                // Get the currently selected item
                CPAYCSV     far *pcPAYCSV;
                HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
                int         iIndex = ComboBox_GetCurSel( hWndPayment );

                // Get the payment type, and update the payment are
                pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
                ASSERT(pcPAYCSV);
                SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());
            }
            break;
        }
        default:
            break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  05/18/98  donaldm  Created.
//
 
#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in ISPSEL.CPP
BOOL CALLBACK ISPSelectInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPSelectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPSelectNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in ISPASEL.CPP
BOOL CALLBACK ISPAutoSelectInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPAutoSelectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPAutoSelectNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in NOOFFER.CPP
BOOL CALLBACK NoOfferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK NoOfferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in USERINFO.CPP
BOOL CALLBACK UserInfoInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK UserInfoOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in BILLOPT.CPP
BOOL CALLBACK BillingOptInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK BillingOptOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in PAYMENT.CPP
BOOL CALLBACK PaymentInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK PaymentOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK PaymentCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ISPDIAL.CPP
BOOL CALLBACK ISPDialInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPDialPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPDialOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPDialCancelProc(HWND hDlg);

// Functions in ISPPAGE.CPP
BOOL CALLBACK ISPPageInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPPageOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in OLS.CPP
BOOL CALLBACK OLSInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK OLSOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in DIALERR.CPP
BOOL CALLBACK DialErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK DialErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK DialErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in SERVERR.CPP
BOOL CALLBACK ServErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ServErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ServErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ACFGNOFF.CPP
BOOL CALLBACK ACfgNoofferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ACfgNoofferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in ISDNNOFF.CPP
BOOL CALLBACK ISDNNoofferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISDNNoofferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in NOOFFER.CPP
BOOL CALLBACK OEMOfferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK OEMOfferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK OEMOfferCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);


#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwconn.rc
//
/******************************************
*** THIS FILE IS FOR THE SHARED RES ID  *** 
*** BETWEEN ICWCONN.DLL AND ICWRES.DLL  ***
*******************************************/

#define IDI_CNS                         100

#define IDD_PAGE_ISPSELECT              2300
#define IDD_PAGE_NOOFFER                2301
#define IDD_PAGE_USERINFO               2302
#define IDD_PAGE_BILLINGOPT             2303
#define IDD_PAGE_PAYMENT                2304
#define IDD_PAGE_ISPDIAL                2305
#define IDD_PAGE_ISPDATA                2306
#define IDD_PAGE_OLS                    2307
#define IDD_PAGE_DIALERROR              2308
#define IDD_PAGE_SERVERROR              2309
#define IDD_PAGE_ACFG_ISP               2310
#define IDD_PAGE_ACFG_NOOFFER           2311
#define IDD_PAGE_ISDN_NOOFFER           2312
#define IDD_PAGE_OEMOFFER               2313

#define IDD_PAYMENTTYPE_CREDITCARD      2400
#define IDD_PAYMENTTYPE_INVOICE         2401
#define IDD_PAYMENTTYPE_PHONEBILL       2402
#define IDD_PAYMENTTYPE_CUSTOM          2403

#define IDD_AUTODISCONNECT              2410

#define IDC_STATIC                      -1
#define IDC_LBLTITLE                    999
#define IDC_PAYMENT_CUSTOM_INV          1053
#define IDC_PAYMENT_CCNUMBER_LABEL      1025
#define IDC_PAYMENT_EXPIREMONTH_LABEL   1026
#define IDC_PAYMENT_EXPIREYEAR_LABEL    1027
#define IDC_PAYMENT_CCNAME_LABEL        1028
#define IDC_PAYMENT_CCADDRESS_LABEL     1029
#define IDC_PAYMENT_CCZIP_LABEL         1030
#define IDC_PAYMENT_SECURE              1031
#define IDC_PAYMENT_GROUP               1032
#define IDC_USERINFO_INTRO              1006
#define IDC_ISPLIST_CNSINFO             1003
#define IDC_ISPLIST_CNSICON             1004
#define IDC_BILLINGOPT_INTRO            1016
#define IDC_ISPDIAL_INTRO               1033
#define IDC_ISPDIAL_PHONENUM            1034
#define IDC_ISPDIAL_STATUS              1035
#define IDC_ISPDATA_HTML                1036
#define IDC_PAYMENT_IVADDRESS_LABEL1    1039
#define IDC_PAYMENT_IVADDRESS_LABEL2    1041
#define IDC_PAYMENT_IVCITY_LABEL        1043
#define IDC_PAYMENT_IVSTATE_LABEL       1045
#define IDC_PAYMENT_IVZIP_LABEL         1047
#define IDC_PAYMENT_PHONEIV_BILLNAME_LABEL 1049
#define IDC_PAYMENT_PHONEIV_ACCNUM_LABEL   1051
#define IDC_OLS_HTML                    1054
#define IDC_OLS_TITLE_LABEL             1055
#define IDC_OLS_GROUP                   1056
#define IDC_SERVERR_HELP                1058
#define IDC_DIALERR_HELP                1059
#define IDC_SERVERR_TEXT                1060
#define IDC_DIALERR_TEXT                1061
#define IDC_DIALING_PROPERTIES          1064
#define IDC_ISPDATA_TOSHTML             1066
#define IDC_ISPDATA_CUSTHTML            1068
#define IDC_ISPDATA_TOSINSTRT           1069
#define IDC_ISPSELECT_INTRO             1070
#define IDC_ISPSELECT_LBLISPLIST        1072
#define IDC_ISPSELECT_LBLMARKET         1073
#define IDC_USERINFO_LBLFIRSTNAME       1074
#define IDC_USERINFO_LBLLASTNAME        1075
#define IDC_USERINFO_LBLADDRESS1        1076
#define IDC_USERINFO_LBLADDRESS2        1077
#define IDC_USERINFO_LBLCITY            1078
#define IDC_USERINFO_LBLSTATE           1079
#define IDC_USERINFO_LBLZIP             1080
#define IDC_USERINFO_LBLPHONE           1081
#define IDC_LBLPAYMENTTYPE              1082
#define IDC_PAYMENT_INSTRUCT            1083
#define IDC_ISPDIAL_INSTRUCT            1084
#define IDC_ISPDIAL_LBLPHONENUM         1085
#define IDC_DIALERR_LBLPHONENUMBER      1086
#define IDC_DIALERR_LBLPROPERTIES       1087
#define IDC_DIALERR_LBLHELP             1089
#define IDC_ACFG_INSTRUCT               1090
#define IDC_ACFG_LBLISPLIST             1091
#define IDC_USERINFO_LBLCOMPANYNAME     1092
#define IDC_USERINFO_LBL_FENAME         1093
#define IDC_SAVE_DESKTOP_TEXT           1094

#define IDD_USERINFO_US                 1095
#define IDD_USERINFO_US_NO_COMPANY      1096
#define IDD_USERINFO_FE                 1097
#define IDD_USERINFO_FE_NO_COMPANY      1098
#define IDD_USERINFO_JPN                1099
#define IDD_USERINFO_JPN_NO_COMPANY     1100

#define IDC_NOOFFER1                    1101
#define IDC_NOOFFER2                    1102
#define IDC_NOOFFER3                    1103
#define IDC_AUTOCFG_NOOFFER1            1104
#define IDC_AUTOCFG_NOOFFER2            1105


#define IDC_OEMOFFER_HTML               1200
#define IDC_OEMOFFER_INSTRUCTION        1201

#define IDI_PHONE                       1210
#define IDC_IDLE_TEXT                   1211
#define IDC_DISCONNECT_TEXT             1212
#define IDC_SECONDS                     1213
#define IDC_SEC_TEXT                    1214
#define IDC_ISP_SEL_TITLE               1215
#define IDC_OEM_MULTI_TIER_INTRO        1216
#define IDC_OEM_MULTI_TIER_OFFER_HTML   1217
#define IDC_OEM_TIER1                   1218
#define IDC_OEM_TIER2                   1219
#define IDC_OEM_TIER3                   1220

#define IDA_PROGRESSANIME               1221
#define IDC_OEM_TEASER_HTML1            1222
#define IDC_OEM_TEASER_HTML2            1223
#define IDC_OEM_TEASER_HTML3            1224
#define IDC_TOS_TOSSAVE                 1225
#define IDC_NOOFFER                     1226

#define IDB_WATERMARK256                100
#define IDB_WATERMARK16                 101
#define IDB_BANNER256                   102
#define IDB_BANNER16                    103

#define IDS_APPNAME                     500
#define IDS_QUERYCANCEL                 501
#define IDS_ERR_OUTOFMEMORY             502
#define IDS_ISPSELECT_INTROFMT_MULTIPLE 504
#define IDS_ISPSELECT_INTROFMT_SINGLE   505
#define IDS_USERINFO_TITLE              506
#define IDS_USERINFO_INTROFMT           507
#define IDS_ISPSELECT_CNS               508
#define IDS_ISPSELECT_ONLISTSIGNUP      509
#define IDS_BILLINGOPT_INTROFMT         510
#define IDS_PAYMENT_SECURE              512
#define IDS_PAYMENT_UNSECURE            513
#define IDS_PAYMENT_CREDITCARD          514
#define IDS_ISPDIAL_INTROFMT            516
#define IDS_ISPDIAL_STATUSDIALINGFMT    517
#define IDS_ISPDIAL_STATUSREDIALINGFMT  518
#define IDS_ISPDIAL_STATUSCONNECTINGFMT 519
#define IDS_PAYMENT_INVOICE             521  
#define IDS_PAYMENT_PHONE               522  
#define IDS_PAYMENT_CUSTOM              600

#define IDS_JANUARY                   601  
#define IDS_FEBRUARY                  602  
#define IDS_MARCH                     603  
#define IDS_APRIL                     604  
#define IDS_MAY                       605  
#define IDS_JUNE                      606  
#define IDS_JULY                      607  
#define IDS_AUGUST                    608  
#define IDS_SEPTEMBER                 609  
#define IDS_OCTOBER                   610  
#define IDS_NOVEMBER                  611  
#define IDS_DECEMBER                  612

#define IDS_ISPSELECT_INVALID         634
#define IDS_ERR_TOS_DECLINE           637
#define IDS_DEFAULT_TOS_FILTER        638
#define IDS_DEFAULT_TOS_FILENAME      639

#define IDS_STEP1_TITLE               641
#define IDS_STEP2_TITLE               642
#define IDS_DIALERR_HELP              643
#define IDS_OLS_TITLE                 644
#define IDS_ISPASELECT_TITLE          648

#define IDS_ISP_AUTOCONFIG_OTHER      650

#define IDS_DEFAULT_ISPHTML_FILENAME  652

#define IDS_MOREADDRESS_JPN           653
#define IDS_MOREADDRESS_US            654
#define IDS_ISDN_NOOFFER1             655
#define IDS_ISDN_NOOFFER2             656
#define IDS_ISDN_NOOFFER3             657
#define IDS_ISDN_NOOFFER4             658
#define IDS_AUTOCFG_NOOFFER1          659
#define IDS_ISDN_AUTOCFG_NOOFFER1     660
#define IDS_ISDN_AUTOCFG_NOOFFER2     661
#define IDS_ISDN_AUTOCFG_NOOFFER3     662

#define IDS_OEMOFFER_INSTFMT_MULTIPLE 670
#define IDS_OEMOFFER_INSTFMT_SINGLE   671
#define IDS_DIALING_ERROR_TITLE       672
#define IDS_SERVER_ERROR_TITLE        673
#define IDS_SERVER_ERROR_BADPAGE      674
#define IDS_STEP3_TITLE               675

#define IDS_WIZ97_TITLE_FONT_FACE     676
#define IDS_MANUAL_TITLE              678
#define IDS_STEP2A_TITLE              679
#define IDS_NOT_ENOUGH_DISKSPACE      680
#define IDS_AUTOCFG_EXPLAIN_OTHER     681
#define IDS_SAVE_COPY_CONFIRM_MSG     682
#define IDS_TERMS_FILENAME            683
#define IDS_TERMS_FILENAME_COPY       684
#define IDS_ISPINFO_FILENAME          685
#define IDS_ISPINFO_FILENAME_COPY     686
#define IDS_OEMOFFER_INSTR_MULTITIER  687
#define IDS_OEM_TIER_TOOLTIP          688
#define IDS_NOOFFER                   689
#define IDS_SAVE_ISP_CONFIRM_MSG      690
#define IDS_START_MENU_INFOTIP        20001
#define IDS_START_MENU_NAME           20002
#define IDS_INS_FILE_FRIENDLYNAME     20003

#define IDA_ISPSELECT                   2000 
#define IDA_ACFG_ISP                    2001
#define IDA_USERINFO_US                 2002
#define IDA_USERINFO_FE                 2003
#define IDA_USERINFO_JPN                2004
#define IDA_BILLINGOPT                  2005
#define IDA_PAYMENT                     2006
#define IDA_PAYMENTTYPE_CREDITCARD      2007
#define IDA_PAYMENTTYPE_INVOICE         2008
#define IDA_PAYMENTTYPE_PHONEBILL       2009
#define IDA_ISPDATA                     2010
#define IDA_DIALERROR                   2011
#define IDA_SERVERROR                   2012
#define IDA_OEMOFFER                    2013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\paycsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"

extern CHAR szTempBuffer[];

const CHAR cszLUHN[]    = "LUHN";
const CHAR cszCustURL[] = "CustURL";

#define ReadVerifyW(x)      if (!ReadW(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto PAYCSVReadOneLineError;                    \
                            }
#define ReadVerifyBOOL(x)   if (!ReadBOOL(&(x),pcCSVFile))                      \
                            {                                                   \
                                AssertMsg(0,"Invalid BOOL in CSV file");        \
                                goto PAYCSVReadOneLineError;                    \
                            }
#define ReadVerifySZ(x,y)   if (!ReadSZ(&x[0],y+sizeof('\0'),pcCSVFile))        \
                            {                                                   \
                                AssertMsg(0,"Invalid STRING in CSV file");      \
                                goto PAYCSVReadOneLineError;                    \
                            }

// Do an strip of Single Quotes from a source string.  The source is formatted as:
// 'some text', and the dest string ends up being
// some text
void CPAYCSV::StripQuotes
(
    LPSTR   lpszDst,
    LPSTR   lpszSrc
)
{
    //lstrcpyn(lpszDst, lpszSrc + 1, lstrlen(lpszSrc) - 1);
    strcpy(lpszDst, lpszSrc + 1);
    lpszDst[strlen(lpszDst) - 1] = '\0';
}

// ############################################################################
BOOL CPAYCSV::ReadW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPAYCSV::ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2BOOL(szTempBuffer,pbool));
}

// ############################################################################
BOOL CPAYCSV::ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPAYCSV::ReadToEOL(CCSVFile far *pcCSVFile)
{
    return pcCSVFile->SkipTillEOL();
}

HRESULT CPAYCSV::ReadOneLine
(
    CCSVFile    far *pcCSVFile,
    BOOL        bLUHNFormat
)
{
    HRESULT     hr = ERROR_SUCCESS;
    CHAR        szTemp[MAX_ISP_NAME] = "\0";
    WORD        wLUHN;
    CHAR        szDisplayName[MAX_DISPLAY_NAME] = "\0";
    CHAR        szCustomPayURLPath[MAX_PATH] = "\0";

    if (!ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto PAYCSVReadOneLineExit;
    }

    if ('\0' == *szTemp)
    {
        hr = ERROR_FILE_NOT_FOUND; // no more enteries
        goto PAYCSVReadOneLineExit;
    }

    // Strip the single quotes from the isp Name
    StripQuotes(szDisplayName, szTemp);

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDisplayName, MAX_DISPLAY_NAME, m_szDisplayName, MAX_DISPLAY_NAME);
#else
    lstrcpy(m_szDisplayName, szDisplayName);
#endif

    ReadVerifyW(m_wPaymentType);
    
    // If this NOT a LUHN format file, then the next field is the payment custom URL
    if (!bLUHNFormat)
    {
        if (ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
        {
            StripQuotes(szCustomPayURLPath, szTemp);
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCustomPayURLPath, MAX_PATH, m_szCustomPayURLPath, MAX_PATH);
#else
            lstrcpy(m_szCustomPayURLPath, szCustomPayURLPath);
#endif
        }
        else
        {
            goto PAYCSVReadOneLineError;
        }
    }
    else
    {
        // BUGBUG: The format of the PAYMENT CSV file is not clear, so I am coding this for
        // now to just consume the entry, and move on.  Once the format is clarified, and FORBIN
        // updated, then the real code can be turned on, which should just be a ReadBOOL, followed
        // by the readSZ.
        
        ReadVerifyW(wLUHN);
        m_bLUHNCheck = FALSE;
        
        if (wLUHN == (WORD)1)
        {
            m_bLUHNCheck = TRUE;
        }
        
        // There may now also be a URL
        if (ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
        {
            StripQuotes(szCustomPayURLPath, szTemp);
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCustomPayURLPath, MAX_PATH, m_szCustomPayURLPath, MAX_PATH);
#else
            lstrcpy(m_szCustomPayURLPath, szCustomPayURLPath);
#endif
        }
    }        

    ReadToEOL(pcCSVFile);

PAYCSVReadOneLineExit:
    return hr;
    
PAYCSVReadOneLineError:
    hr = ERROR_INVALID_DATA;
    goto PAYCSVReadOneLineExit;
}

HRESULT CPAYCSV::ReadFirstLine
(
    CCSVFile    far *pcCSVFile,
    BOOL        far *pbLUHNFormat
)
{
    CHAR   szTemp[TEMP_BUFFER_LENGTH];
    int     i = 0;
    
    while (TRUE)
    {
        if (!ReadSZ(szTemp, TEMP_BUFFER_LENGTH, pcCSVFile))
            return(ERROR_INVALID_DATA);
            
        if (_strcmpi(szTemp, cszLUHN) == 0)
            *pbLUHNFormat = TRUE;

        if (_strcmpi(szTemp, cszCustURL) == 0)
            break;
            
        // Safety check
        if (i++ > NUM_PAYCSV_FIELDS)
            return (ERROR_INVALID_DATA);
    }
    ReadToEOL(pcCSVFile);
    return (ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\ressrcs.inc ===
GETCONN_DIR     = ..\..\

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn

MAJORCOMP=GETCONN
MINORCOMP=ICWRES

RESOURCE_ONLY_DLL=1

TARGETNAME=ICWRES
TARGETTYPE=DYNLINK
TARGETPATH=obj

#SET THE ICWRES FLAG FOR THE IFDEFs
C_DEFINES = -DICWRES -DNASHVILLE

DLLDEF=..\icwres.def

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES=                \
	..\icwconn.rc       \
    ..\icwres.cpp
    
TARGETLIBS= \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\serverr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  06/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    ServErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ServErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    HideProgressAnimation();

    if (fFirstInit)
    {   
        if (g_bMalformedPage)
        {
            TCHAR szMsg[MAX_MESSAGE_LEN] = TEXT("\0");
            LoadString(ghInstanceResDll, IDS_SERVER_ERROR_BADPAGE, szMsg, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szMsg);
            g_bMalformedPage = FALSE;
        }
        else
        {
            BSTR    bstrErrMsg = NULL;
            gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
            SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), W2A(bstrErrMsg));
            SysFreeString(bstrErrMsg);
        }

         // Fill in the support number
        BSTR bstrSupportPhoneNum     = NULL; 
        
        //Let the isp file override this in IEAK with SupportPhoneNumber=
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            gpWizardState->pRefDial->get_ISPSupportPhoneNumber(&bstrSupportPhoneNum);
        }
        
        if (!bstrSupportPhoneNum)
            gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);

        if (bstrSupportPhoneNum)
        {
            ASSERT(gpWizardState->lpSelectedISPInfo);
            gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_SERVERR_HELP), IDS_DIALERR_HELP, W2A(bstrSupportPhoneNum));
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
            SysFreeString(bstrSupportPhoneNum);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
        }
    }
    else
    {
        KillIdleTimer();
            
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_SERVERR;
    }        
    
    return bRet;
}


/*******************************************************************

  NAME:    ServErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ServErrorOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    if (fForward)
    {
        *pfKeepHistory = FALSE;
        gpWizardState->bDialExact = TRUE;
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    else
    {
        BOOL bRetVal;
        // Clear the dial Exact state var so that when we get to the dialing
        // page, we will regenerate the dial string
        gpWizardState->bDialExact = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}

BOOL CALLBACK ServErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    if ((GET_WM_COMMAND_CMD (wParam, lParam) == BN_CLICKED) &&
        (GET_WM_COMMAND_ID  (wParam, lParam) == IDC_DIAL_HELP))
    {
        HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\storage.h ===
//**********************************************************************
// File name: STORAGE.H
//
//      Definition of CStorage
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _STORAGE_H_ )
#define _STORAGE_H_





// Key to set and get elements from the storage 
typedef enum tagSTORAGEKEY
{
    ICW_PAYMENT = 0,
    
    // MUST LEAVE THIS ITEM AS LAST!!!
    MAX_STORGE_ITEM
} STORAGEKEY;

typedef struct Item 
{
    void*   pData;  // Data  
    DWORD   dwSize; // Size of data
} ITEM;

class CStorage
{
    private:
        ITEM   *m_pItem[MAX_STORGE_ITEM]; // list of items in storage
        
        
    public:

        CStorage(void);
        ~CStorage(void);
         
        BOOL    Set(STORAGEKEY key, void far * pData, DWORD dwSize);
        void*   Get(STORAGEKEY key);
        BOOL    Compare(STORAGEKEY key, void far * pData, DWORD dwSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\storage.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1998                   **
//*********************************************************************


#include "pre.h"


CStorage::CStorage(void) 
{
    // initialize all items
    for (int i=0; i<MAX_STORGE_ITEM; i++)
    {
        m_pItem[i] = NULL;
    }
}

CStorage::~CStorage(void) 
{
    // Clean up
    for (int i=0; i<MAX_STORGE_ITEM; i++)
    {
        if (m_pItem[i])
        {
            if (m_pItem[i]->pData)
            {
                delete [] m_pItem[i]->pData;
            }
            delete m_pItem[i];
        }
    }
}

// Associate the data with a key and puts it in storage
BOOL CStorage::Set(
    STORAGEKEY  key,
    void far *  pData,
    DWORD       dwSize
)
{

    // checks for existence of previous item
    if (m_pItem[key])
    {
        // Checks if a new allocation is necessary
        if (m_pItem[key]->dwSize < dwSize )
        {
            // Too small, new reallocation
            if (m_pItem[key]->pData)
            {
                delete [] m_pItem[key]->pData;
                m_pItem[key]->pData = (void*) new CHAR[dwSize];
            }
        }
    }
    else
    {
        // Allocate a new item
        m_pItem[key] = new ITEM;
        if (m_pItem[key])
        {
            m_pItem[key]->pData = (void*) new CHAR[dwSize];
        }
        else
        {
            return FALSE;
        }
    }

    if (m_pItem[key]->pData)
    {
        memcpy( m_pItem[key]->pData, pData, dwSize );
        m_pItem[key]->dwSize = dwSize;
        return TRUE;
    }

    return FALSE;
}



// Get the data with the specified key 
void* CStorage::Get(STORAGEKEY key)
{
    if (key < MAX_STORGE_ITEM)
    {
        if (m_pItem[key])
        {
            return m_pItem[key]->pData;
        }
    }
    return NULL;
}

// Compare the data with the specified key with the data
// pointed by pData with size dwSize
BOOL CStorage::Compare
(
    STORAGEKEY  key,
    void far *  pData,
    DWORD       dwSize
)
{
    // Make sure key is within our range
    if (key < MAX_STORGE_ITEM)
    {
        // make sure item is non-null
        if (m_pItem[key])
        {
            // make sure item has data 
            if (m_pItem[key]->pData && pData)
            {
                if (m_pItem[key]->dwSize == dwSize)
                {
                    if (memcmp(m_pItem[key]->pData,
                        pData,
                        dwSize) == 0)
                    {
                        return TRUE;
                    }
                }
            }
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\timeout.cpp ===
//**********************************************************************
// File name: timeout.cpp
//
//      Implementation of idle timer
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

const DWORD cdwIdleMinsTimeout = 5; // 5 minute timeout after a page has been fetched


INT_PTR CALLBACK DisconnectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndSecs;
    static DWORD s_dwStartTicks;
    const DWORD cdwSecsTimeout = 30; // Timeout of 30 seconds
    const UINT cuTimerID = 812U;
    int iSecsRemaining;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Start a one second timer
            s_hwndSecs = GetDlgItem(hwndDlg, IDC_SECONDS);
            SetTimer(hwndDlg, cuTimerID, 1000U, NULL);
            s_dwStartTicks = GetTickCount();
            return TRUE;

        case WM_TIMER:

            iSecsRemaining = cdwSecsTimeout - (int)(GetTickCount() - s_dwStartTicks) / 1000;
            if (iSecsRemaining <= 0)
            {
                KillTimer(hwndDlg, cuTimerID);
                EndDialog(hwndDlg, IDCANCEL);
                return TRUE;
            }

            if (NULL != s_hwndSecs)
            {
                TCHAR szSeconds[16];
                wsprintf(szSeconds, TEXT("%d"), iSecsRemaining);
                SetWindowText(s_hwndSecs, szSeconds);
            }
            return TRUE;

        case WM_COMMAND:
            // IDOK == Stay connected, IDCANCEL == Disconnect
            if (IDOK == wParam || IDCANCEL == wParam)
            {
                KillTimer(hwndDlg, cuTimerID);
                EndDialog(hwndDlg, wParam);
            }

        default:
            return 0;
    }
}

void CALLBACK IdleTimerProc (HWND hWnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(NULL, gpWizardState->nIdleTimerID);
    gpWizardState->nIdleTimerID = 0;

    if (gpWizardState->hWndMsgBox)
        EnableWindow(gpWizardState->hWndMsgBox,FALSE);

    int iResult = (int)DialogBox(ghInstanceResDll,
                                 MAKEINTRESOURCE(IDD_AUTODISCONNECT),
                                 gpWizardState->hWndWizardApp,
                                 DisconnectDlgProc);

    if (gpWizardState->hWndMsgBox)
    {
        EnableWindow(gpWizardState->hWndMsgBox,TRUE);
        SetActiveWindow(gpWizardState->hWndMsgBox);
    }

    if (iResult == IDCANCEL)
    {
        // Disconnect, and setup so that the user goes to the dial error page
        gpWizardState->pRefDial->DoHangup();

        // Simulate the pressing of the NEXT button.  The ISPPAGE will see that
        // bAutoDisconnected is TRUE, and automatically goto the server error page
        gpWizardState->bAutoDisconnected = TRUE;
        PropSheet_PressButton(gpWizardState->hWndWizardApp,PSBTN_NEXT);

    }
    else
    {
        gpWizardState->nIdleTimerID = SetTimer(NULL, 0, cdwIdleMinsTimeout * 60 * 1000, IdleTimerProc);
    }
}


void StartIdleTimer()
{
   // Start the 5 min inactivity timer
    if (gpWizardState->nIdleTimerID)
    {
       KillTimer(NULL, gpWizardState->nIdleTimerID);
    }
    gpWizardState->nIdleTimerID = SetTimer(NULL, 0, cdwIdleMinsTimeout * 60 * 1000, IdleTimerProc);
}

void KillIdleTimer()
{
    if (gpWizardState->nIdleTimerID)
    {
       KillTimer(NULL, gpWizardState->nIdleTimerID);
       gpWizardState->nIdleTimerID = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  05/13/98    donaldm     new for ICW 5.0

#ifndef _WIZDEF_H_
#define _WIZDEF_H_


// Defines
#define MAX_REG_LEN         2048    // max length of registry entries
#define MAX_RES_LEN         255     // max length of string resources
#define SMALL_BUF_LEN       48      // convenient size for small text buffers


#define NUM_WIZARD_PAGES    14      // total number of pages in wizard
#define MAX_PAGE_INDEX      13
#define ISP_INFO_NO_VALIDOFFER   -1
#define MAX_OEM_MUTI_TIER   3

// Data structures

// structure to hold information about wizard state
typedef struct tagWIZARDSTATE  
{
    UINT    uCurrentPage;    // index of current page wizard is on
    
    // keeps a history of which pages were visited, so user can
    // back up and we know the last page completed in case of reboot.
    UINT    uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT    uPagesCompleted;         // # of pages in uPageHistory

    BOOL    fNeedReboot;    // reboot needed at end
    BOOL    bDoneWebServDownload;
    BOOL    bDoneWebServRAS;
    BOOL    bDialExact;
    BOOL    bRefDialTerminate;
    BOOL    bParseIspinfo;
    BOOL    bISDNMode;

    int     iRedialCount;

    // Number of different offers types available
    int     iNumOfValidOffers;
    int     iNumOfISDNOffers;
    
    // Image list for ISP select list view
    HIMAGELIST  himlIspSelect;

    CISPCSV FAR *lpSelectedISPInfo;
    
    // Pointer to an OEM tier 1 offer, max of 3
    CISPCSV FAR *lpOEMISPInfo[MAX_OEM_MUTI_TIER];
    UINT    uNumTierOffer;

    BOOL    bShowMoreOffers;            // TRUE if we should show more offers
    
    UINT_PTR nIdleTimerID;
    BOOL     bAutoDisconnected;
    
    HWND    hWndWizardApp;
    HWND    hWndMsgBox;
    
    // ICWHELP objects
    IUserInfo           *pUserInfo;
    IRefDial            *pRefDial;
    IWebGate            *pWebGate;
    IINSHandler         *pINSHandler;
        
    CRefDialEvent       *pRefDialEvents;
    CWebGateEvent       *pWebGateEvents;
    CINSHandlerEvent    *pINSHandlerEvents;

    // ICWWebView Object
    IICWWebView         *pICWWebView;
    IICWWalker          *pHTMLWalker;
    IICWGifConvert      *pGifConvert;
    IICWISPData         *pISPData;    
    CStorage            *pStorage;

    BOOL                bWasNoUserInfo;     // TRUE if there was no user info in the registry
    BOOL                bUserEnteredData;   // TRUE if the user sees the user info page
    
    HANDLE              hEventWebGateDone;
    
    HWND                hwndProgressAnime;
    // State data that is common to both sides of the WIZARD
    CMNSTATEDATA        cmnStateData;
} WIZARDSTATE;


#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "pre.h"

HHOOK     g_hhookCBT;              // CBT hook identifier

// function prototypes
VOID _cdecl FormatErrorMessage(LPTSTR pszMsg,DWORD cbMsg,LPTSTR pszFmt,LPTSTR szArg);

/*******************************************************************

  NAME:    ShowWindowWithParentControl

  SYNOPSIS:  Shows a dialog box with the WS_EX_CONTROLPARENT style.

********************************************************************/
void ShowWindowWithParentControl(HWND hwndChild)
{
    // Parent should control us, so the user can tab out of our property sheet
    DWORD dwStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong(hwndChild, GWL_EXSTYLE, dwStyle);
    ShowWindow(hwndChild, SW_SHOW);
}

//****************************************************************************
// Function: CBTProc
//
// Purpose: Callback function of WH_CBT hook
//
// Parameters and return value:
//    See documentation for CBTProc. 
//
// Comments: This function is used to get a copy of the window handle for
// modal message boxes created while ICW is running, so we can make the
// connection timeout dialog be "super modal" in that it can disable even
// these modal message boxes.  This is necessary because the connection timeout
// dialog can popup at any time.
//
//****************************************************************************

LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
   LPCBT_CREATEWND lpcbtcreate;
   
   if (nCode < 0)
       return CallNextHookEx(g_hhookCBT, nCode, wParam, lParam); 

   // If a window is being created, and we don't have a copy of the handle yet
   // then we want to make a copy of the handle.
   if (nCode == HCBT_CREATEWND && (NULL == gpWizardState->hWndMsgBox))     
   {
       lpcbtcreate = (LPCBT_CREATEWND)lParam;
       
       // Check if the window being created is a message box. The class name of
       //   a message box is WC_DIALOG since message boxes are just special dialogs.
       //   We can't subclass the message box right away because the window 
       //   procedure of the message box is not set when this hook is called. So
       //   we wait till the hook is called again when one of the message box 
       //   controls are created and then we subclass. This will happen because
       //   the message box has at least one control.
       if (WC_DIALOG == lpcbtcreate->lpcs->lpszClass) 
       {
           gpWizardState->hWndMsgBox = (HWND)wParam;
       }
   }
   else if (nCode == HCBT_DESTROYWND && (HWND)wParam == gpWizardState->hWndMsgBox)
   {
       gpWizardState->hWndMsgBox = NULL;      
   }   
   return 0;          
}

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR       szMsgBuf[MAX_RES_LEN+1];
    TCHAR       szSmallBuf[SMALL_BUF_LEN+1];
    HOOKPROC    hkprcCBT;
    int         nResult;
        
    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    hkprcCBT = (HOOKPROC)MakeProcInstance((FARPROC)CBTProc, ghInstance);
    
    // Set a task specific CBT hook before calling MessageBox. The CBT hook will
    //    be called when the message box is created and will give us access to 
    //    the window handle of the MessageBox.
    g_hhookCBT = SetWindowsHookEx(WH_CBT, hkprcCBT, ghInstance, GetCurrentThreadId());

    nResult = MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons);
    
    UnhookWindowsHookEx(g_hhookCBT);
    
    FreeProcInstance(hkprcCBT);
    return nResult;
    
}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    ASSERT(lpszBuf);

    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstanceResDll, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2DwEx(PCSTR pSz,DWORD *dw)
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2DwEx(LPCSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    BOOL    bNeg = FALSE;
    while (*pSz)
    {
        if( *pSz == '-' )
        {
            bNeg = TRUE;
            pSz++;
        }
        else if ((*pSz >= '0' && *pSz <= '9'))
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    if(bNeg)
        val = 0 - val;
        
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2WEx(PCSTR pSz,WORD *w)
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2WEx(LPCSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2DwEx(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCSTR pSz,BYTE far *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}

const CHAR cszFALSE[] = "FALSE";
const CHAR cszTRUE[]  = "TRUE";
// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2BOOL(LPCSTR pSz,BOOL far *pbool)
{
    if (_strcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = (BOOL)FALSE;
    }
    else
    {
        *pbool = (BOOL)TRUE;
    }
    return TRUE;
}

BOOL FSz2SPECIAL(LPCSTR pSz,BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt)
{
    // See if the value is a BOOL (TRUE or FALSE)
    if (_strcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = FALSE;
        *pbIsSpecial = FALSE;
    }
    else if (_strcmpi(cszTRUE, pSz) == 0)
    {
        *pbool = (BOOL)TRUE;
        *pbIsSpecial = FALSE;
    }
    else
    {
        // Not a BOOL, so it must be special
        *pbool = (BOOL)FALSE;
        *pbIsSpecial = TRUE;
        *pInt = atol(pSz); //_ttoi(pSz); 
    }
    return TRUE;
}

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}

void WaitForEvent(HANDLE hEvent)
{
    MSG     msg;
    DWORD   dwRetCode;
    HANDLE  hEventList[1];
    hEventList[0] = hEvent;

    while (TRUE)
    {
        // We will wait on window messages and also the named event.
        dwRetCode = MsgWaitForMultipleObjects(1, 
                                          &hEventList[0], 
                                          FALSE, 
                                          300000,            // 5 minutes
                                          QS_ALLINPUT);

        // Determine why we came out of MsgWaitForMultipleObjects().  If
        // we timed out then let's do some TrialWatcher work.  Otherwise
        // process the message that woke us up.
        if (WAIT_TIMEOUT == dwRetCode)
        {
            break;
        }
        else if (WAIT_OBJECT_0 == dwRetCode)
        {
            break;
        }
        else if (WAIT_OBJECT_0 + 1 == dwRetCode)
        {
            while (TRUE)
            {   
                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT == msg.message)
                    {
                        break;
                    }
                    else if ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_ESCAPE))
                    {
                        PropSheet_PressButton(gpWizardState->hWndWizardApp,PSBTN_CANCEL);
                    }                        
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }                                
                } 
                else
                {
                    break;
                }                   
            }
        }
    }
}

void ShowProgressAnimation()
{
    if (gpWizardState->hwndProgressAnime)
    {
        ShowWindow(gpWizardState->hwndProgressAnime, SW_SHOWNORMAL);  
        Animate_Play (gpWizardState->hwndProgressAnime,0, -1, -1);
    }
}

void HideProgressAnimation()
{
    if (gpWizardState->hwndProgressAnime)
    {
        Animate_Stop(gpWizardState->hwndProgressAnime);        
        ShowWindow(gpWizardState->hwndProgressAnime, SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\userinfo.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  USERINFO.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98    donaldm     Created.
//  08/19/98    donaldm     BUGBUG: The code to collect and save the user
//                          entered data is not optimal in terms of size
//                          and can/should be cleaned up at some future time
//
//*********************************************************************

#include "pre.h"

#define BACK 0
#define NEXT 1

enum DlgLayout
{
    LAYOUT_FE = 0,
    LAYOUT_JPN,
    LAYOUT_US
};

HWND hDlgUserInfoCompany   = NULL;
HWND hDlgUserInfoNoCompany = NULL;
HWND hDlgCurrentUserInfo   = NULL;
WORD g_DlgLayout;

// This function will initialize the data in the user information dialog edit controls.
// The data used to initalize comes from the UserInfo object in ICWHELP.DLL
void InitUserInformation
(
    HWND    hDlg
)
{    
    BOOL        bRetVal;
    IUserInfo   *pUserInfo = gpWizardState->pUserInfo;
    BSTR        bstr;        
        
        
    // Get initial user info data values from the ICWHELP user info object, and
    // set the value in the ISPDATA object
    // we only need to do this 1 time per ICW session
    if(!gpWizardState->bUserEnteredData)
    {
        
        pUserInfo->CollectRegisteredUserInfo(&bRetVal);
        // Set this state varialbe, since the user has seen the user info page
        gpWizardState->bUserEnteredData = TRUE;
    
    }
    // The return value from CollectRegisteredUserInfo is FALSE if there is no data in the
    // registry. In this case we set bWasNoUserInfo so that we can persist it later.  We
    // only want to persis the user info it we complete sucessfully, and if there was
    // no user info.
    gpWizardState->bWasNoUserInfo = !bRetVal;
    
    // Put all the initial values, with no validation
    pUserInfo->get_FirstName(&bstr);
    if (GetDlgItem(hDlg, IDC_USERINFO_FE_NAME))
    {
        SetDlgItemText(hDlg,IDC_USERINFO_FE_NAME, W2A(bstr));
    }
    else
    {
        SetDlgItemText(hDlg, IDC_USERINFO_FIRSTNAME, W2A(bstr));
        SysFreeString(bstr);
        
        pUserInfo->get_LastName(&bstr);
        SetDlgItemText(hDlg, IDC_USERINFO_LASTNAME, W2A(bstr));
    }
    SysFreeString(bstr);
    
    if (GetDlgItem(hDlg, IDC_USERINFO_COMPANYNAME))
    {
        pUserInfo->get_Company(&bstr);
        SetDlgItemText(hDlg, IDC_USERINFO_COMPANYNAME, W2A(bstr));
        SysFreeString(bstr);
    }        
    
    pUserInfo->get_Address1(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ADDRESS1, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_Address2(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ADDRESS2, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_City(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_CITY, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_State(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_STATE, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_ZIPCode(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ZIP, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_PhoneNumber(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_PHONE, W2A(bstr));
    SysFreeString(bstr);
}        

BOOL bValidateSaveUserInformation (HWND hDlg, BOOL fForward)
{
    UINT        uCtrlID;
    BOOL        bValid = FALSE;
    IUserInfo   *pUserInfo = gpWizardState->pUserInfo;
    IICWISPData *pISPData = gpWizardState->pISPData;    
    TCHAR       szTemp[MAX_RES_LEN] = TEXT("\0");
    WORD        wPrevValidationValue = 0;

    if (fForward)
        wPrevValidationValue = ISPDATA_Validate_DataPresent;
    else
        wPrevValidationValue = ISPDATA_Validate_None;

    while (1)
    {
        if (GetDlgItem(hDlg, IDC_USERINFO_FE_NAME))
        {
            uCtrlID = IDC_USERINFO_FE_NAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_FE_NAME, szTemp, wPrevValidationValue))
                break;
               
            // Set the input data into the pUserInfo object
            pUserInfo->put_FirstName(A2W(szTemp));
            
            // Since we used FE_NAME, we need to clear FIRSTNAME and LASTNAME, so they are not sent in the
            // query string
            pISPData->PutDataElement(ISPDATA_USER_FIRSTNAME, NULL, ISPDATA_Validate_None);
            pISPData->PutDataElement(ISPDATA_USER_LASTNAME, NULL, ISPDATA_Validate_None);
        }
        else
        {
            uCtrlID = IDC_USERINFO_FIRSTNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_FIRSTNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_FirstName(A2W(szTemp));
            
            uCtrlID = IDC_USERINFO_LASTNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_LASTNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_LastName(A2W(szTemp));
            
            // Since we did not use FE_NAME, we need to clear it
            pISPData->PutDataElement(ISPDATA_USER_FE_NAME, NULL, ISPDATA_Validate_None);
        }
        
        if (GetDlgItem(hDlg, IDC_USERINFO_COMPANYNAME))
        {
            uCtrlID = IDC_USERINFO_COMPANYNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_COMPANYNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_Company(A2W(szTemp));
        }
        else
        {
            pISPData->PutDataElement(ISPDATA_USER_COMPANYNAME, NULL, ISPDATA_Validate_None);
        }
        
        uCtrlID = IDC_USERINFO_ADDRESS1;
        GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_ADDRESS, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_Address1(A2W(szTemp));
        
        // Only validate address 2 if we are in Japanese layout, since FE and US layout
        // have this an on optional field
        uCtrlID = IDC_USERINFO_ADDRESS2;
        GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_MOREADDRESS, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_Address2(A2W(szTemp));
        
        uCtrlID = IDC_USERINFO_CITY;
        GetDlgItemText(hDlg, uCtrlID , szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_CITY, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_City(A2W(szTemp));

        uCtrlID = IDC_USERINFO_STATE;
        GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_STATE, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_State(A2W(szTemp));

        uCtrlID = IDC_USERINFO_ZIP;
        GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_ZIP, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_ZIPCode(A2W(szTemp));
        
        uCtrlID = IDC_USERINFO_PHONE;
        GetDlgItemText(hDlg, uCtrlID, szTemp, sizeof(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_PHONE, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_PhoneNumber(A2W(szTemp));
        
        // If we get here, then all fields are valid
        bValid = TRUE;
        break;
    }    
    if (!bValid)    
        SetFocus(GetDlgItem(hDlg, uCtrlID));            
        
    return (bValid);
}

INT_PTR CALLBACK UserInfoDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg) 
    {
        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
    
        case WM_SHOWWINDOW:
        {
            if((BOOL)wParam)
                InitUserInformation(hDlg);
            break;
        }
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_BACK:
        {
            if (bValidateSaveUserInformation(hDlg, BACK))
                SetPropSheetResult(hDlg,TRUE);
            else                
                SetPropSheetResult(hDlg, FALSE);
            return TRUE;
       
        }
        case WM_USER_NEXT:
        {
            if (bValidateSaveUserInformation(hDlg, NEXT))
                SetPropSheetResult(hDlg,TRUE);
            else                
                SetPropSheetResult(hDlg, FALSE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

/*******************************************************************

  NAME:    SwitchUserInfoType

********************************************************************/
void SwitchUserInfoDlg
(
    HWND    hDlg, 
    BOOL    bNeedCompanyName
)
{
    UINT    idDlg;
    // Hide the current userinfo window if there is one
    if (hDlgCurrentUserInfo)
        ShowWindow(hDlgCurrentUserInfo, SW_HIDE);
    
    // Figure out which template to use
    switch(g_DlgLayout)
    {
        case LAYOUT_FE:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_FE;
            else
                idDlg = IDD_USERINFO_FE_NO_COMPANY;
            break;
            
            
        case LAYOUT_JPN:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_JPN;
            else
                idDlg = IDD_USERINFO_JPN_NO_COMPANY;
            break;
        
        case LAYOUT_US:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_US;
            else
                idDlg = IDD_USERINFO_US_NO_COMPANY;
            break;
    }        
    
    // Create the necessary dialog
    if (bNeedCompanyName)
    {
        if (NULL == hDlgUserInfoCompany)
        {
            hDlgUserInfoCompany = CreateDialog(ghInstanceResDll, 
                                               MAKEINTRESOURCE(idDlg), 
                                               hDlg, 
                                               UserInfoDlgProc);
        }            
        hDlgCurrentUserInfo = hDlgUserInfoCompany;
    }
    else
    {
        if (NULL == hDlgUserInfoNoCompany)
        {
            hDlgUserInfoNoCompany = CreateDialog(ghInstanceResDll, 
                                                   MAKEINTRESOURCE(idDlg), 
                                                   hDlg, 
                                                   UserInfoDlgProc);
        }            
        hDlgCurrentUserInfo = hDlgUserInfoNoCompany;
    }
    
    
    // Show the new payment type window
    ShowWindowWithParentControl(hDlgCurrentUserInfo);
}

/*******************************************************************

  NAME:    UserInfoInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK UserInfoInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // Create a local reference for the ISPData object
    IICWISPData        *pISPData = gpWizardState->pISPData;    
    PAGEINFO            *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    
    if (fFirstInit)
    {
        // Figure out which dialog layout to use, FE or US
        // This is a 1 time calculation, since the user cannot change locales while running ICW
        switch (GetUserDefaultLCID())
        {
            case LCID_JPN:
                g_DlgLayout = LAYOUT_JPN;
                // Load the appropriate nested dialog accelerator table
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_JPN));      
                break;
                
            case LCID_CHT:
            case LCID_S_KOR:
            case LCID_N_KOR:
            case LCID_CHS:
                g_DlgLayout = LAYOUT_FE;
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_FE));      
                break;
                                
            default:
                g_DlgLayout = LAYOUT_US;            
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_US));      
                break;
        }
    }
    else
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_USERINFO;
        
        DWORD   dwConfigFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        // Setup the ISPData object so that is can apply proper validation based on the selected ISP
        pISPData->PutValidationFlags(gpWizardState->lpSelectedISPInfo->get_dwRequiredUserInputFlags());

        // Switch in the correct User Info Dialog template
        SwitchUserInfoDlg(hDlg, dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME);

    }    
    return TRUE;
}

/*******************************************************************

  NAME:    UserInfoOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/

BOOL CALLBACK UserInfoOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // Create a local reference for the ISPData object
    IICWISPData* pISPData      = gpWizardState->pISPData;    
    DWORD        dwConfigFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

    if (fForward)
    {
        // Collect, valicate, and save user entered information
        if (dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME)
        {
            if (!SendMessage(hDlgUserInfoCompany, WM_USER_NEXT, 0, 0l))
                return FALSE;
        }
        else
        {
            if (!SendMessage(hDlgUserInfoNoCompany, WM_USER_NEXT, 0, 0l))
                return FALSE;
        }        
        // Figure out which page to goto next, based on the config flags
        while (1)
        {           
            if (ICW_CFGFLAG_BILL & dwConfigFlags)
            {
                *puNextPage = ORD_PAGE_BILLINGOPT; 
                break;
            }            
            
            if (ICW_CFGFLAG_PAYMENT & dwConfigFlags)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                break;
            }         
            
            // We need to skip both billing and payment pages, so goto the dial page
            *puNextPage = ORD_PAGE_ISPDIAL; 
            break;
        }            
    }
    else
    {
        // Collect, valicate, and save user entered information
        if (dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME)
        {
            if (!SendMessage(hDlgUserInfoCompany, WM_USER_BACK, 0, 0l))
                return FALSE;
        }
        else
        {
            if (!SendMessage(hDlgUserInfoNoCompany, WM_USER_BACK, 0, 0l))
                return FALSE;
        }        
    
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for ICWCONN
//

//  HISTORY:
//  
//  05/14/98    donaldm     created it
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define WIZ97_TITLE_FONT_PTS    12

#define WM_MYINITDIALOG         WM_USER

#define WM_USER_NEXT            (WM_USER + 100)
#define WM_USER_CUSTOMINIT      (WM_USER + 101)
#define WM_USER_BACK            (WM_USER + 102)

#define MAX_RES_LEN         255
#define SMALL_BUF_LEN       48

extern const VARIANT c_vaEmpty;
//
// BUGBUG: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)


// Globals used by multiple files.
extern WIZARDSTATE* gpWizardState;
extern HINSTANCE    ghInstance;
extern HINSTANCE    ghInstanceResDll;
extern PAGEINFO     PageInfo[];
extern INT          _convert;
extern UINT         g_uExternUIPrev;
extern UINT         g_uExternUINext;
extern BOOL         gfQuitWizard;
extern BOOL         gfUserCancelled;
extern BOOL         gfUserBackedOut;
extern BOOL         gfUserFinished;
extern BOOL         gfBackedUp;
extern BOOL         gfReboot;
extern BOOL         g_bMalformedPage;
extern BOOL         g_bCustomPaymentActive;
extern BOOL         gfISPDialCancel;
// Trace flags
#define TF_APPRENTICE       0x00000010
#define TF_CLASSFACTORY     0x00000020
#define TF_ICWCONN          0x00000040
#define TF_GENDLG           0x00000080
#define TF_ISPSELECT        0x00000100

// Function avalable in UTIL.CPP
LPTSTR  LoadSz                       (UINT idString,LPTSTR lpszBuf,UINT cbBuf);
int     MsgBox                       (HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int     MsgBoxSz                     (HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
void    ShowWindowWithParentControl  (HWND hwndChild);

BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCSTR pSz,WORD far *w);    
BOOL FSz2WEx(LPCSTR pSz,WORD far *w);    //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2B(LPCSTR pSz,BYTE far *pb);
BOOL FSz2BOOL(LPCSTR pSz,BOOL far *pbool);
BOOL FSz2SPECIAL(LPCSTR pSz,BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt);

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);

void WaitForEvent(HANDLE hEvent);

void StartIdleTimer();
void KillIdleTimer();
void ShowProgressAnimation();
void HideProgressAnimation();

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa,  int nChars);
LPSTR  WINAPI W2AHelper(LPSTR lpa,  LPCWSTR lpw, int nChars);

#ifndef A2WHELPER
#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper
#endif

#ifdef UNICODE
// In this module, A2W and W2A are not required.
#define A2W(lpa)       (lpa)
#define W2A(lpw)       (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#endif  // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\appwnd.h ===
// This class will implement

class CICWApp
{
    public:
        // Data    
        HWND        m_hWndApp;             // Window Handle of the Application
        HACCEL      m_haccel;
        TCHAR       m_szOEMHTML[INTERNET_MAX_URL_LENGTH];
        TCHAR       m_szAppTitle[MAX_TITLE];
        COLORREF    m_clrBusyBkGnd;
        CICWButton  m_BtnBack;
        CICWButton  m_BtnNext;
        CICWButton  m_BtnCancel;
        CICWButton  m_BtnFinish;
        CICWButton  m_BtnTutorial;
        
        CICWApp( void );
        ~CICWApp( void );

        HRESULT Initialize( void );
        static LRESULT CALLBACK ICWAppWndProc(HWND hWnd,
                                       UINT uMessage,
                                       WPARAM wParam,
                                       LPARAM lParam);

        void SetWizButtons(HWND hDlg, LPARAM lParam);
        
        HRESULT SetBackgroundBitmap(LPTSTR szBkgrndBmp);
        HRESULT SetFirstPageBackgroundBitmap(LPTSTR szBkgrndBmp);
        HRESULT SetTitleParams(int iTitleTop,
                               int iTitleLeft,
                               LPTSTR lpszFontFace,
                               long lFontPts,
                               long lFontWeight,
                               COLORREF clrFont);
        
        int     GetButtonAreaHeight();

        // Use Default wizard page placement
        HRESULT SetWizardWindowTop(int iTop);
        HRESULT SetWizardWindowLeft(int iLeft);
        
    private:
        // Fuctions
        BOOL    InitWizAppWindow(HWND hWnd);
        BOOL    InitAppButtons(HWND hWnd);
        BOOL    InitAppHTMLWindows(HWND hWnd);
        BOOL    CreateWizardPages(HWND hWnd);
        BOOL    CycleButtonFocus(BOOL bForward);
        BOOL    CheckButtonFocus( void );
        
        void    DisplayHTML( void );
        void    CenterWindow( void );
        
        // Data    
        HWND        m_hwndHTML;
        HWND        m_hwndTitle;
        HFONT       m_hTitleFont;
        COLORREF    m_clrTitleFont;
        
        int         m_iWizardTop;           // Top left corner of where the
        int         m_iWizardLeft;          // wizard dialogs will be placed
        RECT        m_rcClient;             // Client area of the Application
        RECT        m_rcHTML;               // Size of the OEM HTML area (first page)
        RECT        m_rcTitle;
        
        int         m_iBtnBorderHeight;     // Total border above and below the wizard
                                            // buttons
        int         m_iBtnAreaHeight;           // Overall button area height                                            
        BOOL        m_bOnHTMLIntro;
        HWND        m_hWndFirstWizardPage;
        
        HBITMAP     m_hbmFirstPageBkgrnd;
        
        WORD        m_wMinWizardHeight;
        WORD        m_wMinWizardWidth;
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\appwnd.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"
#include "tutor.h"

extern HWND     RunSignupWizard(HWND hWndOwner);
extern TCHAR    g_szICWStatic[];
extern CICWTutorApp* g_pICWTutorApp; 


#define MIN_WIZARD_WIDTH        686     // Size needed for Large fonts
#define MIN_WIZARD_HEIGHT       470     // This is the default fallback


#define MAX_BORDER_HEIGHT       30      // MAX total height of border above and
                                        // below the wizard buttons

#define DEFAULT_TITLE_TOP       10      // Default top/left position for titles
#define DEFAULT_TITLE_LEFT      10
#include "icwextsn.h"
#include "webvwids.h"           // Needed to create an instance of the ICW WebView object

INT_PTR CALLBACK SizerDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    return FALSE;
}            

CICWApp::CICWApp
( 
    void
)
{
    HWND    hDlgSizer;
    RECT    rcDlg;
    
    m_haccel = NULL;
    
    // Use Default wizard page placement
    m_iWizardTop = -1;
    m_iWizardLeft = -1;
    m_hTitleFont = NULL;
    m_clrTitleFont = (COLORREF)GetSysColor(COLOR_WINDOWTEXT);
    m_clrBusyBkGnd = (COLORREF)GetSysColor(COLOR_WINDOW);
    m_hbmFirstPageBkgrnd = NULL;

    hDlgSizer = CreateDialog(g_hInstance, 
                             MAKEINTRESOURCE(IDD_PAGE_SIZER), 
                             GetDesktopWindow(), 
                             SizerDlgProc);
    if (hDlgSizer)
    {   
        GetClientRect(hDlgSizer, &rcDlg);                          
        DestroyWindow(hDlgSizer);
        m_wMinWizardWidth = (WORD)RECTWIDTH(rcDlg);
        m_wMinWizardHeight = (WORD)RECTHEIGHT(rcDlg);
    }
    else
    {
        m_wMinWizardWidth = MIN_WIZARD_WIDTH;
        m_wMinWizardHeight = MIN_WIZARD_HEIGHT;
    }        
}

CICWApp::~CICWApp
( 
    void
)
{
    if (m_hTitleFont)
        DeleteObject(m_hTitleFont);
    
    if (m_hbmFirstPageBkgrnd)    
        DeleteObject(m_hbmFirstPageBkgrnd);
}

// Enumerator proc used to disable the children windows in the
// wizard control
BOOL CALLBACK EnumChildProc
(
    HWND hwnd,      // handle to child window
    LPARAM lParam   // application-defined value
)
{
    // We are only interested in immediate children of the wizard, but
    // not the wizard page DLG, which is a child of the wizard. The 
    // PropSheet_GetCurrentPagehwnd will return the window handle of the
    // current Wizard page, so we can compare against the windows being
    // enumerated
    if ((hwnd != PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages)) 
         && GetParent(hwnd) == (HWND)lParam)
    {
        // Remove the DEFPUSHBITTON style if the child has it
        DWORD dwStyle = GetWindowLong(hwnd,GWL_STYLE);
        SendMessage(hwnd,BM_SETSTYLE,dwStyle & (~BS_DEFPUSHBUTTON),0);

        // Hide and disable the window
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }        
    return TRUE;
}

BOOL CICWApp::CreateWizardPages
(
    HWND    hWnd
)
{
    DWORD   dwStyle;
    RECT    rcWizardPage;
    int     iTop = m_iWizardTop;
    int     iLeft = m_iWizardLeft;
    
    gpWizardState->cmnStateData.bOEMCustom = TRUE;
    gpWizardState->cmnStateData.hWndWizardPages = RunSignupWizard(hWnd);
    
     // Parent should control us, so the user can tab out of our property sheet
    dwStyle = GetWindowLong(gpWizardState->cmnStateData.hWndWizardPages, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong(gpWizardState->cmnStateData.hWndWizardPages, GWL_EXSTYLE, dwStyle);

    // Disable the standard Wizard control windows
    EnumChildWindows(gpWizardState->cmnStateData.hWndWizardPages, 
                    EnumChildProc, 
                    (LPARAM)gpWizardState->cmnStateData.hWndWizardPages);
 
    // Get the client rectangle of the Wizard page.  We will use this
    // for the width and height.  The top/left corner is either specified
    // or computed
    m_hWndFirstWizardPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    
    // Update the wizard dialog position
    GetWindowRect(m_hWndFirstWizardPage, &rcWizardPage);
    if (-1 == iTop)
    {
        // Start out by allowing for the page and the buttons, going from
        // the bottom up...
        iTop = RECTHEIGHT(m_rcClient) - 
               RECTHEIGHT(rcWizardPage) - 
               GetButtonAreaHeight();
        // If there is still room, leave a border between the buttons
        // and the page               
        if (iTop > 0)
        {
            iTop -= m_iBtnBorderHeight/2;
        }
                    
        // Make sure the top is not in negative space               
        if (iTop < 0)
            iTop = 0;
    }
    
    if (-1 == iLeft)
    {
        if (RECTWIDTH(m_rcClient) > RECTWIDTH(rcWizardPage))
            iLeft = (RECTWIDTH(m_rcClient) - RECTWIDTH(rcWizardPage)) / 2;
        else            
            iLeft = 0;
    }    
   
    MoveWindow(gpWizardState->cmnStateData.hWndWizardPages,
               iLeft,
               iTop, 
               RECTWIDTH(rcWizardPage),
               RECTHEIGHT(rcWizardPage),
               TRUE);

    ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_SHOW);
    return TRUE;
}

void CICWApp::DisplayHTML( void )
{
    if (m_hbmFirstPageBkgrnd)
        gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(m_hbmFirstPageBkgrnd, &m_rcHTML);
    else
        gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &m_rcHTML);
        
    gpWizardState->pICWWebView->ConnectToWindow(m_hwndHTML, PAGETYPE_BRANDED);

    gpWizardState->pICWWebView->DisplayHTML(m_szOEMHTML);
    

    // We are currently displaying the OEM HTML page
    m_bOnHTMLIntro = TRUE;
}

BOOL CICWApp::InitAppHTMLWindows
( 
    HWND hWnd 
) 
{ 
    // Co-Create the browser object
    if (FAILED(CoCreateInstance(CLSID_ICWWEBVIEW,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWebView,
                              (LPVOID *)&gpWizardState->pICWWebView)))
    {
        return FALSE;
    }

    m_hwndHTML = CreateWindow(TEXT("WebOC"), 
                                    NULL, 
                                    WS_VISIBLE | WS_CHILD, 
                                    m_rcHTML.left,
                                    m_rcHTML.top,
                                    RECTWIDTH(m_rcHTML),
                                    RECTHEIGHT(m_rcHTML),
                                    hWnd, 
                                    NULL, 
                                    g_hInstance, 
                                    NULL); 

    ASSERT(gpWizardState->pICWWebView);            
    
    DisplayHTML();
    return TRUE; 
}

// compute that height of the button area. 
// The button area height will be the height of the largest button plus
// a border (15 pixels above and below.)
// Additionally, the overall client height - the button area must be <= 354 pixels
// which is the area required for the wizard pages in large font mode.
// We can loose the border if necessary, but we will fail if 
// client height - max button is < 354.  In this case this function will return -1
int CICWApp::GetButtonAreaHeight
(
    void
)
{
    RECT    rcBtn;
    int     iWizHeight;
    
    m_iBtnAreaHeight = 0;

    // Go Through each button
    m_BtnBack.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);

    m_BtnNext.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    m_BtnCancel.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);

    m_BtnFinish.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    m_BtnTutorial.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    // See if there is enough room for the buttons.
    iWizHeight = RECTHEIGHT(m_rcClient) - m_iBtnAreaHeight;
    if ( iWizHeight < m_wMinWizardHeight)
        return -1;
            
    // Compute the border height.            
    m_iBtnBorderHeight = iWizHeight - m_wMinWizardHeight;
    if (m_iBtnBorderHeight > MAX_BORDER_HEIGHT)
        m_iBtnBorderHeight = MAX_BORDER_HEIGHT;
                    
    // Add the border height to the ret value                    
    m_iBtnAreaHeight += m_iBtnBorderHeight;
    return (m_iBtnAreaHeight);    
}    

BOOL CICWApp::InitAppButtons
(
    HWND    hWnd
)
{
    int     iTopOfButtons;
    TCHAR   szButtonText[MAX_BUTTON_TITLE];

    iTopOfButtons = RECTHEIGHT(m_rcClient) - GetButtonAreaHeight();
    iTopOfButtons += m_iBtnBorderHeight/2;
        
    // Setup the Back button
    LoadString(g_hInstance, IDS_BACK, szButtonText, MAX_BUTTON_TITLE);
    m_BtnBack.SetButtonText(szButtonText);
    m_BtnBack.SetYPos(iTopOfButtons);
    m_BtnBack.CreateButtonWindow(hWnd, IDC_BACK);

    // Setup the Next button
    LoadString(g_hInstance, IDS_NEXT, szButtonText, MAX_BUTTON_TITLE);
    m_BtnNext.SetButtonText(szButtonText);
    m_BtnNext.SetYPos(iTopOfButtons);
    m_BtnNext.CreateButtonWindow(hWnd, IDC_NEXT);

    // Setup the Cancel button
    LoadString(g_hInstance, IDS_CANCEL, szButtonText, MAX_BUTTON_TITLE);
    m_BtnCancel.SetButtonText(szButtonText);
    m_BtnCancel.SetYPos(iTopOfButtons);
    m_BtnCancel.CreateButtonWindow(hWnd, IDC_CANCEL);

    // Setup the Finish button
    LoadString(g_hInstance, IDS_FINISH, szButtonText, MAX_BUTTON_TITLE);
    m_BtnFinish.SetButtonText(szButtonText);
    m_BtnFinish.SetYPos(iTopOfButtons);
    m_BtnFinish.CreateButtonWindow(hWnd, IDC_FINISH);
    m_BtnFinish.Show(SW_HIDE);
    m_BtnFinish.Enable(FALSE);

    // Setup the Tutorial button
    LoadString(g_hInstance, IDS_TUTORIAL, szButtonText, MAX_BUTTON_TITLE);
    m_BtnTutorial.SetButtonText(szButtonText);
    m_BtnTutorial.SetYPos(iTopOfButtons);
    m_BtnTutorial.CreateButtonWindow(hWnd, IDC_TUTORIAL);

    // Disable the back button by default, since we are initially on the first
    // page
    m_BtnBack.Enable(FALSE);

    return TRUE;
}    

void CICWApp::SetWizButtons
(
    HWND hDlg, 
    LPARAM lParam
)
{
    BOOL    bEnabled;

    bEnabled = (lParam & PSWIZB_BACK) != 0;
    m_BtnBack.Enable(bEnabled);

    // Enable/Disable the IDD_NEXT button, and Next gets shown by default
    // bEnabled remembers whether hwndShow should be enabled or not
    bEnabled = (lParam & PSWIZB_NEXT) != 0;
    m_BtnNext.Show(SW_SHOW);
    m_BtnNext.Enable(bEnabled);
    
    // Hide/Disable Finish (this is the default case, and can be overridden below)
    m_BtnFinish.Show(SW_HIDE);
    m_BtnFinish.Enable(FALSE);
    

    // Enable/Disable Show/Hide the IDD_FINISH button
    if (lParam & (PSWIZB_FINISH | PSWIZB_DISABLEDFINISH)) 
    {
        bEnabled = (lParam & PSWIZB_FINISH) != 0;
        m_BtnFinish.Show(SW_SHOW);
        m_BtnFinish.Enable(bEnabled);
        
        m_BtnNext.Show(SW_HIDE);
        m_BtnNext.Enable(FALSE);
    }
}

BOOL CICWApp::CheckButtonFocus
(
    void 
)
{
    int                 i;
    HWND                hwndFocus = GetFocus();
    BOOL                bRet = FALSE;
    const CICWButton    *Btnids[5] = { &m_BtnBack, 
                                        &m_BtnNext, 
                                        &m_BtnFinish, 
                                        &m_BtnCancel,
                                        &m_BtnTutorial };

    for (i = 0; i < ARRAYSIZE(Btnids); i++) 
    {
        if (hwndFocus == Btnids[i]->m_hWndButton)
        {
            bRet = TRUE;
            break;
        }
    }
    return bRet;                    
}

// Determine if any of the ICW buttons have focus, and cycle focus through
// appropriatly.
BOOL CICWApp::CycleButtonFocus
(
    BOOL    bForward
)
{
    int                 i, x;
    HWND                hwndFocus = GetFocus();
    BOOL                bFocusSet = FALSE;
    BOOL                bWrapped = FALSE;
    const CICWButton    *Btnids[5] = { &m_BtnBack, 
                                        &m_BtnNext, 
                                        &m_BtnFinish, 
                                        &m_BtnCancel,
                                        &m_BtnTutorial };


    for (i = 0; i < ARRAYSIZE(Btnids); i++) 
    {
        if (hwndFocus == Btnids[i]->m_hWndButton)
        {
            // Find the next button that can take focus starting with
            // the next button in the list
            if (bForward)
            {
                for (x = i + 1; x < ARRAYSIZE(Btnids); x++)
                {
                    if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                        IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                    {
                        SetFocus(Btnids[x]->m_hWndButton);
                        bFocusSet = TRUE;
                        break;
                    }
                } 
                
                if (!bFocusSet)
                {
                    // Wrap around to the the beginning of the button order
                    bWrapped = TRUE;
                    
                    for (x = 0; x < i; x++)
                    {
                        if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                            IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                        {
                            bFocusSet = TRUE;
                            SetFocus(Btnids[x]->m_hWndButton);
                            break;
                        }
                    }                
                }                
            }
            else
            {
                for (x = i - 1; x >= 0; x--)
                {
                    if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                        IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                    {
                        SetFocus(Btnids[x]->m_hWndButton);
                        bFocusSet = TRUE;
                        break;
                    }
                } 
                
                if (!bFocusSet)
                {
                    bWrapped = TRUE;
                    // Wrap around to the the end of the button order
                    for (x = ARRAYSIZE(Btnids) - 1; x > i; x--)
                    {
                        if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                            IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                        {
                            bFocusSet = TRUE;
                            SetFocus(Btnids[x]->m_hWndButton);
                            break;
                        }
                    }                
                }                
            }                
        }
    }  
    
    // If focus is not on the buttons, and was not set, then set it to the first/last
    // button
    if (!bFocusSet)
    {
        if (bForward)
        {
            // Start at the beginning
            for (x = 0; x < ARRAYSIZE(Btnids); x++)
            {
                if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                    IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                {
                    SetFocus(Btnids[x]->m_hWndButton);
                    break;
                }
            }                
        }
        else
        {
            // Start at the beginning
            for (x = ARRAYSIZE(Btnids) - 1; x >= 0; x--)
            {
                if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                    IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                {
                    SetFocus(Btnids[x]->m_hWndButton);
                    break;
                }
            }                
        }            
    }
    
    return bWrapped;
}


BOOL CICWApp::InitWizAppWindow
(
    HWND    hWnd
)
{
    if (!InitAppHTMLWindows(hWnd))
        return FALSE;
    
    if (!InitAppButtons(hWnd))
        return FALSE;
 
    // Setup the window that will display the page titles
    m_hwndTitle = CreateWindow(g_szICWStatic, 
                               NULL, 
                               WS_VISIBLE | WS_CHILD, 
                               m_rcTitle.left,
                               m_rcTitle.top,
                               RECTWIDTH(m_rcTitle),
                               RECTHEIGHT(m_rcTitle),
                               hWnd, 
                               NULL, 
                               g_hInstance, 
                               NULL); 
        
    if (NULL == m_hwndTitle)
        return FALSE;
    
    SendMessage(m_hwndTitle, WM_SETFONT, (WPARAM)m_hTitleFont, 0l);    
    ShowWindow(m_hwndTitle, SW_HIDE);        
        
    return TRUE;
}

HWND GetControl
(
    int     iCtlId
)
{
    HWND    hWndCtrl = NULL;
    
    // We should never call GetControl unless we translate a wizard page accelerator
    // which implies that hWndWizardPages must be set
    Assert(gpWizardState->cmnStateData.hWndWizardPages);
    
    HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    hWndCtrl = GetDlgItem(hWndPage, iCtlId);
       
    // If the control exist, but is not visible, or not enabled, then return NULL
    if (hWndCtrl &&
        (!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_VISIBLE) ||
         !IsWindowEnabled(hWndCtrl))) 
    {
        hWndCtrl = NULL;
    }
    return hWndCtrl;
}

#define MAX_CHILDREN        100         // Reasonable number of children to search
HWND GetNestedControl
(
    int     iCtlId
)
{
    HWND    hWndCtrl = NULL;
    WORD    wCnt = 0;
    
    // We should never call GetControl unless we translate a wizard page accelerator
    // which implies that hWndWizardPages must be set
    Assert(gpWizardState->cmnStateData.hWndWizardPages);
    
    HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    HWND    hWndNested = GetWindow(hWndPage, GW_CHILD);

    // Search for the child window of the current page that contains the
    // dialog controls    
    do
    {
        wCnt++;             // Prevent infinite looping.
        if (NULL != (hWndCtrl = GetDlgItem(hWndNested, iCtlId)))
            break;          // Found it!!!
            
    }while ((wCnt < MAX_CHILDREN) && 
            (NULL != (hWndNested = GetWindow(hWndNested, GW_HWNDNEXT))));            
       
    // If the control exist, but is not visible, or not enabled, then return NULL
    if (hWndCtrl &&
        (!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_VISIBLE) ||
         !IsWindowEnabled(hWndCtrl))) 
    {
        hWndCtrl = NULL;
    }
    return hWndCtrl;
}

LRESULT CALLBACK CICWApp::ICWAppWndProc
( 
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    LPCREATESTRUCT  lpcs;
    LRESULT         lRet = 0l;
    CICWApp         *pICWApp = (CICWApp *)GetWindowLongPtr(hWnd, GWLP_USERDATA);        
    HICON           hIcon;
        
    switch (uMessage)
    {
        case WM_CREATE:
            lpcs = (LPCREATESTRUCT) lParam;

            // Get the Class instance pointer for this window
            pICWApp = (CICWApp *) lpcs->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pICWApp);           
            
            if (!pICWApp->InitWizAppWindow(hWnd))
                lRet = -1;

            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICWCONN1_ICON));
            SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
            break;

        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
        {
            // See if the control is an ES_READONLY style edit box, and if
            // so then don't make it transparent
            if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
            {
                HDC hdc = (HDC)wParam;
                
                // If this is the animation control, then set the color to the
                // animation control solid color
                if (ID_BUSY_ANIMATION_WINDOW == GetWindowLong((HWND)lParam, GWL_ID))
                {
                    SetBkColor(hdc, pICWApp->m_clrBusyBkGnd); 
                }
                                    
                SetBkMode(hdc, TRANSPARENT);
                lRet = (LRESULT) GetStockObject(NULL_BRUSH);    
                
                // If this is the Title control, set the color
                if ( pICWApp->m_hwndTitle == (HWND)lParam)
                {
                    SetTextColor(hdc, pICWApp->m_clrTitleFont);
                }
            }                
            break;
        }
        
        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT    lpdis = (LPDRAWITEMSTRUCT)lParam;
            CICWButton          *pBtn;
            POINT               pt;            
            
            pt.x = lpdis->rcItem.left;
            pt.y = lpdis->rcItem.top;
            
            switch (wParam)
            {
                case IDC_BACK:
                    pBtn = &pICWApp->m_BtnBack;
                    break;
                    
                case IDC_NEXT:
                    pBtn = &pICWApp->m_BtnNext;
                    break;
                
                case IDC_FINISH:
                    pBtn = &pICWApp->m_BtnFinish;
                    break;
                    
                case IDC_CANCEL:
                    pBtn = &pICWApp->m_BtnCancel;
                    break;
                    
                case IDC_TUTORIAL:
                    pBtn = &pICWApp->m_BtnTutorial;
                    break;
                    
            }    
            pBtn->DrawButton(lpdis->hDC,    
                             lpdis->itemState,
                             &pt);
            
            break;
        }   
        
        case WM_ERASEBKGND: 
        {
            // Fill in the App Window's update rect with the background bitmap
            FillWindowWithAppBackground(hWnd, (HDC)wParam);
            lRet  = 1L;
            break;
        }          

        case WM_CLOSE:
        {
            if (MsgBox(hWnd,IDS_QUERYCANCEL,
                       MB_ICONQUESTION,MB_YESNO |
                       MB_DEFBUTTON2) == IDYES)
            {
                DestroyWindow(hWnd);
            }   
            break;
        }
        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        // Set the wizard page title
        case WUM_SETTITLE:
        {
            TCHAR   szTitle[MAX_RES_LEN];
            
            if (wParam)
            {
                LoadString((HINSTANCE)wParam, LOWORD(lParam), szTitle, MAX_RES_LEN);
                SetWindowText(pICWApp->m_hwndTitle, szTitle);        
            }                
            else
            {
                SetWindowText(pICWApp->m_hwndTitle, (LPTSTR)lParam);        
            }
            break;
        }        
        
        case WM_COMMAND:
        {
            int     iCtlId = GET_WM_COMMAND_ID(wParam, lParam);
            HWND    hWndCtrl;
            
            switch (iCtlId)
            {
                case IDC_BACK:
                    if ((GetWindowLong(pICWApp->m_BtnBack.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnBack.m_hWndButton)) 
                    {
                        if (pICWApp->m_hWndFirstWizardPage == PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages))
                        {
                            // Hide the wizard pages
                            ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_HIDE);
                            ShowWindow(pICWApp->m_hwndTitle, SW_HIDE);
                            
                            // Show and re-display the HTML page
                            pICWApp->DisplayHTML();
                            ShowWindow(pICWApp->m_hwndHTML, SW_SHOW);
                            pICWApp->m_bOnHTMLIntro = TRUE;
                            
                            // Show the tutorial button
                            pICWApp->m_BtnTutorial.Show(SW_SHOW);
                            pICWApp->m_BtnTutorial.Enable(TRUE);
                            
                            
                            // Disable the Back button
                            pICWApp->m_BtnBack.Enable(FALSE);
                        }
                        else
                        {
                            // Go to the previous page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_BACK);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                
                case IDC_NEXT:
                    if ((GetWindowLong(pICWApp->m_BtnNext.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnNext.m_hWndButton)) 
                    {
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            // Hide the HTML window
                            ShowWindow(pICWApp->m_hwndHTML, SW_HIDE);
                            pICWApp->m_bOnHTMLIntro = FALSE;
                            
                            // Hide the tutorial button
                            pICWApp->m_BtnTutorial.Show(SW_HIDE);
                            pICWApp->m_BtnTutorial.Enable(FALSE);
                            
                            // Show the Title window
                            ShowWindow(pICWApp->m_hwndTitle, SW_SHOW);
                            // Create and Show, or just show the Wizard pages
                            if (!gpWizardState->cmnStateData.hWndWizardPages)
                                pICWApp->CreateWizardPages(hWnd);
                            else
                                ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_SHOW);
                                
                            // Enable the Back button
                            pICWApp->m_BtnBack.Enable(TRUE);
                            
                        }                        
                        else
                        {
                            // Go to the Next page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_NEXT);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                     
                case IDC_FINISH:
                    if ((GetWindowLong(pICWApp->m_BtnFinish.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnFinish.m_hWndButton)) 
                    {                         
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            DestroyWindow(hWnd);
                        }
                        else
                        {
                            // Go to the Next page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_FINISH);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                     
                
                case IDC_CANCEL:
                    if ((GetWindowLong(pICWApp->m_BtnCancel.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnCancel.m_hWndButton)) 
                    {                         
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            if (MsgBox(hWnd,IDS_QUERYCANCEL,
                                               MB_ICONQUESTION,MB_YESNO |
                                               MB_DEFBUTTON2) == IDYES)
                            {
                                DestroyWindow(hWnd);
                            }                                           
                        }                                           
                        else
                        {
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_CANCEL);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                    
#ifndef ICWDEBUG
                case IDC_TUTORIAL:
                {
                    // If the Tutorial button is enabled/Visible then run
                    // the tutorial
                    if ((GetWindowLong(pICWApp->m_BtnTutorial.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnTutorial.m_hWndButton)) 
                    {                                        
                        g_pICWTutorApp->LaunchTutorApp();
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                }                    
#endif
                                    
                case ID_NEXT_FIELD:
                {
                    if (pICWApp->m_bOnHTMLIntro)
                    {
                        pICWApp->CycleButtonFocus(TRUE);
                    }
                    else
                    {                        
                        HWND    hWndFocus = GetFocus();
                        HWND    hWndTabItem;
                        HWND    hWndFirstTabItem;
                        HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
                        BOOL    bButtonsHaveFocus = pICWApp->CheckButtonFocus();
                        
                        hWndFirstTabItem = GetNextDlgTabItem(hWndPage, 
                                                        NULL, 
                                                        FALSE);
                                                 
                        // If we are on the last item in the tab order, cycle
                        // focus to the buttons
                        hWndTabItem = GetNextDlgTabItem(hWndPage, hWndFirstTabItem, TRUE);
                        if ((hWndFocus == hWndTabItem) ||
                            IsChild(hWndTabItem, hWndFocus))
                        {
                            pICWApp->CycleButtonFocus(TRUE);
                        }
                        else
                        {
                            
                            if (bButtonsHaveFocus)
                            {
                                // Cycle the button focus. If the focus
                                // wraps, this function will fail
                                if (pICWApp->CycleButtonFocus(TRUE))
                                {
                                    // Set focus to the First item in the tab order
                                    SetFocus(hWndFirstTabItem);
                                }
                            }
                            else
                            {
                                // Set focus to the next item in the tab order
                                SetFocus(GetNextDlgTabItem(hWndPage,
                                                           hWndFocus, 
                                                           FALSE));
                            }
                        }                            
                    }                        
                    break;
                }    
                case ID_PREV_FIELD:                                                        
                    if (pICWApp->m_bOnHTMLIntro)
                    {
                        pICWApp->CycleButtonFocus(FALSE);
                    }
                    else
                    {                        
                        HWND    hWndFocus = GetFocus();
                        HWND    hWndFirstTabItem;
                        HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
                        BOOL    bButtonsHaveFocus = pICWApp->CheckButtonFocus();
                        
                        hWndFirstTabItem = GetNextDlgTabItem(hWndPage, 
                                                        NULL, 
                                                        FALSE);
                                                 
                        // If we are on the first item in the tab order, cycle
                        // focus to the buttons
                        if ((hWndFocus == hWndFirstTabItem) ||
                            IsChild(hWndFirstTabItem, hWndFocus))
                        {
                            pICWApp->CycleButtonFocus(FALSE);
                        }
                        else
                        {
                            
                            if (bButtonsHaveFocus)
                            {
                                // Cycle the button focus. If the focus
                                // wraps, this function will fail
                                if (pICWApp->CycleButtonFocus(FALSE))
                                {
                                    // Set focus to the last item in the tab order
                                    SetFocus(GetNextDlgTabItem(hWndPage, hWndFirstTabItem, TRUE));
                                }
                            }
                            else
                            {
                                // Set focus to the prev item in the tab order
                                SetFocus(GetNextDlgTabItem(hWndPage,
                                                           hWndFocus, 
                                                           TRUE));
                            }
                        }                            
                    }                        
                    break;
                
                
                // Radio button group
                case IDC_RUNNEW:
                case IDC_RUNAUTO:
                case IDC_ICWMAN:
                {
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        CheckRadioButton(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), 
                                         IDC_RUNNEW, 
                                         IDC_ICWMAN, 
                                         iCtlId);
                        SetFocus(hWndCtrl);
                    }
                    else
                    {
                        MessageBeep(0);
                    }        
                    break;
                }
                
                // Check box. Needs to be toggled
                case IDC_CHECK_BROWSING:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        // Toggle the button check state
                        if (BST_CHECKED == Button_GetCheck(hWndCtrl))
                            Button_SetCheck(hWndCtrl, BST_UNCHECKED);
                        else
                            Button_SetCheck(hWndCtrl, BST_CHECKED);
                            
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                                            
                // Pushbutton type controls
                case IDC_OEMOFFER_MORE:
                case IDC_DIALERR_PROPERTIES:
                case IDC_ISPDATA_TOSSAVE:
                case IDC_CHANGE_NUMBER:
                case IDC_DIALING_PROPERTIES:
                case IDC_DIAL_HELP:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        HWND    hWndFocus = GetFocus();
                        SendMessage(hWndCtrl, BM_CLICK, 0, 0l);
                        SetFocus(hWndFocus);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Edit Text and drop down controls. Need to be selected and focused
                case IDC_DIAL_FROM:
                case IDC_DIALERR_PHONENUMBER:
                case IDC_DIALERR_MODEM:
                case IDC_BILLINGOPT_HTML:
                case IDC_PAYMENTTYPE:
                case IDC_ISPMARKETING:
                case IDC_ISPLIST:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        Edit_SetSel(hWndCtrl, 0, -1);
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Nested controls
                case IDC_USERINFO_FIRSTNAME:
                case IDC_USERINFO_LASTNAME:
                case IDC_USERINFO_COMPANYNAME:
                case IDC_USERINFO_ADDRESS1:
                case IDC_USERINFO_ADDRESS2:
                case IDC_USERINFO_CITY:
                case IDC_USERINFO_STATE:
                case IDC_USERINFO_ZIP:
                case IDC_USERINFO_PHONE:
                case IDC_USERINFO_FE_NAME:
                case IDC_PAYMENT_CCNUMBER:
                case IDC_PAYMENT_EXPIREMONTH:
                case IDC_PAYMENT_EXPIREYEAR:
                case IDC_PAYMENT_CCNAME:
                case IDC_PAYMENT_CCADDRESS:
                case IDC_PAYMENT_CCZIP:
                case IDC_PAYMENT_IVADDRESS1:
                case IDC_PAYMENT_IVADDRESS2:
                case IDC_PAYMENT_IVCITY:
                case IDC_PAYMENT_IVSTATE:
                case IDC_PAYMENT_IVZIP:
                case IDC_PAYMENT_PHONEIV_BILLNAME:
                case IDC_PAYMENT_PHONEIV_ACCNUM:
                    if (NULL != (hWndCtrl = GetNestedControl(iCtlId)))
                    {
                        Edit_SetSel(hWndCtrl, 0, -1);
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Radio button select group    
                case IDC_ISPDATA_TOSACCEPT:
                case IDC_ISPDATA_TOSDECLINE:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        CheckRadioButton(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), 
                                         IDC_ISPDATA_TOSACCEPT, 
                                         IDC_ISPDATA_TOSDECLINE, 
                                         iCtlId);
                        // simulate a button click, so the right WM_COMMAND
                        // gets to the isppage proc                                         
                        SendMessage(hWndCtrl, BM_CLICK, 0, 0l);
                        SetFocus(hWndCtrl);
                    }
                    else
                    {
                        MessageBeep(0);
                    }        
                    break;
                
                default:
                    break;
            
            }
            lRet = 1L;
            break;
        }                   // WM_COMMAND
        
        default:
            return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }
    return lRet;
}

void  CICWApp::CenterWindow
(
    void
) 
{    
    RECT  rcScreen;                         // Screen rect    
    RECT  rcApp;                            // window rect    
    int   nLeft, nTop;                      // Top-left coordinates    
    
    // Get frame window client rect in screen coordinates    
    rcScreen.top = rcScreen.left = 0;       
    rcScreen.right = GetSystemMetrics(SM_CXFULLSCREEN);       
    rcScreen.bottom = GetSystemMetrics(SM_CYFULLSCREEN);    
    
    // Determine the top-left point for the window to be centered    
    GetWindowRect(m_hWndApp, &rcApp);    
    nLeft   = rcScreen.left + ((RECTWIDTH(rcScreen) - RECTWIDTH(rcApp)) / 2);    
    nTop    = rcScreen.top  + ((RECTHEIGHT(rcScreen) - RECTHEIGHT(rcApp)) / 2);    
    if (nLeft < 0) 
        nLeft = 0;    
    if (nTop  < 0) 
        nTop  = 0;     
    
    // Place the dialog    
    MoveWindow(m_hWndApp, nLeft, nTop, RECTWIDTH(rcApp), RECTHEIGHT(rcApp), TRUE);
    return;
}    

HRESULT CICWApp::Initialize
(
    void
)
{   
    HRESULT hr = S_OK;
         
    // Create the Application Window
    WNDCLASSEX  wc; 
    
    //Register the Application window class
    ZeroMemory (&wc, sizeof(WNDCLASSEX));
    wc.style         = CS_GLOBALCLASS;
    wc.cbSize        = sizeof(wc);
    wc.lpszClassName = TEXT("ICWApp");
    wc.hInstance     = g_hInstance;
    wc.lpfnWndProc   = ICWAppWndProc;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;
    RegisterClassEx (&wc);
    
    // Compute the HTML rectangle area based on the OEM customizations
    // that have been previously applied
    m_rcHTML.left = 0;
    m_rcHTML.top = 0;
    m_rcHTML.right = m_rcClient.right;
    m_rcHTML.bottom = m_rcClient.bottom - m_iBtnAreaHeight;
   
    // Load the accelerator table
    m_haccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDA_ACCEL));      
    
    // Create the Application Window
    m_hWndApp = CreateWindow( TEXT("ICWApp"), 
                              m_szAppTitle, 
                              WS_BORDER | WS_CAPTION | WS_SYSMENU, 
                              CW_USEDEFAULT, 
                              CW_USEDEFAULT, 
                              RECTWIDTH(m_rcClient) +
                                2*GetSystemMetrics(SM_CXFIXEDFRAME),
                              RECTHEIGHT(m_rcClient) + 
                                GetSystemMetrics(SM_CYCAPTION) +
                                2*GetSystemMetrics(SM_CYFIXEDFRAME),
                              NULL, 
                              NULL, 
                              g_hInstance, 
                              (LPVOID) this); 
    if (m_hWndApp)
    {
        gpWizardState->cmnStateData.hWndApp = m_hWndApp;
        
        // Center the Window
        CenterWindow();                              
        
        // Show the window and paint its contents. 
        ShowWindow(m_hWndApp, SW_SHOW); 
        UpdateWindow(m_hWndApp); 
    }
    else
    {
        hr = E_FAIL;
    }        
    
    return hr;
}

HRESULT CICWApp::SetBackgroundBitmap
(
    LPTSTR lpszBkgrndBmp
)
{
    BITMAP  bmInfo;
    HRESULT hr = E_FAIL;
        
    // Load the Background Bitmap
    if (NULL != (gpWizardState->cmnStateData.hbmBkgrnd = (HBITMAP)LoadImage(g_hInstance, 
                                                               lpszBkgrndBmp, 
                                                               IMAGE_BITMAP, 
                                                               0, 
                                                               0, 
                                                               LR_LOADFROMFILE)))
    {
        
        GetObject(gpWizardState->cmnStateData.hbmBkgrnd, sizeof(BITMAP), (LPVOID) &bmInfo);
        
        // Compute some usefull Rectangles.
        // The client will be the size of the background bitmap
        m_rcClient.left = 0;
        m_rcClient.top = 0;
        m_rcClient.right = bmInfo.bmWidth;
        m_rcClient.bottom = bmInfo.bmHeight;
        
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CICWApp::SetFirstPageBackgroundBitmap
(
    LPTSTR lpszBkgrndBmp
)
{
    BITMAP  bmInfo;
    HRESULT hr = E_FAIL;
        
    // Load the Background Bitmap
    if (NULL != (m_hbmFirstPageBkgrnd = (HBITMAP)LoadImage(g_hInstance, 
                                                           lpszBkgrndBmp, 
                                                           IMAGE_BITMAP, 
                                                           0, 
                                                           0, 
                                                           LR_LOADFROMFILE)))
    {
        
        GetObject(m_hbmFirstPageBkgrnd, sizeof(BITMAP), (LPVOID) &bmInfo);
        
        // Make sure the bitmap is the same size as the main one
        
        if ((RECTWIDTH(m_rcClient) == bmInfo.bmWidth) &&
            (RECTHEIGHT(m_rcClient) == bmInfo.bmHeight))
        {
            hr = S_OK;
        }            
    }
    return hr;
}

HRESULT CICWApp::SetTitleParams
(
    int iTitleTop,
    int iTitleLeft,
    LPTSTR lpszFontFace,
    long lFontPts,
    long lFontWeight,
    COLORREF clrFont
)
{
    LOGFONT     lfTitle;
    HFONT       hOldFont;
    TEXTMETRIC  tm;
    HDC         hdc;
        
    // Fill in the log font for the title
    lfTitle.lfHeight = -MulDiv(lFontPts, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
    lfTitle.lfWidth = 0; 
    lfTitle.lfEscapement = 0; 
    lfTitle.lfOrientation = 0; 
    lfTitle.lfWeight = lFontWeight; 
    lfTitle.lfItalic = FALSE; 
    lfTitle.lfUnderline = FALSE; 
    lfTitle.lfStrikeOut = FALSE; 
    lfTitle.lfCharSet = DEFAULT_CHARSET; 
    lfTitle.lfOutPrecision = OUT_DEFAULT_PRECIS; 
    lfTitle.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
    lfTitle.lfQuality = DEFAULT_QUALITY; 
    lfTitle.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE; 
    lstrcpy(lfTitle.lfFaceName, lpszFontFace); 
    
    if (NULL == (m_hTitleFont = CreateFontIndirect(&lfTitle)))
        return E_FAIL;
    
    // Compute the area for the title
    if (-1 != iTitleTop)
        m_rcTitle.top = iTitleTop;
    else
        m_rcTitle.top = DEFAULT_TITLE_TOP;

    if (-1 != iTitleLeft)
        m_rcTitle.left = iTitleLeft;
    else
        m_rcTitle.left = DEFAULT_TITLE_LEFT;
    // The right side will be the width of the client, minus the left border        
    m_rcTitle.right = RECTWIDTH(m_rcClient) - m_rcTitle.left;
    
    // The bottom will be the top plus the char height for the font
    if (NULL != (hdc = GetDC(NULL)))
    {
        hOldFont = (HFONT)SelectObject(hdc, m_hTitleFont);
        GetTextMetrics(hdc, &tm);
        SelectObject(hdc, hOldFont);
        ReleaseDC(NULL, hdc);
    }
    else
    {
        return E_FAIL;        
    }
    m_rcTitle.bottom = m_rcTitle.top + tm.tmHeight;
    
    
    // Set the font color
    m_clrTitleFont = clrFont;
    
    return S_OK;
    
}

HRESULT CICWApp::SetWizardWindowTop
(
    int iTop
)
{
    m_iWizardTop = iTop;

    // If default positioning is not selected, then ensure the ICW wizard
    // page will fit
    if (-1 != iTop)    
    {
        if ((m_iWizardTop +  m_wMinWizardHeight) > (RECTHEIGHT(m_rcClient) - m_iBtnAreaHeight))
            return E_FAIL;
    }
    return S_OK;
}

HRESULT CICWApp::SetWizardWindowLeft
(
    int iLeft
)
{
    m_iWizardLeft = iLeft;
    if (-1 != iLeft)    
    {
        if ((iLeft +  m_wMinWizardWidth) > RECTWIDTH(m_rcClient))
            return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\areacode.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  AREACODE.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************


#include "pre.h"
#include "icwextsn.h"

long lLastLocationID = -1;

void CleanupCombo(HWND hDlg)
{
    HWND hCombo = GetDlgItem(hDlg, IDC_DIAL_FROM);
    for (int i=0; i < ComboBox_GetCount(hCombo); i++)
    {
        DWORD *pdwTemp = (DWORD*)ComboBox_GetItemData(hCombo, i);
        if (pdwTemp)
            delete pdwTemp;
    }
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIAL_FROM));
}

/*******************************************************************

  NAME:    AreaCodeInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK AreaCodeInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {   
        short   wNumLocations;
        long    lCurrLocIndex;
        DWORD   dwCountryCode;
        TCHAR   szTemp[MAX_MESSAGE_LEN];
        BOOL    bRetVal;

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
            LoadString(g_hInstance, IDS_MANUALOPTS_TITLE, szTemp, MAX_MESSAGE_LEN);
        else
            LoadString(g_hInstance, IDS_STEP1_TITLE, szTemp, MAX_MESSAGE_LEN);

        PropSheet_SetHeaderTitle(GetParent(hDlg), ORD_PAGE_AREACODE, (LPCSTR)szTemp);

        // We can skip the page if we have already downloaded
        gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
        gpWizardState->pTapiLocationInfo->get_wNumberOfLocations(&wNumLocations, &lCurrLocIndex);
        
        // Ensure that we only have only 1 location and we never shwon the areacode page
        // Second part of this check is for case where user had more than 1 location and deleted
        // down to one location.  That case, our history told us to come to areacode page but 
        // since wNumLocations == 1, we would go back to refdial page.
        if ((1 == wNumLocations) && (-1 == lLastLocationID))
        {
            // We are happy, so advance to the next page
            BSTR    bstrAreaCode = NULL;

            *puNextPage = ORD_PAGE_REFSERVDIAL;
            
            gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
            gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
            
            gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
            lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
            SysFreeString(bstrAreaCode);
        }
        else
        {
            // We need to have the user enter the area code
            if (wNumLocations)
            {
                int iIndex = 0;
                CleanupCombo(hDlg);
                for (long lIndex=0; lIndex < (long)wNumLocations; lIndex++)
                {
                    BSTR bstr = NULL;
                    if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationName(lIndex, &bstr))
                    {
                       iIndex = ComboBox_InsertString(GetDlgItem(hDlg, IDC_DIAL_FROM), lIndex, W2A(bstr));
                    }
                    SysFreeString(bstr);
                }

                BSTR bstrCountry = NULL;
                BSTR bstrAreaCode = NULL;
                long lCountryCode = 0;
                ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_DIAL_FROM), lCurrLocIndex );
                if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationInfo(lCurrLocIndex, &gpWizardState->lLocationID, &bstrCountry, &lCountryCode, &bstrAreaCode))
                {
                    if (gpWizardState->lLocationID != lLastLocationID)
                    {
                        gpWizardState->bDoneRefServDownload = FALSE;
                    }
                    if (-1 == gpWizardState->lDefaultLocationID)
                    {
                        gpWizardState->lDefaultLocationID = gpWizardState->lLocationID;
                    }
                    lLastLocationID = gpWizardState->lLocationID;
                    gpWizardState->cmnStateData.dwCountryCode = (DWORD) lCountryCode;
                    SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), W2A(bstrAreaCode));
                    SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), W2A(bstrCountry));
                }

                SysFreeString(bstrCountry);
                SysFreeString(bstrAreaCode);
             
            }
        }
    }
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_AREACODE;
    
    return TRUE;
}

/*******************************************************************

  NAME:    AreaCodeOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK AreaCodeOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    // Extract the data entered by the user and save it.
    if (fForward)
    {
        //BUGBUG - if we are in auto config, we need to change the title of the next page
        GetWindowText(GetDlgItem(hDlg, IDC_AREACODE), gpWizardState->cmnStateData.szAreaCode, MAX_AREA_CODE);
        gpWizardState->pTapiLocationInfo->put_LocationId(gpWizardState->lLocationID);
        if (gpWizardState->lLocationID != lLastLocationID)
        {
            lLastLocationID = gpWizardState->lLocationID;
            gpWizardState->bDoneRefServDownload = FALSE;
        }
    }

    return TRUE;
}

/*******************************************************************

  NAME:    AreaCodeCmdProc

********************************************************************/
BOOL CALLBACK AreaCodeCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
            
    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_DIAL_FROM:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
            {
                // Get the currently selected item
                HWND        hWndDialFrom    = GetDlgItem(hDlg, IDC_DIAL_FROM);
                int         iIndex          = ComboBox_GetCurSel( hWndDialFrom );

                BSTR bstrCountry = NULL;
                BSTR bstrAreaCode = NULL;
                long lCountryCode = 0;

                if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationInfo( iIndex, 
                                                                                &gpWizardState->lLocationID,
                                                                                &bstrCountry, 
                                                                                &lCountryCode, 
                                                                                &bstrAreaCode))
                {
                    gpWizardState->cmnStateData.dwCountryCode = lCountryCode;
                    if (bstrAreaCode)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), W2A(bstrAreaCode));
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), NULL);
                    }
                    if (bstrCountry)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), W2A(bstrCountry));
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), NULL);
                    }
                }
            }
            break;
        }
        default:
            break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\branded.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  BRANDED.C - Functions for OEM/ISP branded first Wizard pages
//

//  HISTORY:
//  
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include "webvwids.h"           // Needed to create an instance of the ICW WebView object

extern UINT GetDlgIDFromIndex(UINT uPageIndex);

// This function is in intro.cpp
BOOL WINAPI ConfigureSystem(HWND hDlg);

/*******************************************************************

  NAME:    BrandedIntroInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK BrandedIntroInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is the very first page, so no back is needed
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);

    if (!fFirstInit)
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_BRANDEDINTRO;
    }
        
    return TRUE;
}

BOOL CALLBACK BrandedIntroPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;

    if (fFirstInit)
    {
        BOOL bFail = FALSE;
    
        // For the window to paint itself
        UpdateWindow(GetParent(hDlg));
    
        // Co-Create the browser object
        if (FAILED(CoCreateInstance(CLSID_ICWWEBVIEW,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWebView,
                              (LPVOID *)&gpWizardState->pICWWebView)))
        {
            bFail = TRUE;
        }

        // Co-Create the browser object
        if(FAILED(CoCreateInstance(CLSID_ICWWALKER,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWalker,
                              (LPVOID *)&gpWizardState->pHTMLWalker)))
        {
            bFail = TRUE;
        }
        
        if (bFail)
        {
            MsgBox(NULL,IDS_LOADLIB_FAIL,MB_ICONEXCLAMATION,MB_OK);
            bRet = FALSE;
            gfQuitWizard = TRUE;            // Quit the wizard
        }                       
    }
    else
    {
        TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
        
        ASSERT(gpWizardState->pICWWebView);            
        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_BRANDEDWEBVIEW), PAGETYPE_BRANDED);

        // Form the URL
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedHTML);        

        gpWizardState->pICWWebView->DisplayHTML(szURL);
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    return bRet;
}

BOOL CALLBACK BrandedIntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        //Are we in some special branding mode?
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            TCHAR         szTemp[MAX_PATH]   = TEXT("\0");
            IWebBrowser2* pIWebBrowser2      = NULL;

            gpWizardState->pICWWebView->get_BrowserObject(&pIWebBrowser2);
            
            ASSERT(pIWebBrowser2);

            gpWizardState->pHTMLWalker->AttachToDocument(pIWebBrowser2);
            gpWizardState->pHTMLWalker->get_IeakIspFile(szTemp);

            if(lstrlen(szTemp) != 0)
            {                
                TCHAR szDrive [_MAX_DRIVE]    = TEXT("\0");
                TCHAR szDir   [_MAX_DIR]      = TEXT("\0");
                _tsplitpath(gpWizardState->cmnStateData.ispInfo.szISPFile, szDrive, szDir, NULL, NULL);
                _tmakepath (gpWizardState->cmnStateData.ispInfo.szISPFile, szDrive, szDir, szTemp, NULL);   
            }
          
            //OK make sure we don't try and download something, JIC.
            gpWizardState->bDoneRefServDownload  = TRUE;
            gpWizardState->bDoneRefServRAS       = TRUE;
            gpWizardState->bStartRefServDownload = TRUE;
            
            // BUGBUG, need to set a legit last page, maybe!
            if (LoadICWCONNUI(GetParent(hDlg), 
                              GetDlgIDFromIndex(ORD_PAGE_BRANDEDINTRO), 
                              gpWizardState->cmnStateData.bOEMCustom ? IDD_PAGE_ENDOEMCUSTOM : IDD_PAGE_END,
                              gpWizardState->cmnStateData.dwFlags))
            {
                if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                {
                    // we're about to jump into the external apprentice, and we don't want
                    // this page to show up in our history list, infact, we need to back
                    // the history up 1, because we are going to come back here directly
                    // from the DLL, not from the history list.
                    
                    *pfKeepHistory = FALSE;
                    *puNextPage = g_uICWCONNUIFirst;
                    
                    // Backup 1 in the history list, since we the external pages navigate back
                    // here, we want this history list to be in the correct spot
                    gpWizardState->uPagesCompleted --;
                }
            }
        }
    }   
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\button.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"

// Local private function for drawing transparent bitmaps
static void DrawTransparentBitmap
(
    HDC hdc,                    // Destination DC
    HBITMAP hBitmap,            // The Bitmap to Draw
    long xStart,               // Upper Left starting point
    long yStart,               // Upport Left Starting Point
    COLORREF cTransparentColor
)
{
    BITMAP     bm;
    COLORREF   cColor;
    HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
    HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
    HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT      ptSize;

    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, hBitmap);   // Select the bitmap

    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    ptSize.x = bm.bmWidth;            // Get width of bitmap
    ptSize.y = bm.bmHeight;           // Get height of bitmap
    DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device
                                      // to logical points

    // Create some DCs to hold temporary data.
    hdcBack   = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem    = CreateCompatibleDC(hdc);
    hdcSave   = CreateCompatibleDC(hdc);

    // Create a bitmap for each DC. DCs are required for a number of
    // GDI functions.

    // Monochrome DC
    bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    // Monochrome DC
    bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);

    // Each DC must select a bitmap object to store pixel data.
    bmBackOld   = (HBITMAP)SelectObject(hdcBack, bmAndBack);
    bmObjectOld = (HBITMAP)SelectObject(hdcObject, bmAndObject);
    bmMemOld    = (HBITMAP)SelectObject(hdcMem, bmAndMem);
    bmSaveOld   = (HBITMAP)SelectObject(hdcSave, bmSave);

    // Set proper mapping mode.
    SetMapMode(hdcTemp, GetMapMode(hdc));

    // Save the bitmap sent here, because it will be overwritten.
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC to the color.
    // contained in the parts of the bitmap that should be transparent
    cColor = SetBkColor(hdcTemp, cTransparentColor);

    // Create the object mask for the bitmap by performing a BitBlt
    // from the source bitmap to a monochrome bitmap.
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC back to the original
    // color.
    SetBkColor(hdcTemp, cColor);

    // Create the inverse of the object mask.
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY);

    // Copy the background of the main DC to the destination.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,
           SRCCOPY);

    // Mask out the places where the bitmap will be placed.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);

    // Mask out the transparent colored pixels on the bitmap.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);

    // XOR the bitmap with the background on the destination DC.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);

    // Copy the destination to the screen.
    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY);

    // Place the original bitmap back into the bitmap sent here.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);

    // Delete the memory bitmaps.
    DeleteObject(SelectObject(hdcBack, bmBackOld));
    DeleteObject(SelectObject(hdcObject, bmObjectOld));
    DeleteObject(SelectObject(hdcMem, bmMemOld));
    DeleteObject(SelectObject(hdcSave, bmSaveOld));

    // Delete the memory DCs.
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}        

CICWButton::CICWButton(void)
{
    m_vAlign = DT_VCENTER;
    m_bDisplayButton = TRUE;
}

CICWButton::~CICWButton( void )
{
    if (m_hbmPressed)
        DeleteObject(m_hbmPressed);

    if (m_hbmUnpressed)        
        DeleteObject(m_hbmUnpressed);
        
    if (m_hfont)
        DeleteObject(m_hfont);
}


HRESULT CICWButton::SetButtonParams
(
    long        xPos,
    LPTSTR      lpszPressedBmp,
    LPTSTR      lpszUnpressedBmp,
    LPTSTR      lpszFontFace,
    long        lFontSize,
    long        lFontWeight,
    COLORREF    clrFontColor,
    COLORREF    clrTransparentColor,
    COLORREF    clrDisabled,
    long        vAlign
)
{
    BITMAP      bmInfo;
    LOGFONT     lfButtonText;

    // Set the Button's xPosition
    m_xPos = xPos;
    
    if (NULL == (m_hbmPressed = (HBITMAP)LoadImage(g_hInstance, 
                                                   lpszPressedBmp, 
                                                   IMAGE_BITMAP, 
                                                   0, 
                                                   0, 
                                                   LR_LOADFROMFILE)))
    {                                                   
        return E_FAIL;
    }        
    if (NULL == (m_hbmUnpressed = (HBITMAP)LoadImage(g_hInstance, 
                                                   lpszUnpressedBmp, 
                                                   IMAGE_BITMAP, 
                                                   0, 
                                                   0, 
                                                   LR_LOADFROMFILE)))
    {                                                   
        return E_FAIL;
    }        
    
    // Set the transparent color
    m_clrTransparent = clrTransparentColor;
    
    // Set the text color
    m_clrText = clrFontColor;

    // Set the Disabled color
    m_clrDisabledText = clrDisabled;
       
    // Set the vertical alignment
    if (-1 != vAlign)
        m_vAlign = vAlign;        
        
    // Fill in the default text log font
    lfButtonText.lfHeight = -lFontSize;
    lfButtonText.lfWidth = 0; 
    lfButtonText.lfEscapement = 0; 
    lfButtonText.lfOrientation = 0; 
    lfButtonText.lfWeight = lFontWeight; 
    lfButtonText.lfItalic = FALSE; 
    lfButtonText.lfUnderline = FALSE; 
    lfButtonText.lfStrikeOut = FALSE; 
    lfButtonText.lfCharSet = DEFAULT_CHARSET; 
    lfButtonText.lfOutPrecision = OUT_DEFAULT_PRECIS; 
    lfButtonText.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
    lfButtonText.lfQuality = DEFAULT_QUALITY; 
    lfButtonText.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE; 
    lstrcpy(lfButtonText.lfFaceName, lpszFontFace); 
    
    // Create the font for drawing the button
    if (NULL == (m_hfont = CreateFontIndirect(&lfButtonText)))
        return E_FAIL;
    
    // Compute the client button area
    if (GetObject(m_hbmUnpressed, sizeof(BITMAP), (LPVOID) &bmInfo))
    {
        m_rcBtnClient.left = 0;
        m_rcBtnClient.top = 0;
        m_rcBtnClient.right = bmInfo.bmWidth;
        m_rcBtnClient.bottom = bmInfo.bmHeight;
        return S_OK;
    }    
    else
    {
        return E_FAIL;
    }
}

HRESULT CICWButton::CreateButtonWindow(HWND hWndParent, UINT uiCtlID)
{
    HRESULT hr = S_OK;
            
    m_hWndButton = CreateWindow( TEXT("Button"), 
                                 NULL, 
                                 BS_OWNERDRAW | WS_VISIBLE | WS_CHILD | WS_TABSTOP, 
                                 m_xPos, 
                                 m_yPos, 
                                 RECTWIDTH(m_rcBtnClient),
                                 RECTHEIGHT(m_rcBtnClient),
                                 hWndParent, 
                                 (HMENU) UlongToPtr(uiCtlID), 
                                 g_hInstance, 
                                 NULL); 
    if (m_hWndButton)
    {   
        ShowWindow(m_hWndButton, m_bDisplayButton ? SW_SHOW : SW_HIDE);
        UpdateWindow(m_hWndButton);                                 
    }
    else
    {
        hr = E_FAIL;
    }        
    return (hr);
}

void CICWButton::DrawButton(HDC hdc, UINT itemState, LPPOINT lppt)
{
    HFONT       hOldFont;
    COLORREF    clrOldColor;
    COLORREF    clrText;
    HBITMAP     hbmUsed;
    DWORD       dwStyle=GetWindowLong(m_hWndButton,GWL_STYLE);
    RECT        rcFocus;
    
    if (itemState & ODS_SELECTED)
        hbmUsed = m_hbmPressed;
    else
        hbmUsed = m_hbmUnpressed;
    
    if (itemState & ODS_DISABLED)
        clrText = m_clrDisabledText;
    else
        clrText = m_clrText;        
    
    DrawTransparentBitmap(hdc,
                          hbmUsed,
                          lppt->x,
                          lppt->y,
                          m_clrTransparent);
    
    hOldFont = (HFONT)SelectObject(hdc, m_hfont);

    clrOldColor = SetTextColor(hdc, clrText);
    
    DrawText(hdc, m_szButtonText, -1, &m_rcBtnClient, m_vAlign | DT_CENTER | DT_SINGLELINE);
    
    SetTextColor(hdc, clrOldColor);
    SelectObject(hdc, hOldFont);
    
    if (itemState & ODS_FOCUS)
    {
        CopyRect(&rcFocus, &m_rcBtnClient);
        DrawText(hdc, m_szButtonText, -1, &rcFocus, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_TOP);
        OffsetRect(&rcFocus, (m_rcBtnClient.left + m_rcBtnClient.right - rcFocus.right) /
                2, (m_rcBtnClient.top + m_rcBtnClient.bottom - rcFocus.bottom) / 2);
        InflateRect(&rcFocus, 10, 1);                
        DrawFocusRect(hdc, &rcFocus);
    }        
    
};

HRESULT CICWButton::GetClientRect
(
    LPRECT lpRect
)
{
    if (!lpRect)
        return E_POINTER;
        
    memcpy(lpRect, &m_rcBtnClient, sizeof(RECT));
        
    return (S_OK);        
}    

HRESULT CICWButton::Enable
(
    BOOL bEnable
)
{
    EnableWindow(m_hWndButton, bEnable);
    return S_OK;

}    

HRESULT CICWButton::Show
(
    int nShowCmd 
)
{
    ShowWindow(m_hWndButton, m_bDisplayButton ? nShowCmd : SW_HIDE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\button.h ===
// This class will implement an owner draw button for the ICW when
// running in Customized App mode. 

#define MAX_BUTTON_TITLE    50

class CICWButton
{
    public:
    
        void DrawButton(HDC hdc, UINT itemState, LPPOINT lppt);
        
        void SetButtonText(LPTSTR   lpszText)
        {
            lstrcpyn(m_szButtonText, lpszText, MAX_BUTTON_TITLE);
        };
        
        void SetYPos(long yPos)
        {
            m_yPos = yPos;
        };
        
        void SetButtonDisplay(BOOL bDisplay)
        {
            m_bDisplayButton = bDisplay;
        };
                    
        HRESULT Enable( BOOL bEnable );
        HRESULT Show( int nShowCmd );
        
        HRESULT GetClientRect( LPRECT lpRect );
        HRESULT CreateButtonWindow(HWND hWndParent, UINT uiCtlID);
        HRESULT SetButtonParams(long        xPos,
                                LPTSTR      lpszPressedBmp,
                                LPTSTR      lpszUnpressedBmp,
                                LPTSTR      lpszFontFace,
                                long        lFontSize,
                                long        lFontWeight,
                                COLORREF    clrFontColor,
                                COLORREF    clrTransparentColor,
                                COLORREF    clrDisabled,
                                long        vAlign);
                
        CICWButton( void );
        ~CICWButton( void );

        HWND        m_hWndButton;             // Window Handle of the button
        long        m_xPos;
        long        m_yPos;
    private:
        
        HBITMAP     m_hbmPressed;
        HBITMAP     m_hbmUnpressed;
        TCHAR       m_szButtonText[MAX_BUTTON_TITLE+1];
        COLORREF    m_clrTransparent;
        COLORREF    m_clrText;
        COLORREF    m_clrDisabledText;
        HFONT       m_hfont;
        
        RECT        m_rcBtnClient;
        UINT        m_vAlign;        
        BOOL        m_bDisplayButton;
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\connect.cpp ===
//**********************************************************************
// File name: connect.cpp
//
//      Implementation of connection point sink objects
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "icwextsn.h"

/*
 * CRefDialEvent::CRefDialEvent
 * CRefDialEvent::~CRefDialEvent
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CRefDialEvent::CRefDialEvent( HWND  hWnd )
{
    m_hWnd = hWnd;
    m_cRef = 0;
}

CRefDialEvent::~CRefDialEvent( void )
{
    assert( m_cRef == 0 );
}


/*
 * CRefDialEvent::QueryInterface
 * CRefDialEvent::AddRef
 * CRefDialEvent::Release
 *
 * Purpose:
 *  IUnknown members for CRefDialEvent object.
 */

STDMETHODIMP CRefDialEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__RefDialEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CRefDialEvent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRefDialEvent::Release(void)
{
    return --m_cRef;
}


//IDispatch
STDMETHODIMP CRefDialEvent::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRefDialEvent::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRefDialEvent::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    HRESULT hr = ResultFromScode(DISP_E_UNKNOWNNAME);
    return hr;
}

STDMETHODIMP CRefDialEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_RasDialStatus:
        {
            BSTR    bstrDialStatus = NULL;
            
            // Get the Status Text
            if (gpWizardState->iRedialCount > 0)
                gpWizardState->pRefDial->put_Redial(TRUE);
            else
                gpWizardState->pRefDial->put_Redial(FALSE);

            gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);

            SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
            SysFreeString(bstrDialStatus);
             
            break;
        }
                    
        case DISPID_DownloadProgress:
        {
            long    lNewPos;
            if (pDispParams)
            {
                lNewPos =  pDispParams->rgvarg[0].lVal;
                if (!gpWizardState->bStartRefServDownload)
                {
                    BSTR    bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                }   
                gpWizardState->bStartRefServDownload = TRUE;

                // Set the Progress Position
                SendDlgItemMessage(m_hWnd, IDC_REFSERV_DIALPROGRESS, PBM_SETPOS, (WORD)lNewPos, 0l);
            }
            
            break;
        }
        case DISPID_DownloadComplete:
        {
            ASSERT(pDispParams);

            if(gpWizardState->lRefDialTerminateStatus != ERROR_CANCELLED)
            {

                if ((gpWizardState->lRefDialTerminateStatus = pDispParams->rgvarg[0].lVal) == ERROR_SUCCESS)
                {
                    gpWizardState->bDoneRefServDownload = TRUE; 

                    BSTR    bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                }

                // Hangup
                gpWizardState->pRefDial->DoHangup();
            
                
                PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
            }
            break;
        }
        case DISPID_RasConnectComplete:
        {
            BOOL    bRetVal;
            
            if(gpWizardState->lRefDialTerminateStatus != ERROR_CANCELLED)
            {
                if (pDispParams && pDispParams->rgvarg[0].bVal)
                {
                    // Show the progress bar
                    ShowWindow(GetDlgItem(m_hWnd, IDC_REFSERV_DIALPROGRESS), SW_SHOW);
                
                    gpWizardState->bDoneRefServRAS = TRUE;

                    // Start the Offer Download
                    gpWizardState->pRefDial->DoOfferDownload(&bRetVal);
            
                }
                else
                {
                    // Simulate the press of the NEXT button
                    gpWizardState->pRefDial->DoHangup();

                    PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
                }
            }
            
            break;
        }            
        
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\connect.h ===
#define DISPID_RasDialStatus       0x1
#define DISPID_DownloadProgress    0x2
#define DISPID_DownloadComplete    0x3
#define DISPID_RasConnectComplete  0x4

class CRefDialEvent : public _RefDialEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CRefDialEvent(HWND  hWnd);
        ~CRefDialEvent(void);        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void);        
        STDMETHODIMP_(DWORD) Release(void);        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\clntsrcs.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

TARGET_BOTH     = 1
USE_MSVCRT      = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn1;$(SHELL_INC_PATH)

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwconn1
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =
PRECOMPILED_CXX = 1

# Conditional compilation

LINKLIBS =  $(LIBRARY_PATH)\gdi32.lib                   \
            $(LIBRARY_PATH)\kernel32.lib                \
            $(LIBRARY_PATH)\advapi32.lib                \
            $(LIBRARY_PATH)\mpr.lib                     \
            $(LIBRARY_PATH)\comctl32.lib                \
            $(LIBRARY_PATH)\shell32.lib                 \
            $(LIBRARY_PATH)\uuid.lib                    \
            $(LIBRARY_PATH)\ole32.lib                   \
            $(SDK_LIB_PATH)\oleaut32.lib                \
            $(SDK_LIB_PATH)\oledlg.lib                  \
            $(SDK_LIB_PATH)\urlmon.lib                  \
            $(SDK_LIB_PATH)\shlwapi.lib                 \
            $(SHELL_LIB_PATH)\shlwapip.lib              \
            $(SDK_LIB_PATH)\htmlhelp.lib                \
!if defined(NOT_UNICODE)
            $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib     \
!else
            $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib  \
!endif

!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif

#
# List of sources.
#
SOURCES=                   \
        ..\icwconn1.rc     \
        ..\icwconn1.cpp    \
        ..\icwextsn.cpp    \
        ..\icwext.cpp      \
        ..\debug.cpp       \
        ..\intro.cpp       \
        ..\manual.cpp      \
        ..\areacode.cpp    \
        ..\gendlg.cpp      \
        ..\desktop.cpp     \
        ..\reboot.cpp      \
        ..\refdial.cpp     \
        ..\icwhelp.cpp     \
        ..\connect.cpp     \
        ..\end.cpp         \
        ..\dialerr.cpp     \
        ..\multinum.cpp    \
        ..\serverr.cpp     \
        ..\util.cpp        \
        ..\branded.cpp     \
        ..\isperr.cpp     \
        ..\tutor.cpp     \
        ..\sbsintro.cpp \
        ..\appwnd.cpp   \
        ..\button.cpp   \
        ..\icwsupr.cpp


PRECOMPILED_INCLUDE = ..\pre.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\debug.cpp ===
//
//
//
#include "pre.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "icwconn1"
#define SZ_MODULE           "icwconn1"
#define DECLARE_DEBUG

#include <ccstock.h>
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\dbgsrcs.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..\

TARGET_BOTH     = 1
USE_MSVCRT      = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn1;$(SHELL_INC_PATH)

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwdebug
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =
PRECOMPILED_CXX = 1

#SET THE ICWDEBUG FLAG FOR THE IFDEFs
C_DEFINES = $(C_DEFINES) -DICWDEBUG -DNASHVILLE

LINKLIBS =      $(SDK_LIB_PATH)\kernel32.lib                    \
                $(SDK_LIB_PATH)\user32.lib                      \
                $(SDK_LIB_PATH)\gdi32.lib                       \
                $(SDK_LIB_PATH)\advapi32.lib                    \
                $(SDK_LIB_PATH)\comctl32.lib                    \
                $(SDK_LIB_PATH)\shell32.lib                     \
                $(SDK_LIB_PATH)\comdlg32.lib                    \
                $(SDK_LIB_PATH)\mpr.lib                         \
                $(SDK_LIB_PATH)\ole32.lib                       \
                $(SDK_LIB_PATH)\oleaut32.lib                    \
                $(SDK_LIB_PATH)\uuid.lib                        \
                $(SDK_LIB_PATH)\shlwapi.lib                     \
                $(SHELL_LIB_PATH)\shlwapip.lib                  \
                $(SDK_LIB_PATH)\fdi.lib                         \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib       \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif


!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif

#
# List of sources
#
SOURCES=                   \
        ..\icwconn1.rc     \
        ..\icwconn1.cpp    \
        ..\icwextsn.cpp    \
        ..\icwext.cpp      \
        ..\debug.cpp       \
        ..\gendlg.cpp      \
        ..\desktop.cpp     \
        ..\reboot.cpp      \
        ..\icwhelp.cpp     \
        ..\end.cpp         \
        ..\util.cpp        \
        ..\icwdebug.cpp	   \
        ..\fdi.cpp         \
        ..\appwnd.cpp      \
        ..\button.cpp      \
        ..\icwsupr.cpp


PRECOMPILED_INCLUDE = ..\pre.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\end.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  END.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"


/*******************************************************************

  NAME:    EndInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/

BOOL CALLBACK EndInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    HWND  hwndPropsheet    = GetParent(hDlg);

    SetWindowLongPtr(GetDlgItem(hDlg, IDC_STATIC_ICON), GWLP_USERDATA, 201);

    // This is the very last page, so no back is not possible
    if (!g_bAllowCancel)
    {
        PropSheet_CancelToClose(hwndPropsheet);

        // Get the main frame window's style
        LONG window_style = GetWindowLong(hwndPropsheet, GWL_STYLE);

        //Remove the system menu from the window's style
        window_style &= ~WS_SYSMENU;

        //set the style attribute of the main frame window
        SetWindowLong(hwndPropsheet, GWL_STYLE, window_style);
    }
    
    if (!fFirstInit)
    {
        HWND  hwndBtn                     = GetDlgItem(hDlg, IDC_CHECK_BROWSING);
        TCHAR szTemp  [MAX_MESSAGE_LEN*2] = TEXT("\0");
            
        if (gpICWCONNApprentice)
            gpICWCONNApprentice->SetStateDataFromDllToExe( &gpWizardState->cmnStateData);

        PropSheet_SetWizButtons(hwndPropsheet, PSWIZB_FINISH); 

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
#ifndef ICWDEBUG
        // NOTE: No ORD_PAGE_ENDOEMCUSTOM for ICWDEBUG
        if (gpWizardState->cmnStateData.bOEMCustom)
            gpWizardState->uCurrentPage = ORD_PAGE_ENDOEMCUSTOM;
        else            
#endif  
            gpWizardState->uCurrentPage = ORD_PAGE_END;

        //the ins has failed let's display the special message.
        if (gpWizardState->cmnStateData.ispInfo.bFailedIns)
        {
            TCHAR szErrTitle   [MAX_MESSAGE_LEN] = TEXT("\0");
            TCHAR szErrMsg1    [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsg2    [MAX_RES_LEN]     = TEXT("\0");  
            TCHAR szErrMsg3    [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsgTmp1 [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsgTmp2 [MAX_RES_LEN]     = TEXT("\0");    

            LoadString(g_hInstance, IDS_INSCONFIG_ERROR_TITLE, szErrTitle, MAX_MESSAGE_LEN);
           
            SetWindowText(GetDlgItem(hDlg, IDC_LBLTITLE), szErrTitle);
            
            if(*(gpWizardState->cmnStateData.ispInfo.szISPName))
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_1, szErrMsg1, ARRAYSIZE(szErrMsg1));
                wsprintf(szErrMsgTmp1, szErrMsg1, gpWizardState->cmnStateData.ispInfo.szISPName); 
                lstrcpy(szTemp,szErrMsgTmp1);
            }
            else
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_1_NOINFO, szErrMsg1, ARRAYSIZE(szErrMsg1));
                lstrcpy(szTemp, szErrMsg1);
            }
            
            if(*(gpWizardState->cmnStateData.ispInfo.szSupportNumber))
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_2, szErrMsg2, ARRAYSIZE(szErrMsg2));
                wsprintf(szErrMsgTmp2, szErrMsg2, gpWizardState->cmnStateData.ispInfo.szSupportNumber); 
                lstrcat(szTemp, szErrMsgTmp2);
            }
            else
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_2_NOINFO, szErrMsg2, ARRAYSIZE(szErrMsg2));
                lstrcat(szTemp, szErrMsg2);
            }

            LoadString(g_hInstance, IDS_INSCONFIG_ERROR_INSTRUCT, szErrMsg3, ARRAYSIZE(szErrMsg3));
            lstrcat(szTemp, szErrMsg3);

            SetWindowText(GetDlgItem(hDlg, IDC_INSERROR_FINISH_TEXT), szTemp);

            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_TEXT), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_SUPPORT_TEXT), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_STATIC_ICON), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_CLOSE_WIZ_CLICK_FINISH), SW_HIDE); 
            ShowWindow(hwndBtn, SW_HIDE); 
        }
        else
        {       
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
                LoadString(g_hInstance, IDS_END_AUTOCFG_FINISH, szTemp, MAX_MESSAGE_LEN);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_NEWISP)
                LoadString(g_hInstance, IDS_END_SIGNUP_FINISH, szTemp, MAX_MESSAGE_LEN);
            else
                LoadString(g_hInstance, IDS_END_MANUAL_FINISH, szTemp, MAX_MESSAGE_LEN);
            
            SetWindowText(GetDlgItem(hDlg, IDC_FINISH_TEXT), szTemp);
        }

        // IDC_CHECK_BROWSING is now permanently unchecked and hidden
        // (can't modify resources so we do it in code)
        ShowWindow(hwndBtn, SW_HIDE);
    }
    
    return TRUE;
}


/*******************************************************************

  NAME:    EndOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK EndOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // If connection info is not saved, save it
    if (gpINETCFGApprentice)
    {
        DWORD dwStatus;
        gpINETCFGApprentice->Save(hDlg, &dwStatus);
    }
   
    return TRUE;
}
/*******************************************************************

  NAME:    EndOlsInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
#ifndef ICWDEBUG
BOOL CALLBACK EndOlsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is a finish page
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_FINISH);

    if (!fFirstInit)
    {

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ENDOLS;
    }        
    
    return TRUE;
}
#endif  //ICWDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\desktop.cpp ===
//**********************************************************************
// File name: desktop.cpp
//
//      Desktop manipulation functions
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "regstr.h"
#include "inetreg.h"
#include <shlobj.h>
#include <shfolder.h>   // latest platform SDK has this

#define MAX_USER_NAME             255
#define REGSTR_PATH_SETUPKEY      REGSTR_PATH_SETUP REGSTR_KEY_SETUP
#define REGSTR_PATH_IEONDESKTOP   REGSTR_PATH_IEXPLORER TEXT("\\AdvancedOptions\\BROWSE\\IEONDESKTOP")
#define InternetConnectionWiz     "Internet Connection Wizard"
#define NOICWICON                 "NoICWIcon"

static const TCHAR g_szRegPathWelcomeICW[]  = TEXT("Welcome\\ICW");
static const TCHAR g_szAllUsers[]           = TEXT("All Users");
static const TCHAR g_szConnectApp[]         = TEXT("ICWCONN1.EXE");
static const TCHAR g_szConnectLink[]        = TEXT("Connect to the Internet");
static const TCHAR g_szOEApp[]              = TEXT("MSINM.EXE");
static const TCHAR g_szOELink[]             = TEXT("Outlook Express");
static const TCHAR g_szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR g_szRegValICWCompleted[] = TEXT("Completed");
static const TCHAR g_szRegValNoIcon[]       = TEXT("NoIcon");

extern BOOL MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen);
extern BOOL IsNT();
extern BOOL IsNT5();

void QuickCompleteSignup()
{
    // Set the welcome state
    UpdateWelcomeRegSetting(TRUE);

    // Restore the desktop
    UndoDesktopChanges(g_hInstance);

    // Mark the ICW as being complete
    SetICWComplete();
}


void UpdateWelcomeRegSetting
(
    BOOL    bSetBit
)
{
    HKEY    hkey;
    HKEY    hkeyCurVer;
    DWORD   dwValue = bSetBit;
         
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_SETUP,         // ...\Windows\CurrentVersion
                     0,
                     KEY_ALL_ACCESS,
                     &hkeyCurVer) == ERROR_SUCCESS)
    {
                        
        DWORD dwDisposition;
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurVer,
                                            g_szRegPathWelcomeICW,
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE, 
                                            KEY_ALL_ACCESS, 
                                            NULL, 
                                            &hkey, 
                                            &dwDisposition))
        {
            RegSetValueEx(hkey,
                          TEXT("@"),
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwValue,
                          sizeof(DWORD));                              

            RegCloseKey(hkey);
        }       
        RegCloseKey(hkeyCurVer);
    }        
}

BOOL GetCompletedBit( )
{
    HKEY    hkey;
    DWORD   dwValue;
    DWORD   dwRet = ERROR_GEN_FAILURE;
    DWORD   dwType = REG_DWORD;
    BOOL    bBit = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     g_szRegPathICWSettings,         // ...Software\\Microsoft\\Internet Connection Wizard
                     0,
                     KEY_ALL_ACCESS,
                     &hkey) == ERROR_SUCCESS)
    {
        DWORD dwDataSize = sizeof (dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, g_szRegValICWCompleted, NULL, &dwType, (LPBYTE) &dwValue, &dwDataSize))
        {
            bBit = (1 == dwValue);
        }
        RegCloseKey(hkey);
    }        
    return bBit;
}


void GetDesktopDirectory(TCHAR* pszPath)
{
    LPITEMIDLIST lpItemDList = NULL;
    IMalloc*     pMalloc     = NULL;
    HRESULT      hr          = E_FAIL;
    
    if(IsNT5()) // Bug 81444 in IE DB
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &lpItemDList);
    else if (IsNT())
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &lpItemDList);
    else
    {


        TCHAR pszFolder[MAX_PATH];
        *pszFolder = 0;
        HRESULT hRet = S_FALSE;

        HMODULE hmod = LoadLibrary(TEXT("shfolder.dll"));
        PFNSHGETFOLDERPATH pfn = NULL;
        if (hmod)
        {
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, "SHGetFolderPathA"); // or W if you are unicode
            if (pfn)
            {
                hRet = pfn(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, 0, pszFolder);
                if (S_OK != hRet)
                    hRet = pfn(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszFolder);
                if (S_OK == hRet)
                    lstrcpy(pszPath ,pszFolder);
            }
            FreeLibrary(hmod);
        }

        if (S_OK != hRet)
        {

            FARPROC hShell32VersionProc = NULL;
            HMODULE hShell32Mod = (HMODULE)LoadLibrary(TEXT("shell32.dll"));
    
            if (hShell32Mod)
                hShell32VersionProc = GetProcAddress(hShell32Mod, "DllGetVersion");

            if(hShell32VersionProc)
            {
                TCHAR szDir [MAX_PATH] = TEXT("\0");

                //ok, we're not NT, but we may be multiuser windows.
                GetWindowsDirectory(szDir, MAX_PATH);
                if (szDir)
                {
                    lstrcat(szDir, TEXT("\\"));
                    lstrcat(szDir, g_szAllUsers);
            
                    TCHAR szTemp [MAX_MESSAGE_LEN] = TEXT("\0");      
            
                    LoadString(g_hInstance, IDS_DESKTOP, szTemp, MAX_MESSAGE_LEN);
                    if (szTemp)
                    {
                        lstrcat(szDir, TEXT("\\"));
                        lstrcat(szDir, szTemp);
                        lstrcpy(pszPath ,szDir);
                    }
                }
            }
            else
                hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &lpItemDList);
        }
    }

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, pszPath);
    
        if (SUCCEEDED(SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }
}


void RemoveDesktopShortCut
(
    LPTSTR lpszShortcutName    
)
{
    TCHAR szShortcutPath[MAX_PATH] = TEXT("\0");
    
    GetDesktopDirectory(szShortcutPath);
    
    if(szShortcutPath[0] != TEXT('\0'))
    {
        lstrcat(szShortcutPath, TEXT("\\"));
        lstrcat(szShortcutPath, lpszShortcutName);
        lstrcat(szShortcutPath, TEXT(".LNK"));
        DeleteFile(szShortcutPath);
    }
}

// This function will add a desktop shortcut
void AddDesktopShortCut
(
    LPTSTR lpszAppName,
    LPTSTR lpszLinkName
)
{
    TCHAR       szConnectPath     [MAX_PATH]   = TEXT("\0");
    TCHAR       szAppPath         [MAX_PATH]   = TEXT("\0");
    TCHAR       szConnectLinkPath [MAX_PATH]   = TEXT("\0");        // Path the where the Shortcut file will livE 
    TCHAR       szdrive           [_MAX_DRIVE] = TEXT("\0");   
    TCHAR       szdir             [_MAX_DIR]   = TEXT("\0");
    TCHAR       szfname           [_MAX_FNAME] = TEXT("\0");   
    TCHAR       szext             [_MAX_EXT]   = TEXT("\0");
    TCHAR       szRegPath         [MAX_PATH]   = TEXT("\0");
    HRESULT     hres                           = E_FAIL; 
    IShellLink* psl                            = NULL;
    HKEY        hkey                           = NULL;
    
    // first get the app path
    lstrcpy(szRegPath, REGSTR_PATH_APPPATHS);
    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, lpszAppName);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szRegPath,
                     0,
                     IsNT5()? KEY_QUERY_VALUE : KEY_ALL_ACCESS,
                     &hkey) == ERROR_SUCCESS)
    {
        DWORD dwTmp = sizeof(szConnectPath);
        DWORD dwType = 0;
        if(RegQueryValueEx(hkey, 
                           NULL, 
                           NULL,
                           &dwType,
                           (LPBYTE) szConnectPath, 
                           &dwTmp) != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return;
        }
        RegQueryValueEx(hkey, 
                           TEXT("Path"), 
                           NULL,
                           &dwType,
                           (LPBYTE) szAppPath, 
                           &dwTmp);

        RegCloseKey(hkey);
    }
    else
    {
        return;
    }

    GetDesktopDirectory(szConnectLinkPath);
    
    if(szConnectLinkPath[0] != TEXT('\0'))
    {
        // Append on the connect EXE name
        lstrcat(szConnectLinkPath, TEXT("\\"));
        lstrcat(szConnectLinkPath, lpszAppName);

        //
        int nLastChar = lstrlen(szAppPath)-1;
        if ((nLastChar > 0) && (';' == szAppPath[nLastChar]))
            szAppPath[nLastChar] = 0;

        // Split the path, and the reassemble with the .LNK extension
        _tsplitpath( szConnectLinkPath, szdrive, szdir, szfname, szext );
        _tmakepath(szConnectLinkPath, szdrive, szdir, lpszLinkName, TEXT(".LNK"));

        // Create an IShellLink object and get a pointer to the IShellLink 
        // interface (returned from CoCreateInstance).
        hres = CoCreateInstance (CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IShellLink, (void **)&psl);
        if (SUCCEEDED (hres))
        {
            IPersistFile *ppf;

            // Query IShellLink for the IPersistFile interface for 
            // saving the shortcut in persistent storage.
            hres = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);
            if (SUCCEEDED (hres))
            { 
                WORD wsz [MAX_PATH]; // buffer for Unicode string

                do
                {  

                    // Set the path to the shortcut target.
                    if (!SUCCEEDED(psl->SetPath (szConnectPath)))
                        break;

                    // Set the working dir to the shortcut target.
                    if (!SUCCEEDED(psl->SetWorkingDirectory (szAppPath)))
                        break;

                    // Set the args.
                    if (!SUCCEEDED(psl->SetArguments (SHORTCUTENTRY_CMD)))
                        break;

                    // Set the description of the shortcut.
                    TCHAR   szDescription[MAX_MESSAGE_LEN];
                    if (!LoadString(g_hInstance, IDS_SHORTCUT_DESC, szDescription, MAX_MESSAGE_LEN))
                        lstrcpy(szDescription, lpszLinkName);

                    if (!SUCCEEDED(psl->SetDescription (szDescription)))
                        break;
                
                    // Ensure that the string consists of ANSI TCHARacters.
#ifdef UNICODE
                    lstrcpy(wsz, szConnectLinkPath);
#else
                    MultiByteToWideChar (CP_ACP, 0, szConnectLinkPath, -1, wsz, MAX_PATH);
#endif
        
                    // Save the shortcut via the IPersistFile::Save member function.
                    if (!SUCCEEDED(ppf->Save (wsz, TRUE)))
                        break;
                    
                    // Release the pointer to IPersistFile.
                    ppf->Release ();
                    break;
                
                } while (1);
            }
            // Release the pointer to IShellLink.
            psl->Release ();
        }
    }        
} 

// This function will apply the appropriate desktop changes based on the following
// algorithm.  This code below assumes that the machine is NOT internet capable.
// If the machine was upgraded from a previous OS, then
//      Add the connect to the internet ICON
//  ELSE (clean install or OEM pre install)
//      Add the connect to the internet ICON
//
void DoDesktopChanges
(
    HINSTANCE   hAppInst
)
{
    TCHAR    szAppName[MAX_PATH];
    TCHAR    szLinkName[MAX_PATH];
    HKEY    hkey;

    if (!LoadString(hAppInst, IDS_CONNECT_FNAME, szAppName, sizeof(szAppName)))
        lstrcpy(szAppName, g_szConnectApp);
                    
    if (!LoadString(hAppInst, IDS_CONNECT_DESKTOP_TITLE, szLinkName, sizeof(szLinkName)))
        lstrcpy(szLinkName, g_szConnectLink);

    // We always add the connect shortcut
    AddDesktopShortCut(szAppName, szLinkName);                
                                
    // Set a registry value indicating that we messed with the desktop
    DWORD dwDisposition;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                        ICWSETTINGSPATH,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE, 
                                        KEY_ALL_ACCESS, 
                                        NULL, 
                                        &hkey, 
                                        &dwDisposition))
    {
        DWORD   dwDesktopChanged = 1;    
        RegSetValueEx(hkey, 
                      ICWDESKTOPCHANGED, 
                      0, 
                      REG_DWORD,
                      (LPBYTE)&dwDesktopChanged, 
                      sizeof(DWORD));
        RegCloseKey(hkey);
    }
}

// This undoes what DoDesktopChanges did
void UndoDesktopChanges
(
    HINSTANCE   hAppInst
)
{

    TCHAR    szConnectTotheInternetTitle[MAX_PATH];
    HKEY    hkey;

    // Verify that we really changed the desktop
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      ICWSETTINGSPATH,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkey))
    {
        DWORD   dwDesktopChanged = 0;    
        DWORD   dwTmp = sizeof(DWORD);
        DWORD   dwType = 0;
        
        RegQueryValueEx(hkey, 
                        ICWDESKTOPCHANGED, 
                        NULL, 
                        &dwType,
                        (LPBYTE)&dwDesktopChanged, 
                        &dwTmp);
        RegCloseKey(hkey);
        
        // Bail if the desktop was not changed by us
        if(!dwDesktopChanged)
            return;
    }
        
    // Always nuke the Connect to the internet icon
    if (!LoadString(hAppInst, 
                    IDS_CONNECT_DESKTOP_TITLE, 
                    szConnectTotheInternetTitle, 
                    sizeof(szConnectTotheInternetTitle)))
    {
        lstrcpy(szConnectTotheInternetTitle, g_szConnectLink);
    }
    
    RemoveDesktopShortCut(szConnectTotheInternetTitle);    
}    

void UpdateDesktop
(
    HINSTANCE   hAppInst
)
{
    if(MyIsSmartStartEx(NULL, 0))
    {
        // VYUNG NT5 bug See if IEAK wants to stop GETCONN icon creation
        //if (!SHGetRestriction(NULL, TEXT("Internet Connection Wizard"), TEXT("NoICWIcon")))
        // CHUNHOC NT5.1 bug Don't create icon at desktop in any case.
        /*
        if (!SHGetRestriction(NULL, L"Internet Connection Wizard", L"NoICWIcon"))
            DoDesktopChanges(hAppInst);
        */
    }
    else
    {
        // We are internet ready, so set the appropriate Welcome show bit
        // and replace the IE and OE links
        UpdateWelcomeRegSetting(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\fdi.cpp ===
//#include <stdio.h>
//
//#include <string.h>

#include "pre.h"

#include "fdi.h"
#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>


/*
 * Function prototypes 
 */
BOOL	fdi(char *cabinet_file, char *dir);
int		get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[256];


/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close((int)hf);
}


FNSEEK(file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
            /*
			printf(
				"fdintCABINET_INFO\n"
				"  next cabinet     = %s\n"
				"  next disk        = %s\n"
				"  cabinet path     = %s\n"
				"  cabinet set ID   = %d\n"
				"  cabinet # in set = %d (zero based)\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet
			);
            */
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
            /*
			printf(
				"fdintPARTIAL_FILE\n"
				"   name of continued file            = %s\n"
				"   name of cabinet where file starts = %s\n"
				"   name of disk where file starts    = %s\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
            */
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
        	INT_PTR	handle;
            //int		response;
			char	destination[256];
            /*
			printf(
				"fdintCOPY_FILE\n"
				"  file name in cabinet = %s\n"
				"  uncompressed file size = %d\n"
				"  copy this file? (y/n): ",
				pfdin->psz1,
				pfdin->cb
			);

			do
			{
				response = getc(stdin);
				response = toupper(response);
			} while (response != 'Y' && response != 'N');

			printf("\n");

			if (response == 'Y')
			{
				sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

				handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

				return handle;
			}
			else
			{
				return 0;
			}
            */
            sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

            handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            /*
 			printf(
				"fdintCLOSE_FILE_INFO\n"
				"   file name in cabinet = %s\n"
				"\n",
				pfdin->psz1
			);

            sprintf(
                destination, 
                "%s%s",
                dest_dir,
                pfdin->psz1
            );
            */
            sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);
			file_close(pfdin->hf);


            handle = CreateFileA(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributesA(
                destination,
                attrs
            );

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
            /*
			printf(
				"fdintNEXT_CABINET\n"
				"   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
				"   cabinet path name                         = %s\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
            */
			return 0;
        
	}
	return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR			hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

    strcpy(dest_dir, directory);

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
        char szErr[255];
		sprintf(szErr, "FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		cabinet_fullpath,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		char szErr[255];
		sprintf(szErr, "Unable to open '%s' for input\n", cabinet_fullpath);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * No, it's not a cabinet!
		 */
		_close((int)hf);

        char szErr[255];
		sprintf(szErr, "FDIIsCabinet() failed: '%s' is not a cabinet\n",
			cabinet_fullpath
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close((int)hf);

        /*
        char szErr[255];
		sprintf(szErr, "Information on cabinet file '%s'\n"
			"   Total length of cabinet file : %d\n"
			"   Number of folders in cabinet : %d\n"
			"   Number of files in cabinet   : %d\n"
			"   Cabinet set ID               : %d\n"
			"   Cabinet number in set        : %d\n"
			"   RESERVE area in cabinet?     : %s\n"
			"   Chained to prev cabinet?     : %s\n"
			"   Chained to next cabinet?     : %s\n"
			"\n",
			cabinet_fullpath,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? "yes" : "no",
			fdici.hasprev == TRUE ? "yes" : "no",
			fdici.hasnext == TRUE ? "yes" : "no"
		);
        MessageBox(NULL, szErr, "", MB_OK);
        */
	}

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabinet_fullpath);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
        char szErr[255];
		sprintf(szErr, "FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
        char szErr[255];
		sprintf(szErr, "FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}

	return TRUE;
}


char *return_fdi_error_string(int err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\gendlg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"

#ifndef ICWDEBUG
#include "tutor.h"

extern CICWTutorApp* g_pICWTutorApp; 

#endif

#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458
/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
    if( uPageIndex <= EXE_MAX_PAGE_INDEX )
    {
        ASSERT(uPageIndex < EXE_NUM_WIZARD_PAGES);

        return PageInfo[uPageIndex].uDlgID;
    }
    else
    {
        return(uPageIndex);
    }
}

//
//  GENDLG.C - 
//  Generic DLG proc for common wizard functions
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//


// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;

    if (!LoadString(g_hInstance, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc
(
    HWND hDlg, 
    BOOL fFirstInit, 
    UINT uDlgID
)
{
//    switch( uDlgID )
//    {
//    }
    return TRUE;
}


INT_PTR CALLBACK CancelCmdProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // put the dialog in the center of the screen
            RECT rc;
            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg,
                        NULL,
                        ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                        ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                        0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
            break;
            
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if (Button_GetCheck(GetDlgItem(hDlg, IDC_CHECK_HIDE_ICW)))
                    {
                        // Set the welcome state
                        UpdateWelcomeRegSetting(TRUE);
    
                        // Restore the desktop
                        UndoDesktopChanges(g_hInstance);
    
                        // Mark the ICW as being complete
                        SetICWComplete();

                        gfQuitWizard = TRUE;
                    }
                    EndDialog(hDlg,TRUE);
                    break;

                case IDCANCEL:
                   EndDialog(hDlg,FALSE);
                    break;                  
            }
            break;
    }

    return FALSE;
}


//This is a dummy winproc needed for a dummy child window
//which will be used by dlls etc to get the hwnd for this app.
//**************************************************
//***REMOVING THIS CODE WILL CAUSE OTHER CODE    ***
//***IN ICWHELP AND POSSIBLY OTHER PACES TO FAIL ***
//**************************************************
LRESULT CALLBACK InvisibleChildDummyWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc (hWnd, message, wParam, lParam);
}

/*******************************************************************
//
//    Function:    PaintWithPaletteBitmap
//
//    Arguments:   lprc is the target rectangle.
//                 cy is the putative dimensions of hbmpPaint.
//                 If the target rectangle is taller than cy, then 
//                 fill the rest with the pixel in the upper left 
//                 corner of the hbmpPaint.
//
//    Returns:     void
//
//    History:      10-29-98    Vyung    -  Stole from prsht.c
//
********************************************************************/
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}

/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}
/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:         back and next buttons enabled
          next btn:     switches to page following current page
          back btn:     switches to previous page
          cancel btn:   prompts user to confirm, and cancels the wizard
          dlg ctrl:     does nothing (in response to WM_COMMANDs)
          
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    static HCURSOR  hcurOld = NULL;
    static BOOL     bKilledSysmenu = FALSE;
    PAGEINFO        *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

    switch (uMsg) 
    {

        case WM_ERASEBKGND:
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                FillWindowWithAppBackground(hDlg, (HDC)wParam);
                return TRUE;
            }
            else
            {
                // Only paint the external page 
                if ((!pPageInfo->nIdTitle) && (IDD_PAGE_BRANDEDINTRO != pPageInfo->uDlgID))
                {
                    Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                    return TRUE;
                }
            }                
            break;
        }
        
        GENDLG_CTLCOLOR:
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        {
            // Only paint the external page and except the ISP sel page
            if ((!pPageInfo->nIdTitle) && (IDD_PAGE_BRANDEDINTRO != pPageInfo->uDlgID))
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        

        // We need to make sure static controls draw transparently
        // on the background bitmap.  This is done by painting in
        // the appropriate portion of the background, and then 
        // returning a NULL brush so the control just draws the text    
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                // See if the control is an ES_READONLY style edit box, and if
                // so then don't make it transparent
                if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
                {
                    SetBkMode((HDC)wParam, TRANSPARENT);
                    return (INT_PTR) GetStockObject(NULL_BRUSH);    
                }   
                
                break;             
            }                
            else
            {
                // Not in modeless opperation so just do the default cltcolor
                // handling
                goto GENDLG_CTLCOLOR;
            }

#ifndef ICWDEBUG
        case WM_RUNICWTUTORAPP:    
        {
            g_pICWTutorApp->LaunchTutorApp();
            break;
        }
#endif
        case WM_INITDIALOG:
        {
            // get propsheet page struct passed in
            LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT(lpsp);
        
            // fetch our private page info from propsheet struct
            pPageInfo = (PAGEINFO *)lpsp->lParam;

            // store pointer to private page info in window data for later
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);
        
            if(!gpWizardState->cmnStateData.bOEMCustom)
            {
                if (!bKilledSysmenu )
                {
                    HWND hWnd = GetParent(hDlg);
                    RECT rect;
                    
                    //Get our current pos and width etc.
                    GetWindowRect(hWnd, &rect);
                    
                    //Let's get centred
                    MoveWindow(hWnd,
                               (GetSystemMetrics(SM_CXSCREEN) - (rect.right  - rect.left )) / 2, //int X,
                               (GetSystemMetrics(SM_CYSCREEN) - (rect.bottom - rect.top  )) / 2, //int Y,
                               rect.right  - rect.left,                                          //width 
                               rect.bottom - rect.top,                                           // height
                               TRUE);
        
                    // Get the main frame window's style
                    LONG window_style = GetWindowLong(GetParent(hDlg), GWL_EXSTYLE);

                    //Remove the system menu from the window's style
                    window_style &= ~WS_EX_CONTEXTHELP;

                    //set the style attribute of the main frame window
                    SetWindowLong(GetParent(hDlg), GWL_EXSTYLE, window_style);

                    bKilledSysmenu = TRUE;
                }
            }
            else
            {
                 // Parent should control us, so the user can tab out of our property sheet
                DWORD dwStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
                dwStyle = dwStyle | WS_EX_CONTROLPARENT;
                SetWindowLong(hDlg, GWL_EXSTYLE, dwStyle);
            }
            
            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

            // Make the title text bold
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc)
            {
                if (!( pPageInfo->InitProc(hDlg,TRUE, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
            // Before we return, lets send another message to ourself so
            // we have a second chance of initializing stuff that the 
            // property sheet wizard doesn't normally let us do.
            PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


            return TRUE;
        }
        break;  // WM_INITDIALOG

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        case WM_MYINITDIALOG:
        {
            PAGEINFO * pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
            ASSERT(pPageInfo);
            
            if (pPageInfo->PostInitProc)
            {
                if (!( pPageInfo->PostInitProc(hDlg, (BOOL)wParam, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }
            
            // wParam tells whether this is the first initialization or not
            MiscInitProc(hDlg, (BOOL)wParam, pPageInfo->uDlgID);
            return TRUE;
        }


        case WM_DESTROY:
            ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
            // 12/18/96 jmazner Normandy #12923
            // bKilledSysmenu is static, so even if the window is killed and reopened later
            // (as happens when user starts in conn1, goes into man path, backs up
            //  to conn1, and then returns to man path), the value of bKilledSysmenu is preserved.
            // So when the window is about to die, set it to FALSE, so that on the next window
            // init we go through and kill the sysmenu again.
            bKilledSysmenu = FALSE;
            break;

#ifdef HAS_HELP
        case WM_HELP:
        {
            DWORD dwData = 1000;

            WinHelp(hDlg,"connect.hlp>proc4",HELP_CONTEXT, dwData);
            break;
        }
#endif
        
        case WM_NOTIFY:
        {
            BOOL fRet,fKeepHistory=TRUE;
            NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
            int iNextPage = NEXTPAGEUNITIALIZED;
            switch (lpnm->code) 
            {
                case PSN_TRANSLATEACCELERATOR:    
                {
                    if (pPageInfo->bIsHostingWebOC)
                    {                    
                        //SUCEEDED macro will not work here cuz ret maybe S_FALSE
                        if (S_OK == gpWizardState->pICWWebView->HandleKey((LPMSG)((PSHNOTIFY*)lParam)->lParam)) 
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        else
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else if (((IDD_PAGE_END == pPageInfo->uDlgID) ||
                              (IDD_PAGE_ENDOEMCUSTOM == pPageInfo->uDlgID))
                               && !g_bAllowCancel)
                    {
                        //needed to disable Alt-F4 
                        LPMSG lpMsg = (LPMSG)((PSHNOTIFY*)lParam)->lParam;

                        if ((WM_SYSKEYDOWN == lpMsg->message) && (lpMsg->wParam == VK_F4))
                        {
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        }
                    }
                    return TRUE;
                }    
                case PSN_SETACTIVE:
                    // If a fatal error occured in first call to init proc
                    // from WM_INITDIALOG, don't call init proc again.
                    if (FALSE == gfQuitWizard)
                    {
                        // For modeless operation, we are suppressing the painting
                        // of the wizard page background to get the effect of
                        // transparency, so we need to for an update of the 
                        // app's client area after hiding the current page.
                        if(gpWizardState->cmnStateData.bOEMCustom)
                        {
                            // Set the position of the page that is being activated
                            SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                            
                            // Set the page title
                            if (pPageInfo->nIdTitle)
                            {
                                SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, (WPARAM)g_hInstance, MAKELONG(pPageInfo->nIdTitle, 0));
                            }
                        }    
                    
                        // initialize 'back' and 'next' wizard buttons, if
                        // page wants something different it can fix in init proc below
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                        // call init proc for this page if one is specified
                        if (pPageInfo->InitProc)
                        {
                            pPageInfo->InitProc(hDlg,FALSE, (UINT*)&iNextPage);
                            // See if the init proc want to skip this step
                            if (NEXTPAGEUNITIALIZED != iNextPage)
                            {
                                // Skipping
                                SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                                return (iNextPage);
                            }
                        }
                    }

                    // If we set the wait cursor, set the cursor back
                    if (hcurOld)
                    {
                        SetCursor(hcurOld);
                        hcurOld = NULL;
                    }

                    PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:

                    if(lpnm->code == PSN_WIZFINISH)
                    {
                         // Set the welcome state
                        UpdateWelcomeRegSetting(TRUE);
            
                        // Restore the desktop
                        UndoDesktopChanges(g_hInstance);            
                    }
                    
                    // Change cursor to an hour glass
                    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // call OK proc for this page if one is specified
                    if (pPageInfo->OKProc) 
                    {
                        if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK), (UINT*)&iNextPage,&fKeepHistory))
                        {
                            // If a fatal error occured, quit the wizard.
                            // Note: gfQuitWizard is also used to terminate the wizard
                            // for non-error reasons, but in that case TRUE is returned
                            // from the OK proc and the case is handled below.
                            if (gfQuitWizard)
                            {
                                // Don't reboot if error occured.
                                gpWizardState->fNeedReboot = FALSE;
                
                                // send a 'cancel' message to ourselves (to keep the prop.
                                // page mgr happy)
                                //
                                // ...Unless we're serving as an Apprentice.  In which case, let
                                // the Wizard decide how to deal with this.

                                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                            }
                            
                            // stay on this page
                            SetPropSheetResult(hDlg,-1);
                            return TRUE;
                        }
                    }
                    
                    if (lpnm->code != PSN_WIZBACK) 
                    {
                        // 'next' pressed
                        ASSERT(gpWizardState->uPagesCompleted < EXE_NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory) 
                        {
                            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
                            TraceMsg(TF_GENDLG, TEXT("GENDLG: added page %d (IDD %d) to history list"),
                                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                            gpWizardState->uPagesCompleted++;
                        }
                        else
                        {
                            TraceMsg(TF_GENDLG, TEXT("GENDLG: not adding %d (IDD: %d) to the history list"),
                            gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                        }


                        // if no next page specified or no OK proc,
                        // advance page by one
                        if (0 > iNextPage)
                            iNextPage = gpWizardState->uCurrentPage + 1;

                    }
                    else
                    {
                        // 'back' pressed
//                        switch( gpWizardState->uCurrentPage )
//                        {
//                        }

                        if( NEXTPAGEUNITIALIZED == iNextPage )
                        {
                            if (gpWizardState->uPagesCompleted > 0)
                            {
                                // get the last page from the history list
                                gpWizardState->uPagesCompleted --;
                                iNextPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
                                TraceMsg(TF_GENDLG, TEXT("GENDLG:  extracting page %d (IDD %d) from history list"),iNextPage, GetDlgIDFromIndex(iNextPage));
                            }
                            else
                            {
                                ASSERT(0);
                                // This is bad, the history list position pointer indicates that
                                // there are no pages in the history, so we should probably
                                // just stay right were we are.
                                iNextPage = gpWizardState->uCurrentPage;
                                
                            }                                
                        }
#if 0  // We shouldn't be depend on this piece of code, as we should always use History.      
                        else
                        {
                            // The OK proc has specified a specific page to goto so lets see if it
                            // is in the history stack, otherwise we we want to back the stack up
                            // anyways
                            while (gpWizardState->uPagesCompleted  > 0)
                            {
                                --gpWizardState->uPagesCompleted;
                                if (iNextPage == (int)gpWizardState->uPageHistory[gpWizardState->uPagesCompleted])
                                    break;
                            }                                    
                        }
#endif
                    }

                    // if we need to exit the wizard now (e.g. launching
                    // signup app and want to terminate the wizard), send
                    // a 'cancel' message to ourselves (to keep the prop.
                    // page mgr happy)
                    if (gfQuitWizard) 
                    {
       
                        //
                        // if we are going from manual to conn1 then
                        // then do not show the  REBOOT dialog but
                        // still preserve the gpWizardState -MKarki Bug #404
                        //
                        if (lpnm->code ==  PSN_WIZBACK)
                        {
                            gfBackedUp = TRUE;
                            gfReboot = gpWizardState->fNeedReboot;
                        }

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                        SetPropSheetResult(hDlg,-1);
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed
                    if (lpnm->code != PSN_WIZFINISH) 
                    {

                        // set the next current page index
                        gpWizardState->uCurrentPage = iNextPage;
                        TraceMsg(TF_GENDLG, TEXT("GENDLG: going to page %d (IDD %d)"), iNextPage, GetDlgIDFromIndex(iNextPage));

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                        return TRUE;
                    }
                    break;

                case PSN_QUERYCANCEL:
                {
                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...
                    if (gfQuitWizard) 
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
                        return TRUE;
                    }
#ifndef ICWDEBUG 
                    //Dialing is a super special case cuz we wanna skip all the UI and 
                    //go striaght to a dialing error page
                    if (gpWizardState->uCurrentPage == ORD_PAGE_REFSERVDIAL)
                    {
                        // if this page has a special cancel proc, call it
                        if (pPageInfo->CancelProc)
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,pPageInfo->CancelProc(hDlg));
                    }
                    else
                    {
#endif  //ICWDEBUG
                        // default behavior: pop up a message box confirming
                        // the cancel...
                        // ... unless we're serving as an Apprentice, in which case
                        // we should let the Wizard handle things
                        // Display a dialog and allow the user to select modem

#ifndef ICWDEBUG 
                        
                        if ((gpWizardState->uCurrentPage == ORD_PAGE_INTRO) && !GetCompletedBit())
                        {
                            fRet=(BOOL)DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_QUIT),hDlg, CancelCmdProc,0);
                        }
                        else
#endif  //ICWDEBUG
                        fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                                           MB_ICONQUESTION,MB_YESNO |
                                           MB_DEFBUTTON2) == IDYES);                       
                        gfUserCancelled = fRet;
                        if(gfUserCancelled)
                        {
                            // if this page has a special cancel proc, call it
                            if (pPageInfo->CancelProc)
                                fRet = pPageInfo->CancelProc(hDlg);
                            if (gpWizardState->pTapiLocationInfo && (gpWizardState->lLocationID != gpWizardState->lDefaultLocationID))
                            {
                                gpWizardState->pTapiLocationInfo->put_LocationId(gpWizardState->lDefaultLocationID);
                            }
                        }

                        // don't reboot if cancelling
                        gpWizardState->fNeedReboot = FALSE;

                        // return the value thru window data
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
#ifndef ICWDEBUG   
                    }
#endif  //ICWDEBUG
                 
                    return TRUE;
                    break;
                }
                default:
                {
                    // See if the page has a notify proc
                    if (pPageInfo->NotifyProc) 
                    {
                        pPageInfo->NotifyProc(hDlg,wParam,lParam);
                    }
                    break; 
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc) 
            {
                pPageInfo->CmdProc(hDlg, wParam, lParam);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\dialerr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  DIALERR.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

void FillModemList(HWND hDlg)
{
    long lNumModems;
    long lCurrModem;
    long lIndex;
    HWND hWndMdmCmb = GetDlgItem(hDlg, IDC_DIALERR_MODEM);

    ComboBox_ResetContent(hWndMdmCmb);


    // Fill the list with the current set of installed modems
    gpWizardState->pRefDial->get_ModemEnum_NumDevices( &lNumModems );

    //RefDialSignup.ModemEnum_Reset();
    gpWizardState->pRefDial->ModemEnum_Reset( );
    for (lIndex=0; lIndex < lNumModems; lIndex++)
    {
        BSTR bstr = NULL;
        gpWizardState->pRefDial->ModemEnum_Next(&bstr);
        ComboBox_InsertString(hWndMdmCmb, lIndex, W2A(bstr));
        SysFreeString(bstr);
    }

    gpWizardState->pRefDial->get_CurrentModem(&lCurrModem);

    if (lCurrModem != -1)
    {
        ComboBox_SetCurSel(hWndMdmCmb, lCurrModem);
    }
    else
    {
        ComboBox_SetCurSel(hWndMdmCmb, 0);
    }

}

void GetSupportNumber(HWND hDlg)
{
    HWND hwndSupport         = GetDlgItem(hDlg, IDC_SERVERR_HELP);
    BSTR bstrSupportPhoneNum = NULL; 
    TCHAR szFmt [MAX_MESSAGE_LEN*3];

    // Fill in the support number
    gpWizardState->pRefDial->get_SupportNumber(&bstrSupportPhoneNum);
    
    //If no support number could be found this will
    //be null, in which case we don't want to display the
    //support number string
    if(bstrSupportPhoneNum)
    {
        LoadString(g_hInstance, IDS_DIALERR_HELP, szFmt, ARRAYSIZE(szFmt));
        lstrcat(szFmt, W2A(bstrSupportPhoneNum));
        SetWindowText(hwndSupport, szFmt);
        SysFreeString(bstrSupportPhoneNum);
        ShowWindow(hwndSupport, SW_SHOW);
    }
    else
        ShowWindow(hwndSupport, SW_HIDE);
}

/*******************************************************************

  NAME:    DialErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DialErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {
        // Show the phone Number
        BSTR  bstrPhoneNum = NULL; 
        BSTR  bstrErrMsg   = NULL;
        
        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);      
        SetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA, TRUE);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
        SysFreeString(bstrPhoneNum);
        EnableWindow(GetDlgItem(hDlg, IDC_DIALING_PROPERTIES), TRUE);

        // Display the error text message
        gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_TEXT), W2A(bstrErrMsg));
        SysFreeString(bstrErrMsg);

        // Enum Modems, and fill in list.
        FillModemList(hDlg);   

        //Get the support number for the current dlg
        // Currently this is removed from BETA 2
        // GetSupportNumber(hDlg);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_REFDIALERROR;
    }

    return TRUE;
}


/*******************************************************************

  NAME:    DialErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK DialErrorOKProc
(
    HWND hMdmCmb,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    // Initialze status before connecting
    gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bStartRefServDownload   = FALSE;

    // Assume the user has selected a number on this page
    // So we will not do SetupForDialing again next time
    gpWizardState->bDoUserPick          = TRUE;

    if (fForward)
    {
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;

        // Set the new phone Number
        TCHAR    szPhone[MAX_RES_LEN];
        GetWindowText(GetDlgItem(hMdmCmb, IDC_DIALERR_PHONENUMBER), szPhone, sizeof(szPhone));
        gpWizardState->pRefDial->put_DialPhoneNumber(A2W(szPhone));

        // Set the current modem 
        long lCurrModem = ComboBox_GetCurSel(GetDlgItem(hMdmCmb, IDC_DIALERR_MODEM));
        gpWizardState->pRefDial->put_CurrentModem(lCurrModem);
    }
    else
    {
        BOOL bRetVal;
        // Set userpick to FALSE to regenerate connectoid
        gpWizardState->bDoUserPick = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}






/*******************************************************************

  NAME:    DialErrorCmdProc

  SYNOPSIS:  Called when a command is generated from  page

  ENTRY:    hDlg - dialog window
            wParam - wParam
            lParam - lParam
          
  EXIT: returns TRUE 

********************************************************************/

BOOL g_bNotChildDlgUpdate = TRUE;

BOOL CALLBACK DialErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    switch(GET_WM_COMMAND_CMD(wParam, lParam))
    {
        case BN_CLICKED:
        {          
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_CHANGE_NUMBER: 
                {
                    BOOL bRetVal;
                    
                    g_bNotChildDlgUpdate = FALSE;
                    // Pass current modem, because if ISDN modem we need to show different content
                    gpWizardState->pRefDial->ShowPhoneBook(gpWizardState->cmnStateData.dwCountryCode,
                                                           ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_DIALERR_MODEM)),
                                                           &bRetVal);
                    if (bRetVal)
                    {
                        // Show the phone Number as it may be changed after the popup
                        BSTR bstrPhoneNum = NULL; 
                        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                        SysFreeString(bstrPhoneNum);

                        // 10/6/98 vyung 
                        // We decided to remove this support number for beta 2
                        // Get the support number for the current dlg
                        // GetSupportNumber(hDlg);
                        
                        g_bNotChildDlgUpdate = TRUE;
                   }

                    break;
                }
                
                case IDC_DIALING_PROPERTIES:   
                {
                    BOOL bRetVal;

                    g_bNotChildDlgUpdate = FALSE;
                    
                    gpWizardState->pRefDial->ShowDialingProperties(&bRetVal);
                    if (bRetVal)
                    {
                        // Show the phone Number as it may be changed after the popup
                        BSTR    bstrPhoneNum = NULL; 
                        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                        SysFreeString(bstrPhoneNum);

                        // Show the modem as it may be changed after the popup
                        LONG    lCurrModem = 0;
                        gpWizardState->pRefDial->get_CurrentModem(&lCurrModem);
                        if (lCurrModem == -1l)
                        {
                            lCurrModem = 0;
                        }
                        ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_DIALERR_MODEM), lCurrModem);
                        if (gpWizardState->pTapiLocationInfo)
                        {
                            BOOL    bRetVal;
                            BSTR    bstrAreaCode = NULL;
                            DWORD   dwCountryCode;
                            gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
                            gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
                            gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
                            gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
                            lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
                            SysFreeString(bstrAreaCode);
                        }
                        g_bNotChildDlgUpdate = TRUE;
                    }
                    break;
                }
                case IDC_DIAL_HELP:
                {
                    HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
                    break;
                }
                default:
                    break;
            }
            break;
        } 
        case EN_UPDATE:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_DIALERR_PHONENUMBER:
                {
                    if (!GetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA))
                    {
                        //Since when the other popups set this text this event will fire we 
                        //don't disable wanna disable the button when it's them.
                        //more so because a race condition and caos ensues causing a lack of input
                        //while windows figures out what the heck is going on
                        if(g_bNotChildDlgUpdate)
                            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_PROPERTIES), FALSE);
                    }
                    SetWindowLongPtr(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), GWLP_USERDATA, FALSE);
                }
            }
        }     
        default:
            break;
    } // End of switch

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwhelp.cpp ===
#include "pre.h"


// Include the interface file for the ICWHELP Dll
#include "..\inc\icwhelp_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwconn1.cpp ===
//**********************************************************************
// File name: connwiz.cpp
//
//      Main source file for the Internet Connection Wizard '98
//
// Functions:
//
//      WinMain         - Program entry point
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"
#include "icwextsn.h"
#ifndef ICWDEBUG
#include "tutor.h"
#endif //ICWDEBUG
#include "iimgctx.h"
#include "icwcfg.h"
#include <stdio.h>
#include "tchar.h"
#include <netcon.h>

// External functions
#ifdef DEBUG
extern void DoDesktopChanges(HINSTANCE hAppInst);
#endif //DEBUG

extern void UpdateDesktop(HINSTANCE hAppInst);
extern void UpdateWelcomeRegSetting(BOOL bSetBit);
extern void UndoDesktopChanges(HINSTANCE   hAppInst);
extern BOOL WasNotUpgrade();
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern BOOL SuperClassICWControls(void);
extern BOOL RemoveICWControlsSuperClass(void);
extern BOOL IsNT5();
extern BOOL IsNT();
extern BOOL IsWhistler();

// local function prototypes
BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

static BOOL 
CheckOobeInfo(
    OUT    LPTSTR pszOobeSwitch,
    OUT    LPTSTR pszISPApp);

static LONG
MakeBold (
    IN HWND hwnd,
    IN BOOL fSize,
    IN LONG lfWeight);

static LONG
ReleaseBold(
    IN HWND hwnd);

static VOID 
StartNCW(
    IN LPTSTR szShellNext,
    IN LPTSTR szShellNextParams);

static VOID 
StartOOBE(
    IN LPTSTR pszCmdLine,
    IN LPTSTR pszOOBESwitch);

static VOID 
StartISPApp(
    IN LPTSTR pszISPPath,
    IN LPTSTR pszCmdLine);

static BOOL
MyExecute(
    IN LPTSTR pszCmdLine);

INT_PTR CALLBACK 
ChooseWizardDlgProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam);


// Return values of ChooseWizardDlgProc
#define RUNWIZARD_CANCEL      0
#define RUNWIZARD_NCW         1
#define RUNWIZARD_OOBE        2

#define ICW_CFGFLAGS_NONCW    (ICW_CFGFLAG_IEAKMODE |\
                               ICW_CFGFLAG_BRANDED |\
                               ICW_CFGFLAG_SBS |\
                               ICW_CFGFLAG_PRODCODE_FROM_CMDLINE |\
                               ICW_CFGFLAG_OEMCODE_FROM_CMDLINE |\
                               ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS)

//Branding file default names
#define BRANDING_DEFAULT_HTML                  TEXT("BRANDED.HTM")
#define BRANDING_DEFAULT_HEADER_BMP            TEXT("BRANDHDR.BMP")
#define BRANDING_DEFAULT_WATERMARK_BMP         TEXT("BRANDWTR.BMP")
#define ICW_NO_APP_TITLE                       TEXT("-1")

// Definitions for command line parameters

#define OOBE_CMD                               TEXT("/oobe")

#define PRECONFIG_CMD                          TEXT("/preconfig")
#define OFFLINE_CMD                            TEXT("/offline")
#define LOCAL_CMD                              TEXT("/local")
#define MSN_CMD                                TEXT("/xicw")

#define ICW_OOBE_TITLE                         TEXT("icwoobe.exe")
#define ICW_APP_TITLE                          TEXT("icwconn1.exe")
#define OOBE_APP_TITLE                         TEXT("msoobe.exe")
#define OOBE_MSOBMAINDLL                       TEXT("msobmain.dll")

static const TCHAR cszSignup[]                 = TEXT("Signup");
static const TCHAR cszISPSignup[]              = TEXT("ISPSignup");
static const TCHAR cszISPSignupApp[]           = TEXT("ISPSignupApp");

static const TCHAR cszOOBEINFOINI[]            = TEXT("oobeinfo.ini");
static const TCHAR cszNone[]                   = TEXT("None");
static const TCHAR cszMSN[]                    = TEXT("MSN");
static const TCHAR cszOffline[]                = TEXT("Offline");
static const TCHAR cszPreconfig[]              = TEXT("preconfig");
static const TCHAR cszLocal[]                  = TEXT("local");

//static const TCHAR cszMSNIconKey[]             = TEXT("CLSID\\{88667D10-10F0-11D0-8150-00AA00BF8457}");
static const TCHAR cszMSNIconKey[]               = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\explorer\\Desktop\\NameSpace\\{88667D10-10F0-11D0-8150-00AA00BF8457}");


#pragma data_seg(".data")

// Global state vars

#ifndef ICWDEBUG
CICWTutorApp*   g_pICWTutorApp; 
#endif  //ICWDEBUG

INT             _convert;               // For string conversion
HINSTANCE       g_hInstance;
UINT            g_uICWCONNUIFirst;
UINT            g_uICWCONNUILast; 

BOOL g_bUserIsAdmin          = FALSE;
BOOL g_bUserIsIEAKRestricted = FALSE;
BOOL g_bRetProcessCmdLine    = FALSE;
BOOL g_OEMOOBE               = FALSE;

const TCHAR c_szOEMCustomizationDir[]  = TEXT("ICW");
const TCHAR c_szOEMCustomizationFile[] = TEXT("OEMCUST.INI");
CICWApp         *g_pICWApp = NULL;
WNDPROC         g_lpfnOldWndProc = NULL;

WIZARDSTATE*    gpWizardState        = NULL;   // pointer to global wizard state struct
CICWExtension*  g_pCICWExtension     = NULL;
CICWExtension*  g_pCINETCFGExtension = NULL;       
DWORD*          g_pdwDialogIDList    = NULL;
HANDLE          g_hMapping           = NULL;
DWORD           g_dwDialogIDListSize = 0;
BOOL            g_bRunDefaultHtm     = FALSE;  //BOOL the will force IE to launch even though shell next is NULL
BOOL            g_fICWCONNUILoaded   = FALSE;
BOOL            g_fINETCFGLoaded     = FALSE;
BOOL            g_bHelpShown         = FALSE;
BOOL            gfQuitWizard         = FALSE;  // global flag used to signal that we want to terminate the wizard ourselves
BOOL            gfUserCancelled      = FALSE;  // global flag used to signal that the user cancelled
BOOL            gfUserBackedOut      = FALSE;  // global flag used to signal that the user pressed Back on the first page
BOOL            gfUserFinished       = FALSE;  // global flag used to signal that the user pressed Finish on the final page
BOOL            gfBackedUp           = FALSE;  // Added to preserve the REBOOT state from conn1 -> manual and manual -> conn1 - MKarki
BOOL            gfReboot             = FALSE;  // DJM BUGBUG:  We should only need 1 of these
BOOL            g_bReboot            = FALSE;
BOOL            g_bRunOnce           = FALSE;
BOOL            g_bShortcutEntry     = FALSE;
BOOL            g_bNewIspPath        = TRUE;
BOOL            g_bSkipIntro         = FALSE;
BOOL            g_bAutoConfigPath    = FALSE;
BOOL            g_bManualPath        = FALSE;
BOOL            g_bLanPath           = FALSE;
BOOL            g_bAllowCancel       = FALSE;
TCHAR*          g_pszCmdLine         = NULL;
BOOL            g_bDebugOEMCustomization = FALSE;

//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

#ifdef ICWDEBUG 
PAGEINFO PageInfo[EXE_NUM_WIZARD_PAGES] =
{
    { IDD_ICWDEBUG_OFFER,    FALSE, DebugOfferInitProc,    NULL, DebugOfferOKProc,    DebugOfferCmdProc,    NULL, DebugOfferNotifyProc, IDS_ICWDEBUG_OFFER_TITLE,    0, 0, NULL, NULL},
    { IDD_ICWDEBUG_SETTINGS, FALSE, DebugSettingsInitProc, NULL, DebugSettingsOKProc, DebugSettingsCmdProc, NULL, NULL,                 IDS_ICWDEBUG_SETTINGS_TITLE, 0, 0, NULL, NULL},
    { IDD_PAGE_END,          FALSE, EndInitProc,           NULL, EndOKProc,           NULL,                 NULL, NULL,                 0,                           0, 0, NULL, NULL}
};
#else //!def ICWDEBUG
PAGEINFO PageInfo[EXE_NUM_WIZARD_PAGES] =
{
    { IDD_PAGE_INTRO,         FALSE,   IntroInitProc,          NULL,                       IntroOKProc,            IntroCmdProc,        NULL,                    NULL, 0,                         0, 0, NULL, NULL },
    { IDD_PAGE_MANUALOPTIONS, FALSE,   ManualOptionsInitProc,  NULL,                       ManualOptionsOKProc,    ManualOptionsCmdProc,NULL,                    NULL, IDS_MANUALOPTS_TITLE,      0, 0, NULL, NULL  },
    { IDD_PAGE_AREACODE,      FALSE,   AreaCodeInitProc,       NULL,                       AreaCodeOKProc,         AreaCodeCmdProc,     NULL,                    NULL, IDS_STEP1_TITLE,           0, IDA_AREACODE, NULL, NULL  },
    { IDD_PAGE_REFSERVDIAL,   FALSE,   RefServDialInitProc,    RefServDialPostInitProc,    RefServDialOKProc,      NULL,                RefServDialCancelProc,   NULL, IDS_STEP1_TITLE,           0, 0, NULL, NULL  },
    { IDD_PAGE_END,           FALSE,   EndInitProc,            NULL,                       EndOKProc,              NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  },
    { IDD_PAGE_ENDOEMCUSTOM,  FALSE,   EndInitProc,            NULL,                       EndOKProc,              NULL,                NULL,                    NULL, IDS_OEMCUST_END_TITLE,     0, IDA_ENDOEMCUSTOM, NULL, NULL  },
    { IDD_PAGE_ENDOLS,        FALSE,   EndOlsInitProc,         NULL,                       NULL,                   NULL,                NULL,                    NULL, IDS_ENDOLS_TITLE,          0, 0, NULL, NULL  },
    { IDD_PAGE_DIALERROR,     FALSE,   DialErrorInitProc,      NULL,                       DialErrorOKProc,        DialErrorCmdProc,    NULL,                    NULL, IDS_DIALING_ERROR_TITLE,   0, IDA_DIALERROR, NULL, NULL  },
    { IDD_PAGE_MULTINUMBER,   FALSE,   MultiNumberInitProc,    NULL,                       MultiNumberOKProc,      NULL,                NULL,                    NULL, IDS_STEP1_TITLE,           0, 0, NULL, NULL  },
    { IDD_PAGE_SERVERROR,     FALSE,   ServErrorInitProc,      NULL,                       ServErrorOKProc,        ServErrorCmdProc,    NULL,                    NULL, IDS_SERVER_ERROR_TITLE,    0, 0, NULL, NULL  },
    { IDD_PAGE_BRANDEDINTRO,  TRUE,    BrandedIntroInitProc,   BrandedIntroPostInitProc,   BrandedIntroOKProc,     NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  },
    { IDD_PAGE_INTRO2,        FALSE,   IntroInitProc,          NULL,                       IntroOKProc,            NULL,                NULL,                    NULL, IDS_STEP1_TITLE,           0, IDA_INTRO2, NULL, NULL  },
    { IDD_PAGE_DEFAULT,       FALSE,   ISPErrorInitProc,       NULL,                       NULL,                   NULL,                NULL,                    NULL, NULL,                      0, 0, NULL, NULL  },
    { IDD_PAGE_SBSINTRO,      FALSE,   SbsInitProc,            NULL,                       SbsIntroOKProc,         NULL,                NULL,                    NULL, 0,                         0, 0, NULL, NULL  }
};
#endif //ICWDEBUG

// Global Command Line Parameters
TCHAR g_szOemCode         [MAX_PATH+1]              = TEXT("");
TCHAR g_szProductCode     [MAX_PATH+1]              = TEXT("");
TCHAR g_szPromoCode       [MAX_PROMO]               = TEXT("");
TCHAR g_szShellNext       [MAX_PATH+1]              = TEXT("\0nogood");
TCHAR g_szShellNextParams [MAX_PATH+1]              = TEXT("\0nogood");

// File names used for branded operation
TCHAR g_szBrandedHTML         [MAX_PATH] = TEXT("\0");
TCHAR g_szBrandedHeaderBMP    [MAX_PATH] = TEXT("\0");
TCHAR g_szBrandedWatermarkBMP [MAX_PATH] = TEXT("\0");

#pragma data_seg()

//+----------------------------------------------------------------------------
//
//    Function:    IsOemVer
//
//    Synopsis:    This function will determine if the machine is an OEM system.
//                
//    Arguments:   None
//
//    Returns:     TRUE - OEM system; FALSE - Retail Win 98 OSR
//
//    History:     3/26/99    JCohen    Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI * ISOEMVER)();

BOOL IsOemVer()
{
    BOOL bOEMVer = FALSE;
    TCHAR       szOOBEPath [MAX_PATH]       = TEXT("\0");
    TCHAR       szOOBEDir [MAX_PATH]        = TEXT("\0");
    ISOEMVER    lpfnIsOEMVer                = NULL;
    HINSTANCE   hMsobMainDLL                = NULL;


    //Try and get the path from the OEM file
    GetSystemDirectory(szOOBEPath, MAX_PATH);
    lstrcat(szOOBEPath, TEXT("\\oobe"));

    lstrcat(szOOBEPath, TEXT("\\"));

    lstrcat(szOOBEPath, OOBE_MSOBMAINDLL);

    hMsobMainDLL = LoadLibrary(szOOBEPath);

    if (hMsobMainDLL)
    {
        lpfnIsOEMVer = (ISOEMVER)GetProcAddress(hMsobMainDLL, "IsOemVer");
        if (NULL != lpfnIsOEMVer)
        {
            bOEMVer = lpfnIsOEMVer();
        }
        FreeLibrary(hMsobMainDLL);
    }

    return (bOEMVer);
}

//+----------------------------------------------------------------------------
//
//    Function:    CheckOobeInfo
//
//    Synopsis:    This function determines if the OOBE/ISP App should be run by
//                 checking %windir%\system32\oobe\oobeinfo.ini.
//                
//    Arguments:   pszOobeSwitch  - OOBE additional command line arguments
//                                  assume size is at least MAX_PATH characters
//
//                 pszISPApp      - output empty string unless ISP App is found;
//                                  assume size is at least MAX_PATH characters
//
//    Returns:     TRUE - OOBE/ISP App should run; FALSE - otherwise
//
//    History:     25/11/99    Vyung    Created
//
//-----------------------------------------------------------------------------
BOOL
CheckOobeInfo(
    OUT    LPTSTR pszOobeSwitch,
    OUT    LPTSTR pszISPApp)
{
    BOOL  bLaunchOOBE = TRUE;
    TCHAR szOOBEInfoINIFile[MAX_PATH] = TEXT("\0");
    TCHAR szISPSignup[MAX_PATH] = TEXT("\0");
    TCHAR szOOBEPath [MAX_PATH] = TEXT("\0");

    pszISPApp[0] = TEXT('\0');
    pszOobeSwitch[0] = TEXT('\0');
    
    GetSystemDirectory(szOOBEPath, MAX_PATH);
    lstrcat(szOOBEPath, TEXT("\\oobe"));
    SearchPath(szOOBEPath, cszOOBEINFOINI, NULL, MAX_PATH, szOOBEInfoINIFile, NULL);  
    GetPrivateProfileString(cszSignup,
                            cszISPSignup,
                            TEXT(""),
                            szISPSignup,
                            MAX_PATH,
                            szOOBEInfoINIFile);

    if (0 == lstrcmpi(szISPSignup, cszNone))
    {
        bLaunchOOBE = FALSE;
    }
    else if (0 == lstrcmpi(szISPSignup, cszMSN))
    {
        if (IsWhistler())
        {            
            GetPrivateProfileString(cszSignup,
                                    cszISPSignupApp,
                                    TEXT(""),
                                    pszISPApp,
                                    MAX_PATH,
                                    szOOBEInfoINIFile);

            if (pszISPApp[0] == TEXT('\0'))
            {
                lstrcpy(pszOobeSwitch, MSN_CMD);
            }
        }
        else
        {
            HKEY hKey = 0;
            RegOpenKey(HKEY_LOCAL_MACHINE,cszMSNIconKey,&hKey);
            if (hKey)
            {
                RegCloseKey(hKey);
            }
            else
            {
                bLaunchOOBE = FALSE;
            }
        }
    }
    else if (0 == lstrcmpi(szISPSignup, cszOffline))
    {
        lstrcpy(pszOobeSwitch, OFFLINE_CMD);
    }
    else if (0 == lstrcmpi(szISPSignup, cszPreconfig))
    {
        bLaunchOOBE = FALSE;
    }
    else if (0 == lstrcmpi(szISPSignup, cszLocal))
    {
        lstrcpy(pszOobeSwitch, LOCAL_CMD);
    }

    return bLaunchOOBE;    
}        


// ############################################################################
//
// 5/23/97 jmazner Olympus #4157
// Spaces are returned as a token
// modified to consider anything between paired double quotes to be a single token
// For example, the following consists of 9 tokens (4 spaces and 5 cmds)
//
//        first second "this is the third token" fourth "fifth"
//
// The quote marks are included in the returned string (pszOut)
void GetCmdLineToken(LPTSTR *ppszCmd, LPTSTR pszOut)
{
    LPTSTR  c;
    int     i = 0;
    BOOL    fInQuote = FALSE;
    
    c = *ppszCmd;

    pszOut[0] = *c;
    if (!*c) 
        return;
    if (*c == ' ') 
    {
        pszOut[1] = '\0';
        *ppszCmd = c+1;
        return;
    }
    else if( '"' == *c )
    {
        fInQuote = TRUE;
    }

NextChar:
    i++;
    c++;
    if( !*c || (!fInQuote && (*c == ' ')) )
    {
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else if( fInQuote && (*c == '"') )
    {
        fInQuote = FALSE;
        pszOut[i] = *c;
        
        i++;
        c++;
        pszOut[i] = '\0';
        *ppszCmd = c;
        return;
    }
    else
    {
        pszOut[i] = *c;
        goto NextChar;
    }   
}

BOOL GetFilteredCmdLineToken(LPTSTR *ppszCmd, LPTSTR pszOut)
{
    if(**ppszCmd != '/')
    {
        GetCmdLineToken(ppszCmd, pszOut);
        return TRUE;
    }
    return FALSE;
}

#define INETCFG_ISSMARTSTART "IsSmartStart"
#define INETCFG_ISSMARTSTARTEX "IsSmartStartEx"
#define SMART_RUNICW TRUE
#define SMART_QUITICW FALSE


//+----------------------------------------------------------------------------
//
//    Function:    MyIsSmartStartEx
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    25/11/97    Vyung    Created
//
//-----------------------------------------------------------------------------
BOOL MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen)
{
    BOOL                bRC = SMART_RUNICW;
    PFNIsSmartStart     fp = NULL;
    HINSTANCE           hInetCfg;
    
    // Load DLL and API
    hInetCfg = LoadLibrary(TEXT("inetcfg.dll"));
    if (hInetCfg)
    {
        if (NULL == lpszConnectionName)
        {
            PFNIsSmartStart   fp = NULL;
            if (fp = (PFNIsSmartStart) GetProcAddress(hInetCfg,INETCFG_ISSMARTSTART))
            {
                // Call smart start 
                bRC = (BOOL)fp();

            }
        }
        else
        {
            PFNIsSmartStartEx   fp = NULL;
            if (fp = (PFNIsSmartStartEx) GetProcAddress(hInetCfg,INETCFG_ISSMARTSTARTEX))
            {
                // Call smart start 
                bRC = (BOOL)fp(lpszConnectionName, dwBufLen);

            }
        }
        FreeLibrary(hInetCfg);    
    }
            
    return bRC;
}

// Used below to load a bitmap file
void CALLBACK ImgCtx_Callback(void* pIImgCtx,void* pfDone)
{
    ASSERT(pfDone);

    *(BOOL*)pfDone = TRUE;
    return;
}

//+----------------------------------------------------------------------------
//
// This function will load a specified branded bitmap
//
//-----------------------------------------------------------------------------

#define BRANDED_WATERMARK   1
#define BRANDED_HEADER      2

HBITMAP LoadBrandedBitmap
(
    int   iType
)
{
    HRESULT     hr;
    IImgCtx     *pIImgCtx;
    BSTR        bstrFile;
    TCHAR       szURL[INTERNET_MAX_URL_LENGTH];
    HBITMAP     hbm = NULL;
        
    // Create an ImgCtx object to load/convert the bitmap
    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    if (FAILED(hr))
        return NULL;

    ASSERT(pIImgCtx);

    if (iType == BRANDED_WATERMARK)
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedWatermarkBMP);        
    else
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedHeaderBMP);        
    
    // "Download" the image
    bstrFile = A2W(szURL);
    hr = pIImgCtx->Load(bstrFile, 0);
    if (SUCCEEDED(hr))
    {
        ULONG fState;
        SIZE  sz;

        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        // If we are not complete, then wait for the download to complete
        if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
        {
            BOOL fDone = FALSE;

            hr = pIImgCtx->SetCallback(ImgCtx_Callback, &fDone);
            if (SUCCEEDED(hr))
            {
                hr = pIImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);
                if (SUCCEEDED(hr))
                {
                    MSG msg;
                    BOOL fMsg;

                    // HACK: restrict the message pump to those messages we know that URLMON and
                    // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                    // HACK: windows we shouldn't be pumping right now...
                    while(!fDone )
                    {
                        fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                        if (!fMsg)
                            fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                        if (!fMsg)
                        {
                            // go to sleep until we get a new message....
                            WaitMessage();
                            continue;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pIImgCtx->Disconnect();
        }
        
        // Get the Final state info, incase we just had to loop above
        hr = pIImgCtx->GetStateInfo(&fState, &sz, TRUE);
        if (SUCCEEDED(hr) && (fState & IMGLOAD_COMPLETE))
        {
            // OK, create our compatible bitmap, and blt in the one just loaded
            
            HDC hdcScreen = GetDC(NULL);
            if (hdcScreen)
            {
                if (NULL != (hbm = CreateCompatibleBitmap(hdcScreen, sz.cx, sz.cy)))
                {
                    HDC hdcImgDst = CreateCompatibleDC(NULL);
                    if (hdcImgDst)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcImgDst, hbm);
                
                        hr = pIImgCtx->StretchBlt(hdcImgDst, 
                                                  0, 
                                                  0, 
                                                  sz.cx, 
                                                  sz.cy, 
                                                  0, 
                                                  0,
                                                  sz.cx, 
                                                  sz.cy, 
                                                  SRCCOPY);
                        SelectObject(hdcImgDst, hbmOld);
                        DeleteDC(hdcImgDst);
                        
                        if (FAILED(hr))
                        {
                            DeleteObject(hbm);
                            hbm = NULL;
                        }
                    }
                    else
                    {
                        DeleteObject(hbm);
                        hbm = NULL;
                    }                                                  
                }
                
                DeleteDC(hdcScreen);
            }                
        }
    }    

    pIImgCtx->Release();

    return (hbm);
}

//+----------------------------------------------------------------------------
//
// This function will check to see if OEM branding is allowed, and if so, then did the OEM provide
// the necessary branding pieces
// TRUE means the OEM wants branding AND is allowed to brand
// FALSE means no OEM branding will be done
//
//-----------------------------------------------------------------------------
BOOL bCheckForOEMBranding
(
    void
)
{
    BOOL    bRet = FALSE;
    HANDLE  hFile;
        
    // Check for required branding files.  To brand an OEM needs to supply a first
    // page HTML file, and optionally, a header bitmap, and a final page graphic (watermark)

    hFile = CreateFile((LPCTSTR)g_szBrandedHTML,
                        GENERIC_READ, 
                        FILE_SHARE_READ,
                        0, 
                        OPEN_EXISTING, 
                        0, 
                        0);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        bRet = TRUE;
        CloseHandle(hFile);
    }            
    return  bRet;
}

BOOL ValidateFile(TCHAR* pszFile)
{
    ASSERT(pszFile);
  
    DWORD dwFileType = GetFileAttributes(pszFile);

    if ((dwFileType == 0xFFFFFFFF) || (dwFileType == FILE_ATTRIBUTE_DIRECTORY))
        return FALSE;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function:    SetDefaultProductCode
//
//    Arguments:    pszBuffer - buffer that will contain the default product code
//                 dwLen - size of pszBuffer
//
//    Returns:    ERROR_SUCCESS if it succeded
//
//    History:    1-20-96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD SetDefaultProductCode (LPTSTR pszBuffer, DWORD dwLen)
{
    DWORD dwRet = ERROR_SUCCESS, dwType = 0;
    HKEY hkey = NULL;
    Assert(pszBuffer);

    // Open key
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Internet Connection Wizard"),&hkey);
    if (ERROR_SUCCESS != dwRet)
        goto SetDefaultProductCodeExit;

    // Read key
    dwRet = RegQueryValueEx(hkey,TEXT("Default Product Code"),NULL,
        &dwType,(LPBYTE)pszBuffer,&dwLen);
    if (ERROR_SUCCESS != dwRet)
        goto SetDefaultProductCodeExit;

SetDefaultProductCodeExit:
    if (NULL != hkey)
        RegCloseKey(hkey);
    if (ERROR_SUCCESS != dwRet)
        pszBuffer[0] = '\0';
        
    return dwRet;
}

//GetShellNext
//
// 5/21/97    jmazner    Olympus #4157
// usage: /shellnext c:\path\executeable [parameters]
// the token following nextapp will be shellExec'd at the
// end of the "current" path.  It can be anything that the shell
// knows how to handle -- an .exe, a URL, etc..  If executable
// name contains white space (eg: c:\program files\foo.exe), it
// should be wrapped in double quotes, "c:\program files\foo.exe"
// This will cause us to treat it as a single token.
//
// all consecutive subsequent tokens will
// be passed to ShellExec as the parameters until a token is
// encountered of the form /<non-slash character>.  That is to say,
// the TCHARacter combination // will be treated as an escape character
//
// this is easiest to explain by way of examples.
//
// examples of usage:
//
//    icwconn1.exe /shellnext "C:\prog files\wordpad.exe" file.txt
//    icwconn1.exe /prod IE /shellnext msimn.exe /promo MCI
//  icwconn1.exe /shellnext msimn.exe //START_MAIL /promo MCI
//
// the executeable string and parameter string are limited to
// a length of MAX_PATH
//
void GetShellNextToken(LPTSTR szOut, LPTSTR szCmdLine)
{
    if (lstrcmpi(szOut,SHELLNEXT_CMD)==0)
    {
        // next token is expected to be white space
        GetCmdLineToken(&szCmdLine,szOut);

        if (szOut[0])
        {
            ZeroMemory(g_szShellNext,sizeof(g_szShellNext));
            ZeroMemory(g_szShellNextParams,sizeof(g_szShellNextParams));

            //this should be the thing to ShellExec
            if(GetFilteredCmdLineToken(&szCmdLine,szOut))
            {
                // watch closely, this gets a bit tricky
                //
                // if this command begins with a double quote, assume it ends
                // in a matching quote.  We do _not_ want to store the
                // quotes, however, since ShellExec doesn't parse them out.
                if( '"' != szOut[0] )
                {
                    // no need to worry about any of this quote business
                    lstrcpy( g_szShellNext, szOut );
                }
                else
                {
                    lstrcpy( g_szShellNext, &szOut[1] );
                    g_szShellNext[lstrlen(g_szShellNext) - 1] = '\0';
                }

                // now read in everything up to the next command line switch
                // and consider it to be the parameter.  Treat the sequence
                // "//" as an escape sequence, and allow it through.
                // Example:
                //        the token /whatever is considered to be a switch to
                //        icwconn1, and thus will break us out of the whle loop.
                //
                //        the token //something is should be interpreted as a
                //        command line /something to the the ShellNext app, and
                //        should not break us out of the while loop.
                GetCmdLineToken(&szCmdLine,szOut);
                while( szOut[0] )
                {
                    if( '/' == szOut[0] )
                    {
                        if( '/' != szOut[1] )
                        {
                            // it's not an escape sequence, so we're done
                            break;
                        }
                        else
                        {
                            // it is an escape sequence, so store it in
                            // the parameter list, but remove the first /
                            lstrcat( g_szShellNextParams, &szOut[1] );
                        }
                    }
                    else
                    {
                        lstrcat( g_szShellNextParams, szOut );
                    }
    
                    GetCmdLineToken(&szCmdLine,szOut);
                }
            }
        }
    }
}

// Process the incomming command line
BOOL  ProcessCommandLine
(
    HINSTANCE   hInstance,
    LPTSTR       szCmdLine
)
{
    TCHAR szOut[MAX_PATH];    
    BOOL  bOOBESwitch = FALSE;
    
    // Get the first token
    GetCmdLineToken(&szCmdLine,szOut);
    while (szOut[0])
    {
        if (g_OEMOOBE)
        {
            if((0 == lstrcmpi(szOut, OOBE_CMD)) ||
               (0 == lstrcmpi(szOut, SHELLNEXT_CMD)))
            {
                bOOBESwitch = TRUE;
                break; // Stop processing command line, launch oobe
            }
        }

        if (lstrcmpi(&szOut[0],OEMCODE_CMD)==0)
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szOemCode,sizeof(g_szOemCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szOemCode))
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_OEMCODE_FROM_CMDLINE;
            }
        }

        if (lstrcmpi(&szOut[0],PRODCODE_CMD)==0)
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szProductCode,sizeof(g_szProductCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szProductCode))
                {
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PRODCODE_FROM_CMDLINE;

                    //Is it for sbs???
                    if (!lstrcmpi(g_szProductCode, PRODCODE_SBS))
                        gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SBS;
                }
            }
        }

        if (0 == lstrcmpi(szOut,PROMO_CMD))
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (szOut[0])
            {
                ZeroMemory(g_szPromoCode,sizeof(g_szPromoCode));
                if(GetFilteredCmdLineToken(&szCmdLine,g_szPromoCode))
                    gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE;
            }
        }

        if (0 == lstrcmpi(szOut,SKIPINTRO_CMD))
        {
            g_bSkipIntro = TRUE;
        }

        if (0 == lstrcmpi(szOut,SMARTREBOOT_CMD))
        {
            GetCmdLineToken(&szCmdLine,szOut);
            if (GetFilteredCmdLineToken(&szCmdLine,szOut))
            {            
                g_bNewIspPath = FALSE;
            
                if (0 == lstrcmpi(szOut, NEWISP_SR))
                    g_bNewIspPath = TRUE;
            
                if (0 == lstrcmpi(szOut, AUTO_SR))
                    g_bAutoConfigPath = TRUE;
            
                if (0 == lstrcmpi(szOut, MANUAL_SR))
                    g_bManualPath = TRUE;

                if (0 == lstrcmpi(szOut, LAN_SR))
                    g_bLanPath = TRUE;
            }
        }

        //
        // Check for the smart start command line switch
        //
        if (0 == lstrcmpi(szOut,SMARTSTART_CMD))
        {
            //
            // If we shouldn't be running, quit.
            //
            if (SMART_QUITICW == MyIsSmartStartEx(NULL, 0))
            {
                // Set completed key if SmartStart is already configured
                SetICWComplete();
                // Set the welcome show bit
                UpdateWelcomeRegSetting(TRUE);
                
                return FALSE;       // Bail out of ICWCONN1.EXE
            }
        }

        //
        // 5/21/97    jmazner    Olympus #4157
        // usage: /shellnext c:\path\executeable [parameters]
        // the token following nextapp will be shellExec'd at the
        // end of the "current" path.  It can be anything that the shell
        // knows how to handle -- an .exe, a URL, etc..  If executable
        // name contains white space (eg: c:\program files\foo.exe), it
        // should be wrapped in double quotes, "c:\program files\foo.exe"
        // This will cause us to treat it as a single token.
        //
        // all consecutive subsequent tokens will
        // be passed to ShellExec as the parameters until a token is
        // encountered of the form /<non-slash character>.  That is to say,
        // the TCHARacter combination // will be treated as an escape character
        //
        // this is easiest to explain by way of examples.
        //
        // examples of usage:
        //
        //    icwconn1.exe /shellnext "C:\prog files\wordpad.exe" file.txt
        //    icwconn1.exe /prod IE /shellnext msimn.exe /promo MCI
        //  icwconn1.exe /shellnext msimn.exe //START_MAIL /promo MCI
        //
        // the executeable string and parameter string are limited to
        // a length of MAX_PATH
        //
        GetShellNextToken(szOut, szCmdLine);

#ifdef DEBUG
        if (lstrcmpi(szOut, ICON_CMD)==0)
        {
            DoDesktopChanges(hInstance);
            return(FALSE);
        }
#endif //DEBUG

        // If there is a /desktop command line arg, then do the
        // processing and bail
        if (lstrcmpi(szOut, UPDATEDESKTOP_CMD)==0)
        {
            if(g_bUserIsAdmin && !g_bUserIsIEAKRestricted)
               UpdateDesktop(hInstance);
           
            return(FALSE);
        }
       
        // If there is a /restoredesktop command line arg, then do the
        // processing and bail
        if (lstrcmpi(szOut, RESTOREDESKTOP_CMD)==0)
        {
            UndoDesktopChanges(hInstance);
            return(FALSE);
        }

        //Do we need to go into IEAK mode?        
        if (lstrcmpi(szOut, ICW_IEAK_CMD)==0)
        {   
            TCHAR szIEAKFlag      [2]          = TEXT("\0");
            TCHAR szIEAKStr       [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandHTML     [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandHeadBMP  [MAX_PATH*2] = TEXT("\0");
            TCHAR szBrandWaterBMP [MAX_PATH*2] = TEXT("\0");
            TCHAR szIEAKBillHtm   [MAX_PATH*2] = TEXT("\0");
            TCHAR szIEAKPayCsv    [MAX_PATH*2] = TEXT("\0");
            TCHAR szDefIspName    [MAX_PATH]   = TEXT("\0");
            TCHAR szDrive         [_MAX_DRIVE] = TEXT("\0");
            TCHAR szDir           [_MAX_DIR]   = TEXT("\0");
            TCHAR szDefaultTitle  [MAX_PATH*2] = TEXT("\0");

            gpWizardState->cmnStateData.lpfnConfigSys = &ConfigureSystem;

            GetCmdLineToken(&szCmdLine,szOut); //get rid of the space
            if(GetFilteredCmdLineToken(&szCmdLine,szOut))
            {
                //Get the path to the isp file
                lstrcpyn(gpWizardState->cmnStateData.ispInfo.szISPFile,
                         szOut + 1, 
                         lstrlen(szOut) -1);
                
                 //get the branding settings as well...
                 //The HTML page
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_HTML,
                                         TEXT(""), szBrandHTML,
                                         sizeof(szBrandHTML), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);

                 //The wizard title
                 lstrcpy(szDefaultTitle, gpWizardState->cmnStateData.szWizTitle);

                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_TITLE, szDefaultTitle, 
                                         gpWizardState->cmnStateData.szWizTitle, sizeof(gpWizardState->cmnStateData.szWizTitle)*sizeof(TCHAR), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);

                 //The header bitmap
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_HEADER_BMP, TEXT(""), 
                                         szBrandHeadBMP, sizeof(szBrandHeadBMP), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);
                 //The watermark bitmap
                 GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_WATERMARK_BMP, TEXT(""), 
                                         szBrandWaterBMP, sizeof(szBrandWaterBMP), 
                                         gpWizardState->cmnStateData.ispInfo.szISPFile);


                _tsplitpath(gpWizardState->cmnStateData.ispInfo.szISPFile,
                           szDrive,
                           szDir, 
                           NULL, 
                           NULL);
               
                _tmakepath(g_szBrandedHTML,         szDrive, szDir, szBrandHTML,     NULL);
                _tmakepath(g_szBrandedHeaderBMP,    szDrive, szDir, szBrandHeadBMP,  NULL);
                _tmakepath(g_szBrandedWatermarkBMP, szDrive, szDir, szBrandWaterBMP, NULL);

                 //make sure file is valid if not bail
                 if (ValidateFile(g_szBrandedHTML))
                 {
                     //evertyething is cool.. let's set the right flags.
                     gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_IEAKMODE | ICW_CFGFLAG_BRANDED;
            
                    //Look in the isp file and see if they provided an ISP name to display 
                    //for dialing and whatnot
                    //If we can't find this section we'll just use a resource which says
                    //"an Internet service provider"

                    LoadString(hInstance, IDS_DEFAULT_ISPNAME, szDefIspName, sizeof(szDefIspName));

                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_ISPNAME, szDefIspName, 
                                            szIEAKStr, sizeof(szIEAKStr), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);
            
                    if (lstrlen(szIEAKStr) == 0)
                        lstrcpy(szIEAKStr, szDefIspName);

                    lstrcpy(gpWizardState->cmnStateData.ispInfo.szISPName, szIEAKStr);

                    //Look in the isp file and see if they want UserInfo
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_USERINFO, TEXT("0"), 
                                            szIEAKFlag, sizeof(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);
    
                    if ((BOOL)_ttoi(szIEAKFlag))
                    {
                        // Since we are showing the user info page, we may need to
                        // show or hide the company name
                        gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_USERINFO;
                
                       if (GetPrivateProfileInt(ICW_IEAK_SECTION, 
                                             ICW_IEAK_USECOMPANYNAME, 
                                             0, 
                                             gpWizardState->cmnStateData.ispInfo.szISPFile))
                            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_USE_COMPANYNAME;
                                     
                
                    }
                    //Look in the isp file and see if they want billing stuff
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_BILLING, TEXT("0"), 
                                            szIEAKFlag, sizeof(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);

                     if ((BOOL)_ttoi(szIEAKFlag))
                     {
                         //try and get the billing page, if it's not there don't bother
                         //setting the bit.
                         GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_BILLINGHTM, NULL, 
                                                 szIEAKBillHtm, sizeof(szIEAKBillHtm), 
                                                 gpWizardState->cmnStateData.ispInfo.szISPFile);
                
                         if(lstrlen(szIEAKBillHtm) != 0)             
                         {
                             gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_BILL;
                             lstrcpy(gpWizardState->cmnStateData.ispInfo.szBillHtm, szIEAKBillHtm);
                         }
                     }

                    //Look in the isp file and see if they want payment stuff
                    //If we can't find this section it the isp file we'll assume "no". 
                    GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_PAYMENT, NULL, 
                                            szIEAKFlag, sizeof(szIEAKFlag), 
                                            gpWizardState->cmnStateData.ispInfo.szISPFile);

                     if ((BOOL)_ttoi(szIEAKFlag))
                     {   
                         //try and get the payment csv, if it's not there don't bother
                         //setting the bit.
                         GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_PAYMENTCSV, NULL, 
                                                 szIEAKPayCsv, sizeof(szIEAKPayCsv), 
                                                 gpWizardState->cmnStateData.ispInfo.szISPFile);
         
                         if (lstrlen(szIEAKPayCsv) != 0)
                         {
                            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_PAYMENT;
                            lstrcpy(gpWizardState->cmnStateData.ispInfo.szPayCsv, szIEAKPayCsv);
                         }
                     }
             
                    //Get validation flags from the ISP file
                    gpWizardState->cmnStateData.ispInfo.dwValidationFlags = GetPrivateProfileInt(ICW_IEAK_SECTION, 
                                                                        ICW_IEAK_VALIDATEFLAGS, 
                                                                        0xFFFFFFFF, 
                                                                        gpWizardState->cmnStateData.ispInfo.szISPFile);
                 }
            }
        }
        
        // Check to see if we are running in Branded mode.  In this mode, we will allow special
        // OEM tweaks.
        if (lstrcmpi(szOut, BRANDED_CMD)==0)
        {
            TCHAR       szCurrentDir[MAX_PATH];

            //whether or not the ICW "fails" to run in branding mode we do not wan to overide the alloffers value
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;

            GetCurrentDirectory(sizeof(szCurrentDir), szCurrentDir);

            wsprintf (g_szBrandedHTML, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_HTML);        
            wsprintf (g_szBrandedHeaderBMP, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_HEADER_BMP);        
            wsprintf (g_szBrandedWatermarkBMP, TEXT("%s\\%s"), szCurrentDir, BRANDING_DEFAULT_WATERMARK_BMP);        

            // We are in OEM mode, so see if we allow branding
            if (bCheckForOEMBranding())
            {
                gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_BRANDED;
            }
        }

        // Check to see if we are running in run once mode.  In this mode, we will disallow IE check box
        if (0 == lstrcmpi(szOut, RUNONCE_CMD))
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;
            g_bRunOnce = TRUE;
        }
        
        // Check to see if we were run from a shortcut on the desktop
        if (0 == lstrcmpi(szOut, SHORTCUTENTRY_CMD))
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS;
            g_bShortcutEntry = TRUE;
        }
        
        // Check to see if we should debug the OEMCUST.INI file
        if (0 == lstrcmpi(szOut, DEBUG_OEMCUSTOM))
        {
            g_bDebugOEMCustomization = TRUE;
        }
        
        // Eat the next token, it will be null if we are at the end
        GetCmdLineToken(&szCmdLine,szOut);
    }

    g_OEMOOBE = g_OEMOOBE && bOOBESwitch;
    gpWizardState->cmnStateData.bOEMEntryPt = g_bShortcutEntry || g_bRunOnce;
    return(TRUE);    
}

//+----------------------------------------------------------------------------
//
//    Function:    RemoveShellNextFromReg
//
//    Synopsis:    deletes the ShellNext reg key if present. This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
void RemoveShellNextFromReg( void )
{
    HKEY    hkey;
    
    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey, TEXT("ShellNext"));
        RegCloseKey(hkey);
    }        
}

//+----------------------------------------------------------------------------
//
//    Function:    GetShellNextFromReg
//
//    Synopsis:    Reads the ShellNext key from the registry, and then parses it
//                into a command and parameter.  This key is set by
//                SetShellNext in inetcfg.dll in conjunction with
//                CheckConnectionWizard.
//
//    Arguments:    none
//
//    Returns:    none
//
//    History:    jmazner 7/9/97 Olympus #9170
//
//-----------------------------------------------------------------------------
BOOL GetShellNextFromReg
( 
    LPTSTR lpszCommand, 
    LPTSTR lpszParams
)
{
    BOOL    fRet                      = TRUE;
    TCHAR   szShellNextCmd [MAX_PATH] = TEXT("\0");
    DWORD   dwShellNextSize           = sizeof(szShellNextCmd);
    LPTSTR  lpszTemp                  = NULL;
    HKEY    hkey                      = NULL;
    
    if( !lpszCommand || !lpszParams )
    {
        return FALSE;
    }

    if ((RegOpenKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, 
                            TEXT("ShellNext"), 
                            NULL, 
                            NULL, 
                            (BYTE *)szShellNextCmd, 
                            (DWORD *)&dwShellNextSize) != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto GetShellNextFromRegExit;
        }
    }
    else
    {
        fRet = FALSE;
        goto GetShellNextFromRegExit;
    }

    //
    // This call will parse the first token into lpszCommand, and set szShellNextCmd
    // to point to the remaining tokens (these will be the parameters).  Need to use
    // the pszTemp var because GetCmdLineToken changes the pointer's value, and we
    // need to preserve lpszShellNextCmd's value so that we can GlobalFree it later.
    //
    lpszTemp = szShellNextCmd;
    GetCmdLineToken( &lpszTemp, lpszCommand );

    lstrcpy( lpszParams, lpszTemp );

    //
    // it's possible that the shellNext command was wrapped in quotes for
    // parsing purposes.  But since ShellExec doesn't understand quotes,
    // we now need to remove them.
    //
    if( '"' == lpszCommand[0] )
    {
        //
        // get rid of the first quote
        // note that we're shifting the entire string beyond the first quote
        // plus the terminating NULL down by one byte.
        //
        memmove( lpszCommand, &(lpszCommand[1]), lstrlen(lpszCommand) );

        //
        // now get rid of the last quote
        //
        lpszCommand[lstrlen(lpszCommand) - 1] = '\0';
    }

GetShellNextFromRegExit:
    if (hkey)
        RegCloseKey(hkey);
    return fRet;
}

void StartIE
(
    LPTSTR   lpszURL
)
{
    TCHAR    szIEPath[MAX_PATH];
    HKEY    hkey;
    
    // first get the app path
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_APPPATHS,
                     0,
                     KEY_READ,
                     &hkey) == ERROR_SUCCESS)
    {
                        
        DWORD dwTmp = sizeof(szIEPath);
        if(RegQueryValue(hkey, TEXT("iexplore.exe"), szIEPath, (PLONG)&dwTmp) != ERROR_SUCCESS)
        {
            ShellExecute(NULL,TEXT("open"),szIEPath,lpszURL,NULL,SW_NORMAL);
        }
        else
        {
            ShellExecute(NULL,TEXT("open"),TEXT("iexplore.exe"),lpszURL,NULL,SW_NORMAL);
            
        }
        RegCloseKey(hkey);
    }
    else
    {
        ShellExecute(NULL,TEXT("open"),TEXT("iexplore.exe"),lpszURL,NULL,SW_NORMAL);
    }
    
}        

void HandleShellNext
(
    void
)
{
    DWORD dwVal  = 0;
    DWORD dwSize = sizeof(dwVal);
    HKEY  hKey   = NULL;

    if(RegOpenKeyEx(HKEY_CURRENT_USER, 
                    ICWSETTINGSPATH,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                    ICW_REGKEYCOMPLETED,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

        RegCloseKey(hKey);
    }
    
    if (dwVal)
    {
        if (PathIsURL(g_szShellNext) || g_bRunDefaultHtm)
            StartIE(g_szShellNext);        
        else if(g_szShellNext[0] != '\0')
            // Let the shell deal with it
            ShellExecute(NULL,TEXT("open"),g_szShellNext,g_szShellNextParams,NULL,SW_NORMAL); 
    }
}

extern "C" void _stdcall ModuleEntry (void)
{
    int         i;
    
    g_hMapping = CreateFileMapping( INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READONLY,
                                    0,
                                    32,
#ifdef ICWDEBUG
                                    TEXT("ICWDEBUG") );
#else
                                    TEXT("ICWCONN1") );
#endif //ICWDEBUG

    if(g_hMapping)
    {
        // See if there is allready a mapping file, if so, we have an instance 
        // already running
        if( GetLastError() == ERROR_ALREADY_EXISTS )
        {
            // Front the existing instance, and exit
            HWND  hWnd               = NULL;
            HWND  FirstChildhWnd     = NULL; 
            TCHAR szTitle[MAX_TITLE] = TEXT("\0");
    
            if (!LoadString(g_hInstance, IDS_APPNAME, szTitle, sizeof(szTitle)))
                lstrcpy(szTitle, TEXT("Internet Connection Wizard"));

            if (hWnd = FindWindow(TEXT("#32770"), szTitle)) 
            { 
                FirstChildhWnd = GetLastActivePopup(hWnd);
                SetForegroundWindow(hWnd);         // bring main window to top

                // is a pop-up window active
                if (hWnd != FirstChildhWnd)
                    BringWindowToTop(FirstChildhWnd); 

            }
            CloseHandle(g_hMapping);
            ExitProcess(1);
        }
        else
        {
            LPTSTR      pszCmdLine = GetCommandLine();

            // We don't want the "No disk in drive X:" requesters, so we set
            // the critical error mask such that calls will just silently fail
            SetErrorMode(SEM_FAILCRITICALERRORS);

            if ( *pszCmdLine == TEXT('\"') ) 
            {
                /*
                 * Scan, and skip over, subsequent characters until
                 * another double-quote or a null is encountered.
                 */
                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                    ;
                /*
                 * If we stopped on a double-quote (usual case), skip
                 * over it.
                 */
                if ( *pszCmdLine == TEXT('\"') )
                    pszCmdLine++;
            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                pszCmdLine++;
            }

            /*
             * Skip past any white space preceeding the second token.
             */
            while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
            {
                pszCmdLine++;
            }

            // Set the current directory.
            HKEY    hkey = NULL;
            TCHAR    szAppPathKey[MAX_PATH];
            TCHAR    szICWPath[MAX_PATH];
            DWORD   dwcbPath = sizeof(szICWPath);
                    
            lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
            lstrcat (szAppPathKey, TEXT("\\"));
            lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

            if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
            {
                if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
                {
                    // The Apppaths' have a trailing semicolon that we need to get rid of
                    // dwcbPath is the lenght of the string including the NULL terminator
                    int nSize = lstrlen(szICWPath);
                    szICWPath[nSize-1] = TEXT('\0');
                    SetCurrentDirectory(szICWPath);
                }            
            }        
            if (hkey) 
                RegCloseKey(hkey);

            i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, SW_SHOWDEFAULT);

            // see if we need to exectute any /ShellNext dudes
            HandleShellNext();
            
            CloseHandle(g_hMapping);
       
            ExitProcess(i); // Were outa here....
        }            
    }    
    else
    {
        ExitProcess(1); 
    }
    
}   /*  ModuleEntry() */


/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL InitWizardState(WIZARDSTATE * pWizardState)
{
    HRESULT        hr;
    
    ASSERT(pWizardState);

    // set starting page
#ifdef ICWDEBUG
	pWizardState->uCurrentPage = ORD_PAGE_ICWDEBUG_OFFER;
#else  //!def ICWDEBUG
	pWizardState->uCurrentPage = ORD_PAGE_INTRO;
#endif //ICWDEBUG
    
    pWizardState->fNeedReboot = FALSE;
    pWizardState->bDoUserPick = FALSE;
    gpWizardState->lSelectedPhoneNumber = -1;
    gpWizardState->lDefaultLocationID = -1;
    gpWizardState->lLocationID = -1;
    
#ifndef ICWDEBUG
    //init the tutor app class
    g_pICWTutorApp = new CICWTutorApp;
#endif //ICWDEBUG

    // Instansiate ICWHELP objects
    hr = CoCreateInstance(CLSID_TapiLocationInfo,NULL,CLSCTX_INPROC_SERVER,
                          IID_ITapiLocationInfo,(LPVOID *)&pWizardState->pTapiLocationInfo);
    if (FAILED(hr))
       return FALSE;                          
    hr = CoCreateInstance(CLSID_RefDial,NULL,CLSCTX_INPROC_SERVER,
                          IID_IRefDial,(LPVOID *)&pWizardState->pRefDial);
    if (FAILED(hr))
        return FALSE;                          
    hr = CoCreateInstance(CLSID_ICWSystemConfig,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWSystemConfig,(LPVOID *)&pWizardState->cmnStateData.pICWSystemConfig);
    if (FAILED(hr))
        return FALSE;                          
   
    hr = CoCreateInstance(CLSID_INSHandler,NULL,CLSCTX_INPROC_SERVER,
                          IID_IINSHandler,(LPVOID *)&pWizardState->pINSHandler);
    if (FAILED(hr))
        return FALSE;                          
   
    if ( !(SUCCEEDED(hr)                              || 
         !pWizardState->pTapiLocationInfo             ||
         !pWizardState->cmnStateData.pICWSystemConfig ||
         !pWizardState->pRefDial                      ||
         !pWizardState->pINSHandler ))
    {
        return FALSE;
    }
    
    // Need to load the UTIL lib, to register the WEBOC window class
    pWizardState->hInstUtilDLL = LoadLibrary(ICW_UTIL);

    gpWizardState->cmnStateData.lpfnCompleteOLS = &OlsFinish;
    gpWizardState->cmnStateData.bOEMOffline = FALSE;
    gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground = &FillWindowWithAppBackground;
    gpWizardState->cmnStateData.ispInfo.bFailedIns = FALSE;
    
    return TRUE;
}

/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL CleanupWizardState(WIZARDSTATE * pWizardState)
{
    ASSERT(pWizardState);
  
#ifndef ICWDEBUG    
    ASSERT(g_pICWTutorApp);

    delete g_pICWTutorApp;
#endif //ICWDEBUG

    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;

    if (pWizardState->pTapiLocationInfo)
    {
        pWizardState->pTapiLocationInfo->Release();
        pWizardState->pTapiLocationInfo = NULL;
        
    }
    
    if (pWizardState->pRefDial)
    {
        pWizardState->pRefDial->Release();
        pWizardState->pRefDial = NULL;
    
    }

    if (pWizardState->pINSHandler)
    {
        pWizardState->pINSHandler->Release();
        pWizardState->pINSHandler = NULL;
    
    }
    
    if (pWizardState->cmnStateData.pICWSystemConfig)
    {
        pWizardState->cmnStateData.pICWSystemConfig->Release();
        pWizardState->cmnStateData.pICWSystemConfig = NULL;
    }

    if(pWizardState->pHTMLWalker)
    {
        pWizardState->pHTMLWalker->Release();
        pWizardState->pHTMLWalker = NULL;
    }

    if(pWizardState->pICWWebView)
    {
        pWizardState->pICWWebView->Release();
        pWizardState->pICWWebView = NULL;
    }
    
    if (pWizardState->hInstUtilDLL)
        FreeLibrary(pWizardState->hInstUtilDLL);
    
    //Now's a good a time as any, let's clean up the
    //download directory
    RemoveDownloadDirectory();

#ifdef ICWDEBUG
    RemoveTempOfferDirectory();
#endif

    return TRUE;
}

LRESULT FAR PASCAL WndSubClassFunc
(   
    HWND hWnd,
    WORD uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_ERASEBKGND:
            return 1;

        case PSM_SETWIZBUTTONS:
            g_pICWApp->SetWizButtons(hWnd, lParam);
            break;
        
        case PSM_CANCELTOCLOSE:
            // Disable the cancel button.
            g_pICWApp->m_BtnCancel.Enable(FALSE);
            break;
            
            
        case PSM_SETHEADERTITLE:
            SendMessage(g_pICWApp->m_hWndApp, WUM_SETTITLE, 0, lParam);
            break;
            
        default:
            return CallWindowProc(g_lpfnOldWndProc, hWnd, uMsg, wParam, lParam);
    }   
    return TRUE;         
}

/**************************************************************************

   PropSheetCallback()

**************************************************************************/

void CALLBACK PropSheetCallback(HWND hwndPropSheet, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
        //called before the dialog is created, hwndPropSheet = NULL, lParam points to dialog resource
        case PSCB_PRECREATE:
        {
            LPDLGTEMPLATE  lpTemplate = (LPDLGTEMPLATE)lParam;
            // THIS is the STYLE used for Wizards.
            // We want to nuke all of these styles to remove the border, caption,
            // etc., and make the wizard a child of the parent. We also make the
            // wizard not visible initially.  It will be make visable after
            // we get the wizard modeless handle back and do some resizing.
            //STYLE DS_MODALFRAME | DS_3DLOOK | DS_CONTEXTHELP | WS_POPUP | WS_CAPTION | WS_SYSMENU

            lpTemplate->style &= ~(WS_SYSMENU | WS_CAPTION | DS_CONTEXTHELP | DS_3DLOOK | DS_MODALFRAME | WS_POPUP | WS_VISIBLE);
            lpTemplate->style |= WS_CHILD;
    
            break;
        }

        //called after the dialog is created
        case PSCB_INITIALIZED:
            //
            // Now subclass the Wizard window AND the DLG class so all of our
            // dialog pages can be transparent
            //      
            g_lpfnOldWndProc = (WNDPROC)SetWindowLongPtr(hwndPropSheet, GWLP_WNDPROC, (DWORD_PTR)&WndSubClassFunc);
            break;
    }
}


// General ICW cleanup to be done before existing
void ICWCleanup (void)
{            
    if (gpICWCONNApprentice)
    {
        gpICWCONNApprentice->Release();
        gpICWCONNApprentice = NULL;
    }

    if (gpINETCFGApprentice)
    {
        gpINETCFGApprentice->Release();
        gpINETCFGApprentice = NULL;
    }

    if( g_pdwDialogIDList )
    {
        GlobalFree(g_pdwDialogIDList);
        g_pdwDialogIDList = NULL;
    }

    if( g_pCICWExtension )
    {
        g_pCICWExtension->Release();
        g_pCICWExtension = NULL;
    }

    if( g_pCINETCFGExtension )
    {
        g_pCINETCFGExtension->Release();
        g_pCINETCFGExtension = NULL;
    }

    CleanupWizardState(gpWizardState);
}
/*******************************************************************

  NAME:    RunSignupWizard

  SYNOPSIS:  Creates property sheet pages, initializes wizard property sheet and runs wizard

  ENTRY:    

  EXIT:     returns TRUE if user runs wizard to completion,
            FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
HWND RunSignupWizard(HWND hWndOwner)
{
    HPROPSHEETPAGE  hWizPage[EXE_NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE   psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    UINT            nPageIndex;
    INT_PTR         iRet;
    BOOL            bUse256ColorBmp = FALSE;
    HBITMAP         hbmHeader = NULL;
    
    ASSERT(gpWizardState);   // assert that global structs have been allocated

    AllocDialogIDList();

    // Compute the color depth we are running in
    HDC hdc = GetDC(NULL);
    if(hdc)
    {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
            bUse256ColorBmp = TRUE;
        ReleaseDC(NULL, hdc);
    }

    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = g_hInstance;
    psPage.pfnDlgProc = GenDlgProc;
    
    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0;nPageIndex < EXE_NUM_WIZARD_PAGES;nPageIndex++) 
    {
        psPage.dwFlags     = PSP_DEFAULT | PSP_USETITLE;
        psPage.pszTitle    = gpWizardState->cmnStateData.szWizTitle;
        psPage.pszTemplate = MAKEINTRESOURCE(PageInfo[nPageIndex].uDlgID);
        
        // set a pointer to the PAGEINFO struct as the private data for this page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];
        if (!gpWizardState->cmnStateData.bOEMCustom)
        {
            if (PageInfo[nPageIndex].nIdTitle)
            {
                psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
                psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
                psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
            }
            else
            {
                psPage.dwFlags |= PSP_HIDEHEADER;
            }
        }
                
        hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);
        if (!hWizPage[nPageIndex]) 
        {
            ASSERT(0);

            // creating page failed, free any pages already created and bail
            MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
            UINT nFreeIndex;
            for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
                DestroyPropertySheetPage(hWizPage[nFreeIndex]);

            iRet = 0;
            goto RunSignupWizardExit;
        }
        
        // Load the accelerator table for this page if necessary
        if (PageInfo[nPageIndex].idAccel)
            PageInfo[nPageIndex].hAccel = LoadAccelerators(g_hInstance, 
                                          MAKEINTRESOURCE(PageInfo[nPageIndex].idAccel));      
    }

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    if (!gpWizardState->cmnStateData.bOEMCustom)
    {
        psHeader.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_STRETCHWATERMARK;
    }        
    else
    {
        psHeader.dwFlags = PSH_WIZARD | PSH_MODELESS | PSH_USECALLBACK;
        psHeader.pfnCallback = (PFNPROPSHEETCALLBACK)PropSheetCallback;
    }
    psHeader.hwndParent = hWndOwner;
    psHeader.hInstance = g_hInstance;
    psHeader.nPages = EXE_NUM_WIZARD_PAGES;
    psHeader.phpage = hWizPage;

#ifndef ICWDEBUG
    // If we are running in Modal mode, then we want to setup for
    // wizard 97 style with appropriate bitmaps
    if (!gpWizardState->cmnStateData.bOEMCustom)
    {
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
        {
            psHeader.nStartPage = ORD_PAGE_BRANDEDINTRO;
                    
            if (NULL == (gpWizardState->cmnStateData.hbmWatermark = LoadBrandedBitmap(BRANDED_WATERMARK)))
            {
                // Use our default Watermark
                gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                                bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION);
            }            
            
            if(NULL != (hbmHeader = LoadBrandedBitmap(BRANDED_HEADER)))
            {
                psHeader.hbmHeader = hbmHeader;
                psHeader.dwFlags |= PSH_USEHBMHEADER;
            }
            else
            {
                // Use our default header
                psHeader.pszbmHeader = bUse256ColorBmp?
                                     MAKEINTRESOURCE(IDB_BANNER256):
                                     MAKEINTRESOURCE(IDB_BANNER16);
            }            
            
        }            
        else // NORMAL
        {
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS)
                psHeader.nStartPage = ORD_PAGE_SBSINTRO;
            else
                psHeader.nStartPage = ORD_PAGE_INTRO;

            // Specify wizard left graphic
            gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                            bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                            IMAGE_BITMAP,
                            0,
                            0,
                            LR_CREATEDIBSECTION);

            // Specify wizard header
            psHeader.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
        }
    }    
    else
    {
        // Start page for modeless is INTRO2
        psHeader.nStartPage = ORD_PAGE_INTRO2;
    }    
    
#else  //ifdef ICWDEBUG

        psHeader.nStartPage = ORD_PAGE_ICWDEBUG_OFFER;

        // Specify wizard left graphic
        gpWizardState->cmnStateData.hbmWatermark = (HBITMAP)LoadImage(g_hInstance,
                        bUse256ColorBmp ? MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16),
                        IMAGE_BITMAP,
                        0,
                        0,
                        LR_CREATEDIBSECTION);
        psHeader.pszbmHeader    = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256)   :MAKEINTRESOURCE(IDB_BANNER16);

#endif // ICWDEBUG
    
    
    //
    // set state of gpWizardState->fNeedReboot and
    // reset the state of Backup Flag here - MKarki Bug #404
    // 
    if (gfBackedUp == TRUE)
    {
        gpWizardState->fNeedReboot = gfReboot;
        gfBackedUp = FALSE;
    }
    
    //register the Native font control so the dialog won't fail
    INITCOMMONCONTROLSEX iccex;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    if (!InitCommonControlsEx(&iccex))
        return FALSE;

    // run the Wizard
    iRet = PropertySheet(&psHeader);
    
    // If we are doing a modless wizard, then PropertySheet will return
    // immediatly with the property sheet window handle
    if (gpWizardState->cmnStateData.bOEMCustom)
        return (HWND)iRet;
        
    if (iRet < 0) 
    {
        // property sheet failed, most likely due to lack of memory
        MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
    }

RunSignupWizardExit:

    // Clean up allocated bitmaps that might exist from the branding case
    if (gpWizardState->cmnStateData.hbmWatermark)
        DeleteObject(gpWizardState->cmnStateData.hbmWatermark);
    gpWizardState->cmnStateData.hbmWatermark = NULL;
        
    if (hbmHeader)
        DeleteObject(hbmHeader);
        
    return (HWND)(iRet > 0);
}

// Convert a string color in HTML format (#RRGGBB) into a COLORREF 
COLORREF  ColorToRGB
(
    LPTSTR   lpszColor
)
{
    int r,g,b;
    
    Assert(lpszColor);
    if (lpszColor && '#' == lpszColor[0])
    {
        _stscanf(lpszColor, TEXT("#%2x%2x%2x"), &r,&g,&b);
        return RGB(r,g,b);
    }
    return RGB(0,0,0);
}

const TCHAR cszSectionGeneral[] = TEXT("General");
const TCHAR cszSectionHeader[] = TEXT("Header");
const TCHAR cszSectionDialog[] = TEXT("Dialog");
const TCHAR cszSectionBusy[] = TEXT("Busy");
const TCHAR cszSectionBack[] = TEXT("Back");
const TCHAR cszSectionNext[] = TEXT("Next");
const TCHAR cszSectionFinish[] = TEXT("Finish");
const TCHAR cszSectionCancel[] = TEXT("Cancel");
const TCHAR cszSectionTutorial[] = TEXT("Tutorial");

const TCHAR cszTitleBar[] = TEXT("TitleBar");
const TCHAR cszBackgroundBmp[] = TEXT("background");
const TCHAR cszFirstPageHTML[] = TEXT("FirstPageHTML");
const TCHAR cszFirstPageBackground[] = TEXT("FirstPageBackground");
const TCHAR cszTop[] = TEXT("Top");
const TCHAR cszLeft[] = TEXT("Left");
const TCHAR cszBackgroundColor[] = TEXT("BackgroundColor");
const TCHAR cszAnimation[] = TEXT("Animation");

const TCHAR cszFontFace[] = TEXT("FontFace");
const TCHAR cszFontSize[] = TEXT("FontSize");
const TCHAR cszFontWeight[] = TEXT("FontWeight");
const TCHAR cszFontColor[] = TEXT("FontColor");

const TCHAR cszPressedBmp[] = TEXT("PressedBmp");
const TCHAR cszUnpressedBmp[] = TEXT("UnpressedBmp");
const TCHAR cszTransparentColor[] = TEXT("TransparentColor");
const TCHAR cszDisabledColor[] = TEXT("DisabledColor");
const TCHAR cszvalign[] = TEXT("valign");
const TCHAR cszTutorialExe[] = TEXT("TutorialExe");
const TCHAR cszTutorialHTML[] = TEXT("TutorialHTML");

#define DEFAULT_HEADER_FONT TEXT("MS Shell Dlg")
#define DEFAULT_HEADER_SIZE 8
#define DEFAULT_HEADER_WEIGHT FW_BOLD


void DisplayOEMCustomizationErrorMsg
(
    int iErrorCode
)
{
    TCHAR   szMsg[MAX_RES_LEN];
    TCHAR   szFmt[MAX_RES_LEN];
    TCHAR   szMsgText[MAX_RES_LEN];
    TCHAR   szTitle[MAX_RES_LEN];
        
    LoadString(g_hInstance, OEMCUSTOM_ERR_MSGFMT, szFmt, sizeof(szFmt));
    LoadString(g_hInstance, iErrorCode, szMsgText, sizeof(szMsgText));
    LoadString(g_hInstance, IDS_APPNAME, szTitle, sizeof(szTitle));
    
    wsprintf (szMsg, szFmt, szMsgText);
    MessageBox(NULL, szMsg, szTitle, MB_OK | MB_ICONSTOP);
}

// Check for, and load OEM custom settings.
BOOL bCheckOEMCustomization
(
    void
)
{
    int             iErrorCode = 0;
    TCHAR           szTemp[MAX_PATH];
    TCHAR           szOEMCustPath[MAX_PATH];
    TCHAR           szOEMCustFile[MAX_PATH];
    TCHAR           szHTMLFile[MAX_PATH];
    TCHAR           szCurrentDir[MAX_PATH];
    TCHAR           szPressedBmp[MAX_PATH];
    TCHAR           szUnpressedBmp[MAX_PATH];
    TCHAR           szFontFace[MAX_PATH];
    TCHAR           szColor[MAX_COLOR_NAME];
    TCHAR           szTransparentColor[MAX_COLOR_NAME];
    TCHAR           szDisabledColor[MAX_COLOR_NAME];
    TCHAR           szBusyFile[MAX_PATH];
    COLORREF        clrDisabled;
    long            lFontSize;
    long            lFontWeight;
    long            xPos;
    int             i;
    int             iVal;
    int             iTitleTop, iTitleLeft;
    long            vAlign;
    const LPTSTR    cszBtnSections[4] = { (LPTSTR)cszSectionBack, 
                                         (LPTSTR)cszSectionNext, 
                                         (LPTSTR)cszSectionFinish, 
                                         (LPTSTR)cszSectionCancel};
    CICWButton      *Btnids[4] = { &g_pICWApp->m_BtnBack, 
                                   &g_pICWApp->m_BtnNext, 
                                   &g_pICWApp->m_BtnFinish, 
                                   &g_pICWApp->m_BtnCancel};
    
     
    Assert(g_pICWApp);
     
    // We only allow OEM customization when running from Runonce or
    // a desktop shortcut
    if (!g_bRunOnce && !g_bShortcutEntry)
    {
        iErrorCode = OEMCUSTOM_ERR_NOTOEMENTRY;
        goto CheckOEMCustomizationExit2;
    }   
    // Get the current working directory so we can restore it later
    if (!GetCurrentDirectory(sizeof(szCurrentDir), szCurrentDir))
    {
        iErrorCode = OEMCUSTOM_ERR_WINAPI;
        goto CheckOEMCustomizationExit2;
    }   
    
    // Get the Windows Directory. That is the root where the OEM customization
    // files will be places
    if (!GetWindowsDirectory(szOEMCustPath, sizeof(szOEMCustPath)))
    {
        iErrorCode = OEMCUSTOM_ERR_WINAPI;
        goto CheckOEMCustomizationExit2;
    }
    
    // Make sure we can append the backslash and oem customization file name            
    if ((int)(sizeof(szOEMCustFile) - lstrlen(szOEMCustPath)) < 
           (int) (3 + lstrlen(c_szOEMCustomizationDir) + lstrlen(c_szOEMCustomizationFile)))
    {
        iErrorCode = OEMCUSTOM_ERR_NOMEM;
        goto CheckOEMCustomizationExit2;
    }   
        
    // Append the customization file name        
    lstrcat(szOEMCustPath, TEXT("\\"));
    lstrcat(szOEMCustPath, c_szOEMCustomizationDir);        
    
    // Change the working directory to the OEM one
    SetCurrentDirectory(szOEMCustPath);
    
    lstrcpy(szOEMCustFile, szOEMCustPath);
    lstrcat(szOEMCustFile, TEXT("\\"));
    lstrcat(szOEMCustFile, c_szOEMCustomizationFile);        
        
    // See if the customization file exists.
    if (0xFFFFFFFF == GetFileAttributes(szOEMCustFile))
    {
        iErrorCode = OEMCUSTOM_ERR_CANNOTFINDOEMCUSTINI;
        goto CheckOEMCustomizationExit;
    }
    
    // Background bitmap
    GetPrivateProfileString(cszSectionGeneral, 
                            cszBackgroundBmp, 
                            TEXT(""), 
                            szTemp, 
                            sizeof(szTemp), 
                            szOEMCustFile);
    if (FAILED(g_pICWApp->SetBackgroundBitmap(szTemp)))
    {
        iErrorCode = OEMCUSTOM_ERR_BACKGROUND;
        goto CheckOEMCustomizationExit;
    }
    
    // solid background color for some HTML pages
    GetPrivateProfileString(cszSectionDialog, 
                            cszBackgroundColor, 
                            TEXT(""), 
                            gpWizardState->cmnStateData.szHTMLBackgroundColor, 
                            sizeof(gpWizardState->cmnStateData.szHTMLBackgroundColor), 
                            szOEMCustFile);
    // App Title
    if (!GetPrivateProfileString(cszSectionGeneral, 
                            cszTitleBar, 
                            TEXT(""), 
                            g_pICWApp->m_szAppTitle, 
                            sizeof(g_pICWApp->m_szAppTitle), 
                            szOEMCustFile))
    {                            
        // Default Title    
        LoadString(g_hInstance, IDS_APPNAME, g_pICWApp->m_szAppTitle, sizeof(g_pICWApp->m_szAppTitle));
    }                        
    else
    {
        if (0 == lstrcmpi(g_pICWApp->m_szAppTitle, ICW_NO_APP_TITLE))
            LoadString(g_hInstance, IDS_APPNAME, g_pICWApp->m_szAppTitle, sizeof(g_pICWApp->m_szAppTitle));
    }
    
    // Initial HTML page. REQUIRED
    if (!GetPrivateProfileString(cszSectionGeneral, 
                            cszFirstPageHTML, 
                            TEXT(""), 
                            szHTMLFile, 
                            sizeof(szHTMLFile), 
                            szOEMCustFile))
    {
        iErrorCode = OEMCUSTOM_ERR_FIRSTHTML;
        goto CheckOEMCustomizationExit;
    }        
    
    // Make sure the file exists
    if (0xFFFFFFFF == GetFileAttributes(szHTMLFile))
    {
        iErrorCode = OEMCUSTOM_ERR_FIRSTHTML;
        goto CheckOEMCustomizationExit;
    }   
    
    // Form the URL for the OEM first page HTML
    wsprintf(g_pICWApp->m_szOEMHTML, TEXT("FILE://%s\\%s"), szOEMCustPath, szHTMLFile);

    // Initial page. BMP (OPTIONAL). NOTE this bitmap must be loaded after
    // the main background bitmap
    if (GetPrivateProfileString(cszSectionGeneral, 
                            cszFirstPageBackground, 
                            TEXT(""), 
                            szTemp, 
                            sizeof(szTemp), 
                            szOEMCustFile))
    {
        if (FAILED(g_pICWApp->SetFirstPageBackgroundBitmap(szTemp)))
        {
            iErrorCode = OEMCUSTOM_ERR_BACKGROUND;
            goto CheckOEMCustomizationExit;
        }            
    }        

    // Position, and AVI file for busy animation
    if (GetPrivateProfileString(cszSectionBusy, 
                            cszAnimation, 
                            TEXT(""), 
                            szBusyFile, 
                            sizeof(szBusyFile), 
                            szOEMCustFile))
    {
        if (0 != lstrcmpi(szBusyFile, TEXT("off")))
        {        
            // A file is specified, so quality the path
            if (!GetCurrentDirectory(sizeof(gpWizardState->cmnStateData.szBusyAnimationFile), 
                                     gpWizardState->cmnStateData.szBusyAnimationFile))
            {
                iErrorCode = OEMCUSTOM_ERR_WINAPI;
                goto CheckOEMCustomizationExit;
            }
            // Make sure we can append the backslash and 8.3 file name            
            if ((int)(sizeof(gpWizardState->cmnStateData.szBusyAnimationFile) - 
                        lstrlen(gpWizardState->cmnStateData.szBusyAnimationFile)) < 
                   (int) (2 + lstrlen(gpWizardState->cmnStateData.szBusyAnimationFile)))
            {               
                iErrorCode = OEMCUSTOM_ERR_NOMEM;
                goto CheckOEMCustomizationExit;
            }
            // Append the customization file name        
            lstrcat(gpWizardState->cmnStateData.szBusyAnimationFile, TEXT("\\"));
            lstrcat(gpWizardState->cmnStateData.szBusyAnimationFile, szBusyFile);        
        }
        else
        {
            // Hide the animation
            gpWizardState->cmnStateData.bHideProgressAnime = TRUE;
        }            
    }                        
    gpWizardState->cmnStateData.xPosBusy = GetPrivateProfileInt(cszSectionBusy,
                                                                cszLeft,
                                                                -1,
                                                                szOEMCustFile);                            
    // Get the background color for the Animation file
    if (GetPrivateProfileString(cszSectionBusy, 
                            cszBackgroundColor, 
                            TEXT(""), 
                            szColor, 
                            sizeof(szColor), 
                            szOEMCustFile))
    {
        g_pICWApp->m_clrBusyBkGnd = ColorToRGB(szColor);
    }   
    
    // Get the font to be used for the Titles. Note this must be done
    // after the background bitmap is set, since the title position
    // is dependant on the overall window size
    GetPrivateProfileString(cszSectionHeader, 
                            cszFontFace, 
                            DEFAULT_HEADER_FONT, 
                            szFontFace, 
                            sizeof(szFontFace), 
                            szOEMCustFile);
    GetPrivateProfileString(cszSectionHeader, 
                            cszFontColor, 
                            TEXT(""), 
                            szColor, 
                            sizeof(szColor), 
                            szOEMCustFile);
                            
    lFontSize = (long)GetPrivateProfileInt(cszSectionHeader,
                                          cszFontSize,
                                          DEFAULT_HEADER_SIZE,
                                          szOEMCustFile);
    lFontWeight = (long)GetPrivateProfileInt(cszSectionHeader,
                                             cszFontWeight,
                                             DEFAULT_HEADER_WEIGHT,
                                             szOEMCustFile);
    iTitleTop = GetPrivateProfileInt(cszSectionHeader,
                                     cszTop,
                                     -1,
                                     szOEMCustFile);                            
    iTitleLeft = GetPrivateProfileInt(cszSectionHeader,
                                     cszLeft,
                                     -1,
                                     szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetTitleParams(iTitleTop,
                                         iTitleLeft,
                                         szFontFace,
                                         lFontSize,
                                         lFontWeight,
                                         ColorToRGB(szColor))))
    {
        iErrorCode = OEMCUSTOM_ERR_HEADERPARAMS;
        goto CheckOEMCustomizationExit;
    }                                                      
    
    // Get the Button Params
    for (i = 0; i < ARRAYSIZE(cszBtnSections); i++) 
    {
        
        GetPrivateProfileString(cszBtnSections[i], 
                                cszPressedBmp, 
                                TEXT(""), 
                                szPressedBmp, 
                                sizeof(szPressedBmp), 
                                szOEMCustFile);
        GetPrivateProfileString(cszBtnSections[i], 
                                cszUnpressedBmp, 
                                TEXT(""), 
                                szUnpressedBmp, 
                                sizeof(szUnpressedBmp), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszBtnSections[i], 
                                cszFontFace, 
                                TEXT(""), 
                                szFontFace, 
                                sizeof(szFontFace), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTFACE;
            goto CheckOEMCustomizationExit;
        }   
                                     
        xPos = (long)GetPrivateProfileInt(cszBtnSections[i],
                                          cszLeft,
                                          -1,
                                          szOEMCustFile);                            
        if (-1 == xPos)
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONLEFT;
            goto CheckOEMCustomizationExit;
        }                                          
        
        lFontSize = (long)GetPrivateProfileInt(cszBtnSections[i],
                                              cszFontSize,
                                              -1,
                                              szOEMCustFile);
        if (-1 == lFontSize)                    
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTSIZE;
            goto CheckOEMCustomizationExit;
        }
                                  
        lFontWeight = (long)GetPrivateProfileInt(cszBtnSections[i],
                                                 cszFontWeight,
                                                 0,
                                                 szOEMCustFile);
        GetPrivateProfileString(cszBtnSections[i], 
                                cszFontColor, 
                                TEXT(""), 
                                szColor, 
                                sizeof(szColor), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszBtnSections[i], 
                                cszTransparentColor, 
                                TEXT(""), 
                                szTransparentColor, 
                                sizeof(szTransparentColor), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR;
            goto CheckOEMCustomizationExit;
        }                                
        if (GetPrivateProfileString(cszBtnSections[i], 
                                cszDisabledColor, 
                                TEXT(""), 
                                szDisabledColor, 
                                sizeof(szDisabledColor), 
                                szOEMCustFile))
            clrDisabled = ColorToRGB(szDisabledColor);                
        else
            clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        
        // Vertical alignment for the text
        if (GetPrivateProfileString(cszBtnSections[i], 
                                    cszvalign, 
                                    TEXT(""), 
                                    szTemp, 
                                    sizeof(szTemp), 
                                    szOEMCustFile))
        {
            if (0 == lstrcmpi(szTemp, TEXT("top")))
                vAlign = DT_TOP;
            else if (0 == lstrcmpi(szTemp, TEXT("center")))
                vAlign = DT_VCENTER;
            else if (0 == lstrcmpi(szTemp, TEXT("bottom")))
                vAlign = DT_BOTTOM;
            else
                vAlign = -1;
        }
        else
        {
            vAlign = -1;
        }                                                
                                              
                                                         
        if (FAILED(Btnids[i]->SetButtonParams(xPos,
                                              szPressedBmp,
                                              szUnpressedBmp,
                                              szFontFace,
                                              lFontSize,
                                              lFontWeight,
                                              ColorToRGB(szColor),
                                              ColorToRGB(szTransparentColor),
                                              clrDisabled,
                                              vAlign)))
        {
            iErrorCode = OEMCUSTOM_ERR_BUTTONPARAMS;
            goto CheckOEMCustomizationExit;
        }                                                      
    }
    // Handle the Tutorial button seperatly, because they might 
    // not want one
    if (GetPrivateProfileString(cszSectionTutorial, 
                            cszPressedBmp, 
                            TEXT(""), 
                            szPressedBmp, 
                            sizeof(szPressedBmp), 
                            szOEMCustFile))
    {                            
        GetPrivateProfileString(cszSectionTutorial, 
                                cszUnpressedBmp, 
                                TEXT(""), 
                                szUnpressedBmp, 
                                sizeof(szUnpressedBmp), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszSectionTutorial, 
                                cszFontFace, 
                                TEXT(""), 
                                szFontFace, 
                                sizeof(szFontFace), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTFACE;
            goto CheckOEMCustomizationExit;
        }   
                                     
        xPos = (long)GetPrivateProfileInt(cszSectionTutorial,
                                          cszLeft,
                                          -1,
                                          szOEMCustFile);                            
        if (-1 == xPos)
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONLEFT;
            goto CheckOEMCustomizationExit;
        }                                          
        
        lFontSize = (long)GetPrivateProfileInt(cszSectionTutorial,
                                              cszFontSize,
                                              -1,
                                              szOEMCustFile);
        if (-1 == lFontSize)                    
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONFONTSIZE;
            goto CheckOEMCustomizationExit;
        }
                                  
        lFontWeight = (long)GetPrivateProfileInt(cszSectionTutorial,
                                                 cszFontWeight,
                                                 0,
                                                 szOEMCustFile);
        GetPrivateProfileString(cszSectionTutorial, 
                                cszFontColor, 
                                TEXT(""), 
                                szColor, 
                                sizeof(szColor), 
                                szOEMCustFile);
        if (!GetPrivateProfileString(cszSectionTutorial, 
                                cszTransparentColor, 
                                TEXT(""), 
                                szTransparentColor, 
                                sizeof(szTransparentColor), 
                                szOEMCustFile))
        {
            iErrorCode = OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR;
            goto CheckOEMCustomizationExit;
        }                                
        if (GetPrivateProfileString(cszSectionTutorial, 
                                cszDisabledColor, 
                                TEXT(""),
                                szDisabledColor, 
                                sizeof(szDisabledColor), 
                                szOEMCustFile))
            clrDisabled = ColorToRGB(szDisabledColor);                
        else
            clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        
        // Vertical alignment for the text
        if (GetPrivateProfileString(cszSectionTutorial, 
                                    cszvalign, 
                                    TEXT(""),
                                    szTemp, 
                                    sizeof(szTemp), 
                                    szOEMCustFile))
        {
            if (0 == lstrcmpi(szTemp, TEXT("top")))
                vAlign = DT_TOP;
            else if (0 == lstrcmpi(szTemp, TEXT("center")))
                vAlign = DT_VCENTER;
            else if (0 == lstrcmpi(szTemp, TEXT("bottom")))
                vAlign = DT_BOTTOM;
            else
                vAlign = -1;
        }
        else
        {
            vAlign = -1;
        }                                                
                                              
        if (FAILED(g_pICWApp->m_BtnTutorial.SetButtonParams(xPos,
                                                              szPressedBmp,
                                                              szUnpressedBmp,
                                                              szFontFace,
                                                              lFontSize,
                                                              lFontWeight,
                                                              ColorToRGB(szColor),
                                                              ColorToRGB(szTransparentColor),
                                                              clrDisabled,
                                                              vAlign)))
        {
            iErrorCode = OEMCUSTOM_ERR_BUTTONPARAMS;
            goto CheckOEMCustomizationExit;
        }                                                      
        
#ifndef ICWDEBUG    
        // See if the OEM wants to replace the Tutor executable
        if (GetPrivateProfileString(cszSectionTutorial, 
                                cszTutorialExe, 
                                TEXT(""), 
                                szTemp, 
                                sizeof(szTemp), 
                                szOEMCustFile))
        {
            // Checkt to see if the provided name is fully qualified or not. If it
            // is not fully qualified, then make szTemp a fully qualified path using
            // the OEM custom file dir as the base path
            if (PathIsFileSpec(szTemp))
            {
                TCHAR szDrive         [_MAX_DRIVE] = TEXT("\0");
                TCHAR szDir           [_MAX_DIR]   = TEXT("\0");
                TCHAR szFile          [MAX_PATH]   = TEXT("\0");       // Large because there might be cmd line params
                
                // Breakdown the current OEM custom file path
                _tsplitpath(szOEMCustFile,
                           szDrive,
                           szDir, 
                           NULL, 
                           NULL);
                           
                // The name specified in the OEMCUST.INI file is the file name
                lstrcpyn(szFile, szTemp, sizeof(szFile));
                
                // Form the fill path into szTemp                
                _tmakepath(szTemp, szDrive, szDir, szFile, NULL);
            }
            g_pICWTutorApp->ReplaceTutorAppCmdLine(szTemp);
        }                                
        // See if the OEM wants to replace the Tutor HTML
        else if (GetPrivateProfileString(cszSectionTutorial, 
                                cszTutorialHTML, 
                                TEXT(""), 
                                szTemp, 
                                sizeof(szTemp), 
                                szOEMCustFile))
        {
            TCHAR   szCmdLine[MAX_PATH];
            
            wsprintf(szCmdLine, TEXT("icwtutor %s\\%s"), szOEMCustPath, szTemp);
            g_pICWTutorApp->ReplaceTutorAppCmdLine(szCmdLine);
        }                                
#endif        
    }    
    else
    {
        // Don't show the tutorial button    
        g_pICWApp->m_BtnTutorial.SetButtonDisplay(FALSE);
    }
    
    // This makes sure things will fit. This function will compute the button
    // area height based on overall window size, set by the background bitmap
    if (-1 == g_pICWApp->GetButtonAreaHeight())
    {
        iErrorCode = OEMCUSTOM_ERR_SIZE;
        goto CheckOEMCustomizationExit;
    }
    // Get the Top Left corner of the ICW wizard page frame. Note this has be be
    // done after the button area is calculated
    iVal = GetPrivateProfileInt(cszSectionDialog,
                                cszTop,
                                -1,
                                szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetWizardWindowTop(iVal)))
    {
        iErrorCode = OEMCUSTOM_ERR_WIZARDTOP;
        goto CheckOEMCustomizationExit;
    }    
    iVal = GetPrivateProfileInt(cszSectionDialog,
                                cszLeft,
                                -1,
                                szOEMCustFile);                            
    if (FAILED(g_pICWApp->SetWizardWindowLeft(iVal)))
    {
        iErrorCode = OEMCUSTOM_ERR_WIZARDLEFT;
        goto CheckOEMCustomizationExit;
    }    
            
    if (GetPrivateProfileString(cszSectionDialog, 
                            cszFontColor, 
                            TEXT(""), 
                            szColor, 
                            sizeof(szColor), 
                            szOEMCustFile))
    {
        lstrcpy(gpWizardState->cmnStateData.szclrHTMLText, szColor);                                
        gpWizardState->cmnStateData.clrText = ColorToRGB(szColor);
    }        
    else
    {
        lstrcpy(gpWizardState->cmnStateData.szclrHTMLText, TEXT("WINDOWTEXT"));                                
        gpWizardState->cmnStateData.clrText = GetSysColor(COLOR_WINDOWTEXT);
    }
    
CheckOEMCustomizationExit:
    // Change the working directory back, and perform any other cleanup
    SetCurrentDirectory(szCurrentDir);
    
CheckOEMCustomizationExit2:

    // if there was an error see if we should show the reason
    if (iErrorCode)
    {
        if (g_bDebugOEMCustomization)
            DisplayOEMCustomizationErrorMsg(iErrorCode);
            
        return FALSE;
    }
    else
    {
        return TRUE;
    }        
}

BOOL TranslateWizardPageAccelerator
(
    HWND    hWndWizPage,
    LPMSG   lpMsg
)
{
    // Locate the accelerator table for the current page
    PAGEINFO    *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hWndWizPage,DWLP_USER);
    BOOL        bRet = FALSE;
        
    if (pPageInfo)
    {
        // See if there is a nested accelerator
        if (pPageInfo->hAccelNested)
            bRet = TranslateAccelerator(g_pICWApp->m_hWndApp, pPageInfo->hAccelNested, lpMsg);
        
        // If no nested, or nested not translated, then check for accelerators on the page    
        if (!bRet && pPageInfo->hAccel)
            bRet = TranslateAccelerator(g_pICWApp->m_hWndApp, pPageInfo->hAccel, lpMsg);
    }        
    else
        bRet =  FALSE;
        
    return bRet;        
}    

/*******************************************************************

  NAME:    RunSignupApp

  SYNOPSIS:  Create an application to host the Wizard pages

  ENTRY:    

  EXIT:     returns TRUE if user runs ICW to completion,
            FALSE if user cancels or an error occurs

  NOTES:    Wizard pages all use one dialog proc (GenDlgProc).
        They may specify their own handler procs to get called
        at init time or in response to Next, Cancel or a dialog
        control, or use the default behavior of GenDlgProc.

********************************************************************/
BOOL RunSignupApp(void)
{
    MSG msg;
    
    // Initialize the Application Class
    if (S_OK != g_pICWApp->Initialize())
        return FALSE;
            
    // Start the message loop. 
    while (GetMessage(&msg, (HWND) NULL, 0, 0)) 
    { 
        // If the wizard pages are being displayed, we need to see
        // if the wizard is ready to be destroyed.
        // (PropSheet_GetCurrentPageHwnd returns NULL) then destroy the dialog.
       
        // PropSheet_GetCurrentPageHwnd will return NULL after the OK or Cancel 
        // button has been pressed and all of the pages have been notified.
        if(gpWizardState->cmnStateData.hWndWizardPages && (NULL == PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages)))
        {
            DestroyWindow(gpWizardState->cmnStateData.hWndWizardPages);
            gpWizardState->cmnStateData.hWndWizardPages = NULL;
               
            DestroyWindow(g_pICWApp->m_hWndApp);
        }
        
        if(gpWizardState->cmnStateData.hWndWizardPages)
        {
            // Need to translate accelerators for this page. The page accelerators need
            // to be translated first, because some of the app level ones overlap, but
            // not visible at the same time. For this reason we want the page to have first
            // shot at translating.
            if (!TranslateWizardPageAccelerator(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), &msg))
            {
                // OK see if the app has any accelerators
                if (!g_pICWApp->m_haccel || !TranslateAccelerator(g_pICWApp->m_hWndApp,
                                                                  g_pICWApp->m_haccel,
                                                                  &msg))
                {
                    if (!PropSheet_IsDialogMessage(gpWizardState->cmnStateData.hWndWizardPages, &msg))
                    {
                        TranslateMessage(&msg); 
                        DispatchMessage(&msg); 
                    }
                }                    
            }
        }    
        else
        {
            // see if the app has any accelerators
            if (!g_pICWApp->m_haccel || !TranslateAccelerator(g_pICWApp->m_hWndApp,
                                                              g_pICWApp->m_haccel,
                                                               &msg))
            {                                                               
                TranslateMessage(&msg); 
                DispatchMessage(&msg); 
            }                
        }            
    } 
 
    // Return the exit code to the system. 
    return ((BOOL)msg.wParam);
}

//**********************************************************************
//
// bRegisterHelperOC
//
// Purpose:
//
//      Register the ICWCONN1 helper COM
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
//********************************************************************
BOOL bRegisterHelperOC
(
    HINSTANCE   hInstance,
    UINT        idLibString,
    BOOL        bReg
)
{
    BOOL    bRet = FALSE;
    HINSTANCE   hMod;
    char        szLib[MAX_PATH];

    // Self register the COM that ICWCONN1 needs
    // Because we load the DLL server into our own (ie, REGISTER.EXE)
    // process space, call to initialize the OLE COM Library.  Use the
    // OLE SUCCEEDED macro to detect success.  If fail then exit app
    // with error message.

    LoadStringA(hInstance, idLibString, szLib, sizeof(szLib));

    // Load the Server DLL into our process space.
    hMod = LoadLibraryA(szLib);

    if (NULL != hMod)
    {
        HRESULT (STDAPICALLTYPE *pfn)(void);

        // Extract the proper RegisterServer or UnRegisterServer entry point
        if (bReg)
            (FARPROC&)pfn = GetProcAddress(hMod, "DllRegisterServer");
        else
            (FARPROC&)pfn = GetProcAddress(hMod, "DllUnregisterServer");

        // Call the entry point if we have it.
        if (NULL != pfn)
        {
            if (FAILED((*pfn)()))
            {
                if (IsNT5() )
                {
                    if (*g_szShellNext)
                    {
                        // 1 Process Shell Next
                        // 2 Set Completed Bit
                        // 3 Remove ICW icon grom desktop
                        UndoDesktopChanges(hInstance);

                        SetICWComplete();
                    }
                    else
                    {
                        TCHAR szTemp[MAX_MESSAGE_LEN];
                        TCHAR szPrivDenied[MAX_MESSAGE_LEN] = TEXT("\0");

                        LoadString(hInstance, IDS_INSUFFICIENT_PRIV1, szPrivDenied, MAX_PATH);
                        LoadString(hInstance, IDS_INSUFFICIENT_PRIV2, szTemp, MAX_PATH);
                        lstrcat(szPrivDenied, szTemp);

                        LoadString(hInstance, IDS_APPNAME, szTemp, MAX_PATH);
                        MessageBox(NULL, szPrivDenied, szTemp, MB_OK | MB_ICONINFORMATION);
                    }
                }
                else
                {
                    MsgBox(NULL,IDS_DLLREG_FAIL,MB_ICONEXCLAMATION,MB_OK);
                }
                bRet = FALSE;
            }
            else
            {
                bRet = TRUE;
            }
        }
        else
        {
            MsgBox(NULL,IDS_NODLLREG_FAIL,MB_ICONEXCLAMATION,MB_OK);
            bRet = FALSE;
        }

        // Free the library
        FreeLibrary(hMod);

    }
    else
    {
        MsgBox(NULL,IDS_LOADLIB_FAIL,MB_ICONEXCLAMATION,MB_OK);
        bRet = FALSE;
    }

    return (bRet);
}

//**********************************************************************
//
// WinMain
//
// Purpose:
//
//      Program entry point
//
// Parameters:
//
//      HANDLE hInstance        - Instance handle for this instance
//
//      HANDLE hPrevInstance    - Instance handle for the last instance
//
//      LPTSTR lpCmdLine         - Pointer to the command line
//
//      int nCmdShow            - Window State
//
// Return Value:
//
//      msg.wParam
//
// Function Calls:
//      Function                        Location
//
//      CConnWizApp::CConnWizApp          APP.CPP
//      CConnWizApp::fInitApplication    APP.CPP
//      CConnWizApp::fInitInstance       APP.CPP
//      CConnWizApp::HandleAccelerators  APP.CPP
//      CConnWizApp::~CConnWizApp         APP.CPP
//      GetMessage                      Windows API
//      TranslateMessage                Windows API
//      DispatchMessage                 Windows API
//
// Comments:
//
//********************************************************************
int PASCAL WinMainT(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPTSTR lpCmdLine,int nCmdShow)
{
    int iRetVal = 1;

#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    g_hInstance = hInstance;

    //Do this here to minimize the chance that a user will ever see this
    DeleteStartUpCommand();
    
    // needed for LRPC to work properly...
    SetMessageQueue(96);

    if (FAILED(CoInitialize(NULL)))
        return(0);

    //Is the user an admin?
    g_bUserIsAdmin = DoesUserHaveAdminPrivleges(hInstance);
    g_bUserIsIEAKRestricted = CheckForIEAKRestriction(hInstance);
    
    // Allocate memory for the global wizard state
    gpWizardState = new WIZARDSTATE;
    
    if (!gpWizardState)
    {
        MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return 0;
    }
    
    // zero out structure
    ZeroMemory(gpWizardState,sizeof(WIZARDSTATE));
    SetDefaultProductCode(g_szProductCode,sizeof(g_szProductCode));
    ZeroMemory(g_szPromoCode,sizeof(g_szPromoCode));

#ifndef ICWDEBUG

    g_pszCmdLine = (TCHAR*)malloc((lstrlen(lpCmdLine) + 1)*sizeof(TCHAR));
    if(g_pszCmdLine == NULL)
    {
        iRetVal = 0;

        goto WinMainExit;
    }
    lstrcpy(g_pszCmdLine, lpCmdLine);

    if (IsOemVer())
       g_OEMOOBE = TRUE;

    if (!(g_bRetProcessCmdLine = ProcessCommandLine(hInstance, lpCmdLine)))
    {
        iRetVal = 0;

        goto WinMainExit;
    }

    if (g_OEMOOBE)
    {
        TCHAR szISPAppCmdLine[MAX_PATH];
        TCHAR szOobeSwitch[MAX_PATH];
        
        if (CheckOobeInfo(szOobeSwitch, szISPAppCmdLine))
        {
            if (IsWhistler())
            {
                // Ask if user want to run NCW or OEM version of OOBE 
                // [Windows Bug 325762]
                INT_PTR nResult = DialogBox(hInstance,
                                            MAKEINTRESOURCE(IDD_CHOOSEWIZARD),
                                            NULL,
                                            ChooseWizardDlgProc);
                if (nResult == RUNWIZARD_OOBE)
                {
                    // launch Mars sign-up on OEM preinstall machines which are 
                    // configured with default offer as Mars [Windows Bug 347909]
                    if (szISPAppCmdLine[0] == TEXT('\0'))
                    {
                        StartOOBE(g_pszCmdLine, szOobeSwitch);
                    }
                    else
                    {
                        StartISPApp(szISPAppCmdLine, g_pszCmdLine);
                    }
                }
                else if (nResult == RUNWIZARD_NCW)
                {
                    StartNCW(g_szShellNext, g_szShellNextParams);
                }
            }
            else
            {
                StartOOBE(g_pszCmdLine, szOobeSwitch);
            }

            g_szShellNext[0] = TEXT('\0');
            
            goto WinMainExit;

        }
    }

#endif

    //Is the user an admin?
    if(!g_bUserIsAdmin)
    {
        TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
        TCHAR szAdminDeniedTitle [MAX_PATH] = TEXT("\0");
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
        LoadString(hInstance, IDS_ADMIN_ACCESS_DENIED_TITLE, szAdminDeniedTitle, MAX_PATH);
        MessageBox(NULL, szAdminDenied, szAdminDeniedTitle, MB_OK | MB_ICONSTOP);
    
        TCHAR szOut[MAX_PATH];    
     
        // Get the first token
        GetCmdLineToken(&lpCmdLine,szOut);
        while (szOut[0])
        {
            GetShellNextToken(szOut, lpCmdLine);
            
            // Eat the next token, it will be null if we are at the end
            GetCmdLineToken(&lpCmdLine,szOut);
        }

        SetICWComplete();

        goto WinMainExit;
    }
    
    //Has an admin restricted access through the IEAK?
    if (g_bUserIsIEAKRestricted)
    {
        TCHAR szIEAKDenied[MAX_PATH];
        TCHAR szIEAKDeniedTitle[MAX_PATH];
        LoadString(hInstance, IDS_IEAK_ACCESS_DENIED, szIEAKDenied, MAX_PATH);
        LoadString(hInstance, IDS_IEAK_ACCESS_DENIED_TITLE, szIEAKDeniedTitle, MAX_PATH);
        MessageBox(NULL, szIEAKDenied, szIEAKDeniedTitle, MB_OK | MB_ICONSTOP);
        
        //Yup, bail.
        goto WinMainExit;
    }


    //Are we recovering from an OEM INS failure?
    if (CheckForOemConfigFailure(hInstance))
    {
        QuickCompleteSignup();
        //Yup, bail.
        goto WinMainExit;
    }

    // Register ICWHELP.DLL
    if (!bRegisterHelperOC(hInstance, IDS_HELPERLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }

    // Register ICWUTIL.DLL
    if (!bRegisterHelperOC(hInstance, IDS_UTILLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }

    // Register ICWCONN.DLL
    if (!bRegisterHelperOC(hInstance, IDS_WIZARDLIB, TRUE))
    {
        iRetVal = 0;
        goto WinMainExit;
    }
      
    // initialize the app state structure 
    //-- do this here so we don't changed made in cmdln process
    if (!InitWizardState(gpWizardState))
        return 0;    
   
    if(!LoadString(g_hInstance, IDS_APPNAME, gpWizardState->cmnStateData.szWizTitle, sizeof(gpWizardState->cmnStateData.szWizTitle)))
        lstrcpy(gpWizardState->cmnStateData.szWizTitle, TEXT("Internet Connection Wizard"));
    
     
    //we are being run from an OEM
    if(g_bRunOnce)
    {
        //Do they have a connection
        if(MyIsSmartStartEx(NULL, 0))
        {   
            //Nope, look for oemconfig.ins
            if(RunOemconfigIns())
                goto WinMainExit;
        }
        else
        {
            //Yup, clean up desktop, set completed bit etc., then bail
            QuickCompleteSignup(); 
            goto WinMainExit;
        }
    }

    // If there was not a shellnext passed on the CMD line, there might be
    // one in the registry
    if( g_szShellNext[0]  == TEXT('\0'))
    {
        GetShellNextFromReg(g_szShellNext,g_szShellNextParams);
    }        
    // We need to remove this entry now, so ICWMAN (INETWIZ) does not 
    // pick it up later
    RemoveShellNextFromReg();

    if (IsWhistler() &&
        ((gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAGS_NONCW) == 0))
    {
        // If we have shellnext, we want to run NCW instead [Windows Bug 325157]
        if ( g_szShellNext[0] != TEXT('\0'))
        {
            StartNCW(g_szShellNext, g_szShellNextParams);

            g_szShellNext[0] = TEXT('\0');
            
            goto WinMainExit;
        }
    }
    
    // Create an instance of the App Class
    g_pICWApp = new CICWApp();
    if (NULL == g_pICWApp)
    {
        iRetVal = 0;
        goto WinMainExit;
    }
    
    // Superclass some dialog control types so we can correctly draw them
    // transparently if we are using OEM customizations
    SuperClassICWControls();
    
    if (bCheckOEMCustomization())
        iRetVal = RunSignupApp();
    else
        iRetVal = (RunSignupWizard(NULL) != NULL);
    
    // Prepare for reboot if necessary
    if (gfBackedUp == FALSE)
    {
        if (gpWizardState->fNeedReboot)
            SetupForReboot(0);
    }

    // Cleanup the wizard state
    ICWCleanup();

WinMainExit: 
    
    if (g_bUserIsAdmin && g_bRetProcessCmdLine && !g_bUserIsIEAKRestricted)
    {
        // Lets unregister the helper DLL
        if (!bRegisterHelperOC(hInstance, IDS_HELPERLIB, FALSE))
        {
            iRetVal = 0;
        }

        if (!bRegisterHelperOC(hInstance, IDS_UTILLIB, FALSE))
        {
            iRetVal = 0;
        }

        if (!bRegisterHelperOC(hInstance, IDS_WIZARDLIB, FALSE))
        {
            iRetVal = 0;
        }
    
        // Nuke the ICWApp class
        if (g_pICWApp)
        {
            delete g_pICWApp;
        }
    
        // Remove the superclassing for the ICW Controls
        RemoveICWControlsSuperClass();   
    
    }
    
    // deref from COM
    CoUninitialize();
    
    // free global structures
    if (gpWizardState) 
        delete gpWizardState;
    
    if(g_pszCmdLine)
        free(g_pszCmdLine);

    return (iRetVal);          /* Returns the value from PostQuitMessage */
}


void RemoveDownloadDirectory (void)
{
    DWORD dwAttribs;
    TCHAR szDownloadDir[MAX_PATH];
    TCHAR szSignedPID[MAX_PATH];

    // form the ICW98 dir.  It is basically the CWD
    if (0 == GetCurrentDirectory(MAX_PATH, szDownloadDir))
      return;
    
    // remove the signed.pid file from the ICW directory (see BUG 373)
    wsprintf(szSignedPID, TEXT("%s%s"), szDownloadDir, TEXT("\\signed.pid"));
    if (GetFileAttributes(szSignedPID) != 0xFFFFFFFF)
    {
      SetFileAttributes(szSignedPID, FILE_ATTRIBUTE_NORMAL);    
      DeleteFile(szSignedPID);
    }
    
    lstrcat(szDownloadDir, TEXT("\\download"));

   // See if the directory exists
   dwAttribs = GetFileAttributes(szDownloadDir);
   if (dwAttribs != 0xFFFFFFFF && dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
      DeleteDirectory(szDownloadDir);
}

#ifdef ICWDEBUG
void RemoveTempOfferDirectory (void)
{
    DWORD dwAttribs;
    TCHAR szDownloadDir[MAX_PATH];
    // Set the current directory.
    HKEY    hkey = NULL;
    TCHAR   szAppPathKey[MAX_PATH];
    TCHAR   szICWPath[MAX_PATH];
    DWORD   dwcbPath = sizeof(szICWPath);
            
    lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat (szAppPathKey, TEXT("\\"));
    lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
        {
            // The Apppaths' have a trailing semicolon that we need to get rid of
            // dwcbPath is the lenght of the string including the NULL terminator
            int nSize = lstrlen(szICWPath);
            if (nSize > 0)
                szICWPath[nSize-1] = TEXT('\0');
            //SetCurrentDirectory(szICWPath);
        }            
    }

    if (hkey) 
        RegCloseKey(hkey);

    lstrcpy(szDownloadDir, szICWPath);

    lstrcat(szDownloadDir, TEXT("\\tempoffer"));
   
    // See if the directory exists
    dwAttribs = GetFileAttributes(szDownloadDir);
    if (dwAttribs != 0xFFFFFFFF && dwAttribs & FILE_ATTRIBUTE_DIRECTORY)
        DeleteDirectory(szDownloadDir);
}
#endif

void DeleteDirectory (LPCTSTR szDirName)
{
WIN32_FIND_DATA fdata;
TCHAR szPath[MAX_PATH];
HANDLE hFile;
BOOL fDone;

   wsprintf(szPath, TEXT("%s\\*.*"), szDirName);
   hFile = FindFirstFile (szPath, &fdata);
   if (INVALID_HANDLE_VALUE != hFile)
      fDone = FALSE;
   else
      fDone = TRUE;

   while (!fDone)
   {
      wsprintf(szPath, TEXT("%s\\%s"), szDirName, fdata.cFileName);
      if (fdata.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
      {
         if (lstrcmpi(fdata.cFileName, TEXT("."))  != 0 &&
             lstrcmpi(fdata.cFileName, TEXT("..")) != 0)
         {
            // recursively delete this dir too
            DeleteDirectory(szPath);
         }
      }  
      else
      {
         SetFileAttributes(szPath, FILE_ATTRIBUTE_NORMAL);
         DeleteFile(szPath);
      }
      if (FindNextFile(hFile, &fdata) == 0)
      {
         FindClose(hFile);
         fDone = TRUE;
      }
   }
   SetFileAttributes(szDirName, FILE_ATTRIBUTE_NORMAL);
   RemoveDirectory(szDirName);
}

//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: AllocDialogIDList called with non-null g_pdwDialogIDList!"));
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: AllocDialogIDList unable to allocate space for g_pdwDialogIDList!"));
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: DialogIDAlreadyInUse received an out of range DialogID, %d"), uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN1,TEXT("ICWCONN1: SetDialogIDInUse received an out of range DialogID, %d"), uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
    }


    return TRUE;
}

BOOL CheckForIEAKRestriction(HINSTANCE hInstance)
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER,
        IEAK_RESTRICTION_REGKEY,&hkey))
    {
        dwSize = sizeof(dwData);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,IEAK_RESTRICTION_REGKEY_VALUE,0,&dwType,
            (LPBYTE)&dwData,&dwSize))
        {
            if (dwData)
            {   
                bRC = TRUE;
            }
        }
   }

   if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    StartISPApp
//
//    Synopsis    Launch ISP App as a detached process and pass the ICW command line
//                to the ISP App.
//
//    Arguments   pszISPPath    - ISP Application command line, including the
//                                application name and additional arguments
//
//                pszCmdLine    - ICW command line arguments (without ICW executable
//                                name). It must not be NULL, but can be empty.
//
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID
StartISPApp(
    IN LPTSTR pszISPPath,
    IN LPTSTR pszCmdLine)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = TEXT("%s %s");
    
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;


    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) +
        lstrlen(pszISPPath) + lstrlen(pszCmdLine) + 1;
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, pszISPPath, pszCmdLine);
    ASSERT(i <= cchCommandLine);

    MyExecute(szCommandLine);
    
cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    StartOOBE
//
//    Synopsis    Launch OOBE as a detached process and pass the ICW command line
//                and additional switch to OOBE.
//
//    Arguments   pszCmdLine    - ICW command line arguments (without ICW executable
//                                name). It must not be NULL, but can be empty.
//
//                pszOobeSwitch - additional OOBE specific switch. It must not be
//                                NULL, but can be empty.
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID
StartOOBE(
    IN LPTSTR pszCmdLine,
    IN LPTSTR pszOobeSwitch)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = TEXT("%s\\msoobe.exe %s %s");
    
    TCHAR               szOOBEPath[MAX_PATH];
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;

    if (GetSystemDirectory(szOOBEPath, MAX_PATH) == 0)
    {
        goto cleanup;
    }

    lstrcat(szOOBEPath, TEXT("\\oobe"));
    
    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) +
        lstrlen(szOOBEPath) + lstrlen(pszCmdLine) + lstrlen(pszOobeSwitch) + 1;
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, szOOBEPath, pszCmdLine, pszOobeSwitch);
    ASSERT(i <= cchCommandLine);

    SetCurrentDirectory(szOOBEPath);

    MyExecute(szCommandLine);

cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    StartNCW
//
//    Synopsis    Launch NCW as a detached process and pass the shellnext to it.
//                NCW is supposed to handle shellnext and 
//                disable ICW smart start on successful configuration
//
//    Arguments   szShellNext - shellnext
//
//                szShellNextParams - argument to shellnext
//
//    Returns     none
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
VOID 
StartNCW(
    IN LPTSTR szShellNext,
    IN LPTSTR szShellNextParams)
{
    static const TCHAR  COMMANDLINE_FORMAT[] = 
        TEXT("%s\\rundll32.exe %s\\netshell.dll StartNCW %d,%s,%s");
    static const int    NCW_FIRST_PAGE = 0;
    static const int    NCW_MAX_PAGE_NO_LENGTH = 5;
    
    TCHAR               szSystemDir[MAX_PATH];
    int                 cchSystemDir;
    LPTSTR              szCommandLine = NULL;
    int                 cchCommandLine;
    int                 i;


    if ((cchSystemDir = GetSystemDirectory(szSystemDir, MAX_PATH)) == 0)
    {
        goto cleanup;
    }
    cchCommandLine = sizeof(COMMANDLINE_FORMAT) / sizeof(TCHAR) + cchSystemDir * 2 +
        lstrlen(szShellNext) + lstrlen(szShellNextParams) + NCW_MAX_PAGE_NO_LENGTH + 1;        
    szCommandLine = (LPTSTR) LocalAlloc(LPTR, cchCommandLine * sizeof(TCHAR));
    if (szCommandLine == NULL)
    {
        goto cleanup;
    }
    i = wsprintf(szCommandLine, COMMANDLINE_FORMAT, szSystemDir, szSystemDir,
        NCW_FIRST_PAGE, szShellNext, szShellNextParams);
    ASSERT(i <= cchCommandLine);

    MyExecute(szCommandLine);
    
cleanup:

    if (szCommandLine != NULL)
    {
        LocalFree(szCommandLine);
    }

}

//+----------------------------------------------------------------------------
//
//    Function    ChooseWizardDlgProc
//
//    Synopsis    Let user to determine if they want to run NCW or OEM
//                customized OOBE
//
//    Arguments   (standard DialogProc, see MSDN)
//
//    Returns     RUNWIZARD_CANCEL - if user doesn't want to run any wizard
//                RUNWIZARD_OOBE   - if user wants to run OEM customized OOBE
//                RUNWIZARD_NCW    - if user wants to run NCW
//
//    History     3/11/01     chunhoc     created
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
ChooseWizardDlgProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
   switch (uMsg)
   {
       case WM_INITDIALOG:
       {
           RECT rcDialog;

           CheckRadioButton(hwnd, IDC_RUN_OOBE, IDC_RUN_NCW, IDC_RUN_OOBE);

           if (GetWindowRect(hwnd, &rcDialog))
           {
               int cxWidth = rcDialog.right - rcDialog.left;
               int cyHeight = rcDialog.bottom - rcDialog.top;              
               int cxDialog = (GetSystemMetrics(SM_CXSCREEN) - cxWidth) / 2;
               int cyDialog = (GetSystemMetrics(SM_CYSCREEN) - cyHeight) / 2;

               MoveWindow(hwnd, cxDialog, cyDialog, cxWidth, cyHeight, FALSE);           
           }

           MakeBold(GetDlgItem(hwnd, IDC_CHOOSEWIZARD_TITLE), TRUE, FW_BOLD);

           return TRUE;
       }

       case WM_CTLCOLORSTATIC:
       {
           if (GetDlgCtrlID((HWND)lParam) == IDC_CHOOSEWIZARD_TITLE)
           {
                HBRUSH hbr = (HBRUSH) GetStockObject(WHITE_BRUSH);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbr;
           }
       }

       case WM_COMMAND:
       {
           WORD id = LOWORD(wParam);
           switch (id)
           {
              case IDOK:                 
                 if (IsDlgButtonChecked(hwnd, IDC_RUN_OOBE))
                 {
                     EndDialog(hwnd, RUNWIZARD_OOBE);                      
                 }
                 else
                 {
                     EndDialog(hwnd, RUNWIZARD_NCW);
                 }
                 
                 break;
              case IDCANCEL:
                
                 EndDialog(hwnd, RUNWIZARD_CANCEL);
                 break;

           }

           return TRUE;
       }

       case WM_DESTROY:
       {
            ReleaseBold(GetDlgItem(hwnd, IDC_CHOOSEWIZARD_TITLE));
            return 0;
       }
       
   }

   return(FALSE);
}

//+----------------------------------------------------------------------------
//
//    Function    MyExecute
//
//    Synopsis    Run a command line in a detached process
//
//    Arguments   szCommandLine - the command line to be executed
//
//    Returns     TRUE if the process is created; FALSE otherwise
//
//    History     3/27/01     chunhoc     created
//
//-----------------------------------------------------------------------------
BOOL
MyExecute(
    IN LPTSTR szCommandLine)
{
    PROCESS_INFORMATION pi;
    STARTUPINFO         si;
    BOOL                bRet;
    
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    if (CreateProcess(NULL,
                      szCommandLine,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi) == TRUE)
    {        
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
    
}

LONG
MakeBold (
    IN HWND hwnd,
    IN BOOL fSize,
    IN LONG lfWeight)
{
    LONG hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    plogfont->lfWeight = (int) lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    
MakeBoldExit:

    if (plogfont)
    {
        free(plogfont);
    }

    return hr;
}

LONG
ReleaseBold(
    HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwdebug.cpp ===
#include "pre.h"
#include <stdio.h>
#include <tchar.h>
#include "lookups.h"
#include "icwextsn.h"

//Defines
#define TEMP_OFFER_DIR             TEXT("tempoffer\\")
#define DOWNLOAD_OFFER_DIR         TEXT("download\\")
#define VALID_MAIN_OFFER_FILE_TYPE TEXT(".cab")
#define VALID_OFFER_INFO_FILE_TYPE TEXT(".csv")
#define VALID_OFFER_INFO_FILE_NAME TEXT("offers50.csv")
#define VALID_ICW_INFO_FILE_NAME   TEXT("ispinfo.csv")
#define ISPINFO_CSV_HEADER         "Name,OfferID,Icon,LocalHtm,OEMSpecialIcon,OEMSpecialHtm,ISPFile,CFGFlag,UIFlag,BillingForm,PayCSV,GUID,MIRS,LCID\r\n"
#define INFO_FILE_DELIMITER        TEXT(',')
#define BROWSE_FILTER              TEXT("CAB Files(*.cab)\0*.cab\0\0")
#define ICWDEBUG_KEY               TEXT("software\\microsoft\\Icwdebug")
#define CORPNET_VAL                TEXT("CorpNet")
#define DBGPATH_VAL                TEXT("DebugPath")
#define ISPFILE_VAL                TEXT("IspFile")
#define URL_VAL                    TEXT("Url")
#define MAX_INT_STR                10
#define CAB_PATH_INDEX             7
#define NUMBER_OF_FIELDS           21

//Prototypes
void InitListView           (HWND   hwndDlg, int    iListViewCtrlID);
void SetupOfferToDebug      (HWND   hwndDlg, int    iListViewCtrlID);
void TryToUpdateListBox     (HWND   hwndDlg, int    iListViewCtrlID, int   iEditCtrlID);
void AddOffersToListView    (HWND   hwndLV,  TCHAR* pFileBuff,       DWORD dwBuffSize);
void Browse                 (HWND   hwndDlg);
BOOL WriteCSVLine           (HWND   hwndLV,  int    iSelItem,        HFILE hFile);
BOOL ValidateOfferFile      (TCHAR* pszFile, TCHAR* pszValidExt);
BOOL ExpandOfferFileIntoDir (TCHAR* pszFile, TCHAR* pszDir);

//External prototypes
extern BOOL fdi               (char* cabinet_fullpath, char* directory);
extern UINT GetDlgIDFromIndex (UINT  uPageIndex);

typedef struct IspStruct
{
    TCHAR szISPCab      [MAX_PATH];
    TCHAR szMIRS        [MAX_PATH];
    TCHAR szISPName     [MAX_PATH];
    TCHAR szIcon        [MAX_PATH];
    TCHAR szOEMTeaseHTM [MAX_PATH];
    TCHAR szOEMButton   [MAX_PATH];
    TCHAR szLocalHtm    [MAX_PATH];
    TCHAR szIspFile     [MAX_PATH];
    TCHAR szBilling     [MAX_PATH];
    TCHAR szPayCsv      [MAX_PATH];
    TCHAR szCab         [MAX_PATH];
    UINT  dwUiFlag;
    UINT  dwLCID;
    UINT  dwCfgFlag;

}ISPSTRUCT;

TCHAR* g_pszaHeader[8] = {TEXT("ISP Name     "),
                          TEXT("Country      "),
                          TEXT("Langauage    "),
                          TEXT("Area Code    "),
                          TEXT("Platform     "),
                          TEXT("Product Code "),
                          TEXT("Promo Code   "),
                          TEXT("Oem          ")};

int g_uLastLVSel = -1;

//CountryID to friendly name resolution
inline TCHAR* LookupCountry (TCHAR* pszCid)
{
	int iCid = _ttoi(pszCid);
	int i;

	for (i = 0; i < CIDLEN; i++)
	{
		if(iCid == aryCIDLookup[i].iCID)
			return aryCIDLookup[i].pszCountry;
	}
	return NULL;
}

//LCID to friendly name resolution
inline TCHAR* LookupLanguage (TCHAR* pszLcid)
{
	int iLcid = _ttoi(pszLcid);

	for (int i = 0; i < LCIDLEN; i++)
	{
		if(iLcid == aryLCIDLookup[i].iLCID)
			return aryLCIDLookup[i].pszLcid;
	}
	return NULL;
}

//Platform to friendly name resolution
inline TCHAR* LookupPlatform (TCHAR* pszOSType, TCHAR* pszOSArch, TCHAR* pszOSMajor)
{
	int    iOsType  = _ttoi(pszOSType);
	int    iOsArch  = _ttoi(pszOSArch);
#ifdef UNICODE
        CHAR   szTmp[MAX_PATH];
        wcstombs(szTmp, pszOSMajor, MAX_PATH);
	double fOsMajor = atof(szTmp);
#else
	double fOsMajor = atof(pszOSMajor);
#endif

    for (int i = 0; i < PLATFORMLEN; i++)
	{
		if ( (iOsType  == aryPlatformLookup[i].iOSType) &&
             (iOsArch  == aryPlatformLookup[i].iOSArch) &&
             (fOsMajor == aryPlatformLookup[i].fOSMajor) )
        {
            return aryPlatformLookup[i].pszOSDescription;
        }
	}
	return NULL;
}

BOOL CALLBACK DebugOfferInitProc (HWND hDlg,BOOL fFirstInit, UINT *puNextPage)
{
    if (fFirstInit)
    {
        PropSheet_SetWizButtons(GetParent(hDlg), 0);
        InitListView(hDlg, IDC_ISPCAB_LIST);
    }
    else
    {
        HWND hLst = GetDlgItem(hDlg, IDC_ISPCAB_LIST);
        if (g_uLastLVSel != -1)
            ListView_SetItemState(hLst, g_uLastLVSel, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        if (IsWindowEnabled(hLst))
        {
            SetFocus(hLst);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
        }
        else
            PropSheet_SetWizButtons(GetParent(hDlg), 0);
    }

    return TRUE;
}

BOOL CALLBACK DebugOfferOKProc (HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL * pfKeepHistory)
{
    if (fForward)
    {
        g_uLastLVSel = ListView_GetNextItem (GetDlgItem(hDlg, IDC_ISPCAB_LIST), -1, LVNI_SELECTED);
        if (g_uLastLVSel != -1)
        {
            SetupOfferToDebug(hDlg, IDC_ISPCAB_LIST);
            return TRUE;
        }
        else
            MessageBox(hDlg, TEXT("Please select an offer to debug"), NULL, MB_OK);
    }

    return FALSE;
}

BOOL CALLBACK DebugOfferCmdProc (HWND hDlg, WPARAM wParam, LPARAM  lParam)
{
    DWORD dwMsg = GET_WM_COMMAND_CMD(wParam, lParam);

    switch(dwMsg)
    {
        case EN_CHANGE:
        {
            TryToUpdateListBox(hDlg, IDC_ISPCAB_LIST, IDC_ISPCAB_PATH);
            break;
        }
        case BN_CLICKED:
        {
            Browse(hDlg);
            return FALSE;
            break;
        }
        default:
            break;
    }

    return TRUE;
}

BOOL CALLBACK DebugOfferNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;
        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;
        case LVN_ITEMCHANGED:
            break;
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            break;
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
            {
                GlobalFree((ISPSTRUCT*)((NM_LISTVIEW*)lParam)->lParam);
                ((NM_LISTVIEW*)lParam)->lParam = NULL;
            }
            break;
        default:
            break;

    }
    return TRUE;
}

void InitListView (HWND hwndDlg, int iListViewCtrlID)
{
    ASSERT(hwndDlg);

    HWND      hwndListView;
    LVCOLUMN  lvColumn;
    int       iMaxNumHeader;

    hwndListView  = GetDlgItem(hwndDlg, iListViewCtrlID);
    lvColumn.mask = LVCF_TEXT;
    iMaxNumHeader = sizeof(g_pszaHeader) / sizeof(g_pszaHeader[0]);

    lvColumn.pszText = NULL;
    ListView_InsertColumn   (hwndListView, 0, &lvColumn);
    ListView_SetColumnWidth (hwndListView, 0, 0);

    for (int i = 1; i < iMaxNumHeader+1; i++)
    {
        lvColumn.pszText = g_pszaHeader[i-1];
        ListView_InsertColumn   (hwndListView, i, &lvColumn);
        ListView_SetColumnWidth (hwndListView, i, lstrlen(g_pszaHeader[i-1])*10);
    }

    //Add drag/drop/ordering and row select
    ListView_SetExtendedListViewStyle(hwndListView, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP );

    //disable it
    Static_Enable(hwndListView, FALSE);
}

BOOL ValidateOfferFile (TCHAR* pszFile, TCHAR* pszValidExt)
{
    ASSERT(pszFile);
    ASSERT(pszValidExt);

    if (GetFileAttributes(pszFile) != 0xFFFFFFFF)
    {
        TCHAR szExt [_MAX_EXT] = TEXT("\0");

        _tsplitpath(pszFile, NULL, NULL, NULL, szExt);

        if(!lstrcmpi(szExt, pszValidExt))
            return TRUE;
    }
    return FALSE;
}

BOOL ExpandOfferFileIntoDir (TCHAR* pszFile, TCHAR* pszDir)
{
    ASSERT(pszFile);
    ASSERT(pszDir);

   // Set the current directory.
    HKEY    hkey = NULL;
    TCHAR   szAppPathKey[MAX_PATH];
    TCHAR   szICWPath[MAX_PATH];
    TCHAR   szCurPath[MAX_PATH];
    DWORD   dwcbPath = sizeof(szICWPath);


    GetCurrentDirectory(dwcbPath, szCurPath);
    lstrcpy (szAppPathKey, REGSTR_PATH_APPPATHS);
    lstrcat (szAppPathKey, TEXT("\\"));
    lstrcat (szAppPathKey, TEXT("ICWCONN1.EXE"));

    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,szAppPathKey, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkey, TEXT("Path"), NULL, NULL, (BYTE *)szICWPath, (DWORD *)&dwcbPath) == ERROR_SUCCESS)
        {
            // The Apppaths' have a trailing semicolon that we need to get rid of
            // dwcbPath is the lenght of the string including the NULL terminator
            int nSize = lstrlen(szICWPath);
            szICWPath[nSize-1] = '\0';
            SetCurrentDirectory(szICWPath);
        }
    }

    if (hkey)
        RegCloseKey(hkey);

    //create the temp dir for the offer cab
    CreateDirectory(pszDir, NULL);

    //
    // expand the cab file in the temp directory
    //
#ifdef UNICODE
    CHAR szFile[MAX_PATH+1];
    CHAR szDir[MAX_PATH+1];

    wcstombs(szFile, pszFile, MAX_PATH+1);
    wcstombs(szDir,  pszDir,  MAX_PATH+1);
    if (fdi(szFile, szDir))
        return TRUE;
#else
    if (fdi((LPTSTR)(LPCTSTR)pszFile, pszDir))
        return TRUE;
#endif

    SetCurrentDirectory(szCurPath);

    return FALSE;
}

void AddOffersToListView (HWND hwndLV, TCHAR* pFileBuff, DWORD dwBuffSize)
{
    TCHAR  szField [MAX_PATH]    = TEXT("\0");
    TCHAR  szOs    [MAX_INT_STR] = TEXT("\0");
    TCHAR  szArch  [MAX_INT_STR] = TEXT("\0");
    TCHAR* pszField              = (TCHAR*)&szField;
    int    i                     = 0;
    int    iLen                  = 0;
    LVITEM lvItem;

    lvItem.mask     = LVIF_TEXT | LVIF_PARAM;
    lvItem.pszText  = szField;
    lvItem.iItem    = 0;
    lvItem.iSubItem = 0;

    TCHAR* pFileBuffStart = pFileBuff;

    while((DWORD)(pFileBuff - pFileBuffStart) < dwBuffSize)
    {
        pszField  = (TCHAR*)&szField;

        ISPSTRUCT* pIspInfo = (ISPSTRUCT*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(ISPSTRUCT));
        if (!pIspInfo)
        {
            MessageBox(GetParent(hwndLV), TEXT("OUT OF MEMORY!"), NULL, MB_OK);
            return;
        }

        lvItem.lParam = (LPARAM)pIspInfo;
        ListView_InsertItem(hwndLV, &lvItem);

        while(i <= NUMBER_OF_FIELDS)
        {
            while(*pFileBuff != ',' && *pFileBuff != '\n')
                *pszField++ = *pFileBuff++;
            *pFileBuff++;
            *pszField++ = '\0';

            switch (i)
            {
                case 0: //mirs
                    lstrcpy(pIspInfo->szMIRS, szField);
                    break;
                case 1: //isp name
                    lstrcpy(pIspInfo->szISPName, szField);
                    ListView_SetItemText(hwndLV, lvItem.iItem, 1, szField);
                    break;
                case 2: //local htm
                    lstrcpy(pIspInfo->szLocalHtm, szField);
                    break;
                case 3: //icon
                    lstrcpy(pIspInfo->szIcon, szField);
                    break;
                case 4: //OEM Button
                    lstrcpy(pIspInfo->szOEMButton, szField);
                    break;
                case 5: //OEM Teaser
                    lstrcpy(pIspInfo->szOEMTeaseHTM, szField);
                    break;
                case 6: //billing htm
                    lstrcpy(pIspInfo->szBilling, szField);
                    break;
                case 7: //isp file
                    lstrcpy(pIspInfo->szIspFile, szField);
                    break;
                case 8: //paycsv file
                    lstrcpy(pIspInfo->szPayCsv, szField);
                    break;
                case 9: //cab file
                    lstrcpy(pIspInfo->szCab, szField);
                    break;
                case 10: // LCID
                    pIspInfo->dwLCID = _ttoi(szField);
                    ListView_SetItemText(hwndLV, lvItem.iItem, 3, LookupLanguage(szField));
                    break;
                case 11: // Country
                    ListView_SetItemText(hwndLV, lvItem.iItem, 2, LookupCountry(szField));
                    break;
                case 12: // Areacode
                    ListView_SetItemText(hwndLV, lvItem.iItem, 4, szField);
                    break;
                case 13: // Exchng
                    break;
                case 14: //prod
                    ListView_SetItemText(hwndLV, lvItem.iItem, 6, szField);
                    break;
                case 15: //promo
                    ListView_SetItemText(hwndLV, lvItem.iItem, 7, szField);
                    break;
                case 16: //oem
                    ListView_SetItemText(hwndLV, lvItem.iItem, 8, szField);
                    break;
                case 17: //os
                    lstrcpy(szOs, szField);
                    break;
                case 18: //arch
                    lstrcpy(szArch, szField);
                    break;
                case 19: //major
                    ListView_SetItemText(hwndLV, lvItem.iItem, 5, LookupPlatform(szOs, szArch, szField));
                    break;
                case 20: //cfg
                    pIspInfo->dwCfgFlag = _ttoi(szField);
                    break;
                case 21: //ui
                    pIspInfo->dwUiFlag = _ttoi(szField);
                    break;
                default:
                    break;
            }
            pszField  = (TCHAR*)&szField;
            i++;
        }

        lvItem.iItem++;
        i = 0;
    }
    pFileBuff = pFileBuffStart;
}

void TryToUpdateListBox (HWND hwndDlg, int iListViewCtrlID, int iEditCtrlID)
{
    ASSERT(hwndDlg);

    HWND   hwndListView                   = NULL;
    HWND   hwndEdit                       = NULL;
    HFILE  hOfferFile                     = NULL;
    DWORD  dwSize                         = 0;
    TCHAR  szCabPath           [MAX_PATH] = TEXT("\0");
    TCHAR  szOfferInfoFilePath [MAX_PATH] = TEXT("\0");
    void* pFileBuff                       = NULL;

    hwndListView  = GetDlgItem(hwndDlg, iListViewCtrlID);
    hwndEdit      = GetDlgItem(hwndDlg, iEditCtrlID);

    GetWindowText(hwndEdit, szCabPath, sizeof(szCabPath));

    if (!ValidateOfferFile(szCabPath, VALID_MAIN_OFFER_FILE_TYPE))
    {
        if (IsWindowEnabled(hwndListView))
        {
            Static_Enable(hwndListView, FALSE);
            PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
        }
        return; //FAILURE
    }

    RemoveTempOfferDirectory();

    if(!ExpandOfferFileIntoDir(szCabPath, TEMP_OFFER_DIR))
        return; //FAILURE

    lstrcpy(szOfferInfoFilePath, TEMP_OFFER_DIR);
    lstrcat(szOfferInfoFilePath, VALID_OFFER_INFO_FILE_NAME);

    if (!ValidateOfferFile(szOfferInfoFilePath, VALID_OFFER_INFO_FILE_TYPE))
    {
        MessageBox(hwndDlg, TEXT("The selected cab is not a valid Offer Wizard 5.0 file."), NULL, MB_OK);
        return; //FAILURE
    }

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, szOfferInfoFilePath, MAX_PATH+1);
    hOfferFile = _lopen(szTmp, OF_READ | OF_SHARE_EXCLUSIVE);
#else
    hOfferFile = _lopen(szOfferInfoFilePath, OF_READ | OF_SHARE_EXCLUSIVE);
#endif
    if (hOfferFile)
    {
        dwSize = GetFileSize((HANDLE)LongToHandle(hOfferFile), NULL);
        if(dwSize)
        {
            pFileBuff =  malloc(dwSize + 1);

            if (pFileBuff)
            {
                if (_lread(hOfferFile, pFileBuff, dwSize) != HFILE_ERROR)
                {

                    ListView_DeleteAllItems(hwndListView);
                    AddOffersToListView(hwndListView, (TCHAR*)pFileBuff, dwSize);
                    Static_Enable(hwndListView, TRUE);
                    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
                }
                free(pFileBuff);
            }
        }
        _lclose(hOfferFile);
    }
}

void Browse (HWND hwndDlg)
{
    OPENFILENAME ofn;

    TCHAR szNewFileBuff[MAX_PATH + 1] = TEXT("\0");
    TCHAR szDesktopPath[MAX_PATH + 1] = TEXT("\0");

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwndDlg;
    ofn.lpstrFilter       = BROWSE_FILTER;
    ofn.lpstrFile         = szNewFileBuff;
    ofn.nMaxFile          = sizeof(szNewFileBuff);
    ofn.lpstrFileTitle    = NULL;
    ofn.lpstrInitialDir   = szDesktopPath;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lCustData         = 0;
    ofn.nFilterIndex      = 1L;
    ofn.nMaxFileTitle     = 0;
    ofn.Flags             = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY |
                            OFN_EXPLORER      | OFN_LONGNAMES;

    GetOpenFileName(&ofn);
    SetWindowText(GetDlgItem(hwndDlg, IDC_ISPCAB_PATH), ofn.lpstrFile);
}

void SetupOfferToDebug (HWND hwndDlg, int iListViewCtrlID)
{
    ASSERT(hwndDlg);

    TCHAR      szCabPath    [MAX_PATH] = TEXT("\0");
    TCHAR      szFullPath   [MAX_PATH] = TEXT("\0");
    TCHAR      szCSVFile    [MAX_PATH] = TEXT("\0");
    HWND       hwndListView            = GetDlgItem(hwndDlg, iListViewCtrlID);
    int        iItem                   = ListView_GetSelectionMark(hwndListView);
    ISPSTRUCT* pIspStruct              = NULL;
    LVITEM     lvItem;

    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iItem;

    ListView_GetItem(hwndListView, &lvItem);
    pIspStruct = (ISPSTRUCT*)lvItem.lParam;

    lstrcpy(szFullPath, TEMP_OFFER_DIR);
    lstrcat(szFullPath, pIspStruct->szCab);

    if (ValidateOfferFile(szFullPath, VALID_MAIN_OFFER_FILE_TYPE))
    {
        RemoveDownloadDirectory();

        if (ExpandOfferFileIntoDir (szFullPath, DOWNLOAD_OFFER_DIR))
        {
            HFILE hIspCsvFile = NULL;

            lstrcpy(szCSVFile, DOWNLOAD_OFFER_DIR);
            lstrcat(szCSVFile, VALID_ICW_INFO_FILE_NAME);

#ifdef UNICODE
            CHAR szTmp[MAX_PATH+1];
            wcstombs(szTmp, szCSVFile, MAX_PATH+1);
            if ((hIspCsvFile = _lcreat(szTmp, 0))!= HFILE_ERROR)
#else
            if ((hIspCsvFile = _lcreat(szCSVFile, 0))!= HFILE_ERROR)
#endif
            {
                //write header
                _hwrite(hIspCsvFile, ISPINFO_CSV_HEADER, strlen(ISPINFO_CSV_HEADER));
                WriteCSVLine(hwndListView, iItem, hIspCsvFile);
                _lclose(hIspCsvFile);
            }

        }
    }
}

// Header Format of the CSV File
#define CSV_FORMAT50	_T("'%s',%d,%s%s,%s%s,%s%s,%s%s,%s%s,%lu,%lu,%s%s,%s%s,%s,%s,%ld\r\n")
//                         "Name,OfferID,Icon,LocalHtm,OEMSpecialIcon,OEMSpecialHtm,ISPFile,CFGFlag,UIFlag,BillingForm,PayCSV,GUID,MIRS,LCID\r\n";
#define GUID            _T("11111111-00000-000000000-0")

BOOL WriteCSVLine (HWND hwndLV, int iSelItem, HFILE hFile)
{
    ASSERT(hwndLV);
    ASSERT(hFile);

    TCHAR      szIspCsvLine  [1024]     = TEXT("\0");
    TCHAR      szName        [MAX_PATH] = TEXT("\0");
    ISPSTRUCT* pIspStruct               = NULL;
    LVITEM     lvItem;

    lvItem.mask     = LVIF_PARAM;
    lvItem.iItem    = iSelItem;

    ListView_GetItemText(hwndLV, iSelItem, 1,  szName, sizeof(szName));

    ListView_GetItem(hwndLV, &lvItem);

    pIspStruct = (ISPSTRUCT*)lvItem.lParam;

    wsprintf(szIspCsvLine, CSV_FORMAT50,
             pIspStruct->szISPName,
             0,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szIcon,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szLocalHtm,
             (pIspStruct->szOEMButton[0] != TEXT('\0') ? DOWNLOAD_OFFER_DIR : TEXT("")),
             (pIspStruct->szOEMButton[0] != TEXT('\0') ? pIspStruct->szOEMButton : TEXT("")),
             (pIspStruct->szOEMTeaseHTM[0] != TEXT('\0') ? DOWNLOAD_OFFER_DIR : TEXT("")),
             (pIspStruct->szOEMTeaseHTM[0] != TEXT('\0') ? pIspStruct->szOEMTeaseHTM : TEXT("")),
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szIspFile,
             pIspStruct->dwCfgFlag,
             pIspStruct->dwUiFlag,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szBilling,
             DOWNLOAD_OFFER_DIR,
             pIspStruct->szPayCsv,
             GUID,
             pIspStruct->szMIRS,
             pIspStruct->dwLCID);

#ifdef UNICODE
    CHAR szTmp[1024];
    wcstombs(szTmp, szIspCsvLine, 1024);
    _hwrite(hFile, szTmp, lstrlenA(szTmp));
#else
    _hwrite(hFile, szIspCsvLine, lstrlen(szIspCsvLine));
#endif

    return TRUE;
}

/************************************************
*************************************************
*************************************************
************************************************/

void SetKeyValues (HKEY hKey, DWORD dwCorpNet, DWORD dwDbgPath, DWORD dwIspFile, TCHAR* pszUrl, size_t sizeUrl)
{
    RegSetValueEx(hKey,
                  CORPNET_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwCorpNet,
                  sizeof(dwCorpNet));

    RegSetValueEx(hKey,
                  DBGPATH_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwDbgPath,
                  sizeof(dwDbgPath));

    RegSetValueEx(hKey,
                  ISPFILE_VAL,
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwIspFile,
                  sizeof(dwIspFile));

    RegSetValueEx(hKey,
                  URL_VAL,
                  0,
                  REG_SZ,
                  (LPBYTE)pszUrl,
                  sizeUrl);
}

void GetSettingsFromReg (HKEY hKey, HWND hDlg)
{
    DWORD dwVal            = 0;
    DWORD dwSize           = sizeof(dwVal);
    TCHAR szUrl [MAX_PATH] = TEXT("\0");

    RegQueryValueEx(hKey,
                    CORPNET_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK),  (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_MODEM),       !(BOOL)dwVal);

    RegQueryValueEx(hKey,
                    DBGPATH_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH),  (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_AUTO_PATH),   !(BOOL)dwVal);

    RegQueryValueEx(hKey,
                    ISPFILE_VAL,
                    0,
                    NULL,
                    (LPBYTE)&dwVal,
                    &dwSize);

    Button_SetCheck(GetDlgItem(hDlg, IDC_ISP_URL),    (BOOL)dwVal);
    Button_SetCheck(GetDlgItem(hDlg, IDC_OTHER_URL), !(BOOL)dwVal);

    dwSize = sizeof(szUrl);

    RegQueryValueEx(hKey,
                    URL_VAL,
                    0,
                    NULL,
                    (LPBYTE)&szUrl,
                    &dwSize);

    SetWindowText(GetDlgItem(hDlg, IDC_URL), szUrl);
    Edit_Enable(GetDlgItem(hDlg, IDC_URL), !(BOOL)dwVal);
}

void SetSettingsInReg (HWND hDlg)
{
    HKEY  hKey             = NULL;
    DWORD dwAction         = 0;
    DWORD dwCorpNet        = 0;
    DWORD dwDbgPath        = 0;
    DWORD dwIspFile        = 0;
    TCHAR szUrl [MAX_PATH] = TEXT("\0");

    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 ICWDEBUG_KEY,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey);

    dwCorpNet = Button_GetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK));
    dwDbgPath = Button_GetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH));
    dwIspFile = Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL));

    GetWindowText(GetDlgItem(hDlg, IDC_URL), szUrl, sizeof(szUrl));

    SetKeyValues(hKey, dwCorpNet, dwDbgPath, dwIspFile, szUrl, lstrlen(szUrl));

    lstrcpy(gpWizardState->cmnStateData.ispInfo.szIspURL, szUrl);

    RegCloseKey(hKey);
}

void InitRegKeySettings (HWND hDlg)
{
    HKEY  hKey     = NULL;
    DWORD dwAction = 0;

    RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                   ICWDEBUG_KEY,
                   0,
                   NULL,
                   0,
                   KEY_ALL_ACCESS,
                   NULL,
                   &hKey,
                   &dwAction);

    if (dwAction == REG_CREATED_NEW_KEY)
        SetKeyValues(hKey, 0, 1, 1, TEXT("\0"), 1);

    GetSettingsFromReg(hKey, hDlg);

    RegCloseKey(hKey);
}

BOOL CALLBACK DebugSettingsInitProc (HWND hDlg,BOOL fFirstInit, UINT *puNextPage)
{
    if(!fFirstInit)
        InitRegKeySettings(hDlg);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

BOOL CALLBACK DebugSettingsOKProc (HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL * pfKeepHistory)
{
    SetSettingsInReg(hDlg);

    if (fForward)
    {
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_USE_NETWORK)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_MODEMOVERRIDE;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_MODEMOVERRIDE;

        if(!Button_GetCheck(GetDlgItem(hDlg, IDC_SIGNUP_PATH)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_AUTOCONFIG;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_AUTOCONFIG;

        if(!Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL)))
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_ISPURLOVERRIDE;
        else
            gpWizardState->cmnStateData.dwFlags &= ~ICW_CFGFLAG_ISPURLOVERRIDE;


        if (LoadICWCONNUI(GetParent(hDlg),
                          GetDlgIDFromIndex(ORD_PAGE_ICWDEBUG_SETTINGS),
                          IDD_PAGE_END,
                          gpWizardState->cmnStateData.dwFlags))
        {

            if( DialogIDAlreadyInUse(g_uICWCONNUIFirst))
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list, infact, we need to back
                // the history up 1, because we are going to come back here directly
                // from the DLL, not from the history list.

                *pfKeepHistory = FALSE;

                *puNextPage = g_uICWCONNUIFirst;
            }
        }
    }
    return TRUE;
}

BOOL CALLBACK DebugSettingsCmdProc (HWND hDlg, WPARAM wParam, LPARAM  lParam)
{
   DWORD dwMsg = GET_WM_COMMAND_CMD(wParam, lParam);

    switch(dwMsg)
    {
        case BN_CLICKED:
        {
            if((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ISP_URL) ||
               (GET_WM_COMMAND_ID(wParam, lParam) == IDC_OTHER_URL))
                Edit_Enable(GetDlgItem(hDlg, IDC_URL), !Button_GetCheck(GetDlgItem(hDlg, IDC_ISP_URL)));
            break;
        }
        default:
            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwext.cpp ===
/******************************************************

  ICWEXT.CPP 

  Contains definitions for global variables and
  functions used for including wizard pages from ICWCONN.DLL

 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1996
 *  All rights reserved


  5/14/98   donaldm     created

 ******************************************************/

#include "pre.h"
#include "initguid.h"   // Make DEFINE_GUID declare an instance of each GUID
#include "icwacct.h"
#include "icwconn.h"
#include "webvwids.h"       // GUIDS for the ICW WEBVIEW class
#include "icwextsn.h"
#include "icwcfg.h"

extern BOOL g_bManualPath;     
extern BOOL g_bLanPath;     

IICW50Apprentice    *gpICWCONNApprentice = NULL;    // ICWCONN apprentice object
IICWApprenticeEx     *gpINETCFGApprentice = NULL;    // ICWCONN apprentice object

//+----------------------------------------------------------------------------
//
//  Function    LoadICWCONNUI
//
//  Synopsis    Loads in the ICWCONN's apprentice pages
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fICWCONNUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     5/13/98 donaldm     adapted from INETCFG code
//
//-----------------------------------------------------------------------------

BOOL LoadICWCONNUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    if( g_fICWCONNUILoaded )
    {
        ASSERT( g_pCICWExtension );
        ASSERT( gpICWCONNApprentice );

        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI: UI already loaded, just reset first (%d) and last (%d) pages"),
                uPrevDlgID, uNextDlgID);
                
        // Set the State data for the external pages
        hResult = gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
        hResult = gpICWCONNApprentice->ProcessCustomFlags(dwFlags);
        hResult = gpICWCONNApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );

        goto LoadICWCONNUIExit;
    }


    if( !hWizHWND )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI got a NULL hWizHWND!"));
        return FALSE;
    }

    // Demand load the ICWCONN apprentice DLL, so we can dynamically update it
    if (!gpICWCONNApprentice)
    {
        HRESULT        hr;

        // Load the ICWCONN OLE in-proc server
        hr = CoCreateInstance(CLSID_ApprenticeICWCONN,NULL,CLSCTX_INPROC_SERVER,
                              IID_IICW50Apprentice,(LPVOID *)&gpICWCONNApprentice);

        if ( (!SUCCEEDED(hr) || !gpICWCONNApprentice) )
        {
            g_fICWCONNUILoaded = FALSE;
            TraceMsg(TF_ICWEXTSN, TEXT("Unable to CoCreateInstance on IID_IICW50Apprentice!  hr = %x"), hr);
            
            return FALSE;
        }
    }
    
    
    ASSERT(gpICWCONNApprentice);
    if( NULL == g_pCICWExtension )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("Instantiating ICWExtension and using it to initialize ICWCONN's IICW50Apprentice"));
        g_pCICWExtension = new( CICWExtension );
        g_pCICWExtension->AddRef();
        g_pCICWExtension->m_hWizardHWND = hWizHWND;
        gpICWCONNApprentice->Initialize( g_pCICWExtension );
        
        // Initialize the DLL's state data before adding the pages.
        gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
    }

    
    // Add the DLL's wizard pages
    hResult = gpICWCONNApprentice->AddWizardPages(dwFlags);

    if( !SUCCEEDED(hResult) )
    {
        goto LoadICWCONNUIExit;
    }

    hResult = gpICWCONNApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );


LoadICWCONNUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fICWCONNUILoaded = TRUE;
        return TRUE;
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI failed with (hex) hresult %x"), hResult);
        return FALSE;
    }
}



//+----------------------------------------------------------------------------
//
//  Function    LoadInetCfgUI
//
//  Synopsis    Loads in the InetCfg's apprentice pages
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fICWCONNUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     5/13/98 donaldm     adapted from INETCFG code
//              10/5/00 seanch      No longer want to see the Mail & News stuff
//
//-----------------------------------------------------------------------------

BOOL LoadInetCfgUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    dwFlags |= (WIZ_USE_WIZARD97 | WIZ_NO_MAIL_ACCT | WIZ_NO_NEWS_ACCT);

    if( g_fINETCFGLoaded )
    {
        ASSERT( g_pCINETCFGExtension );
        ASSERT( gpINETCFGApprentice );

        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI: UI already loaded, just reset first (%d) and last (%d) pages"),
                uPrevDlgID, uNextDlgID);
        hResult = gpINETCFGApprentice->ProcessCustomFlags(dwFlags);
        //need to watch the retrun here since user may cancel out of installing files
        //and we don't want to hide the failure if the do.
        if( !SUCCEEDED(hResult) )
            goto LoadInetCfgUIExit;
        hResult = gpINETCFGApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
        goto LoadInetCfgUIExit;
    }


    if( !hWizHWND )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("LoadICWCONNUI got a NULL hWizHWND!"));
        return FALSE;
    }

    // Demand load the ICWCONN apprentice DLL, so we can dynamically update it
    if (!gpINETCFGApprentice)
    {
        HRESULT        hr;

        // Load the ICWCONN OLE in-proc server
        hr = CoCreateInstance(/*CLSID_ApprenticeAcctMgr*/ CLSID_ApprenticeICW,NULL,CLSCTX_INPROC_SERVER,
                              IID_IICWApprenticeEx,(LPVOID *)&gpINETCFGApprentice);

        if ( (!SUCCEEDED(hr) || !gpINETCFGApprentice) )
        {
            g_fICWCONNUILoaded = FALSE;
            TraceMsg(TF_ICWEXTSN, TEXT("Unable to CoCreateInstance on IID_IICW50Apprentice!  hr = %x"), hr);
            
            return FALSE;
        }
    }
    
    
    ASSERT(gpINETCFGApprentice);
    if( NULL == g_pCINETCFGExtension )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("Instantiating ICWExtension and using it to initialize ICWCONN's IICW50Apprentice"));
        g_pCINETCFGExtension = new( CICWExtension );
        g_pCINETCFGExtension->AddRef();
        g_pCINETCFGExtension->m_hWizardHWND = GetParent(hWizHWND);
        gpINETCFGApprentice->SetDlgHwnd(hWizHWND);
        gpINETCFGApprentice->Initialize((struct IICWExtension *)g_pCINETCFGExtension);
    }

    hResult = gpINETCFGApprentice->AddWizardPages(dwFlags | WIZ_USE_WIZARD97);

    if( !SUCCEEDED(hResult) )
    {
        goto LoadInetCfgUIExit;
    }

    hResult = gpINETCFGApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );


LoadInetCfgUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fINETCFGLoaded = TRUE;
        return TRUE;
    }
    else
    {
        // Check if we are in /smartreboot mode, if so, don't add icw to runonce
        // to avoid infinite reboot.
        if (gpINETCFGApprentice && !g_bManualPath && !g_bLanPath)
        {
            HKEY    hkey;

            // Verify that we really changed the desktop
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              ICWSETTINGSPATH,
                                              0,
                                              KEY_ALL_ACCESS,
                                              &hkey))
            {
                DWORD   dwICWErr = 0;    
                DWORD   dwTmp = sizeof(DWORD);
                DWORD   dwType = 0;
        
                RegQueryValueEx(hkey, 
                                ICW_REGKEYERROR, 
                                NULL, 
                                &dwType,
                                (LPBYTE)&dwICWErr, 
                                &dwTmp);
                RegDeleteValue(hkey, ICW_REGKEYERROR);
                RegCloseKey(hkey);
        
                // Bail if the desktop was not changed by us
                if(dwICWErr & ICW_CFGFLAG_SMARTREBOOT_MANUAL)
                {
                    ShowWindow(GetParent(hWizHWND), FALSE);

                    Reboot(GetParent(hWizHWND));
                    gfQuitWizard = TRUE;

                }            
            }

        }
        TraceMsg(TF_ICWEXTSN, TEXT("LoadInetCfgUIExit failed with (hex) hresult %x"), hResult);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwextsn.cpp ===
/****************************************************************************
 *
 *  ICWESTSN.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWExtension class.
 *
 *  05/14/98    donaldm     copied from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "icwconn.h"
#include "icwextsn.h"


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::AddExternalPage
//
//  Synopsis    Adds a page created via CreatePropertySheetPage to the main
//              property sheet/wizard.
//
//
//  Arguments   hPage -- page handle returned from CreatePropertySheetPage
//              uDlgID -- the dialog ID of the page to be added, as defined
//                        the resource file of the page's owner.
//
//
//  Returns     FALSE is the dlgID is already in use in the Wizard
//              TRUE otherwise
//
//  Notes:      PropSheet_AddPage does not return a usefull error code.  Thus
//              the assumption here is that every AddPage will succeed.  But, even
//              though it is not enforced by PropSheet_AddPage, every page in the
//              PropSheet must have a unique dialog ID.  Thus, if the uDlgID passed
//              in has previously been added to the PropSheet, we'll return FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::AddExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
    LRESULT lResult= 0;

    if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uDlgID %d is out of range!"), uDlgID);
        return( FALSE );
    }

    if( !DialogIDAlreadyInUse(uDlgID) )
    {
        SetDialogIDInUse( uDlgID, TRUE );
        lResult = PropSheet_AddPage(m_hWizardHWND, hPage);
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: PS_AddPage DlgID %d"), uDlgID);

        return(TRUE);
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: AddExternalPage DlgID %d is already in use, rejecting this page!"), uDlgID);
        return(FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::RemoveExternalPage
//
//  Synopsis    Removes a page added via ::AddExternalPage to the main
//              property sheet/wizard.
//
//
//  Arguments   hPage -- page handle returned from CreatePropertySheetPage
//              uDlgID -- the dialog ID of the page to be removed, as defined
//                        the resource file of the page's owner.
//
//
//  Returns     FALSE is the dlgID is not already in use in the Wizard
//              TRUE otherwise
//
//  Notes:      PropSheet_RemovePage does not return a usefull error code.  Thus
//              the assumption here is that every RemovePage will succeed if that
//              dialog id is currently in the property sheet
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::RemoveExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
    if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uDlgID %d is out of range!"), uDlgID);
        return( FALSE );
    }

    if( DialogIDAlreadyInUse(uDlgID) )
    {
        SetDialogIDInUse( uDlgID, FALSE );
        PropSheet_RemovePage(m_hWizardHWND, NULL, hPage);
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: propmgr: PS_RemovePage DlgID %d"), uDlgID);

        return(TRUE);
    }
    else
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: RemoveExternalPage: DlgID %d was not marked as in use!"), uDlgID);
        return(FALSE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::ExternalCancel
//
//  Synopsis    Notifies the wizard that the user has cancelled while in the
//              apprentice pages
//
//
//  Arguments   uCancelType -- tells the wizard whether it should immediately
//                              quit out, or whether it should show the confirmation
//                              dialog (as though the user had hit Cancel within the
//                              wizard itself.)
//
//
//  Returns     TRUE if we're about to exit the wizard
//              FALSE if not.
//
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::ExternalCancel( CANCELTYPE uCancelType )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: propmgr.cpp: received ExternalCancel callback"));
    switch( uCancelType )
    {
        case CANCEL_PROMPT:
            gfUserCancelled = (MsgBox(m_hWizardHWND,
                                      IDS_QUERYCANCEL,
                                      MB_ICONQUESTION,MB_YESNO |  MB_DEFBUTTON2) == IDYES);
    
            if( gfUserCancelled )
            {
                PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
                gfQuitWizard = TRUE;
                return( TRUE );
            }
            else
            {
                return( FALSE );
            }
            break;

        case CANCEL_SILENT:
            PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
            gfQuitWizard = TRUE;
            return( TRUE );
            break;

        case CANCEL_REBOOT:
            PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
            gfQuitWizard = TRUE;
            gpWizardState->fNeedReboot = TRUE;
            return( TRUE );
            break;

        default:
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: ExternalCancel got an unkown CancelType!"));
            return( FALSE );
    }
    
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::SetFirstLastPage
//
//  Synopsis    Lets the apprentice notify the wizard of the dialog IDs of the
//              first and last pages in the apprentice
//
//
//  Arguments   uFirstPageDlgID -- DlgID of first page in apprentice.
//              uLastPageDlgID -- DlgID of last page in apprentice
//
//
//  Returns     FALSE if the parameters passed in are out of range
//              TRUE if the update succeeded.
//
//  Notes:      If either variable is set to 0, the function will not update
//              that information, i.e. a value of 0 means "ignore me".  If both
//              variables are 0, the function immediately returns FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID)
{

    // validation code galore!
    if( (0 == uFirstPageDlgID) && (0 == uLastPageDlgID) )
    {
        TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: both IDs are 0!"));
        return( FALSE );
    }

    if( (0 != uFirstPageDlgID) )
    {
        if ( (uFirstPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uFirstPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uFirstPageDlgID %d is out of range!"), uFirstPageDlgID);
            return( FALSE );
        }

        if( !DialogIDAlreadyInUse(uFirstPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uFirstPageDlgID %d not marked as in use!"), uFirstPageDlgID);
            return( FALSE );
        }
    }

    if( (0 != uLastPageDlgID) )
    {
        if ( (uLastPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uLastPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uLastPageDlgID %d is out of range!"), uFirstPageDlgID);
            return( FALSE );
        }

        if( !DialogIDAlreadyInUse(uLastPageDlgID) )
        {
            TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: uLastPageDlgID %d not marked as in use!"), uFirstPageDlgID);
            return( FALSE );
        }
    }
    
    if( 0 != uFirstPageDlgID )
        g_uICWCONNUIFirst = uFirstPageDlgID;
    if( 0 != uLastPageDlgID )
        g_uICWCONNUILast = uLastPageDlgID;
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: SetFirstLastPage: updating mail, first = %d, last = %d"),
        uFirstPageDlgID, uLastPageDlgID);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICW50Apprentice
//              (Taken from Inside COM, chapter 7)
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWExtension::QueryInterface( REFIID riid, void** ppv )
{

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICW50Apprentice
    if (IID_IICW50Apprentice == riid)
        *ppv = (void *)(IICW50Apprentice *)this;
    // IID_IICWExtension
    else if (IID_IICW50Extension == riid)
        *ppv = (void *)(IICW50Extension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::AddRef
//
//  Synopsis    This is the standard AddRef
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::AddRef( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension::AddRef called %d"), m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::Release
//
//  Synopsis    This is the standard Release
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::Release( void )
{

    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension::Release called %d"), m_lRefCount);

    if( 0 == m_lRefCount )
    {
        delete( this );
        return( 0 );
    }
    else
    {
        return( m_lRefCount );
    }
    
}


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::CICWExtension
//
//  Synopsis    The constructor.  Initializes member variables to NULL.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWExtension::CICWExtension( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension constructor called"));
    m_lRefCount = 0;
    m_hWizardHWND = NULL;
}


//+----------------------------------------------------------------------------
//
//  Function    CICWExtension::CICWExtension
//
//  Synopsis    The constructor.  Since there was no fancy initialization,
//              there's nothing to do here.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWExtension::~CICWExtension( void )
{
    TraceMsg(TF_ICWEXTSN, TEXT("ICWEXTSN: CICWExtension destructor called with ref count of %d"), m_lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwconn1.h ===
//**********************************************************************
// File name: icwconn1.h
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#ifdef WIN32
#define EXPORT
#else
#define EXPORT __export
#endif

#define MAX_STRING              128

#define WIZ97_TITLE_FONT_PTS    12

#define WM_MYINITDIALOG             WM_USER
#define WM_USER_DOWNLOADCOMPLETE    ((WM_USER) + 1)

#define CONNWIZAPPNAME TEXT("InternetConnectionWizardWClass")

#define SETUPPATH_NONE TEXT("current")
#define SETUPPATH_MANUAL TEXT("manual")
#define SETUPPATH_AUTO TEXT("automatic")
#define MAX_SETUPPATH_TOKEN 200
#define MAX_PROMO 64

#define SMART_QUITICW FALSE

// Trace flags
#define TF_ICWCONN1         0x00000010      // General ICWCONN1 stuff
#define TF_GENDLG           0x00000020
#define TF_ICWEXTSN         0x00000040

extern INT              _convert;
extern HINSTANCE        g_hInstance;
extern WIZARDSTATE      *gpWizardState;
extern BOOL             g_bHelpShown;
extern DWORD            *g_pdwDialogIDList;
extern DWORD            g_dwDialogIDListSize;
extern BOOL             gfQuitWizard;
extern BOOL             gfUserCancelled;
extern BOOL             gfUserBackedOut;
extern BOOL             gfUserFinished;
extern BOOL             gfBackedUp;
extern BOOL             gfReboot;
extern BOOL             g_bReboot;
extern BOOL             g_bRunOnce;
extern BOOL             g_bAllowCancel;
extern PAGEINFO         PageInfo[];
extern BOOL             g_fICWCONNUILoaded;
extern BOOL             g_fINETCFGLoaded;
extern BOOL             g_bRunDefaultHtm;  
extern TCHAR            g_szShellNext[];
extern TCHAR            g_szBrandedHTML[];

#define ICWSETTINGSPATH TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWDESKTOPCHANGED TEXT("DesktopChanged")



typedef DWORD (WINAPI *PFNIsSmartStart)(void);
typedef DWORD (WINAPI *PFNIsSmartStartEx)(LPTSTR, DWORD);

#define STR_BSTR    0
#define STR_OLESTR  1
#define BSTRFROMANSI(x) (BSTR)MakeWideStrFromAnsi((LPTSTR)(x), STR_BSTR)
#define ANSIFROMOLE(x) (LPTSTR)MakeAnsiStrFromWide((LPCWSTR)(x))

#define TO_ASCII(x) (TCHAR)((unsigned TCHAR)x + 0x30)
LPWSTR MakeWideStrFromAnsi (LPTSTR psz, BYTE bType);
LPTSTR MakeAnsiStrFromWide (LPCWSTR lpwstr);

int PASCAL WinMainT(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPTSTR lpCmdLine,int nCmdShow);
BOOL InitApplication(HANDLE hInstance);
BOOL InitInstance(HANDLE hInstance, int nCmdShow);

long FAR PASCAL EXPORT MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
long FAR PASCAL EXPORT DocWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FAR PASCAL EXPORT About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#ifdef ICWDEBUG
void RemoveTempOfferDirectory (void);
#endif

void RemoveDownloadDirectory (void);
void DeleteDirectory (LPCTSTR szDirName);

BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

BOOL WINAPI ConfigureSystem(HWND hDlg);
BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance);
BOOL CheckForIEAKRestriction(HINSTANCE hInstance);
BOOL CheckForOemConfigFailure(HINSTANCE hInstance);
BOOL RunOemconfigIns();

// Function avalable in UTIL.CPP
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
void SetICWComplete(void);
void OlsFinish(void);
LPTSTR GetSz(WORD wszID);
BOOL ConfirmCancel(HWND hWnd);
BOOL Restart(HWND hWnd);
void Reboot(HWND hWnd);

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPTSTR WINAPI W2AHelper(LPTSTR lpa, LPCWSTR lpw, int nChars);

#ifndef A2WHELPER
#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper
#endif

#ifdef UNICODE
#define A2W(lpa)  (lpa)
#define W2A(lpw)  (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))


// For events
HRESULT ConnectToICWConnectionPoint(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);

// In reboot.cpp
BOOL SetupForReboot(long lRebootType);
void DeleteStartUpCommand();

// In Desktop.cpp
void UpdateWelcomeRegSetting(BOOL    bSetBit);
BOOL GetCompletedBit();
void UndoDesktopChanges(HINSTANCE   hAppInst);
void QuickCompleteSignup();
void ICWCleanup();

void WINAPI FillWindowWithAppBackground(HWND hWndToFill, HDC hdc);
void FillDCRectWithAppBackground(LPRECT lpRectDC, LPRECT lpRectApp, HDC hdc);

#define MAX_PROMO 64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwextsn.h ===
#include "icwconn.h"
#include "icwacct.h"

extern  UINT                g_uICWCONNUIFirst, g_uICWCONNUILast;

#ifndef EXTERNAL_DIALOGID_MAXIMUM
#define EXTERNAL_DIALOGID_MAXIMUM 3000
#endif
#ifndef EXTERNAL_DIALOGID_MINIMUM
#define EXTERNAL_DIALOGID_MINIMUM 2000
#endif

class CICWExtension : public IICW50Extension
{
    public:
        virtual BOOL    STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
        virtual BOOL    STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
        virtual BOOL    STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
        virtual BOOL    STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);
        virtual HWND    STDMETHODCALLTYPE GetWizardHwnd(void)
        {
            return m_hWizardHWND;
        };            
        
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWExtension( void );
        ~CICWExtension( void );

        HWND m_hWizardHWND;

    private:
        LONG    m_lRefCount;
};

// This _has_ to be a pointer -- if you just instantiate directly, the compiler doesn't
// correctly fill in the vtable, and thus it can't be treated as an IICWExtension pointer.
extern CICWExtension        *g_pCICWExtension;
extern CICWExtension        *g_pCINETCFGExtension;
extern IICW50Apprentice     *gpICWCONNApprentice;
extern IICWApprenticeEx     *gpINETCFGApprentice;

extern BOOL LoadICWCONNUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );
extern BOOL LoadInetCfgUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\intro.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INTRO.C - Functions for introductory Wizard pages
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "windowsx.h"
#include "tutor.h"
#include "icwcfg.h"
#include "icwextsn.h"
extern UINT GetDlgIDFromIndex(UINT uPageIndex);

extern CICWTutorApp* g_pICWTutorApp; 
extern BOOL          g_bNewIspPath;     
extern BOOL          g_bAutoConfigPath; 
extern BOOL          g_bManualPath;     
extern BOOL          g_bLanPath;     
extern BOOL          g_bSkipIntro;
extern BOOL          MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen);

BOOL  g_bExistConnect                       = FALSE;
BOOL  g_bCheckForOEM                        = FALSE;
TCHAR g_szAnsiName    [ICW_MAX_RASNAME + 1] = TEXT("\0");


/*******************************************************************

  NAME:         ReadOEMOffline

  SYNOPSIS:     Read OfflineOffers flag from the oeminfo.ini file

  ENTRY:        None

  RETURN:       True if OEM offline is read

********************************************************************/
BOOL ReadOEMOffline(BOOL *bOEMOffline)
{
    // OEM code
    //
    TCHAR szOeminfoPath[MAX_PATH + 1];
    TCHAR *lpszTerminator = NULL;
    TCHAR *lpszLastChar = NULL;
    BOOL bRet = FALSE;

    // If we already checked, don't do it again
    if (!g_bCheckForOEM)
    {
        if( 0 != GetSystemDirectory( szOeminfoPath, MAX_PATH + 1 ) )
        {
            lpszTerminator = &(szOeminfoPath[ lstrlen(szOeminfoPath) ]);
            lpszLastChar = CharPrev( szOeminfoPath, lpszTerminator );

            if( TEXT('\\') != *lpszLastChar )
            {
                lpszLastChar = CharNext( lpszLastChar );
                *lpszLastChar = '\\';
                lpszLastChar = CharNext( lpszLastChar );
                *lpszLastChar = '\0';
            }

            lstrcat( szOeminfoPath, ICW_OEMINFO_FILENAME );

            //Default oem code must be NULL if it doesn't exist in oeminfo.ini
            if (1 == GetPrivateProfileInt(ICW_OEMINFO_ICWSECTION,
                                                ICW_OEMINFO_OFFLINEOFFERS,
                                                0,
                                                szOeminfoPath))
            {
                // Check if file already exists
                if (0xFFFFFFFF != GetFileAttributes(ICW_OEMINFOPath))
                {
                    bRet = TRUE;
                }
            }
        }
        *bOEMOffline = bRet;
        g_bCheckForOEM = TRUE;
    }
    return TRUE;
}

        
/*******************************************************************

  NAME:      SetNextPage

  SYNOPSIS:  Determine whether we should proceed to icwconn.dll

********************************************************************/
BOOL SetNextPage(HWND hDlg, UINT* puNextPage, BOOL *pfKeepHistory)
{
    BOOL bRetVal = FALSE;
    // If we have switched path, then redownload 
    if (gpWizardState->bDoneRefServDownload)
    {
        if ( (DWORD) (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG) != 
             (DWORD) (gpWizardState->dwLastSelection & ICW_CFGFLAG_AUTOCONFIG) )
        {
            gpWizardState->bDoneRefServDownload = FALSE;
        }
    }

    // Read OEM offline flag 
    ReadOEMOffline(&gpWizardState->cmnStateData.bOEMOffline);

    //
    // Make sure we are not in autoconfig 
    //
    if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG))
    {
        if (gpWizardState->cmnStateData.bOEMOffline && gpWizardState->cmnStateData.bOEMEntryPt)
            gpWizardState->bDoneRefServDownload = TRUE;
    }
    gpWizardState->dwLastSelection = gpWizardState->cmnStateData.dwFlags;

    // If we have completed the download, then list just jump to the next page
    if (gpWizardState->bDoneRefServDownload)
    //if (TRUE)
    {
        int iReturnPage = 0;

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
            iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
        else
        {
            if (gpWizardState->uPagesCompleted > 0)
            {
                iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted-1];
            }
            else
            {
                iReturnPage = gpWizardState->uCurrentPage;
            }
        }

        if (LoadICWCONNUI(GetParent(hDlg), GetDlgIDFromIndex(iReturnPage), IDD_PAGE_DEFAULT, gpWizardState->cmnStateData.dwFlags))
        {
            if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                *puNextPage = g_uICWCONNUIFirst;
        
                // Backup 1 in the history list, since we the external pages navigate back
                // we want this history list to be in the correct spot.  Normally
                // pressing back would back up the history list, and figure out where to
                // go, but in this case, the external DLL just jumps right back in.
                // We also don't want to keep histroy.
                if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED))
                {
                    if (gpWizardState->uPagesCompleted > 0)
                    {
                        gpWizardState->uPagesCompleted--;
                    }
                    else
                    {
                        if (pfKeepHistory)
                        {
                            *pfKeepHistory = FALSE;
                        }
                    }
                }
                bRetVal = TRUE;
        
            }
        }
    }
    return bRetVal;

}

/*******************************************************************

  NAME:      SetIntroNextPage

  SYNOPSIS:  Determine whether we what is the next page of intro page

********************************************************************/
void SetIntroNextPage(HWND hDlg, UINT* puNextPage, BOOL *pfKeepHistory)
{
    short   wNumLocations;
    long    lCurrLocIndex;
    BOOL    bRetVal;

    *puNextPage = ORD_PAGE_AREACODE;
    // Check dialing location here to prevent flashing of areacode page
    gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
    gpWizardState->pTapiLocationInfo->get_wNumberOfLocations(&wNumLocations, &lCurrLocIndex);
    if (1 >= wNumLocations)
    {
        BSTR    bstrAreaCode = NULL;
        DWORD   dwCountryCode;

        *puNextPage = ORD_PAGE_REFSERVDIAL;
        
        gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
        gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
        
        gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
        lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
        SysFreeString(bstrAreaCode);

        // we can skip area code page
        *puNextPage = ORD_PAGE_REFSERVDIAL;
        SetNextPage(hDlg, puNextPage, pfKeepHistory);
    }
}

INT_PTR CALLBACK ExistingConnectionCmdProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            // put the dialog in the center of the screen
            RECT rc;
            TCHAR   szFmt   [MAX_MESSAGE_LEN];
            TCHAR   *args   [1];
            LPVOID  pszIntro;

            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg,
                        NULL,
                        ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                        ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                        0, 0, SWP_NOSIZE | SWP_NOACTIVATE);


            args[0] = (LPTSTR) lParam;
    
            LoadString(g_hInstance, IDS_EXIT_CONN, szFmt, ARRAYSIZE(szFmt));
                
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                          szFmt, 
                          0, 
                          0, 
                          (LPTSTR)&pszIntro, 
                          0,
                          (va_list*)args);
   
            SetWindowText(GetDlgItem(hDlg, IDC_EXIT_CONN), (LPTSTR) pszIntro);
            LocalFree(pszIntro);
 
            break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    EndDialog(hDlg,TRUE);
                    break;

                case IDCANCEL:
                   EndDialog(hDlg,FALSE);
                    break;                  
            }
            break;
    }

    return FALSE;
}

/*******************************************************************

  NAME:    IntroInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK IntroInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED) 
        &&!(gpWizardState->cmnStateData.bOEMCustom)
       )
    {
        // This is the very first page, so do not allow back
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    if (fFirstInit)
    {        
//#ifdef  NON_NT5
        // Hide the manual option when running in run once
        if (g_bRunOnce)
        {
            ShowWindow(GetDlgItem(hDlg, IDC_ICWMAN), SW_HIDE);
            EnableWindow(GetDlgItem(hDlg, IDC_ICWMAN), FALSE);
        }
                    
        // initialize radio buttons
        Button_SetCheck(GetDlgItem(hDlg, IDC_RUNNEW), g_bNewIspPath);
        Button_SetCheck(GetDlgItem(hDlg, IDC_RUNAUTO),  g_bAutoConfigPath);
        Button_SetCheck(GetDlgItem(hDlg, IDC_ICWMAN), g_bManualPath || g_bLanPath);

        if (SMART_QUITICW == MyIsSmartStartEx(g_szAnsiName, ARRAYSIZE(g_szAnsiName)))
             g_bExistConnect = TRUE;    
/* #else
        //We only support manual path for NT5 for NT5 beta3 release.
        EnableWindow(GetDlgItem(hDlg, IDC_RUNNEW), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RUNAUTO), FALSE);
        Button_SetCheck(GetDlgItem(hDlg, IDC_ICWMAN), TRUE);
#endif */

    }
    else
    {
        // If branded, then our template is intro2
        if ((gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
           || (gpWizardState->cmnStateData.bOEMCustom)
            )
        {
            gpWizardState->uCurrentPage = ORD_PAGE_INTRO2;
        }            
        else        
        {
            gpWizardState->uCurrentPage = ORD_PAGE_INTRO;
        }
        // If it is reboot from manual wiz, advance to the manual option page
        if (g_bManualPath || g_bLanPath)
        {
            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
            gpWizardState->uPagesCompleted++;
            
            TCHAR    szTitle[MAX_TITLE];
            LoadString(g_hInstance, IDS_APPNAME, szTitle, sizeof(szTitle));
            SetWindowText(GetParent(hDlg), szTitle); 

            *puNextPage = ORD_PAGE_MANUALOPTIONS;
        }

        if (g_bSkipIntro)
        {
            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
            g_bSkipIntro = FALSE;
        }
    }        
    return TRUE;
}

/*******************************************************************

  NAME:    IntroOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK IntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
         
        gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_AUTOCONFIG;
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_NEWISP;    
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG; // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_MANUAL;            
        gpWizardState->cmnStateData.dwFlags &= ~(DWORD)ICW_CFGFLAG_SMARTREBOOT_LAN;            

        // read radio button state
        if( IsDlgButtonChecked(hDlg, IDC_RUNNEW) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_NEWISP;
            
            if (g_bExistConnect)
            {
                if (!DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_EXISTINGCONNECTION),hDlg, 
                                    ExistingConnectionCmdProc, (LPARAM)g_szAnsiName))
                {                                   
                    gfQuitWizard = TRUE;            // Quit the wizard
                    return FALSE;
                }                    
            }
        
            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
        
            // OK, give me the next page
            SetIntroNextPage(hDlg, puNextPage, pfKeepHistory);
            
        }
        else if( IsDlgButtonChecked(hDlg, IDC_RUNAUTO) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG;

            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
            // The system config check is done in Inetcfg
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_AUTOCONFIG;

            SetIntroNextPage(hDlg, puNextPage, pfKeepHistory);
        }
        else if( IsDlgButtonChecked(hDlg, IDC_ICWMAN) )
        {
            *puNextPage = ORD_PAGE_MANUALOPTIONS;
        }
    }
    else if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED))
    {
        // Were are out of here, since we cannot go back from the first page
        gpWizardState->uPagesCompleted = 1;
        gfUserBackedOut = TRUE;
        gfQuitWizard = TRUE;
    }
    else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_BRANDED)
        gpWizardState->uPagesCompleted = 1;

    return TRUE;
}

BOOL CALLBACK IntroCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
        {
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_TUTORIAL)
                g_pICWTutorApp->LaunchTutorApp();
            break;
        }
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_RUNNEW: 
                case IDC_RUNAUTO: 
                case IDC_ICWMAN: 
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\isperr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPERR.CPP - Functions for ISP error dialog page
//
//  HISTORY:
//  
//  08/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"

/*******************************************************************

  NAME:    ISPErrorInitProc

  SYNOPSIS:  This is a transparent page.

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is a transparent page to determine which page to go
    // next based on error condition
    if (!fFirstInit)
    {
        if (gpICWCONNApprentice)
            gpICWCONNApprentice->SetStateDataFromDllToExe( &gpWizardState->cmnStateData);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        if (gpWizardState->cmnStateData.bOEMCustom)
            gpWizardState->uCurrentPage = ORD_PAGE_ENDOEMCUSTOM;
        else
            gpWizardState->uCurrentPage = ORD_PAGE_END;

        // there was a data corruption in download, go to server error page
        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            // Re-build the history list since we substract 1 in refdial
            gpWizardState->uPagesCompleted++;
            *puNextPage = ORD_PAGE_REFSERVERR;
        }
        else if (gpWizardState->cmnStateData.bPhoneManualWiz)
        {
            // If we are in OEM custom mode, then goto the manual page
            // which will handle switching to the external manual wizard
            if (gpWizardState->cmnStateData.bOEMCustom)
            {
                *puNextPage = ORD_PAGE_MANUALOPTIONS;
            }
            else
            {
                if (LoadInetCfgUI(  hDlg,
                                    IDD_PAGE_REFSERVDIAL,
                                    IDD_PAGE_END,
                                    WIZ_HOST_ICW_PHONE))
                {
                    if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                    {
                        // Re-build the history list since we substract 1 in refdial
                        gpWizardState->uPagesCompleted++;

                        // we're about to jump into the external apprentice, and we don't want
                        // this page to show up in our history list
                        *puNextPage = g_uICWCONNUIFirst;
                        g_bAllowCancel = TRUE;
                    }
                }
                gpWizardState->cmnStateData.bPhoneManualWiz = FALSE;
                gpICWCONNApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);
            }                
        }
        else
        {
            // Normal case goes to End page
            if (gpWizardState->cmnStateData.bOEMCustom)
                *puNextPage = ORD_PAGE_ENDOEMCUSTOM;
            else
                *puNextPage = ORD_PAGE_END;
        }

    }        
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\lookups.h ===
#ifndef _LOOKUPS_H
#define _LOOKUPS_H

#define LCIDLEN     124
#define CIDLEN      241
#define PLATFORMLEN 9

typedef struct LCIDstruct
{
    int    iLCID;
    TCHAR* pszLcid;

} LCIDSTRUCT;

typedef struct CIDstruct
{
    int    iCID;
    TCHAR* pszCountry;

} CIDSTRUCT;

typedef struct PlatfromStruct
{
    int    iOSType;
    int    iOSArch;
    double fOSMajor;
    TCHAR* pszOSDescription;

} PLATFORMSTRUCT;

PLATFORMSTRUCT aryPlatformLookup[PLATFORMLEN] =
{
    { 2,    2,    5.0001,    TEXT("Win 2000 Beta 3 / ICW5 on Alpha")},
    { 2,    0,    5.0001,    TEXT("Win 2000 Beta 3 / ICW5 on x86")  },
    { 1,    0,    4.0001,    TEXT("Windows 95 / ICW5")              },
    { 1,    0,    4.1   , TEXT("Windows 98 / ICW3")              },
    { 1,    0,    4.1001,    TEXT("Windows 98 / ICW5")              },
    { 1,    0,    4.1002,    TEXT("Windows 98 OSR1 / ICW5")         },
    { 2,    2,    4.0001,    TEXT("Windows NT4 / ICW5 on Alpha")    },
    { 2,    1,    4.0001,    TEXT("Windows NT4 / ICW5 on MIPS")     },
    { 2,    0,    4.0001,    TEXT("Windows NT4 / ICW5 on x86")      }
};

LCIDSTRUCT aryLCIDLookup[LCIDLEN] =
{
    {   -1,  TEXT("All Languages")                      },
    { 1025,  TEXT("Arabic (Saudi Arabia)")              },
    { 1026,  TEXT("Bulgarian")                          },
    { 1027,  TEXT("Catalan")                            },
    { 1028,  TEXT("Chinese (Taiwan)")                   },
    { 1029,  TEXT("Czech")                              },
    { 1030,  TEXT("Danish")                             },
    { 1031,  TEXT("German (Standard)")                  },
    { 1032,  TEXT("Greek")                              },
    { 1033,  TEXT("English (US)")                       },
    { 1034,  TEXT("Spanish (Spain - Traditional Sort)") },
    { 1035,  TEXT("Finnish")                            },
    { 1036,  TEXT("French (Standard)")                  },
    { 1037,  TEXT("Hebrew")                             },
    { 1038,  TEXT("Hungarian")                          },
    { 1039,  TEXT("Icelandic")                          },
    { 1040,  TEXT("Italian")                            },
    { 1041,  TEXT("Japanese")                           },
    { 1042,  TEXT("Korean")                             },
    { 1043,  TEXT("Dutch (Standard)")                   },
    { 1044,  TEXT("Norwegian (Bokmal)")                 },
    { 1045,  TEXT("Polish")                             },
    { 1046,  TEXT("Portugeuse (Brazil)")                },
    { 1047,  TEXT("Rhaeto-Romantic")                    },
    { 1048,  TEXT("Romanian")                           },
    { 1049,  TEXT("Russian")                            },
    { 1050,  TEXT("Croatia")                            },
    { 1051,  TEXT("Slovak")                             },
    { 1052,  TEXT("Albania")                            },
    { 1053,  TEXT("Swedish")                            },
    { 1054,  TEXT("Thai")                               },
    { 1055,  TEXT("Turkish")                            },
    { 1056,  TEXT("Urdu")                               },
    { 1057,  TEXT("Indonesian")                         },
    { 1058,  TEXT("Ukrainian")                          },
    { 1059,  TEXT("Byelorussian")                       },
    { 1060,  TEXT("Slovenian")                          },
    { 1061,  TEXT("Estonia")                            },
    { 1062,  TEXT("Latvian")                            },
    { 1063,  TEXT("Lithuanian")                         },
    { 1065,  TEXT("Farsi")                              },
    { 1066,  TEXT("Vietnamese")                         },
    { 1069,  TEXT("Basque")                             },
    { 1070,  TEXT("Sorbian")                            },
    { 1071,  TEXT("FYRO Macedonian")                    },
    { 1072,  TEXT("Sutu")                               },
    { 1073,  TEXT("Tsonga")                             },
    { 1074,  TEXT("Tswana")                             },
    { 1075,  TEXT("Venda")                              },
    { 1076,  TEXT("Xhosa")                              },
    { 1077,  TEXT("Zulu")                               },
    { 1078,  TEXT("Afrikaans")                          },
    { 1080,  TEXT("Faeroese")                           },
    { 1081,  TEXT("Hindi")                              },
    { 1082,  TEXT("Maltese")                            },
    { 1083,  TEXT("Sami (Lapland)")                     },
    { 1084,  TEXT("Gaelic (Scots / Gaidhilge)")         },
    { 1085,  TEXT("Yiddish")                            },
    { 1086,  TEXT("Malaysian")                          },
    { 2049,  TEXT("Arabic (Iraq)")                      },
    { 2052,  TEXT("Chinese (PRC)")                      },
    { 2055,  TEXT("German (Switzerland)")               },
    { 2057,  TEXT("English (UK)")                       },
    { 2058,  TEXT("Spanish (Mexico)")                   },
    { 2060,  TEXT("French (Belgium)")                   },
    { 2064,  TEXT("Italian (Switzerland)")              },
    { 2066,  TEXT("Korean (Johab)")                     },
    { 2067,  TEXT("Dutch (Belgium)")                    },
    { 2068,  TEXT("Norwegian (Nynorsk)")                },
    { 2070,  TEXT("Portugeuse (Standard)")              },
    { 2072,  TEXT("Romanian (Moldavia)")                },
    { 2073,  TEXT("Russian (Moldavia)")                 },
    { 2074,  TEXT("Serbian (Latin)")                    },
    { 2108,  TEXT("Gaelic (Irish)")                     },
    { 3073,  TEXT("Arabic (Egypt)")                     },
    { 3076,  TEXT("Chinese (Hong Kong SAR)")            },
    { 3079,  TEXT("German (Austria)")                   },
    { 3081,  TEXT("English (Austrailia)")               },
    { 3082,  TEXT("Spanish (Spain - Modern Sort)")      },
    { 3084,  TEXT("French (Canada)")                    },
    { 3098,  TEXT("Serbian (Cyrillic)")                 },
    { 4097,  TEXT("Arabic (Libya)")                     },
    { 4100,  TEXT("Chinese (Singapore)")                },
    { 4103,  TEXT("German (Luxembourg)")                },
    { 4105,  TEXT("English (Canada)")                   },
    { 4106,  TEXT("Spanish (Guatemala)")                },
    { 4108,  TEXT("French (Switzerland)")               },
    { 5121,  TEXT("Arabic (Algeria)")                   },
    { 5127,  TEXT("German (Liechtenstein)")             },
    { 5129,  TEXT("English (New Zealand)")              },
    { 5130,  TEXT("Spanish (Costa Rica)")               },
    { 5132,  TEXT("French (Luxembourg)")                },
    { 6145,  TEXT("Arabic (Morocco)")                   },
    { 6153,  TEXT("English (Ireland)")                  },
    { 6154,  TEXT("Spanish (Panama)")                   },
    { 7169,  TEXT("Arabic (Tunisia)")                   },
    { 7177,  TEXT("English (South Africa)")             },
    { 7178,  TEXT("Spanish (Dominican Republic)")       },
    { 8193,  TEXT("Arabic (Oman)")                      },
    { 8201,  TEXT("English (Jamacia)")                  },
    { 8202,  TEXT("Spanish (Venezuela)")                },
    { 9217,  TEXT("Arabic (Yemen)")                     },
    { 9225,  TEXT("English (Carribean)")                },
    { 9226,  TEXT("Spanish (Colombia)")                 },
    { 10241, TEXT("Arabic (Syria)")                     },
    { 10249, TEXT("English (Belize)")                   },
    { 10250, TEXT("Spanish (Peru)")                     },
    { 11265, TEXT("Arabic (Jordan)")                    },
    { 11273, TEXT("English (Trinidad)")                 },
    { 11274, TEXT("Spanish (Argentina)")                },
    { 12289, TEXT("Arabic (Lebanon)")                   },
    { 12298, TEXT("Spanish (Ecuador)")                  },
    { 13313, TEXT("Arabic (Kuwait)")                    },
    { 13322, TEXT("Spanish (Chile)")                    },
    { 14337, TEXT("Arabic (UAE)")                       },
    { 14346, TEXT("Spanish (Uruguay)")                  },
    { 15361, TEXT("Arabic (Bahrain)")                   },
    { 15370, TEXT("Spanish (Paraguay)")                 },
    { 16385, TEXT("Arabic (Qatar)")                     },
    { 16394, TEXT("Spanish (Boliva)")                   },
    { 17418, TEXT("Spanish (El Salvador)")              },
    { 18442, TEXT("Spanish (Honduras)")                 },
    { 19466, TEXT("Spanish (Nicaragua)")                },
    { 20490, TEXT("Spanish (Puerto Rico)")              }
};

CIDSTRUCT aryCIDLookup[CIDLEN] =
{
    { 1,    TEXT("United States of America")                           },
    { 7,    TEXT("Russia")                                             },
    { 20,   TEXT("Egypt")                                              },
    { 27,   TEXT("South Africa")                                       },
    { 30,   TEXT("Greece")                                             },
    { 31,   TEXT("Netherlands")                                        },
    { 32,   TEXT("Belgium")                                            },
    { 33,   TEXT("France")                                             },
    { 34,   TEXT("Spain")                                              },
    { 36,   TEXT("Hungary")                                            },
    { 39,   TEXT("Italy")                                              },
    { 40,   TEXT("Romania")                                            },
    { 41,   TEXT("Switzerland")                                        },
    { 42,   TEXT("Czech Republic")                                     },
    { 43,   TEXT("Austria")                                            },
    { 44,   TEXT("United Kingdom")                                     },
    { 45,   TEXT("Denmark")                                            },
    { 46,   TEXT("Sweden")                                             },
    { 47,   TEXT("Norway")                                             },
    { 48,   TEXT("Poland")                                             },
    { 49,   TEXT("Germany")                                            },
    { 51,   TEXT("Peru")                                               },
    { 52,   TEXT("Mexico")                                             },
    { 53,   TEXT("Cuba")                                               },
    { 54,   TEXT("Argentina")                                          },
    { 55,   TEXT("Brazil")                                             },
    { 56,   TEXT("Chile")                                              },
    { 57,   TEXT("Colombia")                                           },
    { 58,   TEXT("Venezuela")                                          },
    { 60,   TEXT("Malaysia")                                           },
    { 61,   TEXT("Australia")                                          },
    { 62,   TEXT("Indonesia")                                          },
    { 63,   TEXT("Philippines")                                        },
    { 64,   TEXT("New Zealand")                                        },
    { 65,   TEXT("Singapore")                                          },
    { 66,   TEXT("Thailand")                                           },
    { 81,   TEXT("Japan")                                              },
    { 82,   TEXT("Korea (South)")                                      },
    { 84,   TEXT("Vietnam")                                            },
    { 86,   TEXT("China")                                              },
    { 90,   TEXT("Turkey")                                             },
    { 91,   TEXT("India")                                              },
    { 92,   TEXT("Pakistan")                                           },
    { 93,   TEXT("Afghanistan")                                        },
    { 94,   TEXT("Sri Lanka")                                          },
    { 95,   TEXT("Myanmar")                                            },
    { 98,   TEXT("Iran")                                               },
    { 101,  TEXT("Anguilla")                                           },
    { 102,  TEXT("Antigua")                                            },
    { 103,  TEXT("Bahamas")                                            },
    { 104,  TEXT("Barbados")                                           },
    { 105,  TEXT("Bermuda")                                            },
    { 106,  TEXT("British Virgin Islands")                             },
    { 107,  TEXT("Canada")                                             },
    { 108,  TEXT("Cayman Islands")                                     },
    { 109,  TEXT("Dominica")                                           },
    { 110,  TEXT("Dominican Republic")                                 },
    { 111,  TEXT("Grenada")                                            },
    { 112,  TEXT("Jamaica")                                            },
    { 113,  TEXT("Montserrat")                                         },
    { 114,  TEXT("Nevis")                                              },
    { 115,  TEXT("St. Kitts")                                          },
    { 116,  TEXT("St. Vincent and the Grenadines")                     },
    { 117,  TEXT("Trinidad and Tobago")                                },
    { 118,  TEXT("Turks and Caicos Islands")                           },
    { 120,  TEXT("Barbuda")                                            },
    { 121,  TEXT("Puerto Rico")                                        },
    { 122,  TEXT("Saint Lucia")                                        },
    { 123,  TEXT("United States Virgin Islands")                       },
    { 212,  TEXT("Morocco")                                            },
    { 213,  TEXT("Algeria")                                            },
    { 216,  TEXT("Tunisia")                                            },
    { 218,  TEXT("Libya")                                              },
    { 220,  TEXT("Gambia")                                             },
    { 221,  TEXT("Senegal Republic")                                   },
    { 222,  TEXT("Mauritania")                                         },
    { 223,  TEXT("Mali")                                               },
    { 224,  TEXT("Guinea")                                             },
    { 225,  TEXT("Cote d'Ivoire")                                      },
    { 226,  TEXT("Burkina Faso")                                       },
    { 227,  TEXT("Niger")                                              },
    { 228,  TEXT("Togo")                                               },
    { 229,  TEXT("Benin")                                              },
    { 230,  TEXT("Mauritius")                                          },
    { 231,  TEXT("Liberia")                                            },
    { 232,  TEXT("Sierra Leone")                                       },
    { 233,  TEXT("Ghana")                                              },
    { 234,  TEXT("Nigeria")                                            },
    { 235,  TEXT("Chad")                                               },
    { 236,  TEXT("Central African Republic")                           },
    { 237,  TEXT("Cameroon")                                           },
    { 238,  TEXT("Cape Verde Islands")                                 },
    { 239,  TEXT("Sao Tome and Principe")                              },
    { 240,  TEXT("Equatorial Guinea")                                  },
    { 241,  TEXT("Gabon")                                              },
    { 242,  TEXT("Congo")                                              },
    { 243,  TEXT("Congo (DRC)")                                        },
    { 244,  TEXT("Angola")                                             },
    { 245,  TEXT("Guinea-Bissau")                                      },
    { 246,  TEXT("Diego Garcia")                                       },
    { 247,  TEXT("Ascension Island")                                   },
    { 248,  TEXT("Seychelle Islands")                                  },
    { 249,  TEXT("Sudan")                                              },
    { 250,  TEXT("Rwanda")                                             },
    { 251,  TEXT("Ethiopia")                                           },
    { 252,  TEXT("Somalia")                                            },
    { 253,  TEXT("Djibouti")                                           },
    { 254,  TEXT("Kenya")                                              },
    { 255,  TEXT("Tanzania")                                           },
    { 256,  TEXT("Uganda")                                             },
    { 257,  TEXT("Burundi")                                            },
    { 258,  TEXT("Mozambique")                                         },
    { 260,  TEXT("Zambia")                                             },
    { 261,  TEXT("Madagascar")                                         },
    { 262,  TEXT("Reunion Island")                                     },
    { 263,  TEXT("Zimbabwe")                                           },
    { 264,  TEXT("Namibia")                                            },
    { 265,  TEXT("Malawi")                                             },
    { 266,  TEXT("Lesotho")                                            },
    { 267,  TEXT("Botswana")                                           },
    { 268,  TEXT("Swaziland")                                          },
    { 269,  TEXT("Mayotte Island")                                     },
    { 290,  TEXT("St. Helena")                                         },
    { 291,  TEXT("Eritrea")                                            },
    { 297,  TEXT("Aruba")                                              },
    { 298,  TEXT("Faeroe Islands")                                     },
    { 299,  TEXT("Greenland")                                          },
    { 350,  TEXT("Gibraltar")                                          },
    { 351,  TEXT("Portugal")                                           },
    { 352,  TEXT("Luxembourg")                                         },
    { 353,  TEXT("Ireland")                                            },
    { 354,  TEXT("Iceland")                                            },
    { 355,  TEXT("Albania")                                            },
    { 356,  TEXT("Malta")                                              },
    { 357,  TEXT("Cyprus")                                             },
    { 358,  TEXT("Finland")                                            },
    { 359,  TEXT("Bulgaria")                                           },
    { 370,  TEXT("Lithuania")                                          },
    { 371,  TEXT("Latvia")                                             },
    { 372,  TEXT("Estonia")                                            },
    { 373,  TEXT("Moldova")                                            },
    { 374,  TEXT("Armenia")                                            },
    { 375,  TEXT("Belarus")                                            },
    { 376,  TEXT("Andorra")                                            },
    { 378,  TEXT("San Marino")                                         },
    { 379,  TEXT("Vatican City")                                       },
    { 380,  TEXT("Ukraine")                                            },
    { 381,  TEXT("Yugoslavia")                                         },
    { 385,  TEXT("Croatia")                                            },
    { 386,  TEXT("Slovenia")                                           },
    { 387,  TEXT("Bosnia and Herzegovina")                             },
    { 389,  TEXT("F.Y.R.O.M. (Former Yugoslav Republic of Macedonia)") },
    { 420,  TEXT("Czech Republic")                                     },
    { 421,  TEXT("Slovak Republic")                                    },
    { 500,  TEXT("Falkland Islands (Islas Malvinas)")                  },
    { 501,  TEXT("Belize")                                             },
    { 502,  TEXT("Guatemala")                                          },
    { 503,  TEXT("El Salvador")                                        },
    { 504,  TEXT("Honduras")                                           },
    { 505,  TEXT("Nicaragua")                                          },
    { 506,  TEXT("Costa Rica")                                         },
    { 507,  TEXT("Panama")                                             },
    { 508,  TEXT("St. Pierre and Miquelon")                            },
    { 509,  TEXT("Haiti")                                              },
    { 590,  TEXT("Guadeloupe")                                         },
    { 591,  TEXT("Bolivia")                                            },
    { 592,  TEXT("Guyana")                                             },
    { 593,  TEXT("Ecuador")                                            },
    { 594,  TEXT("French Guiana")                                      },
    { 595,  TEXT("Paraguay")                                           },
    { 596,  TEXT("Martinique")                                         },
    { 597,  TEXT("Suriname")                                           },
    { 598,  TEXT("Uruguay")                                            },
    { 599,  TEXT("Netherlands Antilles")                               },
    { 670,  TEXT("Saipan Island")                                      },
    { 671,  TEXT("Guam")                                               },
    { 672,  TEXT("Christmas Island")                                   },
    { 673,  TEXT("Brunei")                                             },
    { 674,  TEXT("Nauru")                                              },
    { 675,  TEXT("Papua New Guinea")                                   },
    { 676,  TEXT("Tonga")                                              },
    { 677,  TEXT("Solomon Islands")                                    },
    { 678,  TEXT("Vanuatu")                                            },
    { 679,  TEXT("Fiji Islands")                                       },
    { 680,  TEXT("Palau")                                              },
    { 681,  TEXT("Wallis and Futuna Islands")                          },
    { 682,  TEXT("Cook Islands")                                       },
    { 683,  TEXT("Niue")                                               },
    { 684,  TEXT("American Samoa")                                     },
    { 685,  TEXT("Samoa")                                              },
    { 686,  TEXT("Kiribati Republic")                                  },
    { 687,  TEXT("New Caledonia")                                      },
    { 688,  TEXT("Tuvalu")                                             },
    { 689,  TEXT("French Polynesia")                                   },
    { 690,  TEXT("Tokelau")                                            },
    { 691,  TEXT("Micronesia")                                         },
    { 692,  TEXT("Marshall Islands")                                   },
    { 705,  TEXT("Kazakhstan")                                         },
    { 706,  TEXT("Kyrgyzstan")                                         },
    { 708,  TEXT("Tajikistan")                                         },
    { 709,  TEXT("Turkmenistan")                                       },
    { 711,  TEXT("Uzbekistan")                                         },
    { 850,  TEXT("Korea (North)")                                      },
    { 852,  TEXT("Hong Kong")                                          },
    { 853,  TEXT("Macao")                                              },
    { 855,  TEXT("Cambodia")                                           },
    { 856,  TEXT("Laos")                                               },
    { 871,  TEXT("INMARSAT (Atlantic-East)")                           },
    { 872,  TEXT("INMARSAT (Pacific)")                                 },
    { 873,  TEXT("INMARSAT (Indian)")                                  },
    { 874,  TEXT("INMARSAT (Atlantic-West)")                           },
    { 880,  TEXT("Bangladesh")                                         },
    { 886,  TEXT("Taiwan")                                             },
    { 960,  TEXT("Maldives")                                           },
    { 961,  TEXT("Lebanon")                                            },
    { 962,  TEXT("Jordan")                                             },
    { 963,  TEXT("Syria")                                              },
    { 964,  TEXT("Iraq")                                               },
    { 965,  TEXT("Kuwait")                                             },
    { 966,  TEXT("Saudi Arabia")                                       },
    { 967,  TEXT("Yemen")                                              },
    { 968,  TEXT("Oman")                                               },
    { 971,  TEXT("United Arab Emirates")                               },
    { 972,  TEXT("Israel")                                             },
    { 973,  TEXT("Bahrain")                                            },
    { 974,  TEXT("Qatar")                                              },
    { 975,  TEXT("Bhutan")                                             },
    { 976,  TEXT("Mongolia")                                           },
    { 977,  TEXT("Nepal")                                              },
    { 994,  TEXT("Azerbaijan")                                         },
    { 995,  TEXT("Georgia")                                            },
    { 2691, TEXT("Comoros")                                            },
    { 3302, TEXT("Monaco")                                             },
    { 4101, TEXT("Liechtenstein")                                      },
    { 5399, TEXT("Guantanamo Bay")                                     },
    { 5901, TEXT("French Antilles")                                    },
    { 6101, TEXT("Cocos-Keeling Islands")                              },
    { 6701, TEXT("Rota Island")                                        },
    { 6702, TEXT("Tinian Island")                                      },
    { 6721, TEXT("Australian Antarctic Territory")                     },
    { 6722, TEXT("Norfolk Island")                                     }
};

#endif //_LOOKUPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\icwsupr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"

typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout

TCHAR       g_szICWGrpBox[] = TEXT("ICW_GROUPBOX");
TCHAR       g_szICWStatic[] = TEXT("ICW_STATIC");
FARPROC     lpfnOriginalGroupBoxWndProc;
FARPROC     lpfnOriginalStaticWndProc;

int GetGroupBoxTextRect
(
    LPTSTR  lpszText,
    int     cch,
    HDC     hdc,
    LPRECT  lpGroupBoxRect
)
{
    int     dy;
    
    // Compute the rectangle needed to draw the group box text
    dy = DrawText(hdc, lpszText, cch, lpGroupBoxRect, DT_CALCRECT|DT_LEFT|DT_SINGLELINE);

    // Adjust rectangle for the group box text
    lpGroupBoxRect->left += 4;
    lpGroupBoxRect->right += 4;
    lpGroupBoxRect->bottom = lpGroupBoxRect->top + dy;
    
    return dy;
}    

#ifndef LAYOUT_RTL
#define LAYOUT_RTL                       0x00000001 // Right to left
//#else
//#error "LAYOUT_RTL is already defined in wingdi.h.remove local define"
#endif // LAYOUT_RTL

LRESULT CALLBACK ICWGroupBoxWndProc
(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    if(gpWizardState->cmnStateData.bOEMCustom)
    {
        switch (uMessage)
        {
            // Handle the case where the text in the combo box title is being changed.
            // When the text is being changed, we first have to erase the existing
            // text with the background bitmap, and then allow the new text to
            // get set, and then repaint with the new text.
            case WM_SETTEXT:
            {   
                HFONT   hfont, hOldfont;    
                HDC     hdc = GetDC(hWnd);
                RECT    rcGroupBoxText, rcUpdate;
                int     cch;
                long    lStyle;
                TCHAR   szText[256];
                
                // Get the existing text to cover over
                cch = GetWindowText(hWnd, szText, sizeof(szText));
                
                // Set the font for drawing the group box text
                if((hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L)) != NULL)
                    hOldfont = (HFONT)SelectObject(hdc, hfont);
                
                // Compute the group box text area
                GetClientRect(hWnd, (LPRECT)&rcGroupBoxText);
                GetGroupBoxTextRect(szText, cch, hdc, &rcGroupBoxText);
                
                // Ccmpute the area to be updated
                rcUpdate = rcGroupBoxText;
                MapWindowPoints(hWnd, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcUpdate, 2);
                FillDCRectWithAppBackground(&rcGroupBoxText, &rcUpdate, hdc);
                
                // Cleanup the DC
                SelectObject(hdc, hOldfont);
                ReleaseDC(hWnd, hdc);
                
                // Finish up by setting the new text, and updating the window                
                if((lStyle = GetWindowLong(hWnd, GWL_STYLE)) & WS_VISIBLE)
                {
                    // Call the original window handler to set the text, but prevent the
                    // window from updating. This is necessary because all painting of
                    // the window must be done from the WM_PAINT below
                    SetWindowLong(hWnd, GWL_STYLE, lStyle & ~(WS_VISIBLE));
                    CallWindowProc((WNDPROC)lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
                    SetWindowLong(hWnd, GWL_STYLE, GetWindowLong(hWnd, GWL_STYLE)|WS_VISIBLE);
                    
                    // Force the window to be repainted
                    RedrawWindow(hWnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
                }                    
                return TRUE;
            }
                            
            case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC         hdc;
                RECT        rcClient;
                RECT        rcGroupBoxText;
                RECT        rcUpdate;
                int         cch;
                TCHAR       szTitle[256];
                int         dy;

                HFONT       hfont, hOldfont;
                int         iOldBkMode;
                HBRUSH      hOldBrush;
                
                hdc = BeginPaint(hWnd, &ps); 
            
            
                GetClientRect(hWnd, (LPRECT)&rcClient);
                rcGroupBoxText = rcClient;

                // Set the font for drawing the group box text
                if((hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L)) != NULL)
                    hOldfont = (HFONT)SelectObject(hdc, hfont);

                // Get the group box text that we need to draw, and compute it rectangle
                cch = GetWindowText(hWnd, szTitle, sizeof(szTitle));
                dy = GetGroupBoxTextRect(szTitle, cch, hdc, &rcGroupBoxText);

                // Adjust rectangle for the group box outline
                rcClient.top += dy/2;
                rcClient.right--;
                rcClient.bottom--;
                DrawEdge(hdc, &rcClient, EDGE_ETCHED, BF_ADJUST| BF_RECT);
                
                // Erase the text area with the app background bitmap to cover over
                // the edge drawn above
                rcUpdate = rcGroupBoxText;
                MapWindowPoints(hWnd, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcUpdate, 2);
                FillDCRectWithAppBackground(&rcGroupBoxText, &rcUpdate, hdc);
                
                // Set up to draw the text
                hOldBrush = (HBRUSH)SelectObject(hdc, GetStockObject(NULL_BRUSH));
                iOldBkMode = SetBkMode(hdc, TRANSPARENT);
                SetTextColor(hdc, gpWizardState->cmnStateData.clrText);
                DrawText(hdc, szTitle, cch, (LPRECT) &rcGroupBoxText, DT_LEFT|DT_SINGLELINE);

                // Cleanup GDI Objects
                SelectObject(hdc, hOldfont);
                SelectObject(hdc, hOldBrush);
                SetBkMode(hdc, iOldBkMode);

                EndPaint(hWnd, &ps); 
                break;
            }
            default:
                // Let the original proc handle other messages
                return CallWindowProc((WNDPROC)lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
        }  
        
        // Call the default window proc handler if necessary
        return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }
    else
    {
        // Not in modeless mode, so just pass through the messages
        return CallWindowProc((WNDPROC)lpfnOriginalGroupBoxWndProc, hWnd, uMessage, wParam, lParam);
    }
}    

DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

LRESULT CALLBACK ICWStaticWndProc
(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMessage)
    {
        case WM_SETTEXT:
        {   
            // only handle this case for OEMcustom mode
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                FillWindowWithAppBackground(hWnd, NULL);
            }                
            return CallWindowProc((WNDPROC)lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
        }
            
        case WM_PAINT:
        {
            // This case gets handled for oem custom and regular mode
            // since we have to paint the icon
            if (GetWindowLong(hWnd, GWL_STYLE) & SS_ICON)
            {
                PAINTSTRUCT ps;
                HDC         hdc;
                int        iIconID;
                HICON       hIcon;
                DWORD       dwLayout= 0L;
               
                // Get the name of the icon.  
                iIconID = (int)GetWindowLongPtr(hWnd, GWLP_USERDATA);
                       
                if (iIconID)
                {
                    // Load the icon by name.  It is stored with the next, not
                    // an integer value
                    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(iIconID));
                
                    hdc = BeginPaint(hWnd, &ps); 
            
                    if(gpWizardState->cmnStateData.bOEMCustom)
                    {
                        // Fill in the window with the background color
                        FillWindowWithAppBackground(hWnd, hdc);
                    }
                        
                    // Draw the icon
                    // Disable mirroring before we draw
                    dwLayout = Mirror_GetLayout(hdc);
                    Mirror_SetLayout(hdc, dwLayout & ~LAYOUT_RTL);
                    DrawIcon(hdc, 0, 0, hIcon);
                    Mirror_SetLayout(hdc, dwLayout);
                
                    EndPaint(hWnd, &ps); 
                }
                break;
            }
            else
            {
                return CallWindowProc((WNDPROC)lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
            }                    
        }
        default:
            // Let the original proc handle other messages
            return CallWindowProc((WNDPROC)lpfnOriginalStaticWndProc, hWnd, uMessage, wParam, lParam);
    }   
    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}    

BOOL SuperClassICWControls
(
    void
)
{
    WNDCLASS    WndClass;
    
    ZeroMemory (&WndClass, sizeof(WNDCLASS));
    // Create a Superclass for ICW_TEXT
    GetClassInfo(NULL,
                 TEXT("STATIC"),   // address of class name string
                 &WndClass);   // address of structure for class data
    WndClass.style |= CS_GLOBALCLASS;                 
    WndClass.hInstance = g_hInstance;
    WndClass.lpszClassName = g_szICWStatic;
    lpfnOriginalStaticWndProc = (FARPROC)WndClass.lpfnWndProc;
    WndClass.lpfnWndProc = (WNDPROC)ICWStaticWndProc;
    
    if (!RegisterClass(&WndClass))
        return FALSE;
    
    ZeroMemory (&WndClass, sizeof(WNDCLASS));
    // Create a Superclass for ICW_GROUPBOX
    GetClassInfo(NULL,
                 TEXT("BUTTON"),   // address of class name string
                 &WndClass);   // address of structure for class data
    WndClass.style |= CS_GLOBALCLASS;                 
    WndClass.hInstance = g_hInstance;
    WndClass.lpszClassName = g_szICWGrpBox;
    lpfnOriginalGroupBoxWndProc = (FARPROC)WndClass.lpfnWndProc;
    WndClass.lpfnWndProc = (WNDPROC)ICWGroupBoxWndProc;
    
    return (RegisterClass(&WndClass));
}

BOOL RemoveICWControlsSuperClass
(
    void
)
{
    UnregisterClass(g_szICWGrpBox, g_hInstance);
    UnregisterClass(g_szICWStatic, g_hInstance);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\manual.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  MANUAL.CPP - Functions for manual options page
//

//  HISTORY:
//  
//  05/13/98  jeremys  Created.
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include "icwacct.h"

extern UINT GetDlgIDFromIndex(UINT uPageIndex);
extern BOOL g_bManualPath;     
extern BOOL g_bLanPath;     

const   TCHAR  c_szICWMan[] = TEXT("INETWIZ.EXE");
const   TCHAR  c_szRegValICWCompleted[] = TEXT("Completed");

// Run the manual wizard
BOOL RunICWManProcess
(
    void
)
{
    STARTUPINFO             si;
    PROCESS_INFORMATION     pi;
    MSG                     msg ;
    DWORD                   iWaitResult = 0;
    BOOL                    bRetVal = FALSE;
    
    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    if(CreateProcess(c_szICWMan, 
                     NULL, 
                     NULL, 
                     NULL, 
                     TRUE, 
                     0, 
                     NULL, 
                     NULL, 
                     &si, 
                     &pi))
    {
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
            // read all of the messages in this next loop
            // removing each message as we read it
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                // how to handle quit message?
                if (msg.message == WM_QUIT)
                {
                    goto done;
                }
                else
                    DispatchMessage(&msg);
            }
        }
done:
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }   
    
    // See if ICWMAN completed, by checking the SmartStart Completed RegKey
    HKEY    hkey;
    if ( RegOpenKeyEx(HKEY_CURRENT_USER, 
                      ICWSETTINGSPATH,
                      0,
                      KEY_ALL_ACCESS,
                      &hkey) == ERROR_SUCCESS)
    {
        DWORD   dwType = REG_BINARY;
        DWORD   dwValue = 0;
        DWORD   cbValue = sizeof(DWORD);
        RegQueryValueEx(hkey,
                        c_szRegValICWCompleted,
                        NULL,
                        &dwType,
                        (LPBYTE) &dwValue,
                        &cbValue);                              

        RegCloseKey(hkey);
        
        bRetVal = dwValue;
    }
    
    return(bRetVal);
}

/*******************************************************************

  NAME:    ManualOptionsInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ManualOptionsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // If we are in modeless operation, then we need to 
        // quit the wizard, and launch INETWIZ.EXE
        if (gpWizardState->cmnStateData.bOEMCustom)
        {        
            ShowWindow(gpWizardState->cmnStateData.hWndApp,SW_HIDE);
            if (RunICWManProcess())
            {
                // Set the welcome state
                UpdateWelcomeRegSetting(TRUE);
            
                // Restore the desktop
                UndoDesktopChanges(g_hInstance);            
            }
        
            gfQuitWizard = TRUE;            // Quit the wizard
            return FALSE;
        }
        else
        {
            //BUGBUG  -- SHOULD BE AUTO?
            // initialize radio buttons
            CheckDlgButton(hDlg,IDC_MANUAL_MODEM, BST_CHECKED);
            TCHAR*   pszManualIntro = new TCHAR[MAX_MESSAGE_LEN * 3];
            if (pszManualIntro)
            {
                TCHAR    szTemp[MAX_MESSAGE_LEN];

                LoadString(g_hInstance, IDS_MANUAL_INTRO1, pszManualIntro, MAX_MESSAGE_LEN * 3);
                LoadString(g_hInstance, IDS_MANUAL_INTRO2, szTemp, sizeof(szTemp));
                lstrcat(pszManualIntro, szTemp);
                SetWindowText(GetDlgItem(hDlg, IDC_MANUAL_INTRO), pszManualIntro);
                delete pszManualIntro;
            }
        }            
    }
    else
    {
        // If we are run from the Runonce with the smartreboot option, we need to 
        // jump to the Manual wiz immediately because that was where we left the user
        // last time.
        
        if (g_bManualPath || g_bLanPath)
        {
            Button_SetCheck(GetDlgItem(hDlg, IDC_MANUAL_MODEM), g_bManualPath);
            Button_SetCheck(GetDlgItem(hDlg, IDC_MANUAL_LAN), !g_bManualPath);

            if (LoadInetCfgUI(  hDlg,
                                IDD_PAGE_MANUALOPTIONS,
                                IDD_PAGE_END,
                                IsDlgButtonChecked(hDlg, IDC_MANUAL_LAN) ? WIZ_HOST_ICW_LAN : WIZ_HOST_ICW_MPHONE))
            {
                if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                {
                    // we're about to jump into the external apprentice, and we don't want
                    // this page to show up in our history list
                    *puNextPage = g_uICWCONNUIFirst;

                    g_bAllowCancel = TRUE;
                    if (gpINETCFGApprentice)
                        gpINETCFGApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);

                }
            }
            g_bManualPath = FALSE;
            g_bLanPath = FALSE;

        }

    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_MANUALOPTIONS;

    return TRUE;
}

/*******************************************************************

  NAME:         ManualOptionsCmdProc

  SYNOPSIS:     Called when a command is generated from  page

  ENTRY:        hDlg - dialog window
                wParam - wParam
                lParam - lParam
          
  EXIT:         returns TRUE 

********************************************************************/
BOOL CALLBACK ManualOptionsCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_DBLCLK:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_MANUAL_MODEM: 
                case IDC_MANUAL_LAN: 
                {
		            // somebody double-clicked a radio button
		            // auto-advance to the next page
		            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
            }
		    break;
    }

    return TRUE;
}



/*******************************************************************

  NAME:    ManualOptionsOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ManualOptionsOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    BOOL    bRet = TRUE;
    
    if (fForward)
    {
        if( IsDlgButtonChecked(hDlg, IDC_MANUAL_MODEM) )
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_MANUAL;
        }
        else
        {
            gpWizardState->cmnStateData.dwFlags |= ICW_CFGFLAG_SMARTREBOOT_LAN;
        }

        bRet = FALSE;
        // read radio button state
        *pfKeepHistory = FALSE;
        if (LoadInetCfgUI(  hDlg,
                            IDD_PAGE_MANUALOPTIONS,
                            IDD_PAGE_END,
                            IsDlgButtonChecked(hDlg, IDC_MANUAL_LAN) ? WIZ_HOST_ICW_LAN : WIZ_HOST_ICW_MPHONE))
        {
            if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                bRet = TRUE;
                *puNextPage = g_uICWCONNUIFirst;
                g_bAllowCancel = TRUE;
                if (gpINETCFGApprentice)
                    gpINETCFGApprentice->SetStateDataFromExeToDll( &gpWizardState->cmnStateData);

            }
        }
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\multinum.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  MULTINUM.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:     InitListBox

  SYNOPSIS: Initialize the phone number list view

  ENTRY:    hListBox       - handle to the list view window

  EXIT:     returns TRUE when successful, FALSE otherwise.

********************************************************************/
BOOL InitListBox(HWND  hListBox)
{
    LONG        lNumDevice;
    LONG        i;
    
    gpWizardState->pRefDial->get_PhoneNumberEnum_NumDevices(&lNumDevice);
    if (lNumDevice > 0)
    {
        for (i=0; i < lNumDevice; i++)
        {
            BSTR        bstr = NULL;
            gpWizardState->pRefDial->PhoneNumberEnum_Next(&bstr);
            if (bstr != NULL)
            {
                ListBox_InsertString(hListBox, i, W2A(bstr));
                SysFreeString(bstr);
            }
        }

        ListBox_SetCurSel(hListBox, 0);
    }
    return(TRUE);
}

/*******************************************************************

  NAME:    MultiNumberInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK MultiNumberInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
    
    if (fFirstInit)
    {
        InitListBox(GetDlgItem(hDlg, IDC_MULTIPHONE_LIST) );
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_MULTINUMBER;
    }        
    
    return bRet;
}

/*******************************************************************

  NAME:    MultiNumberOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK MultiNumberOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        BOOL bRetVal = FALSE;
        // Do not go to this page when backing up
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;
        gpWizardState->lSelectedPhoneNumber = ListBox_GetCurSel(GetDlgItem(hDlg, IDC_MULTIPHONE_LIST));
    }
    else
        //FIX -- RAID: 33413
        //if the user is backing out of this page we must act as if no
        //number was ever selected.
        gpWizardState->bDoUserPick = FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>
#include <commctrl.h>
#include <locale.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include "icwunicd.h"

#include "icwcmn.h"
#include "icwhelp.h"
#include "connect.h"
#include "webview.h"            // ICW WEBView Interface

#include "wizdef.h"
#include "pagefcns.h"
#include "icwconn1.h"
#include "resource.h"

#include "button.h"
#include "appwnd.h"

#include <ole2ver.h>
#include <exdisp.h>

#include "appdefs.h"
#include "..\inc\debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  05/18/98  donaldm  Created.
//

#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in INTRO.CPP
BOOL CALLBACK IntroInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK IntroPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK IntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK IntroCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in BRANDED.CPP
BOOL CALLBACK BrandedIntroInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK BrandedIntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK BrandedIntroPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in MANUAL.CPP
BOOL CALLBACK ManualOptionsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ManualOptionsCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ManualOptionsOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in AREACODE.CPP
BOOL CALLBACK AreaCodeInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK AreaCodeOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK AreaCodeCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in REFDIAL.CPP
BOOL CALLBACK RefServDialInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK RefServDialPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK RefServDialOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK RefServDialCancelProc(HWND hDlg);

// Functions in END.CPP
BOOL CALLBACK EndInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK EndOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK EndOlsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in DIALERR.CPP
BOOL CALLBACK DialErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK DialErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK DialErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in MULTINUM.CPP
BOOL CALLBACK MultiNumberInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK MultiNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in SERVERR.CPP
BOOL CALLBACK ServErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ServErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ServErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ISPERR.CPP
BOOL CALLBACK ISPErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);

// Functions in SBSINTRO.CPP
BOOL CALLBACK SbsInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK SbsIntroOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

#ifdef ICWDEBUG

// Functions in ICWDEBUG.CPP
BOOL CALLBACK DebugOfferInitProc (HWND hDlg, BOOL   fFirstInit, UINT*  puNextPage);
BOOL CALLBACK DebugOfferOKProc   (HWND hDlg, BOOL   fForward,   UINT*  puNextPage, BOOL* pfKeepHistory);
BOOL CALLBACK DebugOfferCmdProc  (HWND hDlg, WPARAM wParam,     LPARAM lParam);
BOOL CALLBACK DebugOfferNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in ICWDEBUG.CPP
BOOL CALLBACK DebugSettingsInitProc   (HWND hDlg, BOOL fFirstInit, UINT*  puNextPage);
BOOL CALLBACK DebugSettingsOKProc     (HWND hDlg, BOOL fForward,   UINT*  puNextPage, BOOL* pfKeepHistory);
BOOL CALLBACK DebugSettingsCmdProc    (HWND hDlg, WPARAM wParam,   LPARAM lParam);

#endif //ICWDEBUG

#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\reboot.cpp ===
//**********************************************************************
// File name: reboot.cpp
//
//      Desktop manipulation functions
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <shlobj.h>

extern TCHAR  g_szProductCode[];
extern TCHAR  g_szPromoCode[];
extern TCHAR  g_szOemCode[];
extern TCHAR* g_pszCmdLine;

#define SHELL_LINK_NAME   TEXT("icwstart.lnk")
#define KEYVALUE_SIGNUPID TEXT("iSignUp")

#define MsgBox(m,s) MessageBox(NULL,GetSz(m),GetSz(IDS_APPNAME),s)
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

class RegEntry
{
    public:
        RegEntry(LPCTSTR pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        
        long    GetError()    { return _error; }
        long    SetValue(LPCTSTR pszValue, LPCTSTR string);
        LPTSTR    GetString(LPCTSTR pszValue, LPTSTR string, unsigned long length);
        long    DeleteValue(LPCTSTR pszValue);

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};

RegEntry::RegEntry(LPCTSTR pszSubKey, HKEY hkey)
{
    _error = RegCreateKey(hkey, pszSubKey, &_hkey);
    if (_error) {
        bhkeyValid = FALSE;
    }
    else {
        bhkeyValid = TRUE;
    }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(LPCTSTR pszValue, LPCTSTR string)
{
    if (bhkeyValid) {
        _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ, (LPBYTE) string,
                               sizeof(TCHAR)*(lstrlen(string)+1));
    }
    return _error;
}

LPTSTR RegEntry::GetString(LPCTSTR pszValue, LPTSTR string, unsigned long length)
{
    DWORD     dwType = REG_SZ;
    
    if (bhkeyValid) {
        _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
                    &length);
    }
    if (_error) {
        *string = '\0';
         return NULL;
    }

    return string;
}

long RegEntry::DeleteValue(LPCTSTR pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}

/*******************************************************************
    ARULM -- copied from JeremyS's UTIL.C in original INETCFG.DLL

    NAME:        PrepareForRunOnceApp

    SYNOPSIS:    Copies wallpaper value in registry to make the runonce
                app happy

    NOTES:        The runonce app (the app that displays a list of apps
                that are run once at startup) has a bug.  At first boot,
                it wants to change the wallpaper from the setup wallpaper
                to what the user had before running setup.  Setup tucks
                the "old" wallpaper away in a private key, then changes
                the wallpaper to the setup wallpaper.  After the runonce
                app finishes, it looks in the private key to get the old
                wallpaper and sets that to be the current wallpaper.
                However, it does this all the time, not just at first boot!
                The end effect is that whenever you do anything that
                causes runonce.exe to run (add stuff thru add/remove
                programs control panel), your wallpaper gets set back to
                whatever it was when you installed win 95.  This is
                especially bad for Plus!, since wallpaper settings are an
                important part of the product.

                To work around this bug, we copy the current wallpaper settings
                (which we want preserved) to setup's private key.  When
                runonce runs it will say "aha!" and copy those values back
                to the current settings.

********************************************************************/

// "Control Panel\\Desktop"
static const TCHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const TCHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const TCHAR szRegValWallpaper[]     = TEXT("Wallpaper");
static const TCHAR szRegValTileWallpaper[] = TEXT("TileWallpaper");

#define LD_USEDESC     0x00000001
#define LD_USEARGS     0x00000002
#define LD_USEICON     0x00000004
#define LD_USEWORKDIR  0x00000008
#define LD_USEHOTKEY   0x00000010
#define LD_USESHOWCMD  0x00000020

typedef struct {  
    // Mandatory members  
    LPTSTR pszPathname;   // Pathname of original object  
    DWORD  fdwFlags;       // LD_* flags ORed together for optional members  
    // Optional members  
    LPTSTR pszDesc;       // Description of link file (its filename)  
    LPTSTR pszArgs;       // command-line arguments  
    LPTSTR pszIconPath;   // Pathname of file containing the icon  
    LPTSTR pszWorkingDir; // Working directory when process starts  
    int    nIconIndex;      // Index of icon in pszIconPath  
    int    nShowCmd;        // How to show the initial window  
    WORD   wHotkey;        // Hot key for the link
} LINKDATA, *PLINKDATA;

HRESULT WINAPI Shell_CreateLink (LPCTSTR pszLinkFilePathname, PLINKDATA pld);

VOID PrepareForRunOnceApp(VOID)
{
    // open a key to the current wallpaper settings
    RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
    Assert(reDesktop.GetError() == ERROR_SUCCESS);

    // open a key to the private setup section
    RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
    Assert(reSetup.GetError() == ERROR_SUCCESS);

    if (reDesktop.GetError() == ERROR_SUCCESS &&
        reSetup.GetError() == ERROR_SUCCESS) {
        TCHAR szWallpaper[MAX_PATH+1] = TEXT("");
        TCHAR szTiled[10] = TEXT("");    // big enough for "1" + slop

        // get the current wallpaper name
        if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
            sizeof(szWallpaper))) {

            // set the current wallpaper name in setup's private section
            UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
            Assert(uRet == ERROR_SUCCESS);

            // get the current 'tiled' value. 
            reDesktop.GetString(szRegValTileWallpaper,szTiled,
                sizeof(szTiled));

            // set the 'tiled' value in setup's section
            if (lstrlen(szTiled)) {
                uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
                Assert(uRet == ERROR_SUCCESS);
            }
        }
    }
} 


//+----------------------------------------------------------------------------
//
//    Function    SetStartUpCommand
//
//    Synopsis    On an NT machine the RunOnce method is not reliable.  Therefore
//                we will restart the ICW by placing a .BAT file in the common
//                startup directory.
//
//    Arguments    lpCmd - command line used to restart the ICW
//
//    Returns        TRUE if it worked
//                FALSE otherwise.
//
//    History        1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------

BOOL SetStartUpCommand(LPTSTR lpCmd, LPTSTR lpArgs)
{
    BOOL bRC = FALSE;
    TCHAR szCommandLine[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    HRESULT hr = ERROR_SUCCESS;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_STARTUP,&lpItemDList)))  
    {
        if (SHGetPathFromIDList(lpItemDList, szCommandLine))
        {
            // make sure there is a trailing \ character
            if ('\\' != szCommandLine[lstrlen(szCommandLine)-1])
                lstrcat(szCommandLine, TEXT("\\"));
            lstrcat(szCommandLine,SHELL_LINK_NAME);                     

            //Setup our link structure            
            LINKDATA ld;
            ld.pszPathname   = lpCmd; 
            ld.fdwFlags      = LD_USEARGS;
            ld.pszArgs       = lpArgs;
         
            //Create the shorLD_USEWORKDIRtcut in start-up
            if(SUCCEEDED(Shell_CreateLink(szCommandLine,  &ld)))
                bRC = TRUE;
        }
      
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            //Don't worry about the return value of the function 
            //since even if we can't clean up the mem the shortcut was 
            //created so in that sense the function "succeded"
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }

    return bRC;
}

HRESULT WINAPI Shell_CreateLink (LPCTSTR pszLinkFilePathname, PLINKDATA pld) 
{  
    HRESULT hres;  
    IShellLink* psl;  
    IPersistFile* ppf;  
    hres = CoInitialize(NULL);  // Create a shell link object  
    hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (PVOID *) &psl); 
    if (SUCCEEDED(hres)) 
    {   // Initialize the shell link object   
        psl->SetPath(pld->pszPathname);   
        if (pld->fdwFlags & LD_USEARGS)      
            psl->SetArguments(pld->pszArgs);   
        if (pld->fdwFlags & LD_USEDESC)      
            psl->SetDescription(pld->pszDesc);   
        if (pld->fdwFlags & LD_USEICON)      
            psl->SetIconLocation(pld->pszIconPath, pld->nIconIndex);   
        if (pld->fdwFlags & LD_USEWORKDIR)      
            psl->SetWorkingDirectory(pld->pszWorkingDir);   
        if (pld->fdwFlags & LD_USESHOWCMD)      
            psl->SetShowCmd(pld->nShowCmd);   
        if (pld->fdwFlags & LD_USEHOTKEY)      
            psl->SetHotkey(pld->wHotkey);   
        
        // Save the shell link object on the disk   
        hres = psl->QueryInterface(IID_IPersistFile, (PVOID *) &ppf);   
        if (SUCCEEDED(hres)) 
        {
            hres = ppf->Save(A2W(pszLinkFilePathname), TRUE);

            ppf->Release();   
        }   
        psl->Release();  
    }  
    CoUninitialize();  
    return(hres);
}

//+----------------------------------------------------------------------------
//
//    Function:    DeleteStartUpCommand
//
//    Synopsis:    After restart the ICW we need to delete the .bat file from
//                the common startup directory
//
//    Arguements: None
//
//    Returns:    None
//
//    History:    1-10-97    ChrisK    Created
//
//-----------------------------------------------------------------------------
void DeleteStartUpCommand ()
{
    TCHAR szFileName[MAX_PATH + 1];
    LPITEMIDLIST lpItemDList = NULL;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL,CSIDL_STARTUP,&lpItemDList)))
    {
        if (SHGetPathFromIDList(lpItemDList, szFileName))
        {
            // make sure there is a trailing \ character
            if ('\\' != szFileName[lstrlen(szFileName)-1])
                lstrcat(szFileName,TEXT("\\"));
            lstrcat(szFileName,SHELL_LINK_NAME);                     
    
            //delete the shortcut
            DeleteFile(szFileName);
        }
      
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            //Don't worry about the return value of the function 
            //since even if we can't clean up the mem the shortcut was 
            //created so in that sense the function "succeded"
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }
}

//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while (('\0' != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;
    OSVERSIONINFO osver;
    
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
    {
        if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
        {
            // 
            // Get the current process token handle 
            // so we can get shutdown privilege. 
            //

            if (!OpenProcessToken(GetCurrentProcess(), 
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                    goto FGetSystemShutdownPrivledgeExit;

            //
            // Get the LUID for shutdown privilege.
            //

            ZeroMemory(&tkp,sizeof(tkp));
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                    &tkp.Privileges[0].Luid); 

            tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

            //
            // Get shutdown privilege for this process.
            //

            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                (PTOKEN_PRIVILEGES) NULL, 0); 

            if (ERROR_SUCCESS == GetLastError())
                bRC = TRUE;
        }
        else
        {
            bRC = TRUE;
        }
    }
FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}

BOOL SetupForReboot(long lRebootType)
{
    UINT   uRebootFlags;
    TCHAR* pszNewArgs = NULL;

    switch (lRebootType)
    {
        case 0:
            uRebootFlags = EWX_REBOOT;
            break;
            
        case 1:
            uRebootFlags = EWX_LOGOFF;
            break;
    }    
    //
    // twiddle the registry to work around a bug 
    // where it trashes the wallpaper
    //
    PrepareForRunOnceApp();

    LPTSTR lpRunOnceCmd;

    lpRunOnceCmd = (LPTSTR)GlobalAlloc(GPTR,MAX_PATH*2 + 1);

    if (lpRunOnceCmd)
    {
        GetModuleFileName(NULL, lpRunOnceCmd, MAX_PATH);

        //for smart reboot
        pszNewArgs = (TCHAR*)malloc((lstrlen(g_pszCmdLine)+MAX_PATH)*sizeof(TCHAR));
        
        if(pszNewArgs)
        {
            lstrcpy(pszNewArgs, g_pszCmdLine);
            lstrcat(pszNewArgs, TEXT(" "));
            lstrcat(pszNewArgs, SMARTREBOOT_CMD);
            lstrcat(pszNewArgs, TEXT(" "));
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_NEWISP)
                lstrcat(pszNewArgs, NEWISP_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG)
                lstrcat(pszNewArgs, AUTO_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_MANUAL)
                lstrcat(pszNewArgs, MANUAL_SR);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_LAN)
                lstrcat(pszNewArgs, LAN_SR);
        }

        if (FALSE == SetStartUpCommand(lpRunOnceCmd, (pszNewArgs ? pszNewArgs : g_pszCmdLine)))
            MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
        else
        {
            if (!FGetSystemShutdownPrivledge() ||
                !ExitWindowsEx(uRebootFlags,0))
            {
                MsgBox(IDS_EXITFAILED, MB_MYERROR);
            }
        }
        if(pszNewArgs)
            free(pszNewArgs);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\sbsintro.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SBSINTRO.C - Functions for SBS introductory Wizard pages
//

//  HISTORY:
//  
//  09/01/98  vyung  Created.
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:    SbsInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK SbsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {
        // This is the very first page, so do not allow back
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    gpWizardState->uCurrentPage = ORD_PAGE_SBSINTRO;
    
    return TRUE;
}



/*******************************************************************

  NAME:    SbsIntroOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK SbsIntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
                    // Do the system config checks
        if (!gpWizardState->cmnStateData.bSystemChecked && !ConfigureSystem(hDlg))
        {
         // gfQuitWizard will be set in ConfigureSystem if we need to quit
         return FALSE;
        }
        
        gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;

        *puNextPage = ORD_PAGE_AREACODE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\tutor.cpp ===
#include "pre.h"
#include "tutor.h"

CICWTutorApp::CICWTutorApp()
{
    //init the tutorial process structs
    memset(&m_StartInfo,   0, sizeof(m_StartInfo));
    memset(&m_ProcessInfo, 0, sizeof(m_ProcessInfo));

    SetTutorAppCmdLine();
}

CICWTutorApp::~CICWTutorApp()
{
    DWORD dwExitCode = 0; //thread is dead

    if (m_ProcessInfo.hThread)
    {
        GetExitCodeThread(m_ProcessInfo.hThread, &dwExitCode);

        if (dwExitCode == STILL_ACTIVE)
           TerminateProcess(m_ProcessInfo.hProcess, 0);
 
        CloseHandle(m_ProcessInfo.hThread);
        CloseHandle(m_ProcessInfo.hProcess);
    }
}

void CICWTutorApp::SetTutorAppCmdLine()
{
    
    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
    {
        //we're in IEAK mode get the path from the isp file
        GetPrivateProfileString(ICW_IEAK_SECTION, ICW_IEAK_TUTORCMDLN, ICW_DEFAULT_TUTOR, 
                                m_szTutorAppCmdLine, SIZE_OF_TUTOR_PATH, 
                                gpWizardState->cmnStateData.ispInfo.szISPFile);
    }
    else
    {
        TCHAR szOEMInfoPath [MAX_PATH] = TEXT("\0");
        
        //Try and get the path from the OEM file
        GetSystemDirectory(szOEMInfoPath, sizeof(szOEMInfoPath));
        lstrcat(szOEMInfoPath, TEXT("\\"));
        lstrcat(szOEMInfoPath, ICW_OEMINFO_FILENAME);
        
        //we're in IEAK mode get the path from the isp file
        GetPrivateProfileString(ICW_OEMINFO_ICWSECTION, ICW_OEMINFO_TUTORCMDLN, ICW_DEFAULT_TUTOR, 
                                m_szTutorAppCmdLine, SIZE_OF_TUTOR_PATH, 
                                szOEMInfoPath);
    }
}



BOOL CALLBACK EnumThreadWndProc(HWND hwnd, LPARAM lParam)
{
    
    if(IsWindowVisible(hwnd))
    {
        SetForegroundWindow(hwnd); 
    }
    return 1;
}


void CICWTutorApp::LaunchTutorApp()
{
    ASSERT(m_szTutorAppCmdLine);
    
    DWORD dwExitCode = 0; //thread is dead

    GetExitCodeThread(m_ProcessInfo.hThread, &dwExitCode);

    if (dwExitCode != STILL_ACTIVE)
    {
        CloseHandle(m_ProcessInfo.hThread);
        CloseHandle(m_ProcessInfo.hProcess);

        CreateProcess(NULL, 
                  m_szTutorAppCmdLine, 
                  NULL, 
                  NULL, 
                  TRUE, 
                  0, 
                  NULL, 
                  NULL, 
                  &m_StartInfo, 
                  &m_ProcessInfo);
    }
    else
    {
        EnumThreadWindows(m_ProcessInfo.dwThreadId, EnumThreadWndProc, 0);      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SIMPCNTR.RC
//


////////////////////////////////////////////
////////////////////////////////////////////
#ifdef ICWDEBUG

#define IDC_BROWSE                      9000
#define IDC_ISPCAB_PATH                 9009
#define IDC_ISPCAB_LIST                 9002
#define IDC_ISPCAB_PATH_LBL             9003
#define IDC_ISPCAB_LIST_LBL             9004
#define IDC_INSTRUCT_TEXT               9005
#define IDC_CAB_INSTRUCT_TEXT           9005
#define IDC_SIGNUP_PATH                 9006
#define IDC_AUTO_PATH                   9007
#define IDC_USE_NETWORK                 9008
#define IDC_MODEM                       9009
#define IDC_ISP_URL                     9090
#define IDC_OTHER_URL                   9099
#define IDC_URL                         9092
#define IDC_CHOOSE_PATH_LBL             9093
#define IDC_CHOOSE_MODEM_LBL            9094
#define IDC_CHOOSE_URL_LBL              9095
#define IDC_PATH_INSTRUCT_TEXT          9096
#define IDC_URL_LBL                     9097

#define IDS_ICWDEBUG_OFFER_TITLE        9098
#define IDS_ICWDEBUG_SETTINGS_TITLE     9099

#define IDD_ICWDEBUG_OFFER              9100
#define IDD_ICWDEBUG_SETTINGS           9101


#endif //ICWDEBUG
////////////////////////////////////////////
////////////////////////////////////////////

#define IDD_PAGE_MANUALOPTIONS          100
#define IDD_PAGE_AREACODE               101
#define IDD_PAGE_REFSERVDIAL            102
#define IDD_PAGE_INTRO                  103
#define IDD_PAGE_END                    104
#define IDD_PAGE_ENDOLS                 105
#define IDD_PAGE_DIALERROR              106
#define IDD_PAGE_MULTINUMBER            107
#define IDD_PAGE_SERVERROR              108
#define IDD_PAGE_BRANDEDINTRO           109
#define IDD_PAGE_INTRO2                 110
#define IDD_PAGE_DEFAULT                111
#define IDD_QUIT                        112
#define IDD_PAGE_SBSINTRO               113
#define IDD_EXISTINGCONNECTION          114
#define IDD_PAGE_ENDOEMCUSTOM           115
#define IDD_PAGE_SIZER                  116
#define IDD_CHOOSEWIZARD                117

#define IDC_STATIC                      -1
#define IDC_LBLTITLE                    1000
#define IDC_RUNNEW                      1001
#define IDC_RUNAUTO                     1002
#define IDC_ICWMAN                      1003
#define IDC_MANUAL_OLS                  1005
#define IDC_AREACODE                    1006
#define IDC_REFSERV_PHONENUM            1007
#define IDC_REFSERV_DIALSTATUS          1008
#define IDC_REFSERV_DIALPROGRESS        1009
#define IDC_DIALERR_TEXT                1010
#define IDC_DIALERR_MODEM               1012
#define IDC_CHANGE_NUMBER               1013
#define IDC_DIALING_PROPERTIES          1014
#define IDC_SIGUP_COUNTRY               1015
#define IDC_SIGUP_STATE                 1016
#define IDC_SIGUP_PHONE_NUMBER          1017
#define IDC_BUTTON_SIGNUP_OK            1018
#define IDC_BUTTON_SIGNUP_CANCEL        1019
#define IDC_MULTIPHONE_LIST             1020
#define IDC_SERVERR_HELP                1022
#define IDC_DIALERR_HELP                1023
#define IDC_SERVERR_TEXT                1024
#define IDC_MANUAL_LAN                  1025
#define IDC_MANUAL_MODEM                1026
#define IDC_TUTORIAL                    1028
#define IDC_COUNTRY                     1029
#define IDC_FINISH_TEXT                 1031
#define IDC_FINISH_SUPPORT_TEXT         1032
#define IDC_BRANDEDWEBVIEW              1033
#define IDC_AREADETECT                  1034
#define IDC_LBLAREA                     1035
#define IDC_LBLCOUNTRY                  1036
#define IDC_REFDIAL_TEXT                1037
#define IDC_LBLREFNUM                   1038
#define IDC_INTRO_MAINTEXT              1039
#define IDC_INTRO_SELECTOPT             1040
#define IDC_OLS_MAINTEXT                1041
#define IDC_OLS_FINISHTEXT              1042
#define IDC_DIALERR_LBLPHONENUMBER      1042
#define IDC_DIALERR_LBLCURMODEM         1043
#define IDC_DIALERR_LBLNEWNUMBER        1044
#define IDC_DIALERR_LBLCHNGNUMBER       1045
#define IDC_DIALERR_LBLHELP             1046
#define IDC_MULTINUM_MAINTEXT           1047
#define IDC_MULTINUM_LBLPHONE           1048
#define IDC_LBDIAL_FROM                 1049
#define IDC_DIAL_FROM                   1050
#define IDC_CHECK_BROWSING              1051
#define IDC_CHECK_HIDE_ICW              1052
#define IDC_MANUAL_INTRO                1053
#define IDC_BACK                        1100
#define IDC_NEXT                        1101
#define IDC_CANCEL                      1102
#define IDC_FINISH                      1103
#define IDC_EXIT_CONN                   1104
#define IDC_STATIC_ICON                 1105
#define IDC_INSERROR_FINISH_TEXT        1106
#define IDC_CLOSE_WIZ_CLICK_FINISH      1107
#define IDC_RUN_OOBE                    1108
#define IDC_RUN_NCW                     1109
#define IDC_CHOOSEWIZARD_TITLE          1110

#define IDI_ICWCONN1_ICON               200
#define IDB_WATERMARK256                210
#define IDB_WATERMARK16                 211
#define IDB_BANNER256                   212
#define IDB_BANNER16                    213
#define IDB_BANNER                      214

#define ID_NEXT_FIELD                   250
#define ID_PREV_FIELD                   251

#define IDA_ACCEL                       2000
#define IDA_INTRO2                      2001
#define IDA_AREACODE                    2002
#define IDA_ENDOEMCUSTOM                2003
#define IDA_DIALERROR                   2004


#define IDS_APPNAME                     500
#define IDS_CONNECT_DESKTOP_TITLE       501
#define IDS_CONNECT_FNAME               502
#define IDS_WANTTOEXIT                  503
#define IDS_OE_DESKTOP_TITLE            504
#define IDS_OE_APP_NAME                 505
#define IDS_DECLINETOS                  506
#define IDS_REQUIREDINFO                507                                  
#define IDS_CANTSAVEKEY                 508
#define IDS_EXITFAILED                  509                                    
#define IDS_NEEDREBOOT1                 510
#define IDS_NEEDREBOOT2                 511 
#define IDS_NEEDRESTART1                512
#define IDS_NEEDRESTART2                513
#define IDS_QUERYCANCEL                 514
#define IDS_ERR_CANNOTRUN               550
#define IDS_ERR_OUTOFMEMORY             551
#define IDS_HELPERLIB                   552
#define IDS_DLLREG_FAIL                 553
#define IDS_LOADLIB_FAIL                554
#define IDS_NODLLREG_FAIL               555
#define IDS_UTILLIB                     556
#define IDS_WIZARDLIB                   557
#define IDS_MANUALOPTS_TITLE            600
#define IDS_RASSTATUS_INITIAL           700
#define IDS_SERVERROR_TITLE             701
#define IDS_IEAK_ACCESS_DENIED          702
#define IDS_IEAK_ACCESS_DENIED_TITLE    703
#define IDS_ENDOLS_TITLE                704
#define IDS_STEP1_TITLE                 705
#define IDS_DEFAULT_ISPNAME             706
#define IDS_FINISH_TEXT                 708
#define IDS_FINISH_SUPPORT_TEXT         709
#define IDS_DIALERR_HELP                710
#define IDS_MANUAL_INTRO1               711
#define IDS_MANUAL_INTRO2               712
#define IDS_NOT_ENOUGH_DISKSPACE        713
#define IDS_DIALING_ERROR_TITLE         714
#define IDS_SERVER_ERROR_TITLE          715
#define IDS_REFDIAL_1                   716
#define IDS_REFDIAL_2                   717
#define IDS_WIZ97_TITLE_FONT_FACE       718
#define IDS_CONNECTION_OFFLINE          719
#define IDS_ADMIN_ACCESS_DENIED         720
#define IDS_ADMIN_ACCESS_DENIED_TITLE   721
#define IDS_OEMCUST_END_TITLE           723
#define IDS_DESKTOP                     724
#define IDS_SERVER_ERROR_COMMON         725
#define IDS_BACK                        750
#define IDS_NEXT                        751
#define IDS_FINISH                      752
#define IDS_CANCEL                      753
#define IDS_TUTORIAL                    754
#define IDS_EXIT_CONN                   755
#define IDS_END_SIGNUP_FINISH           757
#define IDS_END_AUTOCFG_FINISH          758
#define IDS_END_MANUAL_FINISH           759
#define IDS_PRECONFIG_ERROR_1           760
#define IDS_PRECONFIG_ERROR_1_NOINFO    761
#define IDS_PRECONFIG_ERROR_2           762
#define IDS_PRECONFIG_ERROR_2_NOINFO    763
#define IDS_INSCONFIG_ERROR_TITLE       764
#define IDS_INSCONFIG_ERROR_INSTRUCT    765
#define IDS_SHORTCUT_DESC               766
#define IDS_INSUFFICIENT_PRIV1          767
#define IDS_INSUFFICIENT_PRIV2          768

#define OEMCUSTOM_ERR_MSGFMT                        799
#define OEMCUSTOM_ERR_NOTOEMENTRY                   800
#define OEMCUSTOM_ERR_WINAPI                        801
#define OEMCUSTOM_ERR_NOMEM                         802
#define OEMCUSTOM_ERR_NOBUTTONTRANSPARENTCOLOR      803
#define OEMCUSTOM_ERR_NOBUTTONFONTSIZE              804
#define OEMCUSTOM_ERR_NOBUTTONLEFT                  805
#define OEMCUSTOM_ERR_NOBUTTONFONTFACE              806
#define OEMCUSTOM_ERR_HEADERPARAMS                  807
#define OEMCUSTOM_ERR_BUTTONPARAMS                  808
#define OEMCUSTOM_ERR_SIZE                          809
#define OEMCUSTOM_ERR_WIZARDTOP                     810
#define OEMCUSTOM_ERR_WIZARDLEFT                    811
#define OEMCUSTOM_ERR_BACKGROUND                    812
#define OEMCUSTOM_ERR_FIRSTHTML                     813
#define OEMCUSTOM_ERR_CANNOTFINDOEMCUSTINI          814

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         113
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\serverr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  06/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    ServErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ServErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    if (!fFirstInit)
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_REFSERVERR;
    
        
        switch (gpWizardState->lRefDialTerminateStatus)
        {
            case SP_OUTOFDISK:
            case ERROR_PATH_NOT_FOUND: //Occurs when download could not be created due to lack of space
            case ERROR_DISK_FULL:
            {
                TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                LoadString(g_hInstance, IDS_NOT_ENOUGH_DISKSPACE, szErr, ARRAYSIZE(szErr));
                SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                break;
            }
            case INTERNET_CONNECTION_OFFLINE:
            {
                TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                LoadString(g_hInstance, IDS_CONNECTION_OFFLINE, szErr, ARRAYSIZE(szErr));
                SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                break;
            }
            default:
            {   
                if(gpWizardState->bStartRefServDownload)
                {
                    TCHAR szErr [MAX_MESSAGE_LEN*3] = TEXT("\0");
                    LoadString(g_hInstance, IDS_SERVER_ERROR_COMMON, szErr, ARRAYSIZE(szErr));
                    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szErr);
                }
                else
                {
                    BSTR bstrErrMsg = NULL; 
                    gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
                    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), W2A(bstrErrMsg));
                    SysFreeString(bstrErrMsg);
                }
                break;
            }
        }

        // Currently this is removed from BETA 2
        //BSTR  bstrSupportPhoneNum = NULL; 
        //TCHAR szFmt [MAX_MESSAGE_LEN*3];
        //gpWizardState->pRefDial->get_SupportNumber(&bstrSupportPhoneNum);
        //if (bstrSupportPhoneNum)
        //{
        //    LoadString(g_hInstance, IDS_DIALERR_HELP, szFmt, ARRAYSIZE(szFmt));
        //    lstrcat(szFmt, W2A(bstrSupportPhoneNum));
        //    SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_HELP), szFmt);
        //    SysFreeString(bstrSupportPhoneNum);
        //    ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
        //}
        //else
        //    ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
    }        
   
    return bRet;
}


/*******************************************************************

  NAME:    ServErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ServErrorOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    // Initialze status before connecting
    gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bStartRefServDownload   = FALSE;

    if (fForward)
    {
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_REFSERVDIAL;
    }
    else
    {
        BOOL bRetVal;
        // Set userpick to FALSE to regenerate connectoid
        gpWizardState->bDoUserPick = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }

    return TRUE;
}

BOOL CALLBACK ServErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    if ((GET_WM_COMMAND_CMD (wParam, lParam) == BN_CLICKED) &&
        (GET_WM_COMMAND_ID  (wParam, lParam) == IDC_DIAL_HELP))
    {
        HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\refdial.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  REFDIAL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include <raserror.h>

extern UINT GetDlgIDFromIndex(UINT uPageIndex);
extern BOOL SetNextPage(HWND hDlg, UINT* puNextPage, BOOL* pfKeepHistory);
extern TCHAR g_szOemCode[];
extern TCHAR g_szProductCode[];
extern TCHAR g_szPromoCode[];

const TCHAR cszISPINFOPath[] = TEXT("download\\ispinfo.csv");

/*******************************************************************

  NAME:    RefServDialInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK RefServDialInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
    
    // Initialize the progres bar.
    SendDlgItemMessage(hDlg, IDC_REFSERV_DIALPROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
    SendDlgItemMessage(hDlg, IDC_REFSERV_DIALPROGRESS, PBM_SETPOS, 0, 0l);

    // Hide the progress bar
    ShowWindow(GetDlgItem(hDlg, IDC_REFSERV_DIALPROGRESS), SW_HIDE);

    // Disable Back and Next
    PropSheet_SetWizButtons(GetParent(hDlg), 0);

    g_bAllowCancel = FALSE;

    if (fFirstInit)
    {
        CRefDialEvent   *pRefDialEvent;
    
        //set the redial count
        gpWizardState->iRedialCount = 0;
        gpWizardState->dwLastSelection = 0;

        // Blank out the status text initially
        SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_DIALSTATUS), TEXT(""));
        
        // Setup and Event Handler
        pRefDialEvent = new CRefDialEvent(hDlg);
        if (NULL != pRefDialEvent)
        {
            HRESULT hr;
            gpWizardState->pRefDialEvents = pRefDialEvent;
            gpWizardState->pRefDialEvents->AddRef();
    
            hr = ConnectToICWConnectionPoint((IUnknown *)gpWizardState->pRefDialEvents, 
                                         DIID__RefDialEvents,
                                        TRUE,
                                        (IUnknown *)gpWizardState->pRefDial, 
                                        &gpWizardState->pRefDialEvents->m_dwCookie, 
                                        NULL);     
            
            bRet = TRUE;
                
        }
        else
        {
            //BUGBUG: Throw error message
                        
            gfQuitWizard = TRUE;
            bRet = FALSE;
        } 

        return (bRet);
    }
    else
    {      
        ASSERT(puNextPage);


        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.

        gpWizardState->uCurrentPage = ORD_PAGE_REFSERVDIAL;

        SetNextPage(hDlg, puNextPage, NULL);

        //
        // Display the messages 
        //
        TCHAR    szTemp[MAX_MESSAGE_LEN];

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            LoadString(g_hInstance, IDS_REFDIAL_1, szTemp, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_REFDIAL_TEXT), szTemp);
        }
        else
        {
            TCHAR    szIntro[MAX_MESSAGE_LEN];
            LoadString(g_hInstance, IDS_REFDIAL_1, szIntro, MAX_MESSAGE_LEN);
            LoadString(g_hInstance, IDS_REFDIAL_2, szTemp, MAX_MESSAGE_LEN);
            lstrcat(szIntro, szTemp);
            SetWindowText(GetDlgItem(hDlg, IDC_REFDIAL_TEXT), szIntro);
        }

        gpWizardState->pRefDial->DoInit();
    }
    return bRet;
}


BOOL CALLBACK RefServDialPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;

    if (!fFirstInit)
    {

        // Force the Window to update
        UpdateWindow(GetParent(hDlg));
        gpWizardState->bDoneRefServRAS       = FALSE;
        gpWizardState->bStartRefServDownload = FALSE;
        gpWizardState->bDoneRefServDownload  = FALSE;
        
        if (!gpWizardState->iRedialCount)
            // If it's not a redial blank out the status text 
            SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_DIALSTATUS), TEXT(""));

        if (!gpWizardState->bDoUserPick)
        {
            BSTR            bstrPhoneNum = NULL; 
            DWORD           dwFlag = (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG) ? ICW_CFGFLAG_AUTOCONFIG : 0;
            BOOL            bRetVal;

            dwFlag |= gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS;

            // Setup for Dialing.  This will ensure that we are ready to dial.
            gpWizardState->pRefDial->SetupForDialing(A2W(TEXT("msicw.isp")), 
                                                     gpWizardState->cmnStateData.dwCountryCode,
                                                     A2W(gpWizardState->cmnStateData.szAreaCode),
                                                     dwFlag,
                                                     &bRetVal);

            // if /branding switch is not specified in command line, alloffers become true.
            if (!(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS))
                gpWizardState->pRefDial->put_AllOfferCode(1);

            // We override oem, product and promo codes with the one from command line if there is.
            if ( *g_szOemCode || *g_szPromoCode ||
                 gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_PRODCODE_FROM_CMDLINE )
            {
                BSTR    bstrTmp;

                if( *g_szOemCode )
                    bstrTmp = A2W(g_szOemCode);
                else
                    bstrTmp = A2W(DEFAULT_OEMCODE);
                gpWizardState->pRefDial->put_OemCode(bstrTmp);

                if( gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_PRODCODE_FROM_CMDLINE )
                    bstrTmp = A2W(g_szProductCode);
                else
                    bstrTmp = A2W(DEFAULT_PRODUCTCODE);
                gpWizardState->pRefDial->put_ProductCode(bstrTmp);

                if( *g_szPromoCode )
                    bstrTmp = A2W(g_szPromoCode);
                else
                    bstrTmp = A2W(DEFAULT_PROMOCODE);
                gpWizardState->pRefDial->put_PromoCode(bstrTmp);

                // if any of /oem, /prod, or /promo is specified in command line, Alloffers becomes false
                gpWizardState->pRefDial->put_AllOfferCode(0);
            }

            if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
                gpWizardState->pRefDial->put_AllOfferCode(1);

            if (bRetVal)
            {
                // Show the phone Number
                gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_PHONENUM), W2A(bstrPhoneNum));
        
                if (ERROR_SUCCESS == gpWizardState->pRefDial->FormReferralServerURL(&bRetVal))
                {
                    gpWizardState->pRefDial->DoConnect(&bRetVal);
                }
                else
                {
                    // BUGBUG: Throw error message
                
                    gfQuitWizard = TRUE;
                    bRet =  FALSE;
                }
            }
            else
            {
                //gpWizardState->pRefDial->SelectedPhoneNumber(1, &bRetVal);
                gpWizardState->pRefDial->get_UserPickNumber(&bRetVal);
                if (bRetVal)
                {
                    gpWizardState->bDoUserPick = TRUE;

                    // Simulate the press of the NEXT button
                    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                
            
                    bRet = TRUE;
                }
                else
                {       
                    gpWizardState->pRefDial->get_QuitWizard(&bRetVal);
                    if (bRetVal)
                    {
                        gfQuitWizard = TRUE;
                        bRet = FALSE;

                    }
                    else 
                    {
                        gpWizardState->pRefDial->get_TryAgain(&bRetVal);
                        if (bRetVal)
                        {
                            PropSheet_PressButton(GetParent(hDlg),PSBTN_BACK);
                        }
                        else
                        {
                            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                        }
                    }
                }                
            }   
            SysFreeString(bstrPhoneNum);                                              
        }        
        else // else (!gpWizardState->bDoUserPick)
        {

            BOOL    bRetVal;
            BSTR    bstrPhoneNum = NULL; 

            // Have we selected a phone number from Multi number page?
            if (gpWizardState->lSelectedPhoneNumber != -1) 
            {
                gpWizardState->pRefDial->SelectedPhoneNumber(gpWizardState->lSelectedPhoneNumber, &bRetVal);
                gpWizardState->lSelectedPhoneNumber = -1;
            }

            // Show the phone Number
            gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
            SetWindowText(GetDlgItem(hDlg, IDC_REFSERV_PHONENUM), W2A(bstrPhoneNum));
            SysFreeString(bstrPhoneNum);

            gpWizardState->pRefDial->FormReferralServerURL(&bRetVal);
            gpWizardState->pRefDial->DoConnect(&bRetVal);
            
            gpWizardState->bDoUserPick = FALSE;

        }
    }  // endif (!Firstinit)
    return bRet;
}

/*******************************************************************

  NAME:    RefServDialOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK RefServDialOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    //Load the External Pages here
    
    if (fForward)
    {
        *pfKeepHistory = FALSE;
        // BUGBUG move this to the global state
        if (gpWizardState->bDoUserPick)
        {
            *puNextPage = ORD_PAGE_MULTINUMBER;
            return TRUE;
        }
        gpWizardState->bDoUserPick = TRUE;
        
        if (gpWizardState->bDoneRefServDownload)
        {
            // BUGBUG, need to set a legit last page, maybe!
            int iReturnPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted - 1];

            // Set it so that We will read the new ispinfo.csv in incwconn.dll
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            
            //Make sure we really have a file to parse, other bail to server error
            HANDLE hFile = CreateFile((LPCTSTR)cszISPINFOPath, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
            if (INVALID_HANDLE_VALUE != hFile)
            {            
                CloseHandle(hFile);
                gpWizardState->pRefDial->get_bIsISDNDevice(&gpWizardState->cmnStateData.bIsISDNDevice);

                if (LoadICWCONNUI(GetParent(hDlg), GetDlgIDFromIndex(iReturnPage), IDD_PAGE_DEFAULT, gpWizardState->cmnStateData.dwFlags))
                {
                    if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                    {
                        // we're about to jump into the external apprentice, and we don't want
                        // this page to show up in our history list
                        BOOL bRetVal;
                        *pfKeepHistory = FALSE;
                        *puNextPage = g_uICWCONNUIFirst;
                        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
                        gpWizardState->bDoUserPick = 0;
                    
                        // Backup 1 in the history list, since we the external pages navigate back
                        // we want this history list to be in the correct spot.  Normally
                        // pressing back would back up the history list, and figure out where to
                        // go, but in this case, the external DLL just jumps right back in.
                        gpWizardState->uPagesCompleted--;
                    
                    }
                    else
                    {
                    }
                }
            }
            else
            {
                // server error
                *puNextPage = ORD_PAGE_REFSERVERR;
            }
        }
        else
        {
            if (gpWizardState->bDoneRefServRAS)
            {
                // server error
                *puNextPage = ORD_PAGE_REFSERVERR;
            }
            else
            {
                //OK so we had a dialing error but let's figure out which one...
                HRESULT hrDialErr;
                
                gpWizardState->pRefDial->get_DialError(&hrDialErr);

                switch (hrDialErr)
                {
                    case ERROR_LINE_BUSY: //Line is engaged
                    {     
                        if (gpWizardState->iRedialCount < NUM_MAX_REDIAL)
                        {   
                            //Redial
                            // Initialze status before connecting
                            gpWizardState->lRefDialTerminateStatus = ERROR_SUCCESS;
                            gpWizardState->bDoneRefServDownload    = FALSE;
                            gpWizardState->bDoneRefServRAS         = FALSE;
                            gpWizardState->bStartRefServDownload   = FALSE;

                            // Assume the user has selected a number on this page
                            // So we will not do SetupForDialing again next time
                            gpWizardState->bDoUserPick          = TRUE;

                            *puNextPage = ORD_PAGE_REFSERVDIAL;
                            gpWizardState->iRedialCount++;
                            break;
                        }
                        gpWizardState->iRedialCount = 0;
                    }
                    default:
                    {
                        // nothing special just goto the dialing error page
                        *puNextPage = ORD_PAGE_REFDIALERROR;
                        break;
                    }
                }              
            }
        }            
    }     
    else // a retry is simulated when BACK is pressed
    {
        *puNextPage = ORD_PAGE_REFSERVDIAL;
    }
    return TRUE;
}

BOOL CALLBACK RefServDialCancelProc(HWND hDlg)
{
    ASSERT(gpWizardState->pRefDial);

    //User has canceled so reset the redial count
    gpWizardState->iRedialCount = 0;
    
    gpWizardState->pRefDial->DoHangup();

    //We should make sure the wiz thinks it's a dialerr to avoid
    //the server error page
    gpWizardState->bStartRefServDownload   = FALSE;
    gpWizardState->bDoneRefServDownload    = FALSE;
    gpWizardState->bDoneRefServRAS         = FALSE;
    gpWizardState->bDoUserPick             = FALSE;
    gpWizardState->lRefDialTerminateStatus = ERROR_CANCELLED;
    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\tutor.h ===
#ifndef __TUTOR_H
#define __TUTOR_H

#define ICW_DEFAULT_TUTOR   TEXT("icwtutor.exe")
#define SIZE_OF_TUTOR_PATH  MAX_PATH*3

class CICWTutorApp
{
public:
    CICWTutorApp  ();
    ~CICWTutorApp ();

    void LaunchTutorApp ();
    void ReplaceTutorAppCmdLine(LPTSTR lpszCmdLine)
    {
        if (lpszCmdLine)
            lstrcpyn(m_szTutorAppCmdLine, lpszCmdLine, sizeof(m_szTutorAppCmdLine));
    };
    
private:
    STARTUPINFO         m_StartInfo;
    PROCESS_INFORMATION m_ProcessInfo;
    TCHAR               m_szTutorAppCmdLine [SIZE_OF_TUTOR_PATH];

    void SetTutorAppCmdLine ();
};

#endif __TUTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  05/13/98    donaldm     new for ICW 5.0

#ifndef _WIZDEF_H_
#define _WIZDEF_H_
#include "appdefs.h"

// Defines
#define MAX_REG_LEN         2048    // max length of registry entries
#define MAX_RES_LEN         255     // max length of string resources
#define SMALL_BUF_LEN       48      // convenient size for small text buffers



// structure to hold information about wizard state
typedef struct tagWIZARDSTATE
{
    UINT    uCurrentPage;    // index of current page wizard is on
    
    // keeps a history of which pages were visited, so user can
    // back up and we know the last page completed in case of reboot.
    UINT    uPageHistory[EXE_NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT    uPagesCompleted;         // # of pages in uPageHistory

    BOOL    fNeedReboot;    // reboot needed at end

    BOOL    bStartRefServDownload;
    BOOL    bDoneRefServDownload;
    BOOL    bDoneRefServRAS;
    BOOL    bDoUserPick;
    long    lRefDialTerminateStatus;
    long    lSelectedPhoneNumber;

    long    lLocationID;
    long    lDefaultLocationID;

    int     iRedialCount;
    // Objects that live in ICWHELP.DLL that we need to use
    IRefDial*           pRefDial;
    IDialErr*           pDialErr;
    ISmartStart*        pSmartStart;
    ITapiLocationInfo*  pTapiLocationInfo;
    IINSHandler*        pINSHandler;
    CRefDialEvent*      pRefDialEvents;
    IICWWalker*         pHTMLWalker;
    IICWWebView*        pICWWebView; // ICWWebView Object
    HINSTANCE           hInstUtilDLL;
        
    // State data that is common to both sides of the WIZARD
    CMNSTATEDATA        cmnStateData;
    DWORD               dwLastSelection;

} WIZARDSTATE;


#define IEAK_RESTRICTION_REGKEY        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define IEAK_RESTRICTION_REGKEY_VALUE  TEXT("Connwiz Admin Lock")

#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn1\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "pre.h"

// function prototypes
VOID _cdecl FormatErrorMessage(LPTSTR pszMsg,DWORD cbMsg,LPTSTR pszFmt,LPTSTR szArg);
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );

// Static data
static const TCHAR szRegValICWCompleted[] = TEXT("Completed");

#define MAX_STRINGS                  5
#define OEM_CONFIG_INS_FILENAME      TEXT("icw\\OEMCNFG.INS")
#define OEM_CONFIG_REGKEY            TEXT("SOFTWARE\\Microsoft\\Internet Connection Wizard\\INS processing")
#define OEM_CONFIG_REGVAL_FAILED     TEXT("Process failed")
#define OEM_CONFIG_REGVAL_ISPNAME    TEXT("ISP name")
#define OEM_CONFIG_REGVAL_SUPPORTNUM TEXT("Support number")
#define OEM_CONFIG_INS_SECTION       TEXT("Entry")
#define OEM_CONFIG_INS_ISPNAME       TEXT("Entry_Name")
#define OEM_CONFIG_INS_SUPPORTNUM    TEXT("Support_Number")

int     iSzTable=0;
TCHAR   szStrTable[MAX_STRINGS][512];

//+----------------------------------------------------------------------------
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
//+----------------------------------------------------------------------------
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = szStrTable[iSzTable];
    
    iSzTable++;
    if (iSzTable >= MAX_STRINGS)
        iSzTable = 0;
        
    if (!LoadString(g_hInstance, wszID, psz, 512))
    {
        *psz = 0;
    }
    return (psz);
}

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    return (MessageBox(hWnd,
                       GetSz((USHORT)nMsgID),
                       GetSz(IDS_APPNAME),
                       uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    return (MessageBox(hWnd,szText,GetSz(IDS_APPNAME),uIcon | uButtons));
}

void OlsFinish()
{
    QuickCompleteSignup();
    g_bRunDefaultHtm = FALSE;
    g_szShellNext[0] = '\0';
}



void SetICWComplete(void)
{
    // Set the completed bit
    HKEY    hkey          = NULL;
    DWORD   dwValue       = 1;
    DWORD   dwDisposition = 0;

    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                       ICWSETTINGSPATH,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE, 
                                       KEY_ALL_ACCESS, 
                                       NULL, 
                                       &hkey, 
                                       &dwDisposition))

    {
        RegSetValueEx(hkey,
                      szRegValICWCompleted,
                      0,
                      REG_BINARY,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));                              

        RegCloseKey(hkey);
    }
}


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


HRESULT ConnectToICWConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}

BOOL ConfirmCancel(HWND hWnd)
{
    TCHAR    szTitle[MAX_TITLE];
    TCHAR    szMessage[MAX_MESSAGE];
        
    LoadString(g_hInstance, IDS_APPNAME, szTitle, sizeof(szTitle));
    LoadString(g_hInstance, IDS_WANTTOEXIT, szMessage, sizeof(szMessage));
        
    if (IDYES == MessageBox(hWnd,
                            szMessage, 
                            szTitle, 
                            MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL Restart(HWND  hWnd)
{
    TCHAR   szLongString[1024];
    LPTSTR  pszSmallString1, pszSmallString2;
    
    pszSmallString1 = GetSz(IDS_NEEDRESTART1);
    pszSmallString2 = GetSz(IDS_NEEDRESTART2);
    lstrcpy(szLongString,pszSmallString1);
    lstrcat(szLongString,pszSmallString2);
        
    if (IDYES == MessageBox(hWnd,
                            szLongString, 
                            GetSz(IDS_APPNAME),
                            MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2))
    {
        SetupForReboot(1);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}                
        
void Reboot(HWND hWnd)
{
    TCHAR   szLongString[1024];
    LPTSTR  pszSmallString1, pszSmallString2;

    // 4/28/97 ChrisK
    // Fix build break, because string was too long for compiler.
    pszSmallString1 = GetSz(IDS_NEEDREBOOT1);
    pszSmallString2 = GetSz(IDS_NEEDREBOOT2);
    lstrcpy(szLongString,pszSmallString1);
    lstrcat(szLongString,pszSmallString2);
    
    //
    // ChrisK Olympus 419
    // We changed our mind again and decided to no give the user a chance to avoid rebooting.
    //
    MessageBox( hWnd,
                szLongString,
                GetSz(IDS_APPNAME),
                MB_APPLMODAL |
                MB_ICONINFORMATION |
                MB_SETFOREGROUND |
                MB_OK);

    SetupForReboot(0);
}


BOOL WINAPI ConfigureSystem(HWND hDlg)
{
    BOOL    bReboot = FALSE;
    BOOL    bRestart = FALSE;
    BOOL    bQuitWizard = FALSE;
    BOOL    bNoPWCaching = FALSE;

    PropSheet_SetWizButtons(GetParent(hDlg),0);
    gpWizardState->cmnStateData.pICWSystemConfig->ConfigSystem(&gpWizardState->cmnStateData.bSystemChecked);
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    
    if (!gpWizardState->cmnStateData.bSystemChecked)
    {
        gpWizardState->cmnStateData.pICWSystemConfig->get_NeedsReboot(&bReboot);
        if (bReboot)
        {
            Reboot(hDlg);
            gfQuitWizard = TRUE;
            return FALSE;
        }
        
        gpWizardState->cmnStateData.pICWSystemConfig->get_NeedsRestart(&bRestart);
        if (bRestart)
        {
            if (Restart(hDlg))
            {
                gfQuitWizard = TRUE;
                return FALSE;
            }                
            else
            {
                if (ConfirmCancel(hDlg))
                {
                    gfQuitWizard = TRUE;
                }
                return FALSE;
            }                
        }
        
        gpWizardState->cmnStateData.pICWSystemConfig->get_QuitWizard(&bQuitWizard);
        if(bQuitWizard)
        {
            gfQuitWizard = TRUE;
            return FALSE;
        }
        else
        {
            if (ConfirmCancel(hDlg))
                gfQuitWizard = TRUE;
            return FALSE;
            
        }
    }
    
    // Make sure there is not a policy against password caching
    gpWizardState->cmnStateData.pICWSystemConfig->CheckPasswordCachingPolicy(&bNoPWCaching);
    if (bNoPWCaching)
    {
        // too bad, no password caching, no ICW
        gfQuitWizard = TRUE;
        return FALSE;
    }
    
    return true;
}

BOOL IsNT5()
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return ((VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId) && (OsVersionInfo.dwMajorVersion >= 5));
}

BOOL IsNT()
{
    OSVERSIONINFO OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}

BOOL IsWhistler()
{
    BOOL            bRet = FALSE;
    OSVERSIONINFO   OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&OsVersionInfo))
    {
        if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            OsVersionInfo.dwMajorVersion >= 5 &&
            OsVersionInfo.dwMinorVersion >= 1)
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

BOOL DoesUserHaveAdminPrivleges(HINSTANCE hInstance)
{
    HKEY hKey = NULL;
    BOOL bRet = FALSE;

    if (!IsNT())
        return TRUE;

    // BUGBUG: We should allow NT5 to run in all user groups
    // except normal users.
    if (IsNT5())
        return TRUE;
    
    //
    // Ensure caller is an administrator on this machine.
    //
    if(RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_WRITE, &hKey) == 0)
    {
        RegCloseKey(hKey);
        bRet = TRUE;
    }

    return bRet;
}

void WINAPI FillWindowWithAppBackground
(
    HWND    hWndToFill,
    HDC     hdc
)
{
    RECT        rcUpdate;
    RECT        rcBmp;
    HDC         hdcWnd;
    HDC         hSourceDC;
    HGDIOBJ     hgdiOldBitmap; 

    // If we are passed in the DC to use then use it, otherwise get 
    // the DC from the window handle
    if (hdc)
        hdcWnd = hdc;
    else
        hdcWnd = GetDC(hWndToFill);
    hSourceDC = CreateCompatibleDC( hdcWnd ); 
            
    // Compute the client area of the main window that needs to be
    // erased, so that we can extract that chunk of the background
    // bitmap
    GetUpdateRect(hWndToFill, &rcUpdate, FALSE);
    // Make sure the rectangle is not empty
    if (IsRectEmpty(&rcUpdate))
    {
        InvalidateRect(hWndToFill, NULL, FALSE);
        GetUpdateRect(hWndToFill, &rcUpdate, FALSE);
    }
    
    rcBmp = rcUpdate;
    if (hWndToFill != gpWizardState->cmnStateData.hWndApp)
        MapWindowPoints(hWndToFill, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcBmp, 2);

    // paint the background bitmap
    hgdiOldBitmap = SelectObject( hSourceDC, (HGDIOBJ) gpWizardState->cmnStateData.hbmBkgrnd); 
    BitBlt( hdcWnd, 
            rcUpdate.left, 
            rcUpdate.top, 
            RECTWIDTH(rcUpdate),
            RECTHEIGHT(rcUpdate),
            hSourceDC, 
            rcBmp.left, 
            rcBmp.top, 
            SRCCOPY ); 

    // Cleanup GDI Objects
    SelectObject( hSourceDC, hgdiOldBitmap ); 
            
    DeleteDC(hSourceDC);
    // If we were not passed the DC, then release the one that we
    // got from the window handle
    if (!hdc)
        ReleaseDC(hWndToFill, hdcWnd);
}

// Fill in a rectangle within the specificed DC with the app's bkgrnd.
// lpRectDC is a rectangle in the DC's coordinate space, and lpRectApp
// is a rectangle in the Apps coordinate space
void FillDCRectWithAppBackground
(
    LPRECT  lpRectDC,
    LPRECT  lpRectApp,
    HDC     hdc
    
)
{
    HDC         hSourceDC = CreateCompatibleDC( hdc ); 
    HGDIOBJ     hgdiOldBitmap; 

    // paint the background bitmap
    hgdiOldBitmap = SelectObject( hSourceDC, (HGDIOBJ) gpWizardState->cmnStateData.hbmBkgrnd); 
    BitBlt( hdc, 
            lpRectDC->left, 
            lpRectDC->top, 
            RECTWIDTH(*lpRectDC),
            RECTHEIGHT(*lpRectDC),
            hSourceDC, 
            lpRectApp->left, 
            lpRectApp->top,
            SRCCOPY ); 

    // Cleanup GDI Objects
    SelectObject( hSourceDC, hgdiOldBitmap ); 
    DeleteDC(hSourceDC);
}


BOOL CheckForOemConfigFailure(HINSTANCE hInstance)
{
    HKEY  hKey                                        = NULL;
    DWORD dwFailed                                    = 0;
    DWORD dwSize                                      = sizeof(dwFailed);
    TCHAR szIspName    [MAX_PATH+1]                   = TEXT("\0");
    TCHAR szSupportNum [MAX_PATH+1]                   = TEXT("\0");    
    TCHAR szErrMsg1    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsg2    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsgTmp1 [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrMsgTmp2 [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szCaption    [MAX_RES_LEN]                  = TEXT("\0");    
    TCHAR szErrDlgMsg  [MAX_PATH*2 + MAX_RES_LEN + 2] = TEXT("\0");    
    
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                   OEM_CONFIG_REGKEY,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey);
                   
    if(hKey)
    {
        RegQueryValueEx(hKey,
                        OEM_CONFIG_REGVAL_FAILED,
                        0,
                        NULL,
                        (LPBYTE)&dwFailed,
                        &dwSize);

        if(dwFailed)
        {
            dwSize = sizeof(szIspName);

            RegQueryValueEx(hKey,
                            OEM_CONFIG_REGVAL_ISPNAME,
                            0,
                            NULL,
                            (LPBYTE)&szIspName,
                            &dwSize);

            dwSize = sizeof(szSupportNum);

            RegQueryValueEx(hKey,
                            OEM_CONFIG_REGVAL_SUPPORTNUM,
                            0,
                            NULL,
                            (LPBYTE)&szSupportNum,
                            &dwSize);

            if(*szIspName)
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_1, szErrMsg1, sizeof(szErrMsg1));
                wsprintf(szErrMsgTmp1, szErrMsg1, szIspName); 
                lstrcpy(szErrDlgMsg,szErrMsgTmp1);
            }
            else
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_1_NOINFO, szErrMsg1, sizeof(szErrMsg1));
                lstrcpy(szErrDlgMsg, szErrMsg1);
            }
            
            if(*szSupportNum)
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_2, szErrMsg2, sizeof(szErrMsg2));
                wsprintf(szErrMsgTmp2, szErrMsg2, szSupportNum); 
                lstrcat(szErrDlgMsg, szErrMsgTmp2);
            }
            else
            {
                LoadString(hInstance, IDS_PRECONFIG_ERROR_2_NOINFO, szErrMsg2, sizeof(szErrMsg2));
                lstrcat(szErrDlgMsg, szErrMsg2);
            }
            
            LoadString(hInstance, IDS_APPNAME, szCaption, sizeof(szCaption));
            
            MessageBox(NULL, szErrDlgMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);

            dwFailed = 0;

            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_FAILED,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwFailed,
                          sizeof(dwFailed));

            CloseHandle(hKey);
            
            return TRUE;
        }
    }

    return FALSE;
}

//returns TRUE if it could successfully find locate the file 
//and attempt to configure the system, this does not mean however that the process was successful
BOOL RunOemconfigIns()
{
    TCHAR szInsPath    [MAX_PATH+1] = TEXT("\0");
    TCHAR szIspName    [MAX_PATH+1] = TEXT("\0");
    TCHAR szSupportNum [MAX_PATH+1] = TEXT("\0");    
    BOOL  bRet                      = FALSE;
    
    GetWindowsDirectory(szInsPath, MAX_PATH+1);

    if(!szInsPath)
        return FALSE;

    if(*CharPrev(szInsPath, szInsPath + lstrlen(szInsPath)) != TEXT('\\'))
        lstrcat(szInsPath, TEXT("\\"));
    
    lstrcat(szInsPath, OEM_CONFIG_INS_FILENAME);

    //if we can't find the file return false
    if(0xFFFFFFFF == GetFileAttributes(szInsPath))
        return FALSE;

    //ProcessINS will nuke the file so if we want this info we should get it now
    GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                            OEM_CONFIG_INS_ISPNAME,
                            TEXT(""),
                            szIspName,
                            sizeof(szIspName),
                            szInsPath);
        
    GetPrivateProfileString(OEM_CONFIG_INS_SECTION,
                            OEM_CONFIG_INS_SUPPORTNUM,
                            TEXT(""),
                            szSupportNum,
                            sizeof(szSupportNum),
                            szInsPath);

    //set silent mode to disallow UI
    gpWizardState->pINSHandler->put_SilentMode(TRUE);
    // Process the inf file.
    gpWizardState->pINSHandler->ProcessINS(A2W(szInsPath), &bRet);

    if(bRet)
         QuickCompleteSignup(); 
    else
    {        
        HKEY  hKey           = NULL;
        DWORD dwDisposition  = 0;
        DWORD dwFailed       = 1;

        //Let's make double sure we nuke the file.
        if(0xFFFFFFFF != GetFileAttributes(szInsPath))
        {
            DeleteFile(szInsPath);
        }

        RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       OEM_CONFIG_REGKEY,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS, 
                       NULL, 
                       &hKey, 
                       &dwDisposition);

        if(hKey)
        {
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_FAILED,
                          0,
                          REG_DWORD,
                          (LPBYTE)&dwFailed,
                          sizeof(dwFailed));
            
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_ISPNAME,
                          0,
                          REG_SZ,
                          (LPBYTE)szIspName,
                          sizeof(TCHAR)*lstrlen(szIspName));
            
            RegSetValueEx(hKey,
                          OEM_CONFIG_REGVAL_SUPPORTNUM,
                          0,
                          REG_SZ,
                          (LPBYTE)szSupportNum,
                          sizeof(TCHAR)*lstrlen(szSupportNum));

            CloseHandle(hKey);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\bmp.h ===
/****************************************************************************
 *
 * Bmp.H
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

// BMP functions
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance);
void FAR PASCAL BMP_DestroyClass(HINSTANCE hInstance);
void FAR PASCAL BMP_Paint(HWND hwnd);
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam );

// Class name
#define SU_BMP_CLASS "ms_setup_bmp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\debug.h ===
/*-----------------------------------------------------------------------------
	debug.h

	Declarations for debug features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
-----------------------------------------------------------------------------*/

#ifndef _PHBKDEBUG
#define _PHBKDEBUG


void Dprintf(LPCTSTR pcsz, ...);

#ifdef DEBUG
	BOOL FAssertProc(LPCTSTR szFile,  DWORD dwLine, LPCTSTR szMsg, DWORD dwFlags);
	void DebugSz(LPCTSTR psz);
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg)
	#define AssertSz(f, sz)
	#define Assert(f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\debug.cpp ===
/*-----------------------------------------------------------------------------
	debug.cpp

	This file implements the debuggin features

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>



#if defined(WIN16)
extern HINSTANCE g_hInst;
extern LPSTR g_lpszCommandLine;
extern LPSTR GetCommandLine(void);
#endif 


BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCTSTR psz)
{
#if defined(DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCTSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	TCHAR	szBuf[1024];
	
	va_start(argp, pcsz);

#if defined(WIN16)
	vsprintf(szBuf, pcsz, argp);
#else
	wvsprintf(szBuf, pcsz, argp);
#endif
	

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCTSTR szFile,  DWORD dwLine, LPCTSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	TCHAR szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	LPTSTR pszCommandLine = GetCommandLine();
	//BYTE	szTime[80];
#if !defined(WIN16)
	HANDLE	hAssertTxt;
	TCHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz(TEXT("***Recursive Assert***\r\n"));
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInst, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,TEXT("%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s"),
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,TEXT("Assertion Failed"));

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile(TEXT("assert.txt"), GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, TEXT("\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n"), st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			exit(0);
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\dialcan.cpp ===
/*-----------------------------------------------------------------------------
	dialcan.cpp

	This function handle the stern warning given when the user cancels
	setting up their Internet software

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

HRESULT ShowDialReallyCancelDialog(HINSTANCE hInst, HWND hwnd, LPTSTR pszHomePhone)
{
	INT iRC = 0;

#if defined(WIN16)		
	DLGPROC dlgprc;
	dlgprc = (DLGPROC) MakeProcInstance((FARPROC)DialReallyCancelDlgProc, hInst);
	iRC = DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_DIALREALLYCANCEL),
							hwnd, dlgprc, (LPARAM)pszHomePhone);
	FreeProcInstance((FARPROC) dlgprc);
#else
	iRC = (HRESULT)DialogBoxParam(hInst,
							MAKEINTRESOURCE(IDD_DIALREALLYCANCEL),
							hwnd,DialReallyCancelDlgProc,
							(LPARAM)pszHomePhone);
#endif

	return iRC;
}


extern "C" INT_PTR CALLBACK FAR PASCAL DialReallyCancelDlgProc(HWND hwnd, 
																UINT uMsg, 
																WPARAM wparam, 
																LPARAM lparam)
{
	BOOL bRes = TRUE;
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif

	switch (uMsg)
	{
	case WM_INITDIALOG:
#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif
		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
		if (lparam)
			SetDlgItemText(hwnd,IDC_LBLCALLHOME,(LPCTSTR)lparam);
		bRes = TRUE;
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		bRes=FALSE;
		break;
	case WM_CLOSE:
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
		case IDC_CMDCANCEL:
			EndDialog(hwnd,ERROR_USERCANCEL);
			break;
		case IDC_CMDNEXT:
			EndDialog(hwnd,ERROR_USERNEXT);
			break;
		}
		break;
	default:
		bRes = FALSE;
		break;
	}
	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\globals.h ===
/*-----------------------------------------------------------------------------
    globals.h

    General declarations for ICWCONN2

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved

    Authors:
        ChrisK  Chris Kauffman

    Histroy:
        7/22/96 ChrisK   Cleaned and formatted
        9/11/98 a-jaswed really Cleaned and formatted
    
-----------------------------------------------------------------------------*/

#include "debug.h"
#include "resource.h"
#include "helpids.h"
#include "..\inc\icwdial.h"
#include "..\inc\icwerr.h"
#include "..\icwphbk\phbk.h" // need this to get the LPCNTRYNAMELOOKUPELEMENT struct definition
#include "ras2.h"
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
#include "rnaapi.h"

#define DOWNLOAD_LIBRARY         TEXT("icwdl.dll")
#define DOWNLOADINIT             "DownLoadInit"
#define DOWNLOADEXECUTE          "DownLoadExecute"
#define DOWNLOADCLOSE            "DownLoadClose"
#define DOWNLOADSETSTATUS        "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS          "DownLoadProcess"
#define DOWNLOADCANCEL           "DownLoadCancel"
#define SIGNUPKEY                TEXT("SOFTWARE\\MICROSOFT\\ISIGNUP")
#define GATHERINFOVALUENAME      TEXT("UserInfo")
#define RASENTRYVALUENAME        TEXT("RasEntryName")
#define IEAPPPATHKEY             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define MAX_RASENTRYNAME         126
#define AUTODIAL_LIBRARY         TEXT("icwdial.dll")
#define AUTODIAL_INIT            "AutoDialInit"
#define RASAPI_LIBRARY           TEXT("RASAPI32.DLL")
#define RASDELETEAPI             "RasDeleteEntryA"
#define RASAPI_RASGETENTRY       "RasGetEntryPropertiesA"
#define RASAPI_RASSETENTRY       "RasSetEntryPropertiesA"
#define ERROR_USERCANCEL         32767 // quit message value
#define ERROR_USERBACK           32766 // back message value
#define ERROR_USERNEXT           32765 // back message value
#define ERROR_DOWNLOADDIDNT      32764 // download failed
#define MAX_PROMO                64
#define MAX_OEMNAME              64
#define MAX_AREACODE             RAS_MaxAreaCode
#define MAX_EXCHANGE             8
#define MAX_VERSION_LEN          40
#define CMD_CONNECTOID           TEXT("/CONNECTOID:")
#define CMD_INS                  TEXT("/INS:")
#define CMD_REBOOT               TEXT("/REBOOT")
#define LEN_CONNECTOID           sizeof(CMD_CONNECTOID)
#define LEN_INS                  sizeof(CMD_INS)
#define INSFILE_APPNAME          TEXT("ClientSetup")
#define INFFILE_SETUP_CLIENT_URL TEXT("Client_Setup_Url")
#define INFFILE_SETUP_NEW_CALL   TEXT("Client_Setup_New_Call")
#define INFFILE_DONE_MESSAGE     TEXT("Done_Message")
#define INFFILE_EXPLORE_CMD      TEXT("Explore_Command")
#define INFFILE_ENTRYSECTION     TEXT("Entry")
#define INFFILE_ENTRY_NAME       TEXT("Entry_Name")
#define INFFILE_USER_SECTION     TEXT("User")
#define INFFILE_PASSWORD         TEXT("Password")
#define INFFILE_ISPSUPP          TEXT("ISP_Support_Message")
#define NULLSZ                   TEXT("")
#define TIMEOUT                  15000  // 15 seconds
#define WM_DIENOW                WM_USER+1
#define WM_DUMMY                 WM_USER+2
#define WM_DOWNLOAD_DONE         WM_USER+2
#define irgMaxSzs                5
#define MB_MYERROR               (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)
#define MAX_RETIES               3
#define CALLHOME_SIZE            500

typedef DWORD   (WINAPI*   PFNRASDELETEENTRY)        (LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD   (WINAPI*   PFNRASGETENTRYPROPERTIES) (LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD   (WINAPI*   PFNRASSETENTRYPROPERTIES) (LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD   (CALLBACK* PFNRASENUMDEVICES)        (LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef HRESULT (CALLBACK* PFNAUTODIALINIT)          (LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);
typedef HRESULT (CALLBACK* PFNDOWNLOADINIT)          (LPTSTR pszURL, DWORD_PTR FAR *pdwDownLoad, HWND hWndMain);
typedef HRESULT (CALLBACK* PFNDOWNLOADEXECUTE)       (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADCLOSE)         (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADSETSTATUS)     (DWORD_PTR dwDownLoad, INTERNET_STATUS_CALLBACK lpfn);
typedef HRESULT (CALLBACK* PFNDOWNLOADPROCESS)       (DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK* PFNDOWNLOADCANCEL)        (DWORD_PTR dwDownLoad);
typedef HRESULT (WINAPI*   PFNINETGETAUTODIAL)       (LPBOOL, LPTSTR, DWORD);
typedef BOOL    (WINAPI*   LCLSETENTRYSCRIPTPATCH)   (LPTSTR, LPTSTR);

typedef struct tagGATHEREDINFO
{
    LCID    m_lcid;
    HWND    m_hwnd;
    DWORD   m_dwOS;
    DWORD   m_dwMajorVersion;
    DWORD   m_dwMinorVersion;
    DWORD   m_dwCountry;
    WORD    m_wState;
    WORD    m_wArchitecture;
    TCHAR   m_szAreaCode  [MAX_AREACODE+1];
    TCHAR   m_szExchange  [MAX_EXCHANGE+1];
    TCHAR   m_szPromo     [MAX_PROMO];
    TCHAR   m_szSUVersion [MAX_VERSION_LEN];
    TCHAR   m_szISPFile   [MAX_PATH+1];
    TCHAR   m_szAppDir    [MAX_PATH+1];
    BYTE    m_fType;
    BYTE    m_bMask;

    LPLINECOUNTRYLIST        m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;

} GATHEREDINFO, *PGATHEREDINFO;

typedef struct _ShowProgressParams
{
    HANDLE    hProgressReadyEvent;
    HWND      hwnd;
    HWND      hwndParent;
    HINSTANCE hinst;
    DWORD     dwThreadID;

} ShowProgressParams, *PShowProgressParams;

typedef struct tagDialDlg
{
    HRASCONN      m_hrasconn;
    LPTSTR         m_pszConnectoid;
    HANDLE        m_hThread;
    DWORD         m_dwThreadID;
    DWORD_PTR     m_dwDownLoad;
    DWORD         m_dwAPIVersion;
    HWND          m_hwnd;
    PGATHEREDINFO m_pGI;
    LPTSTR         m_pszDisplayable;
    LPTSTR         m_szUrl;
    HLINEAPP      m_hLineApp;
    HINSTANCE     g_hInst;
    TCHAR         m_szPhoneNumber[256];
    BOOL          m_bDialAsIs;
    UINT          m_uiRetry;

} DIALDLG, *PDIALDLG;

typedef struct tagDialErr
{
    LPTSTR         m_pszConnectoid;
    HRESULT       m_hrError;
    PGATHEREDINFO m_pGI;
    HWND          m_hwnd;
    HLINEAPP      m_hLineApp;
    DWORD         m_dwAPIVersion;
    TCHAR         m_szPhoneNumber[256];
    LPTSTR         m_pszDisplayable;
    HINSTANCE     m_hInst;
    LPRASDEVINFO  m_lprasdevinfo;

} DIALERR, *PDIALERR;

typedef struct tagDEVICE
{
    DWORD      dwTapiDev;
    RASDEVINFO RasDevInfo;

} MYDEVICE, *PMYDEVICE;

extern "C" INT_PTR CALLBACK FAR PASCAL DialDlgProc             (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern "C" INT_PTR CALLBACK FAR PASCAL DialErrDlgProc          (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern "C" INT_PTR CALLBACK FAR PASCAL DialReallyCancelDlgProc (HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
extern HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                LPTSTR lpszPhonebookEntry, 
                                LPRASENTRY *lplpRasEntryBuff,
                                LPDWORD lpdwRasEntryBuffSize,
                                LPRASDEVINFO *lplpRasDevInfoBuff,
                                LPDWORD lpdwRasDevInfoBuffSize);

extern PMYDEVICE          g_pdevice;
extern TCHAR              pszINSFileName[MAX_PATH+2];
extern TCHAR              pszFinalConnectoid[MAX_PATH+1];
extern HRASCONN           hrasconn;
extern TCHAR              pszSetupClientURL[1024];
extern UINT               uiSetupClientNewPhoneCall;
extern ShowProgressParams SPParams;
extern RECT               rect;
extern HBRUSH             hbBackBrush;
extern BOOL               fUserCanceled;
extern TCHAR              szBuff256[256];
extern HANDLE             hThread;
extern DWORD              dwThreadID;
extern DWORD_PTR          dwDownLoad;
extern DWORD              g_fNeedReboot;
extern BOOL               g_bProgressBarVisible;

HRESULT ReleaseBold                  (HWND hwnd);
HRESULT WINAPI StatusMessageCallback (DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
HRESULT DeleteFileKindaLikeThisOne   (LPTSTR lpszFileName);
HRESULT DialDlg                      ();
HRESULT MakeBold                     (HWND hwnd, BOOL fSize, LONG lfWeight);
HRESULT ShowDialReallyCancelDialog   (HINSTANCE hInst, HWND hwnd, LPTSTR pszHomePhone);
HRESULT FillModems                   ();
HRESULT DialErrGetDisplayableNumber  ();
HRESULT GetDisplayableNumberDialDlg  ();
HRESULT ShowDialErrDialog            (PGATHEREDINFO pGI, HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd);
HRESULT ShowDialingDialog            (LPTSTR pszConnectoid, PGATHEREDINFO pGI, LPTSTR szUrl, HINSTANCE hInst, HWND hwnd, LPTSTR szINSFile);
LPTSTR   StrDup                       (LPTSTR *ppszDest,LPCTSTR pszSource);
LPTSTR   GetSz                        (WORD wszID);
WORD    RasErrorToIDS                (DWORD dwErr);
BOOL    FShouldRetry                 (HRESULT hrErr);
BOOL    WaitForConnectionTermination (HRASCONN hConn);
BOOL    FileExists                   (TCHAR *pszINSFileName);
void    MinimizeRNAWindow            (LPTSTR pszConnectoidName, HINSTANCE hInst);
void    CALLBACK LineCallback        (DWORD hDevice,
                                      DWORD dwMessage,
                                      DWORD dwInstance,
                                      DWORD dwParam1,
                                      DWORD dwParam2,
                                      DWORD dwParam3);
DWORD WINAPI ThreadInit();


inline BOOL IsNT(void)
{
    OSVERSIONINFO  OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\dialerr.cpp ===
/*-----------------------------------------------------------------------------
	dialerr.cpp

	This file implements the Could Not Connect dialog

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		8/19/96	ValdonB	Added ability to edit phone number
						Fixed some memory leaks
	
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#if defined(WIN16)
#include <string.h>
#include <ietapi.h>
#endif

TCHAR szBuf256[256];
TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

#ifdef WIN16
	#define g_iMyMaxPhone	36
#else
	int g_iMyMaxPhone = 0;
	#define MAXPHONE_NT		80
	#define MAXPHONE_95		36
#endif


PDIALERR g_pcDialErr = NULL;

//////////////////////////////////////////////////////////////////////////
// Keyboard hook
static HHOOK    hKeyHook = NULL;        // our key hook
static HOOKPROC hpKey = NULL;           // hook proc

//+---------------------------------------------------------------------------
//
//	Function:	ProcessDBCS
//
//	Synopsis:	Converts control to use DBCS compatible font
//				Use this at the beginning of the dialog procedure
//	
//				Note that this is required due to a bug in Win95-J that prevents
//				it from properly mapping MS Shell Dlg.  This hack is not needed
//				under winNT.
//
//	Arguments:	hwnd - Window handle of the dialog
//				cltID - ID of the control you want changed.
//
//	Returns:	ERROR_SUCCESS
// 
//	History:	4/31/97 a-frankh	Created
//				5/13/97	jmazner		Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}



HRESULT ShowDialErrDialog(PGATHEREDINFO pGI, HRESULT hrErr, 
							LPTSTR pszConnectoid, HINSTANCE hInst, 
							HWND hwnd)
{
	int iRC;
//	CDialErrDlg *pcDED = NULL;

	g_pcDialErr = (PDIALERR)GlobalAlloc(GPTR,sizeof(DIALERR));
	if (!g_pcDialErr)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	
	g_pcDialErr->m_pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,RAS_MaxEntryName+1);
	if (!g_pcDialErr->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	lstrcpy(g_pcDialErr->m_pszConnectoid,pszConnectoid);
	g_pcDialErr->m_pGI = pGI;
	g_pcDialErr->m_hrError = hrErr;
	g_pcDialErr->m_hInst = hInst;

#if defined(WIN16)		
	DLGPROC dlgprc;
	dlgprc = (DLGPROC) MakeProcInstance((FARPROC)DialErrDlgProc, 
											g_pcDialErr->m_hInst);
	iRC = DialogBoxParam(g_pcDialErr->m_hInst,
							MAKEINTRESOURCE(IDD_DIALERR),
							hwnd, dlgprc, (LPARAM)g_pcDialErr);
	FreeProcInstance((FARPROC) dlgprc);
#else
	iRC = (HRESULT)DialogBoxParam(g_pcDialErr->m_hInst,MAKEINTRESOURCE(IDD_DIALERR),
							hwnd,DialErrDlgProc,
							(LPARAM)g_pcDialErr);
#endif

ShowDialErrDialogExit:
	if (g_pcDialErr->m_pszConnectoid) GlobalFree(g_pcDialErr->m_pszConnectoid);
	if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
	if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	g_pcDialErr->m_lprasdevinfo = NULL;
	if (g_pcDialErr) GlobalFree(g_pcDialErr);
	g_pcDialErr = NULL;
	return iRC;
}

//+----------------------------------------------------------------------------
//
//	Function	LclSetEntryScriptPatch
//
//	Synopsis	Softlink to RasSetEntryPropertiesScriptPatch
//
//	Arguments	see RasSetEntryPropertiesScriptPatch
//
//	Returns		see RasSetEntryPropertiesScriptPatch
//
//	Histroy		10/3/96	ChrisK Created
//
//-----------------------------------------------------------------------------

BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
	HINSTANCE hinst = NULL;
	LCLSETENTRYSCRIPTPATCH fp = NULL;
	BOOL bRC = FALSE;

	hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
	if (hinst)
	{
		fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
		if (fp)
			bRC = (fp)(lpszScript,lpszEntry);
		FreeLibrary(hinst);
		hinst = NULL;
		fp = NULL;
	}
	return bRC;
}

// ############################################################################
// HelpKybdHookProc
//
// Keyboard hook proc - check for F1, and if detected, fake a Help button
// hit to the main dialog.
//
// Paramters:
//		iCode		Windows message code
//		wParam		Windows wParam (contains virtual key code)
//		lParam		Windows lParam
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
#if defined(WIN16)
LRESULT CALLBACK _export HelpKybdHookProc
#else
LRESULT WINAPI HelpKybdHookProc
#endif
(
    int iCode,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT    lRet = 0;

	Assert(g_pcDialErr->m_hwnd);
    if ((iCode != HC_NOREMOVE && iCode >= 0) &&
		(GetActiveWindow() == g_pcDialErr->m_hwnd))
    {
        // HC_NOREMOVE indicates that message is being
        // retrieved using PM_NOREMOVE from peek message,
        // if iCode < 0, then we should not process... dont
        // know why, but sdk says so.
        if (wParam == VK_F1 && !(lParam & 0x80000000L))
        {
            // bit 32 == 1 if key is being release, else 0 if
            // key is being pressed
            PostMessage(g_pcDialErr->m_hwnd, WM_COMMAND, (WPARAM)IDC_CMDHELP, 0);
        }
    }
    if (hKeyHook)
    {
        lRet = CallNextHookEx(hKeyHook, iCode, wParam, lParam);
    }
    return(lRet);
}

// ############################################################################
// HelpInit
//
// Install a windows hook proc to launch help on F1
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
static void HelpInit()
{
    // now install the hook for the keyboard filter
    hpKey = (HOOKPROC)MakeProcInstance((FARPROC)HelpKybdHookProc,
                                        g_pcDialErr->m_hInst);
    if (hpKey)
    {
        hKeyHook = SetWindowsHookEx(WH_KEYBOARD, hpKey, g_pcDialErr->m_hInst,
#if defined(WIN16)
									GetCurrentTask());
#else
									GetCurrentThreadId());
#endif
    }
}


// ############################################################################
// HelpShutdown
//
// Shutdown the keyboard hook
//
// History:
//		8/26/96	ValdonB	Adapted from IEDIAL.C
//
// ############################################################################
static void HelpShutdown()
{
    // remove the hook
    if (hKeyHook)
    {
        UnhookWindowsHookEx(hKeyHook);
    }

    // dump the thunk
    if (hpKey)
    {
        FreeProcInstance((FARPROC)hpKey);
    }
}


extern "C" INT_PTR CALLBACK FAR PASCAL DialErrDlgProc(HWND hwnd, 
													UINT uMsg, 
													WPARAM wparam, 
													LPARAM lparam)
{
	BOOL bRes = TRUE;
	HRESULT hr;
	//LPLINEEXTENSIONID lpExtensionID;
#if !defined(WIN16)
	DWORD dwNumDev;
#endif
	//RNAAPI *pcRNA = NULL;
	WORD wIDS;
	LRESULT idx;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;
	LPTSTR lpszDialNumber = NULL;
	static BOOL bCheckDisplayable = FALSE;
    static BOOL bInitComplete = FALSE; // if we initialize  the dialog - MKarki
    static BOOL bDlgPropEnabled = TRUE;   //this flags holds state of Dialing Properties PushButton MKarki - (5/3/97/) Fix for Bug#3393
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif

	RNAAPI *pRnaapi = NULL;

	static BOOL fUserEditedNumber = FALSE;

	switch(uMsg)
	{
	case WM_INITDIALOG:
		g_pcDialErr->m_hwnd = hwnd;

#if defined(WIN16)
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif

		// Set limit on phone number length
		// Note: this should really be RAS_MaxPhoneNumber (128), but RAS is choking on 
		// anything longer than 100 bytes, so we'll have to limit it to that.
		//
		// 6/3/97 jmazner Olympus #4851
		// RAS has different limits on w95 and NT
		//
#ifndef WIN16
		if( IsNT() )
		{
			g_iMyMaxPhone = MAXPHONE_NT;
		}
		else
		{
			g_iMyMaxPhone = MAXPHONE_95;
		}
#endif
		AssertSz( (sizeof(g_pcDialErr->m_szPhoneNumber) >= g_iMyMaxPhone), "Maximum phone number is greater than m_szPhoneNumber" );

		SendDlgItemMessage(hwnd,IDC_TEXTNUMBER,EM_SETLIMITTEXT,g_iMyMaxPhone,0);

		// Show the phone number
		//
		hr = DialErrGetDisplayableNumber();
		if (hr != ERROR_SUCCESS)
		{
			bCheckDisplayable = FALSE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_szPhoneNumber);
		} else {
			bCheckDisplayable = TRUE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_pszDisplayable);
		}

		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Fill in error message
		//
		wIDS = (WORD)RasErrorToIDS(g_pcDialErr->m_hrError);
		AssertSz(wIDS != -1,"RasErrorToIDS got an error message it did not understand");

		if (wIDS != -1 && wIDS !=0)
			SetDlgItemText(hwnd,IDC_LBLERRMSG,GetSz(wIDS));

		ProcessDBCS(hwnd,IDC_CMBMODEMS);
		ProcessDBCS(hwnd,IDC_TEXTNUMBER);

		FillModems();
		
		// Set the focus to the Modems selection list
		//
	    SetFocus(GetDlgItem(hwnd,IDC_CMBMODEMS));

		// hook the keyboard for F1 help
		HelpInit();

		bRes = FALSE;

        //
        //  we should disable the Dialing Properites PushButton
        //  if we have changed the phone number once
        //  MKarki (5/3/97) - Fix for Bug#3393
        //
        if (FALSE == bDlgPropEnabled)
        {
            EnableWindow (
                GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                FALSE
                );
        }

        //
        // This shows the INIT for the error dialog is complete
        // and we can start processing changes to Ph No. TEXTBOX
        // MKarki (4/24/97) - Fix for Bug#3511
        //
        bInitComplete = TRUE;

		break;

#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		// Shutdown the keyboard hook
		HelpShutdown();

		bRes = FALSE;
		break;

	case WM_CLOSE:
		//if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
		//	MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
		//	EndDialog(hwnd,ERROR_USERCANCEL);
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
	
#if !defined(WIN16)
	case WM_HELP:
		//
		// Chrisk Olympus 5130 5/27/97
		// Added support for F1 Help Key
		//
			WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)ICW_TRB);
#endif

	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
        //
        // We now processes changes to ph no. EDIT BOX
        // If there is anychange in the phone number we
        // disable to Dialing Properties Push Button
        // MKarki (3/22/97) - Fix for Bug #3511
        //
        case IDC_TEXTNUMBER:
			TCHAR lpszTempNumber[RAS_MaxPhoneNumber +1];

            if ((HIWORD (wparam) == EN_CHANGE) && (bInitComplete == TRUE))
            {
                if ((GetDlgItemText (
                            hwnd,
                            IDC_TEXTNUMBER,
                            lpszTempNumber,
                            RAS_MaxPhoneNumber
                            ))  && 
            		(0 != lstrcmp(
                             lpszTempNumber, 
                              bCheckDisplayable ? g_pcDialErr->m_pszDisplayable :g_pcDialErr->m_szPhoneNumber)))
			    {
                    //
                    // number has been modified by the user
                    // hide the Dialing Properties Push Button  
                    //
                    EnableWindow (
                            GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                            FALSE
                            );
                    //
                    // save the state of the Dialing Properties PushButton
                    // MKarki (5/3/97) -  Fix for Bug#3393
                    //
                    bDlgPropEnabled = FALSE;
					
					//
					// 7/17/97 jmazner Olympus #8234
					//
					fUserEditedNumber = TRUE;
                }
            }
            break;

		case IDC_CMBMODEMS:
			if (HIWORD(wparam) == CBN_SELCHANGE)
			{

				idx = SendDlgItemMessage(hwnd,IDC_CMBMODEMS,CB_GETCURSEL,0,0);
				//
				// ChrisK Olympus 245 5/25/97
				// Get index of modem
				//
				idx = SendDlgItemMessage(hwnd,IDC_CMBMODEMS,CB_GETITEMDATA,idx,0);
				if (idx == CB_ERR) break;

				// Get the connectoid
				//

/***** this code is made obsolete by the call to MyRasGetEntryProperties below
#if defined(WIN16)
				//
				// Allocate extra 256 bytes to workaround memory overrun bug in RAS
				//
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
				if (!lpRasEntry)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
					break;
				}

				lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
				if (!lpRasDevInfo)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
					break;
				}
				dwRasEntrySize = sizeof(RASENTRY);
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				lpRasEntry->dwSize = dwRasEntrySize;
				lpRasDevInfo->dwSize = dwRasDevInfoSize;
*******/
				
/*				hRasDll = LoadLibrary(RASAPI_LIBRARY);
				if (!hRasDll)
				{
					hr = GetLastError();
					break;
				}
				fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
				if (!fp)
				{
					FreeLibrary(hRasDll);
					hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
					if (!hRasDll)
					{
						hr = GetLastError();
						break;
					}
					fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
					if (!fp)
					{
						hr = GetLastError();
						break;
					}
				}
*/

/****** this call has been replaced with MyRasGetEntryProperties
				hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
#if defined(WIN16)
											(LPBYTE)
#endif
											lpRasEntry,
											&dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											&dwRasDevInfoSize);
****/

				// these two pointers should not have memory allocated to them
				// See MyRasGetEntryProperties function comment for details.
				if( lpRasEntry )
				{
					GlobalFree( lpRasEntry );
					lpRasEntry = NULL;
				}
				if( lpRasDevInfo )
				{
					GlobalFree( lpRasDevInfo );
					lpRasDevInfo = NULL;
				}
				hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

				if (hr != ERROR_SUCCESS)
				{
					break;
				}

				
				//
				// Replace the device with a new one
				//
				lstrcpyn(lpRasEntry->szDeviceType,g_pcDialErr->m_lprasdevinfo[idx].szDeviceType,RAS_MaxDeviceType+1);
				lstrcpyn(lpRasEntry->szDeviceName,g_pcDialErr->m_lprasdevinfo[idx].szDeviceName,RAS_MaxDeviceName+1);
				if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
				lpRasDevInfo = NULL;
				// DANGER!!  Don't call GlobalFree on lpRasDevInfo after we set it below!!!!!!! --jmazner
				lpRasDevInfo = &g_pcDialErr->m_lprasdevinfo[idx];
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				//hr = pcRNA->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,(LPBYTE)lpRasEntry,dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
				/*fp = GetProcAddress(hRasDll,"RasSetEntryPropertiesA");
				if (!fp)
				{
					hr = GetLastError();
					break;
				}*/

				// softlink to RasSetEntryProperties for simultaneous Win95/NT compatability
				if( !pRnaapi )
				{
					pRnaapi = new RNAAPI;
					if( !pRnaapi )
					{
						hr = ERROR_NOT_ENOUGH_MEMORY;
						break;
					}
				}
				hr = pRnaapi->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
											(LPBYTE)lpRasEntry,
											dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											dwRasDevInfoSize);
#if !defined(WIN16)
				LclSetEntryScriptPatch(lpRasEntry->szScript,g_pcDialErr->m_pszConnectoid);
#endif // !win16

				// Now that we're done with lpRasDevInfo, set it to NULL, but DON'T free it,
				// because it points to memory owned by g_pcDialErr->m_lprasdevinfo
				lpRasDevInfo = NULL;

				if (hr != ERROR_SUCCESS)
				{
					MessageBox(hwnd,GetSz(IDS_CANTSAVEKEY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				/*FreeLibrary(hRasDll);
				hRasDll = NULL;
				fp = NULL;*/

			}
			break;
		case IDC_CMDHELP:
#if defined(WIN16)
			WinHelp(hwnd,"connect.hlp",HELP_CONTEXT,(DWORD)1001);
#else
			WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)1001);
#endif
			break;

		case IDC_CMDNEXT:
			// NOTE: This button is actually labeled "Redial"
			//
			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, (RAS_MaxPhoneNumber + 1) * sizeof(TCHAR));
			if (NULL == lpszDialNumber)
			{
				MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
				break;
			}
			// If the user has altered the phone number, make sure it can be used
			//
			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, RAS_MaxPhoneNumber)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? g_pcDialErr->m_pszDisplayable : g_pcDialErr->m_szPhoneNumber)))
			{
				// Check that the phone number only contains valid characters
				//
				LPTSTR lpNum, lpValid;

				for (lpNum = lpszDialNumber;*lpNum;lpNum++)
				{
					for(lpValid = szValidPhoneCharacters;*lpValid;lpValid++)
					{
						if (*lpNum == *lpValid)
							break; // p2 for loop
					}
					if (!*lpValid) break; // p for loop
				}

				if (*lpNum)
				{
					MessageBox(hwnd,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
					//
					// Set the focus back to the phone number field
					//
					SetFocus(GetDlgItem(hwnd,IDC_TEXTNUMBER));
					break; // switch statement
				}

/**** replaced by call to MyRasGetEntryProperties below
#if defined(WIN16)
				//
				// Allocate extra 256 bytes to workaround memory overrun bug in RAS
				//
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
				lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
				if (!lpRasEntry)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
				if (!lpRasDevInfo)
				{
					MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}

				dwRasEntrySize = sizeof(RASENTRY);
				dwRasDevInfoSize = sizeof(RASDEVINFO);

				lpRasEntry->dwSize = dwRasEntrySize;
				lpRasDevInfo->dwSize = dwRasDevInfoSize;

				hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
#if defined(WIN16)
											(LPBYTE)
#endif
											lpRasEntry,
											&dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											&dwRasDevInfoSize);
****/

				// these two pointers should not have memory allocated to them
				// See MyRasGetEntryProperties function comment for details.
				if( lpRasEntry )
				{
					GlobalFree( lpRasEntry );
					lpRasEntry = NULL;
				}
				if( lpRasDevInfo )
				{
					GlobalFree( lpRasDevInfo );
					lpRasDevInfo = NULL;
				}

				dwRasEntrySize = dwRasDevInfoSize = 0;

				hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

				
				if (hr != ERROR_SUCCESS)
				{
					break;
				}

				// Replace the phone number with the new one
				//
				lstrcpy(lpRasEntry->szLocalPhoneNumber, lpszDialNumber);
				lpRasEntry->dwCountryID = 0;
				lpRasEntry->dwCountryCode = 0;
				lpRasEntry->szAreaCode[0] = '\0';

				// Set to dial as is
				//
				lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

				// softlink to RasSetEntryProperties for simultaneous Win95/NT compatability
				if( !pRnaapi )
				{
					pRnaapi = new RNAAPI;
					if( !pRnaapi )
					{
						hr = ERROR_NOT_ENOUGH_MEMORY;
						break;
					}
				}
				hr = pRnaapi->RasSetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid,
											(LPBYTE)lpRasEntry,
											dwRasEntrySize,
											(LPBYTE)lpRasDevInfo,
											dwRasDevInfoSize);
#if !defined(WIN16)
				LclSetEntryScriptPatch(lpRasEntry->szScript,g_pcDialErr->m_pszConnectoid);
#endif // !win16
				if (hr != ERROR_SUCCESS)
				{
					MessageBox(hwnd,GetSz(IDS_CANTSAVEKEY),GetSz(IDS_TITLE),MB_MYERROR);
					break;
				}
			}

			EndDialog(hwnd,ERROR_USERNEXT);
			break;

		case IDC_CMDCANCEL:
			//if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
			//	MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
			//	EndDialog(hwnd,ERROR_USERCANCEL);
			EndDialog(hwnd,ERROR_USERCANCEL);
			break;


		case IDC_CMDDIALPROP:
			// 12/4/96	jmazner	Normandy #10294
			//ShowWindow(hwnd,SW_HIDE);
			EnableWindow(hwnd, FALSE);
#if defined(WIN16)
			hr = IETapiTranslateDialog(hwnd, 
										g_pcDialErr->m_szPhoneNumber, 
										NULL);
#else
			// 10/24/96	jmazner	Normandy #10185/7019
			if (g_pdevice->dwTapiDev == 0xFFFFFFFF) g_pdevice->dwTapiDev = 0;

			hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,
									LineCallback,NULL,&dwNumDev);
			if (hr == ERROR_SUCCESS)
			{
				hr = lineTranslateDialog(g_pcDialErr->m_hLineApp,
											g_pdevice->dwTapiDev,
											g_pcDialErr->m_dwAPIVersion,
											hwnd,g_pcDialErr->m_szPhoneNumber);
#endif

				hr = DialErrGetDisplayableNumber();
				if (hr != ERROR_SUCCESS)
				{
					bCheckDisplayable = FALSE;
					SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_szPhoneNumber);
				} else {
					bCheckDisplayable = TRUE;
					SetDlgItemText(hwnd,IDC_TEXTNUMBER,g_pcDialErr->m_pszDisplayable);
				}
#if !defined(WIN16)
				lineShutdown(g_pcDialErr->m_hLineApp);
				g_pcDialErr->m_hLineApp = NULL;
			}
#endif
			// 12/4/96	jmazner	Normandy #10294
			//ShowWindow(hwnd,SW_SHOW);
			EnableWindow(hwnd, TRUE);

			//
			// 6/6/97 jmazner Olympus #4759
			//
			SetFocus(GetDlgItem(hwnd,IDC_CMDNEXT));
			
			break;
		}
		break;


	default:
		bRes = FALSE;
		break;
	}

	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	if (lpszDialNumber) GlobalFree(lpszDialNumber);
	if (pRnaapi) delete pRnaapi;

	return bRes;
}




HRESULT FillModems()
{
	//RNAAPI *pcRNA = NULL;
	HRESULT hr = ERROR_SUCCESS;
	//LPRASDEVINFO lprasdevinfo;
	DWORD dwSize;
	DWORD dwNumDev;
	DWORD idx;
    DWORD dwTempNumEntries;
	//HINSTANCE hRasDll=NULL;
	//FARPROC fp=NULL;

	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LRESULT lLast = 0;

	RNAAPI *pRnaapi = NULL;



	// Get the connectoid
	//

/*******  This code has been obsoleted by the call to MyRasGetEntryProperties below
#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		MessageBox(g_pcDialErr->m_hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		goto FillModemExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		MessageBox(g_pcDialErr->m_hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		goto FillModemExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;
*********/

/*	fp = NULL;
	hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (hRasDll)
	{
		fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
		if (!fp)
		{
			FreeLibrary(hRasDll);
			hRasDll = LoadLibrary(RNAPH_LIBRARY);
			if (hRasDll)
			{
				fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
			}
		}
	}

	if (!fp) 
	{
		hr = GetLastError();
		goto FillModemExit;
	}
*/

/******  This call has been replaced by MyRasGetEntryProperties below

  hr = RasGetEntryProperties(NULL,g_pcDialErr->m_pszConnectoid, 
#if defined(WIN16)
								(LPBYTE)
#endif
								lpRasEntry,
								&dwRasEntrySize,(LPBYTE)lpRasDevInfo,
								&dwRasDevInfoSize);
********/

	// these two pointers should not have memory allocated to them
	// See MyRasGetEntryProperties function comment for details.
	if( lpRasEntry )
	{
		GlobalFree( lpRasEntry );
		lpRasEntry = NULL;
	}
	if( lpRasDevInfo )
	{
		GlobalFree( lpRasDevInfo );
		lpRasDevInfo = NULL;
	}
	hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if( ERROR_SUCCESS != hr )
	{
		goto FillModemExit;
	}

	/*FreeLibrary(hRasDll);
	hRasDll = NULL;
	fp = NULL; */


	// Get devices from RAS/RNA
	//

	if (!g_pcDialErr->m_lprasdevinfo) 
		g_pcDialErr->m_lprasdevinfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!g_pcDialErr->m_lprasdevinfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	g_pcDialErr->m_lprasdevinfo->dwSize = sizeof(RASDEVINFO);
	dwSize = sizeof(RASDEVINFO);
	dwNumDev = 0;

	/*hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto FillModemExit;
	}
	fp =GetProcAddress(hRasDll,"RasEnumDevicesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto FillModemExit;
		}
		fp = GetProcAddress(hRasDll,"RasEnumDevicesA");
		if (!fp)
		{
			hr = GetLastError();
			goto FillModemExit;
		}
	}*/

	// soft link to RasEnumDevices to allow for simultaneous Win95/NT compatability
	pRnaapi = new RNAAPI;
	if( !pRnaapi )
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	hr = pRnaapi->RasEnumDevices(g_pcDialErr->m_lprasdevinfo,&dwSize,&dwNumDev);
	if (hr == ERROR_BUFFER_TOO_SMALL)
	{
		GlobalFree(g_pcDialErr->m_lprasdevinfo);
		g_pcDialErr->m_lprasdevinfo = (LPRASDEVINFO)GlobalAlloc(GPTR, (size_t)dwSize);
		if (!g_pcDialErr->m_lprasdevinfo)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto FillModemExit;
		}
		g_pcDialErr->m_lprasdevinfo->dwSize = sizeof(RASDEVINFO);
		hr = pRnaapi->RasEnumDevices(g_pcDialErr->m_lprasdevinfo,&dwSize,&dwNumDev);
	}

	/*FreeLibrary(hRasDll);
	hRasDll = NULL;
	fp = NULL;*/

	if (hr != ERROR_SUCCESS)
		goto FillModemExit;

	// Fill in combo box
	//
    dwTempNumEntries = dwNumDev;

	if (dwNumDev != 0)
	{
		for (idx=0;idx<dwTempNumEntries;idx++)
		{
			//
			// ChrisK Olympus 4560 do not add VPN's to list of modems
            // Vyung only add isdn and modem type devices
			//
			if ((0 == lstrcmpi(TEXT("MODEM"),g_pcDialErr->m_lprasdevinfo[idx].szDeviceType)) &&
                (0 == lstrcmpi(TEXT("ISDN"),g_pcDialErr->m_lprasdevinfo[idx].szDeviceType)))
			{
				lLast = SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_ADDSTRING,0,(LPARAM)&g_pcDialErr->m_lprasdevinfo[idx].szDeviceName[0]);
				//
				// ChrisK Olympus 245 5/25/97
				// Save index of modem
				//
				SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETITEMDATA,(WPARAM)lLast,(LPARAM)idx);
				if (lstrcmp(g_pcDialErr->m_lprasdevinfo[idx].szDeviceName,lpRasEntry->szDeviceName) == 0)
					SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,(WPARAM)lLast,0);
			}
            else
            {
                dwNumDev--;
            }
		}
	}

	if (dwNumDev == 1)
		SendDlgItemMessage(g_pcDialErr->m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,0,0);

	// UNDONE: select default device

FillModemExit:
	//if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	//if (pcRNA) delete pcRNA;
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	if( pRnaapi ) delete pRnaapi;

	return hr;
}


HRESULT DialErrGetDisplayableNumber()
{
#if !defined(WIN16)
	DWORD dwNumDev;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
#endif
	
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

#if !defined(WIN16)
	// Normandy 13024 - ChrisK 12/31/96
	// In all cases we have to get the TAPI version number, because the dialing properies
	// button will not work on NT if the version is 0.

	//
	//  Initialize TAPIness
	//
	dwNumDev = 0;
 	hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
		g_pdevice->dwTapiDev = 0;

	// Get TAPI version number
	lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	do {
		hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
			&g_pcDialErr->m_dwAPIVersion, lpExtensionID);
	} while (hr && g_pdevice->dwTapiDev++ < dwNumDev-1);

	// delete ExtenstionID since we don't use it
	if (lpExtensionID) GlobalFree(lpExtensionID);
	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;
#endif // !WIN16

	//RNAAPI * pcRNA;

	// Get phone number from connectoid
	//

/*  ---replaced by call to MyRasGetEntryProperties below 
#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);
*/


/*  hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}
*/


	// lpRasEntry and lpRasDevInfo should not have memory allocated to them, and should be NULL
	// See MyRasGetEntryProperties function comment for details.
	hr = MyRasGetEntryProperties( NULL,
								  g_pcDialErr->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	} 

	//FreeLibrary(hRasDll);

	//
	// If this is a dial as is number, just get it from the structure
	//
	if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
	{
		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, lstrlen(lpRasEntry->szLocalPhoneNumber)+1);
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(g_pcDialErr->m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(g_pcDialErr->m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
		else
			wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);


#if defined(WIN16)
		char szBuffer[1024];
		LONG lRetCode;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpOutput1 = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpOutput1->dwTotalSize = sizeof(szBuffer);

		lRetCode = IETapiTranslateAddress(NULL, g_pcDialErr->m_szPhoneNumber,
											0L, 0L, lpOutput1);
		
		if (0 != lRetCode)
		{
			//
			// TODO: Set the correct error code
			//
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, 
														((size_t)lpOutput1->dwDisplayableStringSize+1));
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpy(g_pcDialErr->m_pszDisplayable, 
					&szBuffer[lpOutput1->dwDisplayableStringOffset]);


#else //WIN16
	
/* Normandy 13024 this code was moved up
		//
		//  Initialize TAPIness
		//
		dwNumDev = 0;
 		hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		//Normandy #7019  jmazner
		//all devices should share the same dialing properties
		//(at least, this is what icwdial\dialerr.cpp appears to assume, and it works right ;)
//		if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
//		{
//			if (dwNumDev == 1)
//				g_pdevice->dwTapiDev = 0;
//			//else
//			// UNDONE: Tell the user to select a modem
//			// DO NOT EXIT UNTIL THEY PICK ONE
//		}


		if (g_pdevice->dwTapiDev == 0xFFFFFFFF) g_pdevice->dwTapiDev = 0;

		lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
		if (!lpExtensionID)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
			&g_pcDialErr->m_dwAPIVersion, lpExtensionID);

		// ditch it since we don't use it
		//
		if (lpExtensionID) GlobalFree(lpExtensionID);
		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;
Normandy 13024 (see comments above) */

		// Format the phone number
		//

		lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
		if (!lpOutput1)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

		
		// Turn the canonical form into the "displayable" form
		//

		hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcDialErr->m_dwAPIVersion,
									g_pcDialErr->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t) lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
										g_pcDialErr->m_dwAPIVersion,
										g_pcDialErr->m_szPhoneNumber,0,
										LINETRANSLATEOPTION_CANCELCALLWAITING,
										lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		if (g_pcDialErr->m_pszDisplayable) GlobalFree(g_pcDialErr->m_pszDisplayable);
		g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, (size_t) lpOutput1->dwDisplayableStringSize+1);
		if (!g_pcDialErr->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpyn(g_pcDialErr->m_pszDisplayable,
					(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
					(size_t)lpOutput1->dwDisplayableStringSize);
#endif // WIN16
	}

GetDisplayableNumberExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);

#if !defined(WIN16)
	if (lpOutput1) GlobalFree(lpOutput1);
	if (g_pcDialErr->m_hLineApp) lineShutdown(g_pcDialErr->m_hLineApp);
#endif
	return hr;

}



//+---------------------------------------------------------------------------
//
//  Function:   MyRasGetEntryProperties()
//
//  Synopsis:   Performs some buffer size checks and then calls RasGetEntryProperties()
//				See the RasGetEntryProperties() docs to understand why this is needed.
//
//  Arguments:  Same as RasGetEntryProperties with the following exceptions:
//				lplpRasEntryBuff -- pointer to a pointer to a RASENTRY struct.  On successfull
//									return, *lplpRasEntryBuff will point to the RASENTRY struct
//									and buffer returned by RasGetEntryProperties.
//									NOTE: should not have memory allocated to it at call time!
//									      To emphasize this point, *lplpRasEntryBuff must be NULL
//				lplpRasDevInfoBuff -- pointer to a pointer to a RASDEVINFO struct.  On successfull
//									return, *lplpRasDevInfoBuff will point to the RASDEVINFO struct
//									and buffer returned by RasGetEntryProperties.
//									NOTE: should not have memory allocated to it at call time!
//									      To emphasize this point, *lplpRasDevInfoBuff must be NULL
//									NOTE: Even on a successfull call to RasGetEntryProperties,
//										  *lplpRasDevInfoBuff may return with a value of NULL
//										  (occurs when there is no extra device info)
//
//	Returns:	ERROR_NOT_ENOUGH_MEMORY if unable to allocate either RASENTRY or RASDEVINFO buffer
//				Otherwise, it retuns the error code from the call to RasGetEntryProperties.
//				NOTE: if return is anything other than ERROR_SUCCESS, *lplpRasDevInfoBuff and
//			          *lplpRasEntryBuff will be NULL,
//	                  and *lpdwRasEntryBuffSize and *lpdwRasDevInfoBuffSize will be 0
//
//  Example:
//
//	  LPRASENTRY    lpRasEntry = NULL;
//	  LPRASDEVINFO  lpRasDevInfo = NULL;
//	  DWORD			dwRasEntrySize, dwRasDevInfoSize;
//
//	  hr = MyRasGetEntryProperties( NULL,
//	  							    g_pcDialErr->m_pszConnectoid,
//								    &lpRasEntry,
//								    &dwRasEntrySize,
//								    &lpRasDevInfo,
//								    &dwRasDevInfoSize);
//
//
//	  if (hr != ERROR_SUCCESS)
//	  {
//	    	//handle errors here
//	  } else
//	  {
//			//continue processing
//	  }
//
//
//  History:    9/10/96     JMazner    Created
//
//----------------------------------------------------------------------------
HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
								LPTSTR lpszPhonebookEntry, 
								LPRASENTRY *lplpRasEntryBuff,
								LPDWORD lpdwRasEntryBuffSize,
								LPRASDEVINFO *lplpRasDevInfoBuff,
								LPDWORD lpdwRasDevInfoBuffSize)
{
	HRESULT hr;
	RNAAPI *pRnaapi = NULL;

	DWORD dwOldDevInfoBuffSize;


	Assert( NULL != lplpRasEntryBuff );
	Assert( NULL != lpdwRasEntryBuffSize );
	Assert( NULL != lplpRasDevInfoBuff );
	Assert( NULL != lpdwRasDevInfoBuffSize );

	*lpdwRasEntryBuffSize = 0;
	*lpdwRasDevInfoBuffSize = 0;

	// Use reference variables internaly to make notation easier
	LPRASENTRY &reflpRasEntryBuff = *lplpRasEntryBuff;
	LPRASDEVINFO &reflpRasDevInfoBuff = *lplpRasDevInfoBuff;


	Assert( NULL == reflpRasEntryBuff );
	Assert( NULL == reflpRasDevInfoBuff );

	// need to softlink for simultaneous compatability with win95 and winnt
	pRnaapi = new RNAAPI;
	if( !pRnaapi )
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto MyRasGetEntryPropertiesErrExit;
	}
	

	// use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
	// As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

	hr = pRnaapi->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
								(LPBYTE)NULL,
								lpdwRasEntryBuffSize,
								(LPBYTE)NULL,lpdwRasDevInfoBuffSize);

	// we expect the above call to fail because the buffer size is 0
	// If it doesn't fail, that means our RasEntry is messed, so we're in trouble
	if( ERROR_BUFFER_TOO_SMALL != hr )
	{ 
		goto MyRasGetEntryPropertiesErrExit;
	}

	// dwRasEntryBuffSize and dwRasDevInfoBuffSize now contain the size needed for their
	// respective buffers, so allocate the memory for them

	// dwRasEntryBuffSize should never be less than the size of the RASENTRY struct.
	// If it is, we'll run into problems sticking values into the struct's fields

	Assert( *lpdwRasEntryBuffSize >= sizeof(RASENTRY) );

#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize + 256);
#else	
	reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize);
#endif

	if (!reflpRasEntryBuff)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto MyRasGetEntryPropertiesErrExit;
	}

	//
	// Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
	// If size is 0, don't alloc anything
	//
	if( *lpdwRasDevInfoBuffSize > 0 )
	{
		Assert( *lpdwRasDevInfoBuffSize >= sizeof(RASDEVINFO) );
	    reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoBuffSize);
	    if (!reflpRasDevInfoBuff)
	    {
		    hr = ERROR_NOT_ENOUGH_MEMORY;
		    goto MyRasGetEntryPropertiesErrExit;
	    }
	} else
	{
		reflpRasDevInfoBuff = NULL;
	}

	// This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
	// RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
	// This is because the dwSize field is used by RAS for compatability purposes to determine which
	// version of the RASENTRY struct we're using.
	// Same holds for lpRasDevInfo->dwSize
	
	reflpRasEntryBuff->dwSize = sizeof(RASENTRY);
	if( reflpRasDevInfoBuff )
	{
		reflpRasDevInfoBuff->dwSize = sizeof(RASDEVINFO);
	}


	// now we're ready to make the actual call...

	// jmazner   see below for why this is needed
	dwOldDevInfoBuffSize = *lpdwRasDevInfoBuffSize;


	hr = pRnaapi->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
								(LPBYTE)reflpRasEntryBuff,
								lpdwRasEntryBuffSize,
								(LPBYTE)reflpRasDevInfoBuff,lpdwRasDevInfoBuffSize);

	// jmazner 10/7/96  Normandy #8763
	// For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
	// but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
	// size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
	// for the DevInfoBuff match on exit.
	if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoBuffSize) )
	{
		*lpdwRasDevInfoBuffSize = dwOldDevInfoBuffSize;
	}


	return( hr );

MyRasGetEntryPropertiesErrExit:

	if(reflpRasEntryBuff)
	{
		GlobalFree(reflpRasEntryBuff);
		reflpRasDevInfoBuff = NULL;
	}
	if(reflpRasDevInfoBuff)
	{
		GlobalFree(reflpRasDevInfoBuff);
		reflpRasDevInfoBuff = NULL;
	}	

	*lpdwRasEntryBuffSize = 0;
	*lpdwRasDevInfoBuffSize = 0;
	
	return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\icwerr.cpp ===
/*-----------------------------------------------------------------------------
	icwerr.cpp

	Maps RAS and downloading errors to string resource indices

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
//#include <raserror.h>
#include "..\inc\icwerr.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{
	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
#ifdef DEBUG    
		OutputDebugString("Got random RAS MEDIA error!\r\n");
#endif        
		return IDS_MEDIAINIERROR;
	}
	
	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return IDS_PPPRANDOMFAILURE;

	case ERROR_DOWNLOADDIDNT:
		return IDS_CANTDOWNLOAD;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:
		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_PPPRANDOMFAILURE;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
		ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
		ev = EVENT_RAS_AUTH_FAILED; break;

	case ERROR_ALREADY_DISCONNECTING:
	case ERROR_DISCONNECTION:
		ev = EVENT_CONNECTION_DROPPED; break;

	case PENDING: 
	case ERROR_INVALID_PORT_HANDLE:
	case ERROR_CANNOT_SET_PORT_INFO:
	case ERROR_PORT_NOT_CONNECTED:
	case ERROR_DEVICE_DOES_NOT_EXIST:
	case ERROR_DEVICETYPE_DOES_NOT_EXIST:
	case ERROR_PORT_NOT_FOUND:
	case ERROR_DEVICENAME_TOO_LONG:
	case ERROR_DEVICENAME_NOT_FOUND:
	 	ev=EVENT_BAD_MODEM_CONFIG; break;

	case ERROR_TAPI_CONFIGURATION:
		ev=EVENT_BAD_TAPI_CONFIG; break;
	
		ev=EVENT_MODEM_BUSY; break;
	
	case ERROR_BUFFER_TOO_SMALL:
	case ERROR_WRONG_INFO_SPECIFIED:
	case ERROR_EVENT_INVALID:
	case ERROR_BUFFER_INVALID:
	case ERROR_ASYNC_REQUEST_PENDING:
	case ERROR_CANNOT_OPEN_PHONEBOOK:
	case ERROR_CANNOT_LOAD_PHONEBOOK:
	case ERROR_CANNOT_WRITE_PHONEBOOK:
	case ERROR_CORRUPT_PHONEBOOK:
	case ERROR_CANNOT_LOAD_STRING:
	case ERROR_OUT_OF_BUFFERS:
	case ERROR_MACRO_NOT_FOUND:
	case ERROR_MACRO_NOT_DEFINED:
	case ERROR_MESSAGE_MACRO_NOT_FOUND:
	case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
	case ERROR_FILE_COULD_NOT_BE_OPENED:
	case ERROR_PORT_NOT_OPEN:
	case ERROR_PORT_DISCONNECTED:
	case ERROR_NO_ENDPOINTS:
	case ERROR_KEY_NOT_FOUND:
	case ERROR_INVALID_SIZE:
	case ERROR_PORT_NOT_AVAILABLE:
	case ERROR_UNKNOWN:
	case ERROR_WRONG_DEVICE_ATTACHED:
	case ERROR_BAD_STRING:
	case ERROR_BAD_USAGE_IN_INI_FILE:
	case ERROR_READING_SECTIONNAME:
	case ERROR_READING_DEVICETYPE:
	case ERROR_READING_DEVICENAME:
	case ERROR_READING_USAGE:
	case ERROR_READING_MAXCONNECTBPS:
	case ERROR_READING_MAXCARRIERBPS:
	case ERROR_IN_COMMAND:
	case ERROR_WRITING_SECTIONNAME:
	case ERROR_WRITING_DEVICETYPE:
	case ERROR_WRITING_DEVICENAME:
	case ERROR_WRITING_MAXCONNECTBPS:
	case ERROR_WRITING_MAXCARRIERBPS:
	case ERROR_WRITING_USAGE:
	case ERROR_WRITING_DEFAULTOFF:
	case ERROR_READING_DEFAULTOFF:
	case ERROR_EMPTY_INI_FILE:
	case ERROR_FROM_DEVICE:
	case ERROR_UNRECOGNIZED_RESPONSE:
	case ERROR_NO_RESPONSES:
	case ERROR_NO_COMMAND_FOUND:
	case ERROR_WRONG_KEY_SPECIFIED:
	case ERROR_UNKNOWN_DEVICE_TYPE:
	case ERROR_ALLOCATING_MEMORY:
	case ERROR_PORT_NOT_CONFIGURED:
	case ERROR_DEVICE_NOT_READY:
	case ERROR_READING_INI_FILE:
	case ERROR_NO_CONNECTION:
	case ERROR_PORT_OR_DEVICE:
	case ERROR_NOT_BINARY_MACRO:
	case ERROR_DCB_NOT_FOUND:
	case ERROR_STATE_MACHINES_NOT_STARTED:
	case ERROR_STATE_MACHINES_ALREADY_STARTED:
	case ERROR_PARTIAL_RESPONSE_LOOPING:
	case ERROR_UNKNOWN_RESPONSE_KEY:
	case ERROR_RECV_BUF_FULL:
	case ERROR_CMD_TOO_LONG:
	case ERROR_UNSUPPORTED_BPS:
	case ERROR_UNEXPECTED_RESPONSE:
	case ERROR_INTERACTIVE_MODE:
	case ERROR_BAD_CALLBACK_NUMBER:
	case ERROR_INVALID_AUTH_STATE:
	case ERROR_WRITING_INITBPS:
	case ERROR_X25_DIAGNOSTIC:
	case ERROR_OVERRUN:
	case ERROR_RASMAN_CANNOT_INITIALIZE:
	case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
	case ERROR_NO_ACTIVE_ISDN_LINES:
	case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
	case ERROR_TOO_MANY_LINE_ERRORS:
		ev=EVENT_INTERNAL_ERROR; break;
	
	case ERROR_ROUTE_NOT_AVAILABLE:
	case ERROR_ROUTE_NOT_ALLOCATED:
	case ERROR_INVALID_COMPRESSION_SPECIFIED:
	case ERROR_CANNOT_PROJECT_CLIENT:
	case ERROR_CANNOT_GET_LANA:
	case ERROR_NETBIOS_ERROR:
	case ERROR_NAME_EXISTS_ON_NET:
		ev=EVENT_BAD_NET_CONFIG; break;
	
	case ERROR_REQUEST_TIMEOUT:
	case ERROR_SERVER_OUT_OF_RESOURCES:
	case ERROR_SERVER_GENERAL_NET_FAILURE:
	case WARNING_MSG_ALIAS_NOT_ADDED:
	case ERROR_SERVER_NOT_RESPONDING:
		ev=EVENT_GENERAL_NET_ERROR; break;
		
	case ERROR_IP_CONFIGURATION:
	case ERROR_NO_IP_ADDRESSES:
	case ERROR_PPP_REMOTE_TERMINATED:
	case ERROR_PPP_NO_RESPONSE:
	case ERROR_PPP_INVALID_PACKET:
	case ERROR_PHONE_NUMBER_TOO_LONG:
	case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
	case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
	case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
	case ERROR_ACCESSING_TCPCFGDLL:
	case ERROR_NO_IP_RAS_ADAPTER:
	case ERROR_SLIP_REQUIRES_IP:
	case ERROR_PROJECTION_NOT_COMPLETE:
	case ERROR_PPP_NOT_CONVERGING:
	case ERROR_PPP_CP_REJECTED:
	case ERROR_PPP_LCP_TERMINATED:
	case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
	case ERROR_PPP_NCP_TERMINATED:
	case ERROR_PPP_LOOPBACK_DETECTED:
	case ERROR_PPP_NO_ADDRESS_ASSIGNED:
	case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
	case ERROR_NO_LOCAL_ENCRYPTION:
	case ERROR_NO_REMOTE_ENCRYPTION:
	case ERROR_REMOTE_REQUIRES_ENCRYPTION:
	case ERROR_IPXCP_NET_NUMBER_CONFLICT:
		ev = EVENT_PPP_FAILURE; break;
***********/
	}
	return (0xFFFF);
}


// ############################################################################
	
HRESULT LoadDialErrorString(HRESULT hrIN, LPTSTR lpszBuff, DWORD dwBufferSize)
{
	if (lpszBuff && dwBufferSize)
	{
		WORD wSID = 0;
		wSID = RasErrorToIDS(hrIN);
		if (0xFFFF != wSID)
		{
			if (0 != LoadString(GetModuleHandle(NULL),wSID,lpszBuff,(int)dwBufferSize))
				return ERROR_SUCCESS;
		}
	}
	return ERROR_INVALID_PARAMETER;
}

HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
	WORD iIDS = 0;

	switch(dwStatus)
	{
		case RASCS_OpenPort:
			iIDS = IDS_RAS_OPENPORT;
			break;
		case RASCS_PortOpened:
			iIDS = IDS_RAS_PORTOPENED;
			break;
		case RASCS_ConnectDevice:
			iIDS = IDS_RAS_DIALING;
			break;
		case RASCS_DeviceConnected:
			iIDS = IDS_RAS_CONNECTED;
			break;
#if (WINVER >= 0x400) 
		case RASCS_StartAuthentication:
		case RASCS_LogonNetwork:
			iIDS = IDS_RAS_LOCATING;
			break;
//		case RASCS_CallbackComplete:
//			iIDS = IDS_RAS_CONNECTED;
//			break;
#endif 

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
		case RASCS_Connected:
			break;

		case RASCS_Disconnected:
			break;
	}
	if (iIDS && 0 != LoadString(GetModuleHandle(NULL),iIDS,pszBuffer,(int)dwBufferSize))
		return ERROR_SUCCESS;
	else
		return ERROR_INVALID_PARAMETER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\dialdlg.cpp ===
//+---------------------------------------------------------------------------
// File name: dialdlg.cpp
// 
// 	This file impelements the dialing and download progress dialog
// 
// 	Copyright (C) 1996 Microsoft Corporation
// 	All rights reserved
// 
// 	Authors:
// 		ChrisK	Chris Kauffman
// 		VetriV	Vellore Vetrivelkumaran
// 
// 	History:
// 		7/22/96	ChrisK	Cleaned and formatted
// 		8/5/96	VetriV	Added WIN16 code
// 		8/19/96	ValdonB	Added "dial as is" support
// 						Fixed some memory leaks
// 
// -----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#if defined(WIN16)
#include "ietapi.h"
#include <comctlie.h>
#include <string.h>

static FARPROC lpfnCallback = (FARPROC) NULL;
#endif


#define MAX_EXIT_RETRIES 10
#define WM_DIAL WM_USER+3
#define MAX_RETIES 3

PMYDEVICE g_pdevice = NULL;
PDIALDLG g_pcPDLG = NULL;



// ############################################################################
void CALLBACK LineCallback(DWORD hDevice,
						   DWORD dwMessage,
						   DWORD dwInstance,
						   DWORD dwParam1,
						   DWORD dwParam2,
						   DWORD dwParam3)
{
}

#if defined(WIN16)
static BOOL g_bFirstTime = TRUE;
#endif
HWND	g_hDialDlgWnd = NULL;


// ############################################################################
HRESULT ShowDialingDialog(LPTSTR pszConnectoid, PGATHEREDINFO pGI, LPTSTR szUrl, HINSTANCE hInst, HWND hwnd, LPTSTR szINSFile)
{
	int iRC;
	HINSTANCE hDialDLL = NULL;
#if !defined(WIN16)
	PFNDDDlg pfnDDDlg = NULL;
	DIALDLGDATA ddData;
#endif

	if (!g_pdevice) g_pdevice = (PMYDEVICE)GlobalAlloc(GPTR,sizeof(MYDEVICE));
	if (!g_pdevice)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	g_pdevice->dwTapiDev = 0xffffffff;

#if defined(WIN16)

	if (!g_pcPDLG) g_pcPDLG = (PDIALDLG)GlobalAlloc(GPTR,sizeof(DIALDLG));
	if (!g_pcPDLG)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	
	g_pcPDLG->m_pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,lstrlen(pszConnectoid)+1);
	if (!g_pcPDLG->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialingDialogExit;
	}
	lstrcpy(g_pcPDLG->m_pszConnectoid,pszConnectoid);
	g_pcPDLG->m_pGI = pGI;
	g_pcPDLG->m_szUrl = szUrl;
	g_pcPDLG->g_hInst = hInst;
	g_bProgressBarVisible = FALSE;

	DLGPROC dlgprc;
	dlgprc = (DLGPROC) MakeProcInstance((FARPROC)DialDlgProc, g_pcPDLG->g_hInst);
	iRC = DialogBoxParam(g_pcPDLG->g_hInst,
							MAKEINTRESOURCE(IDD_DIALING),
							hwnd, dlgprc, (LPARAM)g_pcPDLG);
	FreeProcInstance((FARPROC) dlgprc);

ShowDialingDialogExit:
	if (g_pcPDLG->m_pszConnectoid) GlobalFree(g_pcPDLG->m_pszConnectoid);
	if (g_pcPDLG->m_pszDisplayable) GlobalFree(g_pcPDLG->m_pszDisplayable);
	if (g_pcPDLG) GlobalFree(g_pcPDLG);
	g_pcPDLG = NULL;
	return iRC;
#else

	//
	// Fill in data structure
	//
	ZeroMemory(&ddData,sizeof(ddData));
	ddData.dwSize = sizeof(ddData);
	StrDup(&ddData.pszMessage,GetSz(IDS_DOWNLOAD_SW));
	StrDup(&ddData.pszRasEntryName,pszConnectoid);
	StrDup(&ddData.pszMultipartMIMEUrl,pszSetupClientURL);
	ddData.pfnStatusCallback = StatusMessageCallback;
	ddData.hInst = hInst;
	ddData.bSkipDial = (0 == uiSetupClientNewPhoneCall);
	//
	// ChrisK 8/20/97
	// Pass .ins file to dialer so that the dialer can find the password
	//
	StrDup(&ddData.pszDunFile,szINSFile);

	//
	// Load API
	//
	hDialDLL = LoadLibrary(AUTODIAL_LIBRARY);
	if (!hDialDLL)
	{
		AssertSz(0,"Can't load icwdial.\r\n");
		iRC = GetLastError();
		goto ShowDialingDialogExit;
	}

	pfnDDDlg = (PFNDDDlg)GetProcAddress(hDialDLL,"DialingDownloadDialog");
	if (!pfnDDDlg)
	{
		AssertSz(0,"Can find DialingDownloadDialog.\r\n");
		iRC = GetLastError();
		goto ShowDialingDialogExit;
	}

	//
	// Display Dialog
	//
	iRC = pfnDDDlg(&ddData);

	//
	// Free memory and clean up
	//

	if (hDialDLL) FreeLibrary(hDialDLL);
	if (ddData.pszMessage) GlobalFree(ddData.pszMessage);
	if (ddData.pszRasEntryName) GlobalFree(ddData.pszRasEntryName);
	if (ddData.pszMultipartMIMEUrl) GlobalFree(ddData.pszMultipartMIMEUrl);

ShowDialingDialogExit:
	return iRC;
#endif
}

// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DialDlgProc(HWND hwnd, 
                                                   UINT uMsg, 
												   WPARAM wparam, 
												   LPARAM lparam)
{
	static UINT unRasEvent = 0;
#if defined(WIN16)
	static BOOL bUserCancelled = FALSE;
#endif
	HRESULT hr;
	//BOOL bPW;
	WORD wIDS;
	//LPRASDIALPARAMS lpRasDialParams;
	HINSTANCE hDLDLL;
	FARPROC fp;
#if !defined(WIN16)
	DWORD dwThreadResults;
#endif
	INT iRetries;
#if defined(WIN16)
	RECT	MyRect;
	RECT	DTRect;
#endif


	BOOL bRes = TRUE;

	switch(uMsg)
	{
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
#ifdef WIN16
		DeleteDlgFont(hwnd);
#endif
		bRes = FALSE;
		break;
#if defined(WIN16)
	case WM_SYSCOLORCHANGE:
		Ctl3dColorChange();
		break;
#endif
	case WM_INITDIALOG:
		g_hDialDlgWnd = hwnd;
#if defined(WIN16)
		g_bFirstTime = TRUE;
		bUserCancelled = FALSE;
		//
		// Move the window to the center of the screen
		//
		GetWindowRect(hwnd, &MyRect);
		GetWindowRect(GetDesktopWindow(), &DTRect);
		MoveWindow(hwnd, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
							MyRect.right, MyRect.bottom, FALSE);

		SetNonBoldDlg(hwnd);
#endif
		ShowWindow(GetDlgItem(hwnd,IDC_PROGRESS),SW_HIDE);

		g_pcPDLG->m_hwnd = hwnd;
		SPParams.hwnd = hwnd;

#if !defined(WIN16)
		unRasEvent = RegisterWindowMessageA( RASDIALEVENT );
#endif
		if (unRasEvent == 0) unRasEvent = WM_RASDIALEVENT; 
		MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Do not make a call.  We are already connected
		//

		if (uiSetupClientNewPhoneCall == FALSE)
		{
			PostMessage(hwnd,unRasEvent,(WPARAM)RASCS_Connected,0);
			break;
		}

		// Show number to be dialed
		//

		hr = GetDisplayableNumberDialDlg();
		if (hr != ERROR_SUCCESS)
		{
			SetDlgItemText(hwnd,IDC_LBLNUMBER,g_pcPDLG->m_szPhoneNumber);
		} else {
			SetDlgItemText(hwnd,IDC_LBLNUMBER,g_pcPDLG->m_pszDisplayable);
		}

		PostMessage(hwnd,WM_DIAL,0,0);
		break;

	case WM_DIAL:
		hr = DialDlg();
#if defined(DEBUG)
		if (0 != hr)
		{
			TCHAR szTempBuf[255];
			RasGetErrorString((UINT)hr, szTempBuf, 254);
			Dprintf("CONNECT: Ras error string is <%s>\n", szTempBuf);
		}
#endif
		if (hr != ERROR_SUCCESS)
			EndDialog(hwnd,(int)hr);
		break;


	case WM_CLOSE:
		if (dwDownLoad)
		{
			hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

			if (hDLDLL)
			{
				fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
				if(fp && dwDownLoad)
					((PFNDOWNLOADCANCEL)fp)(dwDownLoad);
				FreeLibrary(hDLDLL);
			}
		}

		if (uiSetupClientNewPhoneCall)
		{
			if (g_pcPDLG->m_hrasconn) 
			{
				RasHangUp(g_pcPDLG->m_hrasconn);
				WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
			}
			g_pcPDLG->m_hrasconn = NULL;
		}

		EndDialog(hwnd,ERROR_USERCANCEL);
		break;
		
	case WM_COMMAND:
		switch(LOWORD(wparam))
		{
		case IDC_CMDCANCEL:
			if (dwDownLoad)
			{
				hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

				if (hDLDLL)
				{
					fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
					if(fp && dwDownLoad)
						((PFNDOWNLOADCANCEL)fp)(dwDownLoad);
					FreeLibrary(hDLDLL);
				}
#if !defined(WIN16)
			} else {
				PostMessage(hwnd,unRasEvent,RASCS_Disconnected,ERROR_USER_DISCONNECTION);
#endif //!WIN16
			}

			if (uiSetupClientNewPhoneCall)
			{
				if (g_pcPDLG->m_hrasconn) 
				{
					RasHangUp(g_pcPDLG->m_hrasconn);
					WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
				}
				g_pcPDLG->m_hrasconn = NULL;
			}
			break;
		}
#if defined(WIN16)
		bUserCancelled = TRUE;
#endif
		EndDialog(hwnd,ERROR_USERCANCEL);
		break;


	case WM_DOWNLOAD_DONE:
#if !defined(WIN16)
		dwThreadResults = STILL_ACTIVE;
#endif
		
		iRetries = 0;
		
		if (uiSetupClientNewPhoneCall)
		{
			if (g_pcPDLG->m_hrasconn) 
			{
				RasHangUp(g_pcPDLG->m_hrasconn);
				WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
			}
		}

#if !defined(WIN16)
		do {
			if (!GetExitCodeThread(g_pcPDLG->m_hThread,&dwThreadResults))
			{
				AssertSz(0,"CONNECT:GetExitCodeThread failed.\n");
			}

			iRetries++;
			if (dwThreadResults == STILL_ACTIVE) Sleep(500);
		} while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);   

		if (dwThreadResults == ERROR_SUCCESS)
			EndDialog(hwnd,ERROR_USERNEXT);
		else
			EndDialog(hwnd, dwThreadResults);
 #else
		EndDialog(hwnd, ERROR_USERNEXT);
 #endif //!WIN16
		break;


	default:
		bRes = FALSE;

		if (uMsg == unRasEvent)
		{
			Dprintf(TEXT("CONNECT2: Ras event %u error code (%ld)\n"),wparam,lparam);
#if defined(DEBUG)
			if (0 != lparam)
			{
				TCHAR szTempBuf[255];
				RasGetErrorString((UINT)lparam, szTempBuf, 254);
				Dprintf("CONNECT2: Ras error string is <%s>\n", szTempBuf);
			}
#endif

#if !defined(WIN16)
			TCHAR dzRasError[10];
			wsprintf(dzRasError,TEXT("%d %d"),wparam,lparam);
			RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,dzRasError,lstrlen(dzRasError));
#endif


#if defined(WIN16)
			//
			// Work around for WIN16 RAS bug - if status code to > 0x4000 
			// adjust it to the correct value
			//
			if (wparam >= 0x4000)
				wparam -= 0x4000;
#endif							

			wIDS = 0;
			switch(wparam)
			{
			case RASCS_OpenPort:
				wIDS = IDS_RAS_OPENPORT;
				break;
			case RASCS_PortOpened:
				wIDS = IDS_RAS_PORTOPENED;
				break;
			case RASCS_ConnectDevice:
				wIDS = IDS_RAS_DIALING;
				break;
			
#if defined(WIN16)
			case RASCS_AllDevicesConnected: 
				wIDS = IDS_RAS_CONNECTED;
				break; 
#else				
			case RASCS_DeviceConnected:
				wIDS = IDS_RAS_CONNECTED;
				break;
#endif				

			case RASCS_StartAuthentication:
			case RASCS_LogonNetwork:
				wIDS = IDS_RAS_LOCATING;
				break;
//			case RASCS_CallbackComplete:
//				wIDS = IDS_RAS_CONNECTED;
//				break;

/* ETC...
				RASCS_AllDevicesConnected, 
				RASCS_Authenticate, 
				RASCS_AuthNotify, 
				RASCS_AuthRetry, 
				RASCS_AuthCallback, 
				RASCS_AuthChangePassword, 
				RASCS_AuthProject, 
				RASCS_AuthLinkSpeed, 
				RASCS_AuthAck, 
				RASCS_ReAuthenticate, 
				RASCS_Authenticated, 
				RASCS_PrepareForCallback, 
				RASCS_WaitForModemReset, 
				RASCS_WaitForCallback,
				RASCS_Projected, 
 
 
				RASCS_Interactive = RASCS_PAUSED, 
				RASCS_RetryAuthentication, 
				RASCS_CallbackSetByCaller, 
				RASCS_PasswordExpired, 
 */
			case RASCS_Connected:
#if !defined(WIN16)
				MinimizeRNAWindow(g_pcPDLG->m_pszConnectoid, g_pcPDLG->g_hInst);
#endif // !WIN16
				//
				// The connection is open and ready.  Start the download.
				//
				g_pcPDLG->m_dwThreadID = 0;
#if defined(WIN16)
				if (ThreadInit() != ERROR_SUCCESS)
					g_pcPDLG->m_hThread = NULL;
				else
					g_pcPDLG->m_hThread = 1;
#else
 				g_pcPDLG->m_hThread = CreateThread(NULL,0,
												(LPTHREAD_START_ROUTINE)ThreadInit,
												NULL,0,
												&g_pcPDLG->m_dwThreadID);
#endif 				
				if (!g_pcPDLG->m_hThread)
				{
					if (uiSetupClientNewPhoneCall)
					{
						if (g_pcPDLG->m_hrasconn) 
						{
							RasHangUp(g_pcPDLG->m_hrasconn);
							WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
						}
						g_pcPDLG->m_hrasconn =  NULL;
					}
					hr = GetLastError();
#if defined(WIN16)
					if (bUserCancelled)
						hr = ERROR_USERCANCEL;
#endif
					EndDialog(hwnd,(int)hr);
					break;
				}
				break;


			case RASCS_Disconnected:
				//if (FShouldRetry(lparam))
				//	PostMessage(hwnd,WM_DIAL,0,0);
				//else
				
				if (uiSetupClientNewPhoneCall)
				{
					if (g_pcPDLG->m_hrasconn) 
					{
						RasHangUp(g_pcPDLG->m_hrasconn);
						WaitForConnectionTermination(g_pcPDLG->m_hrasconn);
					}
					g_pcPDLG->m_hrasconn = NULL;
				}
				EndDialog(hwnd, (int)lparam);
				break;

				//EndDialog(hwnd,lparam);
				//break;
			}
			if (wIDS)
				SetDlgItemText(hwnd,IDC_LBLSTATUS,GetSz(wIDS));
		}
	}
	return bRes;
}


// ############################################################################
HRESULT GetDisplayableNumberDialDlg()
{
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

#if !defined(WIN16)
	DWORD dwNumDev;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
#endif


	//
	// Get phone number from connectoid
	//
/*#if defined(WIN16)
	//
	// Allocate extra 256 bytes to workaround memory overrun bug in RAS
	//
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY)+256);
#else
	lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,sizeof(RASENTRY));
#endif
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;
*/
	/*hRasDll = LoadLibrary(RASAPI_LIBRARY);
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryProperties");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary("RNAPH.DLL");
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryProperties");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}*/
/*	
	hr = RasGetEntryProperties(NULL,g_pcPDLG->m_pszConnectoid,
#if defined(WIN16)
								(LPBYTE)
#endif
								lpRasEntry,

								&dwRasEntrySize,
								(LPBYTE)lpRasDevInfo,&dwRasDevInfoSize);
*/
	hr = MyRasGetEntryProperties( NULL,
								  g_pcPDLG->m_pszConnectoid,
								  &lpRasEntry,
								  &dwRasEntrySize,
								  &lpRasDevInfo,
								  &dwRasDevInfoSize);

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	//FreeLibrary(hRasDll);

	//
	// If this is a dial as is number, just get it from the structure
	//
	g_pcPDLG->m_bDialAsIs = !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);
	if (g_pcPDLG->m_bDialAsIs)
	{
		if (g_pcPDLG->m_pszDisplayable) GlobalFree(g_pcPDLG->m_pszDisplayable);
		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, lstrlen(lpRasEntry->szLocalPhoneNumber)+1);
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(g_pcPDLG->m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(g_pcPDLG->m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(g_pcPDLG->m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
		else
			wsprintf(g_pcPDLG->m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);

#if defined(WIN16)
		TCHAR szBuffer[1024];
		LONG lRetCode;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpOutput1 = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpOutput1->dwTotalSize = sizeof(szBuffer);

		lRetCode = IETapiTranslateAddress(NULL, g_pcPDLG->m_szPhoneNumber,
											0L, 0L, lpOutput1);
		
		if (0 != lRetCode)
		{
			//
			// TODO: Set the correct error code
			//
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, 
														((size_t)lpOutput1->dwDisplayableStringSize+1));
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpy(g_pcPDLG->m_pszDisplayable, 
					&szBuffer[lpOutput1->dwDisplayableStringOffset]);


#else //WIN16
		
		//
		//  Initialize TAPIness
		//
		dwNumDev = 0;
		hr = lineInitialize(&g_pcPDLG->m_hLineApp,g_pcPDLG->g_hInst,LineCallback,NULL,&dwNumDev);

		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
		{
				g_pdevice->dwTapiDev = 0;
		}

		lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
		if (!lpExtensionID)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		do {
			hr = lineNegotiateAPIVersion(g_pcPDLG->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
				&g_pcPDLG->m_dwAPIVersion, lpExtensionID);
		} while (hr && g_pdevice->dwTapiDev++ < dwNumDev-1);

		// ditch it since we don't use it
		//
		if (lpExtensionID) GlobalFree(lpExtensionID);
		if (hr != ERROR_SUCCESS)
			goto GetDisplayableNumberExit;

		// Format the phone number
		//

		lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
		if (!lpOutput1)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

		
		//
		// Turn the canonical form into the "displayable" form
		//
		hr = lineTranslateAddress(g_pcPDLG->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcPDLG->m_dwAPIVersion,
									g_pcPDLG->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t)lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(g_pcPDLG->m_hLineApp,g_pdevice->dwTapiDev,
										g_pcPDLG->m_dwAPIVersion,
										g_pcPDLG->m_szPhoneNumber,0,
										LINETRANSLATEOPTION_CANCELCALLWAITING,
										lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		g_pcPDLG->m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, (size_t)lpOutput1->dwDisplayableStringSize+1);
		if (!g_pcPDLG->m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}

		lstrcpyn(g_pcPDLG->m_pszDisplayable,
					(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
					(size_t)lpOutput1->dwDisplayableStringSize);
#endif // WIN16
	}

GetDisplayableNumberExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);

#if !defined(WIN16)
	if (lpOutput1) GlobalFree(lpOutput1);
	if (g_pcPDLG->m_hLineApp) lineShutdown(g_pcPDLG->m_hLineApp);
#endif
	return hr;
}



#if defined(WIN16)
//////////////////////////////////////////////////////////////////////////
// The callback proc is called during the connection process. Display
// the connection progress status in the dialer window. When connection
// is complete, change the Cancel button to Disconnect, and change the
// state to connected.
extern "C" void CALLBACK __export DialCallback(UINT uiMsg,
												RASCONNSTATE rasState,
												DWORD dwErr)
{
        if (TRUE == g_bFirstTime)
		{	
			g_bFirstTime = FALSE;
			if (RASCS_Disconnected == rasState)
				return;
		}

		//
		// WIN 3.1 does not send disconnect event on error!!!
		//
		if (0 != dwErr)
			rasState = RASCS_Disconnected;

		PostMessage(g_hDialDlgWnd, WM_RASDIALEVENT, (WPARAM) rasState, 
						(LPARAM)dwErr);
} 
#endif



HRESULT DialDlg()
{
	LPRASDIALPARAMS lpRasDialParams = NULL;
	LPRASDIALEXTENSIONS lpRasDialExtentions = NULL;
	HRESULT hr = ERROR_SUCCESS;
	BOOL bPW;

	// Get connectoid information
	//

	lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
	if (!lpRasDialParams)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto DialExit;
	}
	lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
	lstrcpyn(lpRasDialParams->szEntryName,g_pcPDLG->m_pszConnectoid,
				sizeof(lpRasDialParams->szEntryName));
	bPW = FALSE;
	hr = RasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
	if (hr != ERROR_SUCCESS)
	{
		goto DialExit;
	}


	//
	// This is only used on WINNT
	//
	lpRasDialExtentions = (LPRASDIALEXTENSIONS)GlobalAlloc(GPTR,sizeof(RASDIALEXTENSIONS));
	if (lpRasDialExtentions)
	{
		lpRasDialExtentions->dwSize = sizeof(RASDIALEXTENSIONS);
		lpRasDialExtentions->dwfOptions = RDEOPT_UsePrefixSuffix;
	}


	// Add the user's password
	//
	GetPrivateProfileString(
				INFFILE_USER_SECTION,INFFILE_PASSWORD,
				NULLSZ,lpRasDialParams->szPassword,PWLEN + 1,pszINSFileName);


#if defined(WIN16)
	if (g_pcPDLG->m_bDialAsIs)
	{
		Dprintf("CONNECT: Dialing as is <%s>\n", g_pcPDLG->m_szPhoneNumber);
		lstrcpy(lpRasDialParams->szPhoneNumber, g_pcPDLG->m_szPhoneNumber);
	}
	else
	{
		//
		// Translate the number in canonical format to a dialable string
		//
		TCHAR szBuffer[1024];
		LONG lRetCode;
		LPLINETRANSLATEOUTPUT lpLine;
		
		memset(&szBuffer[0], 0, sizeof(szBuffer));
		lpLine = (LPLINETRANSLATEOUTPUT) & szBuffer[0];
		lpLine->dwTotalSize = sizeof(szBuffer);
		lRetCode = IETapiTranslateAddress(NULL, g_pcPDLG->m_szPhoneNumber, 
											0L, 0L, lpLine);
		Dprintf("CONNECT2: Dialable string retured by IETAPI is <%s>\n", 
					(LPTSTR) &szBuffer[lpLine->dwDialableStringOffset]);
		lstrcpy(lpRasDialParams->szPhoneNumber, 
					&szBuffer[lpLine->dwDialableStringOffset]);
	}
#endif

	
	// Dial connectoid
	//

	g_pcPDLG->m_hrasconn = NULL;
#if defined(WIN16)
	lpfnCallback = MakeProcInstance((FARPROC)DialCallback, g_pcPDLG->g_hInst);
	hr = RasDial(lpRasDialExtentions, NULL,lpRasDialParams,0, 
					(LPVOID)lpfnCallback,
					&g_pcPDLG->m_hrasconn);
#else
	hr = RasDial(lpRasDialExtentions,NULL,lpRasDialParams,0xFFFFFFFF, 
					(LPVOID)g_pcPDLG->m_hwnd,
					&g_pcPDLG->m_hrasconn);
#endif					
	if (hr != ERROR_SUCCESS)
	{
		if (g_pcPDLG->m_hrasconn)
		{
			RasHangUp(g_pcPDLG->m_hrasconn);
		}
		goto DialExit;
	}

DialExit:
	if (lpRasDialParams) GlobalFree(lpRasDialParams);
	if (lpRasDialExtentions) GlobalFree(lpRasDialExtentions);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\pch.hpp ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>
#include <locale.h>

#if defined(WIN16)
#define HRESULT long
#define WCHAR	WORD
#include <rasc.h>
#include <raserr.h>
#include <shellapi.h>
#include <ctl3d.h>
#include "tapi.h"
#include "win16def.h"
#include "..\icwdl\download.h"

#else

#include <ras.h>
#include <raserror.h>
#include <string.h>
#include <commctrl.h>
#include <wininet.h>
#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>
//#pragma pack(4)
//#include <rnaph.h>
//#pragma pack()

#include "icwunicd.h"

#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\resource.h ===
/*-----------------------------------------------------------------------------
	resource.h

	Constants used by .rc file for ICWCONN2

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
	
	NOTE:
		DO NOT EDIT THESE RESOURCES WITH MSVC

-----------------------------------------------------------------------------*/
#ifdef APSTUDIO_INVOKED
#error DO NOT EDIT WITH MSVC
#endif

#define IDD_PROGRESS                    101
#define IDD_BACK                        102
#define IDD_CONTEXT                     103
#define IDI_PHONE                       104
#define IDB_ARROW                       105
#define IDB_WORLD                       106
#define IDD_STEPTWO                     107
#define IDB_PHONE                       108
#define IDB_ICW                         109
#define IDD_DONE                        110
#define IDD_DIALING                     111
#define IDD_DIALERR                     112
#define IDD_DONEREBOOT                  113
#define IDD_DIALREALLYCANCEL            114
#define IDS_TITLE                       500
#define IDS_CANTDOWNLOAD                501 
#define IDS_RECEIVING_RESPONSE          502
#define IDS_OUTOFMEMORY                 503
#define IDS_CALLHOME                    504
#define IDS_DOWNLOAD_SW                 505
#if !defined(WIN16)
#define IDS_CONNECTED_TO                506
#endif //!WIN16
#define IDS_INVALIDPHONE                507
//#if defined(WIN16)
#define	IDS_CANTEXECUTE                 508
//#endif
#define IDS_MISSING_FILE				509
#define IDS_BAD_CMDLINE					510
//#define IDS_NT_AUTODIAL_SUCKS			511

#define IDC_STATIC                      -1
#define IDC_PROGRESS                    1000
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_PCTARROW1                   1002
#define IDC_PCTARROW2                   1003
#define IDC_PCTARROW3                   1004
#define IDC_CMDHELP                     1005
#define IDC_CMDNEXT                     1007
#define IDC_CMDBACK                     1008
#define IDC_LBLTITLE                    1009
#define IDC_LBLSTATUS                   1010
#define IDC_LBLEXPLORE                  1011
#define IDC_CMDCLOSE                    1012
#define IDC_LBLARROW3NUM                1014
#define IDC_LBLARROW3TEXT               1015
#define IDC_LBLNUMBER                   1016
#define IDC_TEXTNUMBER                  1017
#define IDC_LBLERRMSG                   1020
#define IDC_CMBMODEMS                   1021
#define IDC_CMDDIALPROP                 1023

#define IDS_WANTTOEXIT                  1040
#define IDS_CANTSAVEKEY                 1042
#define IDC_LBLCALLHOME                 1043
#define IDC_CLICK                       1044
#define IDC_EXPLORE                     1045
#define IDC_CLICK2                      1046
#define IDC_RESTART                     1047
#define IDC_CMDEXPLORE                  2023
#define IDC_NOTDONE                     2024 
#define IDC_EXITNOW                     2025
#define IDC_ATTEMPT                     2026

#define IDC_DIALING_TEXT2               2028
#define IDC_DIALING_TEXT3               2029
#define IDC_DIALERR_TEXT1               2030
#define IDC_DIALERR_TEXT2               2031
#define IDC_DIALERR_TEXT3               2032
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\main.cpp ===
/*-----------------------------------------------------------------------------
    main.cpp

    Main entry and code for ICWCONN2

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved

    Authors:
        ChrisK  Chris Kauffman
        VetriV  Vellore Vetrivelkumaran

    Histroy:
        7/22/96 ChrisK  Cleaned and formatted
        8/5/96  VetriV  Added WIN16 code
        4/29/98 donaldm removed WIN16 code    
-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
#include "..\inc\semaphor.h"

#define IEAPPPATHKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
DWORD CallCMConfig(LPCTSTR lpszINSFile, LPTSTR lpszConnectoidName);

TCHAR        pszINSFileName[MAX_PATH+2];
TCHAR        pszFinalConnectoid[MAX_PATH+1];
HRASCONN    hrasconn;
TCHAR        pszSetupClientURL[1024];
UINT        uiSetupClientNewPhoneCall;
ShowProgressParams SPParams;
RECT        rect;
HBRUSH      hbBackBrush;
BOOL        fUserCanceled;
TCHAR        szBuff256[256];
HANDLE      hThread;
DWORD       dwThreadID;
DWORD_PTR   dwDownLoad;
DWORD       g_fNeedReboot;
BOOL        g_bProgressBarVisible;
BOOL        g_bINSFileExists; 

TCHAR szStrTable[irgMaxSzs][256];
int iSzTable;

extern HWND g_hDialDlgWnd;


// The following two functions are for My[16|32]ShellExecute
BOOL fStrNCmpI (LPTSTR lp1, LPTSTR lp2, UINT iNum)
{
    UINT i;
    for (i = 0; (i < iNum) && (toupper(lp1[i]) == toupper(lp2[i])); i++) {}
    return (i == iNum);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsURL
//
//  Synopsis:   Determines whether a string is URL
//
//  Arguments:  lpszCommand - the string to check
//
//  Returns:    TRUE - For our purposes, it's a URL
//              FALSE - Do not treat as a URL
//
//  History:    jmazner     Created     10/23/96
//
//-----------------------------------------------------------------------------
BOOL IsURL( LPTSTR lpszCommand )
{
    return (fStrNCmpI(lpszCommand, TEXT("HTTP:"), 5) ||
            fStrNCmpI(lpszCommand, TEXT("HTTPS:"), 6) ||
            fStrNCmpI(lpszCommand, TEXT("FTP:"), 4) ||
            fStrNCmpI(lpszCommand, TEXT("GOPHER:"), 7) ||
            fStrNCmpI(lpszCommand, TEXT("FILE:"), 5));
}


int FindFirstWhiteSpace( LPTSTR szString ); //declared below

//+----------------------------------------------------------------------------
//
//  Function:   My32ShellExecute
//
//  Synopsis:   ShellExecute a command in such a way that browsers other than
//              IE won't get called to handle URLs.
//
//              If command is a URL, explicitly ShellExec IE on it,
//              if it's empty, shellExec IE with no parameters, and
//              if it's anything else, assume it's a command followed by a
//              parameter list, and shellExec that.
//
//  Arguments:  lpszCommand - the command to execute
//
//  Returns:    TRUE - For our purposes, it's a URL
//              FALSE - Do not treat as a URL
//
//  History:    10/23/96    jmazner     Created
//              11/5/96     jmazner     updated to use ShellExec in all cases,
//                                      to mimick behavior of start->run,
//                                      rather than dos box command line.
//              4/30/97     jmazner     updated to use IE AppPath reg key
//                                      (Olympus bug #200)
//
//-----------------------------------------------------------------------------
void My32ShellExecute(LPTSTR lpszCommand)
{
    HINSTANCE hInst = NULL;
    TCHAR * szParameter = NULL;
    TCHAR * pszIEAppPath = NULL;
    const TCHAR * cszGenericIE = TEXT("IEXPLORE.EXE");
    DWORD dwErr = ERROR_GEN_FAILURE;
    LONG lSize = 0;
    
    Assert( lpszCommand );
  
    dwErr = RegQueryValue(HKEY_LOCAL_MACHINE,IEAPPPATHKEY,NULL,&lSize);
    if ((ERROR_SUCCESS == dwErr || ERROR_MORE_DATA == dwErr) && (0 != lSize))
    {
        //
        // add 1 for null and 10 for slop
        //
        pszIEAppPath = (LPTSTR)LocalAlloc(LPTR,lSize+2+1+10); 
  
        if( pszIEAppPath )
        {
            dwErr = RegQueryValue(HKEY_LOCAL_MACHINE,IEAPPPATHKEY,
                                        pszIEAppPath,&lSize);

            if( ERROR_SUCCESS != dwErr )
            {
                LocalFree( pszIEAppPath );
                pszIEAppPath = NULL;
            }
            else
            {
                Dprintf(TEXT("ICWCONN2: got IE Path of %s\n"), pszIEAppPath);
            }
        }
    }

    if( !pszIEAppPath )
    {
        pszIEAppPath = (TCHAR *) cszGenericIE;
        Dprintf(TEXT("ICWCONN2: Couldn't find IE appPath, using generic %s"), pszIEAppPath);
    }



    if( IsURL(lpszCommand) )
    {
        // If the command looks like a URL, explicitly call IE to open it
        // (don't want to rely on default browser)
        hInst = ShellExecute(NULL,TEXT("open"),pszIEAppPath,lpszCommand,NULL,SW_SHOWNORMAL);
    }
    else if( !lpszCommand[0] )
    {
        // If there is no command, just exec IE
        hInst = ShellExecute(NULL,TEXT("open"),pszIEAppPath,NULL,NULL,SW_SHOWNORMAL);
    }
    else
    {
        int i = FindFirstWhiteSpace( lpszCommand );
        if( 0 == i )
        {
            hInst = ShellExecute(NULL, TEXT("open"), lpszCommand, NULL, NULL, SW_SHOWNORMAL);
        }
        else
        {
            lpszCommand[i] = '\0';

            // now skip past all consecutive white space
            while( ' ' == lpszCommand[++i] );

            szParameter = lpszCommand + i;
            hInst = ShellExecute(NULL, TEXT("open"), lpszCommand, szParameter, NULL, SW_SHOWNORMAL);
        }
    }

    if (hInst < (HINSTANCE)32)
    {
        Dprintf(TEXT("ICWCONN2: Couldn't execute the command '%s %s'\n"),
            lpszCommand, szParameter ? szParameter : TEXT("\0"));
        MessageBox(NULL,GetSz(IDS_CANTEXECUTE),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   FindFirstWhiteSpace
//
//  Synopsis:   Return the index of the first whtie space character in the
//              string that's not enclosed in a double quote substring
//      
//              eg: "iexplore foo.htm" should return 8,
//                  ""c:\program files\ie" foo.htm" should return 21
//
//  Arguments:  szString - the string to search through
//
//  Returns:    index of first qualifying white space.
//              if no qualifying character exists, returns 0
//
//  History:    11/5/96 jmazner Created for Normandy #9867
//
//-----------------------------------------------------------------------------

int FindFirstWhiteSpace( LPTSTR szString )
{
    int i = 0;

    Assert( szString );

    if( '\"' == szString[0] )
    {
        // Don't look for spaces within a double quoted string
        // (example string "c:\Program Files\bob.exe" foo.bob)
    
        i++;
        while( '\"' != szString[i] )
        {
            if( NULL == szString[i] )
            {
                AssertSz(0, "ExploreNow command has unmatched quotes!\n");
                Dprintf(TEXT("ICWCONN2: FindFirstWhiteSpace discovered unmatched quote.\n"));
                return( 0 );
            }

            i++;
        }

    }

    while( ' ' != szString[i] )
    {
        if( NULL == szString[i] )
            //there is no white space to be found
            return 0;
        
        i++;
    }

    return( i );
}

//+---------------------------------------------------------------------------
//
//  Function:   WaitForConnectionTermination
//
//  Synopsis:   Waits for the given Ras Connection to complete termination
//
//  Arguments:  hConn - Connection handle of the RAS connection being terminated
//
//  Returns:    TRUE if wait till connection termination was successful
//              FALSE otherwise
// 
//  History:    6/30/96 VetriV  Created
//              8/19/96 ValdonB Moved from duplicate in icwconn1\dialdlg.cpp
//              8/29/96 VetriV  Added code to sleep for a second on WIN 3.1 
//----------------------------------------------------------------------------
// Normandy #12547 Chrisk 12-18-96
#define MAX_TIME_FOR_TERMINATION 5
BOOL WaitForConnectionTermination(HRASCONN hConn)
{
    RASCONNSTATUS RasConnStatus;
    DWORD dwRetCode;
    INT cnt = 0;

    //
    // Get Connection status for hConn in a loop until 
    // RasGetConnectStatus returns ERROR_INVALID_HANDLE
    //
    do
    {
        //
        // Intialize RASCONNSTATUS struct
        // GetConnectStatus API will fail if dwSize is not set correctly!!
        //
        ZeroMemory(&RasConnStatus, sizeof(RASCONNSTATUS));

        RasConnStatus.dwSize = sizeof(RASCONNSTATUS);

        //
        // Sleep for a second and then get the connection status
        //
        Sleep(1000L);
        // Normandy #12547 Chrisk 12-18-96
        cnt++;

        dwRetCode = RasGetConnectStatus(hConn, &RasConnStatus);
        if (0 != dwRetCode)
            return FALSE;
    
    // Normandy #12547 Chrisk 12-18-96
    } while ((ERROR_INVALID_HANDLE != RasConnStatus.dwError) && (cnt < MAX_TIME_FOR_TERMINATION));
    return TRUE;
}

// ############################################################################
// NAME: GetSz
//
//  Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = &szStrTable[iSzTable][0];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(GetModuleHandle(NULL), wszID, psz, 256))
    {
        Dprintf(TEXT("CONNECT2:LoadString failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}
// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = (int)lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
MakeBoldExit:
    // if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}



// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DoneDlgProc(HWND  hwnd,UINT  uMsg,WPARAM  wParam,LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDCLOSE:
        case IDC_CMDEXPLORE:
            EndDialog(hwnd,LOWORD(wParam));
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        GetPrivateProfileString(
                    INSFILE_APPNAME,INFFILE_DONE_MESSAGE,
                    NULLSZ,szBuff256,255,pszINSFileName);
        SetDlgItemText(hwnd,IDC_LBLEXPLORE,szBuff256);

        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
        bRet = FALSE;
        break;
    case WM_CLOSE:
        EndDialog(hwnd,IDC_CMDCLOSE);
        break;
    default:
        bRet = FALSE;
        break;
    }
    return bRet;
}



// ############################################################################
extern "C" INT_PTR CALLBACK FAR PASCAL DoneRebootDlgProc(HWND  hwnd,UINT  uMsg,
                                                        WPARAM  wParam, 
                                                        LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case WM_CLOSE:
        case IDC_CMDEXPLORE:
            EndDialog(hwnd,LOWORD(wParam));
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        GetPrivateProfileString(
                    INSFILE_APPNAME,INFFILE_DONE_MESSAGE,
                    NULLSZ,szBuff256,255,pszINSFileName);
        SetDlgItemText(hwnd,IDC_LBLEXPLORE,szBuff256);

        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));
        bRet = FALSE;
        break;
    default:
        bRet = FALSE;
        break;
    }
    return bRet;
}



// ############################################################################
extern "C" BOOL CALLBACK FAR PASCAL StepTwoDlgProc(HWND  hwnd,UINT  uMsg,
                                                    WPARAM  wParam,
                                                    LPARAM lParam)
{
    BOOL bRet = TRUE;

    switch(uMsg)
    {
    default:
        bRet = FALSE;
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDNEXT:
            EndDialog(hwnd,IDC_CMDNEXT);
            break;
        case IDC_CMDCANCEL:
            EndDialog(hwnd,IDC_CMDCANCEL);
            break;
        }
        break;
    case WM_INITDIALOG:
        MakeBold(GetDlgItem(hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);
        break;
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwnd,IDC_LBLTITLE));

        bRet = FALSE;
        break;
    }
    return bRet;
}

/*
// ############################################################################
BOOL CALLBACK ContextDlgProc(HWND  hwnd,UINT  uMsg,WPARAM  wParam,LPARAM lParam)
{
    LRESULT lRet = TRUE;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        MakeBold (GetDlgItem(hwnd, IDC_LBLARROW3NUM), FALSE, FW_BOLD);
        MakeBold (GetDlgItem(hwnd, IDC_LBLARROW3TEXT), FALSE, FW_BOLD);
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_CMDHELP:
            WinHelp(hwnd,TEXT("connect.hlp>proc4"),HELP_CONTEXT,(DWORD)idh_icwoverview);
            break;
        }
        break;
    case WM_QUIT:
        PostQuitMessage(0);
        break;
    default:
        lRet = FALSE;
        break;
    }
    return lRet;
}
*/

/*
// ############################################################################
BOOL CALLBACK BackDlgProc(
    HWND  hwndDlg,  // handle to dialog box
    UINT  uMsg, // message
    WPARAM  wParam, // first message parameter
    LPARAM  lParam  // second message parameter
   )
{
    HDC hdc;
    LRESULT lRet = TRUE;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // SET WINDOW TEXT HERE
        hbBackBrush = (HBRUSH)(COLOR_BACKGROUND + 1);
        break;
    case WM_SIZE:
        GetClientRect(hwndDlg,&rect);
        lRet = FALSE;   // enable default processing
        break;
    case WM_CLOSE:
        //PostQuitMessage(0);
        //EndDialog(hwndDlg,FALSE);
        break;
    case WM_PAINT:
        hdc = GetDC(hwndDlg);
        FillRect(hdc,&rect,hbBackBrush);
        ReleaseDC(hwndDlg,hdc);
        lRet = 0;
        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }
    return lRet;
}
*/



// ############################################################################
void CALLBACK ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    LPTSTR pszStatus = NULL;
    int prc;
    static BOOL bMessageSet = FALSE;

    switch(dwInternetStatus)
    {
    case 99:
        prc = *(int*)lpvStatusInformation;
        
        if (!g_bProgressBarVisible)
        {
            ShowWindow(GetDlgItem(SPParams.hwnd,IDC_PROGRESS),SW_SHOW);
            g_bProgressBarVisible = TRUE;
        }

        SendDlgItemMessage(SPParams.hwnd,
                IDC_PROGRESS,
                PBM_SETPOS,
                (WPARAM)prc,
                0);
        if (!bMessageSet)
        {
            bMessageSet = TRUE;
            pszStatus = GetSz(IDS_RECEIVING_RESPONSE);
        }
        break;
    }
    if (pszStatus)
       SetDlgItemText(SPParams.hwnd,IDC_LBLSTATUS,pszStatus);
}



// ############################################################################
DWORD WINAPI ThreadInit()
{
    HINSTANCE hDLDLL;
    HINSTANCE hADDll = NULL;
    FARPROC fp;
    HRESULT hr;
    
    hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);

    if (!hDLDLL)
    {
        hr = GetLastError();
        goto ThreadInitExit;
    }

    // Set up for download
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADINIT);
    AssertSz(fp,"DownLoadInit API missing");
    dwDownLoad = 0;
    hr = ((PFNDOWNLOADINIT)fp)(pszSetupClientURL, &dwDownLoad, g_hDialDlgWnd);
    if (hr != ERROR_SUCCESS) goto ThreadInitExit;

    // Set up progress call back
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADSETSTATUS);
    Assert(fp);
    hr = ((PFNDOWNLOADSETSTATUS)fp)(dwDownLoad, &ProgressCallBack);

    // Download stuff
    //

    fp = GetProcAddress(hDLDLL,DOWNLOADEXECUTE);
    Assert(fp);
    hr = ((PFNDOWNLOADEXECUTE)fp)(dwDownLoad);
    // if there is an error, we still have to take down the window and
    // release the WinInet Internet handle.

    if (hr == ERROR_SUCCESS)
    {
        fp = GetProcAddress(hDLDLL,DOWNLOADPROCESS);
        Assert(fp);
        hr = ((PFNDOWNLOADPROCESS)fp)(dwDownLoad);
    }

    fp = GetProcAddress(hDLDLL,DOWNLOADCLOSE);
    Assert(fp);
    ((PFNDOWNLOADCLOSE)fp)(dwDownLoad);
    dwDownLoad = 0;

ThreadInitExit:
    PostMessage(SPParams.hwnd,WM_DOWNLOAD_DONE,0,0);
    if (hDLDLL) FreeLibrary(hDLDLL);
    if (hADDll) FreeLibrary(hADDll);
    return hr;
}

HRESULT HangUpAll()
{
    LPRASCONN lprasconn;
    DWORD cb;
    DWORD cConnections;
    DWORD idx;
    HRESULT hr;

    hr = ERROR_NOT_ENOUGH_MEMORY;

    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    if (!lprasconn) goto SkipHangUp;
    cb = sizeof(RASCONN);
    cConnections = 0;
    lprasconn->dwSize = cb;

    //if(RasEnumConnections(lprasconn,&cb,&cConnections))
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,(size_t)cb);
      
        if (!lprasconn) goto SkipHangUp;

        lprasconn->dwSize = cb;
        RasEnumConnections(lprasconn,&cb,&cConnections);
    }

    if (cConnections)
    {
        for (idx = 0; idx<cConnections; idx++)
        {
            RasHangUp(lprasconn[idx].hrasconn);
            WaitForConnectionTermination(lprasconn[idx].hrasconn);
        }
    }
    if (lprasconn) GlobalFree(lprasconn);
    hr = ERROR_SUCCESS;

SkipHangUp:
    return hr;
}



// ############################################################################
BOOL FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}



// ############################################################################
HRESULT CallDownLoad(LPTSTR pszUrl, HINSTANCE hInst)
{
    FARPROC fp = NULL;
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD dwType=0;
    DWORD dwSize=0;
    GATHEREDINFO gi;
    LPTSTR pszConnectoid=NULL;
    BOOL fEnabled;
    HINSTANCE hInet = NULL;
    INT cRetry;
    TCHAR szCallHomeMsg[CALLHOME_SIZE];
    DWORD dwCMRet = NULL;

    // 11/25/96 jmazner Normandy #12109
    // load in connectoid name before we get to ShowExploreNow

    //// BUG: If isignup keep creating unique filenames, this will only
    //// find the first connectoid created for this ISP.
    ////
    //
    pszConnectoid = (LPTSTR)GlobalAlloc(GPTR,RAS_MaxEntryName + 1);
    if (!pszConnectoid)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto CallDownLoadExit;
    }
    
    hInet = LoadLibrary(TEXT("INETCFG.DLL"));
    if (!hInet)
    {
        AssertSz(0,"Failed to load inetcfg.dll.\r\n");
        hr = GetLastError();
        goto CallDownLoadExit;
    }

    fp = GetProcAddress(hInet,"InetGetAutodial");
    if (!fp)
    {
        AssertSz(0,"Failed to load InetGetAutodial.\r\n");
        hr = GetLastError();
        goto CallDownLoadExit;
    }

    //
    // Get name of autodial connectoid
    //
    fEnabled = FALSE;
    hr = ((PFNINETGETAUTODIAL)fp)(&fEnabled,pszConnectoid,RAS_MaxEntryName);
    if ( hr != ERROR_SUCCESS)
        goto CallDownLoadExit;

    if (hInet) FreeLibrary(hInet);
    hInet = NULL;
    fp = NULL;

    Dprintf(TEXT("CONNECT2: call back using the '%s' connectoid.\n"),pszConnectoid);


    if (pszUrl[0] == '\0')
    {
        Dprintf(TEXT("CONNECT2: Client setup URL in .ins file is empty.\n"));
        goto ShowExploreNow;
    }

    SPParams.hwnd = NULL;
    SPParams.hwndParent = NULL;
    SPParams.hinst = hInst;

    //
    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr == ERROR_SUCCESS)
    {
        dwType = REG_BINARY;
        dwSize = sizeof(gi);
        ZeroMemory(&gi,sizeof(gi));
        hr = RegQueryValueEx(hKey,GATHERINFOVALUENAME,0,&dwType,(LPBYTE)&gi,&dwSize);

        RegCloseKey(hKey);
        hKey = NULL;
    }  else {
        goto CallDownLoadExit;
    }   

    ZeroMemory(szCallHomeMsg,CALLHOME_SIZE);

    GetPrivateProfileString(
        INSFILE_APPNAME,INFFILE_ISPSUPP,
        NULLSZ,szCallHomeMsg,CALLHOME_SIZE,pszINSFileName);

TryDial:
    cRetry = 0;
TryRedial:
        //
        // ChrisK 8/20/97
        // Pass .ins file to dialer so that the dialer can find the password
        //
    hr = ShowDialingDialog(pszConnectoid, &gi, pszUrl, hInst, NULL, pszINSFileName);
    cRetry++;
    
    if ((cRetry < MAX_RETIES) && FShouldRetry(hr))
        goto TryRedial;

    if (hr != ERROR_USERNEXT)
    {
        if (!uiSetupClientNewPhoneCall)
        {
            hr = ShowDialReallyCancelDialog(hInst, NULL, szCallHomeMsg);
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else if (hr == ERROR_USERCANCEL)
                goto CallDownLoadExit;
        } else {
            if (RASBASE > hr || RASBASEEND < hr)
                hr = ERROR_DOWNLOADDIDNT;
            hr = ShowDialErrDialog(&gi, hr, pszConnectoid, hInst, NULL);
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else 
            {
                hr = ShowDialReallyCancelDialog(hInst, NULL, szCallHomeMsg);
                if (hr == ERROR_USERNEXT)
                    goto TryDial;
                else if (hr == ERROR_USERCANCEL)
                    goto CallDownLoadExit;
            }
        }
    }

    //
    // Determine if we should hang up
    //
    
ShowExploreNow:
    if (0 == uiSetupClientNewPhoneCall)
    {
        HangUpAll();
    }
    //
    // 1/8/96 jmazner Normanmdy #12930
    // function moved to isign32.dll
    //

    //
    // 5/9/97 jmazner Olympus #416
    //
    dwCMRet = CallCMConfig(pszINSFileName, pszConnectoid);
    switch( dwCMRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_MOD_NOT_FOUND:
        case ERROR_DLL_NOT_FOUND:
            Dprintf(TEXT("ICWCONN2: CMCFG32 DLL not found, I guess CM ain't installed.\n"));
            break;
        default:
            //ErrorMsg(hwnd, IDS_SBSCFGERROR);
            break;
    }

    if (g_fNeedReboot){
        int iReturnCode = 0;


        iReturnCode = (int)DialogBox(hInst,MAKEINTRESOURCE(IDD_DONEREBOOT),
                                    NULL,DoneRebootDlgProc); 
        
        switch(iReturnCode)
        {
            case IDC_CMDEXPLORE:
                ExitWindowsEx(EWX_REBOOT,0);
                break;
            case IDC_CMDCLOSE:
                HangUpAll();
                break;
        }
    } else { 
        int iReturnCode = 0;

        iReturnCode = (int)DialogBox(hInst,MAKEINTRESOURCE(IDD_DONE),
                                    NULL,DoneDlgProc); 
    
        switch(iReturnCode)
        {
        case IDC_CMDEXPLORE:
            GetPrivateProfileString(
                        INSFILE_APPNAME,INFFILE_EXPLORE_CMD,
                        NULLSZ,szBuff256,255,pszINSFileName);
            My32ShellExecute(szBuff256);
            break;
        case IDC_CMDCLOSE:
            HangUpAll();
            break;
        }
    }

CallDownLoadExit:
    if (pszConnectoid)
        GlobalFree(pszConnectoid);
    pszConnectoid = NULL;
    return hr;
}

// ############################################################################
HRESULT FindCurrentConn ()
{
    LPRASCONN lprasconn = NULL;
    DWORD   cb = sizeof(RASCONN);
    DWORD   cConnections = 0;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    unsigned int idx;
    
    lprasconn = (LPRASCONN)GlobalAlloc(GPTR,sizeof(RASCONN));
    if (!lprasconn) goto FindCurrentConnExit;
    lprasconn[0].dwSize = sizeof(RASCONN);

    if(RasEnumConnections(lprasconn,&cb,&cConnections))
    {
        GlobalFree(lprasconn);
        lprasconn = (LPRASCONN)GlobalAlloc(GPTR,(size_t)cb);
      if (!lprasconn) goto FindCurrentConnExit;
        RasEnumConnections(lprasconn,&cb,&cConnections);
    }

    if (pszFinalConnectoid[0] != '\0')
    {
        if (cConnections)
        {
            for (idx = 0; idx<cConnections; idx++)
            {
                if (lstrcmpi(lprasconn[idx].szEntryName,pszFinalConnectoid)==0)
                {
                    hrasconn = lprasconn[idx].hrasconn;
                    break;
                }
            }
            if (!hrasconn) goto FindCurrentConnExit;
        }
    } else {
        // if they don't tell us the connectoid on the command line
        // we assume there is only one and the first one is the one we are going to use!!
        if (cConnections)
        {
            lstrcpyn(pszFinalConnectoid,lprasconn[0].szEntryName,sizeof(pszFinalConnectoid)/sizeof(TCHAR));
            hrasconn = lprasconn[0].hrasconn;
        }
    }

    hr = ERROR_SUCCESS;
FindCurrentConnExit:
    if (lprasconn) GlobalFree(lprasconn);
    return hr;
}

// ############################################################################
HRESULT CopyCmdLineData (LPTSTR pszCmdLine, LPTSTR pszField, LPTSTR pszOut)
{
    HRESULT hr = ERROR_SUCCESS;
    TCHAR *s;
    TCHAR *t;
    BOOL fQuote = FALSE;

    s = _tcsstr(pszCmdLine,pszField);
    if (s)
    {
        s += lstrlen(pszField);
        t = pszOut;
        *t = '\0';
        if (fQuote =(*s == '"'))
            s++;

        while (*s && 
                ((*s != ' ' && !fQuote)
            ||   (*s != '"' && fQuote )))       // copy until the end of the string or a space char
        {
            *t = *s;
            t++;
            s++;
        }
        *t = '\0';  // add null terminator
    } 
    else 
    {
        hr = ERROR_INVALID_PARAMETER;
    }

    return hr;
}

// ############################################################################
HRESULT ParseCommandLine(LPTSTR pszCmdLine)
{
    HRESULT hr;
    
    // jmazner 10/15/96  make parsing of cmd line options case insensitive
    CharUpper( pszCmdLine );

    g_fNeedReboot = (_tcsstr(pszCmdLine, CMD_REBOOT) != NULL);
    
    hr = CopyCmdLineData (pszCmdLine, CMD_CONNECTOID, &pszFinalConnectoid[0]);
    if (hr != ERROR_SUCCESS) pszFinalConnectoid[0] = '\0';
    hr = CopyCmdLineData (pszCmdLine, CMD_INS, &pszINSFileName[0]);
//ParseCommandLineExit:
    return hr;
}

// ############################################################################
HRESULT DeleteIRN()
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    TCHAR szRasEntry[MAX_RASENTRYNAME+1];
    RNAAPI *pRnaapi = NULL;

    pRnaapi = new RNAAPI;
    if(!pRnaapi)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwSize = sizeof(szRasEntry);
    dwType = REG_SZ;
    hKey = NULL;  
    
    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);

    ZeroMemory(szRasEntry,sizeof(szRasEntry));

    if (hr == ERROR_SUCCESS)
    {
        hr = RegQueryValueEx(hKey,RASENTRYVALUENAME,NULL,&dwType,(LPBYTE)szRasEntry,&dwSize);
        //if (hr == ERROR_SUCCESS && fp)
        if (hr == ERROR_SUCCESS)
            pRnaapi->RasDeleteEntry(NULL, szRasEntry);
    }
    if (hKey) RegCloseKey(hKey);
    //if (hDLL) FreeLibrary(hDLL);
    if (pRnaapi)
    {
        delete pRnaapi;
        pRnaapi = NULL;
    }
    hKey = NULL;
    

    return hr;
}

// ############################################################################
int WINAPI WinMain(
    HINSTANCE  hInstance,   // handle to current instance
    HINSTANCE  hPrevInstance,   // handle to previous instance
    LPSTR  lpCmdLine,   // pointer to command line
    int  nShowCmd   // show state of window
   )
{
    int     irc = 1;
    BOOL    fHangUp = TRUE;
    HKEY    hkey = NULL;

    RNAAPI  *pRnaapi = NULL;

#ifdef UNICODE
    // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    // Initialize globals
    //
    ZeroMemory(pszINSFileName,MAX_PATH+1);
    ZeroMemory(pszFinalConnectoid,MAX_PATH+1);
    ZeroMemory(pszSetupClientURL,1024);


    // 12/3/96  jmazner Normandy #12140, 12088
    // create a semaphore to signal other icw components that we're running
    // Since conn2 is not single instance (see semaphor.h), we don't care if
    // the semaphore already exists.
    HANDLE  hSemaphore = NULL;

    hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);


    hrasconn = NULL;
    uiSetupClientNewPhoneCall = FALSE;
    fUserCanceled = FALSE;
    dwDownLoad = 0;
    g_bProgressBarVisible =FALSE;

    
    //
    // Delete referal service connectoid
    //
    DeleteIRN();

    //
    // Parse command line
    //
    if (ParseCommandLine(GetCommandLine()) != ERROR_SUCCESS)
    {
        irc = 2;
        Dprintf(TEXT("ICWCONN2: Malformed cmd line '%s'\n"), lpCmdLine);
        AssertSz(0,"Command Line parsing failed\r\n.");

        //CHAR szTemp[2048] = "not initialized\0";
        //wsprintf(szTemp, GetSz(IDS_BAD_CMDLINE), lpCmdLine);
        MessageBox(NULL,GetSz(IDS_BAD_CMDLINE),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
        goto WinMainExit;
    }

    g_bINSFileExists = TRUE;
    
    if( !FileExists(pszINSFileName) )
    {
        g_bINSFileExists = FALSE;
        irc = 2;
        TCHAR *pszTempBuff = NULL;
        TCHAR *pszErrString = NULL;
        DWORD dwBuffSize = 0;

        pszErrString = GetSz(IDS_MISSING_FILE);
        // If we can't access a resource string, we may as well just give up and quit silently
        if( !pszErrString ) goto WinMainExit;

        dwBuffSize = MAX_PATH + lstrlen( pszErrString ) + 3; //two quotes and terminating null
        pszTempBuff = (TCHAR *)GlobalAlloc( GPTR, dwBuffSize );

        if( !pszTempBuff )
        {
            MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
            goto WinMainExit;
        }

        wsprintf(pszTempBuff, pszErrString);
        lstrcat(pszTempBuff, TEXT("\""));
        lstrcat(pszTempBuff, pszINSFileName);
        lstrcat(pszTempBuff, TEXT("\""));

        MessageBox(NULL,pszTempBuff,GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);

        GlobalFree(pszTempBuff);
        pszTempBuff = NULL;

        goto WinMainExit;
    }


    //
    // Find the handle to the current connection
    //
    if (FindCurrentConn() != ERROR_SUCCESS)
    {
        irc = 2;
        AssertSz(0,"Finding current connection failed\r\n.");
        goto WinMainExit;
    }

    
    
    //
    // Get SetUp Client URL
    //
    GetPrivateProfileString(
        INSFILE_APPNAME,INFFILE_SETUP_CLIENT_URL,
        NULLSZ,pszSetupClientURL,1024,pszINSFileName);

    //if (pszSetupClientURL[0])
    //{
        uiSetupClientNewPhoneCall = GetPrivateProfileInt(
            INSFILE_APPNAME,INFFILE_SETUP_NEW_CALL,0,pszINSFileName);
        if (uiSetupClientNewPhoneCall == 1 && hrasconn)
        {
            RasHangUp(hrasconn);
            WaitForConnectionTermination(hrasconn);

            pRnaapi = new RNAAPI;
            if(!pRnaapi)
            {
                MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
                goto WinMainExit;
            }

            pRnaapi->RasDeleteEntry(NULL,pszFinalConnectoid);

            pszFinalConnectoid[0] = '\0';
            hrasconn = NULL;
        }

        CallDownLoad(&pszSetupClientURL[0],hInstance);
                
    //}
    //else
    //{
    //  if (hrasconn) 
    //  {
    //      RasHangUp(hrasconn);
    //      Sleep(3000);
    //  }
    //}

WinMainExit:
    hkey = NULL;
    if ((RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hkey)) == ERROR_SUCCESS)
    {
        RegDeleteValue(hkey,GATHERINFOVALUENAME);
        RegCloseKey(hkey);
    } 

    if (g_bINSFileExists && pszINSFileName)
    {
        if (pszINSFileName[0] != '\0')
        {
            DeleteFileKindaLikeThisOne(pszINSFileName);
        }
    }
    Dprintf(TEXT("CONNECT2:Quitting WinMain.\n"));
    if (hrasconn) 
    {
        RasHangUp(hrasconn);

        if (pszFinalConnectoid[0])
        {
            if(!pRnaapi)
            {
                pRnaapi = new RNAAPI;
                if(!pRnaapi)
                {
                    // no point in notifying user with message, we're quitting anyways
                    Dprintf(TEXT("ICWCONN2: couldn't allocate pRnaapi memory in WinMainExit\n"));
                }
                else
                {
                    pRnaapi->RasDeleteEntry(NULL,pszFinalConnectoid);
                }

            }

        }
        pszFinalConnectoid[0] = '\0';

        WaitForConnectionTermination(hrasconn);
        hrasconn = NULL;
    }

    if (g_pdevice) GlobalFree(g_pdevice);

    ExitProcess(0);

    if (pRnaapi)
    {
        delete pRnaapi;
        pRnaapi = NULL;
    }

    if( hSemaphore )
        CloseHandle( hSemaphore );

    return irc;
}

static const TCHAR cszBrandingSection[] = TEXT("Branding");
static const TCHAR cszBrandingServerless[] = TEXT("Serverless");
// ############################################################################
// This function serve the single function of cleaning up after IE3.0, because
// IE3.0 will issue multiple POST and get back multiple .INS files.  These files
// contain sensative data that we don't want lying arround, so we are going out,
// guessing what their names are, and deleting them.
HRESULT DeleteFileKindaLikeThisOne(LPTSTR lpszFileName)
{
    LPTSTR lpNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    WORD wRes = 0;
    HANDLE hFind = NULL;
    WIN32_FIND_DATA sFoundFile;
    TCHAR szPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH + 1];
    LPTSTR lpszFilePart = NULL;

    // Validate parameter
    //

    if (!lpszFileName || lstrlen(lpszFileName) <= 4)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DeleteFileKindaLikeThisOneExit;
    }

    // Check for serverless signup
    if (0 != GetPrivateProfileInt(cszBrandingSection,cszBrandingServerless,0,lpszFileName))
        goto DeleteFileKindaLikeThisOneExit;

    // Determine the directory name where the INS files are located
    //

    ZeroMemory(szPath,MAX_PATH);
    if (GetFullPathName(lpszFileName,MAX_PATH,szPath,&lpszFilePart))
    {
        *lpszFilePart = '\0';
    } else {
        hr = GetLastError();
        goto DeleteFileKindaLikeThisOneExit;
    };

    // Munge filename into search parameters
    //

    lpNext = &lpszFileName[lstrlen(lpszFileName)-4];

    if (CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,lpNext,4,TEXT(".INS"),4) != 2) goto DeleteFileKindaLikeThisOneExit;

    ZeroMemory(szSearchPath,MAX_PATH + 1);
    lstrcpyn(szSearchPath,szPath,MAX_PATH);
    lstrcat(szSearchPath,TEXT("*.INS"));

    // Start wiping out files
    //

    ZeroMemory(&sFoundFile,sizeof(sFoundFile));
    hFind = FindFirstFile(szSearchPath,&sFoundFile);
    if (hFind)
    {
        do {
            lstrcpy(lpszFilePart,sFoundFile.cFileName);
            SetFileAttributes(szPath,FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szPath);
            ZeroMemory(&sFoundFile,sizeof(sFoundFile));
        } while (FindNextFile(hFind,&sFoundFile));
        FindClose(hFind);
    }

    hFind = NULL;

DeleteFileKindaLikeThisOneExit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   StrDup
//
//  Synopsis:   Duplicate given string
//
//  Arguments:  ppszDest - pointer to pointer that will point to string
//              pszSource - pointer to the string to be copied
//
//  Returns:    NULL - failure
//              Pointer to duplicate - success
//
//  History:    7/26/96 ChrisK  Created
//
//-----------------------------------------------------------------------------
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource)
{
    if (ppszDest && pszSource)
    {
        *ppszDest = (LPTSTR)GlobalAlloc(NONZEROLPTR,lstrlen(pszSource)+1);
        if (*ppszDest)
            return (lstrcpy(*ppszDest,pszSource));
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   FileExists
//
//  Synopsis:   Uses FindFirstFile to determine whether a file exists on disk
//
//  Arguments:  None
//
//  Returns:    TRUE - Found the file on disk
//              FALSE - No file found
//
//  History:    jmazner     Created     9/11/96  (as fix for Normandy #7020)
//
//-----------------------------------------------------------------------------

BOOL FileExists(TCHAR *pszINSFileName)
{

    Assert (pszINSFileName);

    HANDLE hFindResult;
    WIN32_FIND_DATA foundData;
    
    hFindResult = FindFirstFile( (LPCTSTR)pszINSFileName, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult)
    {
        return( FALSE );
    } 
    else
    {
        return(TRUE);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CallCMConfig
//
//  Synopsis:   Call into the CMCFG32 dll's Configure function to allow Connection
//              manager to process the .ins file as needed
//
//  Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//              lpszINSFile -- full path to the .ins file
//
//  Returns:    windows error code that cmcfg32 returns.
//
//  History:    2/19/97 jmazner Created for Olympus #1106 (as CallSBSCfg )
//              5/9/97  jmazner Stolen from isign32 for Olympus #416
//
//-----------------------------------------------------------------------------
DWORD CallCMConfig(LPCTSTR lpszINSFile, LPTSTR lpszConnectoidName)
{
    HINSTANCE hCMDLL = NULL;
    DWORD dwRet = ERROR_SUCCESS;

    TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
    CHAR  FAR cszCMCFG_CONFIGURE[] = "_CMConfig@8\0";
    typedef DWORD (WINAPI * CMCONFIGURE) (LPTSTR lpszINSFile, LPTSTR lpszConnectoidName);
    CMCONFIGURE  lpfnConfigure = NULL;

    Dprintf(TEXT("ICWCONN2: Calling LoadLibrary on %s\n"), cszCMCFG_DLL);
    hCMDLL = LoadLibrary(cszCMCFG_DLL);

    //
    // Load DLL and entry point
    //
    if (NULL != hCMDLL)
    {
        Dprintf(TEXT("ICWCONN2: Calling GetProcAddress on %s\n"), cszCMCFG_CONFIGURE);
        lpfnConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
    }
    else
    {
        //
        // 4/2/97   ChrisK  Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        //
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallCMConfigExit;
    }
    
    //
    // Call function
    //
    if( hCMDLL && lpfnConfigure )
    {
        Dprintf(TEXT("ICWCONN2: Calling the %d entry point\n"), cszCMCFG_CONFIGURE);
        dwRet = lpfnConfigure((TCHAR *)lpszINSFile, lpszConnectoidName); 
    }
    else
    {
        Dprintf(TEXT("ICWCONN2: Unable to call the Configure entry point\n"));
        dwRet = GetLastError();
    }

CallCMConfigExit:
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    Dprintf(TEXT("ICWCONN2: CallCMConfig exiting with error code %d \n"), dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\ras2.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
					  
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
	rnaapi.cpp

	Wrapper to softlink to RNAPH and RASAPI32.DLL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		1/29/96		ChrisK	Created
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"
#if defined(WIN16)
#include <memory.h>
#endif

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");
static const TCHAR cszRAS16[] = TEXT("RASC16IE.DLL");

static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasSetAutodialEnablePlain[] = "RasSetAutodialEnable";

#ifdef UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryW";
static const CHAR cszRasHangUp[] = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusW";
static const CHAR cszRasDial[] = "RasDialW";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoW";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
static const CHAR cszRasSetAutodialEnable[] = "RasSetAutodialEnableW";
static const CHAR cszRasSetAutodialAddress[] = "RasSetAutodialAddressW";
#else  // UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryA";
static const CHAR cszRasHangUp[] = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusA";
static const CHAR cszRasDial[] = "RasDialA";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoA";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
static const CHAR cszRasSetAutodialEnable[] = "RasSetAutodialEnableA";
static const CHAR cszRasSetAutodialAddress[] = "RasSetAutodialAddressA";
#endif // UNICODE

#if defined(WIN16)
// on Win3.x we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// Who knows why.  It isn't exactly the same bug as on NT, but similar.  If the buffer
// isn't larger, RasGetEntryProperties overwrites the buffer and eventually will
// cause unexpected behavior such as GPFs and spontaeous reboots of the system.
//
#define RASENTRY_SIZE_PATCH 256
#else
// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))
#endif

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RNAAPI
//
//	Synopsis:	Initialize class members and load DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
#if defined(WIN16)
	m_hInst = LoadLibrary(cszRAS16); 
	m_hInst2 = NULL;
#else
	m_hInst = LoadLibrary(cszRASAPI32_DLL);
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
	    m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif
	

	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
	m_fnRasDeleteEntry = NULL;
	m_fnRasHangUp = NULL;
	m_fnRasGetConnectStatus = NULL;
	m_fnRasEnumConnections = NULL;
	m_fnRasDial = NULL;
	m_fnRasGetEntryDialParams = NULL;
	m_fnRasGetCountryInfo = NULL;
	m_fnRasSetEntryDialParams = NULL;
	m_fnRasSetAutodialEnable = NULL;
#if !defined(WIN16)
	m_fnRasSetAutodialAddress = NULL;
#endif
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::~RNAAPI
//
//	Synopsis:	release DLLs
//
//	Arguments:	None
//
//	Returns:	None
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
	//
	// Clean up
	//
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasEnumDevices
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::LoadApi
//
//	Synopsis:	If the given function pointer is NULL, then try to load the API
//				from the first DLL, if that fails, try to load from the second
//				DLL
//
//	Arguments:	pszFName - the name of the exported function
//				pfnProc - point to where the proc address will be returned
//
//	Returns:	TRUE - success
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetConnectStatus
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

	if (m_fnRasGetConnectStatus)
		dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

#if defined(WIN16) && defined(DEBUG)
	Dprintf("RasGetConnectStatus returned %lu\r\n", dwRet);	
#endif
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasValidateEntryName
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

	LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	RASENTRY FAR *lpRE = NULL;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

	Assert(
		(NULL != lpbDeviceInfo) && (NULL != dwDeviceInfoSize)
		||
		(NULL == lpbDeviceInfo) && (NULL == dwDeviceInfoSize)
		);

#if !defined(WIN16)
#define RASGETCOUNTRYINFO_BUFFER_SIZE 256
	// Only worry about valid countryCode and countryID if we're not dial-as-is
	if ( (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode) &&
		 (((LPRASENTRY)lpbEntryInfo)->dwfOptions & RASEO_UseCountryAndAreaCodes) )
	{
		BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
		LPRASCTRYINFO prasCI;
		DWORD dwSize;
		DWORD dw;
		prasCI = (LPRASCTRYINFO)rasCI;
		ZeroMemory(prasCI,sizeof(rasCI));
		prasCI->dwSize = sizeof(RASCTRYINFO);
		dwSize = sizeof(rasCI);

		Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
		prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

		dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
		if (ERROR_SUCCESS == dw)
		{
			Assert(prasCI->dwCountryCode);
			((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
		} 
		else
		{
			AssertSz(0,"Unexpected error from RasGetCountryInfo.\r\n");
		}
	}
#endif

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);
	lpRE = (RASENTRY FAR*)lpbEntryInfo;
#if !defined(WIN16)
	LclSetEntryScriptPatch(lpRE->szScript,lpszEntry);
#endif

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetEntryProperties
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//				jmazner	9/17/96 Modified to allow calls with buffers = NULL and InfoSizes = 0.
//								(Based on earlier modification to the same procedure in icwdial)
//				                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;
	LPBYTE lpbEntryInfoPatch = NULL;
	LPDWORD  lpdwEntryInfoPatchSize = 0;

#if (!defined(WIN16) && WINVER != 0x400)
#error This was built with WINVER not equal to 0x400.  The size of RASENTRY may not be valid.
#endif

	if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
	{
		Assert( NULL != lpdwEntryInfoSize );
		Assert( NULL != lpdwDeviceInfoSize );

		Assert( 0 == *lpdwEntryInfoSize );
		Assert( 0 == *lpdwDeviceInfoSize );

		// we're here to ask RAS what size these buffers need to be, don't use the patch stuff
		// (see RasGetEntryProperties docs)
		lpbEntryInfoPatch = lpbEntryInfo;
		lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
	}
	else
	{

		Assert((*lpdwEntryInfoSize) >= sizeof(RASENTRY));
		Assert(lpbEntryInfo && lpdwEntryInfoSize);

		//
		// We are going to fake out RasGetEntryProperties by creating a slightly larger
		// temporary buffer and copying the data in and out.
		//
		lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
		if (NULL == lpdwEntryInfoPatchSize)
			return ERROR_NOT_ENOUGH_MEMORY;

		*lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
		lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
		if (NULL == lpbEntryInfoPatch)
			return ERROR_NOT_ENOUGH_MEMORY;

		// RAS expects the dwSize field to contain the size of the LPRASENTRY struct
		// (used to check which version of the struct we're using) rather than the amount
		// of memory actually allocated to the pointer.
#if defined(WIN16)
		//((LPRASENTRY)lpbEntryInfoPatch)->dwSize = ((LPRASENTRY)lpbEntryInfo)->dwSize;
		((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
#else
				// RAS expects the dwSize field to contain the size of the LPRASENTRY struct
		// (used to check which version of the struct we're using) rather than the amount
		// of memory actually allocated to the pointer.
		//((LPRASENTRY)lpbEntryInfoPatch)->dwSize = dwEntryInfoPatch;
		((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);

#endif
	}

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	Dprintf(TEXT("ICWCONN2: RasGetEntryProperties returned %lu\r\n"), dwRet);	

	if( NULL != lpbEntryInfo )
	{
		//
		// Copy out the contents of the temporary buffer UP TO the size of the original buffer
		//
		Assert(lpbEntryInfoPatch);
		memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
		GlobalFree(lpbEntryInfoPatch);
		lpbEntryInfoPatch = NULL;

		if( lpdwEntryInfoPatchSize )
		{
			GlobalFree( lpdwEntryInfoPatchSize );
			lpdwEntryInfoPatchSize = NULL;
		}
		//
		// We are again faking Ras functionality here by over writing the size value;
		// This is neccesary due to a bug in the NT implementation of RasSetEntryProperties
		*lpdwEntryInfoSize = sizeof(RASENTRY);
	}

	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasDeleteEntry
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

	if (m_fnRasDeleteEntry)
		dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
	
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasHangUp
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

	if (m_fnRasHangUp)
	{
		dwRet = (*m_fnRasHangUp) (hrasconn);
#if !defined(WIN16)
		Sleep(3000);
#endif
	}

	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
					  LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
					  LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

	if (m_fnRasDial)
	{
		dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
								dwNotifierType,lpvNotifier,lphRasConn);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

	if (m_fnRasEnumConnections)
	{
		dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
	}
	return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
									LPBOOL lpfPassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

	if (m_fnRasGetEntryDialParams)
	{
		dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasGetCountryInfo
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

	if (m_fnRasGetCountryInfo)
	{
		dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetEntryDialParams
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	ChrisK	Created		8/20/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
							BOOL fRemovePassword)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetEntryDialParams,(FARPROC*)&m_fnRasSetEntryDialParams);

	if (m_fnRasSetEntryDialParams)
	{
		dwRet = (*m_fnRasSetEntryDialParams) (lpszPhonebook,lprasdialparams,
							fRemovePassword);
	}
	return dwRet;
}

//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetAutodialEnable
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	jmazner	Created		10/8/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetAutodialEnable (DWORD dwDialingLocation, BOOL fEnabled)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetAutodialEnablePlain,(FARPROC*)&m_fnRasSetAutodialEnable);

	if (m_fnRasSetAutodialEnable)
	{
		dwRet = (*m_fnRasSetAutodialEnable) (dwDialingLocation, fEnabled);
	}
	return dwRet;

}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//	Function:	RNAAPI::RasSetAutodialAddress
//
//	Synopsis:	Softlink to RAS function
//
//	Arguments:	see RAS documentation
//
//	Returns:	see RAS documentation
//
//	History:	jmazner	Created		10/8/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetAutodialAddress(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi(cszRasSetAutodialAddress,(FARPROC*)&m_fnRasSetAutodialAddress);

	if (m_fnRasSetAutodialAddress)
	{
		dwRet = (*m_fnRasSetAutodialAddress) (lpszAddress,dwReserved, lpAutoDialEntries,
								dwcbAutoDialEntries,dwcAutoDialEntries);
	}
	return dwRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\rnaapi.h ===
// ############################################################################
#if !defined(WIN16)
#define RASAPI_LIBRARY TEXT("RASAPI32.DLL")
#define RNAPH_LIBRARY TEXT("RNAPH.DLL")
#else
#define RASAPI_LIBRARY "rasc16ie.dll"
#endif


#define RASAPI_RASSETENTRY "RasSetEntryPropertiesA"
#define RASAPI_RASGETENTRY "RasGetEntryPropertiesA"
#define RASAPI_RASDELETEENTRY "RasDeleteEntryA"

// ############################################################################
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASDELETEENTRY)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASHANGUP)(HRASCONN);

typedef DWORD (WINAPI* PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* PFNRASDIAL)(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI* PFNRASGETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,LPBOOL);
typedef DWORD (WINAPI* PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);
typedef DWORD (WINAPI* PFNRASGETCOUNTRYINFO)(LPRASCTRYINFO,LPDWORD);
typedef DWORD (WINAPI* PFNRASSETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,BOOL);
typedef DWORD (WINAPI* PFNRASSETAUTODIALENABLE)(DWORD dwDialingLocation, BOOL fEnabled);

#ifndef WIN16
typedef DWORD (WINAPI* PFNRASSETAUTODIALADDRESS)(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
#endif

// ############################################################################
class RNAAPI
{
public:
	RNAAPI();
	~RNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPTSTR,LPTSTR);
	DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
	DWORD RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
	DWORD RasHangUp(HRASCONN hrasconn);
	DWORD RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
								LPBOOL lpfPassword);
	DWORD RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
				  LPRASDIALPARAMS lpRasDialParams,DWORD dwNotifierType,LPVOID lpvNotifier,
				  LPHRASCONN lphRasConn);
	DWORD RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);
    DWORD RasGetConnectStatus(HRASCONN, LPRASCONNSTATUS);
    DWORD RasGetCountryInfo(LPRASCTRYINFO, LPDWORD);
    DWORD RasSetEntryDialParams(LPTSTR,LPRASDIALPARAMS,BOOL);
 	DWORD RasSetAutodialEnable (DWORD dwDialingLocation, BOOL fEnabled);
    
#ifndef WIN16
	DWORD RasSetAutodialAddress(LPTSTR lpszAddress,DWORD dwReserved, LPRASAUTODIALENTRY lpAutoDialEntries,
								DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
#endif

private:
	BOOL LoadApi(LPCSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
	PFNRASDELETEENTRY m_fnRasDeleteEntry;
	PFNRASHANGUP m_fnRasHangUp;
	PFNRASENUMCONNECTIONS m_fnRasEnumConnections;
	PFNRASDIAL m_fnRasDial;
	PFNRASGETENTRYDIALPARAMS m_fnRasGetEntryDialParams;
	PFNRASGETCONNECTSTATUS m_fnRasGetConnectStatus;
	PFNRASGETCOUNTRYINFO m_fnRasGetCountryInfo;
	PFNRASSETENTRYDIALPARAMS m_fnRasSetEntryDialParams;
	PFNRASSETAUTODIALENABLE m_fnRasSetAutodialEnable;

#ifndef WIN16
	PFNRASSETAUTODIALADDRESS m_fnRasSetAutodialAddress;
#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\rnawnd.cpp ===
/*----------------------------------------------------------------------------
    rnawnd.cpp
        
	Functions to zap the RNA windows 
	
    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
	ChrisK	Updated for ICW usage
  --------------------------------------------------------------------------*/

#include "pch.hpp"
#include "globals.h"

#define SMALLBUFLEN 48

/*******************************************************************
	NAME:		MinimizeRNAWindow
	SYNOPSIS:	Finds and minimizes the annoying RNA window
    ENTRY:		pszConnectoidName - name of connectoid launched
	NOTES:		Does a FindWindow on window class "#32770" (hard-coded
    			dialog box class which will never change), with
                the title "connected to <connectoid name>" or its
                localized equivalent.
********************************************************************/

static const TCHAR szDialogBoxClass[] = TEXT("#32770");	// hard coded dialog class name
HWND hwndFound = NULL;
DWORD dwRASWndTitleMinLen = 0;


BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
	TCHAR szTemp[SMALLBUFLEN+2];
	PTSTR pszTitle;
	UINT uLen1, uLen2;

	if(!IsWindowVisible(hwnd))
		return TRUE;
	if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE; // continue enumerating
	if(lstrcmp(szTemp, szDialogBoxClass)!=0)
		return TRUE;
	if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
		return TRUE;
	szTemp[SMALLBUFLEN] = 0;
	uLen1 = lstrlen(szTemp);
	Assert(dwRASWndTitleMinLen);
	if(uLen1 < dwRASWndTitleMinLen)
		return TRUE;
	// skip last 5 chars of title, but keep length to at least the min len
	uLen1 = min(dwRASWndTitleMinLen, (uLen1-5));
	pszTitle = (PTSTR)lparam;
	Assert(pszTitle);
	uLen2 = lstrlen(pszTitle);
	Dprintf(TEXT("Title=(%s), len=%d, Window=(%s), len=%d\r\n"), pszTitle, uLen2, szTemp, uLen1);
	if(uLen2 < uLen1)
		return TRUE;
	if(_memicmp(pszTitle, szTemp, uLen1)!=0)
		return TRUE;
	Dprintf(TEXT("FOUND RNA WINDOW!!!\r\n"));
	hwndFound = hwnd;
	return FALSE;
}

HWND MyFindRNAWindow(PTSTR pszTitle)
{
	DWORD dwRet;
	hwndFound = NULL;
	dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
	Dprintf(TEXT("EnumWindows returned %d\r\n"), dwRet);
	return hwndFound;
}

DWORD WINAPI WaitAndMinimizeRNAWindow(PVOID pTitle)
{
	// starts as a seperate thread
	int i;
	HWND hwndRNAApp;

	Assert(pTitle);
	
	for(i=0; !(hwndRNAApp=MyFindRNAWindow((PTSTR)pTitle)) && i<100; i++)
	{
		Dprintf(TEXT("Waiting for RNA Window\r\n"));
		Sleep(50);
	}

	Dprintf(TEXT("FindWindow (%s)(%s) returned %d\r\n"), szDialogBoxClass, pTitle, hwndRNAApp);

	if(hwndRNAApp)
	{
		// Hide the window
		// ShowWindow(hwndRNAApp,SW_HIDE);
		// Used to just minimize, but that wasnt enough
		// ChrisK reinstated minimize for ICW
		ShowWindow(hwndRNAApp,SW_MINIMIZE);
	}

	LocalFree(pTitle);
	// exit function and thread
	return ERROR_SUCCESS;
}

	
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst)
{
	HANDLE hThread;
	DWORD dwThreadId;
	
	Assert(pszConnectoidName);

	// alloc strings for title and format
	TCHAR * pFmt = (TCHAR*)LocalAlloc(LPTR, (SMALLBUFLEN+1) * sizeof(TCHAR));
	TCHAR * pTitle = (TCHAR*)LocalAlloc(LPTR, (RAS_MaxEntryName + SMALLBUFLEN + 1) * sizeof(TCHAR));
	if (!pFmt || !pTitle) 
		goto error;
	
	// load the title format ("connected to <connectoid name>" from resource
	Assert(hInst);
	LoadString(hInst, IDS_CONNECTED_TO, pFmt, SMALLBUFLEN);

	// get length of localized title (including the %s). Assume the unmunged
	// part of the window title is at least "Connected to XX" long.
	dwRASWndTitleMinLen = lstrlen(pFmt);

	// build the title
	wsprintf(pTitle, pFmt, pszConnectoidName);

	hThread = CreateThread(0, 0, &WaitAndMinimizeRNAWindow, pTitle, 0, &dwThreadId);
	Assert(hThread!=INVALID_HANDLE_VALUE && dwThreadId);
	// dont free pTitle. The child thread needs it!
	LocalFree(pFmt);
	// free the thread handle or the threads stack is leaked!
	CloseHandle(hThread);
	return;
	
error:
	if(pFmt)	LocalFree(pFmt);
	if(pTitle)	LocalFree(pTitle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwconn2\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn2

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN2


TARGETNAME=ICWCONN2
TARGETTYPE=PROGRAM
TARGETPATH=obj
UMTYPE=windows
UMENTRY=winmain
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES = -DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

386_STDCALL     = 0

SOURCES=            \
    ..\icwconn2.rc  \
    ..\rnawnd.cpp   \
    ..\debug.cpp    \
    ..\dialdlg.cpp  \
    ..\dialerr.cpp  \
    ..\dialcan.cpp  \
    ..\icwerr.cpp   \
    ..\rnaapi.cpp   \
    ..\main.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\rasapi32.lib      \
    $(SDK_LIB_PATH)\kernel32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\autodial.cpp ===
/*-----------------------------------------------------------------------------
    autodial.cpp

    Main entry point for autodial hook.

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"
#include "semaphor.h"

UINT g_cDialAttempts = 0;
UINT g_cHangupDelay = 0;
TCHAR g_szPassword[PWLEN + 1] = TEXT("");
TCHAR g_szEntryName[RAS_MaxEntryName + 1] = TEXT("");
HINSTANCE g_hInstance = NULL;
static LPRASDIALPARAMS lpDialParams = NULL;
// 4/2/97    ChrisK    Olympus 296
HANDLE g_hRNAZapperThread = INVALID_HANDLE_VALUE;

typedef struct tagIcwDialShare
{
    TCHAR        szISPFile[MAX_PATH + 1];
    TCHAR        szCurrentDUNFile[MAX_PATH + 1];
    BYTE         fFlags;
    BYTE         bMask;
    DWORD        dwCountryID;
    WORD         wState;
    GATHEREDINFO gi;
    DWORD        dwPlatform;
    
} ICWDIALSHARE, *PICWDIALSHARE;

static PICWDIALSHARE pDynShare;

LPCTSTR GetISPFile()
{
    return pDynShare->szISPFile;
}

void SetCurrentDUNFile(LPCTSTR szDUNFile)
{
    lstrcpyn(
        pDynShare->szCurrentDUNFile,
        szDUNFile,
        SIZEOF_TCHAR_BUFFER(pDynShare->szCurrentDUNFile));
}

DWORD GetPlatform()
{
    return pDynShare->dwPlatform;
}

LPCTSTR GIGetAppDir()
{
    return pDynShare->gi.szAppDir;
}


/********************************************************************

    NAME:        LibShareEntry

    SYNOPSIS:    Initialize or uninitialize shared memory of this DLL

    NOTES:       The share memory replaces the shared section

*********************************************************************/

BOOL LibShareEntry(BOOL fInit)
{
    static TCHAR    szSharedMemName[] = TEXT("ICWDIAL_SHAREMEMORY");
    static HANDLE   hSharedMem = 0;

    BOOL    retval = FALSE;
    
    if (fInit)
    {
        DWORD   dwErr = ERROR_SUCCESS;
        
        SetLastError(0);

        hSharedMem = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(ICWDIALSHARE),
            szSharedMemName);

        dwErr = GetLastError();
            
        switch (dwErr)
        {
        case ERROR_ALREADY_EXISTS:
        case ERROR_SUCCESS:
            pDynShare = (PICWDIALSHARE) MapViewOfFile(
                hSharedMem,
                FILE_MAP_WRITE,
                0,
                0,
                0);
            if (pDynShare != NULL)
            {
                if (dwErr == ERROR_SUCCESS)
                {
                    pDynShare->szISPFile[0] = (TCHAR) 0;
                    pDynShare->szCurrentDUNFile[0] = (TCHAR) 0;
                    pDynShare->fFlags = 0;
                    pDynShare->bMask = 0;
                    pDynShare->dwCountryID = 0;
                    pDynShare->wState = 0;
                    pDynShare->dwPlatform = 0xffffffff;
                }
                else    // dwErr == ERROR_ALREADY_EXISTS
                {
                    // NO initialization needed
                }

                retval = TRUE;
                
            }
            else
            {
                TraceMsg(TF_ERROR, TEXT("MapViewOfFile failed: 0x%08lx"),
                    GetLastError());
                CloseHandle(hSharedMem);
                hSharedMem = 0;
                retval = FALSE;
            }
            break;
            
        default:
            TraceMsg(TF_ERROR, TEXT("CreateFileMapping failed: 0x08lx"), dwErr);
            hSharedMem = 0;
            retval = FALSE;
            
        }
        
    }
    else
    {
        if (pDynShare)
        {
            UnmapViewOfFile(pDynShare);
            pDynShare = NULL;
        }

        if (hSharedMem)
        {
            CloseHandle(hSharedMem);
            hSharedMem = NULL;
        }

        retval = TRUE;
    }

    return retval;
    
}

//static const CHAR szBrowserClass1[] = "IExplorer_Frame";
//static const CHAR szBrowserClass2[] = "Internet Explorer_Frame";
//static const CHAR szBrowserClass3[] = "IEFrame";

//
// 8/5/97 jmazner Olympus 11215
// Isignup window caption/title is IDS_APP_TITLE in isign32\strings.inc
// IDS_APP_TITLE should be in synch with IDS_TITLE in icwdial.rc
//
static const TCHAR cszIsignupWndClassName[] = TEXT("Internet Signup\0");


static DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
static BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
static VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
static HWND FindBrowser(void);
static UINT RetryMessage(HWND hDlg, DWORD dwError);

#define MAX_RETIES 3
#define irgMaxSzs 5
TCHAR szStrTable[irgMaxSzs][256];
int iSzTable;

/*******************************************************************

    NAME:        DllEntryPoint

    SYNOPSIS:    Entry point for DLL.

    NOTES:        Initializes thunk layer to WIZ16.DLL

********************************************************************/
extern "C" BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    BOOL retval = TRUE;
    
    TraceMsg(TF_GENERAL, "ICWDIAL :DllEntryPoint()\n");
    if( fdwReason == DLL_PROCESS_ATTACH ) {
        //
        // ChrisK Olympus 6373 6/13/97
        // Disable thread attach calls in order to avoid race condition
        // on Win95 golden
        //
        DisableThreadLibraryCalls(hInstDll);
        g_hInstance = hInstDll;

        retval = LibShareEntry(TRUE);
        
        if (0xFFFFFFFF == pDynShare->dwPlatform)
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            if (GetVersionEx(&osver))
            {
                pDynShare->dwPlatform = osver.dwPlatformId;
            }
        }
        
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        retval = LibShareEntry(FALSE);
    }
    else if (fdwReason == DLL_THREAD_DETACH)
    {
        //
        // ChrisK 6/3/97 296
        // Broaden window to close this thread
        //
        if (INVALID_HANDLE_VALUE != g_hRNAZapperThread)
        {
            StopRNAReestablishZapper(g_hRNAZapperThread);
        }

    }

    return retval;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT* plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    plogfont = (LOGFONT*)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (abs(plogfont->lfHeight) < 24 && fSize)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = lfWeight;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
MakeBoldExit:
    if (plogfont) GlobalFree(plogfont);
    plogfont = NULL;

    // if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}

// ############################################################################
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
PTSTR GetSz(WORD wszID)
{
    PTSTR psz = szStrTable[iSzTable];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInstance, wszID, psz, 256))
    {
        TraceMsg(TF_GENERAL, "Autodial:LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

//+----------------------------------------------------------------------------
//
//    Function:    IsISignupRunning
//
//    Synopsis:    Check if ISIGNUP is running
//
//    Arguments:    none
//
//    Returns:    TRUE - ISIGNUP is already running
//
//    History:    7/24/97    ChrisK    fixed part of 8445
//
//-----------------------------------------------------------------------------
BOOL IsISignupRunning()
{
    //
    // IE 8445 ChrisK 7/24/97
    // As part of fixing IE 8445, the ICW was inappropriately deleting the
    // isp signup connectoid because it thought isignup was not running.
    //    

    HANDLE hSemaphore;
    BOOL bRC = FALSE;

    //
    // Check the GetLastError value immediately after the CreateSemaphore to
    // make sure nothing else changes the error value
    //
    hSemaphore = CreateSemaphore(NULL, 1, 1, ICW_ELSE_SEMAPHORE);
    if( ERROR_ALREADY_EXISTS == GetLastError() )
    {
        bRC = TRUE;
    }

    //
    // 8/3/97    jmazner    Olympus #11206
    // Even if the semaphore already exists, we still get back a handle
    // reference to it, which means that we need to close that handle
    // or else the semaphore will never get destroyed.
    //
    if( hSemaphore && (hSemaphore != INVALID_HANDLE_VALUE) )
    {
        CloseHandle(hSemaphore);
        hSemaphore = INVALID_HANDLE_VALUE;
    }

    return bRC;
}

TCHAR szDialogBoxClass[] = TEXT("#32770");    // hard coded dialog class name

// check if ICWCONN1 is running
BOOL IsICWCONN1Running()
{
    return (FindWindow(szDialogBoxClass, GetSz(IDS_TITLE)) != NULL);
}

// ############################################################################
typedef HRESULT (WINAPI *PFNINETSETAUTODIAL)(BOOL,LPCTSTR);

void RemoveAutodialer()
{
    HINSTANCE hinst = NULL;
    FARPROC fp = NULL;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst)
    {
        if(fp = GetProcAddress(hinst,"InetSetAutodial"))
        {
            ((PFNINETSETAUTODIAL)fp)(FALSE, TEXT(""));
        }
        FreeLibrary(hinst);
    }
}


// ############################################################################
BOOL WINAPI AutoDialHandler(
    HWND hwndParent,    
    LPCTSTR lpszEntry,
    DWORD dwFlags,
    LPDWORD pdwRetCode
)
{
    HRESULT hr;
    INT cRetry;
    TCHAR szToDebugOrNot[2];
    DWORD dwSize;
    RNAAPI *pcRNA = NULL;
    PDIALDLGDATA pDD = NULL;
    PERRORDLGDATA pDE = NULL;

    if(!IsISignupRunning())
    {

        //
        // 7/30/97 ChrisK IE 8445
        // In ICW 1.1 icwconn1 is left alive the whole time, so we should not
        // care whether or not it is around when we go to dial.
        //
        //// in some *really* weird circs we can be called while ICWCONN1 is running
        //// if so just return failure
        //if(IsICWCONN1Running())
        //{
        //    *pdwRetCode = ERROR_CANCELLED;
        //    return TRUE;
        //}
        
        OutputDebugString(TEXT("Someome didn't cleanup ICWDIAL correctly\r\n"));
        // clean it up now! delete connectoid
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            pcRNA->RasDeleteEntry(NULL, (LPTSTR)lpszEntry);
            delete pcRNA;
            pcRNA = NULL;
        }
        // remove autodial-hook. No clue who to restore, though
        RemoveAutodialer();
        // return FALSE so someone else will dial
        return FALSE;
    }
    
#ifdef _DEBUG
    // This is how we can break into the debugger when this DLL is called as
    // part of the autodialer sequence
    //

    lstrcpyn(szToDebugOrNot,TEXT("0"),2);
    dwSize = sizeof(szToDebugOrNot);
    RegQueryValue(HKEY_LOCAL_MACHINE,TEXT("SOFTWARE\\MICROSOFT\\ISIGNUP\\DEBUG"),szToDebugOrNot,(PLONG)&dwSize);
    if (szToDebugOrNot[0] == '1')
        DebugBreak();
#endif

    // Keep track of EntryName for later
    //

    lstrcpyn(g_szEntryName,  lpszEntry, RAS_MaxEntryName);
    
    if (lstrlen(pDynShare->szISPFile)==0)
    {
//        if ((*pdwRetCode = LoadInitSettingFromRegistry()) != ERROR_SUCCESS)
//            return TRUE;
        LoadInitSettingFromRegistry();
    }

//    g_pdevice = (PMYDEVICE)GlobalAlloc(GPTR,sizeof(MYDEVICE));
//    if (!g_pdevice)
//    {
//        *pdwRetCode = ERROR_NOT_ENOUGH_MEMORY;
//        return TRUE;
//    }

TryDial:
    cRetry = 0;
TryRedial:
    
    if (pDD)
    {
        GlobalFree(pDD);
        pDD = NULL;
    }
    pDD = (PDIALDLGDATA)GlobalAlloc(GPTR,sizeof(DIALDLGDATA));
    if (pDD)
    {
        pDD->dwSize = sizeof(DIALDLGDATA);
        StrDup(&pDD->pszMessage,GetSz(IDS_DIALMESSAGE));
        StrDup(&pDD->pszRasEntryName,lpszEntry);
        pDD->pfnStatusCallback = StatusMessageCallback;
        pDD->hInst = g_hInstance;
    } else {
        MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
    }

    // Dial ISP
    //

    hr = DialingDownloadDialog(pDD);

    cRetry++;

    // Check if we should automatically redial
    //

    if ((cRetry < MAX_RETIES) && (FShouldRetry(hr)))
        goto TryRedial;

    if (hr != ERROR_USERNEXT)
    {
        pDE = (PERRORDLGDATA)GlobalAlloc(GPTR,sizeof(ERRORDLGDATA));
        if (!pDE)
        {
            MessageBox(NULL,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
        } else {
            pDE->dwSize = sizeof (ERRORDLGDATA);
            StrDup(&pDE->pszMessage,GetSz(RasErrorToIDS(hr)));
            StrDup(&pDE->pszRasEntryName,lpszEntry);

            pDE->pdwCountryID = &(pDynShare->dwCountryID);            
            pDE->pwStateID = &(pDynShare->wState);
            pDE->bType = pDynShare->fFlags;
            pDE->bMask = pDynShare->bMask;
            
            StrDup(&pDE->pszHelpFile,AUTODIAL_HELPFILE);
            pDE->dwHelpID = icw_trb;
            pDE->hInst = g_hInstance;
            pDE->hParentHwnd = NULL;

            hr = DialingErrorDialog(pDE);
            
            if (hr == ERROR_USERNEXT)
                goto TryDial;
            else
                hr = ERROR_USERCANCEL;
        }
    }

    GlobalFree(pDD);
    pDD = NULL;

    if (hr == ERROR_SUCCESS)
        *pdwRetCode = ERROR_SUCCESS;
    else if (hr == ERROR_USERCANCEL)
        *pdwRetCode = ERROR_CANCELLED;

    if (ERROR_SUCCESS != *pdwRetCode)
    {
        HWND hwndIsignup = NULL;

        //
        // 8/5/97 jmazner Olympus 11215
        // For ICW 1.1 and IE 4, looking for the browser won't work
        // Instead, look for isignup and send it a special quit message.
        //

        //hwndBrowser = FindBrowser();

        hwndIsignup = FindWindow(cszIsignupWndClassName, GetSz(IDS_TITLE));
        if (NULL != hwndIsignup)
        {
            PostMessage(hwndIsignup, WM_CLOSE, 0, 0);
        }

    }
    return TRUE;
}

// ############################################################################
HRESULT LoadInitSettingFromRegistry()
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD dwType, dwSize;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS)
    {
        TraceMsg(TF_ERROR, TEXT("Failed RegOpenKey: %s 0x%08lx"), SIGNUPKEY, hr);
        goto LoadInitSettingFromRegistryExit;
    }

        
    dwType = REG_BINARY;
    dwSize = sizeof(pDynShare->gi);
    ZeroMemory(&(pDynShare->gi),sizeof(pDynShare->gi));
    
    hr = RegQueryValueEx(
        hKey,
        GATHERINFOVALUENAME,
        0,
        &dwType,
        (LPBYTE) &(pDynShare->gi),
        &dwSize);
    if (hr != ERROR_SUCCESS)
    {
        TraceMsg(TF_ERROR, TEXT("Failed RegQueryValueEx: %s 0x%08lx"),
            GATHERINFOVALUENAME, hr);
        goto LoadInitSettingFromRegistryExit;
    }
    
    AutoDialInit(
        pDynShare->gi.szISPFile,
        pDynShare->gi.fType,
        pDynShare->gi.bMask,
        pDynShare->gi.dwCountry,
        pDynShare->gi.wState);
        
    SetCurrentDirectory(pDynShare->gi.szAppDir);

    // Get the name of the DUN file
    
    pDynShare->szCurrentDUNFile[0] = 0;
    dwSize = SIZEOF_TCHAR_BUFFER(pDynShare->szCurrentDUNFile);
    ReadSignUpReg(
        (LPBYTE)pDynShare->szCurrentDUNFile,
        &dwSize,
        REG_SZ,
        DUNFILEVALUENAME);
        
LoadInitSettingFromRegistryExit:
    if (hKey) RegCloseKey(hKey);
    return hr;
}

// ############################################################################
/******
 *
 * 8/5/97 jmazner Olympus 11215
 * This function is no longer required
 *
static HWND FindBrowser(void)
{
    HWND hwnd;

    //look for all the microsoft browsers under the sun

    if ((hwnd = FindWindow(szBrowserClass1, NULL)) == NULL)
    {
        if ((hwnd = FindWindow(szBrowserClass2, NULL)) == NULL)
        {
            hwnd = FindWindow(szBrowserClass3, NULL);
        }
    }

    return hwnd;
}
****/

// ############################################################################
HRESULT AutoDialInit(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState)
{
    TraceMsg(TF_GENERAL, "AUTODIAL:AutoDialInit()\n");
    if (lpszISPFile) lstrcpyn(pDynShare->szISPFile, lpszISPFile, MAX_PATH);
    pDynShare->fFlags = fFlags;
    pDynShare->bMask = bMask;
    pDynShare->dwCountryID = dwCountry;
    pDynShare->wState = wState;

    return ERROR_SUCCESS;
}


// ############################################################################
BOOL FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dlapi.h ===
/*-----------------------------------------------------------------------------
	dlapi.h

	contains declarations for download api soft link wrappers

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#ifndef _DLAPI_H
#define _DLAPI_H

class CDownLoadAPI
{
public:
	CDownLoadAPI();
	~CDownLoadAPI();
	HRESULT DownLoadInit(PTSTR, DWORD_PTR *, DWORD_PTR *, HWND);
	HRESULT DownLoadCancel(DWORD_PTR);
	HRESULT DownLoadExecute(DWORD_PTR);
	HRESULT DownLoadClose(DWORD_PTR);
	HRESULT DownLoadSetStatus(DWORD_PTR, INTERNET_STATUS_CALLBACK);
	HRESULT DownLoadProcess(DWORD_PTR);

private:
	HINSTANCE m_hDLL;
	PFNDOWNLOADINIT m_pfnDownLoadInit;
	PFNDOWNLOADCANCEL m_pfnDownLoadCancel;
	PFNDOWNLOADEXECUTE m_pfnDownLoadExecute;
	PFNDOWNLOADCLOSE m_pfnDownLoadClose;
	PFNDOWNLOADSETSTATUS m_pfnDownLoadSetStatus;
	PFNDOWNLOADPROCESS m_pfnDownLoadProcess;

	HRESULT LoadAPI(LPSTR, FARPROC*);
};

#endif // _DLAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dialutil.h ===
/*-----------------------------------------------------------------------------
	dialutil.h

	contains declarations for dialutil.cpp

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#ifndef _DIALUTIL_H
#define _DIALUTIL_H

#define IDS_RASCS                    100
#define IDS_OPENPORT                 IDS_RASCS+ 0
#define IDS_PORTOPENED               IDS_RASCS+ 1
#define IDS_CONNECTDEVICE            IDS_RASCS+ 2
#define IDS_DEVICECONNECTED          IDS_RASCS+ 3
#define IDS_ALLDEVICESCONNECTED      IDS_RASCS+ 4
#define IDS_AUTHENTICATE             IDS_RASCS+ 5
#define IDS_AUTHNOTIFY               IDS_RASCS+ 6
#define IDS_AUTHRETRY                IDS_RASCS+ 7
#define IDS_AUTHCALLBACK             IDS_RASCS+ 8
#define IDS_AUTHCHANGEPASSWORD       IDS_RASCS+ 9
#define IDS_AUTHPROJECT              IDS_RASCS+10
#define IDS_AUTHLINKSPEED            IDS_RASCS+11
#define IDS_AUTHACK                  IDS_RASCS+12
#define IDS_REAUTHENTICATE           IDS_RASCS+13
#define IDS_AUTHENTICATED            IDS_RASCS+14
#define IDS_PREPAREFORCALLBACK       IDS_RASCS+15
#define IDS_WAITFORMODEMRESET        IDS_RASCS+16
#define IDS_WAITFORCALLBACK          IDS_RASCS+17
#define IDS_INTERACTIVE              IDS_RASCS+18
#define IDS_RETRYAUTHENTICATION      IDS_RASCS+19
#define IDS_CALLBACKSETBYCALLER      IDS_RASCS+20
#define IDS_PASSWORDEXPIRED          IDS_RASCS+21
#define IDS_CONNECTED                IDS_RASCS+22
#define IDS_DISCONNECTED             IDS_RASCS+23
#define IDS_RASCS_END                IDS_DISCONNECTED
#define IDS_UNDEFINED_ERROR          IDS_RASCS_END+1

#define IDS_CONNECTED_TO             200
#define IDS_DOWNLOADING              201


VOID CenterWindow(HWND hwndChild, HWND hwndParent);
BOOL MinimizeRNAWindow(TCHAR * pszConnectoidName);
DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR NEAR PASCAL GetDisplayPhone(LPTSTR szPhoneNum);
DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb);
HRESULT AutoDialInit(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);
DWORD ReplacePhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber);
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource);
INT_PTR CALLBACK GenericDlgProc(HWND, UINT, WPARAM, LPARAM);

#define PHONEBOOK_LIBRARY TEXT("ICWPHBK.DLL")
#define PHBK_LOADAPI           "PhoneBookLoad"
#define PHBK_SUGGESTAPI        "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI        "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI         "PhoneBookUnload"
#define PHBK_GETCANONICAL      "PhoneBookGetCanonical"

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD_PTR *pdwPhoneID);
typedef HRESULT (CALLBACK* PFNPHONEDISPLAY)(DWORD_PTR dwPhoneID,TCHAR **ppszPhoneNumbers,
											TCHAR **ppszDunFiles, WORD *pwPhoneNumbers,
											DWORD *pdwCountry,WORD *pwRegion,BYTE fType,
											BYTE bMask,HWND hwndParent,DWORD dwFlags);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD_PTR dwPhoneID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dlapi.cpp ===
/*-----------------------------------------------------------------------------
	dlapi.cpp

	Wrapper for softlinking to download DLL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "debug.h"
#include "icwdl.h"
#include "dlapi.h"

// ############################################################################
CDownLoadAPI::CDownLoadAPI()
{
	m_hDLL = NULL;
	m_pfnDownLoadInit = NULL;
	m_pfnDownLoadCancel = NULL;
	m_pfnDownLoadExecute = NULL;
	m_pfnDownLoadClose = NULL;
	m_pfnDownLoadSetStatus = NULL;
	m_pfnDownLoadProcess = NULL;
}

// ############################################################################
CDownLoadAPI::~CDownLoadAPI()
{
	if (m_hDLL) FreeLibrary(m_hDLL);
	m_hDLL = NULL;
	m_pfnDownLoadInit = NULL;
	m_pfnDownLoadCancel = NULL;
	m_pfnDownLoadExecute = NULL;
	m_pfnDownLoadClose = NULL;
	m_pfnDownLoadSetStatus = NULL;
	m_pfnDownLoadProcess = NULL;
}

// ############################################################################
HRESULT CDownLoadAPI::LoadAPI(LPSTR szApiName, FARPROC* pfp)
{
	Assert(szApiName && pfp);
	if (!m_hDLL)
		m_hDLL = LoadLibrary(DOWNLOAD_LIBRARY);

	if (m_hDLL && !(*pfp))
	{
		*pfp = GetProcAddress(m_hDLL, szApiName);
		if (*pfp)
			return ERROR_SUCCESS;
		else
			return GetLastError();
	} else {
		return GetLastError();
	}
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadInit(PTSTR pszUrl, DWORD_PTR * lpCDialingDlg, DWORD_PTR *lpdwDownload, HWND hwndParent)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADINIT,(FARPROC*)&m_pfnDownLoadInit);
	if (m_pfnDownLoadInit)
		hr =  (m_pfnDownLoadInit)(pszUrl, lpCDialingDlg, lpdwDownload, hwndParent);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadCancel(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADCANCEL,(FARPROC*)&m_pfnDownLoadCancel);
	if (m_pfnDownLoadCancel)
		hr =  (m_pfnDownLoadCancel)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadExecute(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADEXECUTE,(FARPROC*)&m_pfnDownLoadExecute);
	if (m_pfnDownLoadExecute)
		hr =  (m_pfnDownLoadExecute)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadProcess(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADPROCESS,(FARPROC*)&m_pfnDownLoadProcess);
	if (m_pfnDownLoadProcess)
		hr =  (m_pfnDownLoadProcess)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadClose(DWORD_PTR dwDownload)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADCLOSE,(FARPROC*)&m_pfnDownLoadClose);
	if (m_pfnDownLoadClose)
		hr =  (m_pfnDownLoadClose)(dwDownload);
	return hr;
}

// ############################################################################
HRESULT CDownLoadAPI::DownLoadSetStatus(DWORD_PTR dwDownload, INTERNET_STATUS_CALLBACK fnCallback)
{
	HRESULT hr = ERROR_DLL_NOT_FOUND;
	LoadAPI(DOWNLOADSETSTATUS,(FARPROC*)&m_pfnDownLoadSetStatus);
	if (m_pfnDownLoadSetStatus)
		// jmazner 10/2/96 Normandy # 8493
		// ICWDL.DLL's DownLoadSetStatus only has two parameters!!!
		//hr =  (m_pfnDownLoadSetStatus)(dwDownload, fnCallback, dwContext);
		  hr =  (m_pfnDownLoadSetStatus)(dwDownload, fnCallback);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dialerr.cpp ===
/*-----------------------------------------------------------------------------
	dialerr.cpp

	Handle Could Not Connect dialog

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

TCHAR szBuf256[256];

#define VALID_INIT (m_pcRNA && m_hLineApp && m_pszPhoneNumber)
TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

#ifndef WIN16
int g_iMyMaxPhone = 0;
#endif

//+---------------------------------------------------------------------------
//
//	Function:	ProcessDBCS
//
//	Synopsis:	Converts control to use DBCS compatible font
//				Use this at the beginning of the dialog procedure
//	
//				Note that this is required due to a bug in Win95-J that prevents
//				it from properly mapping MS Shell Dlg.  This hack is not needed
//				under winNT.
//
//	Arguments:	hwnd - Window handle of the dialog
//				cltID - ID of the control you want changed.
//
//	Returns:	ERROR_SUCCESS
// 
//	History:	4/31/97 a-frankh	Created
//				5/13/97	jmazner		Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
	return;
#else
	HFONT hFont = NULL;

	if( IsNT() )
	{
		return;
	}

	hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
	if (hFont == NULL)
		hFont = (HFONT) GetStockObject(SYSTEM_FONT);
	if (hFont != NULL)
		SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}

//+---------------------------------------------------------------------------
//
//	Function:	IsSBCSString
//
//	Synopsis:	Walks through a string looking for DBCS characters
//
//	Arguments:	sz -- the string to check
//
//	Returns:	TRUE if no DBCS characters are found
//				FALSE otherwise
// 
//	History:	5/17/97	jmazner		Stole from conn1 to use here
//									(Olympus #137)
//----------------------------------------------------------------------------
#if !defined(WIN16)
BOOL IsSBCSString( LPCTSTR sz )
{
	Assert(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    return (BOOL)IsTextUnicode((CONST LPVOID)sz, lstrlen(sz), &attrib);
#else
	while( NULL != *sz )
	{
		 if (IsDBCSLeadByte(*sz)) return FALSE;
		 sz++;
	}

	return TRUE;
#endif
}
#endif


//+----------------------------------------------------------------------------
//
//	Function: DialingErrorDialog
//
//	Synopsis:	Display and handle dialing error dialog, or as it is known
//				the "Could Not Connect" dialog
//
//	Arguemtns:	pED - pointer to error dialog data structure
//
//	Returns:	ERROR_USERNEXT - user hit redial
//				ERROR_USERCANCEL - user selected cancel
//				otherwise the function returns the appropriate error code
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
HRESULT WINAPI DialingErrorDialog(PERRORDLGDATA pED)
{
	HRESULT hr = ERROR_SUCCESS;
	CDialingErrorDlg *pcDEDlg = NULL;

	//
	// Validate parameters
	//

	if (!pED)
	{
		hr = ERROR_INVALID_PARAMETER;
		goto DialingErrorDialogExit;
	}

	if (pED->dwSize < sizeof(ERRORDLGDATA))
	{
		hr = ERROR_BUFFER_TOO_SMALL;
		goto DialingErrorDialogExit;
	}

	//
	// Initialize dialog
	//

	pcDEDlg = new CDialingErrorDlg;
	if (!pcDEDlg)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto DialingErrorDialogExit;
	}

#ifndef WIN16
	if( IsNT() )
	{
		g_iMyMaxPhone = MAXPHONE_NT;
	}
	else
	{
		g_iMyMaxPhone = MAXPHONE_95;
	}
#endif

	AssertMsg( (RAS_MaxPhoneNumber >= g_iMyMaxPhone), "RAS_MaxPhone < g_iMyMaxPhone" );

	//
	// Copy in data
	//

	pcDEDlg->m_hInst = pED->hInst;
	pcDEDlg->m_hwnd = pED->hParentHwnd;

	if (ERROR_SUCCESS != (hr = pcDEDlg->Init()))
		goto DialingErrorDialogExit;

	StrDup(&pcDEDlg->m_pszConnectoid,pED->pszRasEntryName);
	StrDup(&pcDEDlg->m_pszMessage,pED->pszMessage);
	StrDup(&pcDEDlg->m_pszDunFile,pED->pszDunFile);
	pcDEDlg->m_dwPhoneBook = pED->dwPhonebook;

	if (0 != pED->dwPhonebook)
	{
		if (pED->pdwCountryID) pcDEDlg->m_dwCountryID = *(pED->pdwCountryID);
		if (pED->pwStateID) pcDEDlg->m_wState = *(pED->pwStateID);
		pcDEDlg->m_bType = pED->bType;
		pcDEDlg->m_bMask = pED->bMask;
	}

	//
	// Help information, if one was not specified use the default trouble shooter
	//

	if (pcDEDlg->m_pszHelpFile)
	{
		StrDup(&pcDEDlg->m_pszHelpFile,pED->pszHelpFile);
		pcDEDlg->m_dwHelpID = pED->dwHelpID;
	}
	else
	{
		StrDup(&pcDEDlg->m_pszHelpFile,AUTODIAL_HELPFILE);
		pcDEDlg->m_dwHelpID = icw_trb;
	}

	//
	// Display dialog
	//

	hr = (HRESULT)DialogBoxParam(GetModuleHandle(TEXT("ICWDIAL")),MAKEINTRESOURCE(IDD_DIALERR),
		pED->hParentHwnd,GenericDlgProc,(LPARAM)pcDEDlg);

	//
	// Copy out data
	//

	if (pED->pszDunFile)
		GlobalFree(pED->pszDunFile);
	pED->pszDunFile = NULL;
	StrDup(&pED->pszDunFile,pcDEDlg->m_pszDunFile);


DialingErrorDialogExit:
	if (pcDEDlg) delete pcDEDlg;
	pcDEDlg = NULL;
	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg (constructor)
//
//	Synopsis:	initializes CDialingErrorDlg data members
//
//	Arguements:	none
//
//	Returns:	none
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
CDialingErrorDlg::CDialingErrorDlg()
{
	m_hInst = NULL;
	m_hwnd = NULL;

	m_pszConnectoid = NULL;
	m_pszDisplayable = NULL;
	m_pszPhoneNumber = NULL;
	m_pszMessage = NULL;
	m_pszDunFile = NULL;
	m_dwPhoneBook = 0;

	m_hLineApp = NULL;
	m_dwTapiDev = 0;
	m_dwAPIVersion = 0;
	m_pcRNA = NULL;

	m_lpRasDevInfo = NULL;
	m_dwNumDev = 0;

	m_pszHelpFile = NULL;
	m_dwHelpID = 0;

	m_dwCountryID = 0;
	m_wState = 0;
	m_bType = 0;
	m_bMask = 0;

	// Normandy 10612 - ChrisK
	// The dial error dialog will handle its own prompt to exit.  The generic
	// dialog proc should not ask about this.
	m_bShouldAsk = FALSE;

}

//+----------------------------------------------------------------------------
//
//	Function:	~CDialingErrorDlg (destructor)
//
//	Synopsis:	deallocated and cleans up data members
//
//	Arguements:	none
//
//	Returns:	none
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
CDialingErrorDlg::~CDialingErrorDlg()
{
	m_hInst = NULL;
	m_hwnd = NULL;

	if (m_pszConnectoid) GlobalFree(m_pszConnectoid);
	m_pszConnectoid = NULL;

	if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
	m_pszDisplayable = NULL;

	if (m_pszPhoneNumber) GlobalFree(m_pszPhoneNumber);
	m_pszPhoneNumber = NULL;

	if (m_pszMessage) GlobalFree(m_pszMessage);
	m_pszMessage = NULL;

	if (m_pszDunFile) GlobalFree(m_pszDunFile);
	m_pszDunFile = NULL;

	m_dwPhoneBook = 0;

	if (m_hLineApp) lineShutdown(m_hLineApp);
	m_hLineApp = NULL;

	if (m_pszHelpFile) GlobalFree(m_pszHelpFile);
	m_pszHelpFile = NULL;

	m_dwHelpID = 0;

	m_dwNumDev = 0;
	m_dwTapiDev = 0;
	m_dwAPIVersion = 0;
	m_pcRNA = NULL;

	m_dwCountryID = 0;
	m_wState = 0;
	m_bType = 0;
	m_bMask = 0;

}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::Init
//
//	Synopsis:	Intialize data members that may fail.  We need to return an
//				code for these cases and C++ constructors don't support this
//
//	Arguments:	none
//
//	Returns:	ERROR_SUCCESS - success
//				anything else indicates a failure
//
//	History:	7/2/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
HRESULT CDialingErrorDlg::Init()
{
	HRESULT hr = ERROR_SUCCESS;
	LPLINEEXTENSIONID lpExtensionID = NULL;

	// Initialize RAS/RNA
	//

	m_pcRNA = new RNAAPI;
	if (!m_pcRNA)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

	//
	// Initialize TAPI
	//

	hr = lineInitialize(&m_hLineApp,m_hInst,LineCallback,NULL,&m_dwNumDev);
	if (hr) goto InitExit;

	lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(LPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

	hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
		&m_dwAPIVersion, lpExtensionID);

	// 4/2/97	ChrisK	Olypmus 2745
	while (ERROR_SUCCESS != hr && m_dwTapiDev < (m_dwNumDev - 1))
	{
		m_dwTapiDev++;
		hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
		&m_dwAPIVersion, lpExtensionID);
	}

	if (hr != ERROR_SUCCESS)
		goto InitExit;
	
	// Initialize strings
	//

	// 
	// 6/3/97 jmazner Olympus #4868
	// allocate enough space to hold maximum length phone numbers.
	//

	//m_pszPhoneNumber = (LPTSTR)GlobalAlloc(LPTR,MAX_CANONICAL_NUMBER);
	m_pszPhoneNumber = (LPTSTR)GlobalAlloc(GPTR,
		sizeof(TCHAR)*(MAX_CANONICAL_NUMBER>g_iMyMaxPhone?MAX_CANONICAL_NUMBER:g_iMyMaxPhone + 1));

	if (!m_pszPhoneNumber)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto InitExit;
	}

InitExit:
	if (lpExtensionID) GlobalFree(lpExtensionID);
	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::DlgProc
//
//	Synopsis:	Handle messages sent to the dial error dialog
//
//	Arguments:	See Windows documentation for DialogProc's
//
//	Returns:	See Windows documentation for DialogProc's
//
//	History:	7/8/96	ChrisK	Created
//
//-----------------------------------------------------------------------------
LRESULT CDialingErrorDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam, LRESULT lres)
{
	LRESULT lRes = TRUE;
	HRESULT hr;
	// Normandy 11745
	// WORD wIDS;
	FARPROC fp = NULL;
	LPTSTR *ppPhoneNumbers;
	LPTSTR pszPhoneNumber;
	LPTSTR *ppDunFiles;
	LPTSTR pszDunFile = NULL;
	WORD wNumber;
	DWORD dwSize;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;
	LRESULT idx = 0;
	HINSTANCE hPHBKDll = NULL;
	LPTSTR lpszDialNumber = NULL;
	static BOOL bCheckDisplayable = FALSE;
    static BOOL bInitComplete = FALSE;     //shows dialog init is complete - MKarki
    static BOOL bDlgPropEnabled = TRUE;   //this flags holds state of Dialing Properties PushButton MKarki - (5/3/97/) Fix for Bug#3393
    //CSupport    objSupportNum;
    //CHAR  szSupportNumber[256];
    //CHAR    szSupportMsg[256]; 

	static BOOL fUserEditedNumber = FALSE;

	Assert(NULL == m_hwnd || hwnd == m_hwnd);

	switch(uMsg)
	{
	case WM_INITDIALOG:
		Assert(VALID_INIT);

    //
    // This GOTO has been added to
    // display dialog again when phone numbers are
    // not valid -  MKarki (4/21/97) Fix for Bug#2868 and 3461
    //
ShowErrDlgAgain:

		m_hwnd = hwnd;


		// Set limit on phone number length
		//

		//
		// ChrisK Olympus 4851 6/9/97
		// The maximum length of this string needs to include space for a terminating
		// NULL
		//
		SendDlgItemMessage(hwnd,IDC_TEXTNUMBER,EM_SETLIMITTEXT,g_iMyMaxPhone - 1 ,0);

#if 0
        //
        // Get the PSS Support Number now
        // MKarki (5/9/97) -  Fix for Bug#267
        //
        if ((objSupportNum.GetSupportInfo(szSupportNumber)) == TRUE)
        {
            //
            // show the info
            //
            lstrcpy (szSupportMsg, GetSz (IDS_SUPPORTMSG));
            lstrcat (szSupportMsg, szSupportNumber); 
			SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
        }
#endif

		// Show the phone number
		//
		hr = GetDisplayableNumber();
		if (hr != ERROR_SUCCESS)
		{
			bCheckDisplayable = FALSE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
		} else {
			bCheckDisplayable = TRUE;
			SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
		}

		// Bug Normandy 5920
		// ChrisK, turns out we are calling MakeBold twice
		// MakeBold(GetDlgItem(m_hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

		// Fill in error message
		//
		if (m_pszMessage)
			SetDlgItemText(m_hwnd,IDC_LBLERRMSG,m_pszMessage);

		FillModems();

		//
		// Enable DBCS on win95-J systems
		//
		ProcessDBCS(m_hwnd, IDC_CMBMODEMS);
		ProcessDBCS(m_hwnd, IDC_TEXTNUMBER);

		// Set the focus to the Modems selection list
		//
	    SetFocus(GetDlgItem(m_hwnd,IDC_CMBMODEMS));

		lRes = FALSE;


		SetForegroundWindow(m_hwnd);

		if (0 == m_dwPhoneBook)
		{
			//
			// 8/1/97	jmazner	Olympus #11118
			// This ISP phonebook code is totally messed up, but we never use this
			// functionality anyways.  Just make sure that the phonebook button is gone
			// unless someone explicitly asks for it.
			//

			//if (g_szISPFile[0] == '\0') // BUG: this condition should go away eventually.
										// see the comments with the phone book button code below.
			//{
				ShowWindow(GetDlgItem(hwnd,IDC_LBLPHONE),SW_HIDE);
				ShowWindow(GetDlgItem(hwnd,IDC_CMDPHONEBOOK),SW_HIDE);
			//}
		}

        //
        //  we should disable the Dialing Properites PushButton
        //  if we have changed the phone number once
        //  MKarki (5/3/97) - Fix for Bug#3393
        //
        if (FALSE == bDlgPropEnabled)
        {
            EnableWindow (
                GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                FALSE
                );
        }
            
        //
        // This shows the INIT for the error dialog is complete
        // and we can start processing changes to Ph No. TEXTBOX
        // MKarki (4/24/97) - Fix for Bug#3511
        //
        bInitComplete = TRUE;

		break;
	case WM_CLOSE:
		if (MessageBox(m_hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
			MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
			EndDialog(m_hwnd,ERROR_USERCANCEL);
		break;
	case WM_DESTROY:
		ReleaseBold(GetDlgItem(m_hwnd,IDC_LBLTITLE));
		break;

	case WM_HELP:
		//
		// Chrisk Olympus 5130 5/27/97
		// Added support for F1 Help Key
		//
		if (m_pszHelpFile && *m_pszHelpFile)
			WinHelp(m_hwnd,m_pszHelpFile,HELP_CONTEXT,m_dwHelpID);
		break;

	case WM_COMMAND:
		switch(LOWORD(wparam))
		{

        //
        // We now processes changes to ph no. EDIT BOX
        // If there is anychange in the phone number we
        // disable to Dialing Properties Push Button
        // MKarki (3/22/97) - Fix for Bug #3511
        //
        case IDC_TEXTNUMBER:
			TCHAR lpszTempNumber[RAS_MaxPhoneNumber + 1];

            if ((HIWORD (wparam) == EN_CHANGE) && (bInitComplete == TRUE))
            {
                if ((GetDlgItemText (
                            hwnd,
                            IDC_TEXTNUMBER,
                            lpszTempNumber,
                            RAS_MaxPhoneNumber + 1
                            ))  && 
            		(0 != lstrcmp(
                             lpszTempNumber, 
                              bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			    {
                    //
                    // number has been modified by the user
                    // hide the Dialing Properties Push Button  
                    //
                    EnableWindow (
                            GetDlgItem (hwnd, IDC_CMDDIALPROP), 
                            FALSE
                            );
                    //
                    // save the state of the Dialing Properties PushButton
                    // MKarki (5/3/97) -  Fix for Bug#3393
                    //
                    bDlgPropEnabled = FALSE;

					//
					// 7/17/97 jmazner Olympus #8234
					//
					fUserEditedNumber = TRUE;
                }
            }
			break;

		case IDC_CMBMODEMS:
			if (HIWORD(wparam) == CBN_SELCHANGE)
			{

				idx = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_GETCURSEL,0,0);
				//
				// ChrisK Olympus 245 5/25/97
				// Get index of modem
				//
				idx = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_GETITEMDATA,idx,0);
				if (idx == CB_ERR) break;

				//
				// Get the connectoid
				//

				hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
				// UNDONE: Error Message

				//
				// Replace the device with a new one
				//

				lstrcpyn(lpRasEntry->szDeviceType,m_lpRasDevInfo[idx].szDeviceType,RAS_MaxDeviceType+1);
				lstrcpyn(lpRasEntry->szDeviceName,m_lpRasDevInfo[idx].szDeviceName,RAS_MaxDeviceName+1);

				if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
				//
				// ChrisK Olympus 2461 5/30/97
				// Ras will take the modem settings from the RasEntry structure.  If these are
				// not zeroed out, then they will corrupt the entry.
				//
				lpRasDevInfo = 0;
				dwRasDevInfoSize = 0;
				
				hr = m_pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
				lpRasDevInfo = NULL;	// Set back to NULL so we don't try and free later

				if (lpRasEntry) GlobalFree(lpRasEntry);
				lpRasEntry = NULL;
				// DO NOT FREE DEVINFO struct!!
				lpRasDevInfo = NULL;
				dwRasEntrySize = 0;
				dwRasDevInfoSize = 0;
			}
			break;
		case IDC_CMDNEXT:
			//
			// Redial button
			//

			// NOTE: This button is actually labeled "Redial"
			//
			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(g_iMyMaxPhone + 2));
			if (NULL == lpszDialNumber)
			{
				MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
				break;
			}
			// If the user has altered the phone number, make sure it can be used
			//
			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, g_iMyMaxPhone + 1)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			{
                //
                //  return failure if we do not have a valid
                //  phone number - MKarki 4/21/97 Bug# 2868 & 3461
                //
				hr = CreateDialAsIsConnectoid(lpszDialNumber);
                lRes = (hr == ERROR_SUCCESS);
			}

			if (lpszDialNumber) 
				GlobalFree(lpszDialNumber);

            //
            // only end this dialog, if we have a valid 
            //  phone number, else refresh the same dialog
            //  MKarki (4/21/97) Fix for Bug#2868 & 3461
            //
            if (lRes == TRUE)
			    EndDialog(m_hwnd,ERROR_USERNEXT);
            else
                goto ShowErrDlgAgain;

			break;
		case IDC_CMDHELP:
			//
			// Help Button
			//
			if (m_pszHelpFile && *m_pszHelpFile)
				WinHelp(m_hwnd,m_pszHelpFile,HELP_CONTEXT,m_dwHelpID);
			break;
		case IDC_CMDCANCEL:
			//
			// Cancel button
			//
			if (MessageBox(m_hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
				MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
				EndDialog(m_hwnd,ERROR_USERCANCEL);
			break;

		case IDC_CMDDIALPROP:
			//
			// Dialing properties
			//

			// If the user has altered the phone number, make sure it can be used
			//

			lpszDialNumber = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(g_iMyMaxPhone + 2));
			if (NULL == lpszDialNumber)
			{
				MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
				break;
			}

			if (fUserEditedNumber &&
				(GetDlgItemText(hwnd, IDC_TEXTNUMBER, lpszDialNumber, g_iMyMaxPhone + 1)) &&
				(0 != lstrcmp(lpszDialNumber, bCheckDisplayable ? m_pszDisplayable : m_pszPhoneNumber)))
			{
				hr = CreateDialAsIsConnectoid(lpszDialNumber);
                lRes = (hr ==   ERROR_SUCCESS);
				lstrcpy(m_pszPhoneNumber,lpszDialNumber);
			}

			// 11/25/96	jmazner	Normandy #10294
			//ShowWindow(m_hwnd,SW_HIDE);
			EnableWindow(m_hwnd, FALSE);

			hr = lineTranslateDialog(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_hwnd,m_pszPhoneNumber);

			hr = GetDisplayableNumber();
			if (hr != ERROR_SUCCESS)
			{
				bCheckDisplayable = FALSE;
				SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
			} else {
				bCheckDisplayable = TRUE;
				SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
			}

			if (lpszDialNumber) 
				GlobalFree(lpszDialNumber);

#if 0
            //
            //  See if support number has changed
            // MKarki (5/9/97) -  Fix for Bug#267
            //
            if ((objSupportNum.GetSupportInfo(szSupportNumber)) == TRUE)
            {
                //
                // show the info
                //
                lstrcpy (szSupportMsg, GetSz (IDS_SUPPORTMSG));
                lstrcat (szSupportMsg, szSupportNumber); 
			    SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
            }
            else
            {
                //
                // need to clear what is being displayed now
                //
                ZeroMemory ( szSupportMsg, sizeof (szSupportMsg));
			    SetDlgItemText(hwnd,IDC_LBSUPPORTMSG, szSupportMsg);
            }
#endif

			//ShowWindow(m_hwnd,SW_SHOW);
			EnableWindow(m_hwnd, TRUE);
			
			SetForegroundWindow(m_hwnd);

			//
			// 6/6/97 jmazner Olympus #4759
			//
			SetFocus(GetDlgItem(hwnd,IDC_CMDNEXT));

			break;
		case IDC_CMDPHONEBOOK:
			// BUG: This code will not work with the restructured dialer DLL.
			// The problem is the restructure DLL expects the call to have already
			// opened and load the phone book and just pass in the dwPhoneBook ID.
			// This code actually loads the phone book from the global ISP file.
PhoneBookClick:
			if (!hPHBKDll)
				hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
			if (!hPHBKDll)
			{
				wsprintf(szBuf256,GetSz(IDS_CANTLOADINETCFG),PHONEBOOK_LIBRARY);
				MessageBox(m_hwnd,szBuf256,GetSz(IDS_TITLE),MB_MYERROR);
			} else {
				fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI);
				if (!fp)
					MsgBox(IDS_CANTLOADPHBKAPI,MB_MYERROR);
				else
				{
					hr = ((PFNPHONEBOOKLOAD)fp)(GetISPFile(),&m_dwPhoneBook);
					if (hr != ERROR_SUCCESS)
						MsgBox(IDS_CANTINITPHONEBOOK,MB_MYERROR);
					else
					{
						fp = GetProcAddress(hPHBKDll,PHBK_DISPLAYAPI);
						if (!fp)
							MsgBox(IDS_CANTLOADPHBKAPI,MB_MYERROR);
						else {
							ppPhoneNumbers = &pszPhoneNumber;
							pszPhoneNumber = m_pszPhoneNumber;
							ppDunFiles = &pszDunFile;
							pszDunFile = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(256));
							// BUGBUG: ignoring error condition
							Assert(pszDunFile);
							wNumber = 1;
							if (pszDunFile && pszPhoneNumber)
							{
								ShowWindow(m_hwnd,SW_HIDE);
								hr = ((PFNPHONEDISPLAY)fp)
									(m_dwPhoneBook,
									ppPhoneNumbers,
									ppDunFiles,
									&wNumber,
									&m_dwCountryID,
									&m_wState,
									m_bType,
									m_bMask,
									NULL,8);
								ShowWindow(m_hwnd,SW_SHOW);
								SetForegroundWindow(m_hwnd);
								if (hr == ERROR_SUCCESS)
								{

									m_pcRNA->RasDeleteEntry(NULL,m_pszConnectoid);

									// Make a new connectoid
									//

									hr = CreateEntryFromDUNFile(pszDunFile);
									if (hr != ERROR_SUCCESS)
									{
										MsgBox(IDS_INVALIDPN,MB_MYERROR);
										goto PhoneBookClick;
										break;
									}

									// Get the name of the connectoid
									//

									dwSize = sizeof(TCHAR)*RAS_MaxEntryName;
									hr = ReadSignUpReg((LPBYTE)m_pszConnectoid, &dwSize, REG_SZ, RASENTRYVALUENAME);
									if (hr != ERROR_SUCCESS)
									{
										MsgBox(IDS_CANTREADKEY,MB_MYERROR);
										break;
									}

									// Get the connectoid
									//

									hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
									// UNDONE: ERROR MESSAGE

									// Break up phone number
									//
									if (!BreakUpPhoneNumber(lpRasEntry, m_pszPhoneNumber))
									{
										MsgBox(IDS_INVALIDPN,MB_MYERROR);
										goto PhoneBookClick;
										break;
									}

									// Set Country ID
									//
									lpRasEntry->dwCountryID=m_dwCountryID;

									// Set connectoid with new phone number
									//

									hr = m_pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,
										(LPBYTE)lpRasEntry,dwRasEntrySize,
										(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
									// UNDONE: ERROR MESSAGE

									// Update display
									//

									hr = GetDisplayableNumber();
									if (hr != ERROR_SUCCESS)
									{
										bCheckDisplayable = FALSE;
										SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszPhoneNumber);
                                        //
                                        // Now we can show the Dialing Properties Push Button again
                                        // MKarki (4/24/97)  - Fix for Bug#3511
                                        //
                                        EnableWindow (GetDlgItem (hwnd, IDC_CMDDIALPROP), TRUE);
                                        //
                                        // save the state of the Dialing Properties PushButton
                                        // MKarki (5/3/97) -  Fix for Bug#3393
                                        //
                                        bDlgPropEnabled = TRUE;

									} else {
										bCheckDisplayable = TRUE;
										SetDlgItemText(hwnd,IDC_TEXTNUMBER,m_pszDisplayable);
									}
									fUserEditedNumber = FALSE;
								}
							} else {
								MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
							}
							Assert(pszDunFile);
							GlobalFree(pszDunFile);
							pszDunFile = NULL;
						}
					}
				}
			}
			break;
		}
		break;
	default:
		lRes = FALSE;
		break;
	}
	return lRes;
}

// ############################################################################
HRESULT CDialingErrorDlg::FillModems()
{
	HRESULT hr = ERROR_SUCCESS;
	DWORD dwSize;
	DWORD idx;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	LRESULT lLast = 0;

	LPLINEDEVCAPS lpLineDevCaps = NULL;

	//
	// Get the connectoid
	//

	hr = ICWGetRasEntry(&lpRasEntry,&dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
	if (hr) goto FillModemExit;

	//
	// Get devices from RAS
	//

	m_lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,sizeof(RASDEVINFO));
	if (!m_lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto FillModemExit;
	}

	m_dwNumDev = 0;
	m_lpRasDevInfo->dwSize = sizeof(RASDEVINFO);
	dwSize = sizeof(RASDEVINFO);
	hr = m_pcRNA->RasEnumDevices(m_lpRasDevInfo,&dwSize,&m_dwNumDev);

	if (hr == ERROR_BUFFER_TOO_SMALL)
	{
		GlobalFree(m_lpRasDevInfo);

		// 3/20/97	jmazner	Olympus #1768
		m_lpRasDevInfo = NULL;

		m_lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,dwSize);
		if (!m_lpRasDevInfo)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto FillModemExit;
		}

		m_lpRasDevInfo->dwSize = sizeof(RASDEVINFO);
		m_dwNumDev = 0;

		hr = m_pcRNA->RasEnumDevices(m_lpRasDevInfo,&dwSize,&m_dwNumDev);
	}

	if (hr)
		goto FillModemExit;

	for (idx=0;idx < m_dwNumDev;idx++)
	{
		//
		// Add string to combo box
		//

		//
		// ChrisK Olympus 4560 do not add VPN's to list of modems
		//
		if (0 != lstrcmpi(TEXT("VPN"),m_lpRasDevInfo[idx].szDeviceType))
		{
			lLast = SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_ADDSTRING,0,(LPARAM)m_lpRasDevInfo[idx].szDeviceName);
			//
			// ChrisK Olympus 245 5/25/97
			// Save index of modem
			//
			SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETITEMDATA,(WPARAM)lLast,(LPARAM)idx);
			if (lstrcmp(m_lpRasDevInfo[idx].szDeviceName,lpRasEntry->szDeviceName) == 0)
				SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,(WPARAM)lLast,0);
		}
	}

	if (m_dwNumDev == 1)
		SendDlgItemMessage(m_hwnd,IDC_CMBMODEMS,CB_SETCURSEL,0,0);

FillModemExit:
	if (lpRasEntry) GlobalFree(lpRasEntry);
	lpRasEntry = NULL;
	if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	lpRasDevInfo = NULL;
	return hr;
}


// ############################################################################
// UNDONE: Collapse this function with the one in dialdlg.cpp
HRESULT CDialingErrorDlg::GetDisplayableNumber()
{
	HRESULT hr;
	LPRASENTRY lpRasEntry = NULL;
	LPRASDEVINFO lpRasDevInfo = NULL;
	LPLINETRANSLATEOUTPUT lpOutput1;
	LPLINETRANSLATEOUTPUT lpOutput2;
	HINSTANCE hRasDll = NULL;
	// Normandy 11745
	// FARPROC fp = NULL;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	Assert(VALID_INIT);

	// Format the phone number
	//

	lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,sizeof(TCHAR)*sizeof(LINETRANSLATEOUTPUT));
	if (!lpOutput1)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	// Get phone number from connectoid
	//
	hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}
	//
	// If this is a dial as is number, just get it from the structure
	//
	if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
	{
		if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
		m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
		if (!m_pszDisplayable)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lstrcpy(m_pszPhoneNumber, lpRasEntry->szLocalPhoneNumber);
		lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
	}
	else
	{
		//
		// If there is no area code, don't use parentheses
		//
		if (lpRasEntry->szAreaCode[0])
			wsprintf(m_pszPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
 		else
			wsprintf(m_pszPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
						lpRasEntry->szLocalPhoneNumber);

		
		// Turn the canonical form into the "displayable" form
		//

		hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
									0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);

		if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
		{
			lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,lpOutput1->dwNeededSize);
			if (!lpOutput2)
			{
				hr = ERROR_NOT_ENOUGH_MEMORY;
				goto GetDisplayableNumberExit;
			}
			lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
			GlobalFree(lpOutput1);
			lpOutput1 = lpOutput2;
			lpOutput2 = NULL;
			hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
										0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);
		}

		if (hr != ERROR_SUCCESS)
		{
			goto GetDisplayableNumberExit;
		}

		StrDup(&m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset]);
	}

GetDisplayableNumberExit:
	 if (lpRasEntry) GlobalFree(lpRasEntry);
	 lpRasEntry = NULL;
	 if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
	 lpRasDevInfo = NULL;
	 if (lpOutput1) GlobalFree(lpOutput1);
	 lpOutput1 = NULL;

	return hr;
}
/**
// ############################################################################
HRESULT ShowDialErrDialog(HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd)
{
	int iRC;
//	CDialErrDlg *pcDED = NULL;

	g_pcDialErr = (PDIALERR)GlobalAlloc(LPTR,sizeof(DIALERR));
	if (!g_pcDialErr)
	{
		MessageBox(hwnd,GetSz(IDS_OUTOFMEMORY),GetSz(IDS_TITLE),MB_APPLMODAL | MB_ICONERROR);
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	
	g_pcDialErr->m_pszConnectoid = (LPTSTR)GlobalAlloc(LPTR,RAS_MaxEntryName);
	if (!g_pcDialErr->m_pszConnectoid)
	{
		iRC = ERROR_NOT_ENOUGH_MEMORY;
		goto ShowDialErrDialogExit;
	}
	lstrcpyn(g_pcDialErr->m_pszConnectoid,pszConnectoid,RAS_MaxEntryName);
	g_pcDialErr->m_hrError = hrErr;
	g_pcDialErr->m_hInst = hInst;

	iRC = DialogBoxParam(g_pcDialErr->m_hInst,MAKEINTRESOURCE(IDD_DIALERR),hwnd,DialErrDlgProc,(LPARAM)g_pcDialErr);

	lstrcpyn(pszConnectoid,g_pcDialErr->m_pszConnectoid,RAS_MaxEntryName);

ShowDialErrDialogExit:
	if (g_pcDialErr->m_lprasdevinfo) GlobalFree(g_pcDialErr->m_lprasdevinfo);
	if (g_pcDialErr) GlobalFree(g_pcDialErr);
	return iRC;
}
**/

/**
// ############################################################################
HRESULT CDialingErrorDlg::DialErrGetDisplayableNumber()
{
	DWORD dwNumDev;
	HRESULT hr;
	LPRASENTRY lpRasEntry;
	LPRASDEVINFO lpRasDevInfo;
	DWORD dwRasEntrySize;
	DWORD dwRasDevInfoSize;
	LPLINETRANSLATEOUTPUT lpOutput1;
	LPLINETRANSLATEOUTPUT lpOutput2;
	LPLINEEXTENSIONID lpExtensionID = NULL;
	HINSTANCE hRasDll = NULL;
	FARPROC fp = NULL;

	//RNAAPI * pcRNA;

	//  Initialize TAPIness
	//
	dwNumDev = 0;
	hr = lineInitialize(&g_pcDialErr->m_hLineApp,g_pcDialErr->m_hInst,LineCallback,NULL,&dwNumDev);

	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	if (g_pdevice->dwTapiDev == 0xFFFFFFFF)
	{
		// if (dwNumDev == 1)
			g_pdevice->dwTapiDev = 0;
		//else
		// UNDONE: Tell the user to select a modem
		// DO NOT EXIT UNTIL THEY PICK ONE
	}

	lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(LPTR,sizeof(LINEEXTENSIONID));
	if (!lpExtensionID)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	hr = lineNegotiateAPIVersion(g_pcDialErr->m_hLineApp, g_pdevice->dwTapiDev, 0x00010004, 0x00010004,
		&g_pcDialErr->m_dwAPIVersion, lpExtensionID);

	// ditch it since we don't use it
	//
	if (lpExtensionID) GlobalFree(lpExtensionID);
	lpExtensionID = NULL;
	if (hr != ERROR_SUCCESS)
		goto GetDisplayableNumberExit;

	// Format the phone number
	//

	lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,sizeof(LINETRANSLATEOUTPUT));
	if (!lpOutput1)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	// Get phone number from connectoid
	//

	lpRasEntry = (LPRASENTRY)GlobalAlloc(LPTR,sizeof(RASENTRY));
	if (!lpRasEntry)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lpRasDevInfo = (LPRASDEVINFO)GlobalAlloc(LPTR,sizeof(RASDEVINFO));
	if (!lpRasDevInfo)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}
	dwRasEntrySize = sizeof(RASENTRY);
	dwRasDevInfoSize = sizeof(RASDEVINFO);

	lpRasEntry->dwSize = dwRasEntrySize;
	lpRasDevInfo->dwSize = dwRasDevInfoSize;

	hRasDll = LoadLibrary(TEXT("RASAPI32.DLL"));
	if (!hRasDll)
	{
		hr = GetLastError();
		goto GetDisplayableNumberExit;
	}
	fp =GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
	if (!fp)
	{
		FreeLibrary(hRasDll);
		hRasDll = LoadLibrary(TEXT("RNAPH.DLL"));
		if (!hRasDll)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
		fp = GetProcAddress(hRasDll,"RasGetEntryPropertiesA");
		if (!fp)
		{
			hr = GetLastError();
			goto GetDisplayableNumberExit;
		}
	}

	hr = ((PFNRASGETENTRYPROPERTIES)fp)(NULL,g_pcDialErr->m_pszConnectoid,(LPBYTE)lpRasEntry,&dwRasEntrySize,(LPBYTE)lpRasDevInfo,&dwRasDevInfoSize);
	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	FreeLibrary(hRasDll);

	wsprintf(g_pcDialErr->m_szPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
	
	// Turn the canonical form into the "displayable" form
	//

	hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
								g_pcDialErr->m_dwAPIVersion,
								g_pcDialErr->m_szPhoneNumber,0,
								LINETRANSLATEOPTION_CANCELCALLWAITING,
								lpOutput1);

	if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
	{
		lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LPTR,lpOutput1->dwNeededSize);
		if (!lpOutput2)
		{
			hr = ERROR_NOT_ENOUGH_MEMORY;
			goto GetDisplayableNumberExit;
		}
		lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
		GlobalFree(lpOutput1);
		lpOutput1 = lpOutput2;
		lpOutput2 = NULL;
		hr = lineTranslateAddress(g_pcDialErr->m_hLineApp,g_pdevice->dwTapiDev,
									g_pcDialErr->m_dwAPIVersion,
									g_pcDialErr->m_szPhoneNumber,0,
									LINETRANSLATEOPTION_CANCELCALLWAITING,
									lpOutput1);
	}

	if (hr != ERROR_SUCCESS)
	{
		goto GetDisplayableNumberExit;
	}

	g_pcDialErr->m_pszDisplayable = (LPTSTR)GlobalAlloc(LPTR,lpOutput1->dwDisplayableStringSize+1);
	if (!g_pcDialErr->m_pszDisplayable)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto GetDisplayableNumberExit;
	}

	lstrcpyn(g_pcDialErr->m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],lpOutput1->dwDisplayableStringSize);

GetDisplayableNumberExit:
	if (g_pcDialErr->m_hLineApp)
	{
		lineShutdown(g_pcDialErr->m_hLineApp);
		g_pcDialErr->m_hLineApp = NULL;
	}

	return hr;
}
**/

//+----------------------------------------------------------------------------
//
//	Function:	CDialingErrorDlg::CreateDialAsIsConnectoid
//
//	Synopsis:	Using the string in the editable text box create a dia-as-is 
//				connectoid
//
//	Arguemnts:	lpszDialNumber string containing the to-be-dailed number
//
//	Returns:	Error value (ERROR_SUCCESS == success)
//
//	History:	8/29/96	Chrisk	Created
//
//-----------------------------------------------------------------------------
HRESULT CDialingErrorDlg::CreateDialAsIsConnectoid(LPCTSTR lpszDialNumber)
{
	HRESULT hr = ERROR_SUCCESS;
	LPRASENTRY lpRasEntry=NULL;
	LPRASDEVINFO lpRasDevInfo=NULL;
	RNAAPI *pcRNA = NULL;
	LPCTSTR p, p2;

	DWORD dwRasEntrySize = 0;
	DWORD dwRasDevInfoSize = 0;

	Assert(lpszDialNumber);

	// Check that the phone number only contains valid characters
	//

	//
	// 5/17/97 jmazner Olympus #137
	// check for DBCS characters
	//
#ifndef WIN16
	if( !IsSBCSString( lpszDialNumber) )
	{
		MsgBox(IDS_SBCSONLY,MB_MYERROR);
		SetFocus(GetDlgItem(m_hwnd,IDC_TEXTNUMBER));
		SendMessage(GetDlgItem(m_hwnd, IDC_TEXTNUMBER),
						EM_SETSEL,
						(WPARAM) 0,
						(LPARAM) -1);
		hr = ERROR_INVALID_PARAMETER;
		goto CreateDialAsIsConnectoidExit;

	}
#endif
	
	for (p = lpszDialNumber;*p;p++)
	{
		for(p2 = szValidPhoneCharacters;*p2;p2++)
		{
			if (*p == *p2)
				break; // p2 for loop
		}
		if (!*p2) break; // p for loop
	}

	if (*p)
	{
		MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
		//
		// Set the focus back to the phone number field
		//
		SetFocus(GetDlgItem(m_hwnd,IDC_TEXTNUMBER));
		{
			hr = ERROR_INVALID_PARAMETER;
			goto CreateDialAsIsConnectoidExit;
		}
	}

	//hr = ICWGetRasEntry(&lpRasEntry,&lpRasDevInfo,m_pszConnectoid);
	hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);

	if (ERROR_SUCCESS != hr)
		goto CreateDialAsIsConnectoidExit;

	// Replace the phone number with the new one
	//
	lstrcpy(lpRasEntry->szLocalPhoneNumber, lpszDialNumber);

	//
	// This is dummy information and will not effect the dialed string
	// This information is required due to bugs in RAS apis.
	//
	lpRasEntry->dwCountryID = 1;
	lpRasEntry->dwCountryCode = 1;
	lpRasEntry->szAreaCode[0] = '8';
	lpRasEntry->szAreaCode[1] = '\0';

	// Set to dial as is
	//
	lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

	if (!pcRNA) pcRNA = new RNAAPI;
	if (!pcRNA)
	{
		hr = ERROR_NOT_ENOUGH_MEMORY;
		goto CreateDialAsIsConnectoidExit;
	}


	// jmazner 10/10/96  Normandy #9066
	// Don't assume that sizeof lpRasEntry and lpRasDevInfo buffers is that of their
	// respective structs; RasGetEntryProperties sometimes needs these buffers to be
	// larger than just the struct!
//	hr = pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,
//		sizeof(RASENTRY),(LPBYTE)lpRasDevInfo,sizeof(RASDEVINFO));
	hr = pcRNA->RasSetEntryProperties(NULL,m_pszConnectoid,(LPBYTE)lpRasEntry,
		dwRasEntrySize,(LPBYTE)lpRasDevInfo,dwRasDevInfoSize);
	if (hr != ERROR_SUCCESS)
	{
		MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
		goto CreateDialAsIsConnectoidExit;
	}

CreateDialAsIsConnectoidExit:
	if (lpRasEntry)
		GlobalFree(lpRasEntry);
	lpRasEntry = NULL;
	if (lpRasDevInfo) 
		GlobalFree(lpRasDevInfo);
	lpRasDevInfo = NULL;
	if (pcRNA) 
		delete pcRNA;
	pcRNA = NULL;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dialdlg.cpp ===
/*-----------------------------------------------------------------------------
    dialdlg.cpp

    Implement functionality of dialing and download progress dialog

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "icwdl.h"
#include "resource.h"
// the progress bar messages are defined in commctrl.h, but we can't include
// it, because it introduces a conflicting definition for strDup.
// so, just take out the one #define that we need
//#include <commctrl.h>
#define PBM_SETPOS              (WM_USER+2)

#define WM_DIAL WM_USER + 3
#define MAX_EXIT_RETRIES 10
#define MAX_RETIES 3

#define VALID_INIT (m_pcRNA && m_pcDLAPI)


// ############################################################################
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3)
{
}

//+----------------------------------------------------------------------------
//
//    Function: NeedZapper
//
//    Synopsis:    Checks to see if we need to handle the RNA connection dialog.
//                Only builds earlier than 1071 will have the RNA connection dialog
//
//    Arguments:    None
//
//    Returns:    True - the RNA dialog will have to be handled
//
//    History:    ArulM    Created        7/18/96
//                ChrisK    Installed into autodialer    7/19/96
//
//-----------------------------------------------------------------------------
static BOOL NeedZapper(void)
{
    OSVERSIONINFO oi;
    memset(&oi, 0, sizeof(oi));
    oi.dwOSVersionInfoSize = sizeof(oi);

    if( GetVersionEx(&oi) && 
       (oi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) &&
       (oi.dwMajorVersion==4) &&
       (oi.dwMinorVersion==0) &&
       (LOWORD(oi.dwBuildNumber) <= 1070) )
            return TRUE;
    else
            return FALSE;
}

// ############################################################################
VOID WINAPI ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    if (dwContext)
        ((CDialingDlg*)dwContext)->ProgressCallBack(hInternet,dwContext,dwInternetStatus,
                                                    lpvStatusInformation,
                                                    dwStatusInformationLength);
}

// ############################################################################
HRESULT WINAPI DialingDownloadDialog(PDIALDLGDATA pDD)
{
    HRESULT hr = ERROR_SUCCESS;
    CDialingDlg *pcDialDlg;
    LPLINEEXTENSIONID lpExtensionID=NULL;

    // Validate parameters
    //
    Assert(pDD);

    if (!pDD)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto DialingDownloadDialogExit;
    }

    if (pDD->dwSize < sizeof(DIALDLGDATA))
    {
        hr = ERROR_BUFFER_TOO_SMALL;
        goto DialingDownloadDialogExit;
    }

    // Alloc and fill dialog object
    //

    pcDialDlg = new CDialingDlg;
    if (!pcDialDlg)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialingDownloadDialogExit;
    }

    if (ERROR_SUCCESS != (hr = pcDialDlg->Init()))
        goto DialingDownloadDialogExit;

    StrDup(&pcDialDlg->m_pszConnectoid,pDD->pszRasEntryName);
    StrDup(&pcDialDlg->m_pszMessage,pDD->pszMessage);
    StrDup(&pcDialDlg->m_pszUrl,pDD->pszMultipartMIMEUrl);
    StrDup(&pcDialDlg->m_pszDunFile,pDD->pszDunFile);
    pcDialDlg->m_pfnStatusCallback = pDD->pfnStatusCallback;
    pcDialDlg->m_hInst = pDD->hInst;
    pcDialDlg->m_bSkipDial = pDD->bSkipDial;

    // Initialize TAPI
    //
    hr = lineInitialize(&pcDialDlg->m_hLineApp,pcDialDlg->m_hInst,LineCallback,NULL,&pcDialDlg->m_dwNumDev);
    if (hr != ERROR_SUCCESS)
        goto DialingDownloadDialogExit;

    AssertMsg(pcDialDlg->m_dwTapiDev < pcDialDlg->m_dwNumDev,"The user has selected an invalid TAPI device.\n");

    lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
    if (!lpExtensionID)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialingDownloadDialogExit;
    }

    hr = lineNegotiateAPIVersion(pcDialDlg->m_hLineApp, pcDialDlg->m_dwTapiDev, 
        0x00010004, 0x00010004,&pcDialDlg->m_dwAPIVersion, lpExtensionID);

    // 4/2/97    ChrisK    Olympus 2745
    while (ERROR_SUCCESS != hr && pcDialDlg->m_dwTapiDev < (pcDialDlg->m_dwNumDev - 1))
    {
        pcDialDlg->m_dwTapiDev++;
        hr = lineNegotiateAPIVersion(pcDialDlg->m_hLineApp, pcDialDlg->m_dwTapiDev, 
            0x00010004, 0x00010004,&pcDialDlg->m_dwAPIVersion, lpExtensionID);
    }

    // Delete the extenstion ID since we don't use it, but keep the version information.
    //
    if (lpExtensionID) GlobalFree(lpExtensionID);
    if (hr != ERROR_SUCCESS)
        goto DialingDownloadDialogExit;

    // Call back filter for reconnect
    pcDialDlg->m_pfnRasDialFunc1 = pDD->pfnRasDialFunc1;

    // Display dialog
    //
    hr = (HRESULT)DialogBoxParam(GetModuleHandle(TEXT("ICWDIAL")),MAKEINTRESOURCE(IDD_DIALING),
        pDD->hParentHwnd,GenericDlgProc,(LPARAM)pcDialDlg);

    if (pDD->phRasConn)
        *(pDD->phRasConn) = pcDialDlg->m_hrasconn;

// 4/2/97    ChrisK    Olympus 296
// This is now handled inside the dialog
//#if !defined(WIN16)
//    if ((ERROR_USERNEXT == hr) && NeedZapper())
//        MinimizeRNAWindow(pDD->pszRasEntryName,GetModuleHandle("ICWDIAL"));
//#endif

// BUGBUG: on an error wait for the connection to die

DialingDownloadDialogExit:
    // Close tapi line
    //
    if (NULL != pcDialDlg)
    {
        // 4/2/97    ChrisK    Olympus 296
        if (pcDialDlg->m_hLineApp)
        {
            lineShutdown(pcDialDlg->m_hLineApp);    
            pcDialDlg->m_hLineApp = NULL;
        }
        //
        // ChrisK 296 6/3/97
        // Broaden window
        //
        // StopRNAReestablishZapper(g_hRNAZapperThread);
    }

    //
    // 5/23/97 jmazner Olympus #4652
    //
    delete(pcDialDlg);
    
    return hr;
}

// ############################################################################
CDialingDlg::CDialingDlg()
{
    m_hrasconn = NULL;
    m_pszConnectoid = NULL;
    m_hThread = NULL;
    m_dwThreadID = 0;
    m_hwnd = NULL;
    m_pszUrl = NULL;
    m_pszDisplayable = NULL;
    m_dwDownLoad = 0;
    m_pszPhoneNumber = NULL;
    m_pszMessage = NULL;
    m_pfnStatusCallback = NULL;
    m_unRasEvent = 0;
    m_pszDunFile = NULL;
    m_hLineApp = NULL;
    m_dwNumDev = 0;
    m_dwTapiDev = 0;
    m_dwAPIVersion = 0;
    m_pcRNA = NULL;
//    m_hDownLoadDll = NULL;
    m_bProgressShowing = FALSE;
    m_dwLastStatus = 0;
    m_pcDLAPI = NULL;
    m_bSkipDial = FALSE;

    // Normandy 11919 - ChrisK
    // Do not prompt to exit on dialing dialog since we don't exit the app from
    // here
    m_bShouldAsk = FALSE;

    //
    // ChrisK 5240 Olympus
    // Only the thread that creates the dwDownload should invalidate it
    // so we need another method to track if the cancel button has been
    // pressed.
    //
    m_fDownloadHasBeenCanceled = FALSE;
}

// ############################################################################
HRESULT CDialingDlg::Init()
{
    HRESULT hr = ERROR_SUCCESS;
    m_pcRNA = new RNAAPI;
    if (!m_pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

    m_pcDLAPI = new CDownLoadAPI;
    if (!m_pcDLAPI)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

    m_pszPhoneNumber = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*256);
    if (!m_pszPhoneNumber)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto InitExit;
    }

InitExit:
    return hr;
}

// ############################################################################
CDialingDlg::~CDialingDlg()
{
    TraceMsg(TF_GENERAL, "ICWDIAL: CDialingDlg::~CDialingDlg");
    //
    // 5/25/97 ChrisK I know this will leak the connection but that's ok
    // since we sweep this up later and in the meantime we need to close
    // out the object
    //
    //if (m_hrasconn && m_pcRNA)
    //{
    //    m_pcRNA->RasHangUp(m_hrasconn);
    //}
    //m_hrasconn = NULL;

    if (m_pszConnectoid) GlobalFree(m_pszConnectoid);
    m_pszConnectoid = NULL;


    if (m_pszUrl) GlobalFree(m_pszUrl);
    m_pszUrl = NULL;

    if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
    m_pszDisplayable = NULL;

    //
    // ChrisK 5240 Olympus
    // Only the thread that creates the dwDownload should invalidate it
    // so we need another method to track if the cancel button has been
    // pressed.
    //

    //
    // ChrisK 6/24/97    Olympus 6373
    // We have to call DownLoadClose even if the download was canceled because
    // we have to release the semaphores
    //
    if (m_dwDownLoad && m_pcDLAPI)
    {
        m_pcDLAPI->DownLoadClose(m_dwDownLoad);
        m_fDownloadHasBeenCanceled = TRUE;
    }
    m_dwDownLoad = 0;

    if (m_hThread)
    {
        //
        // 5/23/97    jmazner    Olympus #4652
        //
        // we want to make sure the thread is killed before
        // we delete the m_pcDLApi that it relies on.
        //
        WaitForSingleObject(m_hThread, INFINITE);
        CloseHandle(m_hThread);
    }
    m_hThread = NULL;

    m_dwThreadID = 0;
    m_hwnd = NULL;


    if (m_pszPhoneNumber) GlobalFree(m_pszPhoneNumber);
    m_pszPhoneNumber = NULL;

    if (m_pszMessage) GlobalFree(m_pszMessage);
    m_pszMessage = NULL;

    m_pfnStatusCallback=NULL;

    if (m_pszDunFile) GlobalFree(m_pszDunFile);
    m_pszDunFile = NULL;

    if (m_hLineApp) lineShutdown(m_hLineApp);
    m_hLineApp = NULL;

    m_dwNumDev = 0;
    m_dwTapiDev = 0;
    m_dwAPIVersion = 0;

    if (m_pcRNA) delete m_pcRNA;
    m_pcRNA = NULL;

    m_bProgressShowing = FALSE;
    m_dwLastStatus = 0;

    if (m_pcDLAPI) delete m_pcDLAPI;
    m_pcDLAPI = NULL;

    //
    // 4/2/97    ChrisK    Olympus 296
    //
    StopRNAReestablishZapper(g_hRNAZapperThread);
    
}

// ############################################################################
LRESULT CDialingDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam, LRESULT lres)
{
    HRESULT hr;
    // Normandy 11745
    // WORD wIDS;
    FARPROC fp;
    DWORD dwThreadResults;
    INT iRetries;
    static bDisconnect;

    Assert(VALID_INIT);

    switch(uMsg)
    {
    case WM_INITDIALOG:

        //
        // Register with caller's filter
        //
        if (m_pfnRasDialFunc1)
            (m_pfnRasDialFunc1)(NULL,WM_RegisterHWND,RASCS_OpenPort,HandleToUlong(hwnd),0);

        m_hwnd = hwnd;

        m_bProgressShowing = FALSE;

        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS),SW_HIDE);

        m_unRasEvent = RegisterWindowMessageA(RASDIALEVENT);
        if (m_unRasEvent == 0) m_unRasEvent = WM_RASDIALEVENT;

        // Bug Normandy 5920
        // ChrisK, turns out we are calling MakeBold twice
        // MakeBold(GetDlgItem(m_hwnd,IDC_LBLTITLE),TRUE,FW_BOLD);

        IF_NTONLY
            bDisconnect = FALSE;
        ENDIF_NTONLY

        //
        // Show number to be dialed
        //
        
        if (m_bSkipDial)
        {
            PostMessage(m_hwnd,m_unRasEvent,RASCS_Connected,SUCCESS);
        }
        else
        {
            hr = GetDisplayableNumberDialDlg();
            if (hr != ERROR_SUCCESS)
            {
                SetDlgItemText(m_hwnd,IDC_LBLNUMBER,m_pszPhoneNumber);
            } else {
                SetDlgItemText(m_hwnd,IDC_LBLNUMBER,m_pszDisplayable);
            }

            PostMessage(m_hwnd,WM_DIAL,0,0);
        }
        lres = TRUE;
        break;
    case WM_DIAL:
        SetForegroundWindow(m_hwnd);
        hr = DialDlg();

        if (hr != ERROR_SUCCESS)
            EndDialog(m_hwnd,hr);
        lres = TRUE;
        break;
    case WM_COMMAND:
        switch(LOWORD(wparam))
        {
        case IDC_CMDCANCEL:
            //
            // Tell the user what we are doing, since it may take awhile
            //
            SetDlgItemText(m_hwnd,IDC_LBLSTATUS,GetSz(IDS_RAS_HANGINGUP));

            //
            // Cancel download first, HangUp second....
            //

            //
            // ChrisK 5240 Olympus
            // Only the thread that creates the dwDownload should invalidate it
            // so we need another method to track if the cancel button has been
            // pressed.
            //
            if (m_dwDownLoad && m_pcDLAPI && !m_fDownloadHasBeenCanceled)
            {
                m_pcDLAPI->DownLoadCancel(m_dwDownLoad);
                m_fDownloadHasBeenCanceled = TRUE;
            }

            if (m_pcRNA && m_hrasconn)
            {
                m_pcRNA->RasHangUp(m_hrasconn);
            }
            PostMessage(m_hwnd,m_unRasEvent,(WPARAM)RASCS_Disconnected,(LPARAM)ERROR_USER_DISCONNECTION);
            lres = TRUE;
            break;
        }
        break;
    case WM_CLOSE:
        // CANCEL First, HangUp second....
        //

        //
        // ChrisK 5240 Olympus
        // Only the thread that creates the dwDownload should invalidate it
        // so we need another method to track if the cancel button has been
        // pressed.
        //
        if (m_dwDownLoad && m_pcDLAPI && !m_fDownloadHasBeenCanceled)
        {
            m_pcDLAPI->DownLoadCancel(m_dwDownLoad);
            m_fDownloadHasBeenCanceled = TRUE;
        }

        if (m_pcRNA && m_hrasconn)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
        }
        EndDialog(hwnd,ERROR_USERCANCEL);
        m_hwnd = NULL;

        lres = TRUE;
        break;
    case WM_DOWNLOAD_DONE:
        dwThreadResults = STILL_ACTIVE;
        iRetries = 0;
        if (m_pcRNA && m_hrasconn)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
        }

        do {
            if (!GetExitCodeThread(m_hThread,&dwThreadResults))
            {
                AssertMsg(0,"CONNECT:GetExitCodeThread failed.\n");
            }

            iRetries++;
            if (dwThreadResults == STILL_ACTIVE) Sleep(500);
        } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);

        if (dwThreadResults == ERROR_SUCCESS)
            EndDialog(hwnd,ERROR_USERNEXT);
        else
            EndDialog(hwnd,dwThreadResults);
        lres = TRUE;
        break;
    default:
        if (uMsg == m_unRasEvent)
        {
            TCHAR szRasError[10];
            TCHAR szRasMessage[256];
            wsprintf(szRasError,TEXT("%d %d"),wparam,lparam);
            RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,
                szRasError,lstrlen(szRasError));

            TraceMsg(TF_GENERAL, "AUTODIAL: Ras message %d error (%d).\n",wparam,lparam);
            hr = m_pfnStatusCallback((DWORD)wparam, szRasMessage, 256);

            if (!hr)
                SetDlgItemText(m_hwnd,IDC_LBLSTATUS,szRasMessage);

            switch(wparam)
            {
            case RASCS_Connected:

#if !defined(WIN16)
                // 4/2/97    ChrisK    Olympus 296

                //
                // ChrisK Olympus 6060 6/10/97
                // If the URL is blank, then we don't need the zapper thread.
                //
                if (NeedZapper())
                {
                    HMODULE hMod;
                    hMod = GetModuleHandle(TEXT("ICWDIAL"));
                    MinimizeRNAWindow(m_pszConnectoid,hMod);
                    if (m_pszUrl && m_pszUrl[0])
                    {
                        g_hRNAZapperThread = LaunchRNAReestablishZapper(hMod);
                    }
                    hMod = NULL;
                }
#endif
                if (m_pszUrl)
                {
                    //
                    //  we should now let the user know that we 
                    //  are downloading
                    //  MKarki (5/5/97) - Fix for Bug#423
                    //
                    SetDlgItemText(m_hwnd,IDC_LBLSTATUS,GetSz (IDS_DOWNLOADING));

                    // The connection is open and ready.  Start the download.
                    //

                    m_dwThreadID = 0;
                    m_hThread = CreateThread(NULL,0,
                        (LPTHREAD_START_ROUTINE)DownloadThreadInit,this,0,&m_dwThreadID);
                    if (!m_hThread)
                    {
                        hr = GetLastError();

                        if (m_pcRNA && m_hrasconn)
                        {
                            m_pcRNA->RasHangUp(m_hrasconn);
                            m_hrasconn = NULL;
                        }

                        EndDialog(m_hwnd,hr);
                        break;
                    }
                } else {
                    EndDialog(m_hwnd,ERROR_USERNEXT);
                }
                break;

            case RASCS_Disconnected:
                IF_NTONLY
                    // There is a possibility that we will get multiple disconnects in NT
                    // and we only want to handle the first one. Note: the flag is reset
                    // in the INITIALIZE event, so we should handle 1 disconnect per instance
                    // of the dialog.
                    if (bDisconnect)
                        break;
                    else
                        bDisconnect = TRUE;
                ENDIF_NTONLY
                if (m_hrasconn && m_pcRNA) m_pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
                EndDialog(m_hwnd,lparam);
                break;
            default:
                IF_NTONLY
                    if (SUCCESS != lparam)
                    {
                        PostMessage(m_hwnd,m_unRasEvent,(WPARAM)RASCS_Disconnected,lparam);
                    }
                ENDIF_NTONLY
            }
        }
    }

return lres;
}

// ############################################################################
HRESULT CDialingDlg::GetDisplayableNumberDialDlg()
{
    HRESULT hr;
    LPRASENTRY lpRasEntry = NULL;
    LPRASDEVINFO lpRasDevInfo = NULL;
    DWORD dwRasEntrySize = 0;
    DWORD dwRasDevInfoSize = 0;
    LPLINETRANSLATEOUTPUT lpOutput1 = NULL;
    LPLINETRANSLATEOUTPUT lpOutput2 = NULL;
    HINSTANCE hRasDll = NULL;
    FARPROC fp = NULL;

    Assert(VALID_INIT);

    // Format the phone number
    //

    lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
    if (!lpOutput1)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto GetDisplayableNumberExit;
    }
    lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

    // Get phone number from connectoid
    //
    hr = ICWGetRasEntry(&lpRasEntry, &dwRasEntrySize, &lpRasDevInfo, &dwRasDevInfoSize, m_pszConnectoid);
    if (hr != ERROR_SUCCESS)
        goto GetDisplayableNumberExit;

    //
    // If this is a dial as is number, just get it from the structure
    //
    if (!(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes))
    {
        if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lstrcpy(m_pszPhoneNumber, lpRasEntry->szLocalPhoneNumber);
        lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
        //
        // If there is no area code, don't use parentheses
        //
        if (lpRasEntry->szAreaCode[0])
                wsprintf(m_pszPhoneNumber,TEXT("+%d (%s) %s\0"),lpRasEntry->dwCountryCode,lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
         else
            wsprintf(m_pszPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szLocalPhoneNumber);

    
        // Turn the canonical form into the "displayable" form
        //

        hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
                                    0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);

        if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
        {
            lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,lpOutput1->dwNeededSize);
            if (!lpOutput2)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetDisplayableNumberExit;
            }
            lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
            GlobalFree(lpOutput1);
            lpOutput1 = lpOutput2;
            lpOutput2 = NULL;
            hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,m_pszPhoneNumber,
                                        0,LINETRANSLATEOPTION_CANCELCALLWAITING,lpOutput1);
        }

        if (hr != ERROR_SUCCESS)
        {
            goto GetDisplayableNumberExit;
        }

        StrDup(&m_pszDisplayable,(LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset]);
     }

GetDisplayableNumberExit:
     if (lpRasEntry) GlobalFree(lpRasEntry);
     lpRasEntry = NULL;
     if (lpRasDevInfo) GlobalFree(lpRasDevInfo);
     lpRasDevInfo = NULL;
     if (lpOutput1) GlobalFree(lpOutput1);
     lpOutput1 = NULL;

    return hr;
}

// ############################################################################
HRESULT CDialingDlg::DialDlg()
{
    TCHAR szPassword[PWLEN+2];
    LPRASDIALPARAMS lpRasDialParams = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bPW;

    Assert(VALID_INIT);

    // Get connectoid information
    //

    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName,m_pszConnectoid,RAS_MaxEntryName);
    bPW = FALSE;

    hr = m_pcRNA->RasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto DialExit;
    }

    // Add the user's password
    //
    szPassword[0] = 0;
    if (GetISPFile() != NULL && *(GetISPFile()) != TEXT('\0'))
    {
        // GetPrivateProfileString examines one character before the filename
        // if it is an empty string, which could result in AV, if the address 
        // refers to an invalid page.
        GetPrivateProfileString(
                    INFFILE_USER_SECTION,INFFILE_PASSWORD,
                    NULLSZ,szPassword,PWLEN + 1,GetISPFile());
    }

    // if didnt get password, then try to get from DUN file (if any)
    if(!szPassword[0] && m_pszDunFile)
    {
        // 4-29-97 Chrisk Olympus 3985
        // Due to the wrong filename being used, the password was always being set to
        // NULL and therefore requiring the user to provide the password to log onto the 
        // signup server.
        GetPrivateProfileString(
                    INFFILE_USER_SECTION,INFFILE_PASSWORD,
                    NULLSZ,szPassword,PWLEN + 1,m_pszDunFile);
                    //NULLSZ,szPassword,PWLEN + 1,g_szCurrentDUNFile);
    }

    if(szPassword[0])
    {
        lstrcpyn(lpRasDialParams->szPassword, szPassword,PWLEN+1);
        TraceMsg(TF_GENERAL, "ICWDIAL: Password is not blank.\r\n");
    }
    else
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Password is blank.\r\n");
    }
    

    // Dial connectoid
    //

    Assert(!m_hrasconn);

#if !defined(WIN16) && defined(DEBUG)
    if (FCampusNetOverride())
    {
        //
        // Skip dialing because the server is on the campus network
        //
        PostMessage(m_hwnd,RegisterWindowMessageA(RASDIALEVENT),RASCS_Connected,0);
    }
    else
    {
#endif // !WIN16 && DEBUG

    if (m_pfnRasDialFunc1)
        hr = m_pcRNA->RasDial(NULL,NULL,lpRasDialParams,1,m_pfnRasDialFunc1,&m_hrasconn);
    else
        hr = m_pcRNA->RasDial(NULL,NULL,lpRasDialParams,0xFFFFFFFF,m_hwnd,&m_hrasconn);

    if (hr != ERROR_SUCCESS)
    {
        if (m_hrasconn && m_pcRNA)
        {
            m_pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
        }
        goto DialExit;
    }

#if !defined(WIN16) && defined(DEBUG)
    }
#endif

    if (lpRasDialParams) GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

DialExit:
    return hr;
}

// ############################################################################
VOID CDialingDlg::ProgressCallBack(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    TCHAR szRasMessage[256];
    HRESULT hr = ERROR_SUCCESS;
    WPARAM *puiStatusInfo = NULL;

    //
    // 5/28/97 jmazner Olympus #4579
    // *lpvStatusInformation is the percentage of completed download,
    // as a value from 0 to 100.
    //
    puiStatusInfo = (WPARAM *) lpvStatusInformation;
    Assert(    puiStatusInfo );
    Assert( *puiStatusInfo <= 100 );

    Assert(VALID_INIT);

    if (!m_bProgressShowing) 
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS),SW_SHOW);

    if (m_dwLastStatus != dwInternetStatus)
    {
        hr = m_pfnStatusCallback(dwInternetStatus,szRasMessage,256);
        if (!hr)
            SetDlgItemText(m_hwnd,IDC_LBLSTATUS,szRasMessage);
        m_dwLastStatus = dwInternetStatus;
        TraceMsg(TF_GENERAL, "CONNECT:inet status:%s, %d, %d.\n",szRasMessage,m_dwLastStatus,dwInternetStatus);
    }

    //
    // 5/28/97 jmazner Olympus #4579
    // Send update messages to the progress bar
    //

    PostMessage(GetDlgItem(m_hwnd,IDC_PROGRESS), PBM_SETPOS, *puiStatusInfo, 0);

    m_bProgressShowing = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\dialutil.cpp ===
/*-----------------------------------------------------------------------------
    dialutil.cpp

    Miscellenous housekeeping functions for autodial handler

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <raserror.h>
#include <tapi.h>
#include "dialutil.h"
#include "resource.h"

#define CANONICAL_CAP      TEXT("+%d (%s) %s")
#define CANONICAL_CXP      TEXT("+%d %s")

#define TAPI_VERSION        0x00010004

#define SMALLBUFLEN 80
#define ASSERT(c)
#define TRACE_OUT(c)

#define lstrnicmp(sz1, sz2, cch)          (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)
#define lstrncmp(sz1, sz2, cch)           (CompareString(LOCALE_USER_DEFAULT, 0, sz1, cch, sz2, cch) - 2)

typedef DWORD (WINAPI * RASGETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        LPDWORD lpdwEntrySize, LPBYTE lpb, LPDWORD lpdwSize);
typedef DWORD (WINAPI * RASSETENTRYPROPERTIES)
        (LPTSTR lpszPhonebook, LPTSTR szEntry, LPBYTE lpbEntry,
        DWORD dwEntrySize, LPBYTE lpb, DWORD dwSize);

extern HINSTANCE g_hInstance;

static const HWND hwndNil = NULL;

static const TCHAR szRnaAppWindowClass[] = TEXT("#32770");    // hard coded dialog class name

static const CHAR szRasGetEntryProperties[] = "RasGetEntryProperties";
static const CHAR szRasSetEntryProperties[] = "RasSetEntryProperties";
static const TCHAR szRasDll[] = TEXT("rasapi32.dll");
static const TCHAR szRnaPhDll[] = TEXT("rnaph.dll");


void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);

//
// defined in dialerr.cpp
//
void ProcessDBCS(HWND hDlg, int ctlID);


/*  C E N T E R  W I N D O W */
/*-------------------------------------------------------------------------
    %%Function: CenterWindow

    Center a window over another window.
-------------------------------------------------------------------------*/
VOID CenterWindow(HWND hwndChild, HWND hwndParent)
{
    int   xNew, yNew;
    int   cxChild, cyChild;
    int   cxParent, cyParent;
    int   cxScreen, cyScreen;
    RECT  rcChild, rcParent;
    HDC   hdc;

    // Get the Height and Width of the child window
    GetWindowRect(hwndChild, &rcChild);
    cxChild = rcChild.right - rcChild.left;
    cyChild = rcChild.bottom - rcChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect(hwndParent, &rcParent);
    cxParent = rcParent.right - rcParent.left;
    cyParent = rcParent.bottom - rcParent.top;

    // Get the display limits
    hdc = GetDC(hwndChild);
    if (hdc == NULL) {
        // major problems - move window to 0,0
        xNew = yNew = 0;
    } else {
        cxScreen = GetDeviceCaps(hdc, HORZRES);
        cyScreen = GetDeviceCaps(hdc, VERTRES);
        ReleaseDC(hwndChild, hdc);

        if (hwndParent == hwndNil) {
            cxParent = cxScreen;
            cyParent = cyScreen;
            SetRect(&rcParent, 0, 0, cxScreen, cyScreen);
        }

        // Calculate new X position, then adjust for screen
        xNew = rcParent.left + ((cxParent - cxChild) / 2);
        if (xNew < 0) {
            xNew = 0;
        } else if ((xNew + cxChild) > cxScreen) {
            xNew = cxScreen - cxChild;
        }

        // Calculate new Y position, then adjust for screen
        yNew = rcParent.top  + ((cyParent - cyChild) / 2);
        if (yNew < 0) {
            yNew = 0;
        } else if ((yNew + cyChild) > cyScreen) {
            yNew = cyScreen - cyChild;
        }

    }

    SetWindowPos(hwndChild, NULL, xNew, yNew,    0, 0,
        SWP_NOSIZE | SWP_NOZORDER);
}

static HWND hwndFound = NULL;

static BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
    TCHAR szTemp[SMALLBUFLEN+2];
    PTSTR pszTitle;
    UINT uLen1, uLen2;

    if(!IsWindowVisible(hwnd))
        return TRUE;
    if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE; // continue enumerating
    if(lstrcmp(szTemp, szRnaAppWindowClass)!=0)
        return TRUE;
    if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE;
    szTemp[SMALLBUFLEN] = 0;
    uLen1 = lstrlen(szTemp);
    if (uLen1 > 5)
        uLen1 -= 5; // skip last 5 chars of title (avoid "...")
    pszTitle = (PTSTR)lparam;
    ASSERT(pszTitle);
    uLen2 = lstrlen(pszTitle);
    TRACE_OUT(("Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1));
    if(uLen2 < uLen1)
        return TRUE;
    if(lstrnicmp(pszTitle, szTemp, uLen1)!=0)
        return TRUE;
    hwndFound = hwnd;
    return FALSE;
}

static HWND MyFindRNAWindow(PTSTR pszTitle)
{
    DWORD dwRet;
    hwndFound = NULL;
    dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
    TRACE_OUT(("EnumWindows returned %d\r\n", dwRet));
    return hwndFound;
}


/*******************************************************************

    NAME:        MinimizeRNAWindow

    SYNOPSIS:    Finds and minimizes the annoying RNA window

    ENTRY:        pszConnectoidName - name of connectoid launched

********************************************************************/
BOOL MinimizeRNAWindow(TCHAR * pszConnectoidName)
{
    HWND hwndRNAApp;
    TCHAR szFmt[SMALLBUFLEN + 1];
    TCHAR szTitle[RAS_MaxEntryName + SMALLBUFLEN + 1];
    
    // load the title format ("connected to <connectoid name>" from resource
    LoadString(g_hInstance, IDS_CONNECTED_TO, szFmt, sizeof(szFmt));
    // build the title
    wsprintf(szTitle, szFmt, pszConnectoidName);

    hwndRNAApp=MyFindRNAWindow(szTitle);
    if(hwndRNAApp)
    {
        // minimize the RNA window
        ShowWindow(hwndRNAApp,SW_MINIMIZE);
        return TRUE;
    }
    return FALSE;
}

//****************************************************************************
// static LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR)
//
// This function returns the pointer to displayable phone number. It stripped
//   all the prefixes we do not want to show to the user.
//
// History:
//  Tue 26-Jul-1994 16:07:00  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

LPTSTR NEAR PASCAL GetDisplayPhone (LPTSTR szPhoneNum)
{
  // Check whether the first string is the know prefix
  //
  if ((*szPhoneNum == 'T') || (*szPhoneNum == 'P'))
  {
    // It is the prefix
    //
    szPhoneNum++;

    // The first displayable number is not white space after prefix
    //
    while ((*szPhoneNum == ' ') || (*szPhoneNum == '\t'))
      szPhoneNum++;
  };
  return szPhoneNum;
}

void CALLBACK LineCallbackProc (DWORD handle, DWORD dwMsg, DWORD dwInst,
                                DWORD dwParam1, DWORD dwParam2, DWORD dwParam3)
{
}

//****************************************************************************
// TranslateCanonicalAddress()
//
// Function: This function translate a canonical address to a dialable address.
//
// Returns:  SUCCESS or an error code
//
//****************************************************************************

static DWORD NEAR PASCAL TranslateCanonicalAddress(DWORD dwID, LPTSTR szCanonical,
                                            LPTSTR szDialable, DWORD cb)
{
  LINETRANSLATEOUTPUT lto, FAR* lplto;
  DWORD dwRet;
  DWORD cDevices;
  HLINEAPP hApp;

  if ((dwRet = lineInitialize(&hApp, g_hInstance,
                                (LINECALLBACK)LineCallbackProc,
                                NULL, &cDevices)) == SUCCESS)
  {

    // Get the actual buffer size
    lto.dwTotalSize = sizeof(lto);
    if ((dwRet = lineTranslateAddress(hApp, dwID,
                                      TAPI_VERSION, szCanonical, 0,
                                      LINETRANSLATEOPTION_CANCELCALLWAITING,
                                      &lto)) == SUCCESS)
    {
      // Allocate the dialable number buffer
      if ((lplto = (LPLINETRANSLATEOUTPUT)GlobalAlloc(LMEM_FIXED, lto.dwNeededSize))
          != NULL)
      {
        // Translate the phone number
        lplto->dwTotalSize = lto.dwNeededSize;
        if ((dwRet = lineTranslateAddress(hApp, dwID,
                                          TAPI_VERSION, szCanonical, 0,
                                          LINETRANSLATEOPTION_CANCELCALLWAITING,
                                          lplto)) == SUCCESS)
        {
          LPTSTR szPhone;

          szPhone = (LPTSTR)(((LPBYTE)lplto)+lplto->dwDialableStringOffset);
          lstrcpyn(szDialable, szPhone, cb);
        }
        else
          dwRet = ERROR_TAPI_CONFIGURATION;


        GlobalFree((HLOCAL)lplto);
      }
      else
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
      dwRet = ERROR_TAPI_CONFIGURATION;
  }
  else
    dwRet = ERROR_TAPI_CONFIGURATION;
      
  lineShutdown(hApp);

  return dwRet;
}

//****************************************************************************
// DWORD NEAR PASCAL BuildPhoneString (LPBYTE, LPPHONENUM)
//
// This function builds a phone number string from the phone number struct
//
// History:
//  Mon 14-Mar-1994 13:10:44  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

static DWORD NEAR PASCAL BuildPhoneString (LPTSTR szPhoneNum, LPRASENTRY lpRasEntry)
{
  if (*lpRasEntry->szAreaCode != '\0')
  {
    wsprintf(szPhoneNum, CANONICAL_CAP, lpRasEntry->dwCountryCode,
             lpRasEntry->szAreaCode, lpRasEntry->szLocalPhoneNumber);
  }
  else
  {
    wsprintf(szPhoneNum, CANONICAL_CXP, lpRasEntry->dwCountryCode,
             lpRasEntry->szLocalPhoneNumber);
  };
  return SUCCESS;
};

//****************************************************************************
// BOOL NEAR PASCAL TranslatePhoneNumber(LPTSTR, LPPHONENUM, LPTSTR)
//
// Translate phone number into a dialble string.
//
// Returns TRUE if successful, FALSE if use default.
//
// History:
//   Fri 17-Jun-1994 08:42:49  -by-  Viroon  Touranachun [viroont]
// Created
//****************************************************************************

static BOOL NEAR PASCAL TranslatePhoneNumber(LPRASENTRY lpRasEntry, LPTSTR szPhoneNumber)
{
  TCHAR    szOrgPhone[RAS_MaxPhoneNumber+1];

  // Do we need to use the addrees book phone number?
  //
  if (lpRasEntry != NULL)
  {
    // Yes! Do we need to translate anything?
    //
    if (lpRasEntry->dwCountryID == 0)
    {
      // No! we dial as is.
      //
      lstrcpyn(szOrgPhone, lpRasEntry->szLocalPhoneNumber, RAS_MaxPhoneNumber + 1);
    }
    else
    {
      // Yes! build the phone number
      //
      BuildPhoneString (szOrgPhone, lpRasEntry);
    };
  }
  else
  {
    // No! we have a overwritten phone number
    //
    ASSERT(lstrlen(szPhoneNumber) != 0);
    lstrcpyn(szOrgPhone, szPhoneNumber, RAS_MaxPhoneNumber+1);
  };

  // Attempt address translation
  //
  if (TranslateCanonicalAddress(0, szOrgPhone,
                            szPhoneNumber, RAS_MaxPhoneNumber+1)
  != ERROR_SUCCESS)
  {
    // Translation fails, use default phone number
    //
    if (lpRasEntry != NULL)
    {
      // Use entry's local phone number
      //
      lstrcpy(szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
    }
    else
    {
      // Restore the original phone number
      //
      lstrcpy(szPhoneNumber, szOrgPhone);
    };
    return FALSE;
  };

  return TRUE;
}


DWORD GetPhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;
    HINSTANCE hLib;
    RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;

    // look for needed function in rasapi.dll
    hLib = LoadLibrary(szRasDll);
    if (NULL != hLib)
    {
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL != lpfnRasGetEntryProperties)
        {
            // we found the function
            goto get_entry;
        }
        FreeLibrary(hLib);
    }

    // try rnaph.dll if not on NT

    if (FALSE == IsNT ())
    {
        hLib = LoadLibrary(szRnaPhDll);
        if (NULL == hLib)
        {
            return ERROR_FILE_NOT_FOUND;
        }
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL == lpfnRasGetEntryProperties)
        {
            FreeLibrary(hLib);
            return ERROR_INVALID_FUNCTION;
        }
    }
    else
    {
            return ERROR_FILE_NOT_FOUND;
    }

get_entry:
    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
        NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
            (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
        }

        GlobalFree((HLOCAL)lpRasEntry);
    }

    FreeLibrary(hLib);

    return dwRet;
}

DWORD _RasGetStateString(RASCONNSTATE state, LPTSTR lpszState, DWORD cb)
{
    UINT idString;

    switch(state)
    {
        case RASCS_OpenPort:
            idString  = IDS_OPENPORT;
            break;
        case RASCS_PortOpened:
            idString = IDS_PORTOPENED;            
            break;
        case RASCS_ConnectDevice:
            idString = IDS_CONNECTDEVICE;        
            break;
        case RASCS_DeviceConnected:
            idString = IDS_DEVICECONNECTED;       
            break;
        case RASCS_AllDevicesConnected:
            idString = IDS_ALLDEVICESCONNECTED;   
            break;
        case RASCS_Authenticate:
            idString = IDS_AUTHENTICATE;          
            break;
        case RASCS_AuthNotify:
            idString = IDS_AUTHNOTIFY;            
            break;
        case RASCS_AuthRetry:
            idString = IDS_AUTHRETRY;             
            break;
        case RASCS_AuthCallback:
            idString = IDS_AUTHCALLBACK;          
            break;
        case RASCS_AuthChangePassword:
            idString = IDS_AUTHCHANGEPASSWORD;    
            break;
        case RASCS_AuthProject:
            idString = IDS_AUTHPROJECT;           
            break;
        case RASCS_AuthLinkSpeed:
            idString = IDS_AUTHLINKSPEED;         
            break;
        case RASCS_AuthAck: 
            idString = IDS_AUTHACK;               
            break;
        case RASCS_ReAuthenticate:
            idString = IDS_REAUTHENTICATE;        
            break;
        case RASCS_Authenticated:
            idString = IDS_AUTHENTICATED;         
            break;
        case RASCS_PrepareForCallback:
            idString = IDS_PREPAREFORCALLBACK;    
            break;
        case RASCS_WaitForModemReset:
            idString = IDS_WAITFORMODEMRESET;     
            break;
        case RASCS_WaitForCallback:
            idString = IDS_WAITFORCALLBACK;       
            break;
        case RASCS_Interactive:
            idString = IDS_INTERACTIVE;           
            break;
        case RASCS_RetryAuthentication: 
            idString = IDS_RETRYAUTHENTICATION;            
            break;
        case RASCS_CallbackSetByCaller: 
            idString = IDS_CALLBACKSETBYCALLER;   
            break;
        case RASCS_PasswordExpired:
            idString = IDS_PASSWORDEXPIRED;       
            break;
        case RASCS_Connected:
            idString = IDS_CONNECTED;            
            break;
        case RASCS_Disconnected:
            idString = IDS_DISCONNECTED;          
            break;
        default:
            idString = IDS_UNDEFINED_ERROR;
            break;
    }
    if (LoadString(g_hInstance, idString, lpszState, cb))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD ReplacePhoneNumber(LPTSTR lpszEntryName, LPTSTR lpszPhoneNumber)
{
    DWORD dwEntrySize = 0;
    DWORD dwSize = 0;
    DWORD dwRet;
    LPRASENTRY lpRasEntry = NULL;
    HINSTANCE hLib;
    RASGETENTRYPROPERTIES lpfnRasGetEntryProperties;
    RASSETENTRYPROPERTIES lpfnRasSetEntryProperties;

    // look for needed function in rasapi.dll
    hLib = LoadLibrary(szRasDll);
    if (NULL != hLib)
    {
        lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
        if (NULL != lpfnRasGetEntryProperties)
        {
            // we found the function
            goto get_entry2;
        }
        FreeLibrary(hLib);
    }

    // try rnaph.dll
    hLib = LoadLibrary(szRnaPhDll);
    if (NULL == hLib)
    {
        return ERROR_FILE_NOT_FOUND;
    }
    lpfnRasGetEntryProperties = (RASGETENTRYPROPERTIES)GetProcAddress(hLib, szRasGetEntryProperties);
    if (NULL == lpfnRasGetEntryProperties)
    {
        FreeLibrary(hLib);
        return ERROR_INVALID_FUNCTION;
    }

get_entry2:
    // get size needed for RASENTRY struct
    lpfnRasGetEntryProperties(
        NULL,
        lpszEntryName,
        NULL,
        &dwEntrySize,
        NULL,
        &dwSize);

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntrySize + dwSize);

    if (NULL == lpRasEntry)
    {
        dwRet = ERROR_OUTOFMEMORY;
    }
    else
    {
        lpRasEntry->dwSize = dwEntrySize;

        dwRet = lpfnRasGetEntryProperties(
            NULL,
            lpszEntryName,
            (LPBYTE)lpRasEntry,
            &dwEntrySize,
            ((LPBYTE)lpRasEntry) + dwEntrySize,
            &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            //lstrcpyn(lpRasEntry->szLocalPhoneNumber,lpszPhoneNumber,RAS_MaxPhoneNumber);
            lstrcpy(lpRasEntry->szLocalPhoneNumber,lpszPhoneNumber);
            lpfnRasSetEntryProperties = (RASSETENTRYPROPERTIES)GetProcAddress(hLib, szRasSetEntryProperties);
            lpRasEntry->dwfOptions &= ~(RASEO_UseCountryAndAreaCodes);
            TranslatePhoneNumber(lpRasEntry, lpszPhoneNumber);
            dwRet = lpfnRasSetEntryProperties(
                NULL,
                lpszEntryName,
                (LPBYTE)lpRasEntry,
                dwEntrySize,
                NULL,
                0);
//                ((LPBYTE)lpRasEntry) + dwEntrySize,
//                dwSize);
#if !defined(WIN16)
    RasSetEntryPropertiesScriptPatch(lpRasEntry->szScript, lpszEntryName);
#endif //!win16
        
        }

        GlobalFree((HLOCAL)lpRasEntry);
    }

    FreeLibrary(hLib);

    return dwRet;
}


// ############################################################################
LPTSTR StrDup(LPTSTR *ppszDest,LPCTSTR pszSource)
{
    if (ppszDest && pszSource)
    {
        *ppszDest = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(lstrlen(pszSource)+1));
        if (*ppszDest)
            return (lstrcpy(*ppszDest,pszSource));
    }
    return NULL;
}

// ############################################################################
// NAME: GenericDlgProc
//
//    This is a common dlg proc that is shared by all of the signup connectoid
//    dialogs
//
// Notes:
//    This basically works because each dialog has an object associated
//    with it, and that object has a particular dlgproc that is called
//    at the end in order to handle specific functionality for the dialogs.
//
//  Created 1/28/96,        Chris Kauffman
// ############################################################################
INT_PTR CALLBACK GenericDlgProc(
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   )
{
    CDialog *pcDlg = NULL;
    INT_PTR lRet;
    switch (uMsg)
    {
    case WM_QUERYENDSESSION:
        EndDialog(hwndDlg,IDC_CMDCANCEL);
        lRet = TRUE;
        break;
    case WM_INITDIALOG:
        pcDlg = (CDialog *)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,(LONG_PTR)lParam);
        lRet = TRUE;

        MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE),TRUE,FW_BOLD);

        //
        // 7/18/97 jmazner    Olympus #1111
        // dialing string could contain DBCS if using a calling card, so
        // make sure we display that correctly
        //
        ProcessDBCS(hwndDlg, IDC_LBLNUMBER);

        break;
    case WM_CLOSE:
        if (!pcDlg) pcDlg = (CDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
        if (pcDlg)
        {
            if (pcDlg->m_bShouldAsk)
            {
                if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                    MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                    EndDialog(hwndDlg,IDC_CMDCANCEL);
                lRet = TRUE;
            }
        }
        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }

    if (!pcDlg) pcDlg = (CDialog*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (pcDlg)
        lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

    return lRet;
}


// ############################################################################
HRESULT WINAPI ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppRasDevInfo, LPDWORD lpdwRasDevInfoSize, LPTSTR pszEntryName)
{
    //DWORD dwRasEntrySize=0;
    //DWORD dwRasDevInfoSize=0;
    HINSTANCE hRasDll = NULL;
    HRESULT hr = ERROR_SUCCESS;
    FARPROC fp = NULL;
    RNAAPI *pcRNA;
    DWORD dwOldDevInfoBuffSize = 0;

    //
    // Validate parameters
    //
    if (!ppRasEntry || !lpdwRasEntrySize || !ppRasDevInfo || !lpdwRasDevInfoSize || !pszEntryName || !lstrlen(pszEntryName))
    {
        hr = ERROR_INVALID_PARAMETER;
        goto ICWGetRasEntryExit;
    }

    // *ppRasEntry and *ppRasDevInfo should not have memory allocated to them
    Assert( *ppRasEntry == NULL );
    Assert( *ppRasDevInfo == NULL );
    Assert( *lpdwRasEntrySize == 0);
    Assert( *lpdwRasDevInfoSize == 0);

    //
    // Instantiate RNA wrapper
    //
    pcRNA = new RNAAPI;
    if (NULL == pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto ICWGetRasEntryExit;
    }
    

    // use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
    // As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

    hr = pcRNA->RasGetEntryProperties(NULL,
                                      pszEntryName,
//#ifdef WIN16                                    
                                      (LPBYTE)
//#endif
                                      *ppRasEntry,
                                      lpdwRasEntrySize,
                                      (LPBYTE)*ppRasDevInfo,
                                      lpdwRasDevInfoSize);

    // we expect the above call to fail because the buffer size is 0
    // If it doesn't fail, that means our RasEntry is messed, so we're in trouble
    if( ERROR_BUFFER_TOO_SMALL != hr )
    { 
        goto ICWGetRasEntryExit;
    }

    // dwRasEntrySize and dwRasDevInfoSize now contain the size needed for their
    // respective buffers, so allocate the memory for them

    // dwRasEntrySize should never be less than the size of the RASENTRY struct.
    // If it is, we'll run into problems sticking values into the struct's fields

    Assert( *lpdwRasEntrySize >= sizeof(RASENTRY) );

#if defined(WIN16)
    //
    // Allocate extra 256 bytes to workaround memory overrun bug in RAS
    //
    *ppRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntrySize + 256);
#else    
    *ppRasEntry = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntrySize);
#endif

    if ( !(*ppRasEntry) )
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto ICWGetRasEntryExit;
    }

    //
    // Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
    // If size is 0, don't alloc anything
    //
    if( *lpdwRasDevInfoSize > 0 )
    {
        Assert( *lpdwRasDevInfoSize >= sizeof(RASDEVINFO) );
        *ppRasDevInfo = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoSize);
        if ( !(*ppRasDevInfo) )
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto ICWGetRasEntryExit;
        }
    } else
    {
        *ppRasDevInfo = NULL;
    }

    // This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
    // RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
    // This is because the dwSize field is used by RAS for compatability purposes to determine which
    // version of the RASENTRY struct we're using.
    // Same holds for lpRasDevInfo->dwSize
    
    (*ppRasEntry)->dwSize = sizeof(RASENTRY);
    if( *ppRasDevInfo )
    {
        (*ppRasDevInfo)->dwSize = sizeof(RASDEVINFO);
    }

    //now we're ready to make the actual call to RasGetEntryProperties!

/*
    // Load RAS DLL and locate API
    //

    hRasDll = LoadLibrary(RASAPI_LIBRARY);
    if (!hRasDll)
    {
        hr = GetLastError();
        goto ICWGetRasEntryExit;
    }

    fp =GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
    if (!fp)
    {
        FreeLibrary(hRasDll);
        hRasDll = LoadLibrary(RNAPH_LIBRARY);
        if (!hRasDll)
        {
            hr = GetLastError();
            goto ICWGetRasEntryExit;
        }
        fp = GetProcAddress(hRasDll,RASAPI_RASGETENTRY);
        if (!fp)
        {
            hr = GetLastError();
            goto ICWGetRasEntryExit;
        }
    }
*/
    // Get RasEntry
    //
    
    //hr = ((PFNRASGETENTRYPROPERTIES)fp)(NULL,pszEntryName,(LPBYTE)*ppRasEntry,&dwRasEntrySize,(LPBYTE)*ppDevInfo,&dwRasDevInfoSize);

    // jmazner   see below for why this is needed
    dwOldDevInfoBuffSize = *lpdwRasDevInfoSize;

    hr = pcRNA->RasGetEntryProperties(NULL,pszEntryName,(LPBYTE)*ppRasEntry,lpdwRasEntrySize,(LPBYTE)*ppRasDevInfo,lpdwRasDevInfoSize);

    // jmazner 10/7/96  Normandy #8763
    // For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
    // but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
    // size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
    // for the DevInfoBuff match on exit.
    if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoSize) )
    {
        *lpdwRasDevInfoSize = dwOldDevInfoBuffSize;
    }



ICWGetRasEntryExit:
    if (hRasDll) FreeLibrary(hRasDll);
    hRasDll = NULL;
    if (pcRNA) delete pcRNA;
    pcRNA = NULL;

    return hr;
}

//+----------------------------------------------------------------------------
//
//    Function:    FCampusNetOverride
//
//    Synopsis:    Detect if the dial should be skipped for the campus network
//
//    Arguments:    None
//
//    Returns:    TRUE - overide enabled
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if !defined(WIN16) && defined(DEBUG)
BOOL FCampusNetOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FCampusNetOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("CampusNet"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FCampusNetOverrideExit;

    AssertMsg(REG_DWORD == dwType,"Wrong value type for CampusNet.  Must be DWORD.\r\n");
    bRC = (0 != dwData);

    if (bRC)
        MessageBox(NULL,TEXT("DEBUG ONLY: CampusNet will be used."),TEXT("Testing Override"),0);

FCampusNetOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}
#endif //!WIN16 && DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\globals.h ===
/*-----------------------------------------------------------------------------
	globals.h

	contains general declarations for ICWDIAL

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include <ras.h>
#include <raserror.h>
#include <tapi.h>
#include <wininet.h>
#include "debug.h"
#include "icwdial.h"
#include "icwdl.h"
#include "rnaapi.h"
#include "dlapi.h"
#include "helpids.h"
#include "dialutil.h"

// ############################################################################
#define NUMRETRIES      3

#define MAXHANGUPDELAY  20
#define ONE_SECOND      1000
#define TIMER_ID        0

#define SMALLBUFLEN 80

#define ERROR_USERCANCEL 32767 // quit message value
#define ERROR_USERBACK 32766 // back message value
#define ERROR_USERNEXT 32765 // back message value
#define ERROR_DOWNLOADIDNT 32764 // Download failure

#define ERROR_READING_DUN		32768
#define ERROR_READING_ISP		32769
#define ERROR_PHBK_NOT_FOUND	32770
#define ERROR_DOWNLOAD_NOT_FOUND 32771

#define SIGNUPKEY TEXT("Software\\Microsoft\\iSignUp")
#define GATHERINFOVALUENAME TEXT("UserInfo")

#define	MAX_PROMO 64
#define MAX_OEMNAME 64
#define MAX_AREACODE RAS_MaxAreaCode
#define MAX_EXCHANGE 8
#define MAX_VERSION_LEN 40
#define MAX_CANONICAL_NUMBER 40

#define INSFILE_APPNAME TEXT("ClientSetup")
#define INFFILE_SETUP_CLIENT_URL TEXT("Client_Setup_Url")
#define INFFILE_SETUP_NEW_CALL TEXT("Client_Setup_New_Call")
#define INFFILE_DONE_MESSAGE TEXT("Done_Message")
#define INFFILE_EXPLORE_CMD TEXT("Explore_Command")
#define INFFILE_ENTRYSECTION TEXT("Entry")
#define INFFILE_ENTRY_NAME TEXT("Entry_Name")
#define INFFILE_USER_SECTION TEXT("User")
#define INFFILE_PASSWORD TEXT("Password")

#define NULLSZ TEXT("")

#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)
#define MsgBox(x,y) MessageBox(NULL,GetSz(x),GetSz(IDS_TITLE),y)
#define DUNFILEVALUENAME  TEXT("DUNFilePath")
#define RASENTRYVALUENAME TEXT("RasEntryName")

#define DllExport extern "C" __declspec(dllexport)

#define WM_DOWNLOAD_DONE	WM_USER + 4

#define HINTERNET DWORD

#define AUTODIAL_HELPFILE  TEXT("connect.hlp>proc4")

#define IF_NTONLY if(VER_PLATFORM_WIN32_NT == GetPlatform()) {
#define ENDIF_NTONLY }
#define IF_WIN95ONLY if(VER_PLATFORM_WIN32_WINDOWS == GetPlatform()) {
#define ENDIF_WIN95ONLY }

#define SIZEOF_TCHAR_BUFFER(buf)    ((sizeof(buf) / sizeof(TCHAR)))

// ############################################################################

typedef struct tagGATHEREDINFO
{
	LCID	lcid;
	DWORD	dwOS;
	DWORD	dwMajorVersion;
	DWORD	dwMinorVersion;
	WORD	wArchitecture;
	TCHAR	szPromo[MAX_PROMO];
	TCHAR	szOEM[MAX_OEMNAME];
	TCHAR	szAreaCode[MAX_AREACODE+1];
	TCHAR	szExchange[MAX_EXCHANGE+1];
	DWORD	dwCountry;
	TCHAR	szSUVersion[MAX_VERSION_LEN];
	WORD	wState;
	BYTE	fType;
	BYTE	bMask;
	TCHAR   szISPFile[MAX_PATH+1];
	TCHAR	szAppDir[MAX_PATH+1];
} GATHEREDINFO, *PGATHEREDINFO;


// ############################################################################
class CDialog
{
public:
	BOOL m_bShouldAsk;

	CDialog() {m_bShouldAsk=TRUE;};
	~CDialog() {};

	virtual LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

class CDialingDlg : public CDialog
{
public:
	HRASCONN m_hrasconn;
	LPTSTR m_pszConnectoid;
	HANDLE m_hThread;
	DWORD m_dwThreadID;
	HWND m_hwnd;
	LPTSTR m_pszUrl;
	LPTSTR m_pszDisplayable;
	DWORD_PTR m_dwDownLoad;
	LPTSTR m_pszPhoneNumber;
	LPTSTR m_pszMessage;
	PFNSTATUSCALLBACK m_pfnStatusCallback;
	HINSTANCE m_hInst;
	UINT m_unRasEvent;
	LPTSTR m_pszDunFile;
	HLINEAPP m_hLineApp;
	DWORD m_dwNumDev;
	DWORD m_dwTapiDev;
	DWORD m_dwAPIVersion;
	RNAAPI *m_pcRNA;
	BYTE m_bProgressShowing;
	DWORD m_dwLastStatus;
	CDownLoadAPI *m_pcDLAPI;
	BOOL m_bSkipDial;
	RASDIALFUNC1 m_pfnRasDialFunc1;
	//
	// ChrisK 5240 Olympus
	// Only the thread that creates the dwDownload should invalidate it
	// so we need another method to track if the cancel button has been
	// pressed.
	//
	BOOL m_fDownloadHasBeenCanceled;

	CDialingDlg();
	~CDialingDlg();
	HRESULT GetDisplayableNumberDialDlg();
	LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	HRESULT DialDlg();
	HRESULT Init();
	VOID CDialingDlg::ProgressCallBack(HINTERNET hInternet,DWORD_PTR dwContext,
												DWORD dwInternetStatus,
												LPVOID lpvStatusInformation,
												DWORD dwStatusInformationLength);

};

class CDialingErrorDlg : public CDialog
{ 
public:
	HINSTANCE m_hInst;
	HWND m_hwnd;

	LPTSTR m_pszConnectoid;
	LPTSTR m_pszDisplayable;
	LPTSTR m_pszPhoneNumber;
	LPTSTR m_pszMessage;
	LPTSTR m_pszDunFile;
	DWORD_PTR m_dwPhoneBook;

	HLINEAPP m_hLineApp;
	DWORD m_dwTapiDev;
	DWORD m_dwAPIVersion;
	RNAAPI *m_pcRNA;

	DWORD m_dwNumDev;
	LPRASDEVINFO m_lpRasDevInfo;

	DWORD m_dwCountryID;
	WORD m_wState;
	BYTE m_bType;
	BYTE m_bMask;

	LPTSTR m_pszHelpFile;
	DWORD m_dwHelpID;

	CDialingErrorDlg();
	~CDialingErrorDlg();
	HRESULT Init();
	LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
	HRESULT GetDisplayableNumber();
	HRESULT FillModems();
	HRESULT CreateDialAsIsConnectoid(LPCTSTR lpszDialNumber);
};

/**
typedef struct tagDialErr
{
	LPTSTR m_pszConnectoid;
	HRESULT m_hrError;
	PGATHEREDINFO m_pGI;
	HWND m_hwnd;
	HLINEAPP m_hLineApp;
	DWORD m_dwAPIVersion;
	char m_szPhoneNumber[256];
	LPTSTR m_pszDisplayable;
	HINSTANCE m_hInst;
	LPRASDEVINFO m_lprasdevinfo;
} DIALERR, *PDIALERR;
**/

typedef struct tagDEVICE
{
	DWORD dwTapiDev;
	RASDEVINFO RasDevInfo;
} MYDEVICE, *PMYDEVICE;


// ############################################################################
extern HRASCONN g_hRasConn;
extern UINT g_cDialAttempts;
extern UINT g_cHangupDelay;
extern TCHAR g_szPassword[PWLEN + 1];
extern TCHAR g_szEntryName[RAS_MaxEntryName + 1];
extern HINSTANCE g_hInstance;
extern LPRASDIALPARAMS lpDialParams;

DWORD GetPlatform();
LPCTSTR GetISPFile();
void SetCurrentDUNFile(LPCTSTR szDUNFile);
LPCTSTR GIGetAppDir();

extern const TCHAR szBrowserClass1[];
extern const TCHAR szBrowserClass2[];
extern const TCHAR szBrowserClass3[];

// 3/28/97 ChrisK Olympus 296
extern HANDLE g_hRNAZapperThread;

//
// 6/3/97 jmazner Olympus #4851
//
#ifdef WIN16
	#define g_iMyMaxPhone 36
#else
	// allocated in dialerr.cpp
	extern int g_iMyMaxPhone;
	#define MAXPHONE_NT		80
	#define MAXPHONE_95		36
#endif

// ############################################################################
DWORD AutoDialConnect(HWND hDlg, LPRASDIALPARAMS lpDialParams);
BOOL AutoDialEvent(HWND hDlg, RASCONNSTATE state, LPDWORD lpdwError);
VOID SetDialogTitle(HWND hDlg, LPCTSTR pszConnectoidName);
HWND FindBrowser(void);
UINT RetryMessage(HWND hDlg, DWORD dwError);
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey);
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey);

INT_PTR CALLBACK AutoDialDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK PhoneNumberDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);
INT_PTR CALLBACK RetryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM Param);

void CALLBACK LineCallback(DWORD hDevice,DWORD dwMessage,DWORD dwInstance,
						   DWORD dwParam1,DWORD dwParam2,DWORD dwParam3);
HRESULT ShowDialErrDialog(HRESULT hrErr, LPTSTR pszConnectoid, HINSTANCE hInst, HWND hwnd);
LRESULT DialErrDlgProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam);
HRESULT FillModems();
HRESULT DialErrGetDisplayableNumber();
WORD RasErrorToIDS(DWORD dwErr);
HRESULT LoadInitSettingFromRegistry();
PTSTR GetSz(WORD wszID);
HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword);
HRESULT CreateEntryFromDUNFile(PTSTR pszDunFile);
BOOL FSz2Dw(PCTSTR pSz,DWORD *dw);
BOOL BreakUpPhoneNumber(RASENTRY *prasentry, LPTSTR pszPhone);
int Sz2W (LPCTSTR szBuf);
int FIsDigit( int c );
void *MyMemCpy(void *dest,const void *src, size_t count);
PTSTR GetNextNumericChunk(PTSTR psz, PTSTR pszLim, PTSTR* ppszNext);
HRESULT DialDlg();
BOOL FShouldRetry(HRESULT hrErr);
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight);
DWORD WINAPI DownloadThreadInit(CDialingDlg *pcPDlg);
VOID WINAPI ProgressCallBack(DWORD hInternet,DWORD_PTR dwContext,DWORD dwInternetStatus,
							   LPVOID lpvStatusInformation,DWORD dwStatusInformationLength);
HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);
HRESULT ReleaseBold(HWND hwnd);
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst);
#if !defined(WIN16) && defined(DEBUG)
BOOL FCampusNetOverride();
#endif //!WIN && DEBUG
#if !defined(WIN16)
BOOL WINAPI RasSetEntryPropertiesScriptPatch(LPTSTR lpszScript, LPTSTR lpszEntry);
// 4/2/97	ChrisK	Olympus 296
void StopRNAReestablishZapper(HANDLE hthread);
HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst);
#endif //!WIN16


inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\resource.h ===
/*-----------------------------------------------------------------------------
	resource.h

	contains declarations for all IDs in .rc file

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

	NOTE:
		DO NOT EDIT THIS WITH MSVC!  You will destroy the comments and all
		entries designed to build for WIN16

-----------------------------------------------------------------------------*/

#include "dialutil.h"

#define IDS_DIALMESSAGE                 125
#define IDC_STATIC                      -1

#define IDI_WARN                     101
#define IDI_PHONE                    102
#define IDB_PHONE                    108

#define IDS_CONNECTING_TO            401
#define IDS_OUTOFMEMORY              406
#define IDS_WANTTOEXIT               408
#define IDS_RAS_DIALING              409
#define IDS_RAS_PORTOPENED           410
#define IDS_RAS_OPENPORT             411
#define IDS_RAS_CONNECTED            412
#define IDS_RAS_LOCATING             413
#define IDS_TCPINSTALLERROR		     414
#define IDS_PPPRANDOMFAILURE 	     416
#define IDS_RASNOCARRIER		     418
#define IDS_PHONEBUSY			     419
#define IDS_NODIALTONE			     420
#define IDS_NODEVICE			     421
#define IDS_USERCANCELEDDIAL         423
#define IDS_TITLE                    424
#define IDS_CANTLOADINETCFG          425
#define IDS_CANTLOADCONFIGAPI		 426
#define IDS_CANTLOADPHBKAPI		 	 427
#define IDS_CANTINITPHONEBOOK        428
#define IDS_CANTLOADRNAPHAPI		 429
#define IDS_CANTSAVEKEY              430
#define IDS_CANTREADKEY              431
#define IDS_NOANSWER                 432
#define IDS_INVALIDPN                433
#define IDS_MEDIAINIERROR			 434
#define IDS_RAS_HANGINGUP            435
#define IDS_INVALIDPHONE             436
// 3/28/97 ChrisK Olympus 296
#define IDS_REESTABLISH              437
// 5/17/97 jmazner Olympus #137
#define IDS_SBCSONLY				 438

#define IDS_SUPPORTMSG              500

#define IDC_ERROR                   1000
#define IDC_STATUS                  1001
#define IDC_CONNECT                 1002
#define IDC_PHONENUMBER             1003
#define IDC_CMDPHONE			    1004

#define IDC_LBLTITLE                1005
#define IDC_LBLNUMBER               1006
#define IDC_LBLSTATUS               1007
#define IDC_CMDCANCEL               1008
#define IDC_PROGRESS                1009
#define IDC_LBLERRMSG               1010
#define IDC_CMBMODEMS               1011
#define IDC_CMDPHONEBOOK            1012
#define IDC_CMDDIALPROP             1013
#define IDC_CMDNEXT                 1014
#define IDC_CMDHELP                 1015
#define IDC_LBLPHONE                1016
#define IDC_TEXTNUMBER				1017
#define IDC_CONNECT_TEXT            1018
#define IDC_PHNUM_TEXT              1019
#define IDC_NUMTODIAL               1020
#define IDC_CURMODEM                1021
#define IDC_CHNGNUM                 1022


#define IDC_LBSUPPORTMSG            2000

#define IDD_DIALING                  200
#define IDD_DIALERR                  201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\icwerr.cpp ===
/*-----------------------------------------------------------------------------
    icwerr.cpp

    Maps RAS and downloading errors to string resource indices

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

#define RAS_BOGUS_AUTHFAILCODE_1    84
#define RAS_BOGUS_AUTHFAILCODE_2    74389484

// ############################################################################
HRESULT WINAPI StatusMessageCallback(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize)
{
    if (pszBuffer && dwBufferSize)
    {
        WORD wSID = 0;
        switch(dwStatus)
        {
        case RASCS_OpenPort:
            wSID = IDS_RAS_OPENPORT;
            break;
        case RASCS_PortOpened:
            wSID = IDS_RAS_PORTOPENED;
            break;
        case RASCS_ConnectDevice:
            wSID = IDS_RAS_DIALING;
            break;
#if !defined(WIN16)
        case RASCS_DeviceConnected:
            wSID = IDS_RAS_CONNECTED;
            break;
#else
        case RASCS_AllDevicesConnected:
            wSID = IDS_RAS_CONNECTED;
            break; 
#endif

        case RASCS_Authenticate:
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
            wSID = IDS_RAS_LOCATING;
            break;  

        case RASCS_Disconnected:
            //
            // 8/3/97    jmazner    Olympus #11221
            //
            wSID = IDS_RAS_HANGINGUP;
            break;
        
        }
        if (0 == wSID && RASBASE <= dwStatus)
            wSID = RasErrorToIDS(dwStatus);
        
        lstrcpyn(pszBuffer,GetSz(wSID),dwBufferSize);
        return ERROR_SUCCESS;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}

// ############################################################################
WORD RasErrorToIDS(DWORD dwErr)
{

    TraceMsg(TF_GENERAL, "ICWDIAL: RasErrorToIDS received %d\n",dwErr);
    if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: RAS returned bogus AUTH error code %08x. Munging...\r\n", dwErr);
        return IDS_PPPRANDOMFAILURE;
    }

    if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Got random RAS MEDIA error! (%d)\r\n",dwErr);
        return IDS_MEDIAINIERROR;
    }
    
    switch(dwErr)
    {
    default:
        return IDS_PPPRANDOMFAILURE;

    case SUCCESS:
        return 0;
        
    case ERROR_LINE_BUSY:
        return IDS_PHONEBUSY;

    case ERROR_NO_ANSWER:
        return IDS_NOANSWER;
        
    case ERROR_VOICE_ANSWER:
    case ERROR_NO_CARRIER:
        return IDS_RASNOCARRIER;
        
    case ERROR_NO_DIALTONE:
        return IDS_NODIALTONE;

    case ERROR_HARDWARE_FAILURE:    // modem turned off
    case ERROR_PORT_ALREADY_OPEN:    // procomm/hypertrm/RAS has COM port
        return IDS_NODEVICE;

    case ERROR_USER_DISCONNECTION:
        return IDS_USERCANCELEDDIAL;

    case ERROR_BUFFER_INVALID:                // bad/empty rasdilap struct
    case ERROR_BUFFER_TOO_SMALL:            // ditto?
    case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:    // if connectoid name in registry is wrong
        return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:        // get this on actual CHAP reject
        return IDS_PPPRANDOMFAILURE;

    case ERROR_PPP_TIMEOUT:        // get this on CHAP timeout
        return IDS_PPPRANDOMFAILURE;

    case ERROR_REMOTE_DISCONNECTION:        // Ascend drops connection on auth-fail
        return IDS_PPPRANDOMFAILURE;

    case ERROR_AUTH_INTERNAL:                // got this on random POP failure
    case ERROR_PROTOCOL_NOT_CONFIGURED:        // get this if LCP fails
    case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:    // get this if IPCP addr download gives garbage
        return IDS_PPPRANDOMFAILURE;

    case ERROR_USERCANCEL:
        return IDS_USERCANCELEDDIAL;

/******
    case ERROR_CHANGING_PASSWORD:
    case ERROR_PASSWD_EXPIRED:
        ev = EVENT_INVALIDPASSWORD; break;

    case ERROR_ACCT_DISABLED:
    case ERROR_ACCT_EXPIRED:
        ev = EVENT_LOCKEDACCOUNT; break;

    case ERROR_NO_DIALIN_PERMISSION:
    case ERROR_RESTRICTED_LOGON_HOURS:
    case ERROR_AUTHENTICATION_FAILURE:
        ev = EVENT_RAS_AUTH_FAILED; break;

    case ERROR_ALREADY_DISCONNECTING:
    case ERROR_DISCONNECTION:
        ev = EVENT_CONNECTION_DROPPED; break;

    case PENDING: 
    case ERROR_INVALID_PORT_HANDLE:
    case ERROR_CANNOT_SET_PORT_INFO:
    case ERROR_PORT_NOT_CONNECTED:
    case ERROR_DEVICE_DOES_NOT_EXIST:
    case ERROR_DEVICETYPE_DOES_NOT_EXIST:
    case ERROR_PORT_NOT_FOUND:
    case ERROR_DEVICENAME_TOO_LONG:
    case ERROR_DEVICENAME_NOT_FOUND:
         ev=EVENT_BAD_MODEM_CONFIG; break;

    case ERROR_TAPI_CONFIGURATION:
        ev=EVENT_BAD_TAPI_CONFIG; break;
    
        ev=EVENT_MODEM_BUSY; break;
    
    case ERROR_BUFFER_TOO_SMALL:
    case ERROR_WRONG_INFO_SPECIFIED:
    case ERROR_EVENT_INVALID:
    case ERROR_BUFFER_INVALID:
    case ERROR_ASYNC_REQUEST_PENDING:
    case ERROR_CANNOT_OPEN_PHONEBOOK:
    case ERROR_CANNOT_LOAD_PHONEBOOK:
    case ERROR_CANNOT_WRITE_PHONEBOOK:
    case ERROR_CORRUPT_PHONEBOOK:
    case ERROR_CANNOT_LOAD_STRING:
    case ERROR_OUT_OF_BUFFERS:
    case ERROR_MACRO_NOT_FOUND:
    case ERROR_MACRO_NOT_DEFINED:
    case ERROR_MESSAGE_MACRO_NOT_FOUND:
    case ERROR_DEFAULTOFF_MACRO_NOT_FOUND:
    case ERROR_FILE_COULD_NOT_BE_OPENED:
    case ERROR_PORT_NOT_OPEN:
    case ERROR_PORT_DISCONNECTED:
    case ERROR_NO_ENDPOINTS:
    case ERROR_KEY_NOT_FOUND:
    case ERROR_INVALID_SIZE:
    case ERROR_PORT_NOT_AVAILABLE:
    case ERROR_UNKNOWN:
    case ERROR_WRONG_DEVICE_ATTACHED:
    case ERROR_BAD_STRING:
    case ERROR_BAD_USAGE_IN_INI_FILE:
    case ERROR_READING_SECTIONNAME:
    case ERROR_READING_DEVICETYPE:
    case ERROR_READING_DEVICENAME:
    case ERROR_READING_USAGE:
    case ERROR_READING_MAXCONNECTBPS:
    case ERROR_READING_MAXCARRIERBPS:
    case ERROR_IN_COMMAND:
    case ERROR_WRITING_SECTIONNAME:
    case ERROR_WRITING_DEVICETYPE:
    case ERROR_WRITING_DEVICENAME:
    case ERROR_WRITING_MAXCONNECTBPS:
    case ERROR_WRITING_MAXCARRIERBPS:
    case ERROR_WRITING_USAGE:
    case ERROR_WRITING_DEFAULTOFF:
    case ERROR_READING_DEFAULTOFF:
    case ERROR_EMPTY_INI_FILE:
    case ERROR_FROM_DEVICE:
    case ERROR_UNRECOGNIZED_RESPONSE:
    case ERROR_NO_RESPONSES:
    case ERROR_NO_COMMAND_FOUND:
    case ERROR_WRONG_KEY_SPECIFIED:
    case ERROR_UNKNOWN_DEVICE_TYPE:
    case ERROR_ALLOCATING_MEMORY:
    case ERROR_PORT_NOT_CONFIGURED:
    case ERROR_DEVICE_NOT_READY:
    case ERROR_READING_INI_FILE:
    case ERROR_NO_CONNECTION:
    case ERROR_PORT_OR_DEVICE:
    case ERROR_NOT_BINARY_MACRO:
    case ERROR_DCB_NOT_FOUND:
    case ERROR_STATE_MACHINES_NOT_STARTED:
    case ERROR_STATE_MACHINES_ALREADY_STARTED:
    case ERROR_PARTIAL_RESPONSE_LOOPING:
    case ERROR_UNKNOWN_RESPONSE_KEY:
    case ERROR_RECV_BUF_FULL:
    case ERROR_CMD_TOO_LONG:
    case ERROR_UNSUPPORTED_BPS:
    case ERROR_UNEXPECTED_RESPONSE:
    case ERROR_INTERACTIVE_MODE:
    case ERROR_BAD_CALLBACK_NUMBER:
    case ERROR_INVALID_AUTH_STATE:
    case ERROR_WRITING_INITBPS:
    case ERROR_X25_DIAGNOSTIC:
    case ERROR_OVERRUN:
    case ERROR_RASMAN_CANNOT_INITIALIZE:
    case ERROR_BIPLEX_PORT_NOT_AVAILABLE:
    case ERROR_NO_ACTIVE_ISDN_LINES:
    case ERROR_NO_ISDN_CHANNELS_AVAILABLE:
    case ERROR_TOO_MANY_LINE_ERRORS:
        ev=EVENT_INTERNAL_ERROR; break;
    
    case ERROR_ROUTE_NOT_AVAILABLE:
    case ERROR_ROUTE_NOT_ALLOCATED:
    case ERROR_INVALID_COMPRESSION_SPECIFIED:
    case ERROR_CANNOT_PROJECT_CLIENT:
    case ERROR_CANNOT_GET_LANA:
    case ERROR_NETBIOS_ERROR:
    case ERROR_NAME_EXISTS_ON_NET:
        ev=EVENT_BAD_NET_CONFIG; break;
    
    case ERROR_REQUEST_TIMEOUT:
    case ERROR_SERVER_OUT_OF_RESOURCES:
    case ERROR_SERVER_GENERAL_NET_FAILURE:
    case WARNING_MSG_ALIAS_NOT_ADDED:
    case ERROR_SERVER_NOT_RESPONDING:
        ev=EVENT_GENERAL_NET_ERROR; break;
        
    case ERROR_IP_CONFIGURATION:
    case ERROR_NO_IP_ADDRESSES:
    case ERROR_PPP_REMOTE_TERMINATED:
    case ERROR_PPP_NO_RESPONSE:
    case ERROR_PPP_INVALID_PACKET:
    case ERROR_PHONE_NUMBER_TOO_LONG:
    case ERROR_IPXCP_NO_DIALOUT_CONFIGURED:
    case ERROR_IPXCP_NO_DIALIN_CONFIGURED:
    case ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE:
    case ERROR_ACCESSING_TCPCFGDLL:
    case ERROR_NO_IP_RAS_ADAPTER:
    case ERROR_SLIP_REQUIRES_IP:
    case ERROR_PROJECTION_NOT_COMPLETE:
    case ERROR_PPP_NOT_CONVERGING:
    case ERROR_PPP_CP_REJECTED:
    case ERROR_PPP_LCP_TERMINATED:
    case ERROR_PPP_REQUIRED_ADDRESS_REJECTED:
    case ERROR_PPP_NCP_TERMINATED:
    case ERROR_PPP_LOOPBACK_DETECTED:
    case ERROR_PPP_NO_ADDRESS_ASSIGNED:
    case ERROR_CANNOT_USE_LOGON_CREDENTIALS:
    case ERROR_NO_LOCAL_ENCRYPTION:
    case ERROR_NO_REMOTE_ENCRYPTION:
    case ERROR_REMOTE_REQUIRES_ENCRYPTION:
    case ERROR_IPXCP_NET_NUMBER_CONFLICT:
        ev = EVENT_PPP_FAILURE; break;
***********/
    }
    return (0xFFFF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\pch.hpp ===
#include <windows.h>
#include <ras.h>
#include "icwunicd.h"
#include "globals.h"
//#include "support.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\mimedl.cpp ===
/*-----------------------------------------------------------------------------
	mimedl.cpp

	Handle the downloading of MIME multi-part/mixed packages.

	Copyright (C) 1996 Microsoft Corporation
	All rights reserved.

	Authors:
		ChrisK		ChrisKauffman

	History:
		7/22/96		ChrisK	Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include <commctrl.h>

#define MAX_EXIT_RETRIES 10

// ############################################################################
DWORD WINAPI DownloadThreadInit(CDialingDlg *pcPDlg)
{
	HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
//	HINSTANCE hADDll;

	// Set up for download
	//

	Assert (pcPDlg->m_pcDLAPI);

	hr = pcPDlg->m_pcDLAPI->DownLoadInit(pcPDlg->m_pszUrl, (DWORD_PTR *)pcPDlg, &pcPDlg->m_dwDownLoad, pcPDlg->m_hwnd);
	if (hr != ERROR_SUCCESS) goto ThreadInitExit;

	// Set up call back for progress dialog
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadSetStatus(pcPDlg->m_dwDownLoad,(INTERNET_STATUS_CALLBACK)ProgressCallBack);

	/**
	// Set up Autodialer DLL
	//

	hADDll = LoadLibrary(AUTODIAL_LIBRARY);
	if (!hADDll) goto end_autodial_setup;
	fp = GetProcAddress(hADDll,AUTODIAL_INIT);
	if (!fp) goto end_autodial_setup;
	((PFNAUTODIALINIT)fp)(g_szInitialISPFile,pcPDlg->m_pGI->fType,pcPDlg->m_pGI->bMask,pcPDlg->m_pGI->dwCountry,pcPDlg->m_pGI->wState);

end_autodial_setup:
	**/

	// Download stuff MIME multipart
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadExecute(pcPDlg->m_dwDownLoad);
	if (hr)
		goto ThreadInitExit;

	hr = pcPDlg->m_pcDLAPI->DownLoadProcess(pcPDlg->m_dwDownLoad);
	if (hr)
		goto ThreadInitExit;

	// Clean up
	//

	hr = pcPDlg->m_pcDLAPI->DownLoadClose(pcPDlg->m_dwDownLoad);
	pcPDlg->m_dwDownLoad = 0;
	// NOTE: I realize this line is unecessary, it would be
	// required if there were any code after it in this function.
	if (hr != ERROR_SUCCESS) goto ThreadInitExit;  
	hr = ERROR_SUCCESS;

ThreadInitExit:
	PostMessage(pcPDlg->m_hwnd,WM_DOWNLOAD_DONE,0,0);
//	if (hADDll) FreeLibrary(hADDll);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
    rnaapi.cpp

    Wrapper to softlink to RNAPH and RASAPI32.DLL

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        1/29/96        ChrisK    Created
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");
static const TCHAR cszRAS16[] = TEXT("RASC16IE.DLL");


#ifdef UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryW";
static const CHAR cszRasHangUp[] = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusW";
static const CHAR cszRasDial[] = "RasDialW";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoW";
#else  // UNICODE
static const CHAR cszRasEnumDevices[] = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";
static const CHAR cszRasValidateEntryName[] = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[] = "RasDeleteEntryA";
static const CHAR cszRasHangUp[] = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[] = "RasGetConnectStatusA";
static const CHAR cszRasDial[] = "RasDialA";
static const CHAR cszRasEnumConnections[] = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[] = "RasGetCountryInfoA";
#endif // UNICODE

// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RNAAPI
//
//    Synopsis:    Initialize class members and load DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
#if defined(WIN16)
    m_hInst = LoadLibrary(cszRAS16); 
    m_hInst2 = NULL;
#else
    m_hInst = LoadLibrary(cszRASAPI32_DLL);
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
        m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif    

    m_fnRasEnumDeviecs = NULL;
    m_fnRasValidateEntryName = NULL;
    m_fnRasSetEntryProperties = NULL;
    m_fnRasGetEntryProperties = NULL;
    m_fnRasDeleteEntry = NULL;
    m_fnRasHangUp = NULL;
    m_fnRasGetConnectStatus = NULL;
    m_fnRasEnumConnections = NULL;
    m_fnRasDial = NULL;
    m_fnRasGetEntryDialParams = NULL;
    m_fnRasGetCountryInfo = NULL;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::~RNAAPI
//
//    Synopsis:    release DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
    //
    // Clean up
    //
    if (m_hInst) FreeLibrary(m_hInst);
    if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasEnumDevices
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
                             LPDWORD lpcDevices)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

    if (m_fnRasEnumDeviecs)
        dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::LoadApi
//
//    Synopsis:    If the given function pointer is NULL, then try to load the API
//                from the first DLL, if that fails, try to load from the second
//                DLL
//
//    Arguments:    pszFName - the name of the exported function
//                pfnProc - point to where the proc address will be returned
//
//    Returns:    TRUE - success
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
    if (*pfnProc == NULL)
    {
        // Look for the entry point in the first DLL
        if (m_hInst)
            *pfnProc = GetProcAddress(m_hInst,pszFName);
        
        // if that fails, look for the entry point in the second DLL
        if (m_hInst2 && !(*pfnProc))
            *pfnProc = GetProcAddress(m_hInst2,pszFName);
    }

    return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetConnectStatus
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

    if (m_fnRasGetConnectStatus)
        dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

#if defined(WIN16) && defined(DEBUG)
    TraceMsg(TF_GENERAL, ("RasGetConnectStatus returned %lu\r\n", dwRet);    
#endif
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasValidateEntryName
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

    LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

    if (m_fnRasValidateEntryName)
        dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

#if !defined(WIN16)
#define RASGETCOUNTRYINFO_BUFFER_SIZE 256


    if (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode)
    {
        if( !( ((LPRASENTRY)lpbEntryInfo)->dwfOptions & RASEO_UseCountryAndAreaCodes) )
        {
            // jmazner 10/10/96
            // if this is a dial as is number, then RasGetEntryProperties will not have
            // filled in the fields below.  This makes sense.
            // However, RasSetEntryProperties fails to ignore these fileds for a dial-as-is number,
            // the hack below in the else clause takes care of an empty countryCode, but
            // if the CountryID is missing too, it doesn't work.
            // So deal with such a case here, filling in the fields that RasSetEntry will validate.
            ((LPRASENTRY)lpbEntryInfo)->dwCountryID = 1;
            ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = 1;
            ((LPRASENTRY)lpbEntryInfo)->szAreaCode[0] = '8';
            ((LPRASENTRY)lpbEntryInfo)->szAreaCode[1] = '\0';
        }
        else
        {
            BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
            LPRASCTRYINFO prasCI;
            DWORD dwSize;
            DWORD dw;
            prasCI = (LPRASCTRYINFO)rasCI;
            ZeroMemory(prasCI,sizeof(rasCI));
            prasCI->dwSize = sizeof(RASCTRYINFO);
            dwSize = sizeof(rasCI);

            Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
            prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

            dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
            if (ERROR_SUCCESS == dw)
            {
                Assert(prasCI->dwCountryCode);
                ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
            } 
            else
            {
                AssertMsg(0,"Unexpected error from RasGetCountryInfo.\r\n");
            }
        }
    }
#endif

    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfo, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);
#if !defined(WIN16)
    RasSetEntryPropertiesScriptPatch(((RASENTRY*)&(*lpbEntryInfo))->szScript, lpszEntry);
#endif

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//                jmazner    9/16/96 Added bUsePatch variable to allow calls with buffers = NULL and InfoSizes = 0.
//                                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD    dwRet = ERROR_DLL_NOT_FOUND;
    LPBYTE    lpbEntryInfoPatch = NULL;
    LPDWORD    lpdwEntryInfoPatchSize = NULL;
    BOOL    bUsePatch = TRUE;

#if defined(WIN16)
    bUsePatch = FALSE;
#endif

    if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
    {

        Assert( NULL != lpdwEntryInfoSize );
        Assert( NULL != lpdwDeviceInfoSize );

        Assert( 0 == *lpdwEntryInfoSize );
        Assert( 0 == *lpdwDeviceInfoSize );

        // we're here to ask RAS what size these buffers need to be, don't use the patch stuff
        // (see RasGetEntryProperties docs)
        bUsePatch = FALSE;
    }

    if( bUsePatch )
    {
        Assert(lpbEntryInfo && lpdwEntryInfoSize);
        Assert( (*lpdwEntryInfoSize) >= sizeof(RASENTRY) );

        //
        // We are going to fake out RasGetEntryProperties by creating a slightly larger
        // temporary buffer and copying the data in and out.
        //
        lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == lpdwEntryInfoPatchSize)
            return ERROR_NOT_ENOUGH_MEMORY;


        *lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
        lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
        if (NULL == lpbEntryInfoPatch)
            return ERROR_NOT_ENOUGH_MEMORY;
    
        // RAS expects the dwSize field to contain the size of the LPRASENTRY struct
        // (used to check which version of the struct we're using) rather than the amount
        // of memory actually allocated to the pointer.
        //((LPRASENTRY)lpbEntryInfoPatch)->dwSize = *lpdwEntryInfoPatchSize;
        ((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
    }
    else
    {
        lpbEntryInfoPatch = lpbEntryInfo;
        lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
    }


    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

    if (m_fnRasGetEntryProperties)
        dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
                                    lpbDeviceInfo, lpdwDeviceInfoSize);

    TraceMsg(TF_GENERAL, "ICWDIAL: RasGetEntryProperties returned %lu\r\n", dwRet);    

    if( bUsePatch )
    {
        //
        // Copy out the contents of the temporary buffer UP TO the size of the original buffer
        //
        Assert(lpbEntryInfoPatch);
        memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
        GlobalFree(lpbEntryInfoPatch);
        lpbEntryInfoPatch = NULL;
    }

    //
    // We are again faking Ras functionality here by over writing the size value;
    // This is so that RasSetEntryProperties will not choke...
    if( NULL != lpbEntryInfo )
    {
        *lpdwEntryInfoSize = sizeof(RASENTRY);
    }

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasDeleteEntry
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

    if (m_fnRasDeleteEntry)
        dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
    
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasHangUp
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

    if (m_fnRasHangUp)
    {
        dwRet = (*m_fnRasHangUp) (hrasconn);
#if !defined(WIN16)
        Sleep(3000);
#endif
    }

    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                      LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
                      LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

    if (m_fnRasDial)
    {
        dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
                                dwNotifierType,lpvNotifier,lphRasConn);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

    if (m_fnRasEnumConnections)
    {
        dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                    LPBOOL lpfPassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

    if (m_fnRasGetEntryDialParams)
    {
        dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetCountryInfo
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

    if (m_fnRasGetCountryInfo)
    {
        dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
    }
    return dwRet;
}

#if !defined(WIN16)
static const TCHAR cszDeviceSwitch[] = TEXT("DEVICE=switch");
static const TCHAR cszRasPBKFilename[] = TEXT("\\ras\\rasphone.pbk");
#define SCRIPT_PATCH_BUFFER_SIZE 2048
#define SIZEOF_NULL 1
static const TCHAR cszType[] = TEXT("Type=");
//+----------------------------------------------------------------------------
//
//    Function    RemoveOldScriptFilenames
//
//    Synopsis    Given the data returned from a call to GetPrivateProfileSection
//                remove any information about existing script file so that
//                we can replace it with the new script information.
//
//    Arguments    lpszData - pointer to input data
//
//    Returns        TRUE - success
//                lpdwSize - size of resulting data
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL RemoveOldScriptFilenames(LPTSTR lpszData, LPDWORD lpdwSize)
{
    BOOL bRC = FALSE;
    LPTSTR lpszTemp = lpszData;
    LPTSTR lpszCopyTo = lpszData;
    INT iLen = 0;

    //
    // Walk through list of name value pairs
    //
    if (!lpszData || '\0' == lpszData[0])
        goto RemoveOldScriptFilenamesExit;
    while (*lpszTemp) {
        if (0 != lstrcmpi(lpszTemp,cszDeviceSwitch))
        {
            //
            //    Keep pairs that don't match criteria
            //
            iLen = lstrlen(lpszTemp);
            if (lpszCopyTo != lpszTemp)
            {
                memmove(lpszCopyTo, lpszTemp, iLen+1);
            }
            lpszCopyTo += iLen + 1;
            lpszTemp += iLen + 1;
        }
        else
        {
            //
            // Skip the pair that matches and the one after that
            //
            lpszTemp += lstrlen(lpszTemp) + 1;
            if (*lpszTemp)
                lpszTemp += lstrlen(lpszTemp) + 1;
        }
    }

    //
    // Add second trailing NULL
    //
    *lpszCopyTo = '\0';
    //
    // Return new size
    // Note the size does not include the final \0
    //
    *lpdwSize = (DWORD)(lpszCopyTo - lpszData);

    bRC = TRUE;
RemoveOldScriptFilenamesExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    GleanRealScriptFileName
//
//    Synopsis    Given a string figure out the real filename
//                Due to another NT4.0 Ras bug, script filenames returned by
//                RasGetEntryProperties may contain a leading garbage character
//
//    Arguments    lppszOut - pointer that will point to real filename
//                lpszIn - points to current filename
//
//    Returns        TRUE - success
//                *lppszOut - points to real file name, remember to free the memory
//                    in this variable when you are done.  And don't talk with
//                    your mouth full - mom.
//
//    History        10/2/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GleanRealScriptFileName(LPTSTR *lppszOut, LPTSTR lpszIn)
{
    BOOL bRC = FALSE;
    LPTSTR lpsz = NULL;
    DWORD dwRet = 0;

    //
    // Validate parameters
    //
    Assert(lppszOut && lpszIn);
    if (!(lppszOut && lpszIn))
        goto GleanFilenameExit;

    //
    // first determine if the filename is OK as is
    //
    dwRet = GetFileAttributes(lpszIn);
    if ('\0' != lpszIn[0] && 0xFFFFFFFF == dwRet) // Empty filename is OK
    {
        //
        // Check for the same filename without the first character
        //
        lpsz = lpszIn+1;
        dwRet = GetFileAttributes(lpsz);
        if (0xFFFFFFFF == dwRet)
            goto GleanFilenameExit;
    } 
    else
    {
        lpsz = lpszIn;
    }

    //
    // Return filename
    //
    *lppszOut = (LPTSTR)GlobalAlloc(GPTR,sizeof(TCHAR)*(lstrlen(lpsz)+1));
    lstrcpy(*lppszOut,lpsz);

    bRC = TRUE;
GleanFilenameExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    IsScriptPatchNeeded
//
//    Synopsis    Check version to see if patch is needed
//
//    Arguments    lpszData - contents of section in rasphone.pbk
//                lpszScript - name of script file
//
//    Returns        TRUE - patch is needed
//
//    Histroy        10/1/96
//
//-----------------------------------------------------------------------------
static BOOL IsScriptPatchNeeded(LPTSTR lpszData, LPTSTR lpszScript)
{
    BOOL bRC = FALSE;
    LPTSTR lpsz = lpszData;
    TCHAR szType[MAX_PATH + sizeof(cszType)/sizeof(TCHAR) + 1];

    lstrcpy(szType,cszType);
    lstrcat(szType,lpszScript);

    Assert(MAX_PATH + sizeof(cszType)/sizeof(TCHAR) +1 > lstrlen(szType));

    lpsz = lpszData;
    while(*lpsz)
    {
        if (0 == lstrcmp(lpsz,cszDeviceSwitch))
        {
            lpsz += lstrlen(lpsz)+1;
            // if we find a DEVICE=switch statement and the script is empty
            // then we'll have to patch the entry
            if (0 == lpszScript[0])
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is different
            // then we'll have to patch the entry
            else if (0 != lstrcmp(lpsz,szType))
                bRC = TRUE;
            // if we find a DEVICE=switch statement and the script is the same
            // then we DON'T have to patch it
            else
                bRC = FALSE;
            break; // get out of while statement
        }
        lpsz += lstrlen(lpsz)+1;
    }
    
    if ('\0' == *lpsz)
    {
        // if we didn't find DEVICE=switch statement and the script is empty
        // then we DON'T have to patch it
        if ('\0' == lpszScript[0])
            bRC = FALSE;
        // if we didn't find DEVICE=switch statement and the script is not
        // empty the we'll have to patch it.
        else
            bRC = TRUE;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    GetRasPBKFilename
//
//    Synopsis    Find the Ras phone book and return the fully qualified path
//                in the buffer
//
//    Arguments    lpBuffer - pointer to buffer
//                dwSize    - size of buffer (must be at least MAX_PATH)
//
//    Returns        TRUE - success
//
//    History        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
static BOOL GetRasPBKFilename(LPTSTR lpBuffer, DWORD dwSize)
{
    BOOL bRC = FALSE;
    UINT urc = 0;
    LPTSTR lpsz = NULL;

    //
    // Validate parameters
    //
    Assert(lpBuffer && (dwSize >= MAX_PATH));
    //
    // Get path to system directory
    //
    urc = GetSystemDirectory(lpBuffer,dwSize);
    if (0 == urc || urc > dwSize)
        goto GetRasPBKExit;
    //
    // Check for trailing '\' and add \ras\rasphone.pbk to path
    //
    lpsz = &lpBuffer[lstrlen(lpBuffer)-1];
    if ('\\' != *lpsz)
        lpsz++;
    lstrcpy(lpsz,cszRasPBKFilename);

    bRC = TRUE;
GetRasPBKExit:
    return bRC;
}
//+----------------------------------------------------------------------------
//
//    Function    RasSetEntryPropertiesScriptPatch
//
//    Synopsis    Work around bug in NT4.0 that does not save script file names
//                to RAS phone book entries
//
//    Arguments    lpszScript - name of script file
//                lpszEntry - name of phone book entry
//
//    Returns        TRUE - success
//
//    Histroy        10/1/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL WINAPI RasSetEntryPropertiesScriptPatch(LPTSTR lpszScript, LPTSTR lpszEntry)
{
    BOOL bRC = FALSE;
    TCHAR szRasPBK[MAX_PATH+1];
    TCHAR szData[SCRIPT_PATCH_BUFFER_SIZE];
    DWORD dwrc = 0;
    LPTSTR lpszTo;
    LPTSTR lpszFixedFilename = NULL;

    //
    // Validate parameters
    //
    Assert(lpszScript && lpszEntry);
    TraceMsg(TF_GENERAL, "ICWDIAL: ScriptPatch script %s, entry %s.\r\n", lpszScript,lpszEntry);    

    //
    // Verify and fix filename
    //
    if (!GleanRealScriptFileName(&lpszFixedFilename, lpszScript))
        goto ScriptPatchExit;

    //
    // Get the path to the RAS phone book
    //
    if (!GetRasPBKFilename(szRasPBK,MAX_PATH+1))
        goto ScriptPatchExit;
    //
    //    Get data
    //
    ZeroMemory(szData,SCRIPT_PATCH_BUFFER_SIZE);
    dwrc = GetPrivateProfileSection(lpszEntry,szData,SCRIPT_PATCH_BUFFER_SIZE,szRasPBK);
    if (SCRIPT_PATCH_BUFFER_SIZE == (dwrc + 2))
        goto ScriptPatchExit;
    //
    // Verify version
    //
    if (!IsScriptPatchNeeded(szData,lpszFixedFilename))
    {
        bRC = TRUE;
        goto ScriptPatchExit;
    }

    //
    // Clean up data
    //
    RemoveOldScriptFilenames(szData, &dwrc);
    //
    // Make sure there is enough space left to add new data
    //
    if (SCRIPT_PATCH_BUFFER_SIZE <=
        (dwrc + sizeof(cszDeviceSwitch)/sizeof(TCHAR) + SIZEOF_NULL + sizeof(cszType)/sizeof(TCHAR) + MAX_PATH))
        goto ScriptPatchExit;
    //
    // Add data
    //
    if ('\0' != lpszFixedFilename[0])
    {
        lpszTo = &szData[dwrc];
        lstrcpy(lpszTo,cszDeviceSwitch);
        lpszTo += sizeof(cszDeviceSwitch)/sizeof(TCHAR);
        lstrcpy(lpszTo,cszType);
        lpszTo += sizeof(cszType)/sizeof(TCHAR) - 1;
        lstrcpy(lpszTo,lpszFixedFilename);
        lpszTo += lstrlen(lpszFixedFilename) + SIZEOF_NULL;
        *lpszTo = '\0';    // extra terminating NULL

        Assert(&lpszTo[SIZEOF_NULL]<&szData[SCRIPT_PATCH_BUFFER_SIZE]);
    }
    //
    //    Write data
    //
    bRC = WritePrivateProfileSection(lpszEntry,szData,szRasPBK);

ScriptPatchExit:
    if (lpszFixedFilename)
        GlobalFree(lpszFixedFilename);
    lpszFixedFilename = NULL;
    if (!bRC)
        TraceMsg(TF_GENERAL, "ICWDIAL: ScriptPatch failed.\r\n");
    return bRC;
}
#endif //!win16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\import.cpp ===
/*-----------------------------------------------------------------------------
    import.cpp

    This file contain all the functions that handle importing connection
    information from .DUN files

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
    Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
        this code started its life as ixport.c in RNAUI.DLL
        my thanks to viroont
        7/22/96        ChrisK    Cleaned and formatted

-----------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

#include "inetcfg.h"

#define IDS_DEFAULT_SCP         0
#define IDS_INI_SCRIPT_DIR      1
#define IDS_INI_SCRIPT_SHORTDIR 2

#define MAXLONGLEN      80
#define MAXNAME         80

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
//extern HINSTANCE g_hInstance;
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#define AUTORUNSIGNUPWIZARDAPI "InetConfigClient"

typedef HRESULT (CALLBACK *PFNAUTORUNSIGNUPWIZARD) (HWND hwndParent,
                                                    LPCTSTR lpszPhoneBook,
                                                     LPCTSTR lpszConnectoidName,
                                                     LPRASENTRY lpRasEntry,
                                                     LPCTSTR lpszUsername,
                                                     LPCTSTR lpszPassword,
                                                     LPCTSTR lpszProfileName,
                                                     LPINETCLIENTINFO lpINetClientInfo,
                                                     DWORD dwfOptions,
                                                     LPBOOL lpfNeedsRestart);

#pragma data_seg(".rdata")

TCHAR cszEntrySection[] = TEXT("Entry");
TCHAR cszEntryName[]    = TEXT("Entry_Name");
TCHAR cszAlias[]        = TEXT("Import_Name");
TCHAR cszML[]           = TEXT("Multilink");

TCHAR cszPhoneSection[] = TEXT("Phone");
TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
TCHAR cszPhone[]        = TEXT("Phone_Number");
TCHAR cszAreaCode[]     = TEXT("Area_Code");
TCHAR cszCountryCode[]  = TEXT("Country_Code");
TCHAR cszCountryID[]    = TEXT("Country_ID");

TCHAR cszDeviceSection[] = TEXT("Device");
TCHAR cszDeviceType[]    = TEXT("Type");
TCHAR cszDeviceName[]    = TEXT("Name");
TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
TCHAR cszDevCfg[]        = TEXT("Settings");

TCHAR cszServerSection[] = TEXT("Server");
TCHAR cszServerType[]    = TEXT("Type");
TCHAR cszSWCompress[]    = TEXT("SW_Compress");
TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
TCHAR cszNetLogon[]      = TEXT("Network_Logon");
TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");

TCHAR cszIPSection[]     = TEXT("TCP/IP");
TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
TCHAR cszIPAddress[]     = TEXT("IP_address");
TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
TCHAR cszDNSAddress[]    = TEXT("DNS_address");
TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
TCHAR cszWINSAddress[]   = TEXT("WINS_address");
TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

TCHAR cszMLSection[]     = TEXT("Multilink");
TCHAR cszLinkIndex[]     = TEXT("Line_%s");

TCHAR cszScriptingSection[] = TEXT("Scripting");
TCHAR cszScriptName[]    = TEXT("Name");

TCHAR cszScriptSection[] = TEXT("Script_File");

TCHAR cszYes[]           = TEXT("yes");
TCHAR cszNo[]            = TEXT("no");

TCHAR cszUserSection[]   = TEXT("User");
TCHAR cszUserName[]      = TEXT("Name");
TCHAR cszPassword[]      = TEXT("Password");

TCHAR szNull[] = TEXT("");

#define DUN_NOPHONENUMBER TEXT("000000000000")

struct {
    TCHAR *szType;
    DWORD dwType;
    DWORD dwfOptions;
} aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};

#pragma data_seg()

//#define RASAPI_LIBRARY "RASAPI32.DLL"
//#define RNAPH_LIBRARY "RNAPH.DLL"
//typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPSTR lpszPhonebook, LPSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);

//PreWriteConnectoid(LPSTR pszEntryName,RASENTRY *lpRasEntry)
//{
//    FARPROC        fp = NULL;
//    HINSTANCE hRNADLL;
//    DWORD dwRasSize;
//    hRNADLL = LoadLibrary(RASAPI_LIBRARY);
//    fp = NULL;
//    if (hRNADLL)
//    {
//        fp = GetProcAddress(hRNADLL,"RasGetEntryProperties");
//    }
//    if (!fp)
//    {
//        if (hRNADLL) FreeLibrary(hRNADLL);
//        hRNADLL = LoadLibrary(RNAPH_LIBRARY);
//        if (hRNADLL) fp = GetProcAddress(hRNADLL,"RasSetEntryProperties");
//    }
//    if (fp)
//    {
//        dwRasSize = sizeof(RASENTRY);
//        ((PFNRASSETENTRYPROPERTIES)fp)(NULL,pszEntryName,(LPBYTE)lpRasEntry,dwRasSize,NULL,0);
//    }
//    if (hRNADLL) FreeLibrary(hRNADLL);
//}

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************

LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, BYTE *pVal)
{
  LPCTSTR pszIP = szIPAddress;

  *pVal = (BYTE)Sz2W(pszIP);
  // skip over digits
  while (FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  // skip over one or more separators
  while (*pszIP && !FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];

  GetPrivateProfileString(cszPhoneSection,
                          cszPhone,
                          DUN_NOPHONENUMBER,
                          lpRasEntry->szLocalPhoneNumber,
                          RAS_MaxPhoneNumber,
                          szFileName);
/****************
 we need to accept entries w/o phone numbers
  if (GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              szNull,
                              lpRasEntry->szLocalPhoneNumber,
                              sizeof(lpRasEntry->szLocalPhoneNumber),
                              szFileName) == 0)
  {
    return ERROR_CORRUPT_PHONEBOOK;
  };
****************/

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszYes,
                          szYesNo,
                          MAXNAME,
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      if (GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              szNull,
                              lpRasEntry->szAreaCode,
                              RAS_MaxAreaCode,
                              szFileName) != 0)
      {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
      }
    }
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          szNull,
                          szType,
                          MAXNAME,
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < sizeof(aServerTypes)/sizeof(aServerTypes[0]); ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
//#ifdef _CHRISK
      lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
//#else
//      lpRasEntry->dwfNetProtocols &= ~RASNP_Netbeui;
//#endif
    }
    else
    {
//#ifdef _CHRISK
      lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
//#else
//      lpRasEntry->dwfNetProtocols |= RASNP_Netbeui;
//#endif
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
      lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPSTR szEntryName, LPSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              szNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateUniqueFile(LPSTR szPath, LPSTR szFile)
//
// This function creates a unique file. If the file already exists, it will
// try to create a file with similar name and return the name.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szScript)
{
  HANDLE hFile;
  LPTSTR  pszSuffix, lpsz;
  UINT   uSuffix;

  pszSuffix = szPath + lstrlen(szPath);
  lpsz = CharPrev(szPath, pszSuffix);
  if (*lpsz != '\\')
  {
    *pszSuffix = '\\';
    pszSuffix++;
  };
  lstrcpy(pszSuffix, szScript);

  // Try the specified filename
  //
  hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                     FILE_ATTRIBUTE_NORMAL, NULL);

  // If the file exists
  //
  if ((hFile == INVALID_HANDLE_VALUE) && (GetLastError() == ERROR_FILE_EXISTS))
  {
    TCHAR szNewName[MAX_PATH];

    // Need to copy it to another name in the same directory
    //
    if (LoadString(g_hInstance, IDS_DEFAULT_SCP, szNewName, MAX_PATH))
    {
      // Increment the file index until a non-duplicated file can be created
      //
      uSuffix = 0;
      do
      {
        wsprintf(pszSuffix, szNewName, uSuffix);
        uSuffix++;
        hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL, NULL);
      }
      while ((hFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_FILE_EXISTS) &&
             (uSuffix < 0x0000FFFF));
    };
  };

  // If we do not have the file, reserve the pathname
  //
  if (hFile == INVALID_HANDLE_VALUE)
  {
    *pszSuffix = '\0';
  };
  return hFile;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPTSTR szImportFile)
//
// This function creates the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPCTSTR szImportFile)
{
  LPTSTR pszPath, pszShortName;
  LPTSTR pszDir;
  DWORD cb;
  HANDLE hFile;

  // Assume failure
  //
  hFile = INVALID_HANDLE_VALUE;

  // Allocate a buffer for pathname
  //
  if ((pszPath = (LPTSTR)GlobalAlloc(LMEM_FIXED, 2*MAX_PATH)) == NULL)
  {
      TraceMsg(TF_GENERAL, "CONNECT:CreateScriptFile(): Local Alloc failed\n");
    return INVALID_HANDLE_VALUE;
  }
  pszShortName = pszPath+MAX_PATH;

  // Get the default directory
  //
  if (GetWindowsDirectory(pszPath, MAX_PATH) != 0)
  {
    // Get the Windows drive
    //
    pszDir = pszPath;
    while((*pszDir != '\\') && (*pszDir != '\0'))
    {
      pszDir = CharNext(pszDir);
    };

    // Did we find Windows drive?
    //
    if (*pszDir != '\0')
    {
      // Prepare the drive
      //
      cb = (DWORD)(pszDir - pszPath);
      MyMemCpy(szScript, pszPath, cb);
      pszDir = szScript + cb;

      // Get the script filename
      //
      if (GetPrivateProfileString(cszScriptingSection,
                                  cszScriptName,
                                  szNull,
                                  pszShortName,
                                  MAX_PATH,
                                  szImportFile) != 0)
      {
        // Try the favorite script directory
        //
        if (LoadString(g_hInstance, IDS_INI_SCRIPT_DIR, pszDir,
                       MAX_PATH - cb) != 0)
        {
          // Try creating the file
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };

        // If we do not have the file yet, try the second favorite
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          if (LoadString(g_hInstance, IDS_INI_SCRIPT_SHORTDIR, pszDir,
                         MAX_PATH - cb))
          {
            // Try creating the file
            //
            hFile = CreateUniqueFile(szScript, pszShortName);
          };
        };

        // If we do not have the file yet, try Windows directory
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          // Get original Windows directory
          //
          lstrcpy(szScript, pszPath);

          // Try one more time
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };
      };
    };
  };

  GlobalFree((HLOCAL)pszPath);
  return hFile;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportScriptFile(LPTSTR szEntryName, LPTSTR szImportFile)
//
// This function imports the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportScriptFile(LPRASENTRY lpRasEntry, LPCTSTR szImportFile)
{
  HANDLE hfScript;
  LPTSTR  pszLine;
  LPTSTR  pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  TCHAR   szTmp[4];
  DWORD  dwRet;

  dwRet=ERROR_SUCCESS;

  // If a script section does not exist, do nothing
  //
  if (GetPrivateProfileString(cszScriptingSection,
                              cszScriptName,
                              szNull,
                              szTmp,
                              4,
                              szImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  // Allocate a buffer for the script lines
  //
  if ((pszLine = (LPTSTR)GlobalAlloc(LMEM_FIXED, SIZE_ReadBuf+MAX_PATH))
       == NULL)
    {
        TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile(): Local Alloc failed\n");
    return ERROR_OUTOFMEMORY;
    }

  // Look for script
  //
  if (GetPrivateProfileString(cszScriptSection,
                              NULL,
                              szNull,
                              pszLine,
                              SIZE_ReadBuf,
                              szImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszFile = pszLine;
    iMaxLine = -1;
    while (*pszFile)
    {
      i = Sz2W(pszFile);
      iMaxLine = max(iMaxLine, i);
      pszFile += lstrlen(pszFile)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      pszFile = pszLine+SIZE_ReadBuf;

      // Create the script file
      //
      //DebugBreak();
      hfScript = CreateScriptFile(pszFile, szImportFile);
        TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile(): CreateScriptFile hfScript %d, %s, %s\n",hfScript,pszFile,szImportFile);

      if (hfScript != INVALID_HANDLE_VALUE)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(cszScriptSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                szImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
            WriteFile(hfScript, pszLine, cbSize+2, (LPDWORD)&cbRet, NULL);
          };
        };

        CloseHandle(hfScript);

        // Associate it with the phonebook entry
        //
        lstrcpyn(lpRasEntry->szScript, pszFile, RAS_MaxEntryName);
      }
      else
      {
        dwRet = GetLastError();
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  GlobalFree((HLOCAL)pszLine);

  return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD WINAPI RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[4];

  // Get the alias entry name
  //
  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  szNull,
                                  szTmp,
                                  4,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_CORRUPT_PHONEBOOK);
}

//****************************************************************************
// HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//  Sat 16-Mar-1996 10:01:00  -by-  Chris Kauffman [chrisk]
// Modified to return HRESULT and load DLL dynamically
//****************************************************************************

HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
{
    LPRASENTRY    lpRasEntry;
    DWORD        dwRet;
    HINSTANCE    hinetcfg;
    FARPROC        fp;
    BOOL        fNeedsRestart;
//#ifdef DEBUG
//    char szDebug[256];
//#endif
    //char          szEntryName[RAS_MaxEntryName+1];
    //char          szUserName[UNLEN+1];
    //char          szPassword[PWLEN+1];
    //BOOL          fNeedsRestart;

    // Get the size of device configuration
    // This also validates an exported file
    //
    if ((dwRet = RnaValidateImportEntry(szFileName)) != ERROR_SUCCESS)
    {
        return dwRet;
    };

    // Allocate a buffer for entry and device config
    //
    if ((lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    };

    // Get the entry name
    // Need to find a good name for it and remember it as an alias
    //
    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          szNull,
                          pszEntryName,
                          RAS_MaxEntryName+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          szNull,
                          pszUserName,
                          UNLEN+1,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          szNull,
                          pszPassword,
                          PWLEN+1,
                          szFileName);
  
    if ((dwRet = ImportPhoneInfo(lpRasEntry, szFileName))
          == ERROR_SUCCESS)
    {
        // Get device name, type and config
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              szNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        // Get Server Type settings
        //
        ImportServerInfo(lpRasEntry, szFileName);

        // Get IP address
        //
        ImportIPInfo(lpRasEntry, szFileName);

        // Import the script file
        //
        if ((dwRet = ImportScriptFile(lpRasEntry, szFileName)) != ERROR_SUCCESS)
        {
            TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile Failed with the error %d,%s,%s",dwRet,szFileName,lpRasEntry->szScript);
        }

        lpRasEntry->dwSize = sizeof(RASENTRY);

        // Load and Locate AutoRunSignUpWizard entry point
        //

        hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
        AssertMsg(hinetcfg,"Cannot find INETCFG.DLL");
        if (!hinetcfg) 
        {
            dwRet = GetLastError();
            goto ImportConnectionExit;
        }
        fp = GetProcAddress(hinetcfg,AUTORUNSIGNUPWIZARDAPI);
        AssertMsg(fp,"Cannot find AutoRunSignupWizard entry point");
        if (!fp)
        {
            dwRet = GetLastError();
            goto ImportConnectionExit;
        }

        // Insert Autodialer
        //

        lstrcpy(lpRasEntry->szAutodialDll,TEXT("ICWDIAL.DLL"));
        lstrcpy(lpRasEntry->szAutodialFunc,TEXT("AutoDialHandler"));
        TraceMsg(TF_GENERAL, "CONNECT:Autodialer installed at %s, %s.\n",lpRasEntry->szAutodialDll,lpRasEntry->szAutodialFunc);

        // Call InetClientConfig
        //

//        PreWriteConnectoid(pszEntryName,lpRasEntry);

        dwRet =  ((PFNAUTORUNSIGNUPWIZARD)fp)(
                    NULL,
                    NULL,
                    pszEntryName,
                    lpRasEntry,
                    pszUserName,
                    pszPassword,
                    NULL,
                    NULL,
                    INETCFG_SETASAUTODIAL |
                       INETCFG_INSTALLRNA |
                    INETCFG_INSTALLTCP |
                    INETCFG_OVERWRITEENTRY,
                    &fNeedsRestart);
#if !defined(WIN16)
        RasSetEntryPropertiesScriptPatch(lpRasEntry->szScript,pszEntryName);
#endif //!Win16
        //RestoreDeskTopInternetCommand();

        TraceMsg(TF_GENERAL, "CONNECT:EntryName %s, User %s, Password %s, Number %s\n",pszEntryName,pszUserName,pszPassword,lpRasEntry->szLocalPhoneNumber);
        AssertMsg(!fNeedsRestart,"We have to reboot AGAIN!!");
    }

    // Exit and cleanup
    //

ImportConnectionExit:
    if (hinetcfg) FreeLibrary(hinetcfg);
    GlobalFree((HLOCAL)lpRasEntry);
    return dwRet;
}


// ############################################################################
HRESULT CreateEntryFromDUNFile(PTSTR pszDunFile)
{
    TCHAR szFileName[MAX_PATH];
    //char szEntryName[RAS_MaxEntryName+1];
    TCHAR szUserName[UNLEN+1];
    TCHAR szPassword[PWLEN+1];
    LPTSTR pszTemp;
    HRESULT hr;

    hr = ERROR_SUCCESS;

    // Get fully qualified path name
    //

    if (!SearchPath(GIGetAppDir(),pszDunFile,NULL,MAX_PATH,&szFileName[0],&pszTemp))
    {
        //MsgBox(IDS_CANTREADDUNFILE,MB_APPLMODAL | MB_ICONERROR);
        hr = ERROR_FILE_NOT_FOUND;
        goto CreateEntryFromDUNFileExit;
    }

    // save current DUN file name in global (for ourself)
    SetCurrentDUNFile(&szFileName[0]);

    hr = ImportConnection (&szFileName[0], g_szEntryName, szUserName, szPassword);
    //if (hr != ERROR_SUCCESS) 
    //{
    //    MsgBox(IDS_CANTREADDUNFILE,MB_APPLMODAL | MB_ICONERROR);
    //    goto CreateEntryFromDUNFileExit;
    //}// else {
//
//        // place the name of the connectoid in the registry
//        //
    if (ERROR_SUCCESS != (StoreInSignUpReg((LPBYTE)g_szEntryName, lstrlen(g_szEntryName), REG_SZ, RASENTRYVALUENAME)))
    {
        MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
        goto CreateEntryFromDUNFileExit;
    }
//    }
CreateEntryFromDUNFileExit:
    return hr;
}

// ############################################################################
BOOL FSz2Dw(PCTSTR pSz,DWORD *dw)
{
    DWORD val = 0;
    while (*pSz && *pSz != '.')
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
BOOL BreakUpPhoneNumber(RASENTRY *prasentry, LPTSTR pszPhone)
{
    PTSTR         pszStart,pszNext, pszLim;
//    LPPHONENUM     ppn;
    
    if (!pszPhone) return FALSE; // skip if no number
    
    pszLim = pszPhone + lstrlen(pszPhone);    // find end of string

    //ppn = (fMain) ? &(pic->PhoneNum) : &(pic->PhoneNum2);
    
    ////Get the country ID...
    //ppn->dwCountryID = PBKDWCountryId();
    
    // Get Country Code from phone number...
    pszStart = _tcschr(pszPhone,'+');
    if(!pszStart) goto error; // bad format

    // get country code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart || !pszNext) goto error; // bad format
    //ppn->dwCountryCode = Sz2Dw(pszStart);
    FSz2Dw(pszStart,&prasentry->dwCountryCode);
    pszStart = pszNext;
        
    //Now get the area code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart || !pszNext) goto error; // bad format
    //lstrcpy(ppn->szAreaCode, pszStart);
    lstrcpyn(prasentry->szAreaCode,pszStart,sizeof(prasentry->szAreaCode));
    pszStart = pszNext;

    //now the local phone number (everything from here to : or end)
    pszNext = _tcschr(pszStart, ':');
    if(pszNext) *pszNext='\0';
    //lstrcpy(ppn->szLocal,pszStart);
    lstrcpyn(prasentry->szLocalPhoneNumber,pszStart,RAS_MaxPhoneNumber);

    //no extension. what is extension?
    //ppn->szExtension[0] = '\0';
    //GlobalFree(pszPhone);
    return TRUE;

error:
    // This means number is not canonical. Set it as local number anyway!
    // memset(ppn, 0, sizeof(*ppn));
    // Bug#422: need to strip stuff after : or dial fails!!
    pszNext = _tcschr(pszPhone, ':');
    if(pszNext) *pszNext='\0';
    //lstrcpy(ppn->szLocal,pszPhone);
    lstrcpy(prasentry->szLocalPhoneNumber,pszPhone);
    //GlobalFree(pszPhone);
    return TRUE;
}


// ############################################################################
int Sz2W (LPCTSTR szBuf)
{
    DWORD dw;
    if (FSz2Dw(szBuf,&dw))
    {
        return (WORD)dw;
    }
    return 0;
}

// ############################################################################
int FIsDigit( int c )
{
    TCHAR szIn[2];
    WORD rwOut[2];
    szIn[0] = (TCHAR)c;
    szIn[1] = '\0';
    GetStringTypeEx(LOCALE_USER_DEFAULT,CT_CTYPE1,szIn,-1,rwOut);
    return rwOut[0] & C1_DIGIT;
}

// ############################################################################
void *MyMemCpy(void *dest,const void *src, size_t count)
{
    LPBYTE pbDest = (LPBYTE)dest;
    LPBYTE pbSrc = (LPBYTE)src;
    LPBYTE pbEnd = (LPBYTE)((DWORD_PTR)src + count);
    while (pbSrc < pbEnd)
    {
        *pbDest = *pbSrc;
        pbSrc++;
        pbDest++;
    }
    return dest;
}


// ############################################################################
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegQueryValueEx(hKey,pszKey,0,&dwType,lpbData,pdwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegSetValueEx(hKey,pszKey,0,dwType,lpbData,sizeof(TCHAR)*dwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
PTSTR GetNextNumericChunk(PTSTR psz, PTSTR pszLim, PTSTR* ppszNext)
{
    PTSTR pszEnd;

    // init for error case
    *ppszNext = NULL;
    // skip non numerics if any to start of next numeric chunk
    while(*psz<'0' || *psz>'9')
    {
        if(psz >= pszLim) return NULL;
        psz++;
    }
    // skip all numerics to end of country code
    for(pszEnd=psz; *pszEnd>='0' && *pszEnd<='9' && pszEnd<pszLim; pszEnd++)
        ;
    // zap whatever delimiter there was to terminate this chunk
    *pszEnd++ = '\0';
    // return ptr to next chunk (pszEnd now points to it)
    if(pszEnd<pszLim) 
        *ppszNext = pszEnd;
        
    return psz;    // return ptr to start of chunk
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwdial

MAJORCOMP=GETCONN
MINORCOMP=ICWDIAL

TARGETNAME=ICWDIAL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\icwdial.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwdial.rc       \
    ..\autodial.cpp     \
    ..\dialdlg.cpp      \
    ..\dialerr.cpp      \
    ..\dialutil.cpp     \
    ..\dlapi.cpp        \
    ..\icwerr.cpp       \
    ..\import.cpp       \
    ..\mimedl.cpp       \
    ..\rnaapi.cpp       \
    ..\rnawnd.cpp       \

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\boyer.cpp ===
/*-----------------------------------------------------------------------------
    Program Specification

    in:     search space s, pattern p
    out:    a pointer where p is exactly matched at s[i], NULL indicates fail
    why:    Boyer-Moore algorithm is best for general text search. On
            "average" it takes length(s)/length(p) steps to match p in s.

    ref:    I recommend the following references:

            "Algorithms". Robert Sedgewick. Addison Wesley Publishing Company.
            1988. 2nd addition. p286. QA76.6.S435 1983

            "Faster String Searches". Doctor Dobb's Journal. Volume 14
            Issue 7 July 1989. Costas Menico. p74.

    usage:  e.g. to find a pattern "tiger" in a text in RAM starting at
                 pointer "txtp" with a length of 1,000,000 characters,
                 program like this:

            LPSTR matchp;

            SetFindPattern( "tiger" );
            matchp = Find( txtp, 1000000L );
            if (matchp != NULL)
                // found
            else
                // not found

            matchp = FindBackward( txtp + 1000000L - 1, 1000000L);
            if (matchp != NULL)
                // found
            else
                // not found


    Q:      Can I use Find() with a GlobalLock() pointer in Windows?
    A:      Yes.

    Q:      Must I delcare my pointer as HPSTR (huge pointer) ?
    A:      Not necessary.  Find() and FindBackward() will convert your
            LPSTR as HPSTR.  However, in your own code you must aware
            that you are holding a LPSTR and take care of the pointer
            arithmetic and conversion. (see demo.c for example)

    Q:      What is the limit of the memory space I can search?
    A:      To the limit of huge pointer implementation and your hardware.

-----------------------------------------------------------------------------*/

#include "pch.hpp"


/*-----------------------------------------------------------------------------
    func:   SetFindPattern
    desc:   initialize the pattern to be matched and generate skip table
    pass:   lpszPattern = pattern string
    rtrn:   HFIND - the find handle for further text search
-----------------------------------------------------------------------------*/
HFIND SetFindPattern( LPTSTR lpszPattern )
{
    register unsigned int j;
    register TCHAR c;
    HFIND hfind;
   

    hfind = (HFIND)MyAlloc(sizeof(FINDSTRUCT));
    
    hfind->plen = lstrlen( lpszPattern );

    if (hfind->plen > MAXPAT)
        hfind->plen = MAXPAT;

#ifdef UNICODE
    wcstombs( (LPSTR)(hfind->p), lpszPattern, hfind->plen + 1 );
#else
    lstrcpy( (LPSTR)(hfind->p), lpszPattern );
#endif
    

    for (j=0; j<256; j++)
    {
        hfind->skip[j] = hfind->plen;
    }

    for (j=0; j<hfind->plen; j++)
    {
        c = lpszPattern[j];
        hfind->skip[c] =  hfind->plen - (j +1);
    }

    return (hfind);
}

/*-----------------------------------------------------------------------------
    func:   FreeFindPattern
    desc:   free the memory occupied by SetFindPattern
    pass:   hfind - the find handle
    rtrn:   nothing
-----------------------------------------------------------------------------*/
void FreeFindPattern( HFIND hfind )
{
	
	MyFree((LPTSTR)hfind);
}

/*-----------------------------------------------------------------------------
    func:   Find
    desc:   match a pattern defined in SetFindPattern against string s
    pass:   hfind = the find handle created by SetFindPattern
            s = start of search space, slen = length of s
    rtrn:   NULL = match fail
            else = a LPTSTR to p[0] in s matches p
-----------------------------------------------------------------------------*/
LPSTR Find( HFIND hfind, LPSTR s, long slen )

{
    register int i;
    unsigned int n, j;
    register unsigned char c;
    LPSTR lpresult;
    

    
    i = hfind->plen;
	j = hfind->plen;
  

    do
    {
        c = *(s + (i - 1));

        if (c == hfind->p[j - 1])
        {
			i--;
			j--;
        }
		else
        {
            n = hfind->plen - j + 1;
            if (n > hfind->skip[c] )
            {
                i += n;
            }
			else
            {
                i += hfind->skip[c];
            }
            j = hfind->plen;
        }
    }
    while ((j >= 1) && (i <= slen));

    /* match fails */
    if (i >= slen)
    {
        lpresult = (LPSTR)NULL;
    }
    /* match successful */
    else
    {
        lpresult = s + i;
    }

    
    return (lpresult);
}




#ifdef TEST_MAIN
#pragma message("Building with TEST_MAIN")
#include <stdio.h>
TCHAR test_buffer[]=TEXT("___________12191919191919This is string for testing our find ___________12191919191919function 12abE Is it in here somehwere ?");
TCHAR test_pattern[]=TEXT("___________12191919191919");

void main(void)
{
	HFIND hFind;
	TCHAR *tmp;

	hFind=SetFindPattern(test_pattern);
	tmp=Find(hFind, test_buffer,strlen(test_buffer));
	if (tmp!=NULL) printf("Found pattern at offset %u, %s",tmp-test_buffer,tmp);
	FreeFindPattern(hFind);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\rnawnd.cpp ===
/*----------------------------------------------------------------------------
    rnawnd.cpp
        
    Functions to zap the RNA windows 
    
    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
    ChrisK    Updated for ICW usage
  --------------------------------------------------------------------------*/

#include "pch.hpp"
#include "resource.h"

//#define SMALLBUFLEN 48

/*******************************************************************
    NAME:        MinimizeRNAWindow
    SYNOPSIS:    Finds and minimizes the annoying RNA window
    ENTRY:        pszConnectoidName - name of connectoid launched
    NOTES:        Does a FindWindow on window class "#32770" (hard-coded
                dialog box class which will never change), with
                the title "connected to <connectoid name>" or its
                localized equivalent.
********************************************************************/

static const TCHAR szDialogBoxClass[] = TEXT("#32770");    // hard coded dialog class name
typedef struct tagWaitAndMinimizeRNAWindowArgs
{
    LPTSTR pTitle;
    HINSTANCE hinst;
} WnWRNAWind, FAR * LPRNAWindArgs;

WnWRNAWind RNAWindArgs;
HWND hwndFound = NULL;
DWORD dwRASWndTitleMinLen = 0;

BOOL CALLBACK MyEnumWindowsProc(HWND hwnd, LPARAM lparam)
{
    TCHAR szTemp[SMALLBUFLEN+2];
    PTSTR pszTitle;
    UINT uLen1, uLen2;

    if(!IsWindowVisible(hwnd))
        return TRUE;
    if(GetClassName(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE; // continue enumerating
    if(lstrcmp(szTemp, szDialogBoxClass)!=0)
        return TRUE;
    if(GetWindowText(hwnd, szTemp, SMALLBUFLEN)==0)
        return TRUE;
    szTemp[SMALLBUFLEN] = 0;
    uLen1 = lstrlen(szTemp);
    Assert(dwRASWndTitleMinLen);
    if(uLen1 < dwRASWndTitleMinLen)
        return TRUE;
    // skip last 5 chars of title, but keep length to at least the min len
    uLen1 = min(dwRASWndTitleMinLen, (uLen1-5));
    pszTitle = (PTSTR)lparam;
    Assert(pszTitle);
    uLen2 = lstrlen(pszTitle);
    TraceMsg(TF_GENERAL, "Title=(%s), len=%d, Window=(%s), len=%d\r\n", pszTitle, uLen2, szTemp, uLen1);
    if(uLen2 < uLen1)
        return TRUE;
    if(_memicmp(pszTitle, szTemp, uLen1)!=0)
        return TRUE;
    TraceMsg(TF_GENERAL, "FOUND RNA WINDOW!!!\r\n");
    hwndFound = hwnd;
    return FALSE;
}

HWND MyFindRNAWindow(PTSTR pszTitle)
{
    DWORD dwRet;
    hwndFound = NULL;
    dwRet = EnumWindows((WNDENUMPROC)(&MyEnumWindowsProc), (LPARAM)pszTitle);
    TraceMsg(TF_GENERAL, "EnumWindows returned %d\r\n", dwRet);
    return hwndFound;
}

DWORD WINAPI WaitAndMinimizeRNAWindow(PVOID pArgs)
{
    // starts as a seperate thread
    int i;
    HWND hwndRNAApp;
    LPRNAWindArgs lpRNAArgs;

    lpRNAArgs = (LPRNAWindArgs)pArgs;
    
    Assert(lpRNAArgs->pTitle);
    
    for(i=0; !(hwndRNAApp=MyFindRNAWindow((PTSTR)lpRNAArgs->pTitle)) && i<100; i++)
    {
        TraceMsg(TF_GENERAL, "Waiting for RNA Window\r\n");
        Sleep(50);
    }

    TraceMsg(TF_GENERAL, "FindWindow (%s)(%s) returned %d\r\n", szDialogBoxClass, lpRNAArgs->pTitle, hwndRNAApp);

    if(hwndRNAApp)
    {
        // Hide the window
        // ShowWindow(hwndRNAApp,SW_HIDE);
        // Used to just minimize, but that wasnt enough
        // ChrisK reinstated minimize for ICW
        ShowWindow(hwndRNAApp,SW_MINIMIZE);
    }

    GlobalFree(lpRNAArgs->pTitle);
    // exit function and thread

    FreeLibraryAndExitThread(lpRNAArgs->hinst,HandleToUlong(hwndRNAApp));
    return (DWORD)0;
}

    
void MinimizeRNAWindow(TCHAR * pszConnectoidName, HINSTANCE hInst)
{
    HANDLE hThread;
    DWORD dwThreadId;
    
    Assert(pszConnectoidName);

    // alloc strings for title and format
    TCHAR * pFmt = (TCHAR*)GlobalAlloc(GPTR, sizeof(TCHAR)*(SMALLBUFLEN+1));
    TCHAR * pTitle = (TCHAR*)GlobalAlloc(GPTR, sizeof(TCHAR)*((RAS_MaxEntryName + SMALLBUFLEN + 1)));
    if (!pFmt || !pTitle) 
        goto error;
    
    // load the title format ("connected to <connectoid name>" from resource
    Assert(hInst);
    LoadString(hInst, IDS_CONNECTED_TO, pFmt, SMALLBUFLEN);

    // get length of localized title (including the %s). Assume the unmunged
    // part of the window title is at least "Connected to XX" long.
    dwRASWndTitleMinLen = lstrlen(pFmt);

    // build the title
    wsprintf(pTitle, pFmt, pszConnectoidName);

    RNAWindArgs.pTitle = pTitle;
    RNAWindArgs.hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));

    hThread = CreateThread(0, 0, &WaitAndMinimizeRNAWindow, &RNAWindArgs, 0, &dwThreadId);
    Assert(hThread && dwThreadId);
    // dont free pTitle. The child thread needs it!
    GlobalFree(pFmt);
    // free the thread handle or the threads stack is leaked!
    CloseHandle(hThread);
    return;
    
error:
    if(pFmt)    GlobalFree(pFmt);
    if(pTitle)    GlobalFree(pTitle);
}

// 3/28/97 ChrisK Olympus 296
#if !defined (WIN16)
/*******************************************************************
    NAME:        RNAReestablishZapper
    SYNOPSIS:    Finds and closes the annoying RNA reestablish window
                should it ever appear
    NOTES:        Does a FindWindow on window class "#32770" (hard-coded
                dialog box class which will never change), with
                the title "Reestablish Connection" or it's
                localized equivalent.
********************************************************************/

BOOL fKeepZapping = 0;

void StopRNAReestablishZapper(HANDLE hthread)
{
    if (INVALID_HANDLE_VALUE != hthread && NULL != hthread)
    {
        TraceMsg(TF_GENERAL, "ICWDIAL: Started StopRNAZapper=%d\r\n", fKeepZapping);
        // reset the "stop" flag
        fKeepZapping = 0;
        // wait for thread to complete & free handle
        WaitForSingleObject(hthread, INFINITE);
        CloseHandle(hthread);
        TraceMsg(TF_GENERAL, "ICWDIAL: Stopped StopRNAZapper=%d\r\n", fKeepZapping);
    }
    else
    {
        TraceMsg(TF_GENERAL, "ICWCONN1: StopRNAReestablishZapper called with invalid handle.\r\n");
    }
}

DWORD WINAPI RNAReestablishZapper(PVOID pTitle)
{
    int i;
    HWND hwnd;

    TraceMsg(TF_GENERAL, "ICWDIAL: Enter RNAREstablishZapper(%s) f=%d\r\n", pTitle, fKeepZapping);

    // This thread continues until the fKeepZapping flag is reset
    while(fKeepZapping)
    {
        if(hwnd=FindWindow(szDialogBoxClass, (PTSTR)pTitle))
        {
            TraceMsg(TF_GENERAL, "ICWDIAL: Reestablish: Found Window (%s)(%s) hwnd=%x\r\n", szDialogBoxClass, pTitle, hwnd);
            // Post it the Cancel message
            PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
        }
        Sleep(1000);
    }

    TraceMsg(TF_GENERAL, "ICWDIAL: Exit RNAREstablishZapper(%s) f=%d\r\n", pTitle, fKeepZapping);
    GlobalFree(pTitle);
    return 0;
}

HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst)
{
    HANDLE hThread;
    DWORD dwThreadId;

    // alloc strings for title and format
    TCHAR* pTitle = (TCHAR*)GlobalAlloc(LPTR, SMALLBUFLEN+1);
    if (!pTitle) goto error;
    
    // load the title format "Reestablish Connection" from resource
    Assert(hInst);
    LoadString(hInst, IDS_REESTABLISH, pTitle, SMALLBUFLEN);

    // enable zapping
    fKeepZapping = TRUE;

    hThread = CreateThread(0, 0, &RNAReestablishZapper, pTitle, 0, &dwThreadId);
    Assert(hThread && dwThreadId);
    // dont free pTitle. The child thread needs it!
    
    return hThread;
    
error:
    if(pTitle) GlobalFree(pTitle);
    return INVALID_HANDLE_VALUE;
}

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\boyer.h ===
#ifndef _INC_BOYER
#define _INC_BOYER

/* store the pattern, pattern length and skip table for 256 alphabets */
/* maximum pattern length (MAXPAT) cannot be larger than 65535 */

#define MAXPAT  256

typedef struct {
	unsigned int plen;
	CHAR p[MAXPAT + 1];
	unsigned int skip[256];
} FINDSTRUCT;

typedef FINDSTRUCT FAR * LPFIND;
typedef LPFIND HFIND;

/* boyer.c prototypes */

#ifdef __cplusplus
extern "C" {
#endif
	
	
	HFIND SetFindPattern( LPTSTR lpszPattern );
	void FreeFindPattern( HFIND hfind );
	LPSTR Find( HFIND hfind, LPSTR s, long slen );
	
#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdial\support.h ===
//
// !!!!! this file no longer used !!!!!!
// 5/28/97 jmazner Olympus #4528
// We don't want to show support numbers for calls to the ISP
//


//#--------------------------------------------------------------
//        
//  File:       support.h
//        
//  Synopsis:   holds the  Class declaration for the CSupport
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#include "..\icwphbk\icwsupport.h"

const CHAR PHBK_LIB[] = "icwphbk.dll";
const CHAR PHBK_SUPPORTNUMAPI[] = "GetSupportNumbers";

typedef HRESULT (WINAPI *PFNGETSUPPORTNUMBERS) (PSUPPORTNUM, PDWORD);

class CSupport
{
private:
    PSUPPORTNUM     m_pSupportNumList;
    DWORD           m_dwTotalNums;

    //
    // this function gets the countryID
    //
    BOOL GetCountryID (PDWORD pdwCountryID); 

public:
    CSupport (VOID)
    {
        m_pSupportNumList = NULL;
        m_dwTotalNums = 0;
    }

    ~CSupport (VOID);

    BOOL GetSupportInfo (PCHAR);

};  // end of CSupport class declaration
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\cabhandler.cpp ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include    "pch.hpp"
#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

#include "fdi.h"

static HINSTANCE hCabinetDll = NULL;   /* DLL module handle */

/* pointers to the functions in the DLL */
typedef HFDI (FAR DIAMONDAPI *PFNFDICREATE)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);

static PFNFDICREATE pfnFDICreate = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici);

static PFNFDIIsCabinet pfnFDIIsCabinet = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDICopy)(
        HFDI                hfdi,
        CHAR               *pszCabinet,
        CHAR               *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);

static PFNFDICopy pfnFDICopy = NULL;

typedef BOOL (FAR DIAMONDAPI *PFNFDIDestroy)(
        HFDI                hfdi);

static PFNFDIDestroy pfnFDIDestroy = NULL;

/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;


    if ( hCabinetDll != NULL )
    {
        goto gotEntryPoints;
    }

    hCabinetDll = LoadLibrary(TEXT("CABINET"));
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (PFNFDICREATE) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (PFNFDICopy) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (PFNFDIIsCabinet) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (PFNFDIDestroy) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
        return(NULL);
    }

gotEntryPoints:
    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
        hCabinetDll = NULL;
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char        *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);

    return(rc);
}


/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
        return new BYTE[cb];
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
        delete pv;
}


FNOPEN(file_open)
{
    return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
        return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
        return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
        return _close((int)hf);
}


FNSEEK(file_seek)
{
        return _lseek((int)hf, dist, seektype);
}

FNFDINOTIFY(notification_function)
{
    switch (fdint)
    {
        case fdintCABINET_INFO: // general information about the cabinet
#if 0
            printf(
                "fdintCABINET_INFO\n"
                "  next cabinet     = %s\n"
                "  next disk        = %s\n"
                "  cabinet path     = %s\n"
                "  cabinet set ID   = %d\n"
                "  cabinet # in set = %d (zero based)\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3,
                pfdin->setID,
                pfdin->iCabinet
            );
#endif
            return 0;

        case fdintPARTIAL_FILE: // first file in cabinet is continuation
#if 0
            printf(
                "fdintPARTIAL_FILE\n"
                "   name of continued file            = %s\n"
                "   name of cabinet where file starts = %s\n"
                "   name of disk where file starts    = %s\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;

        case fdintCOPY_FILE:    // file to be copied
        {
            int        response;
            INT_PTR    handle;

#if 0
            printf(
                "fdintCOPY_FILE\n"
                "  file name in cabinet = %s\n"
                "  uncompressed file size = %d\n"
                "  copy this file? (y/n): ",
                pfdin->psz1,
                pfdin->cb
            );
#endif

            handle = file_open(
                pfdin->psz1,
                _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL | _O_TRUNC,
                _S_IREAD | _S_IWRITE 
            );

            return handle;
        }

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];

#if 0
            printf(
                "fdintCLOSE_FILE_INFO\n"
                "   file name in cabinet = %s\n"
                "\n",
                pfdin->psz1
            );
#endif

            file_close(pfdin->hf);

            return TRUE;
        }

        case fdintNEXT_CABINET:    // file continued to next cabinet
#if 0
            printf(
                "fdintNEXT_CABINET\n"
                "   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
                "   cabinet path name                         = %s\n"
                "\n",
                pfdin->psz1,
                pfdin->psz2,
                pfdin->psz3
            );
#endif
            return 0;
    }

    return 0;
}

HRESULT HandleCab(LPTSTR cabinet_fullpath)
{
    ERF             erf;
    HFDI            hfdi;
    INT_PTR         hf;
    FDICABINETINFO    fdici;
    char            *p;
    char            cabinet_name[256];
    char            cabinet_path[256];
    char            szCurrentDirectory[MAX_PATH];
    char            szdrive[_MAX_DRIVE];   
    char            szPathName[_MAX_PATH];     // This will be the dir we need to create
    char            szdir[_MAX_DIR];
    char            szfname[_MAX_FNAME];   
    char            szext[_MAX_EXT];
	char            szcabinet_fullpath[MAX_PATH+1];
    HRESULT         err = S_OK;

#ifdef UNICODE
	wcstombs(szcabinet_fullpath, cabinet_fullpath, MAX_PATH+1);
#else
	lstrcpy(szcabinet_fullpath, cabinet_fullpath);
#endif

    if (GetCurrentDirectoryA(sizeof(szCurrentDirectory), szCurrentDirectory))
    {
        // Split the provided path to get at the drive and path portion
        _splitpath( szcabinet_fullpath, szdrive, szdir, szfname, szext );
        wsprintfA (szPathName, "%s%s", szdrive, szdir);
   
        // Set the directory to where the cab is
        if (!SetCurrentDirectoryA(szPathName))
        {
            return(GetLastError());
        }
    }
    else
    {
        return(GetLastError());
    }
    
    
    do
    {
        hfdi = FDICreate(mem_alloc,
                              mem_free,
                              file_open,
                              file_read,
                              file_write,
                              file_close,
                              file_seek,
                              cpuUNKNOWN,
                              &erf);

        if (hfdi == NULL)
        {
            err =  -1;
            break;
        }

        /*
         * Is this file really a cabinet?
         */
        hf = file_open(
            szcabinet_fullpath,
            _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
            0
        );

        if (hf == -1)
        {
            (void) FDIDestroy(hfdi);

            // Error Opening the file
            err =  -2;
            break;
            
        }

        if (FALSE == FDIIsCabinet(
                hfdi,
                hf,
                &fdici))
        {
            /*
             * No, it's not a cabinet!
             */
            _close((int)hf);

            (void) FDIDestroy(hfdi);
            err =  -3;
            break;
            
        }
        else
        {
            _close((int)hf);
        }

        p = strrchr(szcabinet_fullpath, '\\');

        if (p == NULL)
        {
            lstrcpyA(cabinet_name, szcabinet_fullpath);
            lstrcpyA(cabinet_path, "");
        }
        else
        {
            lstrcpyA(cabinet_name, p+1);

            strncpy(cabinet_path, szcabinet_fullpath, (int) (p-szcabinet_fullpath)+1);
            cabinet_path[ (int) (p-szcabinet_fullpath)+1 ] = 0;
        }

        if (TRUE != FDICopy(
            hfdi,
            cabinet_name,
            cabinet_path,
            0,
            notification_function,
            NULL,
            NULL))
        {
            // Extract Failed.
            (void) FDIDestroy(hfdi);
            err =  -4;
            break;
        }

        if (FDIDestroy(hfdi) != TRUE)
        {

            // why in the world would the context destroy fail ?
            err =  -5;
            break;
            
        }
        
        break;
    }
    while(1 );


    // Set the directory back to the original place
    if (!SetCurrentDirectoryA(szCurrentDirectory))
        return(GetLastError());
        
    
    return err;
}

void CleanupCabHandler()
{
    if (hCabinetDll != NULL)
    {
        FreeLibrary(hCabinetDll);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\pch.hpp ===
#include <windows.h> 
#include <shellapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <wtypes.h>

#include "icwunicd.h"
#include "boyer.h"
#include "mydefs.h"

#include "download.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\mydefs.h ===
#if !defined(WIN16)
extern HANDLE g_hDLLHeap;		// private Win32 heap

#define MyAlloc(n)			((LPTSTR)HeapAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR)*(n)))
#define MyFree(pv)			HeapFree(g_hDLLHeap, 0, pv)
#define MyRealloc(pv, n)	((LPTSTR)HeapReAlloc(g_hDLLHeap, HEAP_ZERO_MEMORY, (pv), sizeof(TCHAR)*(n)))
#define MyHeapSize(pv)     HeapSize(g_hDLLHeap, 0, pv)

LPTSTR MyStrDup(LPTSTR);

#ifdef DEBUG

#define MyAssert(f)			((f) ? 0 : MyAssertProc(__FILE__, __LINE__, #f))
#define MyTrace(x)			{ MyDprintf x; }
#define MyDbgSz(x)			{ puts x; OutputDebugString x; }
int MyAssertProc(LPTSTR, int, LPTSTR);
void CDECL MyDprintf(LPCSTR pcsz, ...);

#else // DEBUG

#	define MyTrace(x)			
#	define MyDbgSz(x)			
#	define MyAssert(f)			

#endif // DEBUG

#define W32toHR(x)	HRESULT_FROM_WIN32(x)

#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\download.cpp ===
/*----------------------------------------------------------------------------
    download.cpp

        Download handling for Signup

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
  --------------------------------------------------------------------------*/

#include    "pch.hpp"
#include    <stdio.h>
#include    <stdlib.h>
#include    <stdarg.h>
#include    <shellapi.h>
#include    <shlobj.h>
#include    <intshcut.h>
#include    <wininet.h>
#include    "icwdl.h"

// 12/4/96 jmazner    Normandy #12193
// path to icwconn1.exe registry key from HKEY_LOCAL_MACHINE
#define ICWCONN1PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CONNWIZ.EXE")
#define PATHKEYNAME     TEXT("Path")

#include <winreg.h>

// Cabbing up.
extern HRESULT HandleCab(LPTSTR pszPath);
extern void CleanupCabHandler();

// all global data is static shared, read-only
// (written only during DLL-load)
HANDLE      g_hDLLHeap;        // private Win32 heap
HINSTANCE   g_hInst;        // our DLL hInstance

HWND        g_hWndMain;        // hwnd of icwconn1 parent window


#define DllExport extern "C" __declspec(dllexport)
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers


LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

//+---------------------------------------------------------------------------
//
//  Function:   MyGetTempPath()
//
//  Synopsis:   Gets the path to temporary directory
//                - Use GetTempFileName to get a file name
//                  and strips off the filename portion to get the temp path
//
//  Arguments:  [uiLength - Length of buffer to contain the temp path]
//                [szPath      - Buffer in which temp path will be returned]
//
//    Returns:    Length of temp path if successful
//                0 otherwise
//
//  History:    7/6/96     VetriV    Created
//                8/23/96        VetriV        Delete the temp file
//                12/4/96        jmazner     Modified to serve as a wrapper of sorts;
//                                     if TMP or TEMP don't exist, setEnv our own
//                                     vars that point to conn1's installed path
//                                     (Normandy #12193)
//
//----------------------------------------------------------------------------
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath)
{
    TCHAR szEnvVarName[SMALL_BUF_LEN + 1] = TEXT("\0unitialized szEnvVarName\0");
    DWORD dwFileAttr = 0;

    lstrcpyn( szPath, TEXT("\0unitialized szPath\0"), 20 );

    // is the TMP variable set?
    LoadSz(IDS_TMPVAR,szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        // if there was any error, this directory isn't valid.
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    lstrcpyn( szEnvVarName, TEXT("\0unitialized again\0"), 19 );

    // if not, is the TEMP variable set?
    LoadSz(IDS_TEMPVAR,szEnvVarName,sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    // neither one is set, so let's use the path to the installed icwconn1.exe
    // from the registry  SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWCONN1.EXE\Path
    HKEY hkey = NULL;

#ifdef UNICODE
    uiLength = uiLength*sizeof(TCHAR);
#endif
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,ICWCONN1PATHKEY, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
        RegQueryValueEx(hkey, PATHKEYNAME, NULL, NULL, (BYTE *)szPath, (DWORD *)&uiLength);
    if (hkey)
    {
        RegCloseKey(hkey);
    }

    //The path variable is supposed to have a semicolon at the end of it.
    // if it's there, remove it.
    if( ';' == szPath[uiLength - 2] )
        szPath[uiLength - 2] = '\0';

    MyTrace(("ICWDL: using path "));
    MyTrace((szPath));
    MyTrace(("\r\n"));


    // go ahead and set the TEMP variable for future reference
    // (only effects currently running process)
    if( szEnvVarName[0] )
    {
        SetEnvironmentVariable( szEnvVarName, szPath );
    }
    else
    {
        lstrcpyn( szPath, TEXT("\0unitialized again\0"), 19 );
        return( 0 );
    }

    return( uiLength );
}


extern "C" BOOL _stdcall DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lbv)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Need to use OLE/Com later
        if (FAILED(CoInitialize(NULL)))
            return(FALSE);

        //
        // ChrisK Olympus 6373 6/13/97
        // Disable thread attach calls in order to avoid race condition
        // on Win95 golden
        //
        DisableThreadLibraryCalls(hInstance);
        g_hInst = hInstance;
        g_hDLLHeap = HeapCreate(0, 0, 0);
        MyAssert(g_hDLLHeap);
        if (g_hDLLHeap == NULL)
            return FALSE;
        break;

    case DLL_PROCESS_DETACH:
        CoUninitialize();
        HeapDestroy(g_hDLLHeap);

        // Cleanup the cabbing stuff.
        CleanupCabHandler();
        break;
    }
    return TRUE;
}


LPTSTR MyStrDup(LPTSTR pszIn)
{
    int len;
    LPTSTR pszOut;

    MyAssert(pszIn);
    len = lstrlen(pszIn);
    if(!(pszOut = (LPTSTR)MyAlloc(len+1)))
    {
        MyAssert(FALSE);
        return NULL;
    }
    lstrcpy(pszOut, pszIn);
    pszOut[len] = 0;

    return pszOut;
}

#ifdef UNICODE
LPTSTR MyStrDup(LPSTR pszIn)
{
    int len;
    LPTSTR pszOut;

    MyAssert(pszIn);
    len = lstrlenA(pszIn);
    if(!(pszOut = (LPTSTR)MyAlloc(len+1)))
    {
        MyAssert(FALSE);
        return NULL;
    }
    mbstowcs(pszOut, pszIn, sizeof(TCHAR)*len);
    pszOut[len] = 0;

    return pszOut;
}
#endif

int MyAssertProc(LPTSTR pszFile, int nLine, LPTSTR pszExpr)
{
    TCHAR szBuf[512];

    wsprintf(szBuf, TEXT("Assert failed at line %d in file %s. (%s)\r\n"), nLine, pszFile, pszExpr);
    MyDbgSz((szBuf));
    return 0;
}

void _cdecl MyDprintf(LPCSTR pcsz, ...)
{
    va_list    argp;
    char szBuf[1024];

    if ((NULL == pcsz) || ('\0' == pcsz[0]))
        return;

    va_start(argp, pcsz);

    vsprintf(szBuf, pcsz, argp);

    MyDbgSz((szBuf));
    va_end(argp);
} // Dprintf()

// ############################################################################
//  operator new
//
//  This function allocate memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void * MyBaseClass::operator new( size_t cb )
{
    return MyAlloc(cb);
}

// ############################################################################
//  operator delete
//
//  This function frees memory for C++ classes
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
void MyBaseClass::operator delete( void * p )
{
    MyFree( p );
}

void CDownLoad::AddToFileList(CFileInfo* pfi)
{
    CFileInfo **ppfi;

    // must add at tail
    for(ppfi=&m_pfiHead; *ppfi; ppfi = &((*ppfi)->m_pfiNext))
        ;
    *ppfi = pfi;
}


CDownLoad::CDownLoad(LPTSTR psz)
{
    TCHAR           szUserAgent[128];
    OSVERSIONINFO   osVer;
    LPTSTR          pszOS = TEXT("");

    memset(this, 0, sizeof(CDownLoad));

    if(psz)
        m_pszURL = MyStrDup(psz);

    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    GetVersionEx(&osVer);

    switch(osVer.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            pszOS = TEXT("Windows95");
            break;
        case VER_PLATFORM_WIN32_NT:
            pszOS = TEXT("WindowsNT");
    }


    wsprintf(szUserAgent, USERAGENT_FMT, pszOS, osVer.dwMajorVersion,
                osVer.dwMinorVersion, GetSystemDefaultLangID());

    m_hSession = InternetOpen(szUserAgent, 0, NULL, NULL, 0);

    TCHAR szBuf[MAX_PATH+1];

    GetWindowsDirectory(szBuf, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    m_pszWindowsDir = MyStrDup(szBuf);
    m_dwWindowsDirLen = lstrlen(m_pszWindowsDir);

    GetSystemDirectory(szBuf, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    m_pszSystemDir = MyStrDup(szBuf);
    m_dwSystemDirLen = lstrlen(m_pszSystemDir);

    MyGetTempPath(MAX_PATH, szBuf);
    szBuf[MAX_PATH] = 0;
    m_pszTempDir = MyStrDup(szBuf);
    m_dwTempDirLen = lstrlen(m_pszTempDir);
    if(m_pszTempDir[m_dwTempDirLen-1]=='\\')
    {
        m_pszTempDir[m_dwTempDirLen-1]=0;
        m_dwTempDirLen--;
    }

    // form the ICW98 dir.  It is basically the CWD
    m_pszICW98Dir = MyAlloc(MAX_PATH +1);
    GetCurrentDirectory(MAX_PATH, m_pszICW98Dir);
    m_dwICW98DirLen = lstrlen(m_pszICW98Dir);

    LPTSTR pszCmdLine = GetCommandLine();
    LPTSTR pszTemp = NULL, pszTemp2 = NULL;

    _tcsncpy(szBuf, pszCmdLine, MAX_PATH);
    szBuf[MAX_PATH] = 0;
    pszTemp = _tcstok(szBuf, TEXT(" \t\r\n"));
    if (NULL != pszTemp)
    {
        pszTemp2 = _tcschr(pszTemp, TEXT('\\'));
        if(!pszTemp2)
            pszTemp2 = _tcsrchr(pszTemp, TEXT('/'));
    }
    if(pszTemp2)
    {
        *pszTemp2 = 0;
        m_pszSignupDir = MyStrDup(pszTemp);
    }
    else
    {
        MyAssert(FALSE);
        GetCurrentDirectory(MAX_PATH, szBuf);
        szBuf[MAX_PATH] = 0;
        m_pszSignupDir = MyStrDup(szBuf);
    }
    m_dwSignupDirLen = lstrlen(m_pszSignupDir);
}

CDownLoad::~CDownLoad(void)
{
    MyDprintf("ICWDL: CDownLoad::~CDownLoad called\n", this);

    CFileInfo *pfi, *pfiNext;
    for(pfi=m_pfiHead; pfi; pfi=pfiNext)
    {
        pfiNext = pfi->m_pfiNext;
        delete pfi;
    }

    if(m_pszWindowsDir)
        MyFree(m_pszWindowsDir);
    if(m_pszSystemDir)
        MyFree(m_pszSystemDir);
    if(m_pszTempDir)
        MyFree(m_pszTempDir);
    if(m_pszICW98Dir)
        MyFree(m_pszICW98Dir);
    if(m_pszSignupDir)
        MyFree(m_pszSignupDir);
    if(m_pszURL)
        MyFree(m_pszURL);
    if(m_pszBoundary)
        MyFree(m_pszBoundary);
    if(m_hSession)
        InternetSessionCloseHandle(m_hSession);
    MyAssert(!m_hRequest);

    //
    // 5/23/97 jmazner Olympus #4652
    // Make sure that any waiting threads are freed up.
    //
    if( m_hCancelSemaphore )
    {
        ReleaseSemaphore( m_hCancelSemaphore, 1, NULL );

        CloseHandle( m_hCancelSemaphore );
        m_hCancelSemaphore = NULL;
    }
}

// perform a file name substitution
LPTSTR CDownLoad::FileToPath(LPTSTR pszFile)
{
    TCHAR szBuf[MAX_PATH+1];

    for(long j=0; *pszFile; pszFile++)
    {
        if(j>=MAX_PATH)
            return NULL;
        if(*pszFile=='%')
        {
            pszFile++;
            LPTSTR pszTemp = _tcschr(pszFile, '%');
            if(!pszTemp)
                return NULL;
            *pszTemp = 0;
            if(lstrcmpi(pszFile, SIGNUP)==0)
            {
                lstrcpy(szBuf+j, m_pszSignupDir);
                j+= m_dwSignupDirLen;
            }
            else if(lstrcmpi(pszFile, WINDOWS)==0)
            {
                lstrcpy(szBuf+j, m_pszWindowsDir);
                j+= m_dwWindowsDirLen;
            }
            else if(lstrcmpi(pszFile, SYSTEM)==0)
            {
                lstrcpy(szBuf+j, m_pszSystemDir);
                j+= m_dwSystemDirLen;
            }
            else if(lstrcmpi(pszFile, TEMP)==0)
            {
                lstrcpy(szBuf+j, m_pszTempDir);
                j+= m_dwTempDirLen;
            }
            else if(lstrcmpi(pszFile, ICW98DIR)==0)
            {
                lstrcpy(szBuf+j, m_pszICW98Dir);
                j+= m_dwICW98DirLen;
            }
            else
                return NULL;
            pszFile=pszTemp;
        }
        else
            szBuf[j++] = *pszFile;
    }
    szBuf[j] = 0;
    return MyStrDup(szBuf);
}

// Chops input up into CRLF-delimited chunks
// Modifies input
LPSTR GetNextLine(LPSTR pszIn)
{
    LPSTR pszNext;
    while(*pszIn)
    {
        pszNext = strchr(pszIn, '\r');

        if(!pszNext)
            return NULL;
        else if(pszNext[1]=='\n')
        {
            pszNext[0] = pszNext[1] = 0;
            return pszNext+2;
        }
        else
            pszIn = pszNext+1;
    }
    return NULL;
}

// Modifies input. Output is *in-place*
LPSTR FindHeaderParam(LPSTR pszIn, LPSTR pszLook)
{
    LPSTR pszEnd = pszIn + lstrlenA(pszIn);
    BOOL fFound = FALSE;
    LPSTR pszToken = NULL;

    while(pszIn<pszEnd)
    {
        pszToken=strtok(pszIn, " \t;=");
        if(fFound || !pszToken)
            break;

        pszIn = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, pszLook)==0)
            fFound = TRUE;
    }
    if(fFound && pszToken)
    {
        if(pszToken[0]=='"')
            pszToken++;
        int iLen = lstrlenA(pszToken);
        if(pszToken[iLen-1]=='"')
            pszToken[iLen-1]=0;
        return pszToken;
    }
    return NULL;
}

// Modifies input!!
LPSTR ParseHeaders(LPSTR pszIn, LPTSTR* ppszBoundary, LPTSTR* ppszFilename, BOOL* pfInline)
{
    LPSTR pszNext=NULL, pszCurr=NULL, pszToken=NULL, pszToken2=NULL, pszTemp=NULL;
    // int iLen;    ChrisK

    if(pfInline)     *pfInline = FALSE;
    if(ppszFilename) *ppszFilename = NULL;
    if(ppszBoundary) *ppszBoundary = NULL;

    for(pszCurr=pszIn; pszCurr; pszCurr=pszNext)
    {
        // terminate current line with null & get ptr to next
        pszNext = GetNextLine(pszCurr);

        // if we have a blank line, done with headers--exit loop
        if(*pszCurr==0)
        {
            pszCurr = pszNext;
            break;
        }

        if(!(pszToken = strtok(pszCurr, " \t:;")))
            continue;
        pszCurr = pszToken+lstrlenA(pszToken)+1;

        if(lstrcmpiA(pszToken, MULTIPART_MIXED)==0)
        {
            if(ppszBoundary)
            {
                pszTemp = FindHeaderParam(pszCurr, BOUNDARY);
                if(pszTemp)
                {
                    int iLen = lstrlenA(pszTemp);
                    *ppszBoundary = (LPTSTR)MyAlloc(iLen+2+1);
                    (*ppszBoundary)[0] = (*ppszBoundary)[1] = '-';
#ifdef UNICODE
                    mbstowcs(*ppszBoundary+2, pszTemp, lstrlenA(pszTemp)+1);
#else
                    lstrcpyA(*ppszBoundary+2, pszTemp);
#endif
                }
            }
        }
        else if(lstrcmpiA(pszToken, CONTENT_DISPOSITION)==0)
        {
            if(!(pszToken2 = strtok(pszCurr, " \t:;")))
                continue;
            pszCurr = pszToken2+lstrlenA(pszToken2)+1;

            if(lstrcmpiA(pszToken2, INLINE)==0)
            {
                if(pfInline)
                    *pfInline = TRUE;
            }
            else if(lstrcmpiA(pszToken2, ATTACHMENT)!=0)
                continue;

            if(ppszFilename)
            {
                pszTemp = FindHeaderParam(pszCurr, FILENAME);
                if(pszTemp)
                    *ppszFilename = MyStrDup(pszTemp);
            }
        }
    }
    return pszCurr;
}

BOOL g_ForceOnlineAttempted = FALSE;

HRESULT CDownLoad::Execute(void)
{
    TCHAR    szBuf[256];
    DWORD    dwLen;
    HRESULT hr = ERROR_GEN_FAILURE;

    if(!m_hSession || !m_pszURL)
        return ERROR_INVALID_PARAMETER;

    m_hRequest = InternetOpenUrl(m_hSession, m_pszURL, NULL, 0,
                (INTERNET_FLAG_RELOAD|INTERNET_FLAG_DONT_CACHE), (DWORD_PTR)this);

    if(!m_hRequest)
    {
        if (!m_hSession)
            return GetLastError();
        else
        {
            HRESULT hRes = InternetGetLastError(m_hSession);

            if (hRes == INTERNET_STATE_DISCONNECTED)
            {
                DWORD dwConnectedFlags = 0;

                InternetGetConnectedStateEx(&dwConnectedFlags,
                                             NULL,
                                             0,
                                             0);

                if(dwConnectedFlags & INTERNET_CONNECTION_OFFLINE)
                {
                    if(g_ForceOnlineAttempted)
                    {
                        g_ForceOnlineAttempted = FALSE;
                        hRes = INTERNET_CONNECTION_OFFLINE;
                    }
                    else
                    {
                        //ack! the user is offline. not good. let's put them back online.
                        INTERNET_CONNECTED_INFO ci;

                        memset(&ci, 0, sizeof(ci));
                        ci.dwConnectedState = INTERNET_STATE_CONNECTED;

                        InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

                        g_ForceOnlineAttempted = TRUE;

                        //now that we've reset the state let's recurse the call.
                        //if we fail again, then we'll tell the user they need
                        //to disable the Offline themseleve
                        return Execute();
                    }
                }

            }
            return hRes;
        }
    }

    dwLen = sizeof(szBuf);
    if(HttpQueryInfo(m_hRequest, HTTP_QUERY_CONTENT_LENGTH, szBuf, &dwLen, NULL))
    {
        m_dwContentLength = _ttol(szBuf);
    }
    else
    {
        m_dwContentLength = 0;
    }


    dwLen = sizeof(szBuf);
    if(HttpQueryInfo(m_hRequest, HTTP_QUERY_CONTENT_TYPE, szBuf, &dwLen, NULL))
    {
#ifdef UNICODE
        CHAR szTmp[256];
        wcstombs(szTmp, szBuf, lstrlen(szBuf)+1);
        ParseHeaders(szTmp, &m_pszBoundary, NULL, NULL);
#else
        ParseHeaders(szBuf, &m_pszBoundary, NULL, NULL);
#endif
        if(m_pszBoundary)
            m_dwBoundaryLen = lstrlen(m_pszBoundary);
        else
            goto ExecuteExit; // Chrisk, you have to clean up before exiting

        hr = ProcessRequest();
    }

ExecuteExit:
    if (m_hRequest)
        InternetRequestCloseHandle(m_hRequest);
    m_hRequest = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    ShowProgress
//
//    Synopsis:    update running total & call progress callback
//
//    Arguments:    dwRead - additional number of bytes read
//
//    Returns:    none
//
//    History:            ArulM    Created
//                8/896    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
void CDownLoad::ShowProgress(DWORD dwRead)
{
    int    prc;

    m_dwReadLength += dwRead;    // running total bytes read
    MyAssert(m_dwReadLength <= m_dwContentLength);

    if (m_lpfnCB)
    {
        if (m_dwContentLength)
        {
            prc = (int)((DWORD)100 * m_dwReadLength / m_dwContentLength);
        }
        else
        {
            prc = 0;
        }
        //
        // 5/27/97 jmazner Olympus #4579
        // need to pass in a valid pointer to a CDialingDlg!
        //
        (m_lpfnCB)(m_hRequest,m_lpCDialingDlg,CALLBACK_TYPE_PROGRESS,(LPVOID)&prc,sizeof(prc));
    }
}

//+----------------------------------------------------------------------------
//
//    Function:    FillBuffer
//
//    Synopsis:    takes a buffer that is partially-filled and reads until it is
//                full or until we've reached the end.
//
//    Arguments:    Buffer pointer, buffer size, count of valid data bytes
//
//    Returns:    total number of bytes in buf
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead)
{
    DWORD dwTemp;

    while(dwRead < dwLen)
    {
        dwTemp = 0;
        if(!InternetReadFile(m_hRequest, pbBuf+dwRead, (dwLen-dwRead), &dwTemp))
            break;
        if(!dwTemp)
            break;

        ShowProgress(dwTemp);
        dwRead += dwTemp;
    }
    if(dwLen-dwRead)
        memset(pbBuf+dwRead, 0, (size_t)(dwLen-dwRead));
    return dwRead;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveAndFillBuffer
//
//    Synopsis:    move remaining contents of buffer from middle of buffer back to
//                the beginning & refill buffer.
//
//    Arguements:    Buffer pointer, Buffer size, count of *total* valid data bytes
//                Pointer to start of data to be moved (everything before is nuked)
//
//    Returns:    total number of bytes in buffer
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
DWORD CDownLoad::MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart)
{
    MyAssert(pbNewStart >= pbBuf);
    MyAssert(pbBuf+dwValid >= pbNewStart);

    dwValid -= (DWORD)(pbNewStart-pbBuf);
    if(dwValid)
        memmove(pbBuf, pbNewStart, (size_t)dwValid);

    return FillBuffer(pbBuf, dwLen, dwValid);
}


//+----------------------------------------------------------------------------
//
//    Function:    HandlwDLFile
//
//    Synopsis:    Handle filename:
//                    (1) get full path after macro substituition. (2) Free
//                    pszFile string.
//                    (3) save the file path & inline/attach info internally for
//                    later handling
//                    (4) Create file on disk & return HANDLE
//
//    Aruguments:    pszFile - filename
//                fInLine - value of inline/attached header from the MIME mutli-part
//
//    Returns:    phFile - handle of file created
//                return - ERROR_SUCCESS == success
//
//    History:            ArulM    Created
//                8/8/96    ChrisK    Ported from \\TRANGO
//
//-----------------------------------------------------------------------------
HRESULT CDownLoad::HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHANDLE phFile)
{
    TCHAR szdrive[_MAX_DRIVE];
    TCHAR szPathName[_MAX_PATH];     // This will be the dir we need to create
    TCHAR szdir[_MAX_DIR];
    TCHAR szfname[_MAX_FNAME];
    TCHAR szext[_MAX_EXT];

    MyAssert(phFile);
    *phFile = INVALID_HANDLE_VALUE;

    LPTSTR pszPath = FileToPath(pszFile);
    MyFree(pszFile);

    if(!pszPath)
        return ERROR_INVALID_DATA;


    // Split the provided path to get at the drive and path portion
    _tsplitpath( pszPath, szdrive, szdir, szfname, szext );
    wsprintf (szPathName, TEXT("%s%s"), szdrive, szdir);

    // Create the Directory
    CreateDirectory(szPathName, NULL);

    // create the file
    *phFile = CreateFile(pszPath,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if(*phFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    CFileInfo* pfi = new CFileInfo(pszPath, fInline);
    if(!pfi)
        return GetLastError();
    AddToFileList(pfi);

    return ERROR_SUCCESS;
}


/*******************************************************************
*
*  NAME:    LoadSz
*
*  SYNOPSIS:  Loads specified string resource into buffer
*
*  EXIT:    returns a pointer to the passed-in buffer
*
*  NOTES:    If this function fails (most likely due to low
*        memory), the returned buffer will have a leading NULL
*        so it is generally safe to use this without checking for
*        failure.
*
********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( g_hInst, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

HRESULT CDownLoad::ProcessRequest(void)
{
    LPBYTE  pbData = NULL, pBoundary = NULL;
    DWORD   dwLen = 0;
    HFIND   hFindBoundary = NULL;
    LPTSTR   pszDLFileName = NULL;
    HANDLE  hOutFile = INVALID_HANDLE_VALUE;
    HRESULT hr = E_FAIL;

    MyAssert(m_hRequest && m_pszBoundary);
    MyAssert(m_pszBoundary[0]=='\r' && m_pszBoundary[1]=='\n');
    MyAssert(m_pszBoundary[2]=='-' && m_pszBoundary[3]=='-');
    // Buf Size must be greater than larget possible block of headers
    // also must be greater than the OVERLAP, which must be greater
    // than max size of MIME part boundary (70?)
    MyAssert(DEFAULT_DATABUF_SIZE > OVERLAP_LEN);
    MyAssert(OVERLAP_LEN > 80);

    // init buffer & find-pattern
    if(! (pbData = (LPBYTE)MyAlloc(DEFAULT_DATABUF_SIZE+SLOP)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    hFindBoundary = SetFindPattern(m_pszBoundary);

    // find first boundary. If not in first blob, we have too much
    // white-space. Discard & try again (everything before the first
    // boundary is discardable)
    for(pBoundary=NULL; !pBoundary; )
    {
        if(!(dwLen = FillBuffer(pbData, DEFAULT_DATABUF_SIZE, 0)))
            goto iNetError;
        pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen);
    }

    for(;;)
    {
        MyAssert(pBoundary && pbData && dwLen);
        MyAssert(pBoundary>=pbData && (pBoundary+m_dwBoundaryLen)<=(pbData+dwLen));

        // move remaining data to front of buffer & refill.
        if(!(dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pBoundary+m_dwBoundaryLen)))
            goto iNetError;
        pBoundary = NULL;

        // look for trailing -- after boundary to indicate end of last part
        if(pbData[0]=='-' && pbData[1]=='-')
            break;

        // skip leading CRLF (alway one after boundary)
        MyAssert(pbData[0]=='\r' && pbData[1]=='\n');

        // reads headers and skips everything until doubleCRLF. assumes all
        // headers fit in the single buffer. Pass in pbData+2 to skip
        // leading CRLF. Return value is ptr to first byte past the dbl crlf
        LPTSTR pszFile = NULL;
        BOOL fInline = FALSE;

        LPBYTE pbNext = (LPBYTE)ParseHeaders((LPSTR)pbData+2, NULL, &pszFile, &fInline);

         if(!pszFile || !pbNext)
         {
             hr = ERROR_INVALID_DATA;
             goto error;
         }

        //
        // Make a copy of the file name - will be used
        // for displaying error message
        //
        pszDLFileName = (LPTSTR) MyAlloc(lstrlen(pszFile) + 1);
        lstrcpy(pszDLFileName, pszFile);


        // Handle filename: (1) get full path after macro substituition.
        // (2) Free pszFile string. (3) save the file path & inline/attach info
        // internally for later handling (4) Create file on disk &return HANDLE
        if(hr = HandleDLFile(pszFile, fInline, &hOutFile))
            goto error;

        // move remaining data (after headers) to front of buffer & refill.
        dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbNext);
        pBoundary = NULL;

        MyAssert(dwLen);
        while(dwLen)
        {
            DWORD dwWriteLen = 0;
            DWORD dwTemp = 0;

            // look for boundary. careful of boundary cut across
            // blocks. Overlapping blocks by 100 bytes to cover this case.
            if(pBoundary = (LPBYTE)Find(hFindBoundary, (LPSTR)pbData, dwLen))
                dwWriteLen = (DWORD)(pBoundary - pbData);
            else if(dwLen > OVERLAP_LEN)
                dwWriteLen = dwLen-OVERLAP_LEN;
            else
                dwWriteLen = dwLen;

            MyAssert(dwWriteLen <= dwLen);
            MyAssert(hOutFile != INVALID_HANDLE_VALUE);

            if(dwWriteLen)
            {
                dwTemp = 0;
                if(!WriteFile(hOutFile, pbData, dwWriteLen, &dwTemp, NULL)
                    || dwTemp!=dwWriteLen)
                {
                    hr = GetLastError();
                    //
                    // If we are out of diskspace, get the drive letter
                    // and display an out of diskspace message
                    //
                    goto error;
                }

            }

            if(pBoundary)
                break;

            // move remaining data (after last byte written) to front of buffer & refill
            dwLen = MoveAndFillBuffer(pbData, DEFAULT_DATABUF_SIZE, dwLen, pbData+dwWriteLen);
        }

        // *truncate* file & close
        MyAssert(hOutFile != INVALID_HANDLE_VALUE);
        SetEndOfFile(hOutFile);

        // close file
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
        if (NULL != pszDLFileName)
        {
            MyFree(pszDLFileName);
            pszDLFileName = NULL;
        }

        if(!pBoundary)
        {
            MyAssert(dwLen==0); // can only get here on dwLen==0 or found boundary
            goto iNetError;
        }
        // at start of loop we'll discard everything upto and including the boundary
        // if we loop back with pBoundary==NULL, we'll GPF
    }
    return ERROR_SUCCESS;

iNetError:
    hr = InternetGetLastError(m_hSession);
    if(!hr)
        hr = ERROR_INVALID_DATA;
    // goto error;
    // fall through

error:
    if(pbData) MyFree(pbData);
    if(hFindBoundary) FreeFindPattern(hFindBoundary);
    if (NULL != pszDLFileName)
    {
        MyFree(pszDLFileName);
        pszDLFileName = NULL;
    }
    if (hOutFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hOutFile);
        hOutFile = INVALID_HANDLE_VALUE;
    }
    return hr;
}


HRESULT HandleExe(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    MyAssert( hCancelSemaphore );

    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    if(!CreateProcess(pszPath, NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleExe about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleExe done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

HRESULT HandleReg(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in a directory or file name includes a space.

    lstrcpy(szCmd, REGEDIT_CMD);

    if( '\"' != pszPath[0] )
    {
        // add 2 for two quotes
        MyAssert( (lstrlen(REGEDIT_CMD) + lstrlen(pszPath)) < MAX_PATH );

        lstrcat(szCmd, TEXT("\""));
        lstrcat(szCmd, pszPath);

        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        MyAssert( (lstrlen(REGEDIT_CMD) + lstrlen(pszPath)) < MAX_PATH );

        lstrcat(szCmd, pszPath);
    }



    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    if(!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        // HRESULT hr = (WaitAndKillRegeditWindow(10) ? NO_ERROR : E_FAIL);
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleReg about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleReg done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return ERROR_SUCCESS;
    }
}


HRESULT HandleInf(LPTSTR pszPath, HANDLE hCancelSemaphore)
{
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );
    MyAssert( hCancelSemaphore );

    // add 2 for two quotes,
    // subtract 70 for approximate length of string in sprintf
    MyAssert( (lstrlen(pszPath) - 70 + 2) < MAX_PATH );

    // 11/20/96 jmazner Normandy #5272
    // wrap pszPath in quotes in case it includes a space
    if( '\"' != pszPath[0] )
    {
        wsprintf(szCmd, TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 128 \"%s"), pszPath);
        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        wsprintf(szCmd, TEXT("rundll setupx.dll,InstallHinfSection DefaultInstall 128 %s"), pszPath);
    }


    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    memset(&pi, 0, sizeof(pi));
    memset(&si, 0, sizeof(si));

    si.cb = sizeof(STARTUPINFO);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;
    if(!CreateProcess(NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        return GetLastError();
    else
    {
        HANDLE lpHandles[2] = {hCancelSemaphore, pi.hProcess};
        DWORD dwRet = 0xDEAF;
        MyDprintf("ICWDL: HandleInf about to wait....\n");

        //
        // 5/23/97 jmazner Olympus #4652
        // sit here and wait until either
        // 1) the process we launched terminates, or
        // 2) the user tells us to cancel
        //
        dwRet = WaitForMultipleObjects( 2, lpHandles, FALSE, INFINITE );

        MyDprintf("ICWDL: ....HandleInf done waiting -- %s was signalled\n",
            (0==(dwRet - WAIT_OBJECT_0))?"hCancelSemaphore":"pi.hProcess");

        // should we try to kill the process here??
         CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
        return NO_ERROR;
    }
}

#define STR_BSTR    0
#define STR_OLESTR  1
#ifdef UNICODE
#define BSTRFROMANSI(x) (BSTR)(x)
#define OLESTRFROMANSI(x) (LPCOLESTR)(x)
#else
#define BSTRFROMANSI(x) (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x) (LPCOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#endif
#define TO_ASCII(x) (TCHAR)((unsigned char)x + 0x30)

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPTSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi (LPSTR psz, BYTE bType)
{
    int i;
    LPWSTR pwsz;

    if (!psz)
        return(NULL);

    if ((i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0)) <= 0)    // compute the length of the required BSTR
        return NULL;

    switch (bType) {                                                    // allocate the widestr, +1 for null
        case STR_BSTR:
            pwsz = (LPWSTR)SysAllocStringLen(NULL, (i - 1));            // SysAllocStringLen adds 1
            break;
        case STR_OLESTR:
            pwsz = (LPWSTR)CoTaskMemAlloc(i * sizeof(WCHAR));
            break;
        default:
            return(NULL);
    }

    if (!pwsz)
        return(NULL);

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;

    return(pwsz);

}   /*  MakeWideStrFromAnsi() */

// Get the URL location from the .URL file, and send it to the progress dude
HRESULT CDownLoad::HandleURL(LPTSTR pszPath)
{
    MyAssert( pszPath );

    LPTSTR   pszURL;

    // Create a IUniformResourceLocator object
    IUniformResourceLocator * pURL;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IUniformResourceLocator,
                                   (LPVOID*)&pURL)))
    {
        // Get a persist file interface
        IPersistFile *ppf;
        if (SUCCEEDED(pURL->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf)))
        {
            // Attempt to connect the storage of the IURL to the .URL file we
            // downloaded
            if (SUCCEEDED(ppf->Load(OLESTRFROMANSI(pszPath), STGM_READ)))
            {
                // OK, have the URL object give us the location
                if (SUCCEEDED(pURL->GetURL(&pszURL)) && pszURL)
                {
                    // Notify the callback about the URL location
                    (m_lpfnCB)(m_hRequest,m_lpCDialingDlg, CALLBACK_TYPE_URL, (LPVOID)pszURL, lstrlen(pszURL));

                    // Free the allocated URL, since the callback made a copy of it
                    IMalloc* pMalloc;
                    HRESULT hres = SHGetMalloc(&pMalloc);
                    if (SUCCEEDED(hres))
                    {
                        pMalloc->Free(pszURL);
                        pMalloc->Release();
                    }
                }
            }
            // Release the persist file interface
            ppf->Release();
        }
        // release the URL object
        pURL->Release();
    }
    return(NO_ERROR);
}

#define PHONEBOOK_LIBRARY TEXT("ICWPHBK.DLL")
#define PHBK_LOADAPI "PhoneBookLoad"
#define PHBK_MERGEAPI "PhoneBookMergeChanges"
#define PHBK_UNLOADAPI "PhoneBookUnload"
#define PHONEBOOK_SUFFIX TEXT(".PHB")

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD *pdwPhoneID);
typedef HRESULT (CALLBACK* PFNPHONEBOOKMERGE)(DWORD dwPhoneID, LPTSTR pszFileName);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD dwPhoneID);

HRESULT HandleChg(LPTSTR pszPath)
{
    TCHAR szPhoneBookPath[MAX_PATH+1];
    TCHAR *p;
    LPTSTR szFilePart;
    HRESULT hr = ERROR_FILE_NOT_FOUND;
    HINSTANCE hPHBKDLL = NULL;
    FARPROC fp;
    DWORD dwPhoneBook;

    lstrcpy(szPhoneBookPath,pszPath);
    if (lstrlen(szPhoneBookPath) > 4)
    {
        p = &(szPhoneBookPath[lstrlen(szPhoneBookPath)-4]);
    } else {
        hr = ERROR_INVALID_PARAMETER;
        goto HandleChgExit;
    }

    lstrcpy(p,PHONEBOOK_SUFFIX);

    while (*p != '\\' && p > &szPhoneBookPath[0])
        p--;

    p++;
    if(!SearchPath(NULL,p,NULL,MAX_PATH,szPhoneBookPath,&szFilePart))
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hPHBKDLL = LoadLibrary(PHONEBOOK_LIBRARY);
    if (!hPHBKDLL)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    fp = GetProcAddress(hPHBKDLL,PHBK_LOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKLOAD)fp)(pszPath,&dwPhoneBook);
    if(hr != ERROR_SUCCESS)
        goto HandleChgExit;

    fp = GetProcAddress(hPHBKDLL,PHBK_MERGEAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    hr = ((PFNPHONEBOOKMERGE)fp)(dwPhoneBook,pszPath);

    fp = GetProcAddress(hPHBKDLL,PHBK_UNLOADAPI);
    if (!fp)
    {
        hr = GetLastError();
        goto HandleChgExit;
    }

    ((PFNPHONEBOOKUNLOAD)fp)(dwPhoneBook);

HandleChgExit:
    return hr;
}


HRESULT HandleOthers(LPTSTR pszPath)
{
    DWORD_PTR dwErr;
    TCHAR szCmd[MAX_PATH + 1];

    MyAssert( pszPath );

    // 11/20/96  jmazner  Normandy #5272
    // Wrap quotes around pszPath in case it includes a space.

    // add 2 for two quotes
    MyAssert( (lstrlen(pszPath) + 2) < MAX_PATH );

    if( '\"' != pszPath[0] )
    {
        lstrcpy(szCmd,TEXT("\""));
        lstrcat(szCmd, pszPath);

        int i = lstrlen(szCmd);
        szCmd[i] = '\"';
        szCmd[i+1] = '\0';
    }
    else
    {
        lstrcpyn(szCmd, pszPath, lstrlen(pszPath));
    }


    if((dwErr=(DWORD_PTR)ShellExecute(NULL, NULL, szCmd, NULL, NULL, SW_SHOWNORMAL)) < 32)
        return (DWORD)dwErr;
    else
        return ERROR_SUCCESS;
}



LPTSTR GetExtension(LPTSTR pszPath)
{
    LPTSTR pszRet = _tcsrchr(pszPath, '.');
    if(pszRet)
        return pszRet+1;
    else
        return NULL;
}

// Normandy 12093 - ChrisK 12/3/96
// return the error code for the first error that occurs while processing a file,
// but don't stop processing files.
//
HRESULT CDownLoad::Process(void)
{
    HRESULT     hr;
    HRESULT     hrProcess = ERROR_SUCCESS;
    LPTSTR       pszExt;
    CFileInfo   *pfi;

    for(pfi=m_pfiHead; pfi; pfi=pfi->m_pfiNext)
    {
        // Normandy 12093 - ChrisK 12/3/96
        hr = ERROR_SUCCESS;
        if(pfi->m_fInline)
        {
            pszExt = GetExtension(pfi->m_pszPath);
            if(!pszExt)
                continue;

        	if (lstrcmpi(pszExt, EXT_CAB)==0)
				hr = HandleCab(pfi->m_pszPath);
            else if(lstrcmpi(pszExt, EXT_EXE)==0)
                hr = HandleExe(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_REG)==0)
                hr = HandleReg(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_CHG)==0)
                hr = HandleChg(pfi->m_pszPath);
            else if(lstrcmpi(pszExt, EXT_INF)==0)
                hr = HandleInf(pfi->m_pszPath, m_hCancelSemaphore);
            else if(lstrcmpi(pszExt, EXT_URL)==0)
                hr = HandleURL(pfi->m_pszPath);
            else
                hr = HandleOthers(pfi->m_pszPath);

            // Normandy 12093 - ChrisK 12/3/96
            if ((ERROR_SUCCESS == hrProcess) && (ERROR_SUCCESS != hr))
                hrProcess = hr;
        }
    }

    // Normandy 12093 - ChrisK 12/3/96
    return hrProcess;
}


HRESULT CDownLoad::SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB)
{
    HRESULT hr;

    hr = ERROR_SUCCESS;
    if (!lpfnCB)
    {
        hr = ERROR_INVALID_PARAMETER;
    } else {
        m_lpfnCB = lpfnCB;
    }
    return hr;
}




#ifdef DEBUG
extern "C" HRESULT WINAPI DLTest(LPTSTR pszURL)
{
    CDownLoad* pdl = new CDownLoad(pszURL);
    HRESULT hr = pdl->Execute();
    if(hr) goto done;

    hr = pdl->Process();
done:
    delete pdl;
    return hr;
}
#endif //DEBUG


HRESULT WINAPI DownLoadInit(LPTSTR pszURL, DWORD_PTR FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hWndMain)
{
    g_hWndMain = hWndMain;

    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CDownLoad* pdl = new CDownLoad(pszURL);
    if (!pdl) goto DownLoadInitExit;

    *pdwDownLoad = (DWORD_PTR)pdl;

    //
    // 5/27/97    jmazner Olympus #4579
    //
    pdl->m_lpCDialingDlg = (DWORD_PTR)lpCDialingDlg;

    hr = ERROR_SUCCESS;

    //
    // 5/23/97    jmazner    Olympus #4652
    // create a semaphore in non-signaled state.  If we ever get a downLoadCancel, we
    // should signal the semaphore, and any waiting threads should notice that and bail out.
    //
    pdl->m_hCancelSemaphore = CreateSemaphore( NULL, 0, 1, TEXT("ICWDL DownloadCancel Semaphore") );
    if( !pdl->m_hCancelSemaphore || (ERROR_ALREADY_EXISTS == GetLastError()) )
    {
        MyDprintf("ICWDL: Unable to create CancelSemaphore!!\n");
        hr = ERROR_ALREADY_EXISTS;
    }

DownLoadInitExit:
    return hr;
}

HRESULT WINAPI DownLoadCancel(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadCancel called\n");
    if (dwDownLoad)
    {

        MyDprintf("ICWDL: DownLoadCancel releasing m_hCancelSemaphore\n");
        MyAssert( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore );
        ReleaseSemaphore( ((CDownLoad*)dwDownLoad)->m_hCancelSemaphore, 1, NULL );

        ((CDownLoad*)dwDownLoad)->Cancel();
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadExecute(DWORD_PTR dwDownLoad)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->Execute();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}
HRESULT WINAPI DownLoadClose(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadClose called \n");

    if (dwDownLoad)
    {
        // be good and cancel any downloads that are in progress
        ((CDownLoad*)dwDownLoad)->Cancel();

        delete ((CDownLoad*)dwDownLoad);
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}




HRESULT WINAPI DownLoadSetStatusCallback
(
    DWORD_PTR dwDownLoad,
    INTERNET_STATUS_CALLBACK lpfnCB
)
{
    if (dwDownLoad)
    {
        return     ((CDownLoad*)dwDownLoad)->SetStatusCallback(lpfnCB);
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }
}

HRESULT WINAPI DownLoadProcess(DWORD_PTR dwDownLoad)
{
    MyDprintf("ICWDL: DownLoadProcess\n");
    if (dwDownLoad)
    {
        return ((CDownLoad*)dwDownLoad)->Process();
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\download.h ===
/*----------------------------------------------------------------------------
    download.h
        
        Download handling for Signup

    Copyright (C) 1995 Microsoft Corporation
    All rights reserved.

    Authors:
        ArulM
  --------------------------------------------------------------------------*/
  
class MyBaseClass
{
public:
    void * operator new( size_t cb );
    void operator delete( void * p );
};

#include     <wininet.h>

#define InternetSessionCloseHandle(h)        InternetCloseHandle(h)            
#define InternetRequestCloseHandle(h)        InternetCloseHandle(h)
#define InternetGetLastError(h)                GetLastError()
#define InternetCancel(h)                    InternetCloseHandle(h)

extern HANDLE       g_hDLLHeap;        // private Win32 heap
extern HINSTANCE    g_hInst;        // our DLL hInstance

class CFileInfo : public MyBaseClass
{
public:
    CFileInfo*    m_pfiNext;
    LPTSTR        m_pszPath;
    BOOL          m_fInline;
    
    CFileInfo(LPTSTR psz, BOOL f) { m_pfiNext = NULL; m_pszPath = psz; m_fInline = f; }
    ~CFileInfo() { if(m_pszPath) MyFree(m_pszPath); }
};

class CDownLoad : public MyBaseClass
{
    CFileInfo*    m_pfiHead;
    LPTSTR        m_pszURL;
    HINTERNET    m_hSession;
    HINTERNET    m_hRequest;
    DWORD        m_dwContentLength;
    DWORD        m_dwReadLength;
    LPTSTR       m_pszBoundary;
    DWORD        m_dwBoundaryLen;
    LPTSTR       m_pszWindowsDir;
    LPTSTR       m_pszSystemDir;
    LPTSTR       m_pszTempDir;
    LPTSTR       m_pszICW98Dir;
    LPTSTR       m_pszSignupDir;
    DWORD        m_dwWindowsDirLen;
    DWORD        m_dwSystemDirLen;
    DWORD        m_dwTempDirLen;
    DWORD        m_dwSignupDirLen;
    DWORD        m_dwICW98DirLen;
    INTERNET_STATUS_CALLBACK m_lpfnCB;
    INTERNET_STATUS_CALLBACK m_lpfnPreviousCB;
    
    void AddToFileList(CFileInfo* pfi);
    LPTSTR FileToPath(LPTSTR pszFile);
    HRESULT ProcessRequest(void);
    void ShowProgress(DWORD dwRead);
    DWORD FillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwRead);
    DWORD MoveAndFillBuffer(LPBYTE pbBuf, DWORD dwLen, DWORD dwValid, LPBYTE pbNewStart);
#if defined(WIN16)
    HRESULT HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHFILE phFile);
#else
    HRESULT HandleDLFile(LPTSTR pszFile, BOOL fInline, LPHANDLE phFile);
#endif
    HRESULT HandleURL(LPTSTR pszPath);

public:
    CDownLoad(LPTSTR psz);
    ~CDownLoad(void);
    HRESULT Execute(void);
    HRESULT Process(void);
    HINTERNET GetSession(void) { return m_hRequest; }
    HANDLE        m_hCancelSemaphore;
    DWORD_PTR     m_lpCDialingDlg;
    HRESULT SetStatusCallback (INTERNET_STATUS_CALLBACK lpfnCB);
    void Cancel() { if(m_hRequest) InternetCancel(m_hRequest); }
};

#define USERAGENT_FMT           TEXT("MSSignup/1.1 (%s; %d.%d; Lang=%04x)")
#define SIGNUP                  TEXT("signup")
#define SIGNUP_LEN              (sizeof(SIGNUP)-1)
#define SYSTEM                  TEXT("system")
#define SYSTEM_LEN              (sizeof(SYSTEM)-1)
#define WINDOWS                 TEXT("windows")
#define WINDOWS_LEN             (sizeof(WINDOWS)-1)
#define TEMP                    TEXT("temp")
#define TEMP_LEN                (sizeof(TEMP)-1)
#define ICW98DIR                TEXT("icw98dir")
#define ICW98DIR_LEN            (sizeof(ICW98DIR)-1)

#define MULTIPART_MIXED         "multipart/mixed"
#define MULTIPART_MIXED_LEN     (sizeof(MULTIPART_MIXED)-1)
#define CONTENT_DISPOSITION     "content-disposition"
#define CONTENT_DISPOSITION_LEN (sizeof(CONTENT_DISPOSITION)-1)
#define BOUNDARY                "boundary"
#define BOUNDARY_LEN            (sizeof(BOUNDARY)-1)
#define FILENAME                "filename"
#define FILENAME_LEN            (sizeof(FILENAME)-1)
#define INLINE                  "inline"
#define INLINE_LEN              (sizeof(INLINE)-1)
#define ATTACHMENT              "attachment"
#define ATTACHMENT_LEN          (sizeof(ATTACHMENT)-1)

#define DEFAULT_DATABUF_SIZE    4096
#define SLOP                    5
#define OVERLAP_LEN             100

#define DOUBLE_CRLF             TEXT("\r\n\r\n")
#define DOUBLE_CRLF_LEN         (sizeof(DOUBLE_CRLF)-1)

#define DIALOGBOXCLASS          TEXT("#32770")
#define REGEDIT_CMD             TEXT("regedit /s ")

#define EXT_EXE                 TEXT("exe")
#define EXT_REG                 TEXT("reg")
#define EXT_INF                 TEXT("inf")
#define EXT_CHG                 TEXT("chg")
#define EXT_URL                 TEXT("url")

// ICW Version 2.0 stuff.  Ref Server can send cabbed files now,
// this is the extension for it.  We have a cab File Handler which
// blasts open the cab and decompresses the files.
#define EXT_CAB                 TEXT("cab")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by download.rc
//
#define IDS_DOWNLOAD                    1
#define IDS_APPNAME                     3
#define IDS_TMPVAR                      4
#define IDS_TEMPVAR                     5

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwdl\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwdl

MAJORCOMP=GETCONN
MINORCOMP=ICWDL


TARGETNAME=ICWDL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\icwdl.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwdl.rc         \
    ..\boyer.cpp        \
    ..\download.cpp	    \
    ..\cabhandler.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\wininet.lib       \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\dialerr.cpp ===
// DialErr.cpp : Implementation of CDialErr
#include "stdafx.h"
#include "icwhelp.h"
#include "DialErr.h"

/////////////////////////////////////////////////////////////////////////////
// CDialErr


HRESULT CDialErr::OnDraw(ATL_DRAWINFO& di)
{
	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
	DrawText(di.hdcDraw, _T("ATL 2.0"), -1, &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\debug.cpp ===
//
//
//
#include "stdafx.h"

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "shdocvw"
#define SZ_MODULE           "SHDOCVW"
#define DECLARE_DEBUG
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\cpicwhelp.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxy_RefDialEvents
template <class T>
class CProxy_RefDialEvents : public IConnectionPointImpl<T, &DIID__RefDialEvents, CComDynamicUnkArray>
{
public:
//methods:
//_RefDialEvents : IDispatch
public:
	void Fire_RasDialStatus(WORD wRasEvent)
	{
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                VARIANTARG* pvars = new VARIANTARG[1];
                VariantInit(&pvars[0]);
                pvars[0].vt  = VT_I2;
                pvars[0].iVal= wRasEvent;
                DISPPARAMS disp = { pvars, NULL, 1, 0 };
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
            pp++;
		}
		pT->Unlock();
	}
	void Fire_DownloadProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_DownloadComplete(
		BSTR  bstrURL,
		long  lStatus)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[1].vt = VT_BSTR;
				pvars[1].bstrVal= bstrURL;
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lStatus;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_RasConnectComplete(
		long bSuccess)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= bSuccess;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};


//////////////////////////////////////////////////////////////////////////////
// CProxy_WebGateEvents
template <class T>
class CProxy_WebGateEvents : public IConnectionPointImpl<T, &DIID__WebGateEvents, CComDynamicUnkArray>
{
public:
//methods:
//_WebGateEvents : IDispatch
public:
	void Fire_WebGateDownloadComplete(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

	void Fire_WebGateDownloadProgress(
		long lProgress)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= lProgress;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}

};


//////////////////////////////////////////////////////////////////////////////
// CProxy_INSHandlerEvents
template <class T>
class CProxy_INSHandlerEvents : public IConnectionPointImpl<T, &DIID__INSHandlerEvents, CComDynamicUnkArray>
{
public:
//methods:
//_INSHandlerEvents : IDispatch
public:
	void Fire_RunningCustomExecutable()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	void Fire_KillConnection()
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\dialerr.h ===
// DialErr.h : Declaration of the CDialErr

#ifndef __DIALERR_H_
#define __DIALERR_H_

/////////////////////////////////////////////////////////////////////////////
// CDialErr
class ATL_NO_VTABLE CDialErr :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDialErr,&CLSID_DialErr>,
	public CComControl<CDialErr>,
	public IDispatchImpl<IDialErr, &IID_IDialErr, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CDialErr>,
	public IOleControlImpl<CDialErr>,
	public IOleObjectImpl<CDialErr>,
	public IOleInPlaceActiveObjectImpl<CDialErr>,
	public IViewObjectExImpl<CDialErr>,
	public IOleInPlaceObjectWindowlessImpl<CDialErr>
{
public:
	CDialErr()
	{
 
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DIALERR)

BEGIN_COM_MAP(CDialErr) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDialErr)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDialErr)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CDialErr)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDialErr
public:
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__DIALERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\enumodem.h ===
// jmazner  pinched from inetcfg\rnacall.h class ENUM_MODEM

#ifndef __ENUMODEM_H_
#define __ENUMODEM_H_


class CEnumModem
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  CEnumModem();
  ~CEnumModem();
  DWORD ReInit();
  TCHAR * Next();
  TCHAR * GetDeviceTypeFromName(LPTSTR szDeviceName);
  TCHAR * GetDeviceNameFromType(LPTSTR szDeviceType);
  TCHAR * GetDeviceName(DWORD dwIndex);
  TCHAR * GetDeviceType(DWORD dwIndex);
  BOOL VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType);
  DWORD GetNumDevices() {  this->ReInit(); return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// from inetcfg\export.cpp
// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
  HRESULT hr;
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);


//rnacall.cpp
HRESULT InitModemList(HWND hCB);

#endif      // ENUMODEM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\icwcfg.h ===
// ICWCfg.h : Declaration of the CICWSystemConfig

#ifndef __ICWSYSTEMCONFIG_H_
#define __ICWSYSTEMCONFIG_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CICWSystemConfig
class ATL_NO_VTABLE CICWSystemConfig :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CICWSystemConfig,&CLSID_ICWSystemConfig>,
	public CComControl<CICWSystemConfig>,
	public IDispatchImpl<IICWSystemConfig, &IID_IICWSystemConfig, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CICWSystemConfig>,
	public IOleControlImpl<CICWSystemConfig>,
	public IOleObjectImpl<CICWSystemConfig>,
	public IOleInPlaceActiveObjectImpl<CICWSystemConfig>,
	public IViewObjectExImpl<CICWSystemConfig>,
	public IOleInPlaceObjectWindowlessImpl<CICWSystemConfig>,
    public IObjectSafetyImpl<CICWSystemConfig>
{
public:
	CICWSystemConfig()
	{
    	m_bNeedsReboot = FALSE;
    	m_bNeedsRestart = FALSE;
    	m_bQuitWizard = FALSE;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_ICWSYSTEMCONFIG)

BEGIN_COM_MAP(CICWSystemConfig) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IICWSystemConfig)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CICWSystemConfig)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CICWSystemConfig)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// IICWSystemConfig
public:
	STDMETHOD(VerifyRASIsRunning)(/*[out, retval]*/ BOOL *pbRetVal);
	BOOL m_bNeedsReboot;
	BOOL m_bNeedsRestart;
	BOOL m_bQuitWizard;
	STDMETHOD(get_QuitWizard)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_NeedsReboot)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_NeedsRestart)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(ConfigSystem)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);
	STDMETHOD (CheckPasswordCachingPolicy)(/*[out, retval]*/ BOOL *pbRetVal);

private:
    void InstallScripter(void);

};

#endif //__ICWSYSTEMCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\icwcfg.cpp ===
// ICWCfg.cpp : Implementation of CICWSystemConfig
#include "stdafx.h"
#include "icwhelp.h"
#include "ICWCfg.h"

#include <winnetwk.h>
#include <regstr.h>

/////////////////////////////////////////////////////////////////////////////
// CICWSystemConfig


HRESULT CICWSystemConfig::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN11Installed
//
//    Synopsis    Check if MSDUN 1.1 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.1 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
#define DUN_11_Version (1.1)
BOOL IsMSDUN11Installed()
{
    CHAR    szBuffer[MAX_PATH] = {"\0"};
    HKEY    hkey = NULL;
    BOOL    bRC = FALSE;
    DWORD   dwType = 0;
    DWORD   dwSize = sizeof(szBuffer);
    DOUBLE  dVersion = 0.0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN11InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN11InstalledExit;
    }

    dVersion = atof(szBuffer);
    if (dVersion >= DUN_11_Version)
    {
        bRC =  TRUE;
    }
IsMSDUN11InstalledExit:
    return bRC;
}

//
//    Function    IsScriptingInstalled
//
//    Synopsis    Check to see if scripting is already installed
//
//    Arguments    none
//
//    Returns        TRUE - scripting has been installed
//
//    History        10/14/96    ChrisK    Creaed
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
BOOL IsScriptingInstalled()
{
    BOOL        bRC = FALSE;
    HKEY        hkey = NULL;
    DWORD       dwSize = 0;
    DWORD       dwType = 0;
    LONG        lrc = 0;
    HINSTANCE   hInst = NULL;
    TCHAR       szData[MAX_PATH+1];

    if (VER_PLATFORM_WIN32_NT == g_dwPlatform)
    {
        bRC = TRUE;
    }
    else if (IsMSDUN11Installed())
    {
        bRC = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= g_dwBuild)
        {
            bRC = TRUE;
        }
        else
        {
            bRC = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        bRC = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (bRC)
        {
            hInst = LoadLibrary(TE