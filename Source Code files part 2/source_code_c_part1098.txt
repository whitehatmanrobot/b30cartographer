rql;

        //
        // Walk up each device object in the stack.  For each one, if a VPB
        // exists, grab the database resource exclusive followed by the
        // device lock.  Then acquire the Vpb spinlock and perform the
        // appropriate magic on the device object.
        //

        //
        // NOTE - It's unfortunate that the locking order includes grabing
        // the device specific lock first followed by the global lock.
        //

        if (device->Vpb != NULL) {

            //
            // Grab the device lock.  This will ensure that there are no mount
            // or verify operations in progress, which in turn will ensure
            // that any mounted file system won't go away.
            //

            KeWaitForSingleObject(&(device->DeviceLock),
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            //
            // Now decrement the reference count in the VPB.  If the remove
            // pending flag has been set in the VPB (if this is a QUERY or a
            // REMOVE) then even on a dismount no new file system will be
            // allowed onto the device.
            //

            IoAcquireVpbSpinLock(&oldIrql);

            if (IrpMinorCode == IRP_MN_REMOVE_DEVICE) {

                device->Vpb->Flags &= ~VPB_REMOVE_PENDING;
            }

            IoReleaseVpbSpinLock(oldIrql);

            KeSetEvent(&(device->DeviceLock), IO_NO_INCREMENT, FALSE);
        }

        //
        // Continue up the chain until we know we hit the device the fs
        // mounted on, if any.
        //

        if (Context->MountedDevice == device) {

            //
            // Decrement the fs device handle count. This prevented the filesystem filter stack 
            // from being torn down while a PNP IRP is in progress. 
            //

            if (Context->FsDevice) {
                IopDecrementDeviceObjectHandleCount(Context->FsDevice);
            }
            break;

        } else {

            oldIrql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
            device = device->AttachedDevice;
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, oldIrql );
        }

    } while (device != NULL);

    return;
}


PDEVICE_OBJECT
IopFindMountableDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine will scan up the device stack and find a device which could
    finds with the VPB_REMOVE_PENDING bit (or clear it in the case of cancel)
    and increment (or decrement in the case of cancel) the reference count
    in the VPB.  This is to ensure that no new file system can get mounted on
    the device stack while the remove operation is in place.

    The search will terminate once all the attached device objects have been
    marked, or once a mounted device object has been marked.

Arguments:

    DeviceObject - the PDO we are attempting to remove

    IrpMinorCode - the remove-type operation we are going to perform

    Context - a context block which must be passed in to the unlock operation

Return Value:

    A pointer to the device object stack which the remove request should be
    sent to.  If a mounted file system was found, this will be the lowest
    file system device object in the mounted stack.  Otherwise this will be
    the PDO which was passed in.

--*/

{
    PDEVICE_OBJECT mountableDevice = DeviceObject;

    while (mountableDevice != NULL) {

        if ((mountableDevice->Flags & DO_DEVICE_HAS_NAME) &&
           (mountableDevice->Vpb != NULL)) {

            return mountableDevice;
        }

        mountableDevice = mountableDevice->AttachedDevice;
    }

    return NULL;
}


NTSTATUS
IopDeviceStartComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Completion function for an Async Start IRP.

Arguments:

    DeviceObject - NULL.
    Irp          - SetPower irp which has completed
    Context      - a pointer to the DEVICE_CHANGE_COMPLETION_CONTEXT.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED is returned to IoCompleteRequest
    to signify that IoCompleteRequest should not continue processing
    the IRP.

--*/
{
    PDEVICE_NODE deviceNode = ((PDEVICE_COMPLETION_CONTEXT)Context)->DeviceNode;
    ERESOURCE_THREAD LockingThread = ((PDEVICE_COMPLETION_CONTEXT)Context)->Thread;
    ULONG oldFlags;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Read state from Irp.
    //

#if DBG
    if (((PDEVICE_COMPLETION_CONTEXT)Context)->Id != (PVOID)Irp) {
        ASSERT(0);
        IoFreeIrp (Irp);
        ExFreePool(Context);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
#endif

#if 0
    //
    // Most of this is now handled within PipProcessStartPhase2.
    //
    PnpIrpStatusTracking(Irp->IoStatus.Status, IRP_MN_START_DEVICE, deviceNode->PhysicalDeviceObject);
    ExAcquireSpinLock(&IopPnPSpinLock, &oldIrql);

    oldFlags = deviceNode->Flags;
    deviceNode->Flags &= ~DNF_START_REQUEST_PENDING;
    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if (deviceNode->Flags & DNF_STOPPED) {

            //
            // If the start is initiated by rebalancing, do NOT do enumeration
            //

            deviceNode->Flags &= ~DNF_STOPPED;
            deviceNode->Flags |= DNF_STARTED;

            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        } else {

            //
            // Otherwise, we need to queue a request to enumerate the device if DNF_START_REQUEST_PENDING
            // is set.  (IopStartDevice sets the flag if status of start irp returns pending.)
            //
            //

            deviceNode->Flags |= DNF_NEED_ENUMERATION_ONLY | DNF_STARTED;

            ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);

            if (oldFlags & DNF_START_REQUEST_PENDING) {
                PipRequestDeviceAction( deviceNode->PhysicalDeviceObject,
                                        ReenumerateDeviceTree,
                                        FALSE,
                                        0,
                                        NULL,
                                        NULL );
            }
        }

    } else {

        //
        // The start failed.  We will remove the device
        //

        deviceNode->Flags &= ~(DNF_STOPPED | DNF_STARTED);

        ExReleaseSpinLock(&IopPnPSpinLock, oldIrql);
        SAVE_FAILURE_INFO(deviceNode, Irp->IoStatus.Status);

        PipSetDevNodeProblem(deviceNode, CM_PROB_FAILED_START);
    }
#endif

    //
    // Irp processing is complete, free the irp and then return
    // more_processing_required which causes IoCompleteRequest to
    // stop "completing" this irp any future.
    //

    IoFreeIrp (Irp);
    ExFreePool(Context);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IopQueryDeviceRelations(
    IN DEVICE_RELATION_TYPE Relations,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Synchronous,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )

/*++

Routine Description:

    This routine sends query device relation irp to the specified device object.

Parameters:

    Relations - specifies the type of relation interested.

    DeviceObjet - Supplies the device object of the device being queried.

    AsyncOk - Specifies if we can perform Async QueryDeviceRelations

    DeviceRelations - Supplies a pointer to a variable to receive the returned
                      relation information. This must be freed by the caller.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;
    PDEVICE_COMPLETION_CONTEXT completionContext;
    BOOLEAN requestEnumeration = FALSE;
    KIRQL oldIrql;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryDeviceRelations.Type = Relations;

    //
    // Make the call and return.
    //
    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)DeviceRelations);

    if (Relations == BusRelations) {

        deviceNode->CompletionStatus = status;

        PipSetDevNodeState( deviceNode, DeviceNodeEnumerateCompletion, NULL );

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IopQueryDeviceResources (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    OUT PVOID *Resource,
    OUT ULONG *Length
    )

/*++

Routine Description:

    This routine sends irp to queries resources or resource requirements list
    of the specified device object.

    If the device object is a detected device, its resources will be read from
    registry.  Otherwise, an irp is sent to the bus driver to query its resources.

Parameters:

    DeviceObject - Supplies the device object of the device being queries.

    ResourceType - 0 for device resources and 1 for resource requirements list.

    Resource - Supplies a pointer to a variable to receive the returned resources

    Length - Supplies a pointer to a variable to receive the length of the returned
             resources or resource requirements list.

Return Value:

    NTSTATUS code.

--*/
{
    IO_STACK_LOCATION irpSp;
    PDEVICE_NODE deviceNode;
    NTSTATUS status;
    PIO_RESOURCE_REQUIREMENTS_LIST resReqList, newResources;
    ULONG junk;
    PCM_RESOURCE_LIST cmList;
    PIO_RESOURCE_REQUIREMENTS_LIST filteredList, mergedList;
    BOOLEAN exactMatch;

    PAGED_CODE();

#if DBG

    if ((ResourceType != QUERY_RESOURCE_LIST) &&
        (ResourceType != QUERY_RESOURCE_REQUIREMENTS)) {

        ASSERT(0);
        return STATUS_INVALID_PARAMETER_2;
    }
#endif

    *Resource = NULL;
    *Length = 0;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;

    if (ResourceType == QUERY_RESOURCE_LIST) {

        //
        // caller is asked for RESOURCE_LIST.  If this is a madeup device, we will
        // read it from registry.  Otherwise, we ask drivers.
        //

        if (deviceNode->Flags & DNF_MADEUP) {

            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             ResourceType,
                             REGISTRY_ALLOC_CONFIG + REGISTRY_FORCED_CONFIG + REGISTRY_BOOT_CONFIG,
                             Resource,
                             Length);
            if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                status = STATUS_SUCCESS;
            }
            return status;
        } else {
            irpSp.MinorFunction = IRP_MN_QUERY_RESOURCES;
            irpSp.MajorFunction = IRP_MJ_PNP;
            status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)Resource);
            if (status == STATUS_NOT_SUPPORTED) {

                //
                // If driver doesn't implement this request, it
                // doesn't consume any resources.
                //

                *Resource = NULL;
                status = STATUS_SUCCESS;
            }
            if (NT_SUCCESS(status)) {
                *Length = IopDetermineResourceListSize((PCM_RESOURCE_LIST)*Resource);
            }
            return status;
        }
    } else {

        //
        // Caller is asked for resource requirements list.  We will check:
        // if there is a ForcedConfig, it will be converted to resource requirements
        //     list and return.  Otherwise,
        // If there is an OVerrideConfigVector, we will use it as our
        //     FilterConfigVector.  Otherwise we ask driver for the config vector and
        //     use it as our FilterConfigVector.
        //     Finaly, we pass the FilterConfigVector to driver stack to let drivers
        //     filter the requirements.
        //

        status = IopGetDeviceResourcesFromRegistry(
                         DeviceObject,
                         QUERY_RESOURCE_LIST,
                         REGISTRY_FORCED_CONFIG,
                         Resource,
                         &junk);
        if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             QUERY_RESOURCE_REQUIREMENTS,
                             REGISTRY_OVERRIDE_CONFIGVECTOR,
                             &resReqList,
                             &junk);
            if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                if (deviceNode->Flags & DNF_MADEUP) {
                    status = IopGetDeviceResourcesFromRegistry(
                                     DeviceObject,
                                     QUERY_RESOURCE_REQUIREMENTS,
                                     REGISTRY_BASIC_CONFIGVECTOR,
                                     &resReqList,
                                     &junk);
                    if (status == STATUS_OBJECT_NAME_NOT_FOUND) {
                        status = STATUS_SUCCESS;
                        resReqList = NULL;
                    }
                } else {

                    //
                    // We are going to ask the bus driver ...
                    //

                    if (deviceNode->ResourceRequirements) {
                        ASSERT(deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED);
                        resReqList = ExAllocatePool(PagedPool, deviceNode->ResourceRequirements->ListSize);
                        if (resReqList) {
                            RtlCopyMemory(resReqList,
                                         deviceNode->ResourceRequirements,
                                         deviceNode->ResourceRequirements->ListSize
                                         );
                            status = STATUS_SUCCESS;
                        } else {
                            return STATUS_NO_MEMORY;
                        }
                    } else {

                        status = PpIrpQueryResourceRequirements(DeviceObject, &resReqList);
                        if (status == STATUS_NOT_SUPPORTED) {
                            //
                            // If driver doesn't implement this request, it
                            // doesn't require any resources.
                            //
                            status = STATUS_SUCCESS;
                            resReqList = NULL;
                        }
                    }
                }
                if (!NT_SUCCESS(status)) {
                    return status;
                }
            }

            //
            // For devices with boot config, we need to filter the resource requirements
            // list against boot config.
            //

            status = IopGetDeviceResourcesFromRegistry(
                             DeviceObject,
                             QUERY_RESOURCE_LIST,
                             REGISTRY_BOOT_CONFIG,
                             &cmList,
                             &junk);
            if (NT_SUCCESS(status) &&
                (!cmList || cmList->Count == 0 || cmList->List[0].InterfaceType != PCIBus)) {
                status = IopFilterResourceRequirementsList (
                             resReqList,
                             cmList,
                             &filteredList,
                             &exactMatch);
                if (cmList) {
                    ExFreePool(cmList);
                }
                if (!NT_SUCCESS(status)) {
                    if (resReqList) {
                        ExFreePool(resReqList);
                    }
                    return status;
                } else {

                    //
                    // For non-root-enumerated devices, we merge filtered config with basic config
                    // vectors to form a new res req list.  For root-enumerated devices, we don't
                    // consider Basic config vector.
                    //

                    if (!(deviceNode->Flags & DNF_MADEUP) &&
                        (exactMatch == FALSE || resReqList->AlternativeLists > 1)) {
                        status = IopMergeFilteredResourceRequirementsList (
                                 filteredList,
                                 resReqList,
                                 &mergedList
                                 );
                        if (resReqList) {
                            ExFreePool(resReqList);
                        }
                        if (filteredList) {
                            ExFreePool(filteredList);
                        }
                        if (NT_SUCCESS(status)) {
                            resReqList = mergedList;
                        } else {
                            return status;
                        }
                    } else {
                        if (resReqList) {
                            ExFreePool(resReqList);
                        }
                        resReqList = filteredList;
                    }
                }
            }

        } else {
            ASSERT(NT_SUCCESS(status));

            //
            // We have Forced Config.  Convert it to resource requirements and return it.
            //

            if (*Resource) {
                resReqList = IopCmResourcesToIoResources (0, (PCM_RESOURCE_LIST)*Resource, LCPRI_FORCECONFIG);
                ExFreePool(*Resource);
                if (resReqList) {
                    *Resource = (PVOID)resReqList;
                    *Length = resReqList->ListSize;
                } else {
                    *Resource = NULL;
                    *Length = 0;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    return status;
                }
            } else {
                resReqList = NULL;
            }
        }

        //
        // If we are here, we have a resource requirements list for drivers to examine ...
        // NOTE: Per Lonny's request, we let drivers filter ForcedConfig
        //

        status = IopFilterResourceRequirementsCall(
            DeviceObject,
            resReqList,
            &newResources
            );

        if (NT_SUCCESS(status)) {
            UNICODE_STRING unicodeName;
            HANDLE handle, handlex;

#if DBG
            if (newResources == NULL && resReqList) {
                DbgPrint("PnpMgr: Non-NULL resource requirements list filtered to NULL\n");
            }
#endif
            if (newResources) {

                *Length = newResources->ListSize;
                ASSERT(*Length);

                //
                // Make our own copy of the allocation. We do this so that the
                // verifier doesn't believe the driver has leaked memory if
                // unloaded.
                //

                *Resource = (PVOID) ExAllocatePool(PagedPool, *Length);
                if (*Resource == NULL) {

                    ExFreePool(newResources);
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlCopyMemory(*Resource, newResources, *Length);
                ExFreePool(newResources);

            } else {
                *Length = 0;
                *Resource = NULL;
            }

            //
            // Write filtered res req to registry
            //

            status = IopDeviceObjectToDeviceInstance(DeviceObject, &handlex, KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &handle,
                                               handlex,
                                               &unicodeName,
                                               KEY_READ
                                               );
                if (NT_SUCCESS(status)) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_FILTERED_CONFIG_VECTOR);
                    ZwSetValueKey(handle,
                                  &unicodeName,
                                  TITLE_INDEX_VALUE,
                                  REG_RESOURCE_REQUIREMENTS_LIST,
                                  *Resource,
                                  *Length
                                  );
                    ZwClose(handle);
                    ZwClose(handlex);
                }
            }

        } else {

            //
            // NTRAID #61058-2001/01/05 - ADRIAO
            //     We might want to consider bubbling up
            // non-STATUS_NOT_SUPPORTED failure codes and fail the entire
            // devnode if one is seen.
            //
            ASSERT(status == STATUS_NOT_SUPPORTED);
            *Resource = resReqList;
            if (resReqList) {
                *Length = resReqList->ListSize;
            } else {
                *Length = 0;
            }
        }
        return STATUS_SUCCESS;
    }
}

NTSTATUS
IopQueryResourceHandlerInterface(
    IN RESOURCE_HANDLER_TYPE HandlerType,
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR ResourceType,
    IN OUT PVOID *Interface
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the specified ResourceType
    resource translator.

Parameters:

    HandlerType - specifies Arbiter or Translator

    DeviceObject - Supplies a pointer to the Device object to be queried.

    ResourceType - Specifies the desired type of translator.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PINTERFACE interface;
    USHORT size;
    GUID interfaceType;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    PAGED_CODE();

    //
    // If this device object is created by pnp mgr for legacy resource allocation,
    // skip it.
    //

    if ((deviceNode->DuplicatePDO == (PDEVICE_OBJECT) DeviceObject->DriverObject) ||
        !(DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE)) {
        return STATUS_NOT_SUPPORTED;
    }

    switch (HandlerType) {
    case ResourceTranslator:
        size = sizeof(TRANSLATOR_INTERFACE) + 4;  // Pnptest
        //size = sizeof(TRANSLATOR_INTERFACE);
        interfaceType = GUID_TRANSLATOR_INTERFACE_STANDARD;
        break;

    case ResourceArbiter:
        size = sizeof(ARBITER_INTERFACE);
        interfaceType = GUID_ARBITER_INTERFACE_STANDARD;
        break;

    case ResourceLegacyDeviceDetection:
        size = sizeof(LEGACY_DEVICE_DETECTION_INTERFACE);
        interfaceType = GUID_LEGACY_DEVICE_DETECTION_STANDARD;
        break;

    default:
        return STATUS_INVALID_PARAMETER;
    }

    interface = (PINTERFACE) ExAllocatePool(PagedPool, size);
    if (interface == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(interface, size);
    interface->Size = size;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryInterface.InterfaceType = &interfaceType;
    irpSp.Parameters.QueryInterface.Size = interface->Size;
    irpSp.Parameters.QueryInterface.Version = interface->Version = 0;
    irpSp.Parameters.QueryInterface.Interface = interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = (PVOID) (ULONG_PTR) ResourceType;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {

        switch (HandlerType) {
         
        case ResourceTranslator:
            if (    ((PTRANSLATOR_INTERFACE)interface)->TranslateResources == NULL ||
                    ((PTRANSLATOR_INTERFACE)interface)->TranslateResourceRequirements == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL, 
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_TRANSLATOR_INTERFACE_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case ResourceArbiter:
            if (((PARBITER_INTERFACE)interface)->ArbiterHandler == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL, 
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_ARBITER_INTERFACE_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        case ResourceLegacyDeviceDetection:
            if (((PLEGACY_DEVICE_DETECTION_INTERFACE)interface)->LegacyDeviceDetection == NULL) {

                IopDbgPrint((IOP_ERROR_LEVEL, 
                             "!devstack %p returned success for IRP_MN_QUERY_INTERFACE (GUID_LEGACY_DEVICE_DETECTION_STANDARD) but did not fill in the required data\n",
                             DeviceObject));
                ASSERT(!NT_SUCCESS(status));
                status = STATUS_UNSUCCESSFUL;
            }
            break;

        default:
            //
            // This should never happen.
            //
            IopDbgPrint((IOP_ERROR_LEVEL, 
                         "IopQueryResourceHandlerInterface: Possible stack corruption\n"));
            ASSERT(0);
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if (NT_SUCCESS(status)) {

        *Interface = interface;
     } else {

         ExFreePool(interface);
     }

    return status;
}

NTSTATUS
IopQueryReconfiguration(
    IN UCHAR Request,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the specified ResourceType
    resource translator.

Parameters:

    HandlerType - specifies Arbiter or Translator

    DeviceObject - Supplies a pointer to the Device object to be queried.

    ResourceType - Specifies the desired type of translator.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PDEVICE_NODE deviceNode = (PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode;

    PAGED_CODE();

    switch (Request) {
    case IRP_MN_QUERY_STOP_DEVICE:

        if (deviceNode->State != DeviceNodeStarted) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_QUERY_STOP_DEVICE to an unstarted device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case IRP_MN_STOP_DEVICE:
        //
        // Fall through
        //
        if (deviceNode->State != DeviceNodeQueryStopped) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_STOP_DEVICE to an unqueried device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        if (    deviceNode->State != DeviceNodeQueryStopped &&
                deviceNode->State != DeviceNodeStarted) {

            IopDbgPrint((   IOP_RESOURCE_ERROR_LEVEL,
                            "An attempt made to send IRP_MN_CANCEL_STOP_DEVICE to an unqueried\\unstarted device %wZ!\n",
                            &deviceNode->InstancePath));
            ASSERT(0);
            return STATUS_UNSUCCESSFUL;
        }
        break;

    default:
        ASSERT(0);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = Request;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    return status;
}

NTSTATUS
IopQueryLegacyBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid,          OPTIONAL
    OUT INTERFACE_TYPE *InterfaceType, OPTIONAL
    OUT ULONG *BusNumber               OPTIONAL
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for its legacy bus
    information.

Parameters:

    DeviceObject - The device object to be queried.

    InterfaceGuid = Supplies a pointer to receive the device's interface type
        GUID.

    Interface = Supplies a pointer to receive the device's interface type.

    BusNumber = Supplies a pointer to receive the device's bus number.

Return Value:

    Returns NTSTATUS.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PLEGACY_BUS_INFORMATION busInfo;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_LEGACY_BUS_INFORMATION;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)&busInfo);
    if (NT_SUCCESS(status)) {

        if (busInfo == NULL) {

            //
            // The device driver LIED to us.  Bad, bad, bad device driver.
            //

            PDEVICE_NODE deviceNode;

            deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;

            if (deviceNode && deviceNode->ServiceName.Buffer) {

                DbgPrint("*** IopQueryLegacyBusInformation - Driver %wZ returned STATUS_SUCCESS\n", &deviceNode->ServiceName);
                DbgPrint("    for IRP_MN_QUERY_LEGACY_BUS_INFORMATION, and a NULL POINTER.\n");
            }

            ASSERT(busInfo != NULL);

        } else {
            if (ARGUMENT_PRESENT(InterfaceGuid)) {
                *InterfaceGuid = busInfo->BusTypeGuid;
            }
            if (ARGUMENT_PRESENT(InterfaceType)) {
                *InterfaceType = busInfo->LegacyBusType;
            }
            if (ARGUMENT_PRESENT(BusNumber)) {
                *BusNumber = busInfo->BusNumber;
            }
            ExFreePool(busInfo);
        }
    }
    return status;
}

NTSTATUS
IopQueryPnpBusInformation (
    IN PDEVICE_OBJECT DeviceObject,
    OUT LPGUID InterfaceGuid,         OPTIONAL
    OUT INTERFACE_TYPE *InterfaceType, OPTIONAL
    OUT ULONG *BusNumber               OPTIONAL
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the specified ResourceType
    resource translator.

Parameters:

    HandlerType - specifies Arbiter or Translator

    DeviceObject - Supplies a pointer to the Device object to be queried.

    ResourceType - Specifies the desired type of translator.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PPNP_BUS_INFORMATION busInfo;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_BUS_INFORMATION;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)&busInfo);
    if (NT_SUCCESS(status)) {

        if (busInfo == NULL) {

            //
            // The device driver LIED to us.  Bad, bad, bad device driver.
            //

            PDEVICE_NODE deviceNode;

            deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode;

            if (deviceNode && deviceNode->ServiceName.Buffer) {

                DbgPrint("*** IopQueryPnpBusInformation - Driver %wZ returned STATUS_SUCCESS\n", &deviceNode->ServiceName);
                DbgPrint("    for IRP_MN_QUERY_BUS_INFORMATION, and a NULL POINTER.\n");
            }

            ASSERT(busInfo != NULL);

        } else {
            if (ARGUMENT_PRESENT(InterfaceGuid)) {
                *InterfaceGuid = busInfo->BusTypeGuid;
            }
            if (ARGUMENT_PRESENT(InterfaceType)) {
                *InterfaceType = busInfo->LegacyBusType;
            }
            if (ARGUMENT_PRESENT(BusNumber)) {
                *BusNumber = busInfo->BusNumber;
            }
            ExFreePool(busInfo);
        }
    }
    return status;
}

NTSTATUS
IopQueryDeviceState(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PPNP_DEVICE_STATE DeviceState
    )

/*++

Routine Description:

    This routine sends query device state irp to the specified device object.

Parameters:

    DeviceObjet - Supplies the device object of the device being queried.

Return Value:

    NTSTATUS code.

--*/

{
    IO_STACK_LOCATION irpSp;
    PDEVICE_NODE deviceNode;
    ULONG_PTR stateValue;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_PNP_DEVICE_STATE;

    //
    // Make the call.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, &stateValue);

    //
    // Now perform the appropriate action based on the returned state
    //

    if (NT_SUCCESS(status)) {

        *DeviceState = (PNP_DEVICE_STATE)stateValue;
    }

    return status;
}


VOID
IopIncDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Increments the DisableableDepends field of this devicenode
    and potentially every parent device node up the tree
    A parent devicenode is only incremented if the child in question
    is incremented from 0 to 1

Parameters:

    DeviceNode - Supplies the device node where the depends is to be incremented

Return Value:

    none.

--*/
{

    while (DeviceNode != NULL) {

        LONG newval;

        newval = InterlockedIncrement((PLONG)&DeviceNode->DisableableDepends);
        if (newval != 1) {
            //
            // we were already non-disableable, so we don't have to bother parent
            //
            break;
        }

        DeviceNode = DeviceNode ->Parent;

    }

}


VOID
IopDecDisableableDepends(
    IN OUT PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    Decrements the DisableableDepends field of this devicenode
    and potentially every parent device node up the tree
    A parent devicenode is only decremented if the child in question
    is decremented from 1 to 0

Parameters:

    DeviceNode - Supplies the device node where the depends is to be decremented

Return Value:

    none.

--*/
{

    while (DeviceNode != NULL) {

        LONG newval;

        newval = InterlockedDecrement((PLONG)&DeviceNode->DisableableDepends);
        if (newval != 0) {
            //
            // we are still non-disableable, so we don't have to bother parent
            //
            break;
        }

        DeviceNode = DeviceNode ->Parent;

    }

}

NTSTATUS
IopFilterResourceRequirementsCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResReqList OPTIONAL,
    OUT PVOID *Information
    )

/*++

Routine Description:

    This function sends a synchronous filter resource requirements irp to the
    top level device object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    ResReqList   - Supplies a pointer to the resource requirements requiring
                   filtering.

    Information  - Supplies a pointer to a variable that receives the returned
                   information of the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PULONG_PTR returnInfo = (PULONG_PTR)Information;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SPECIALIRP_WATERMARK_IRP(irp, IRP_SYSTEM_RESTRICTED);

    //
    // Initialize it to success. This is a special hack for WDM (ie 9x)
    // compatibility. The driver verifier is in on this one.
    //

    if (ResReqList) {

        irp->IoStatus.Status = statusBlock.Status = STATUS_SUCCESS;
        irp->IoStatus.Information = statusBlock.Information = (ULONG_PTR) ResReqList;

    } else {

        irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    }

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    irp->UserIosb = &statusBlock;
    irp->UserEvent = &event;

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Queue this irp onto the current thread
    //

    IopQueueThreadIrp(irp);

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Setup the stack location contents
    //

    irpSp->MinorFunction = IRP_MN_FILTER_RESOURCE_REQUIREMENTS;
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList = ResReqList;

    //
    // Call the driver
    //

    status = IoCallDriver(deviceObject, irp);

    PnpIrpStatusTracking(status, IRP_MN_FILTER_RESOURCE_REQUIREMENTS, deviceObject);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    *returnInfo = (ULONG_PTR) statusBlock.Information;

    return status;
}

NTSTATUS
IopQueryDockRemovalInterface(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PDOCK_INTERFACE *DockInterface
    )

/*++

Routine Description:

    This routine queries the specified DeviceObject for the dock removal
    interface. We use this interface to send pseudo-remove's. We use this
    to solve the removal orderings problem.

Parameters:

    DeviceObject - Supplies a pointer to the Device object to be queried.

    Interface - supplies a variable to receive the desired interface.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;
    PINTERFACE interface;
    USHORT size;
    GUID interfaceType;

    PAGED_CODE();

    size = sizeof(DOCK_INTERFACE);
    interfaceType = GUID_DOCK_INTERFACE;
    interface = (PINTERFACE) ExAllocatePool(PagedPool, size);
    if (interface == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(interface, size);
    interface->Size = size;

    //
    // Initialize the stack location to pass to IopSynchronousCall()
    //

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    //
    // Set the function codes.
    //

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Set the pointer to the resource list
    //

    irpSp.Parameters.QueryInterface.InterfaceType = &interfaceType;
    irpSp.Parameters.QueryInterface.Size = interface->Size;
    irpSp.Parameters.QueryInterface.Version = interface->Version = 0;
    irpSp.Parameters.QueryInterface.Interface = interface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Make the call and return.
    //

    status = IopSynchronousCall(DeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {
        *DockInterface = (PDOCK_INTERFACE) interface;
    } else {
        ExFreePool(interface);
    }
    return status;
}

NTSTATUS
PpIrpQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
   )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_RESOURCE_REQUIREMENTS to the 
    DeviceObject to retrieve its resource requirements. If this routine 
    failes, Requirements will be set to NULL.

Arguments:

    DeviceObject - The device object the request should be sent to.
    
    Requirements - Receives the requirements returned by the driver if any.
    The caller is expected to free the storage for Requirements on success.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    *Requirements = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_RESOURCE_REQUIREMENTS;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)Requirements);

    ASSERT(NT_SUCCESS(status) || (*Requirements == NULL));

    if (NT_SUCCESS(status)) {

        if(*Requirements == NULL) {

            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *Requirements = NULL;
    }

    return status;
}

#if FAULT_INJECT_INVALID_ID
//
// Fault injection for invalid IDs
// 
ULONG PiFailQueryID = 0;
#endif

NTSTATUS
PpIrpQueryID(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID
    )

/*++

Routine Description:

    This routine will issue IRP_MN_QUERY_ID to the DeviceObject 
    to retrieve the specified ID. If this routine fails, ID will 
    be set to NULL.

Arguments:

    DeviceObject - The device object the request should be sent to.
    
    IDType - Type of ID to be queried.

    ID - Receives the ID returned by the driver if any. The caller 
    is expected to free the storage for ID on success.

Return Value:

    NTSTATUS.

--*/

{
    IO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(IDType == BusQueryDeviceID || IDType == BusQueryInstanceID || 
           IDType == BusQueryHardwareIDs || IDType == BusQueryCompatibleIDs || 
           IDType == BusQueryDeviceSerialNumber);

    *ID = NULL;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    irpSp.Parameters.QueryId.IdType = IDType;

    status = IopSynchronousCall(DeviceObject, &irpSp, (PULONG_PTR)ID);

    ASSERT(NT_SUCCESS(status) || (*ID == NULL));

    if (NT_SUCCESS(status)) {

        if(*ID == NULL) {

            status = STATUS_NOT_SUPPORTED;
        }
    } else {

        *ID = NULL;
    }

#if FAULT_INJECT_INVALID_ID
    //
    // Fault injection for invalid IDs
    // 
    if (*ID){

        static LARGE_INTEGER seed = {0};

        if(seed.LowPart == 0) {

            KeQuerySystemTime(&seed);
        }

        if(PnPBootDriversInitialized && PiFailQueryID && RtlRandom(&seed.LowPart) % 10 > 7) {
                    
            **ID = L',';
        }
    }
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpirq.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pnpirq.c

Abstract:

    Root IRQ arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Constants
//

#define MAX_ULONGLONG           ((ULONGLONG) -1)

//
// Prototypes
//

NTSTATUS
IopIrqInitialize(
    VOID
    );

NTSTATUS
IopIrqUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopIrqPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopIrqScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopIrqUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

NTSTATUS
IopIrqTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    );

BOOLEAN
IopIrqFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopIrqInitialize)
#pragma alloc_text(PAGE, IopIrqUnpackRequirement)
#pragma alloc_text(PAGE, IopIrqPackResource)
#pragma alloc_text(PAGE, IopIrqScoreRequirement)
#pragma alloc_text(PAGE, IopIrqUnpackResource)
#pragma alloc_text(PAGE, IopIrqTranslateOrdering)
#pragma alloc_text(PAGE, IopIrqFindSuitableRange)
#endif // ALLOC_PRAGMA

//
// Implementation
//
#if !defined(NO_LEGACY_DRIVERS)
NTSTATUS
IopIrqTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    )

/*

Routine Description:

    This routine is called during arbiter initialization to translate the
    orderings.

Parameters:

    Target - Place to put the translated descriptor

    Source - Descriptor to translate

Return Value:

    Status code

*/

{

    KIRQL level;
    KAFFINITY affinity;

    PAGED_CODE();

    //
    // Copy the source to the target
    //

    *Target = *Source;

    if (Source->Type != CmResourceTypeInterrupt) {
        return STATUS_SUCCESS;
    }

    //
    // Translate the vector
    //


    ARB_PRINT(
        2,
        ("Translating Vector 0x%x-0x%x =>",
        Source->u.Interrupt.MinimumVector,
        Source->u.Interrupt.MaximumVector
        ));

    Target->u.Interrupt.MinimumVector =
        HalGetInterruptVector(Isa,
                              0,
                              Source->u.Interrupt.MinimumVector,
                              Source->u.Interrupt.MinimumVector,
                              &level,
                              &affinity
                              );

    if (affinity == 0) {
        ARB_PRINT(2,("Translation failed\n"));
        *Target = *Source;
        return STATUS_SUCCESS;
    }

    Target->u.Interrupt.MaximumVector =
        HalGetInterruptVector(Isa,
                              0,
                              Source->u.Interrupt.MaximumVector,
                              Source->u.Interrupt.MaximumVector,
                              &level,
                              &affinity
                              );

    if (affinity == 0) {
        ARB_PRINT(2,("Translation failed\n"));
        *Target = *Source;
        return STATUS_SUCCESS;
    }

    ARB_PRINT(
        2,
        ("0x%x-0x%x\n",
        Target->u.Interrupt.MinimumVector,
        Target->u.Interrupt.MaximumVector
        ));


    return STATUS_SUCCESS;
}
#endif // NO_LEGACY_DRIVERS

NTSTATUS
IopIrqInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{

    IopRootIrqArbiter.UnpackRequirement = IopIrqUnpackRequirement;
    IopRootIrqArbiter.PackResource      = IopIrqPackResource;
    IopRootIrqArbiter.UnpackResource    = IopIrqUnpackResource;
    IopRootIrqArbiter.ScoreRequirement  = IopIrqScoreRequirement;

    return ArbInitializeArbiterInstance(&IopRootIrqArbiter,
                                        NULL,     // Indicates ROOT arbiter
                                        CmResourceTypeInterrupt,
                                        L"RootIRQ",
                                        L"Root",
#if defined(NO_LEGACY_DRIVERS)
                                        NULL
#else
                                        IopIrqTranslateOrdering
#endif // NO_LEGACY_DRIVERS
                                        );
}

//
// Arbiter callbacks
//

NTSTATUS
IopIrqUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    ARB_PRINT(2,
                ("Unpacking IRQ requirement %p => 0x%I64x-0x%I64x\n",
                Descriptor,
                (ULONGLONG) Descriptor->u.Interrupt.MinimumVector,
                (ULONGLONG) Descriptor->u.Interrupt.MaximumVector
                ));

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    return STATUS_SUCCESS;

}

LONG
IopIrqScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    score = Descriptor->u.Interrupt.MaximumVector -
        Descriptor->u.Interrupt.MinimumVector + 1;

    ARB_PRINT(2,
                ("Scoring IRQ resource %p => %i\n",
                Descriptor,
                score
                ));

    return score;
}

NTSTATUS
IopIrqPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{
    ASSERT(Descriptor);
    ASSERT(Start < ((ULONG)-1));
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    ARB_PRINT(2,
                ("Packing IRQ resource %p => 0x%I64x\n",
                Descriptor,
                Start
                ));

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    return STATUS_SUCCESS;
}

NTSTATUS
IopIrqUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Start - Pointer to where the start value should be unpacked to.

    End - Pointer to where the end value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/


{

    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    ARB_PRINT(2,
                ("Unpacking IRQ resource %p => 0x%I64x\n",
                Descriptor,
                *Start
                ));

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpmemio.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pnpmemio.c

Abstract:

    Root IO Port and Memory arbiter

Author:

    Andy Thornton (andrewth) 04/17/97

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#define BUGFEST_HACKS

//
// Constants
//

#define MAX_ULONGLONG           ((ULONGLONG) -1)
#define MAX_ALIAS_PORT          0x0000FFFF

typedef struct _PORT_ARBITER_EXTENSION {

    PRTL_RANGE_LIST Aliases;
    PRTL_RANGE_LIST PossibleAliases;
    RTL_RANGE_LIST RangeLists[2];

} PORT_ARBITER_EXTENSION, *PPORT_ARBITER_EXTENSION;

//
// Prototypes
//

VOID
IopPortBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
IopPortGetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    );

BOOLEAN
IopPortFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
IopMemFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );


NTSTATUS
IopGenericUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
IopGenericPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

LONG
IopGenericScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
IopGenericUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

BOOLEAN
IopPortIsAliasedRangeAvailable(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
IopMemInitialize(
    VOID
    );

VOID
IopPortAddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
IopTranslateBusAddress(
    IN PHYSICAL_ADDRESS SourceAddress,
    IN UCHAR SourceResourceType,
    OUT PPHYSICAL_ADDRESS TargetAddress,
    OUT PUCHAR TargetResourceType
    );


//
// Make everything pageable
//

#ifdef ALLOC_PRAGMA

NTSTATUS
IopGenericTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    );
#pragma alloc_text(PAGE, IopGenericTranslateOrdering)
#pragma alloc_text(PAGE, IopPortInitialize)
#pragma alloc_text(PAGE, IopMemInitialize)
#pragma alloc_text(PAGE, IopGenericUnpackRequirement)
#pragma alloc_text(PAGE, IopGenericPackResource)
#pragma alloc_text(PAGE, IopGenericScoreRequirement)
#pragma alloc_text(PAGE, IopGenericUnpackResource)
#pragma alloc_text(PAGE, IopPortBacktrackAllocation)
#pragma alloc_text(PAGE, IopPortFindSuitableRange)
#pragma alloc_text(PAGE, IopMemFindSuitableRange)
#pragma alloc_text(PAGE, IopPortGetNextAlias)
#pragma alloc_text(PAGE, IopPortAddAllocation)
#pragma alloc_text(PAGE, IopPortIsAliasedRangeAvailable)
#pragma alloc_text(PAGE, IopTranslateBusAddress)
#endif // ALLOC_PRAGMA


#define ADDRESS_SPACE_MEMORY                0x0
#define ADDRESS_SPACE_PORT                  0x1
#define ADDRESS_SPACE_USER_MEMORY           0x2
#define ADDRESS_SPACE_USER_PORT             0x3
#define ADDRESS_SPACE_DENSE_MEMORY          0x4
#define ADDRESS_SPACE_USER_DENSE_MEMORY     0x6

NTSTATUS
IopTranslateBusAddress(
    IN PHYSICAL_ADDRESS SourceAddress,
    IN UCHAR SourceResourceType,
    OUT PPHYSICAL_ADDRESS TargetAddress,
    OUT PUCHAR TargetResourceType
    )
/*++

Routine Description:

    This routine translates addresses.

Parameters:

    SourceAddress - The address to translate

    ResourceType - The resource type (IO or Memory) we are translaing.  If the
        address space changes from IO->Memory this will be updated.

    TargetAddress - Pointer to where the target should be translated to.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    ULONG sourceAddressSpace, targetAddressSpace;
    BOOLEAN translated;

    PAGED_CODE();

    //
    // Select the appropriate address space
    //

    if (SourceResourceType == CmResourceTypeMemory) {
        sourceAddressSpace = ADDRESS_SPACE_MEMORY;
    } else if (SourceResourceType == CmResourceTypePort) {
        sourceAddressSpace = ADDRESS_SPACE_PORT;
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    ARB_PRINT(
        2,
        ("Translating %s address 0x%I64x => ",
        SourceResourceType == CmResourceTypeMemory ? "Memory" : "I/O",
        SourceAddress.QuadPart
       ));

    //
    // HACKHACK Ask the HAL to translate on ISA bus - if we can't then just
    // don't translate because this must be a PCI system so the root arbiters
    // don't do much (Yes it's a steaming hack but it'll work for beta 1)
    //

    targetAddressSpace = sourceAddressSpace;
    translated = HalTranslateBusAddress(
                     Isa,
                     0,
                     SourceAddress,
                     &targetAddressSpace,
                     TargetAddress
                     );

    if (!translated) {
        ARB_PRINT(2,("Translation failed!\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Update the resource type in the target if we have gone from Io to Memory
    //


    //
    // BUBBUG - update the length for IO -> Memory (Dense vs Sparse)
    // I think the answer is dense -> spares is multiply length by 32
    //

    if (targetAddressSpace == ADDRESS_SPACE_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_USER_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_DENSE_MEMORY
    ||  targetAddressSpace == ADDRESS_SPACE_USER_DENSE_MEMORY) {
        *TargetResourceType = CmResourceTypeMemory;
    } else if (targetAddressSpace == ADDRESS_SPACE_PORT
           ||  targetAddressSpace == ADDRESS_SPACE_USER_PORT) {
        *TargetResourceType = CmResourceTypePort;
    } else {
        ASSERT(0 && "Translation has returned an unknown address space");
        return STATUS_INVALID_PARAMETER;
    }

    ARB_PRINT(
        2,
        ("%s address 0x%I64x\n",
        *TargetResourceType == CmResourceTypeMemory ? "Memory" : "I/O",
        TargetAddress->QuadPart
        ));

    return STATUS_SUCCESS;

}


NTSTATUS
IopGenericTranslateOrdering(
    OUT PIO_RESOURCE_DESCRIPTOR Target,
    IN PIO_RESOURCE_DESCRIPTOR Source
    )

/*

Routine Description:

    This routine is called during arbiter initialization to translate the
    orderings.

Parameters:

    Target - Place to put the translated descriptor

    Source - Descriptor to translate

Return Value:

    STATUS_SUCCESS



*/

{
    NTSTATUS status;
    UCHAR initialResourceType, minResourceType, maxResourceType;
    PAGED_CODE();


    *Target = *Source;

    if (Source->Type != CmResourceTypeMemory
    && Source->Type != CmResourceTypePort) {
        return STATUS_SUCCESS;
    }

    initialResourceType = Source->Type;

    //
    // Translate the minimum
    //

    status = IopTranslateBusAddress(Source->u.Generic.MinimumAddress,
                                    initialResourceType,
                                    &Target->u.Generic.MinimumAddress,
                                    &minResourceType
                                    );

    if (NT_SUCCESS(status)) {

        //
        // Translate the maximum iff we could translate the minimum
        //

        status = IopTranslateBusAddress(Source->u.Generic.MaximumAddress,
                                        initialResourceType,
                                        &Target->u.Generic.MaximumAddress,
                                        &maxResourceType
                                        );

    }

    //
    // If we couldn't translate both ends of the range then we want to skip this
    // range - set it's type to CmResourceTypeNull
    //

    if (!NT_SUCCESS(status)) {
        Target->Type = CmResourceTypeNull;
    } else {
        ASSERT(minResourceType == maxResourceType);
        Target->Type = minResourceType;
    }

    return STATUS_SUCCESS;

}

//
// Implementation
//

NTSTATUS
IopPortInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    // Fill in the non-default action handlers
    //

    IopRootPortArbiter.FindSuitableRange    = IopPortFindSuitableRange;
    IopRootPortArbiter.AddAllocation        = IopPortAddAllocation;
    IopRootPortArbiter.BacktrackAllocation  = IopPortBacktrackAllocation;

    IopRootPortArbiter.UnpackRequirement    = IopGenericUnpackRequirement;
    IopRootPortArbiter.PackResource         = IopGenericPackResource;
    IopRootPortArbiter.UnpackResource       = IopGenericUnpackResource;
    IopRootPortArbiter.ScoreRequirement     = IopGenericScoreRequirement;

    return ArbInitializeArbiterInstance(&IopRootPortArbiter,
                                        NULL,     // Indicates ROOT arbiter
                                        CmResourceTypePort,
                                        L"RootPort",
                                        L"Root",
                                        IopGenericTranslateOrdering
                                        );

}

NTSTATUS
IopMemInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the arbiter

Parameters:

    None

Return Value:

    None

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    IopRootMemArbiter.UnpackRequirement = IopGenericUnpackRequirement;
    IopRootMemArbiter.PackResource      = IopGenericPackResource;
    IopRootMemArbiter.UnpackResource    = IopGenericUnpackResource;
    IopRootMemArbiter.ScoreRequirement  = IopGenericScoreRequirement;

    IopRootMemArbiter.FindSuitableRange    = IopMemFindSuitableRange;

    status = ArbInitializeArbiterInstance(&IopRootMemArbiter,
                                          NULL,     // Indicates ROOT arbiter
                                          CmResourceTypeMemory,
                                          L"RootMemory",
                                          L"Root",
                                          IopGenericTranslateOrdering
                                          );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Allocate the first page of physical memory as the firmware uses it and
    // doesn't report it as so Mm doesn't reuse it.
    //

    status = RtlAddRange(IopRootMemArbiter.Allocation,
                         0,
                         PAGE_SIZE - 1,
                         0, // RangeAttributes
                         0, // Flags
                         NULL,
                         NULL
                         );
    return status;

}


//
// Arbiter callbacks
//

NTSTATUS
IopGenericUnpackRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

Routine Description:

    This routine unpacks an resource requirement descriptor.

Arguments:

    Descriptor - The descriptor describing the requirement to unpack.

    Minimum - Pointer to where the minimum acceptable start value should be
        unpacked to.

    Maximum - Pointer to where the maximum acceptable end value should be
        unpacked to.

    Length - Pointer to where the required length should be unpacked to.

    Minimum - Pointer to where the required alignment should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{
    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypePort
           || Descriptor->Type == CmResourceTypeMemory);


    *Minimum = (ULONGLONG) Descriptor->u.Generic.MinimumAddress.QuadPart;
    *Maximum = (ULONGLONG) Descriptor->u.Generic.MaximumAddress.QuadPart;
    *Length = Descriptor->u.Generic.Length;
    *Alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    //

    if (*Alignment == 0) {
        *Alignment = 1;
    }

    //
    // Fix broken INF's that report they support 24bit memory > 0xFFFFFF
    //

    if (Descriptor->Type == CmResourceTypeMemory
    && Descriptor->Flags & CM_RESOURCE_MEMORY_24
    && Descriptor->u.Memory.MaximumAddress.QuadPart > 0xFFFFFF) {
        *Maximum = 0xFFFFFF;
    }

    ARB_PRINT(2,
                ("Unpacking %s requirement %p => 0x%I64x-0x%I64x length 0x%x alignment 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                *Minimum,
                *Maximum,
                *Length,
                *Alignment
                ));

    return STATUS_SUCCESS;

}

LONG
IopGenericScoreRequirement(
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine scores a requirement based on how flexible it is.  The least
    flexible devices are scored the least and so when the arbitration list is
    sorted we try to allocate their resources first.

Arguments:

    Descriptor - The descriptor describing the requirement to score.


Return Value:

    The score.

--*/

{
    LONG score;
    ULONGLONG start, end;
    LONGLONG bigscore;
    ULONG alignment;

    PAGED_CODE();

#define MAX_SCORE MAXLONG

    ASSERT(Descriptor);
    ASSERT((Descriptor->Type == CmResourceTypePort) ||
           (Descriptor->Type == CmResourceTypeMemory));

    alignment = Descriptor->u.Generic.Alignment;

    //
    // Fix the broken hardware that reports 0 alignment
    // Since this is not a PCI device, set the alignment to 1.
    //
    //

    if (alignment == 0) {
        alignment = 1;
    }



    start = ALIGN_ADDRESS_UP(
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                alignment
                );

    end = Descriptor->u.Generic.MaximumAddress.QuadPart;

    //
    // The score is the number of possible allocations that could be made
    // given the alignment and length constraints
    //

    bigscore = (((end - Descriptor->u.Generic.Length + 1) - start)
                    / alignment) + 1;

    score = (LONG)bigscore;
    if (bigscore < 0) {
        score = -1;
    } else if (bigscore > MAX_SCORE) {
        score = MAX_SCORE;
    }

    ARB_PRINT(2,
                ("Scoring port resource %p(0x%I64x-0x%I64x) => %i\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                Descriptor->u.Generic.MinimumAddress.QuadPart,
                end,
                score
                ));

    return score;
}

NTSTATUS
IopGenericPackResource(
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs an resource descriptor.

Arguments:

    Requirement - The requirement from which this resource was chosen.

    Start - The start value of the resource.

    Descriptor - Pointer to the descriptor to pack into.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Requirement);
    ASSERT(Requirement->Type == CmResourceTypePort
           || Requirement->Type == CmResourceTypeMemory);

    Descriptor->Type = Requirement->Type;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Generic.Start.QuadPart = Start;
    Descriptor->u.Generic.Length = Requirement->u.Generic.Length;

    ARB_PRINT(2,
                ("Packing %s resource %p => 0x%I64x length 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                Descriptor->u.Port.Start.QuadPart,
                Descriptor->u.Port.Length
                ));

    return STATUS_SUCCESS;
}

NTSTATUS
IopGenericUnpackResource(
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks an resource descriptor.

Arguments:

    Descriptor - The descriptor describing the resource to unpack.

    Start - Pointer to where the start value should be unpacked to.

    Length - Pointer to where the length value should be unpacked to.

Return Value:

    Returns the status of this operation.

--*/

{

    PAGED_CODE();
    ASSERT(Descriptor);
    ASSERT(Descriptor->Type == CmResourceTypePort
           || Descriptor->Type == CmResourceTypeMemory);

    *Start = Descriptor->u.Generic.Start.QuadPart;
    *Length = Descriptor->u.Generic.Length;

    ARB_PRINT(2,
                ("Unpacking %s resource %p => 0x%I64x Length 0x%x\n",
                Descriptor->Type == CmResourceTypePort ? "port" : "memory",
                Descriptor,
                *Start,
                *Length
                ));

    return STATUS_SUCCESS;

}
#if 0
NTSTATUS
IopPortRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )

/*++

Routine Description:

    This providesa port specific implementation of the RetestAllocation action
    which takes into account ISA aliases and adds them where appropriate.
    It walks the arbitration list and updates the possible allocation to reflect
    the allocation entries of the list.  For these entries to be valid
    TestAllocation must have been performed on this arbitration list.

Parameters:

    Arbiter - The arbiter instance data for the arbiter being called.

    ArbitrationList - A list of ARBITER_LIST_ENTRY entries which contain the
        requirements and associated devices.  TestAllocation for this arbiter
        should have been called on this list.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    PARBITER_LIST_ENTRY current;
    PIO_RESOURCE_DESCRIPTOR alternative;
    ULONGLONG start;
    ULONG length;

    PAGED_CODE();

    //
    // Copy the current allocation and reserved
    //

    ARB_PRINT(3, ("Retest: Copy current allocation\n"));
    status = RtlCopyRangeList(Arbiter->PossibleAllocation, Arbiter->Allocation);

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Free all the resources currently allocated to all the devices we
    // are arbitrating for
    //

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current) {

        ARB_PRINT(2, ("Retest: Delete 0x%08x's resources\n", current->PhysicalDeviceObject));

        status = RtlDeleteOwnersRanges(Arbiter->PossibleAllocation,
                                       (PVOID) current->PhysicalDeviceObject
                                       );

        if (!NT_SUCCESS(status)) {
            goto cleanup;
        }
    }

    //
    // Copy the previous allocation into the range list
    //

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current) {

        ASSERT(current->Assignment);

        status = Arbiter->UnpackResource(current->Assignment,
                                         &start,
                                         &length
                                         );

        ASSERT(NT_SUCCESS(status));

        //
        // If we had a requirement for length 0 then that will be seen as
        // end == start - 1 here so don't attempt to add the range - it will
        // fail!
        //

        if (length != 0) {

            status = RtlAddRange(
                Arbiter->PossibleAllocation,
                start,
                start + length - 1,
                0,
                RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (current->Assignment->ShareDisposition == CmResourceShareShared ?
                        RTL_RANGE_LIST_ADD_SHARED : 0),
                NULL,
                current->PhysicalDeviceObject
                );

            ASSERT(NT_SUCCESS(status));

            //
            // Retireve the alternative from which the assignment was chosen from
            // then
            //

            alternative = current->SelectedAlternative;

            //
            // Add the aliases
            //

            if (alternative->Flags & CM_RESOURCE_PORT_10_BIT_DECODE
            || alternative->Flags & CM_RESOURCE_PORT_12_BIT_DECODE) {

                ULONGLONG alias = start;
                BOOLEAN shared = current->Assignment->ShareDisposition ==
                                     CmResourceShareShared;

                ARB_PRINT(3, ("Adding aliases\n"));

                while (IopPortGetNextAlias(alternative->Flags,
                                           alias,
                                           &alias)) {

                    status = RtlAddRange(
                                 Arbiter->PossibleAllocation,
                                 alias,
                                 alias + length - 1,
                                 ARBITER_RANGE_ALIAS,
                                 RTL_RANGE_LIST_ADD_IF_CONFLICT +
                                    (shared ? RTL_RANGE_LIST_SHARED_OK : 0),
                                 NULL,
                                 current->PhysicalDeviceObject
                                 );

                    //
                    // We have already checked if these ranges are available
                    // so we should not fail...
                    //

                    ASSERT(NT_SUCCESS(status));
                }
            }
        }
    }

    return status;

cleanup:

    RtlFreeRangeList(Arbiter->PossibleAllocation);
    return status;
}
#endif
VOID
IopPortBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )

/*++

Routine Description:

    This routine is called from AllocateEntry if the possible solution
    (State->Start - State->End) does not allow us to allocate resources to
    the rest of the devices being considered.  It deletes the ranges that were
    added to Arbiter->PossibleAllocation by AddAllocation including those
    associated with ISA aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/


{

    NTSTATUS status;
    ULONGLONG alias = State->Start;

    PAGED_CODE();

    //
    // Delete the aliases
    //

    ARB_PRINT(2, ("\t\tDeleting aliases\n"));

    while (IopPortGetNextAlias(State->CurrentAlternative->Flags,
                               alias,
                               &alias)) {

        status = RtlDeleteRange(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     State->Entry->PhysicalDeviceObject
                     );

        //
        // We should not fail...
        //

        ASSERT(NT_SUCCESS(status));
    }

    //
    // Now call the original function to delete the base range
    //

    ArbBacktrackAllocation(Arbiter, State);

}


BOOLEAN
IopPortFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts with ISA aliases are considered.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    NTSTATUS status;
    UCHAR userFlagsMask = 0;

    PAGED_CODE();

    //
    // If we are asking for zero ports then trivially succeed with the minimum
    // value
    //

    if (State->CurrentAlternative->Length == 0) {
        State->End = State->Start;
        return TRUE;
    }

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    // If we are allocating a devices boot config then we consider all other
    // boot configs to be available.
    //

    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned
        || State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {

        userFlagsMask = ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Try to satisfy the request
    //

    while (State->CurrentMinimum <= State->CurrentMaximum) {

        //
        // Select the first free alternative from the current alternative
        //

        status = RtlFindRange(
                     Arbiter->PossibleAllocation,
                     State->CurrentMinimum,
                     State->CurrentMaximum,
                     State->CurrentAlternative->Length,
                     State->CurrentAlternative->Alignment,
                     State->CurrentAlternative->Flags &
                        ARBITER_ALTERNATIVE_FLAG_SHARED ?
                            RTL_RANGE_LIST_SHARED_OK : 0,
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &State->Start
                     );


        //
        // Did we find a range and if not can we override any conflict
        //
        if (NT_SUCCESS(status)
        || Arbiter->OverrideConflict(Arbiter, State)) {

            State->End = State->Start + State->CurrentAlternative->Length - 1;

            //
            // Check if the aliases are available
            //
            if (IopPortIsAliasedRangeAvailable(Arbiter, State)) {

                //
                // We found a suitable range so return
                //

                return TRUE;

            } else {

                //
                // This range's aliases arn't available so try the next range
                //

                State->Start += State->CurrentAlternative->Length;

                continue;
            }
        } else {

            //
            // We couldn't find a base range
            //

            break;
        }
    }

    return FALSE;
}



BOOLEAN
IopPortGetNextAlias(
    ULONG IoDescriptorFlags,
    ULONGLONG LastAlias,
    PULONGLONG NextAlias
    )
/*++

Routine Description:

    This routine calculates the next alias of an IO port up to MAX_ALIAS_PORT.

Arguments:

    IoDescriptorFlags - The flags from the requirement descriptor indicating the
        type of alias if any.

    LastAlias - The alias previous to this one.

    NextAlias - Point to where the next alias should be returned

Return Value:

    TRUE if we found an alias, FALSE otherwise.

--*/

{
    ULONGLONG next;

    PAGED_CODE();

    if (IoDescriptorFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        next = LastAlias + (1 << 10);
    } else if (IoDescriptorFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        next = LastAlias + (1 << 12);
    } else {

        //
        // There are no aliases
        //

        return FALSE;
    }

    //
    // Check that we are below the maximum aliased port
    //

    if (next > MAX_ALIAS_PORT) {
        return FALSE;
    } else {
        *NextAlias = next;
        return TRUE;
    }
}


VOID
IopPortAddAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine is called from AllocateEntry once we have found a possible
    solution (State->Start - State->End).  It adds the ranges that will not be
    available if we commit to this solution to Arbiter->PossibleAllocation.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    ULONGLONG alias;

    PAGED_CODE();

    ASSERT(Arbiter);
    ASSERT(State);

    status = RtlAddRange(Arbiter->PossibleAllocation,
                 State->Start,
                 State->End,
                 State->RangeAttributes,
                 RTL_RANGE_LIST_ADD_IF_CONFLICT +
                    (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                        ? RTL_RANGE_LIST_ADD_SHARED : 0),
                 NULL,
                 State->Entry->PhysicalDeviceObject
                 );

    ASSERT(NT_SUCCESS(status));

    //
    // Add any aliases
    //

    alias = State->Start;
    ARB_PRINT(2, ("Adding aliases\n"));

    while (IopPortGetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlAddRange(Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     (UCHAR) (State->RangeAttributes | ARBITER_RANGE_ALIAS),
                     RTL_RANGE_LIST_ADD_IF_CONFLICT +
                        (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED
                            ? RTL_RANGE_LIST_ADD_SHARED : 0),
                     NULL,
                     State->Entry->PhysicalDeviceObject
                     );

        //
        // We have already checked if these ranges are available
        // so we should not fail...
        //

        ASSERT(NT_SUCCESS(status));
    }
}


BOOLEAN
IopPortIsAliasedRangeAvailable(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

Routine Description:

    This routine determines if the range (Start-(Length-1)) is available taking
    into account any aliases.

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if the range is available, FALSE otherwise.

--*/

{
    //
    // NTRAID #61146-2000/03/31-andrewth Root IO arbiter don't deal with aliases
    //
    // This is only an issue on machines where the root arbiters are called upon
    // to arbitrated aliased ranges - this means a pure ISA machine with no PCI.
    // I hope we won't support these soon and the root arbiters can be made a
    // lot worse.
    //

#if defined(BUGFEST_HACKS)

    UNREFERENCED_PARAMETER( Arbiter );
    UNREFERENCED_PARAMETER( State );

    PAGED_CODE();

    //
    // For the purposes of the Bug^H^H^HPlugFest don't mind is aliases conflict
    // with any devices but still add them...
    //
    return TRUE;
#else
    NTSTATUS status;
    ULONGLONG alias = State->Start;
    BOOLEAN aliasAvailable;
    UCHAR userFlagsMask = 0;

    PAGED_CODE();

    //
    // For legacy requests from IoAssignResources (directly or by way of
    // HalAssignSlotResources) or IoReportResourceUsage we consider preallocated
    // resources to be available for backward compatibility reasons.
    //
    if (State->Entry->RequestSource == ArbiterRequestLegacyReported
        || State->Entry->RequestSource == ArbiterRequestLegacyAssigned) {

        userFlagsMask |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    while (IopPortGetNextAlias(State->CurrentAlternative->Descriptor->Flags,
                             alias,
                             &alias)) {

        status = RtlIsRangeAvailable(
                     Arbiter->PossibleAllocation,
                     alias,
                     alias + State->CurrentAlternative->Length - 1,
                     State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED ?
                        RTL_RANGE_LIST_SHARED_OK : 0,
                     userFlagsMask,
                     Arbiter->ConflictCallbackContext,
                     Arbiter->ConflictCallback,
                     &aliasAvailable
                     );

        ASSERT(NT_SUCCESS(status));

        if (!aliasAvailable) {

            ARBITER_ALLOCATION_STATE tempState;

            //
            // Check if we allow this conflict by calling OverrideConflict -
            // we will need to falsify ourselves an allocation state first
            //

            RtlCopyMemory(&tempState, State, sizeof(ARBITER_ALLOCATION_STATE));

            tempState.CurrentMinimum = alias;
            tempState.CurrentMaximum = alias + State->CurrentAlternative->Length - 1;

            if (Arbiter->OverrideConflict(Arbiter, &tempState)) {
                //
                // We decided this conflict was ok so contine checking the rest
                // of the aliases
                //

                continue;

            }

            //
            // An alias isn't available - get another possibility
            //

            ARB_PRINT(2,
                        ("\t\tAlias 0x%x-0x%x not available\n",
                        alias,
                        alias + State->CurrentAlternative->Length - 1
                        ));

            return FALSE;
        }
    }

    return TRUE;
#endif
}

BOOLEAN
IopMemFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry once we have decided where we want
    to allocate from.  It tries to find a free range that matches the
    requirements in State while restricting its possible solutions to the range
    State->Start to State->CurrentMaximum.  On success State->Start and
    State->End represent this range.  Conflicts between boot configs are allowed

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    TRUE if we found a range, FALSE otherwise.

--*/
{
    //
    // If this was a boot config then consider other boot configs to be
    // available
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
    }

    //
    // Do the default thing
    //

    return ArbFindSuitableRange(Arbiter, State);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpmgrp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpmgrp.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

Author:

    Nar Ganapathy (narg) 1-Jan-1999


Revision History:

--*/

#ifndef _PNPMGRP_
#define _PNPMGRP_

#ifndef FAR
#define FAR
#endif

#define RTL_USE_AVL_TABLES 0

#include "ntos.h"
#include "zwapi.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "iopcmn.h"

#include "ppmacro.h"
#include "ppdebug.h"
#include "pnpi.h"
#include "arbiter.h"
#include "dockintf.h"
#include "pnprlist.h"

#include "ioverifier.h"
#include "iofileutil.h"
#include "pnpiop.h"
#include "pphotswap.h"
#include "ppprofile.h"
#include "pphandle.h"
#include "ppvutil.h"
#include "ppdrvdb.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  pP')
#undef ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  pP')
#endif

//
// For XP SP1, we could not do any UI change, so these are temporary place holders.
//
#define STATUS_PNP_INVALID_ID   ((NTSTATUS)0xC0040038L)
#define PpSetInvalidIDEvent(s)

#define FAULT_INJECT_INVALID_ID 1

#endif // _PNPMGRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnppower.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pnppower.c

Abstract:

    This file contains the routines that integrate PnP and Power

Author:

    Adrian J. Oney (AdriaO) 01-19-1999

Revision History:

    Modified for nt kernel.

--*/

#include "pnpmgrp.h"

//
// Internal References
//

PWCHAR
IopCaptureObjectName (
    IN PVOID    Object
    );

VOID
IopFreePoDeviceNotifyListHead (
    PLIST_ENTRY ListHead
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopWarmEjectDevice)
#pragma alloc_text(PAGELK, IoBuildPoDeviceNotifyList)
#pragma alloc_text(PAGELK, IoFreePoDeviceNotifyList)
#pragma alloc_text(PAGELK, IopFreePoDeviceNotifyListHead)
#pragma alloc_text(PAGELK, IoGetPoNotifyParent)
#pragma alloc_text(PAGELK, IoMovePoNotifyChildren)
#pragma alloc_text(PAGELK, IopCaptureObjectName)
#endif

NTSTATUS
IoBuildPoDeviceNotifyList (
    IN OUT PPO_DEVICE_NOTIFY_ORDER  Order
    )
{
    PLIST_ENTRY             link;
    PPO_DEVICE_NOTIFY       notify, parentnotify;
    PDEVICE_NODE            node;
    PDEVICE_NODE            parent;
    ULONG                   noLists, listIndex;
    PLIST_ENTRY             notifyLists;
    LONG                    maxLevel, level;
    UCHAR                   orderLevel;
    PDEVICE_OBJECT          nonPaged;
    PDEVICE_OBJECT          current;
    PDEVICE_OBJECT          next;
    LIST_ENTRY              RebaseList;
    ULONG i;

    //
    // Block PnP operations like rebalance.
    //
    PiLockDeviceActionQueue();

    RtlZeroMemory(Order, sizeof (*Order));
    Order->DevNodeSequence = IoDeviceNodeTreeSequence;
    for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
        KeInitializeEvent(&Order->OrderLevel[i].LevelReady,
                          NotificationEvent,
                          FALSE);
        InitializeListHead(&Order->OrderLevel[i].WaitSleep);
        InitializeListHead(&Order->OrderLevel[i].ReadySleep);
        InitializeListHead(&Order->OrderLevel[i].Pending);
        InitializeListHead(&Order->OrderLevel[i].Complete);
        InitializeListHead(&Order->OrderLevel[i].ReadyS0);
        InitializeListHead(&Order->OrderLevel[i].WaitS0);
    }

    InitializeListHead(&RebaseList);

    //
    // Allocate notification structures for all nodes, and determine
    // maximum depth.
    //
    level = -1;
    node = IopRootDeviceNode;
    while (node->Child) {
        node = node->Child;
        level += 1;
    }

    //
    // ADRIAO 01/12/1999 N.B. -
    //
    // Note that we include devices without the started flag. However, two
    // things prevent us from excluding devices that aren't started:
    // 1) We must be able to send power messages to a device we are warm
    //    undocking.
    // 2) Many devices may not be started, that is no guarentee they are in D3!
    //    For example, they could easily have a boot config, and PNP still
    //    relies heavily on BIOS boot configs to keep us from placing hardware
    //    ontop of other devices with boot configs we haven't found or started
    //    yet!
    //

    maxLevel = level;
    while (node != IopRootDeviceNode) {
        notify = ExAllocatePoolWithTag (
                      NonPagedPool,
                      sizeof(PO_DEVICE_NOTIFY),
                      IOP_DPWR_TAG
                      );

        if (!notify) {

            PiUnlockDeviceActionQueue();
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory (notify, sizeof(PO_DEVICE_NOTIFY));
        ASSERT(node->Notify == NULL) ;
        node->Notify = notify;
        notify->Node = node;
        notify->DeviceObject = node->PhysicalDeviceObject;
        notify->TargetDevice = IoGetAttachedDevice(node->PhysicalDeviceObject);
        notify->DriverName   = IopCaptureObjectName(notify->TargetDevice->DriverObject);
        notify->DeviceName   = IopCaptureObjectName(notify->TargetDevice);
        ObReferenceObject (notify->DeviceObject);
        ObReferenceObject (notify->TargetDevice);

        orderLevel   = 0;

        if (notify->TargetDevice->DeviceType != FILE_DEVICE_SCREEN &&
            notify->TargetDevice->DeviceType != FILE_DEVICE_VIDEO) {
            orderLevel |= PO_ORDER_NOT_VIDEO;
        }

        if (notify->TargetDevice->Flags & DO_POWER_PAGABLE) {
            orderLevel |= PO_ORDER_PAGABLE;
        }

        //
        // If this is a level 0 node it's in the root.  Look for
        // non-bus stuff in the root as those guys need to be re-based
        // below everything else.
        //


        notify->OrderLevel = orderLevel;

        //
        // If the node is root-enumerated, put it on the rebase list so
        // we can mark all its children later.
        // If the node is a leaf node it is ready to receive Sx irps.
        // If it has children, it must wait for its children to complete their Sx irps.
        //
        //
        if ((level == 0)  &&
            (node->InterfaceType != Internal) &&
            !(node->Flags & DNF_HAL_NODE)) {
            InsertHeadList(&RebaseList, &notify->Link);
        } else {
            ++Order->OrderLevel[orderLevel].DeviceCount;
            if (node->Child == NULL) {
                InsertHeadList(&Order->OrderLevel[orderLevel].ReadySleep, &notify->Link);
            } else {
                InsertHeadList(&Order->OrderLevel[orderLevel].WaitSleep, &notify->Link);
            }
        }
        //
        // Next node
        //

        if (node->Sibling) {
            node = node->Sibling;
            while (node->Child) {
                node = node->Child;
                level += 1;
                if (level > maxLevel) {
                    maxLevel = level;
                }
            }

        } else {
            node = node->Parent;
            level -= 1;
        }
    }

    //
    // Rebase anything on the rebase list to be after the normal pnp stuff
    //

    while (!IsListEmpty(&RebaseList)) {
        link = RemoveHeadList(&RebaseList);
        notify = CONTAINING_RECORD (link, PO_DEVICE_NOTIFY, Link);

        //
        // Rebase this node
        //

        node = notify->Node;
        notify->OrderLevel |= PO_ORDER_ROOT_ENUM;

        ++Order->OrderLevel[notify->OrderLevel].DeviceCount;
        if (node->Child == NULL) {
            InsertHeadList(&Order->OrderLevel[notify->OrderLevel].ReadySleep, &notify->Link);
        } else {
            InsertHeadList(&Order->OrderLevel[notify->OrderLevel].WaitSleep, &notify->Link);
        }
        //
        // Now rebase all the node's children
        //

        parent = node;
        while (node->Child) {
            node = node->Child;
        }

        while (node != parent) {
            notify = node->Notify;
            if (notify) {
                RemoveEntryList(&notify->Link);
                --Order->OrderLevel[notify->OrderLevel].DeviceCount;
                notify->OrderLevel |= PO_ORDER_ROOT_ENUM;
                ++Order->OrderLevel[notify->OrderLevel].DeviceCount;
                if (node->Child == NULL) {
                    InsertHeadList(&Order->OrderLevel[notify->OrderLevel].ReadySleep, &notify->Link);
                } else {
                    InsertHeadList(&Order->OrderLevel[notify->OrderLevel].WaitSleep, &notify->Link);
                }
            }

            // next node
            if (node->Sibling) {
                node = node->Sibling;
                while (node->Child) {
                    node = node->Child;
                }
            } else {
                node = node->Parent;
            }
        }
    }

    //
    // make one more pass through all the notify devices in order to count
    // the children of each parent. It would be nice if the PNP engine kept
    // track of the number of children in the devnode, but until that is done,
    // we need this second pass.
    //
    // Also make sure that each node's parent is an order level >= its children.
    //
    node = IopRootDeviceNode;
    while (node->Child) {
        node = node->Child;
    }
    while (node != IopRootDeviceNode) {
        if (node->Parent != IopRootDeviceNode) {
            parentnotify = node->Parent->Notify;
            parentnotify->ChildCount++;
            parentnotify->ActiveChild++;
            if (parentnotify->OrderLevel > node->Notify->OrderLevel) {

                //
                // The parent is a higher order level than its child. Move the
                // parent down to the same order as its child
                //
                RemoveEntryList(&parentnotify->Link);
                --Order->OrderLevel[parentnotify->OrderLevel].DeviceCount;
                parentnotify->OrderLevel = node->Notify->OrderLevel;
                ++Order->OrderLevel[parentnotify->OrderLevel].DeviceCount;
                InsertHeadList(&Order->OrderLevel[parentnotify->OrderLevel].WaitSleep, &parentnotify->Link);
            }
        }

        //
        // Next node
        //

        if (node->Sibling) {
            node = node->Sibling;
            while (node->Child) {
                node = node->Child;
            }
        } else {
            node = node->Parent;
        }
    }

    Order->WarmEjectPdoPointer = &IopWarmEjectPdo;

    //
    // The engine lock is release when the notify list is freed
    //

    return STATUS_SUCCESS;
}


PVOID
IoGetPoNotifyParent(
    IN PPO_DEVICE_NOTIFY Notify
    )
/*++

Routine Description:

    Returns the notify structure of the specified device's parent.

Arguments:

    Notify - Supplies the child device

Return Value:

    Parent's notify structure if present
    NULL if there is no parent

--*/

{
    PDEVICE_NODE Node;

    Node = Notify->Node;
    if (Node->Parent != IopRootDeviceNode) {
        return(Node->Parent->Notify);
    } else {
        return(NULL);
    }
}


VOID
IoMovePoNotifyChildren(
    IN PPO_DEVICE_NOTIFY Notify,
    IN PPO_DEVICE_NOTIFY_ORDER Order
    )
/*++

Routine Description:

    Removes any children of the supplied device that are at the
    same orderlevel as the supplied parent and reinserts them
    on the ReadyS0 list.

Arguments:

    Notify - Supplies the device notify structure

    Orderr - Supplies the device notification order structure

Return Value:

    None

--*/

{
    PDEVICE_NODE Node;
    PDEVICE_NODE Child;
    PPO_DEVICE_NOTIFY ChildNotify;
    PPO_NOTIFY_ORDER_LEVEL Level;

    Node = Notify->Node;
    Child = Node->Child;
    while (Child) {
        ChildNotify = Child->Notify;
        if (ChildNotify->OrderLevel == Notify->OrderLevel) {
            RemoveEntryList(&ChildNotify->Link);
            Level = &Order->OrderLevel[ChildNotify->OrderLevel];
            InsertTailList(&Level->ReadyS0, &ChildNotify->Link);
        }
        Child = Child->Sibling;
    }


}

VOID
IopFreePoDeviceNotifyListHead (
    PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY             Link;
    PPO_DEVICE_NOTIFY       Notify;
    PDEVICE_NODE            Node;

    while (!IsListEmpty(ListHead)) {
        Link = RemoveHeadList(ListHead);
        Notify = CONTAINING_RECORD (Link, PO_DEVICE_NOTIFY, Link);

        Node = (PDEVICE_NODE) Notify->Node;
        Node->Notify = NULL;

        ObDereferenceObject (Notify->DeviceObject);
        ObDereferenceObject (Notify->TargetDevice);
        if (Notify->DeviceName) {
            ExFreePool (Notify->DeviceName);
        }
        if (Notify->DriverName) {
            ExFreePool (Notify->DriverName);
        }
        ExFreePool(Notify);
    }
}

VOID
IoFreePoDeviceNotifyList (
    IN OUT PPO_DEVICE_NOTIFY_ORDER  Order
    )
{
    ULONG                   i;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY Link;
    PPO_DEVICE_NOTIFY Notify;

    if (Order->DevNodeSequence) {

        Order->DevNodeSequence = 0;

        PiUnlockDeviceActionQueue();
    }

    //
    // Free the resources from the notify list
    //
    for (i=0; i <= PO_ORDER_MAXIMUM; i++) {
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].WaitSleep);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].ReadySleep);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].Pending);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].Complete);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].ReadyS0);
        IopFreePoDeviceNotifyListHead(&Order->OrderLevel[i].WaitS0);
    }

}


PWCHAR
IopCaptureObjectName (
    IN PVOID    Object
    )
{
    NTSTATUS                    Status;
    UCHAR                       Buffer[512];
    POBJECT_NAME_INFORMATION    ObName;
    ULONG                       len;
    PWCHAR                      Name;

    ObName = (POBJECT_NAME_INFORMATION) Buffer;
    Status = ObQueryNameString (
                Object,
                ObName,
                sizeof (Buffer),
                &len
                );

    Name = NULL;
    if (NT_SUCCESS(Status) && ObName->Name.Buffer) {
        Name = ExAllocatePoolWithTag (
                    NonPagedPool,
                    ObName->Name.Length + sizeof(WCHAR),
                    IOP_DPWR_TAG
                    );

        if (Name) {
            memcpy (Name, ObName->Name.Buffer, ObName->Name.Length);
            Name[ObName->Name.Length/sizeof(WCHAR)] = 0;
        }
    }

    return Name;
}

NTSTATUS
IopWarmEjectDevice(
   IN PDEVICE_OBJECT       DeviceToEject,
   IN SYSTEM_POWER_STATE   LightestSleepState
   )
/*++

Routine Description:

    This function is invoked to initiate a warm eject. The eject progresses
    from S1 to the passed in lightest sleep state.

Arguments:

    DeviceToEject       - The device to eject

    LightestSleepState  - The lightest S state (at least S1) that the device
                          may be ejected in. This might be S4 if we are truely
                          low on power.

Return Value:

    NTSTATUS value.

--*/
{
    NTSTATUS       status;

    PAGED_CODE();

    //
    // Acquire the warm eject device lock. A warm eject requires we enter a
    // specific S-state, and two different devices may have conflicting options.
    // Therefore only one is allowed to occur at once.
    //
    status = KeWaitForSingleObject(
        &IopWarmEjectLock,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(status == STATUS_SUCCESS) ;

    //
    // Acquire engine lock. We are not allowed to set or clear this field
    // unless we are under this lock.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Set the current Pdo to eject.
    //
    ASSERT(IopWarmEjectPdo == NULL);
    IopWarmEjectPdo = DeviceToEject;

    //
    // Release the engine lock.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Attempt to invalidate Po's cached notification list. This should cause
    // IoBuildPoDeviceNotifyList to be called at which time it will in theory
    // pickup the above placed warm eject Pdo.
    //
    // ADRIAO NOTE 01/07/1999 -
    //     Actually, this whole IoDeviceNodeTreeSequence stuff isn't neccessary.
    // PnP will make no changes to the tree while the device tree lock is owned,
    // and it's owned for the duration of a power notification.
    //
    IoDeviceNodeTreeSequence++;

    //
    // Sleep...
    //
    status = NtInitiatePowerAction(
        PowerActionWarmEject,
        LightestSleepState,
        POWER_ACTION_QUERY_ALLOWED |
        POWER_ACTION_UI_ALLOWED,
        FALSE // Asynchronous == FALSE
        );

    //
    // Acquire the engine lock. We are not allowed to set or clear this field
    // unless we are under this lock.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Clear the current PDO to eject, and see if the Pdo was actually picked
    // up.
    //
    if (IopWarmEjectPdo) {

        if (NT_SUCCESS(status)) {

            //
            // If our device wasn't picked up, the return of
            // NtInitiatePowerAction should *not* be successful!
            //
            ASSERT(0);
            status = STATUS_UNSUCCESSFUL;
        }

        IopWarmEjectPdo = NULL;
    }

    //
    // Release the engine lock.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Release the warm eject device lock
    //
    KeSetEvent(
        &IopWarmEjectLock,
        IO_NO_INCREMENT,
        FALSE
        );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpmap.c ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pnpmap.c

Abstract:

    This module contains the code that translates the device info returned from
    the PnP BIOS into root enumerated devices.

Author:

    Robert B. Nelson (RobertN) 22-Sep-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pnpmgrp.h"
#pragma hdrstop
#include "pnpcvrt.h"
#include "pbios.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PpaM')
#endif

#if UMODETEST
#define MULTIFUNCTION_KEY_NAME L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\TestSystem\\MultifunctionAdapter"
#define ENUMROOT_KEY_NAME L"\\Registry\\Machine\\System\\TestControlSet\\Enum\\Root"
#else
#define MULTIFUNCTION_KEY_NAME L"\\Registry\\Machine\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter"
#define ENUMROOT_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Enum\\Root"
#endif

#define BIOSINFO_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Biosinfo\\PNPBios"
#define DISABLENODES_VALUE_NAME L"DisableNodes"
#define DECODEINFO_VALUE_NAME L"FullDecodeChipsetOverride"

#define INSTANCE_ID_PREFIX      L"PnPBIOS_"

#define DEFAULT_STRING_SIZE     80
#define DEFAULT_VALUE_SIZE      80

#define DEFAULT_DEVICE_DESCRIPTION  L"Unknown device class"


#define EXCLUSION_ENTRY(a)  { a, sizeof(a) - sizeof(UNICODE_NULL) }

typedef struct  _EXCLUDED_PNPNODE  {
    PWCHAR  Id;
    ULONG   IdLength;
} EXCLUDED_PNPNODE, *PEXCLUDED_PNPNODE;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const EXCLUDED_PNPNODE ExcludedDevices[] =  {
    EXCLUSION_ENTRY(L"*PNP03"),     // Keyboards
    EXCLUSION_ENTRY(L"*PNP0A"),     // PCI Busses
    EXCLUSION_ENTRY(L"*PNP0E"),     // PCMCIA Busses
    EXCLUSION_ENTRY(L"*PNP0F"),     // Mice
    EXCLUSION_ENTRY(L"*IBM3780"),   // IBM Trackpoint Mouse
    EXCLUSION_ENTRY(L"*IBM3781")    // IBM Trackpoint Mouse
};

#define EXCLUDED_DEVICES_COUNT  (sizeof(ExcludedDevices) / sizeof(ExcludedDevices[0]))

const EXCLUDED_PNPNODE ExcludeIfDisabled[] = {
    EXCLUSION_ENTRY(L"*PNP0C01"),   // Motherboard resources
    EXCLUSION_ENTRY(L"*PNP0C02")    // Motherboard resources
};

#define EXCLUDE_DISABLED_COUNT  (sizeof(ExcludeIfDisabled) / sizeof(ExcludeIfDisabled[0]))

typedef struct _CLASSDATA {
    ULONG   Value;
    PWCHAR  Description;
} CLASSDATA;

const CLASSDATA Class1Descriptions[] = {
    { 0x0000, L"SCSI Controller" },
    { 0x0100, L"IDE Controller" },
    { 0x0200, L"Floppy Controller" },
    { 0x0300, L"IPI Controller" },
    { 0x0400, L"RAID Controller" },
    { 0x8000, L"Other Mass Storage" }
};

const CLASSDATA Class2Descriptions[] = {
    { 0x0000, L"Ethernet" },
    { 0x0100, L"Token ring" },
    { 0x0200, L"FDDI" },
    { 0x0300, L"ATM" },
    { 0x8000, L"Other network" }
};

const CLASSDATA Class3Descriptions[] = {
    { 0x0000, L"VGA" },
    { 0x0001, L"SVGA" },
    { 0x0100, L"XGA" },
    { 0x8000, L"Other display" }
};

const CLASSDATA Class4Descriptions[] = {
    { 0x0000, L"Video device" },
    { 0x0100, L"Audio device" },
    { 0x8000, L"Other multimedia" }
};

const CLASSDATA Class5Descriptions[] = {
    { 0x0000, L"RAM memory" },
    { 0x0100, L"Flash memory" },
    { 0x8000, L"Other memory" }
};

const CLASSDATA Class6Descriptions[] = {
    { 0x0000, L"HOST / PCI" },
    { 0x0100, L"PCI / ISA" },
    { 0x0200, L"PCI / EISA" },
    { 0x0300, L"PCI / MCA" },
    { 0x0400, L"PCI / PCI" },
    { 0x0500, L"PCI / PCMCIA" },
    { 0x0600, L"NuBus" },
    { 0x0700, L"Cardbus" },
    { 0x8000, L"Other bridge" }
};

const CLASSDATA Class7Descriptions[] = {
    { 0x0000, L"XT Serial" },
    { 0x0001, L"16450" },
    { 0x0002, L"16550" },
    { 0x0100, L"Parallel output only" },
    { 0x0101, L"BiDi Parallel" },
    { 0x0102, L"ECP 1.x parallel" },
    { 0x8000, L"Other comm" }
};

const CLASSDATA Class8Descriptions[] = {
    { 0x0000, L"Generic 8259" },
    { 0x0001, L"ISA PIC" },
    { 0x0002, L"EISA PIC" },
    { 0x0100, L"Generic 8237" },
    { 0x0101, L"ISA DMA" },
    { 0x0102, L"EISA DMA" },
    { 0x0200, L"Generic 8254" },
    { 0x0201, L"ISA timer" },
    { 0x0202, L"EISA timer" },
    { 0x0300, L"Generic RTC" },
    { 0x0301, L"ISA RTC" },
    { 0x8000, L"Other system device" }
};

const CLASSDATA Class9Descriptions[] = {
    { 0x0000, L"Keyboard" },
    { 0x0100, L"Digitizer" },
    { 0x0200, L"Mouse" },
    { 0x8000, L"Other input" }
};

const CLASSDATA Class10Descriptions[] = {
    { 0x0000, L"Generic dock" },
    { 0x8000, L"Other dock" },
};

const CLASSDATA Class11Descriptions[] = {
    { 0x0000, L"386" },
    { 0x0100, L"486" },
    { 0x0200, L"Pentium" },
    { 0x1000, L"Alpha" },
    { 0x4000, L"Co-processor" }
};

const CLASSDATA Class12Descriptions[] = {
    { 0x0000, L"Firewire" },
    { 0x0100, L"Access bus" },
    { 0x0200, L"SSA" },
    { 0x8000, L"Other serial bus" }
};

#define CLASSLIST_ENTRY(a)   { a, sizeof(a) / sizeof(a[0]) }

struct _CLASS_DESCRIPTIONS_LIST  {

    CLASSDATA const*Descriptions;
    ULONG      Count;

}   const ClassDescriptionsList[] =  {
    { NULL, 0 },
    CLASSLIST_ENTRY( Class1Descriptions ),
    CLASSLIST_ENTRY( Class2Descriptions ),
    CLASSLIST_ENTRY( Class3Descriptions ),
    CLASSLIST_ENTRY( Class4Descriptions ),
    CLASSLIST_ENTRY( Class5Descriptions ),
    CLASSLIST_ENTRY( Class6Descriptions ),
    CLASSLIST_ENTRY( Class7Descriptions ),
    CLASSLIST_ENTRY( Class8Descriptions ),
    CLASSLIST_ENTRY( Class9Descriptions ),
    CLASSLIST_ENTRY( Class10Descriptions ),
    CLASSLIST_ENTRY( Class11Descriptions ),
    CLASSLIST_ENTRY( Class12Descriptions )

};

#define CLASSLIST_COUNT  ( sizeof(ClassDescriptionsList) / sizeof(ClassDescriptionsList[0]) )

typedef struct _BIOS_DEVNODE_INFO  {
    WCHAR   ProductId[10];  // '*' + 7 char ID + NUL + NUL for REG_MULTI_SZ
    UCHAR   Handle;         // BIOS Node # / Handle
    UCHAR   TypeCode[3];
    USHORT  Attributes;
    PWSTR   Replaces;       // Instance ID of Root enumerated device being replaced

    PCM_RESOURCE_LIST               BootConfig;
    ULONG                           BootConfigLength;
    PIO_RESOURCE_REQUIREMENTS_LIST  BasicConfig;
    ULONG                           BasicConfigLength;
    PWSTR                           CompatibleIDs;  // REG_MULTI_SZ list of compatible IDs (including ProductId)
    ULONG                           CompatibleIDsLength;
    BOOLEAN                         FirmwareDisabled; // determined that it's disabled by firmware

}   BIOS_DEVNODE_INFO, *PBIOS_DEVNODE_INFO;

NTSTATUS
PbBiosResourcesToNtResources (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PUCHAR *BiosData,
    OUT PIO_RESOURCE_REQUIREMENTS_LIST *ReturnedList,
    OUT PULONG ReturnedLength
    );

VOID
PnPBiosExpandProductId(
    PUCHAR CompressedId,
    PWCHAR ProductIDStr
    );

NTSTATUS
PnPBiosIoResourceListToCmResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    OUT PCM_RESOURCE_LIST *CmResourceList,
    OUT ULONG *CmResourceListSize
    );

NTSTATUS
PnPBiosExtractCompatibleIDs(
    IN  PUCHAR *DevNodeData,
    IN  ULONG DevNodeDataLength,
    OUT PWSTR *CompatibleIDs,
    OUT ULONG *CompatibleIDsLength
    );

NTSTATUS
PnPBiosTranslateInfo(
    IN VOID *BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PBIOS_DEVNODE_INFO *DevNodeInfoList,
    OUT ULONG *NumberNodes
    );

LONG
PnPBiosFindMatchingDevNode(
    IN PWCHAR MapperName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

NTSTATUS
PnPBiosEliminateDupes(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

PWCHAR
PnPBiosGetDescription(
    IN PBIOS_DEVNODE_INFO DevNodeInfoEntry
    );

NTSTATUS
PnPBiosWriteInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

VOID
PnPBiosCopyIoDecode(
    IN HANDLE EnumRootKey,
    IN PBIOS_DEVNODE_INFO DevNodeInfo
    );

NTSTATUS
PnPBiosFreeDevNodeInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    );

NTSTATUS
PnPBiosCheckForHardwareDisabled(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    IN OUT PBOOLEAN Disabled
    );

BOOLEAN
PnPBiosCheckForExclusion(
    IN EXCLUDED_PNPNODE const* ExclusionArray,
    IN ULONG ExclusionCount,
    IN PWCHAR PnpDeviceName,
    IN PWCHAR PnpCompatIds
    );

NTSTATUS
PnPBiosMapper(
    VOID
    );

VOID
PpFilterNtResource (
    IN PWCHAR PnpDeviceName,
    PIO_RESOURCE_REQUIREMENTS_LIST ResReqList
    );

NTSTATUS
ComPortDBAdd(
    IN  HANDLE  DeviceParamKey,
    IN  PWSTR   PortName
    );

#ifdef ALLOC_PRAGMA
BOOLEAN
PnPBiosIgnoreNode (
    PWCHAR PnpID,
    PWCHAR excludeNodes
    );
PKEY_VALUE_FULL_INFORMATION
PnPGetBiosInfoValue(
    PWCHAR ValueName
    );
NTSTATUS
PnPBiosCopyDeviceParamKey(
    IN HANDLE EnumRootKey,
    IN PWCHAR SourcePath,
    IN PWCHAR DestinationPath
    );
#pragma alloc_text(INIT, PnPBiosExpandProductId)
#pragma alloc_text(INIT, PnPBiosIgnoreNode)
#pragma alloc_text(INIT, PnPGetBiosInfoValue)
#pragma alloc_text(INIT, PnPBiosIoResourceListToCmResourceList)
#pragma alloc_text(INIT, PnPBiosExtractCompatibleIDs)
#pragma alloc_text(INIT, PnPBiosTranslateInfo)
#pragma alloc_text(INIT, PnPBiosFindMatchingDevNode)
#pragma alloc_text(INIT, PnPBiosEliminateDupes)
#pragma alloc_text(INIT, PnPBiosGetDescription)
#pragma alloc_text(INIT, PnPBiosCopyDeviceParamKey)
#pragma alloc_text(INIT, PnPBiosWriteInfo)
#pragma alloc_text(INIT, PnPBiosCopyIoDecode)
#pragma alloc_text(INIT, PnPBiosFreeDevNodeInfo)
#pragma alloc_text(INIT, PnPBiosCheckForHardwareDisabled)
#pragma alloc_text(INIT, PnPBiosCheckForExclusion)
#pragma alloc_text(INIT, PnPBiosMapper)
#pragma alloc_text(INIT, PpFilterNtResource)
#pragma alloc_text(PAGE, PnPBiosGetBiosInfo)
#endif

NTSTATUS
PnPBiosGetBiosInfo(
    OUT PVOID *BiosInfo,
    OUT ULONG *BiosInfoLength
    )
/*++

Routine Description:

    This function retrieves the PnP BIOS info accumulated by NTDETECT.COM and
    placed in the registry.

Arguments:

    BiosInfo - Set to a dynamically allocated block of information retrieved
        from the PnP BIOS by NTDETECT.  This block should be freed using
        ExFreePool.  The contents of the block are the PnP BIOS
        Installation Check Structure followed by the DevNode Structures reported
        by the BIOS.  The detailed format is documented in the PnP BIOS spec.

    BiosInfoLength - Length of the block whose address is stored in BiosInfo.


Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    UNICODE_STRING                  multifunctionKeyName, biosKeyName, valueName;
    HANDLE                          multifunctionKey = NULL, biosKey = NULL;
    PKEY_BASIC_INFORMATION          keyBasicInfo = NULL;
    ULONG                           keyBasicInfoLength;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;

    PCM_FULL_RESOURCE_DESCRIPTOR    biosValue;

    ULONG                           index;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;

    //
    // The PnP BIOS info is written to one of the subkeys under
    // MULTIFUNCTION_KEY_NAME.  The appropriate key is determined by
    // enumerating the subkeys and using the first one which has a value named
    // "Identifier" that is "PNP BIOS".
    //

    PiWstrToUnicodeString(&multifunctionKeyName, MULTIFUNCTION_KEY_NAME);

    status = IopOpenRegistryKeyEx( &multifunctionKey,
                                   NULL,
                                   &multifunctionKeyName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "Could not open %S, status = %8.8X\n",
                    MULTIFUNCTION_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Allocate memory for key names returned from ZwEnumerateKey and values
    // returned from ZwQueryValueKey.
    //
    keyBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    keyBasicInfo = ExAllocatePool(PagedPool, keyBasicInfoLength + sizeof(UNICODE_NULL));

    if (keyBasicInfo == NULL)  {

        ZwClose( multifunctionKey );

        return STATUS_NO_MEMORY;
    }

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (valueInfo == NULL)  {

        ExFreePool( keyBasicInfo );

        ZwClose( multifunctionKey );

        return STATUS_NO_MEMORY;
    }

    //
    // Enumerate each key under HKLM\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter
    // to locate the one representing the PnP BIOS information.
    //
    for (index = 0; ; index++) {

        status = ZwEnumerateKey( multifunctionKey,   // handle of key to enumerate
                                 index,              // index of subkey to enumerate
                                 KeyBasicInformation,
                                 keyBasicInfo,
                                 keyBasicInfoLength,
                                 &returnedLength);

        if (!NT_SUCCESS(status)) {

            if (status != STATUS_NO_MORE_ENTRIES)  {

                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not enumerate under key %S, status = %8.8X\n",
                            MULTIFUNCTION_KEY_NAME,
                            status) );
            }

            break;
        }

        //
        // We found a subkey, NUL terminate the name and open the subkey.
        //
        keyBasicInfo->Name[ keyBasicInfo->NameLength / 2 ] = L'\0';

        RtlInitUnicodeString(&biosKeyName, keyBasicInfo->Name);

        status = IopOpenRegistryKeyEx( &biosKey,
                                       multifunctionKey,
                                       &biosKeyName,
                                       KEY_READ
                                       );

        if (!NT_SUCCESS(status)) {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Could not open registry key %S\\%S, status = %8.8X\n",
                        MULTIFUNCTION_KEY_NAME,
                        keyBasicInfo->Name,
                        status) );
            break;
        }

        //
        // Now we need to check the Identifier value in the subkey to see if
        // it is PNP BIOS.
        //
        PiWstrToUnicodeString(&valueName, L"Identifier");

        status = ZwQueryValueKey( biosKey,
                                  &valueName,
                                  KeyValuePartialInformation,
                                  valueInfo,
                                  valueInfoLength,
                                  &returnedLength);


        // lets see if its the PNP BIOS identifier
        if (NT_SUCCESS(status)) {

            if (wcscmp((PWSTR)valueInfo->Data, L"PNP BIOS") == 0) {

                //
                // We found the PnP BIOS subkey, retrieve the BIOS info which
                // is stored in the "Configuration Data" value.
                //
                // We'll start off with our default value buffer and increase
                // its size if necessary.
                //

                PiWstrToUnicodeString(&valueName, L"Configuration Data");

                status = ZwQueryValueKey( biosKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength);

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // The default buffer was too small, free it and reallocate
                        // it to the required size.
                        //
                        ExFreePool( valueInfo );

                        valueInfoLength = returnedLength;
                        valueInfo = ExAllocatePool( PagedPool, valueInfoLength );

                        if (valueInfo != NULL)  {

                            status = ZwQueryValueKey( biosKey,
                                                      &valueName,
                                                      KeyValuePartialInformation,
                                                      valueInfo,
                                                      valueInfoLength,
                                                      &returnedLength );
                        } else {

                            status = STATUS_NO_MEMORY;
                        }
                    }
                }

                if (NT_SUCCESS(status)) {

                    //
                    // We now have the PnP BIOS data but it is buried inside
                    // the resource structures.  Do some consistency checks and
                    // then extract it into its own buffer.
                    //

                    ASSERT(valueInfo->Type == REG_FULL_RESOURCE_DESCRIPTOR);

                    biosValue = (PCM_FULL_RESOURCE_DESCRIPTOR)valueInfo->Data;

                    //
                    // The WMI folks added another list so we should search for
                    // the PnPBIOS one, but for now the BIOS one is always
                    // first.
                    //

                    *BiosInfoLength = biosValue->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize;
                    *BiosInfo = ExAllocatePool(PagedPool, *BiosInfoLength);

                    if (*BiosInfo != NULL) {

                        RtlCopyMemory( *BiosInfo,
                                       &biosValue->PartialResourceList.PartialDescriptors[1],
                                       *BiosInfoLength );

                        status = STATUS_SUCCESS;

                    } else {

                        *BiosInfoLength = 0;

                        status = STATUS_NO_MEMORY;
                    }

                } else {

                    IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                "Error retrieving %S\\%S\\Configuration Data, status = %8.8X\n",
                                MULTIFUNCTION_KEY_NAME,
                                keyBasicInfo->Name,
                                status) );
                }

                //
                // We found the PnP BIOS entry, so close the key handle and
                // return.
                //

                ZwClose(biosKey);

                break;
            }
        }

        //
        // That wasn't it so close this handle and try the next subkey.
        //
        ZwClose(biosKey);
    }

    //
    // Cleanup the dynamically allocated temporary buffers.
    //

    if (valueInfo != NULL) {

        ExFreePool(valueInfo);
    }

    if (keyBasicInfo != NULL) {

        ExFreePool(keyBasicInfo);
    }

    ZwClose(multifunctionKey);

    return status;
}

VOID
PnPBiosExpandProductId(
    PUCHAR CompressedId,
    PWCHAR ProductIDStr
    )
/*++

Routine Description:

    This function expands a PnP Device ID from the 4 byte compressed form into
    an 7 character unicode string.  The string is then NUL terminated.

Arguments:

    CompressedId - Pointer to the 4 byte compressed Device ID as defined in the
        PnP Specification.

    ProductIDStr - Pointer to the 16 byte buffer in which the unicode string
        version of the ID is placed.


Return Value:

    NONE.

--*/
{
    static const CHAR HexDigits[16] = "0123456789ABCDEF";

    ProductIDStr[0] = (CompressedId[0] >> 2) + 0x40;
    ProductIDStr[1] = (((CompressedId[0] & 0x03) << 3) | (CompressedId[1] >> 5)) + 0x40;
    ProductIDStr[2] = (CompressedId[1] & 0x1f) + 0x40;
    ProductIDStr[3] = HexDigits[CompressedId[2] >> 4];
    ProductIDStr[4] = HexDigits[CompressedId[2] & 0x0F];
    ProductIDStr[5] = HexDigits[CompressedId[3] >> 4];
    ProductIDStr[6] = HexDigits[CompressedId[3] & 0x0F];
    ProductIDStr[7] = 0x00;
}

BOOLEAN
PnPBiosIgnoreNode (
    PWCHAR PnpID,
    PWCHAR excludeNodes
    )
{
    BOOLEAN bRet=FALSE;
    ULONG   keyLen;
    PWCHAR  pTmp;

    ASSERT(excludeNodes);

    //
    //excludeNodes is multi-sz, so walk through each one and check it.
    //
    pTmp=excludeNodes;

    while (*pTmp != '\0') {

        keyLen = (ULONG)wcslen(pTmp);

        if (RtlCompareMemory(PnpID,pTmp,keyLen*sizeof (WCHAR)) == keyLen*sizeof (WCHAR)) {
            bRet=TRUE;
            break;
        }
        pTmp = pTmp + keyLen + 1;

    }


    return bRet;
}

PKEY_VALUE_FULL_INFORMATION
PnPGetBiosInfoValue(
    PWCHAR ValueName
    )
{
    UNICODE_STRING biosKeyName;
    HANDLE  biosKey;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION info;

    info = NULL;
    PiWstrToUnicodeString(&biosKeyName, BIOSINFO_KEY_NAME);
    status = IopOpenRegistryKeyEx( &biosKey,
                                   NULL,
                                   &biosKeyName,
                                   KEY_READ
                                   );

    if (NT_SUCCESS(status)) {

        IopGetRegistryValue (biosKey, ValueName, &info);
        ZwClose (biosKey);
    }

    return info;
}

BOOLEAN
PnPBiosCheckForExclusion(
    IN EXCLUDED_PNPNODE const*Exclusions,
    IN ULONG  ExclusionCount,
    IN PWCHAR PnpDeviceName,
    IN PWCHAR PnpCompatIds
    )
{
    PWCHAR idPtr;
    ULONG exclusionIndex;

    for (exclusionIndex = 0; exclusionIndex < ExclusionCount; exclusionIndex++) {

        idPtr = PnpDeviceName;

        if (RtlCompareMemory( idPtr,
                              Exclusions[ exclusionIndex ].Id,
                              Exclusions[ exclusionIndex ].IdLength) != Exclusions[ exclusionIndex ].IdLength )  {

            idPtr = PnpCompatIds;

            if (idPtr != NULL)  {

                while (*idPtr != '\0') {

                    if (RtlCompareMemory( idPtr,
                                          Exclusions[ exclusionIndex ].Id,
                                          Exclusions[ exclusionIndex ].IdLength) == Exclusions[ exclusionIndex ].IdLength )  {

                        break;
                    }

                    idPtr += 9;
                }

                if (*idPtr == '\0') {

                    idPtr = NULL;
                }
            }
        }

        if (idPtr != NULL)  {

            break;
        }
    }

    if (exclusionIndex < ExclusionCount) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
PnPBiosIoResourceListToCmResourceList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    OUT PCM_RESOURCE_LIST *CmResourceList,
    OUT ULONG *CmResourceListSize
    )
/*++

Routine Description:

    Converts an IO_RESOURCE_REQUIREMENTS_LIST into a CM_RESOURCE_LIST.  This
    routine is used to convert the list of resources currently being used by a
    device into a form suitable for writing to the BootConfig registry value.

Arguments:

    IoResourceList - Pointer to the input list.

    CmResourceList - Pointer to a PCM_RESOURCE_LIST which is set to the
        dynamically allocated and filled in using the data from IoResourceList.

    CmResourceListSize - Pointer to a variable which is set to the size in bytes
        of the dynamically allocated *CmResourceList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PARTIAL_RESOURCE_LIST       partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ioDescriptor;
    ULONG                           descIndex;

    //
    // Since this routine is only used to translate the allocated resources
    // returned by the PnP BIOS, we can assume that there is only 1 alternative
    // list
    //

    ASSERT(IoResourceList->AlternativeLists == 1);

    //
    // Calculate the size of the translated list and allocate memory for it.
    //
    *CmResourceListSize = sizeof(CM_RESOURCE_LIST) +
                          (IoResourceList->AlternativeLists - 1) * sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                          (IoResourceList->List[0].Count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    *CmResourceList = ExAllocatePool( PagedPool, *CmResourceListSize );

    if (*CmResourceList == NULL) {

        *CmResourceListSize = 0;

        return STATUS_NO_MEMORY;
    }

    //
    // Copy the header info from the requirements list to the resource list.
    //
    (*CmResourceList)->Count = 1;

    (*CmResourceList)->List[ 0 ].InterfaceType = IoResourceList->InterfaceType;
    (*CmResourceList)->List[ 0 ].BusNumber = IoResourceList->BusNumber;

    partialList = &(*CmResourceList)->List[ 0 ].PartialResourceList;

    partialList->Version = IoResourceList->List[ 0 ].Version;
    partialList->Revision = IoResourceList->List[ 0 ].Revision;
    partialList->Count = 0;

    //
    // Translate each resource descriptor, currently we only handle ports,
    // memory, interrupts, and dma.  The current implementation of the routine
    // which converts from ISA PnP Resource data to IO_RESOURCE_REQUIREMENTS
    // won't generate any other descriptor types given the data returned from
    // the BIOS.
    //

    partialDescriptor = &partialList->PartialDescriptors[ 0 ];
    for (descIndex = 0; descIndex < IoResourceList->List[ 0 ].Count; descIndex++) {

        ioDescriptor = &IoResourceList->List[ 0 ].Descriptors[ descIndex ];

        switch (ioDescriptor->Type) {

        case CmResourceTypePort:
            partialDescriptor->u.Port.Start = ioDescriptor->u.Port.MinimumAddress;
            partialDescriptor->u.Port.Length = ioDescriptor->u.Port.Length;
            break;

        case CmResourceTypeInterrupt:
            if (ioDescriptor->u.Interrupt.MinimumVector == (ULONG)2 ) {
                *CmResourceListSize -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                continue;
            }
            partialDescriptor->u.Interrupt.Level = ioDescriptor->u.Interrupt.MinimumVector;
            partialDescriptor->u.Interrupt.Vector = ioDescriptor->u.Interrupt.MinimumVector;
            partialDescriptor->u.Interrupt.Affinity = ~0ul;
            break;

        case CmResourceTypeMemory:
            partialDescriptor->u.Memory.Start = ioDescriptor->u.Memory.MinimumAddress;
            partialDescriptor->u.Memory.Length = ioDescriptor->u.Memory.Length;
            break;

        case CmResourceTypeDma:
            partialDescriptor->u.Dma.Channel = ioDescriptor->u.Dma.MinimumChannel;
            partialDescriptor->u.Dma.Port = 0;
            partialDescriptor->u.Dma.Reserved1 = 0;
            break;

        default:
            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Unexpected ResourceType (%d) in I/O Descriptor\n",
                        ioDescriptor->Type) );

#if DBG
            // DbgBreakPoint();
#endif
            break;
        }

        partialDescriptor->Type = ioDescriptor->Type;
        partialDescriptor->ShareDisposition = ioDescriptor->ShareDisposition;
        partialDescriptor->Flags = ioDescriptor->Flags;
        partialDescriptor++;

        partialList->Count++;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosExtractCompatibleIDs(
    IN  PUCHAR *DevNodeData,
    IN  ULONG DevNodeDataLength,
    OUT PWSTR *CompatibleIDs,
    OUT ULONG *CompatibleIDsLength
    )
{
    PWCHAR  idPtr;
    PUCHAR  currentPtr, endPtr;
    UCHAR   tagName;
    ULONG   increment;
    ULONG   compatibleCount;

    endPtr = &(*DevNodeData)[DevNodeDataLength];

    compatibleCount = 0;

    for (currentPtr = *DevNodeData; currentPtr < endPtr; currentPtr += increment) {

        tagName = *currentPtr;

        if (tagName == TAG_COMPLETE_END)  {

            break;
        }

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment++;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(&currentPtr[1]);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_COMPATIBLE_ID) {

            compatibleCount++;
        }
    }

    if (compatibleCount == 0) {
        *CompatibleIDs = NULL;
        *CompatibleIDsLength = 0;

        return STATUS_SUCCESS;
    }

    *CompatibleIDsLength = (compatibleCount * 9 + 1) * sizeof(WCHAR);
    *CompatibleIDs = ExAllocatePool(PagedPool, *CompatibleIDsLength);

    if (*CompatibleIDs == NULL)  {

        *CompatibleIDsLength = 0;
        return STATUS_NO_MEMORY;
    }

    idPtr = *CompatibleIDs;

    for (currentPtr = *DevNodeData; currentPtr < endPtr; currentPtr += increment) {

        tagName = *currentPtr;

        if (tagName == TAG_COMPLETE_END)  {

            break;
        }

        //
        // Determine the size of the BIOS resource descriptor
        //

        if (!(tagName & LARGE_RESOURCE_TAG)) {
            increment = (USHORT)(tagName & SMALL_TAG_SIZE_MASK);
            increment++;     // length of small tag
            tagName &= SMALL_TAG_MASK;
        } else {
            increment = *(USHORT UNALIGNED *)(&currentPtr[1]);
            increment += 3;     // length of large tag
        }

        if (tagName == TAG_COMPATIBLE_ID) {

            *idPtr = '*';
            PnPBiosExpandProductId(&currentPtr[1], &idPtr[1]);
            idPtr += 9;
        }
    }

    *idPtr++ = '\0';  // Extra NUL for REG_MULTI_SZ
    *CompatibleIDsLength = (ULONG)(idPtr - *CompatibleIDs) * sizeof(WCHAR);

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosTranslateInfo(
    IN VOID *BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PBIOS_DEVNODE_INFO *DevNodeInfoList,
    OUT ULONG *NumberNodes
    )
/*++

Routine Description:

    Translates the devnode info retrieved from the BIOS.

Arguments:

    BiosInfo - The PnP BIOS Installation Check Structure followed by the
        DevNode Structures reported by the BIOS.  The detailed format is
        documented in the PnP BIOS spec.

    BiosInfoLength - Length in bytes of the block whose address is stored in
        BiosInfo.

    DevNodeInfoList - Dynamically allocated array of BIOS_DEVNODE_INFO
        structures, one for each device reported by the BIOS.  The information
        supplied by the BIOS: device ID, type, current resources, and supported
        configurations is converted into a more useful format.  For example the
        current resource allocation is converted from ISA PnP descriptors into
        an IO_RESOURCE_REQUIREMENTS_LIST and then into a CM_RESOURCE_LIST for
        storing into the BootConfig registry value.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PNP_BIOS_INSTALLATION_CHECK biosInstallCheck;
    PCM_PNP_BIOS_DEVICE_NODE        devNodeHeader;
    PBIOS_DEVNODE_INFO              devNodeInfo;

    PIO_RESOURCE_REQUIREMENTS_LIST  tempResReqList;

    PUCHAR                          currentPtr;
    LONG                            lengthRemaining;

    LONG                            remainingNodeLength;

    ULONG                           numNodes;
    ULONG                           nodeIndex;
    PUCHAR                          configPtr;
    ULONG                           configListLength;
    NTSTATUS                        status;
    ULONG                           convertFlags = 0;
    PKEY_VALUE_FULL_INFORMATION     fullValueInfo;

    //
    // Make sure the data is at least large enough to hold the BIOS Installation
    // Check structure and check that the PnP signature is correct.
    //
    if (BiosInfoLength < sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "BiosInfoLength (%d) is smaller than sizeof(PNPBIOS_INSTALLATION_CHECK) (%d)\n",
                    BiosInfoLength,
                    sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) );

        return STATUS_UNSUCCESSFUL;
    }

    biosInstallCheck = (PCM_PNP_BIOS_INSTALLATION_CHECK)BiosInfo;

    if (biosInstallCheck->Signature[0] != '$' ||
        biosInstallCheck->Signature[1] != 'P' ||
        biosInstallCheck->Signature[2] != 'n' ||
        biosInstallCheck->Signature[3] != 'P') {

        return STATUS_UNSUCCESSFUL;
    }
    //
    // First scan the data and count the devnodes to determine the size of our
    // allocated data structures.
    //
    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (numNodes = 0; lengthRemaining > sizeof(CM_PNP_BIOS_DEVICE_NODE); numNodes++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining) );

            return STATUS_UNSUCCESSFUL;
        }

        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;
    }

    //
    // Allocate the list of translated devnodes.
    //
    devNodeInfo = ExAllocatePool( PagedPool, numNodes * sizeof(BIOS_DEVNODE_INFO) );

    if (devNodeInfo == NULL) {

        return STATUS_NO_MEMORY;
    }

    //
    // Should we force all fixed IO decodes to 16bit?
    //
    fullValueInfo = PnPGetBiosInfoValue(DECODEINFO_VALUE_NAME);
    if (fullValueInfo) {

        if (fullValueInfo->Type == REG_DWORD && 
            fullValueInfo->DataLength == sizeof(ULONG) && 
            *(PULONG)((PUCHAR)fullValueInfo + fullValueInfo->DataOffset)) {

            convertFlags |= PPCONVERTFLAG_FORCE_FIXED_IO_16BIT_DECODE;
        }
        ExFreePool(fullValueInfo);
    }
    //
    // Now scan the data translating the info for each devnode into an entry in
    // our devNodeInfo array.
    //

    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (nodeIndex = 0; nodeIndex < numNodes; nodeIndex++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining) );

            break;
        }

        //
        // We use the Product ID field as the DeviceID key name.  So we insert
        // an initial asterisk so we don't have to copy and mangle it later.
        //
        devNodeInfo[nodeIndex].ProductId[0] = '*';

        PnPBiosExpandProductId((PUCHAR)&devNodeHeader->ProductId, &devNodeInfo[nodeIndex].ProductId[1]);

        devNodeInfo[nodeIndex].ProductId[9] = '\0';  // Extra NUL for REG_MULTI_SZ

        //
        // The handle is used as part of the Instance ID
        devNodeInfo[nodeIndex].Handle = devNodeHeader->Node;

        //
        // The type code and attributes aren't currently used but are copied
        // for completeness.
        //
        RtlCopyMemory( &devNodeInfo[nodeIndex].TypeCode,
                       devNodeHeader->DeviceType,
                       sizeof(devNodeInfo[nodeIndex].TypeCode) );

        devNodeInfo[nodeIndex].Attributes = devNodeHeader->DeviceAttributes;

        //
        // Replaces will eventually be set to the path of the Firmware
        // Enumerated devnode which duplicates this one (if a duplicate exists).
        //
        devNodeInfo[nodeIndex].Replaces = NULL;

        //
        // CompatibleIDs will be set to the list of compatible IDs.
        //
        devNodeInfo[nodeIndex].CompatibleIDs = NULL;

        //
        // Convert the allocated resources from ISA PnP resource descriptor
        // format to an IO_RESOURCE_REQUIREMENTS_LIST.
        //
        configPtr = currentPtr + sizeof(*devNodeHeader);
        remainingNodeLength = devNodeHeader->Size - sizeof(*devNodeHeader);

        devNodeInfo[nodeIndex].BootConfig = NULL;
        devNodeInfo[nodeIndex].FirmwareDisabled = FALSE;

        status = PpBiosResourcesToNtResources( 0,            /* BusNumber */
                                               0,            /* SlotNumber */
                                               &configPtr,   /* BiosData */
                                               convertFlags, /* ConvertFlags */
                                               &tempResReqList, /* ReturnedList */
                                               &configListLength);    /* ReturnedLength */

        remainingNodeLength = devNodeHeader->Size - (LONG)(configPtr - (PUCHAR)devNodeHeader);

        if (NT_SUCCESS( status )) {

            if (tempResReqList != NULL) {

                PpFilterNtResource (
                    devNodeInfo[nodeIndex].ProductId,
                    tempResReqList
                );

                //
                // Now we need to convert from a IO_RESOURCE_REQUIREMENTS_LIST to a
                // CM_RESOURCE_LIST.
                //
                status = PnPBiosIoResourceListToCmResourceList( tempResReqList,
                                                                &devNodeInfo[nodeIndex].BootConfig,
                                                                &devNodeInfo[nodeIndex].BootConfigLength);

                status = PnPBiosCheckForHardwareDisabled(tempResReqList,&devNodeInfo[nodeIndex].FirmwareDisabled);
                ExFreePool( tempResReqList );
            }

        } else {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Error converting allocated resources for devnode # %d, status = %8.8X\n",
                        devNodeInfo[nodeIndex].Handle,
                        status) );
        }

        //
        // Convert the supported resource configurations from ISA PnP resource
        // descriptor format to an IO_RESOURCE_REQUIREMENTS_LIST.
        //
        status = PpBiosResourcesToNtResources( 0,            /* BusNumber */
                                               0,            /* SlotNumber */
                                               &configPtr,   /* BiosData */
                                               convertFlags | PPCONVERTFLAG_SET_RESTART_LCPRI, /* ConvertFlags */
                                               &devNodeInfo[nodeIndex].BasicConfig, /* ReturnedList */
                                               &devNodeInfo[nodeIndex].BasicConfigLength );  /* ReturnedLength */

        remainingNodeLength = devNodeHeader->Size - (LONG)(configPtr - (PUCHAR)devNodeHeader);

        if (!NT_SUCCESS( status )) {

            devNodeInfo[nodeIndex].BasicConfig = NULL;

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Error converting allowed resources for devnode # %d, status = %8.8X\n",
                        devNodeInfo[nodeIndex].Handle,
                        status) );
        } else {

            PpFilterNtResource (
                devNodeInfo[nodeIndex].ProductId,
                devNodeInfo[nodeIndex].BasicConfig
            );
        }

        //
        // Convert the list of compatible IDs if present
        //

        ASSERT(remainingNodeLength >= 0);

        status = PnPBiosExtractCompatibleIDs( &configPtr,       // BiosData
                                              (ULONG)remainingNodeLength,
                                              &devNodeInfo[nodeIndex].CompatibleIDs,
                                              &devNodeInfo[nodeIndex].CompatibleIDsLength );

        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;

    }

    *DevNodeInfoList = devNodeInfo;
    *NumberNodes = numNodes;
    return STATUS_SUCCESS;
}

LONG
PnPBiosFindMatchingDevNode(
    IN PWCHAR MapperName,
    IN PCM_RESOURCE_LIST ResourceList,
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Given a list of resources this routine finds an entry in the
    DevNodeInfoList whose BootConfig resources match.  A match is defined as
    having at least overlapping I/O Ports or Memory Ranges.  If ResourceList doesn't
    include any I/O Ports or Memory Ranges then a match is defined as exactly
    the same interrupts and/or DMA channels.

    This routine is used to find PnP BIOS reported devices which match devices
    created by the Firmware Mapper.

Arguments:

    ResourceList - Pointer to CM_RESOURCE_LIST describing the resources
        currently used by the device for which a match is being searched.

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.


Return Value:

    Index of the entry in DevNodeInfoList whose BootConfig matches the resources
    listed in ResourceList.  If no matching entry is found then -1 is returned.

--*/
{
    PCM_PARTIAL_RESOURCE_LIST       sourceList;
    PCM_PARTIAL_RESOURCE_LIST       targetList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR sourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR targetDescriptor;
    ULONG                           nodeIndex, sourceIndex, targetIndex;
    LONG                            firstMatch = -1;
    LONG                            bestMatch = -1;
    ULONG                           numResourcesMatch;
    ULONG                           score, possibleScore, bestScore = 0;
    PWCHAR                          idPtr;
    BOOLEAN                         idsMatch;
    BOOLEAN                         bestIdsMatch = FALSE;

#if DEBUG_DUP_MATCH
    CHAR                            sourceMapping[256];
    CHAR                            targetMapping[256];
#endif

    //
    // In order to simplify the problem we assume there is only one list.  This
    // assumption holds true in the BootConfig structures generated by the
    // current firmware mapper.
    //
    ASSERT( ResourceList->Count == 1 );

    sourceList = &ResourceList->List[0].PartialResourceList;

#if DEBUG_DUP_MATCH
    //
    // For debugging purposes we keep track of which resource entries map to
    // each other.  These relationships are stored in a fixed CHAR array, thus
    // the restriction on the number of descriptors.
    //
    ASSERT( sourceList->Count < 255 );
#endif

    //
    // Loop through each devnode and try and match it to the source resource
    // list.
    //
    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        if (DevNodeInfoList[ nodeIndex ].BootConfig == NULL) {

            continue;
        }

        //
        // We found at least one potential match.  Let's double check if
        // the PNP ids also match.  We use a lack of ID match to disqualify
        // entries which don't match at least I/O ports or memory.
        //

        idPtr = DevNodeInfoList[ nodeIndex ].ProductId;

        if (RtlCompareMemory( idPtr, MapperName, 12 ) != 12) {

            idPtr = DevNodeInfoList[ nodeIndex ].CompatibleIDs;

            if (idPtr != NULL) {

                while (*idPtr != '\0') {

                    if (RtlCompareMemory( idPtr, MapperName, 12 ) == 12) {

                        break;
                    }

                    idPtr += 9;
                }

                if (*idPtr == '\0') {

                    idPtr = NULL;
                }
            }
        }

        idsMatch = (BOOLEAN)(idPtr != NULL);

        ASSERT( DevNodeInfoList[ nodeIndex ].BootConfig->Count == 1 );

        targetList = &DevNodeInfoList[ nodeIndex ].BootConfig->List[0].PartialResourceList;

#if DEBUG_DUP_MATCH
        RtlFillMemory( sourceMapping, sizeof(sourceMapping), -1 );
        RtlFillMemory( targetMapping, sizeof(targetMapping), -1 );
#endif

        numResourcesMatch = 0;
        possibleScore = 0;
        score = 0;

        //
        // Loop through each source descriptor (resource) and try and match it
        // to one of this devnode's descriptors.
        //

        for (sourceIndex = 0; sourceIndex < sourceList->Count; sourceIndex++) {

            sourceDescriptor = &sourceList->PartialDescriptors[sourceIndex];

            //
            // We are recalculating the possible score unnecessarily each time
            // we process a devnode.  We might save a small amount of time by
            // looping through the source descriptors once at the beginning but
            // its not clear it would make all that much difference given the
            // few devices reported by the BIOS.
            //

            switch (sourceDescriptor->Type) {

            case CmResourceTypePort:
                possibleScore += 0x1100;
                break;

            case CmResourceTypeInterrupt:
                possibleScore += 0x0001;
                break;

            case CmResourceTypeMemory:
                possibleScore += 0x1100;
                break;

            case CmResourceTypeDma:
                possibleScore += 0x0010;
                break;

            default:
                continue;
            }

            //
            // Try to find a resource in the target devnode which matches the
            // current source resource.
            //
            for (targetIndex = 0; targetIndex < targetList->Count; targetIndex++) {

                targetDescriptor = &targetList->PartialDescriptors[targetIndex];

                if (sourceDescriptor->Type == targetDescriptor->Type) {
                    switch (sourceDescriptor->Type) {
                    case CmResourceTypePort:
                        if ((sourceDescriptor->u.Port.Start.LowPart + sourceDescriptor->u.Port.Length) <=
                             targetDescriptor->u.Port.Start.LowPart ||
                            (targetDescriptor->u.Port.Start.LowPart + targetDescriptor->u.Port.Length) <=
                             sourceDescriptor->u.Port.Start.LowPart) {
                            continue;
                        }
                        if (sourceDescriptor->u.Port.Start.LowPart ==
                                targetDescriptor->u.Port.Start.LowPart &&
                            sourceDescriptor->u.Port.Length ==
                                targetDescriptor->u.Port.Length) {

                            score += 0x1100;

                        } else {

                            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                        "Overlapping port resources, source = %4.4X-%4.4X, target = %4.4X-%4.4X\n",
                                        sourceDescriptor->u.Port.Start.LowPart,
                                        sourceDescriptor->u.Port.Start.LowPart + sourceDescriptor->u.Port.Length - 1,
                                        targetDescriptor->u.Port.Start.LowPart,
                                        targetDescriptor->u.Port.Start.LowPart + targetDescriptor->u.Port.Length - 1) );

                            score += 0x1000;

                        }
                        break;

                    case CmResourceTypeInterrupt:
                        if (sourceDescriptor->u.Interrupt.Level !=
                            targetDescriptor->u.Interrupt.Level) {
                            continue;
                        }
                        score += 0x0001;
                        break;

                    case CmResourceTypeMemory:
                        if ((sourceDescriptor->u.Memory.Start.LowPart + sourceDescriptor->u.Memory.Length) <=
                             targetDescriptor->u.Memory.Start.LowPart ||
                            (targetDescriptor->u.Memory.Start.LowPart + targetDescriptor->u.Memory.Length) <=
                             sourceDescriptor->u.Memory.Start.LowPart) {

                            continue;
                        }
                        if (sourceDescriptor->u.Memory.Start.LowPart ==
                                targetDescriptor->u.Memory.Start.LowPart &&
                            sourceDescriptor->u.Memory.Length ==
                                targetDescriptor->u.Memory.Length) {

                            score += 0x1100;

                        } else {

                            score += 0x1000;

                        }
                        break;

                    case CmResourceTypeDma:
                        if (sourceDescriptor->u.Dma.Channel !=
                            targetDescriptor->u.Dma.Channel) {

                            continue;
                        }
                        score += 0x0010;
                        break;

                    }
                    break;
                }
            }

            if (targetIndex < targetList->Count) {
#if DEBUG_DUP_MATCH
                sourceMapping[sourceIndex] = (CHAR)targetIndex;
                targetMapping[targetIndex] = (CHAR)sourceIndex;
#endif
                numResourcesMatch++;
            }
        }

        if (numResourcesMatch != 0) {
            if (firstMatch == -1) {
                firstMatch = nodeIndex;
            }

            if ((score > bestScore) || (score == bestScore && !bestIdsMatch && idsMatch))  {
                bestScore = score;
                bestMatch = nodeIndex;
                bestIdsMatch = idsMatch;
            }
        }
    }

    if (bestMatch != -1) {

        if (bestScore == possibleScore) {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Perfect match, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

            if (possibleScore < 0x1000 && !bestIdsMatch) {

                bestMatch = -1;

            }

        } else if (possibleScore > 0x1000 && bestScore >= 0x1000) {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Best match is close enough, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

        } else  {

            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                        "Best match is less than threshold, score = %4.4X, possible = %4.4X, index = %d\n",
                        bestScore,
                        possibleScore,
                        bestMatch) );

            bestMatch = -1;

        }
    }

    return bestMatch;
}

NTSTATUS
PnPBiosEliminateDupes(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    This routine enumerates the Firmware Mapper generated devices under
    Enum\Root.  Those that match entries in DevNodeInfoList have their registry
    key name stored in the DevNodeInfoList entry so that the Firmare Mapper
    instance may be removed later.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    UNICODE_STRING                  enumRootKeyName, valueName;
    HANDLE                          enumRootKey;
    PKEY_BASIC_INFORMATION          deviceBasicInfo = NULL;
    ULONG                           deviceBasicInfoLength;
    UNICODE_STRING                  deviceKeyName;
    HANDLE                          deviceKey = NULL;
    PKEY_BASIC_INFORMATION          instanceBasicInfo = NULL;
    ULONG                           instanceBasicInfoLength;
    WCHAR                           logConfStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey = NULL;

    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;

    ULONG                           deviceIndex, instanceIndex;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;

    PiWstrToUnicodeString(&enumRootKeyName, ENUMROOT_KEY_NAME);

    status = IopOpenRegistryKeyEx( &enumRootKey,
                                   NULL,
                                   &enumRootKeyName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "Could not open registry key %S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;
    }

    deviceBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    deviceBasicInfo = ExAllocatePool(PagedPool, deviceBasicInfoLength);

    instanceBasicInfoLength = sizeof(KEY_BASIC_INFORMATION) + DEFAULT_STRING_SIZE;
    instanceBasicInfo = ExAllocatePool(PagedPool, instanceBasicInfoLength);

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (deviceBasicInfo != NULL && instanceBasicInfo != NULL && valueInfo != NULL) {

        for (deviceIndex = 0; ; deviceIndex++) {

            status = ZwEnumerateKey( enumRootKey,
                                     deviceIndex,
                                     KeyBasicInformation,
                                     deviceBasicInfo,
                                     deviceBasicInfoLength,
                                     &returnedLength);

            if (!NT_SUCCESS(status)) {

                if (status == STATUS_BUFFER_TOO_SMALL ||
                    status == STATUS_BUFFER_OVERFLOW) {

                    continue;

                } else if (status != STATUS_NO_MORE_ENTRIES)  {

                    IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                "Could not enumerate under key %S, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                status) );
                } else {
                    status = STATUS_SUCCESS;
                }
                break;
            }

            if (deviceBasicInfo->Name[0] != '*') {
                continue;
            }

            deviceBasicInfo->Name[ deviceBasicInfo->NameLength / 2 ] = L'\0';
            RtlInitUnicodeString(&deviceKeyName, deviceBasicInfo->Name);

            status = IopOpenRegistryKeyEx( &deviceKey,
                                           enumRootKey,
                                           &deviceKeyName,
                                           KEY_READ
                                           );

            if (!NT_SUCCESS(status)) {

                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not open registry key %S\\%S, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            deviceBasicInfo->Name,
                            status) );
                break;
            }

            for (instanceIndex = 0; ; instanceIndex++) {

                status = ZwEnumerateKey( deviceKey,
                                         instanceIndex,
                                         KeyBasicInformation,
                                         instanceBasicInfo,
                                         instanceBasicInfoLength,
                                         &returnedLength);

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL ||
                        status == STATUS_BUFFER_OVERFLOW) {

                        continue;

                    } else if (status != STATUS_NO_MORE_ENTRIES)  {
                        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                    "Could not enumerate under key %S\\%S, status = %8.8X\n",
                                    ENUMROOT_KEY_NAME,
                                    deviceBasicInfo->Name,
                                    status) );
                    } else {
                        status = STATUS_SUCCESS;
                    }
                    break;
                }

                if (RtlCompareMemory( instanceBasicInfo->Name,
                                      INSTANCE_ID_PREFIX,
                                      sizeof(INSTANCE_ID_PREFIX) - sizeof(UNICODE_NULL)
                                      ) == (sizeof(INSTANCE_ID_PREFIX) - sizeof(UNICODE_NULL))) {

                    continue;
                }

                instanceBasicInfo->Name[ instanceBasicInfo->NameLength / 2 ] = L'\0';

                RtlCopyMemory( logConfStr,
                               instanceBasicInfo->Name,
                               instanceBasicInfo->NameLength );

                logConfStr[ instanceBasicInfo->NameLength / 2 ] = L'\\';

                RtlCopyMemory( &logConfStr[ instanceBasicInfo->NameLength / 2 + 1 ],
                               REGSTR_KEY_LOGCONF,
                               sizeof(REGSTR_KEY_LOGCONF) );

                RtlInitUnicodeString( &logConfKeyName, logConfStr );

                status = IopOpenRegistryKeyEx( &logConfKey,
                                               deviceKey,
                                               &logConfKeyName,
                                               KEY_READ
                                               );

                if (!NT_SUCCESS(status)) {

                    IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                deviceBasicInfo->Name,
                                logConfStr,
                                status) );
                    continue;
                }

                PiWstrToUnicodeString( &valueName, REGSTR_VAL_BOOTCONFIG );

                status = ZwQueryValueKey( logConfKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength );

                if (!NT_SUCCESS(status)) {

                    if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {

                        ExFreePool( valueInfo );

                        valueInfoLength = returnedLength;
                        valueInfo = ExAllocatePool( PagedPool, valueInfoLength );

                        if (valueInfo != NULL) {

                            status = ZwQueryValueKey( logConfKey,
                                                      &valueName,
                                                      KeyValuePartialInformation,
                                                      valueInfo,
                                                      valueInfoLength,
                                                      &returnedLength );
                        } else {
                            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                        "Error allocating memory for %S\\%S\\LogConf\\BootConfig value\n",
                                        ENUMROOT_KEY_NAME,
                                        deviceBasicInfo->Name) );
                            valueInfoLength = 0;
                            status = STATUS_NO_MEMORY;

                            break;
                        }

                    } else {
                        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                    "Error retrieving %S\\%S\\LogConf\\BootConfig size, status = %8.8X\n",
                                    ENUMROOT_KEY_NAME,
                                    deviceBasicInfo->Name,
                                    status) );

                        status = STATUS_UNSUCCESSFUL;
                    }
                }

                if (NT_SUCCESS( status )) {
                    PCM_RESOURCE_LIST   resourceList;
                    LONG                matchingIndex;

                    resourceList = (PCM_RESOURCE_LIST)valueInfo->Data;

                    matchingIndex = PnPBiosFindMatchingDevNode( deviceBasicInfo->Name,
                                                                resourceList,
                                                                DevNodeInfoList,
                                                                NumberNodes );

                    if (matchingIndex != -1) {

                        DevNodeInfoList[ matchingIndex ].Replaces = ExAllocatePool( PagedPool,
                                                                                    deviceBasicInfo->NameLength + instanceBasicInfo->NameLength + 2 * sizeof(UNICODE_NULL));

                        if (DevNodeInfoList[ matchingIndex ].Replaces != NULL) {

                            RtlCopyMemory( DevNodeInfoList[ matchingIndex ].Replaces,
                                           deviceBasicInfo->Name,
                                           deviceBasicInfo->NameLength );

                            DevNodeInfoList[ matchingIndex ].Replaces[ deviceBasicInfo->NameLength / 2 ] = '\\';

                            RtlCopyMemory( &DevNodeInfoList[ matchingIndex ].Replaces[ deviceBasicInfo->NameLength / 2 + 1 ],
                                           instanceBasicInfo->Name,
                                           instanceBasicInfo->NameLength );

                            DevNodeInfoList[ matchingIndex ].Replaces[ (deviceBasicInfo->NameLength + instanceBasicInfo->NameLength) / 2 + 1 ] = '\0';

                            IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                        "Match found: %S\\%S%d replaces %S\n",
                                        DevNodeInfoList[ matchingIndex ].ProductId,
                                        INSTANCE_ID_PREFIX,
                                        DevNodeInfoList[ matchingIndex ].Handle,
                                        DevNodeInfoList[ matchingIndex ].Replaces) );
                        } else {
                            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                        "Error allocating memory for %S\\%S%d\\Replaces\n",
                                        DevNodeInfoList[ matchingIndex ].ProductId,
                                        INSTANCE_ID_PREFIX,
                                        DevNodeInfoList[ matchingIndex ].Handle) );
                        }
                    } else {
                        IopDbgPrint( (IOP_MAPPER_INFO_LEVEL,
                                    "No matching PnP Bios DevNode found for FW Enumerated device %S\\%S\n",
                                    deviceBasicInfo->Name,
                                    instanceBasicInfo->Name) );
                    }
                } else {
                    IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                "Error retrieving %S\\%S\\%S\\BootConfig, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                deviceBasicInfo->Name,
                                logConfStr,
                                status) );
                }

                ZwClose(logConfKey);

                logConfKey = NULL;
            }

            ZwClose(deviceKey);

            deviceKey = NULL;
        }
    } else {
        status = STATUS_NO_MEMORY;
    }

    if (valueInfo != NULL) {
        ExFreePool(valueInfo);
    }

    if (instanceBasicInfo != NULL) {
        ExFreePool(instanceBasicInfo);
    }

    if (deviceBasicInfo != NULL) {
        ExFreePool(deviceBasicInfo);
    }

    if (logConfKey != NULL) {
        ZwClose(logConfKey);
    }

    if (deviceKey != NULL) {
        ZwClose(deviceKey);
    }

    ZwClose(enumRootKey);

    return status;
}

PWCHAR
PnPBiosGetDescription(
    IN PBIOS_DEVNODE_INFO DevNodeInfoEntry
    )
{
    ULONG       class, subClass;
    LONG        index;
    CLASSDATA   const*classDescriptions;
    LONG        descriptionCount;

    class = DevNodeInfoEntry->TypeCode[0];
    subClass = (DevNodeInfoEntry->TypeCode[1] << 8) | DevNodeInfoEntry->TypeCode[2];

    if (class > 0 && class < CLASSLIST_COUNT) {

        classDescriptions = ClassDescriptionsList[ class ].Descriptions;
        descriptionCount = ClassDescriptionsList[ class ].Count;

        //
        // The last description entry is the default so there is no use
        // comparing it, if we get that far just use it.
        //
        for (index = 0; index < (descriptionCount - 1); index++) {

            if (subClass == classDescriptions[ index ].Value)  {

                break;
            }
        }

        return classDescriptions[ index ].Description;
    }

    return DEFAULT_DEVICE_DESCRIPTION;
}

NTSTATUS
PnPBiosCopyDeviceParamKey(
    IN HANDLE EnumRootKey,
    IN PWCHAR SourcePath,
    IN PWCHAR DestinationPath
    )
/*++

Routine Description:

    Copy the Device Parameters key from the firmware mapper node in
    DevNodeInfo->Replaces to the BIOS mapper node represented by DevNodeInfo.

Arguments:

    EnumRootKey - Handle to Enum\Root.

    SourcePath - Instance path of FW Mapper node relative to Enum\Root.

    DestinationKey - Handle to destination instance key.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    NTSTATUS                    status;
    UNICODE_STRING              sourceInstanceKeyName;
    HANDLE                      sourceInstanceKey = NULL;

    UNICODE_STRING              deviceParamKeyName;
    HANDLE                      sourceDeviceParamKey = NULL;
    HANDLE                      destinationDeviceParamKey = NULL;
    UNICODE_STRING              destinationInstanceKeyName;

    PKEY_VALUE_FULL_INFORMATION valueFullInfo = NULL;
    ULONG                       valueFullInfoLength;
    ULONG                       resultLength;

    UNICODE_STRING              valueName;

    ULONG                       index;

    RtlInitUnicodeString( &sourceInstanceKeyName, SourcePath );

    status = IopOpenRegistryKeyEx( &sourceInstanceKey,
                                   EnumRootKey,
                                   &sourceInstanceKeyName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "PnPBiosCopyDeviceParamKey() - Could not open source instance key %S, status = %8.8X\n",
                    SourcePath,
                    status) );

        return status;
    }

    PiWstrToUnicodeString(&deviceParamKeyName, REGSTR_KEY_DEVICEPARAMETERS);

    status = IopOpenRegistryKeyEx( &sourceDeviceParamKey,
                                   sourceInstanceKey,
                                   &deviceParamKeyName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {

        if (status != STATUS_OBJECT_NAME_NOT_FOUND) {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "PnPBiosCopyDeviceParamKey() - Could not open source device parameter key %S\\%S, status = %8.8X\n",
                        SourcePath,
                        deviceParamKeyName.Buffer,
                        status) );
        }

        goto Cleanup;
    }

    RtlInitUnicodeString(&destinationInstanceKeyName, DestinationPath);

    status = IopOpenDeviceParametersSubkey( &destinationDeviceParamKey,
                                            EnumRootKey,
                                            &destinationInstanceKeyName,
                                            KEY_ALL_ACCESS );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "PnPBiosCopyDeviceParamKey() - Could not open destination device parameter key %S\\%S, status = %8.8X\n",
                    DestinationPath,
                    REGSTR_KEY_DEVICEPARAMETERS,
                    status) );

        goto Cleanup;
    }

    valueFullInfoLength = sizeof(KEY_VALUE_FULL_INFORMATION) + DEFAULT_STRING_SIZE + DEFAULT_VALUE_SIZE;
    valueFullInfo = ExAllocatePool(PagedPool, valueFullInfoLength);

    if (valueFullInfo == NULL) {

        goto Cleanup;
    }

    for (index = 0; ; index++) {
        status = ZwEnumerateValueKey( sourceDeviceParamKey,
                                      index,
                                      KeyValueFullInformation,
                                      valueFullInfo,
                                      valueFullInfoLength,
                                      &resultLength );

        if (NT_SUCCESS(status)) {
            UNICODE_STRING  sourcePathString;
            UNICODE_STRING  serialPrefixString;
            UNICODE_STRING  portNameString;

            valueName.Length = (USHORT)valueFullInfo->NameLength;
            valueName.MaximumLength = valueName.Length;
            valueName.Buffer = valueFullInfo->Name;

            RtlInitUnicodeString(&sourcePathString, SourcePath);
            PiWstrToUnicodeString(&serialPrefixString, L"*PNP0501");

            if (sourcePathString.Length > serialPrefixString.Length) {
                sourcePathString.Length = serialPrefixString.Length;
            }

            if (RtlCompareUnicodeString(&sourcePathString, &serialPrefixString, TRUE) == 0) {

                PiWstrToUnicodeString(&portNameString, L"DosDeviceName");

                if (valueName.Length == 16 &&
                    RtlCompareUnicodeString(&valueName, &portNameString, TRUE) == 0)  {

                    // ComPortDBRemove(SourcePath, &unicodeValue);
                    ComPortDBAdd(destinationDeviceParamKey, (PWSTR)((PUCHAR)valueFullInfo + valueFullInfo->DataOffset));
                    continue;
                }
            }

            status = ZwSetValueKey( destinationDeviceParamKey,
                                    &valueName,
                                    valueFullInfo->TitleIndex,
                                    valueFullInfo->Type,
                                    (PUCHAR)valueFullInfo + valueFullInfo->DataOffset,
                                    valueFullInfo->DataLength );
        } else {
            if (status == STATUS_BUFFER_OVERFLOW) {
                ExFreePool( valueFullInfo );

                valueFullInfoLength = resultLength;
                valueFullInfo = ExAllocatePool(PagedPool, valueFullInfoLength);

                if (valueFullInfo == NULL) {
                    status = STATUS_NO_MEMORY;
                } else {
                    index--;
                    continue;
                }
            } else if (status != STATUS_NO_MORE_ENTRIES)  {
                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not enumerate under key %S\\%S, status = %8.8X\n",
                            SourcePath,
                            deviceParamKeyName.Buffer,
                            status) );
            } else {
                status = STATUS_SUCCESS;
            }

            break;
        }
    }

Cleanup:
    if (sourceInstanceKey != NULL) {
        ZwClose( sourceInstanceKey );
    }

    if (sourceDeviceParamKey != NULL) {
        ZwClose( sourceDeviceParamKey );
    }

    if (destinationDeviceParamKey != NULL) {
        ZwClose( destinationDeviceParamKey );
    }

    if (valueFullInfo != NULL) {
        ExFreePool( valueFullInfo );
    }

    return status;
}

NTSTATUS
PnPBiosWriteInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Creates an entry under Enum\Root for each DevNodeInfoList element.  Also
    removes any duplicate entries which were created by the Firmware Mapper.

    Note: Currently entries for the Keyboard, Mouse, and PCI bus are ignored.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PKEY_VALUE_FULL_INFORMATION     excludeList=NULL;

    UNICODE_STRING                  enumRootKeyName;
    HANDLE                          enumRootKey;
    WCHAR                           instanceNameStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  instanceKeyName;
    HANDLE                          instanceKey;
    UNICODE_STRING                  controlKeyName;
    HANDLE                          controlKey;
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey;

    UNICODE_STRING                  valueName;
    ULONG                           dwordValue;
    ULONG                           disposition;

    PWCHAR                          descriptionStr;
    ULONG                           descriptionStrLength;

    ULONG                           nodeIndex;
    NTSTATUS                        status;

    BOOLEAN                         isNewDevice;
    PCHAR                           ids;

    PiWstrToUnicodeString(&enumRootKeyName, ENUMROOT_KEY_NAME);

    status = IopOpenRegistryKeyEx( &enumRootKey,
                                   NULL,
                                   &enumRootKeyName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "Could not open registry key %S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    status) );

        return STATUS_UNSUCCESSFUL;

    }

    //
    // Reasons why a node might be excluded (i.e not enumerated)
    // * included in ExcludedDevices array (non-conditional)
    // * included in CCS\Control\BiosInfo\PnpBios\DisableNodes via biosinfo.inf
    // * resources are disabled and device is included in the
    //   ExcludeIfDisabled array

    excludeList = PnPGetBiosInfoValue(DISABLENODES_VALUE_NAME);

    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        //
        // Check if this node is in the 'ignore on this machine' list.
        //

        if ( excludeList &&
             PnPBiosIgnoreNode( &DevNodeInfoList[ nodeIndex ].ProductId[1],
                                (PWCHAR)((PUCHAR)excludeList+excludeList->DataOffset))) {
            continue;
        }

        // Checking for nodes we always exclude
        if ( PnPBiosCheckForExclusion( ExcludedDevices,
                                       EXCLUDED_DEVICES_COUNT,
                                       DevNodeInfoList[ nodeIndex ].ProductId,
                                       DevNodeInfoList[ nodeIndex ].CompatibleIDs)) {
            //
            // If we are skipping the device, we need to first copy the decode
            // info that the BIOS supplied to the ntdetected device's Boot
            // Config which was generated by the FW mapper.
            //
            PnPBiosCopyIoDecode( enumRootKey, &DevNodeInfoList[ nodeIndex ] );

            //
            // Skip excluded devices, ie busses, mice and keyboards for now.
            //

            continue;
        }

        // Checking for nodes we exclude if disabled
        if ( DevNodeInfoList[ nodeIndex ].FirmwareDisabled &&
             PnPBiosCheckForExclusion( ExcludeIfDisabled,
                                       EXCLUDE_DISABLED_COUNT,
                                       DevNodeInfoList[ nodeIndex ].ProductId,
                                       NULL)) {
            continue;
        }

        swprintf( instanceNameStr,
                  L"%s\\%s%d",
                  DevNodeInfoList[ nodeIndex ].ProductId,
                  INSTANCE_ID_PREFIX,
                  DevNodeInfoList[ nodeIndex ].Handle );

        RtlInitUnicodeString( &instanceKeyName, instanceNameStr );

        status = IopCreateRegistryKeyEx( &instanceKey,
                                         enumRootKey,
                                         &instanceKeyName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         &disposition
                                         );

        if (NT_SUCCESS(status))  {

            //
            // If the key already exists because it was explicitly migrated
            // during textmode setup, we should still consider it a "new key".
            //
            if (disposition != REG_CREATED_NEW_KEY) {
                PKEY_VALUE_FULL_INFORMATION keyValueInformation;
                UNICODE_STRING unicodeString;

                status = IopGetRegistryValue(instanceKey,
                                             REGSTR_VALUE_MIGRATED,
                                             &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    if ((keyValueInformation->Type == REG_DWORD) &&
                        (keyValueInformation->DataLength == sizeof(ULONG)) &&
                        ((*(PULONG)KEY_VALUE_DATA(keyValueInformation)) != 0)) {
                        disposition = REG_CREATED_NEW_KEY;
                    }

                    ExFreePool(keyValueInformation);

                    PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_MIGRATED);
                    ZwDeleteValueKey(instanceKey, &unicodeString);
                }
            }

            isNewDevice = (BOOLEAN)(disposition == REG_CREATED_NEW_KEY);

            if (isNewDevice) {

                PiWstrToUnicodeString( &valueName, L"DeviceDesc" );

                descriptionStr = PnPBiosGetDescription( &DevNodeInfoList[ nodeIndex ] );
                descriptionStrLength = (ULONG)(wcslen(descriptionStr) * 2 + sizeof(UNICODE_NULL));

                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_SZ,
                                        descriptionStr,
                                        descriptionStrLength );
            }

            PiWstrToUnicodeString( &valueName, REGSTR_VAL_FIRMWAREIDENTIFIED );
            dwordValue = 1;

            status = ZwSetValueKey( instanceKey,
                                    &valueName,
                                    0,
                                    REG_DWORD,
                                    &dwordValue,
                                    sizeof(dwordValue) );

            if (isNewDevice)  {

                PiWstrToUnicodeString( &valueName, REGSTR_VALUE_HARDWAREID);
                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_MULTI_SZ,
                                        DevNodeInfoList[ nodeIndex ].ProductId,
                                        sizeof(DevNodeInfoList[nodeIndex].ProductId));

                if (DevNodeInfoList[ nodeIndex ].CompatibleIDs != NULL) {

                    PiWstrToUnicodeString( &valueName, REGSTR_VALUE_COMPATIBLEIDS);
                    status = ZwSetValueKey( instanceKey,
                                            &valueName,
                                            0,
                                            REG_MULTI_SZ,
                                            DevNodeInfoList[ nodeIndex ].CompatibleIDs,
                                            DevNodeInfoList[ nodeIndex ].CompatibleIDsLength);
                }
            }

            PiWstrToUnicodeString( &valueName, L"Replaces" );

            if (DevNodeInfoList[ nodeIndex ].Replaces != NULL) {

                status = ZwSetValueKey( instanceKey,
                                        &valueName,
                                        0,
                                        REG_SZ,
                                        DevNodeInfoList[ nodeIndex ].Replaces,
                                        (ULONG)(wcslen(DevNodeInfoList[ nodeIndex ].Replaces) * 2 + sizeof(UNICODE_NULL)) );

            } else if (!isNewDevice) {

                status = ZwDeleteValueKey( instanceKey,
                                           &valueName );
            }

            PiWstrToUnicodeString( &controlKeyName, REGSTR_KEY_DEVICECONTROL );

            status = IopCreateRegistryKeyEx( &controlKey,
                                             instanceKey,
                                             &controlKeyName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );

            if (NT_SUCCESS(status))  {

                PiWstrToUnicodeString( &valueName, REGSTR_VAL_FIRMWAREMEMBER );
                dwordValue = 1;

                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );

                PiWstrToUnicodeString( &valueName, L"PnpBiosDeviceHandle" );
                dwordValue = DevNodeInfoList[ nodeIndex ].Handle;

                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );

                PiWstrToUnicodeString( &valueName, REGSTR_VAL_FIRMWAREDISABLED );
                dwordValue = DevNodeInfoList[ nodeIndex ].FirmwareDisabled;

                status = ZwSetValueKey( controlKey,
                                        &valueName,
                                        0,
                                        REG_DWORD,
                                        &dwordValue,
                                        sizeof(dwordValue) );

                PiWstrToUnicodeString( &valueName, L"PnpBiosDeviceHandle" );
                dwordValue = DevNodeInfoList[ nodeIndex ].Handle;

                ZwClose( controlKey );

            } else {

                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not open registry key %S\\%S\\%S\\Control, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            DevNodeInfoList[ nodeIndex ].ProductId,
                            instanceNameStr,
                            status) );

                ZwClose( instanceKey );
                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }

            PiWstrToUnicodeString( &logConfKeyName, REGSTR_KEY_LOGCONF );

            status = IopCreateRegistryKeyEx( &logConfKey,
                                           instanceKey,
                                           &logConfKeyName,
                                           KEY_ALL_ACCESS,
                                           REG_OPTION_NON_VOLATILE,
                                           NULL
                                           );

            if (NT_SUCCESS(status))  {

                if (DevNodeInfoList[ nodeIndex ].BootConfig != NULL) {

                    PiWstrToUnicodeString(&valueName, REGSTR_VAL_BOOTCONFIG);
                    status = ZwSetValueKey( logConfKey,
                                            &valueName,
                                            0,
                                            REG_RESOURCE_LIST,
                                            DevNodeInfoList[ nodeIndex ].BootConfig,
                                            DevNodeInfoList[ nodeIndex ].BootConfigLength );
                }

                if (DevNodeInfoList[ nodeIndex ].BasicConfig != NULL) {

                    PiWstrToUnicodeString( &valueName, REGSTR_VAL_BASICCONFIGVECTOR );

                    status = ZwSetValueKey( logConfKey,
                                            &valueName,
                                            0,
                                            REG_RESOURCE_REQUIREMENTS_LIST,
                                            DevNodeInfoList[ nodeIndex ].BasicConfig,
                                            DevNodeInfoList[ nodeIndex ].BasicConfigLength );

                }

                ZwClose( logConfKey );

            } else {

                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not open registry key %S\\%S\\%S\\LogConf, status = %8.8X\n",
                            ENUMROOT_KEY_NAME,
                            DevNodeInfoList[ nodeIndex ].ProductId,
                            instanceNameStr,
                            status) );

                ZwClose( instanceKey );
                status = STATUS_UNSUCCESSFUL;

                goto Cleanup;
            }

            //
            // If we are replacing a FW Mapper devnode we need to copy the
            // Device Parameters subkey.
            //
            if (isNewDevice && DevNodeInfoList[ nodeIndex ].Replaces != NULL) {

                status = PnPBiosCopyDeviceParamKey( enumRootKey,
                                                    DevNodeInfoList[ nodeIndex ].Replaces,
                                                    instanceNameStr );
            }

            ZwClose( instanceKey );

        } else {

            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                        ENUMROOT_KEY_NAME,
                        DevNodeInfoList[ nodeIndex ].ProductId,
                        instanceNameStr,
                        status) );

            ZwClose( instanceKey );
            status = STATUS_UNSUCCESSFUL;

            goto Cleanup;
        }

        //
        // Now check if the entry just written duplicates one written by the
        // Firmware Mapper.  If it does then remove the Firmware Mapper entry.
        //

        if (DevNodeInfoList[ nodeIndex ].Replaces != NULL) {

            IopDeleteKeyRecursive( enumRootKey, DevNodeInfoList[ nodeIndex ].Replaces );

        }
    }

    status = STATUS_SUCCESS;

 Cleanup:
    ZwClose( enumRootKey );

    if (excludeList) {
        ExFreePool (excludeList);
    }

    return status;
}
VOID
PnPBiosCopyIoDecode(
    IN HANDLE EnumRootKey,
    IN PBIOS_DEVNODE_INFO DevNodeInfo
    )
{
    WCHAR                           logConfKeyNameStr[DEFAULT_STRING_SIZE];
    UNICODE_STRING                  logConfKeyName;
    HANDLE                          logConfKey;
    UNICODE_STRING                  valueName;
    PKEY_VALUE_PARTIAL_INFORMATION  valueInfo = NULL;
    ULONG                           valueInfoLength;
    ULONG                           returnedLength;
    NTSTATUS                        status;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
    ULONG                           index;
    USHORT                          flags;

    if (DevNodeInfo->Replaces == NULL || DevNodeInfo->BootConfig == NULL) {

        //
        // If we didn't find a FW Mapper created devnode then there is nothing
        // to do.
        //
        return;
    }

    //
    // Search through the Boot Config and see if the device's I/O ports are
    // 16 bit decode.
    //

    ASSERT(DevNodeInfo->BootConfig->Count == 1);

    partialResourceList = &DevNodeInfo->BootConfig->List[0].PartialResourceList;

    partialDescriptor = &partialResourceList->PartialDescriptors[0];

    flags = (USHORT)~0;

#define DECODE_FLAGS ( CM_RESOURCE_PORT_10_BIT_DECODE | \
                       CM_RESOURCE_PORT_12_BIT_DECODE | \
                       CM_RESOURCE_PORT_16_BIT_DECODE | \
                       CM_RESOURCE_PORT_POSITIVE_DECODE )

    for ( index = 0; index < partialResourceList->Count; index++ ) {
        if (partialDescriptor->Type == CmResourceTypePort) {
            if (flags == (USHORT)~0) {
                flags = partialDescriptor->Flags & DECODE_FLAGS;
            } else {
                ASSERT(flags == (partialDescriptor->Flags & DECODE_FLAGS));
            }
        }
        partialDescriptor++;
    }

    if (!(flags & (CM_RESOURCE_PORT_16_BIT_DECODE | CM_RESOURCE_PORT_POSITIVE_DECODE)))  {
        return;
    }

    swprintf( logConfKeyNameStr,
              L"%s\\%s",
              DevNodeInfo->Replaces,
              REGSTR_KEY_LOGCONF
              );

    RtlInitUnicodeString( &logConfKeyName, logConfKeyNameStr );

    status = IopCreateRegistryKeyEx( &logConfKey,
                                     EnumRootKey,
                                     &logConfKeyName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (!NT_SUCCESS(status)) {

        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "Could not open registry key %S\\%S\\%S, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    DevNodeInfo->Replaces,
                    REGSTR_KEY_LOGCONF,
                    status) );

        return;
    }

    valueInfoLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + DEFAULT_STRING_SIZE;
    valueInfo = ExAllocatePool(PagedPool, valueInfoLength);

    if (valueInfo == NULL)  {

        ZwClose( logConfKey );

        return;
    }

    PiWstrToUnicodeString( &valueName, REGSTR_VAL_BOOTCONFIG );

    status = ZwQueryValueKey( logConfKey,
                              &valueName,
                              KeyValuePartialInformation,
                              valueInfo,
                              valueInfoLength,
                              &returnedLength);

    if (!NT_SUCCESS(status)) {

        if (status == STATUS_BUFFER_TOO_SMALL || status == STATUS_BUFFER_OVERFLOW) {

            //
            // The default buffer was too small, free it and reallocate
            // it to the required size.
            //
            ExFreePool( valueInfo );

            valueInfoLength = returnedLength;
            valueInfo = ExAllocatePool( PagedPool, valueInfoLength );

            if (valueInfo != NULL)  {

                status = ZwQueryValueKey( logConfKey,
                                          &valueName,
                                          KeyValuePartialInformation,
                                          valueInfo,
                                          valueInfoLength,
                                          &returnedLength );

                if (!NT_SUCCESS(status)) {
                    IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                                "Could not query registry value %S\\%S\\LogConf\\BootConfig, status = %8.8X\n",
                                ENUMROOT_KEY_NAME,
                                DevNodeInfo->Replaces,
                                status) );

                    ExFreePool( valueInfo );

                    ZwClose( logConfKey );

                    return;
                }
            } else {

                IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                            "Could not allocate memory for BootConfig value\n"
                            ) );

                ZwClose( logConfKey );

                return;
            }
        }
    }

    partialResourceList = &((PCM_RESOURCE_LIST)valueInfo->Data)->List[0].PartialResourceList;

    partialDescriptor = &partialResourceList->PartialDescriptors[0];

    for ( index = 0; index < partialResourceList->Count; index++ ) {
        if (partialDescriptor->Type == CmResourceTypePort) {
            partialDescriptor->Flags &= ~DECODE_FLAGS;
            partialDescriptor->Flags |= flags;
        }
        partialDescriptor++;
    }

    status = ZwSetValueKey( logConfKey,
                            &valueName,
                            0,
                            REG_RESOURCE_LIST,
                            valueInfo->Data,
                            valueInfo->DataLength );

    if (!NT_SUCCESS(status)) {
        IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                    "Could not set registry value %S\\%S\\LogConf\\BootConfig, status = %8.8X\n",
                    ENUMROOT_KEY_NAME,
                    DevNodeInfo->Replaces,
                    status) );
    }

    ExFreePool(valueInfo);

    ZwClose(logConfKey);
}

NTSTATUS
PnPBiosCheckForHardwareDisabled(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResourceList,
    IN OUT PBOOLEAN Disabled
    )
/*++

Routine Description:

    If this device has been assigned one or more resources, and each resource has a length of zero, then it is
    hardware disabled.

Arguments:

    IoResourceList - Resource obtained from BIOS that we're about to map to a CmResourceList

    Disabled - Set to TRUE if the device is deemed to be disabled

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    BOOLEAN ParsedResource = FALSE;
    PIO_RESOURCE_DESCRIPTOR ioDescriptor;
    ULONG descIndex;
    //
    // Since this routine is only used to translate the allocated resources
    // returned by the PnP BIOS, we can assume that there is only 1 alternative
    // list
    //

    ASSERT(IoResourceList->AlternativeLists == 1);
    ASSERT(Disabled != NULL);

    *Disabled = FALSE;

    //
    // Translate each resource descriptor, currently we only handle ports,
    // memory, interrupts, and dma.  The current implementation of the routine
    // which converts from ISA PnP Resource data to IO_RESOURCE_REQUIREMENTS
    // won't generate any other descriptor types given the data returned from
    // the BIOS.
    //

    for (descIndex = 0; descIndex < IoResourceList->List[ 0 ].Count; descIndex++) {

        ioDescriptor = &IoResourceList->List[ 0 ].Descriptors[ descIndex ];

        switch (ioDescriptor->Type) {

        case CmResourceTypePort:
            if (ioDescriptor->u.Port.Length) {
                return STATUS_SUCCESS;
            }
            ParsedResource = TRUE;
            break;

        case CmResourceTypeInterrupt:
            if (ioDescriptor->u.Interrupt.MinimumVector != (ULONG)(-1)) {
                return STATUS_SUCCESS;
            }
            ParsedResource = TRUE;
            break;

        case CmResourceTypeMemory:
            if (ioDescriptor->u.Memory.Length) {
                return STATUS_SUCCESS;
            }
            ParsedResource = TRUE;
            break;

        case CmResourceTypeDma:
            if (ioDescriptor->u.Dma.MinimumChannel != (ULONG)(-1)) {
                return STATUS_SUCCESS;
            }
            ParsedResource = TRUE;
            break;

        default:
            IopDbgPrint( (IOP_MAPPER_ERROR_LEVEL,
                        "Unexpected ResourceType (%d) in I/O Descriptor\n",
                        ioDescriptor->Type) );

#if DBG
            // DbgBreakPoint();
#endif
            break;
        }
    }

    if (ParsedResource) {
        //
        // at least one empty resource, no non-empty resources
        //
        *Disabled = TRUE;
    }

    return STATUS_SUCCESS;

}


NTSTATUS
PnPBiosFreeDevNodeInfo(
    IN PBIOS_DEVNODE_INFO DevNodeInfoList,
    IN ULONG NumberNodes
    )
/*++

Routine Description:

    Free the dynamically allocated DevNodeInfoList as well as any dynamically
    allocated dependent structures.

Arguments:

    DevNodeInfoList - Array of BIOS_DEVNODE_INFO structures, one for each device
        reported by the BIOS.

    NumberNodes - Number of BIOS_DEVNODE_INFO elements pointed to by
        DevNodeInfoList.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    ULONG   nodeIndex;

    for (nodeIndex = 0; nodeIndex < NumberNodes; nodeIndex++) {

        if (DevNodeInfoList[nodeIndex].Replaces != NULL) {
            ExFreePool( DevNodeInfoList[nodeIndex].Replaces );
        }

        if (DevNodeInfoList[nodeIndex].CompatibleIDs != NULL) {
            ExFreePool( DevNodeInfoList[nodeIndex].CompatibleIDs );
        }

        if (DevNodeInfoList[nodeIndex].BootConfig != NULL) {
            ExFreePool( DevNodeInfoList[nodeIndex].BootConfig );
        }

        if (DevNodeInfoList[nodeIndex].BasicConfig != NULL) {
            ExFreePool( DevNodeInfoList[nodeIndex].BasicConfig );
        }
    }

    ExFreePool( DevNodeInfoList );

    return STATUS_SUCCESS;
}

NTSTATUS
PnPBiosMapper()
/*++

Routine Description:

    Map the information provided from the PnP BIOS and stored in the registry by
    NTDETECT into root enumerated devices.

Arguments:

    NONE

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_RESOURCE_LIST   biosInfo;
    ULONG               length;
    NTSTATUS            status;
    PBIOS_DEVNODE_INFO  devNodeInfoList;
    ULONG               numberNodes;

    status = PnPBiosGetBiosInfo( &biosInfo, &length );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    status = PnPBiosTranslateInfo( biosInfo,
                                   length,
                                   &devNodeInfoList,
                                   &numberNodes );

    ExFreePool( biosInfo );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    status = PnPBiosEliminateDupes( devNodeInfoList, numberNodes );

    if (NT_SUCCESS( status )) {

        status = PnPBiosWriteInfo( devNodeInfoList, numberNodes );

    }

    PnPBiosFreeDevNodeInfo( devNodeInfoList, numberNodes );

    return status;
}

VOID
PpFilterNtResource (
    IN PWCHAR PnpDeviceName,
    PIO_RESOURCE_REQUIREMENTS_LIST ResReqList
)
{
    PIO_RESOURCE_LIST ioResourceList;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptors;

    if (ResReqList == NULL) {
        return;
    }

#if 0 //_X86_
    if (KeI386MachineType == MACHINE_TYPE_EISA) {

        PCM_FULL_RESOURCE_DESCRIPTOR    fullDescriptor;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;
        PUCHAR                          nextDescriptor;
        ULONG                           j;
        ULONG                           lastResourceIndex;

        fullDescriptor = &ResourceList->List[0];

        for (i = 0; i < ResourceList->Count; i++) {

            partialResourceList = &fullDescriptor->PartialResourceList;

            for (j = 0; j < partialResourceList->Count; j++) {
                partialDescriptor = &partialResourceList->PartialDescriptors[j];

                if (partialDescriptor->Type == CmResourceTypePort) {
                    if (partialDescriptor->u.Port.Start.HighPart == 0 &&
                        (partialDescriptor->u.Port.Start.LowPart & 0x00000300) == 0) {
                        partialDescriptor->Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
                }
            }

            nextDescriptor = (PUCHAR)fullDescriptor + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

            //
            // account for any resource descriptors in addition to the single
            // imbedded one I've already accounted for (if there aren't any,
            // then I'll end up subtracting off the extra imbedded descriptor
            // from the previous step)
            //
            //
            // finally, account for any extra device specific data at the end of
            // the last partial resource descriptor (if any)
            //
            if (partialResourceList->Count > 0) {

                nextDescriptor += (partialResourceList->Count - 1) *
                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                lastResourceIndex = partialResourceList->Count - 1;

                if (partialResourceList->PartialDescriptors[lastResourceIndex].Type ==
                          CmResourceTypeDeviceSpecific) {

                    nextDescriptor += partialResourceList->PartialDescriptors[lastResourceIndex].
                               u.DeviceSpecificData.DataSize;
                }
            }

            fullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)nextDescriptor;
        }
    }
#endif

    if (RtlCompareMemory(PnpDeviceName,
                         L"*PNP06",
                         sizeof(L"*PNP06") - sizeof(WCHAR)) ==
                         sizeof(L"*PNP06") - sizeof(WCHAR)) {

        ULONG i, j;

        ioResourceList = ResReqList->List;

        for (j = 0; j < ResReqList->AlternativeLists; j++) {

            ioResourceDescriptors = ioResourceList->Descriptors;

            for (i = 0; i < ioResourceList->Count; i++) {

                if (ioResourceDescriptors[i].Type == CmResourceTypePort) {

                    //
                    // some bios asks for 1 too many io port for ide channel
                    //
                    if ((ioResourceDescriptors[i].u.Port.Length == 2) &&
                            (ioResourceDescriptors[i].u.Port.MaximumAddress.QuadPart ==
                            (ioResourceDescriptors[i].u.Port.MinimumAddress.QuadPart + 1))) {

                            ioResourceDescriptors[i].u.Port.Length = 1;
                        ioResourceDescriptors[i].u.Port.MaximumAddress =
                            ioResourceDescriptors[i].u.Port.MinimumAddress;
                    }
                }
            }

            ioResourceList = (PIO_RESOURCE_LIST) (ioResourceDescriptors + ioResourceList->Count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpres.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpres.c

Abstract:

    This module contains the plug-and-play resource allocation and translation
    routines

Author:

    Shie-Lin Tzong (shielint) 1-Mar-1997

Environment:

    Kernel mode

Revision History:

    25-Sept-1998    SantoshJ    Made IopAssign non-recursive.
    01-Oct-1998     SantoshJ    Replaced "complex (broken)" hypercube code and
                                replaced with cascading counters. Simple,
                                faster, smaller code.
                                Added timeouts to IopAssign.
                                Added more self-debugging capability by
                                generating more meaningful debug spew.
    03-Feb-1999     SantoshJ    Do allocation one device at a time.
                                Do devices with BOOT config before others.
                                Optimize IopFindBusDeviceNode.
    22-Feb-2000     SantoshJ    Add level field to arbiter entry. Arbiter list
                                gets sorted by depth so there is no need to
                                walk the tree while calling arbiters.
    01-Mar-2000     SantoshJ    Added look-up table for legacy interface and
                                bus numbers. Avoids walking the device tree.
    13-Mar-2000     SantoshJ    Cleaned up BOOT allocation related code.
    16-Mar-2000     SantoshJ    Replaced all individual references to
                                PpRegistrySemaphore with IopXXXResourceManager
                                macro.
    17-Mar-2000     SantoshJ    Replaced all debug prints with IopDbgPrint
    20-Mar-2000     SantoshJ    Removed redundant fields from internal data
                                structures.
    21-Mar-2000     SantoshJ    Cleaned up all definitions, MACROs etc.

 --*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// CONSTANT defintions.
//
//
// Set this to 1 for maximum instrumentation.
//
#define MAXDBG                              0
//
// Timeout value for IopFindBestConfiguration in milliseconds.
//
#define FIND_BEST_CONFIGURATION_TIMEOUT     5000
//
// Tag used for memory allocation.
//
#define PNP_RESOURCE_TAG                    'erpP'
//
// Forward typedefs.
//
typedef struct _REQ_DESC
    REQ_DESC, *PREQ_DESC;
typedef struct _REQ_LIST
    REQ_LIST, *PREQ_LIST;
typedef struct _REQ_ALTERNATIVE
    REQ_ALTERNATIVE, *PREQ_ALTERNATIVE, **PPREQ_ALTERNATIVE;
typedef struct _DUPLICATE_DETECTION_CONTEXT
    DUPLICATE_DETECTION_CONTEXT, *PDUPLICATE_DETECTION_CONTEXT;
typedef struct _IOP_POOL
    IOP_POOL, *PIOP_POOL;
//
// Structure definitions.
//
// REQ_LIST represents a list of logical configurations within the
// IO_RESOURCE_REQUIREMENTS_LIST.
//
struct _REQ_LIST {
    INTERFACE_TYPE          InterfaceType;
    ULONG                   BusNumber;
    PIOP_RESOURCE_REQUEST   Request;                // Owning request
    PPREQ_ALTERNATIVE       SelectedAlternative;    // Alternative selected
    PPREQ_ALTERNATIVE       BestAlternative;        // Best alternative
    ULONG                   AlternativeCount;       // AlternativeTable length
    PREQ_ALTERNATIVE        AlternativeTable[1];    // Variable length
};
//
// REQ_ALTERNATIVE represents a logical configuration.
//
struct _REQ_ALTERNATIVE {
    ULONG       Priority;               // Priority for this configuration
    ULONG       Position;               // Used for sorting if Priority is identical
    PREQ_LIST   ReqList;                // List containing this configuration
    ULONG       ReqAlternativeIndex;    // Index within the table in the list
    ULONG       DescCount;              // Entry count for DescTable
    PREQ_DESC   DescTable[1];           // Variable length
};
//
// REQ_DESC represents a resource descriptor within a logical configuration.
//
struct _REQ_DESC {
    INTERFACE_TYPE                  InterfaceType;
    ULONG                           BusNumber;
    BOOLEAN                         ArbitrationRequired;
    UCHAR                           Reserved[3];
    PREQ_ALTERNATIVE                ReqAlternative;
    ULONG                           ReqDescIndex;
    PREQ_DESC                       TranslatedReqDesc;
    ARBITER_LIST_ENTRY              AlternativeTable;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Allocation;
    ARBITER_LIST_ENTRY              BestAlternativeTable;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  BestAllocation;
    ULONG                           DevicePrivateCount; // DevicePrivate info
    PIO_RESOURCE_DESCRIPTOR         DevicePrivate;      // per LogConf
    union {
        PPI_RESOURCE_ARBITER_ENTRY      Arbiter;    // In original REQ_DESC
        PPI_RESOURCE_TRANSLATOR_ENTRY   Translator; // In translated REQ_DESC
    } u;
};
//
// Duplicate_detection_Context
//
struct _DUPLICATE_DETECTION_CONTEXT {
    PCM_RESOURCE_LIST   TranslatedResources;
    PDEVICE_NODE        Duplicate;
};
//
// Pool
//
struct _IOP_POOL {
    PUCHAR  PoolStart;
    ULONG   PoolSize;
};
#if DBG_SCOPE

typedef struct {
    PDEVICE_NODE                    devnode;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  resource;
} PNPRESDEBUGTRANSLATIONFAILURE;

#endif  // DBG_SCOPE
//
// MACROS
//
// Reused device node fields.
//
#define NextDeviceNode                      Sibling
#define PreviousDeviceNode                  Child
//
// Call this macro to block other resource allocations and releases in the
// system.
//
#define IopLockResourceManager() {      \
    KeEnterCriticalRegion();            \
    KeWaitForSingleObject(              \
        &PpRegistrySemaphore,           \
        DelayExecution,                 \
        KernelMode,                     \
        FALSE,                          \
        NULL);                          \
}
//
// Unblock other resource allocations and releases in the system.
//
#define IopUnlockResourceManager() {    \
    KeReleaseSemaphore(                 \
        &PpRegistrySemaphore,           \
        0,                              \
        1,                              \
        FALSE);                         \
    KeLeaveCriticalRegion();            \
}
//
// Initialize arbiter entry.
//
#define IopInitializeArbiterEntryState(a) {         \
    (a)->ResourcesChanged   = FALSE;                \
    (a)->State              = 0;                    \
    InitializeListHead(&(a)->ActiveArbiterList);    \
    InitializeListHead(&(a)->BestConfig);           \
    InitializeListHead(&(a)->ResourceList);         \
    InitializeListHead(&(a)->BestResourceList);     \
}

#define IS_TRANSLATED_REQ_DESC(r)   (!((r)->ReqAlternative))
//
// Pool management MACROs
//
#define IopInitPool(Pool,Start,Size) {      \
    (Pool)->PoolStart   = (Start);          \
    (Pool)->PoolSize    = (Size);           \
    RtlZeroMemory(Start, Size);             \
}
#define IopAllocPool(M,P,S) {                                       \
    *(M)            = (PVOID)(P)->PoolStart;                        \
    ASSERT((P)->PoolStart + (S) <= (P)->PoolStart + (P)->PoolSize); \
    (P)->PoolStart  += (S);                                         \
}
//
// IopReleaseBootResources can only be called for non ROOT enumerated devices
//
#define IopReleaseBootResources(DeviceNode) {                       \
    ASSERT(((DeviceNode)->Flags & DNF_MADEUP) == 0);                \
    IopReleaseResourcesInternal(DeviceNode);                        \
    (DeviceNode)->Flags &= ~DNF_HAS_BOOT_CONFIG;                    \
    (DeviceNode)->Flags &= ~DNF_BOOT_CONFIG_RESERVED;               \
    if ((DeviceNode)->BootResources) {                              \
        ExFreePool((DeviceNode)->BootResources);                    \
        (DeviceNode)->BootResources = NULL;                         \
    }                                                               \
}
//
// Debug support
//
#ifdef POOL_TAGGING

#undef ExAllocatePool
#define ExAllocatePool(a,b)         ExAllocatePoolWithTag(a,b,PNP_RESOURCE_TAG)

#endif // POOL_TAGGING

#if MAXDBG

#define ExAllocatePoolAT(a,b)       ExAllocatePoolWithTag(a,b,'0rpP')
#define ExAllocatePoolRD(a,b)       ExAllocatePoolWithTag(a,b,'1rpP')
#define ExAllocatePoolCMRL(a,b)     ExAllocatePoolWithTag(a,b,'2rpP')
#define ExAllocatePoolCMRR(a,b)     ExAllocatePoolWithTag(a,b,'3rpP')
#define ExAllocatePoolAE(a,b)       ExAllocatePoolWithTag(a,b,'4rpP')
#define ExAllocatePoolTE(a,b)       ExAllocatePoolWithTag(a,b,'5rpP')
#define ExAllocatePoolPRD(a,b)      ExAllocatePoolWithTag(a,b,'6rpP')
#define ExAllocatePoolIORD(a,b)     ExAllocatePoolWithTag(a,b,'7rpP')
#define ExAllocatePool1RD(a,b)      ExAllocatePoolWithTag(a,b,'8rpP')
#define ExAllocatePoolPDO(a,b)      ExAllocatePoolWithTag(a,b,'9rpP')
#define ExAllocatePoolIORR(a,b)     ExAllocatePoolWithTag(a,b,'ArpP')
#define ExAllocatePoolIORL(a,b)     ExAllocatePoolWithTag(a,b,'BrpP')
#define ExAllocatePoolIORRR(a,b)    ExAllocatePoolWithTag(a,b,'CrpP')

#else  // MAXDBG

#define ExAllocatePoolAT(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolRD(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolCMRL(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolCMRR(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolAE(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolTE(a,b)       ExAllocatePool(a,b)
#define ExAllocatePoolPRD(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolIORD(a,b)     ExAllocatePool(a,b)
#define ExAllocatePool1RD(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolPDO(a,b)      ExAllocatePool(a,b)
#define ExAllocatePoolIORR(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolIORL(a,b)     ExAllocatePool(a,b)
#define ExAllocatePoolIORRR(a,b)    ExAllocatePool(a,b)

#endif // MAXDBG

#if DBG_SCOPE

#define IopStopOnTimeout()                  (IopUseTimeout)

VOID
IopDumpResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR Desc
    );

VOID
IopDumpResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResources
    );

VOID
IopDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    );

VOID
IopDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    );

VOID
IopCheckDataStructuresWorker (
    IN PDEVICE_NODE Device
    );

VOID
IopCheckDataStructures (
    IN PDEVICE_NODE DeviceNode
    );

#define IopRecordTranslationFailure(d,s) {              \
    if (PnpResDebugTranslationFailureCount) {           \
        PnpResDebugTranslationFailureCount--;           \
        PnpResDebugTranslationFailure->devnode = d;     \
        PnpResDebugTranslationFailure->resource = s;    \
        PnpResDebugTranslationFailure++;                \
    }                                                   \
}

#else

#define IopStopOnTimeout()                  1
#define IopRecordTranslationFailure(d,s)
#define IopDumpResourceRequirementsList(x)
#define IopDumpResourceDescriptor(x,y)
#define IopDumpCmResourceList(c)
#define IopDumpCmResourceDescriptor(i,d)
#define IopCheckDataStructures(x)

#endif // DBG_SCOPE
//
// Internal/Forward function references
//
VOID
IopRemoveLegacyDeviceNode (
    IN PDEVICE_OBJECT   DeviceObject OPTIONAL,
    IN PDEVICE_NODE     LegacyDeviceNode
    );

NTSTATUS
IopFindLegacyDeviceNode (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PDEVICE_NODE *LegacyDeviceNode,
    OUT PDEVICE_OBJECT *LegacyPDO
    );

NTSTATUS
IopGetResourceRequirementsForAssignTable (
    IN  PIOP_RESOURCE_REQUEST   RequestTable,
    IN  PIOP_RESOURCE_REQUEST   RequestTableEnd,
    OUT PULONG                  DeviceCount
    );

NTSTATUS
IopResourceRequirementsListToReqList(
    IN PIOP_RESOURCE_REQUEST Request,
    OUT PVOID *ResReqList
    );

VOID
IopRearrangeReqList (
    IN PREQ_LIST ReqList
    );

VOID
IopRearrangeAssignTable (
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN ULONG Count
    );

int
__cdecl
IopCompareReqAlternativePriority (
    const void *arg1,
    const void *arg2
    );

int
__cdecl
IopCompareResourceRequestPriority(
    const void *arg1,
    const void *arg2
    );

VOID
IopBuildCmResourceLists(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

VOID
IopBuildCmResourceList (
    IN PIOP_RESOURCE_REQUEST AssignEntry
    );

NTSTATUS
IopSetupArbiterAndTranslators(
    IN PREQ_DESC ReqDesc
    );

BOOLEAN
IopFindResourceHandlerInfo(
    IN RESOURCE_HANDLER_TYPE    HandlerType,
    IN PDEVICE_NODE             DeviceNode,
    IN UCHAR                    ResourceType,
    OUT PVOID                   *HandlerEntry
    );

NTSTATUS
IopParentToRawTranslation(
    IN OUT PREQ_DESC ReqDesc
    );

NTSTATUS
IopChildToRootTranslation(
    IN PDEVICE_NODE DeviceNode,  OPTIONAL
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ARBITER_REQUEST_SOURCE ArbiterRequestSource,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
IopTranslateAndAdjustReqDesc(
    IN PREQ_DESC ReqDesc,
    IN PPI_RESOURCE_TRANSLATOR_ENTRY TranslatorEntry,
    OUT PREQ_DESC *TranslatedReqDesc
    );

NTSTATUS
IopCallArbiter(
    PPI_RESOURCE_ARBITER_ENTRY ArbiterEntry,
    ARBITER_ACTION Command,
    PVOID Input1,
    PVOID Input2,
    PVOID Input3
    );

NTSTATUS
IopFindResourcesForArbiter (
    IN PDEVICE_NODE DeviceNode,
    IN UCHAR ResourceType,
    OUT ULONG *Count,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *CmDesc
    );

VOID
IopReleaseResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopReleaseResources (
    IN PDEVICE_NODE DeviceNode
    );

NTSTATUS
IopRestoreResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    );

VOID
IopSetLegacyDeviceInstance (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_NODE DeviceNode
    );

PCM_RESOURCE_LIST
IopCombineLegacyResources (
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
IopNeedToReleaseBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST AllocatedResources
    );

VOID
IopReleaseFilteredBootResources(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

NTSTATUS
IopQueryConflictListInternal(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    );

NTSTATUS
IopQueryConflictFillConflicts(
    PDEVICE_OBJECT              PhysicalDeviceObject,
    IN ULONG                    ConflictCount,
    IN PARBITER_CONFLICT_INFO   ConflictInfoList,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG                    ConflictListSize,
    IN ULONG                    Flags
    );

NTSTATUS
IopQueryConflictFillString(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWSTR            Buffer,
    IN OUT PULONG       Length,
    IN OUT PULONG       Flags
    );

BOOLEAN
IopEliminateBogusConflict(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PDEVICE_OBJECT   ConflictDeviceObject
    );

VOID
IopQueryRebalance (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

VOID
IopQueryRebalanceWorker (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG RebalancePhase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

VOID
IopTestForReconfiguration (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG RebalancePhase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    );

NTSTATUS
IopRebalance (
    IN ULONG AssignTableCont,
    IN PIOP_RESOURCE_REQUEST AssignTable
    );

NTSTATUS
IopTestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

NTSTATUS
IopRetestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

NTSTATUS
IopCommitConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    );

VOID
IopSelectFirstConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    );

BOOLEAN
IopSelectNextConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    );

VOID
IopCleanupSelectedConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    );

ULONG
IopComputeConfigurationPriority (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    );

VOID
IopSaveRestoreConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ArbiterList,
    IN      BOOLEAN                 Save
    );

VOID
IopAddRemoveReqDescs (
    IN      PREQ_DESC   *ReqDescTable,
    IN      ULONG       ReqDescCount,
    IN OUT  PLIST_ENTRY ActiveArbiterList,
    IN      BOOLEAN     Add
    );

NTSTATUS
IopFindBestConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ActiveArbiterList
    );

PDEVICE_NODE
IopFindLegacyBusDeviceNode (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber
    );

NTSTATUS
IopAllocateBootResourcesInternal (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    );

NTSTATUS
IopBootAllocation (
    IN PREQ_LIST ReqList
    );

PCM_RESOURCE_LIST
IopCreateCmResourceList(
    IN PCM_RESOURCE_LIST ResourceList,
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG   BusNumber,
    OUT PCM_RESOURCE_LIST *RemainingList
    );

PCM_RESOURCE_LIST
IopCombineCmResourceList(
    IN PCM_RESOURCE_LIST ResourceListA,
    IN PCM_RESOURCE_LIST ResourceListB
    );

VOID
IopFreeReqAlternative (
    IN PREQ_ALTERNATIVE ReqAlternative
    );

VOID
IopFreeReqList (
    IN PREQ_LIST ReqList
    );

VOID
IopFreeResourceRequirementsForAssignTable(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IopAllocateResources)
#pragma alloc_text(PAGE, IopReleaseDeviceResources)
#pragma alloc_text(PAGE, IopGetResourceRequirementsForAssignTable)
#pragma alloc_text(PAGE, IopResourceRequirementsListToReqList)
#pragma alloc_text(PAGE, IopRearrangeReqList)
#pragma alloc_text(PAGE, IopRearrangeAssignTable)
#pragma alloc_text(PAGE, IopBuildCmResourceLists)
#pragma alloc_text(PAGE, IopBuildCmResourceList)
#pragma alloc_text(PAGE, IopSetupArbiterAndTranslators)
#pragma alloc_text(PAGE, IopUncacheInterfaceInformation)
#pragma alloc_text(PAGE, IopFindResourceHandlerInfo)
#pragma alloc_text(PAGE, IopParentToRawTranslation)
#pragma alloc_text(PAGE, IopChildToRootTranslation)
#pragma alloc_text(PAGE, IopTranslateAndAdjustReqDesc)
#pragma alloc_text(PAGE, IopCallArbiter)
#pragma alloc_text(PAGE, IopFindResourcesForArbiter)
#pragma alloc_text(PAGE, IopLegacyResourceAllocation)
#pragma alloc_text(PAGE, IopFindLegacyDeviceNode)
#pragma alloc_text(PAGE, IopRemoveLegacyDeviceNode)
#pragma alloc_text(PAGE, IopDuplicateDetection)
#pragma alloc_text(PAGE, IopReleaseResourcesInternal)
#pragma alloc_text(PAGE, IopRestoreResourcesInternal)
#pragma alloc_text(PAGE, IopSetLegacyDeviceInstance)
#pragma alloc_text(PAGE, IopCombineLegacyResources)
#pragma alloc_text(PAGE, IopReleaseResources)
#pragma alloc_text(PAGE, IopReallocateResources)
#pragma alloc_text(PAGE, IopReleaseFilteredBootResources)
#pragma alloc_text(PAGE, IopNeedToReleaseBootResources)
#pragma alloc_text(PAGE, IopQueryConflictList)
#pragma alloc_text(PAGE, IopQueryConflictListInternal)
#pragma alloc_text(PAGE, IopQueryConflictFillConflicts)
#pragma alloc_text(PAGE, IopQueryConflictFillString)
#pragma alloc_text(PAGE, IopCompareReqAlternativePriority)
#pragma alloc_text(PAGE, IopCompareResourceRequestPriority)
#pragma alloc_text(PAGE, IopQueryRebalance)
#pragma alloc_text(PAGE, IopQueryRebalanceWorker)
#pragma alloc_text(PAGE, IopTestForReconfiguration)
#pragma alloc_text(PAGE, IopRebalance)
#pragma alloc_text(PAGE, IopTestConfiguration)
#pragma alloc_text(PAGE, IopRetestConfiguration)
#pragma alloc_text(PAGE, IopCommitConfiguration)
#pragma alloc_text(PAGE, IopSelectFirstConfiguration)
#pragma alloc_text(PAGE, IopSelectNextConfiguration)
#pragma alloc_text(PAGE, IopCleanupSelectedConfiguration)
#pragma alloc_text(PAGE, IopComputeConfigurationPriority)
#pragma alloc_text(PAGE, IopSaveRestoreConfiguration)
#pragma alloc_text(PAGE, IopAddRemoveReqDescs)
#pragma alloc_text(PAGE, IopFindBestConfiguration)
#pragma alloc_text(PAGE, IopInsertLegacyBusDeviceNode)
#pragma alloc_text(PAGE, IopFindLegacyBusDeviceNode)
#pragma alloc_text(PAGE, IopAllocateBootResources)
#pragma alloc_text(INIT, IopReportBootResources)
#pragma alloc_text(INIT, IopAllocateLegacyBootResources)
#pragma alloc_text(PAGE, IopAllocateBootResourcesInternal)
#pragma alloc_text(PAGE, IopBootAllocation)
#pragma alloc_text(PAGE, IopCreateCmResourceList)
#pragma alloc_text(PAGE, IopCombineCmResourceList)
#pragma alloc_text(PAGE, IopFreeReqAlternative)
#pragma alloc_text(PAGE, IopFreeReqList)
#pragma alloc_text(PAGE, IopFreeResourceRequirementsForAssignTable)
#if DBG_SCOPE

#pragma alloc_text(PAGE, IopCheckDataStructures)
#pragma alloc_text(PAGE, IopCheckDataStructuresWorker)
#pragma alloc_text(PAGE, IopDumpResourceRequirementsList)
#pragma alloc_text(PAGE, IopDumpResourceDescriptor)
#pragma alloc_text(PAGE, IopDumpCmResourceDescriptor)
#pragma alloc_text(PAGE, IopDumpCmResourceList)

#endif  // DBG_SCOPE

#endif // ALLOC_PRAGMA
//
// External references
//
extern const WCHAR IopWstrTranslated[];
extern const WCHAR IopWstrRaw[];
//
// GLOBAL variables
//
PIOP_RESOURCE_REQUEST   PiAssignTable;
ULONG                   PiAssignTableCount;
PDEVICE_NODE            IopLegacyDeviceNode;    // Head of list of made-up
                                                // devicenodes used for legacy
                                                // allocation.
                                                // IoAssignResources &
                                                // IoReportResourceUsage
#if DBG_SCOPE

ULONG
    PnpResDebugTranslationFailureCount = 32;  // get count in both this line and the next.
PNPRESDEBUGTRANSLATIONFAILURE
    PnpResDebugTranslationFailureArray[32];
PNPRESDEBUGTRANSLATIONFAILURE
    *PnpResDebugTranslationFailure = PnpResDebugTranslationFailureArray;
ULONG IopUseTimeout = 0;

#endif  // DBG_SCOPE

NTSTATUS
IopAllocateResources(
    IN PULONG                       RequestCount,
    IN OUT PIOP_RESOURCE_REQUEST    *Request,
    IN BOOLEAN                      ResourceManagerLocked,
    IN BOOLEAN                      DoBootConfigs,
    OUT PBOOLEAN                    RebalancePerformed
    )

/*++

Routine Description:

    For each AssignTable entry, this routine queries device's IO resource requirements
    list and converts it to our internal REQ_LIST format; calls worker routine to perform
    the resources assignment.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

    Locked - Indicates whether the PpRegistrySemaphore is acquired by the caller.

    DoBootConfigs - Indicates whether we should assign BOOT configs.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS                status;
    PIOP_RESOURCE_REQUEST   requestTable;
    PIOP_RESOURCE_REQUEST   requestTableEnd;
    ULONG                   deviceCount;
    BOOLEAN                 attemptRebalance;
    PIOP_RESOURCE_REQUEST   requestEntry;
    LIST_ENTRY              activeArbiterList;

    PAGED_CODE();

    //
    // Lock the resource manager if the caller has not locked already.
    // This is to serialize allocations and releases of resources from the
    // arbiters.
    //
    if (!ResourceManagerLocked) {

        IopLockResourceManager();
    }
    requestTable    = *Request;
    requestTableEnd = requestTable + (deviceCount = *RequestCount);
    status = IopGetResourceRequirementsForAssignTable(requestTable, requestTableEnd, &deviceCount);
    if (deviceCount) {

        attemptRebalance = ((*RequestCount == 1) && (requestTable->Flags & IOP_ASSIGN_NO_REBALANCE))? FALSE : TRUE;
        if (DoBootConfigs) {

            if (!IopBootConfigsReserved) {

                //
                // Process devices with boot config. If there are none, process others.
                //
                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    PDEVICE_NODE    deviceNode;

                    deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                    if (deviceNode->Flags & DNF_HAS_BOOT_CONFIG) {

                        break;
                    }
                }
                if (requestEntry != requestTableEnd) {

                    //
                    // There is at least one device with boot config.
                    //
                    for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                        PDEVICE_NODE    deviceNode;

                        deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                        if (    !(requestEntry->Flags & IOP_ASSIGN_IGNORE) &&
                                !(deviceNode->Flags & DNF_HAS_BOOT_CONFIG) &&
                                requestEntry->ResourceRequirements) {

                            IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "Delaying non BOOT config device %wZ...\n", &deviceNode->InstancePath));
                            requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                            requestEntry->Status = STATUS_RETRY;
                            deviceCount--;
                        }
                    }
                }
            }
            if (deviceCount) {

                if (deviceCount != (*RequestCount)) {
                    //
                    // Move the uninteresting devices to the end of the table.
                    //
                    for (requestEntry = requestTable; requestEntry < requestTableEnd; ) {

                        IOP_RESOURCE_REQUEST temp;

                        if (!(requestEntry->Flags & IOP_ASSIGN_IGNORE)) {

                            requestEntry++;
                            continue;
                        }
                        temp = *requestEntry;
                        *requestEntry = *(requestTableEnd - 1);
                        *(requestTableEnd - 1) = temp;
                        requestTableEnd--;
                    }
                }
                ASSERT((ULONG)(requestTableEnd - requestTable) == deviceCount);
                //
                // Sort the AssignTable
                //
                IopRearrangeAssignTable(requestTable, deviceCount);
                //
                // Try one device at a time.
                //
                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    PDEVICE_NODE    deviceNode;

                    deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "Trying to allocate resources for %ws.\n", deviceNode->InstancePath.Buffer));
                    status = IopFindBestConfiguration(requestEntry, 1, &activeArbiterList);
                    if (NT_SUCCESS(status)) {
                        //
                        // Ask the arbiters to commit this configuration.
                        //
                        status = IopCommitConfiguration(&activeArbiterList);
                        if (NT_SUCCESS(status)) {

                            IopBuildCmResourceLists(requestEntry, requestEntry + 1);
                            break;
                        } else {

                            requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                        }
                    } else if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        IopDbgPrint((
                            IOP_RESOURCE_WARNING_LEVEL,
                            "IopAllocateResource: Failed to allocate Pool.\n"));
                        break;

                    } else if (attemptRebalance) {

                        IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Initiating REBALANCE...\n"));

                        deviceNode->Flags |= DNF_NEEDS_REBALANCE;
                        status = IopRebalance(1, requestEntry);
                        deviceNode->Flags &= ~DNF_NEEDS_REBALANCE;
                        if (!NT_SUCCESS(status)) {

                            requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                        } else if (RebalancePerformed) {

                            *RebalancePerformed = TRUE;
                            break;
                        }
                    } else {

                        requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                    }
                }
                //
                // If we ran out of memory, then set the appropriate status
                // on remaining devices. On success, set STATUS_RETRY on the 
                // rest so we will attempt allocation again after the current 
                // device is started.
                //
                if (NT_SUCCESS(status)) {

                    requestEntry++;
                }
                for (; requestEntry < requestTableEnd; requestEntry++) {

                    if (status == STATUS_INSUFFICIENT_RESOURCES) {

                        requestEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        requestEntry->Status = STATUS_RETRY;
                        requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                    }
                }

                for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                    if (requestEntry->Flags & (IOP_ASSIGN_IGNORE | IOP_ASSIGN_RETRY)) {

                        continue;
                    }
                    if (    requestEntry->Status == STATUS_SUCCESS &&
                            requestEntry->AllocationType == ArbiterRequestPnpEnumerated) {

                        IopReleaseFilteredBootResources(requestEntry, requestEntry + 1);
                    }
                    if ((requestEntry->Flags & IOP_ASSIGN_EXCLUDE) || requestEntry->ResourceAssignment == NULL) {

                        requestEntry->Status = STATUS_CONFLICTING_ADDRESSES;
                    }
                }
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        } else {
            //
            // Only process devices with no requirements.
            //
            for (requestEntry = requestTable; requestEntry < requestTableEnd; requestEntry++) {

                PDEVICE_NODE    deviceNode;

                deviceNode = PP_DO_TO_DN(requestEntry->PhysicalDevice);
                if (NT_SUCCESS(requestEntry->Status) && requestEntry->ResourceRequirements == NULL) {

                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Processing no resource requiring device %wZ\n", &deviceNode->InstancePath));
                } else {

                    IopDbgPrint((IOP_RESOURCE_INFO_LEVEL, "IopAllocateResources: Ignoring resource consuming device %wZ\n", &deviceNode->InstancePath));
                    requestEntry->Flags |= IOP_ASSIGN_IGNORE;
                    requestEntry->Status = STATUS_RETRY;
                }
            }
        }
        IopFreeResourceRequirementsForAssignTable(requestTable, requestTableEnd);
    }
    if (!ResourceManagerLocked) {

        IopUnlockResourceManager();
    }

    return status;
}

NTSTATUS
IopReleaseDeviceResources (
    IN PDEVICE_NODE DeviceNode,
    IN BOOLEAN ReserveResources
    )

/*++

Routine Description:

    This routine releases the resources assigned to a device.

Arguments:

    DeviceNode          - Device whose resources are to be released.

    ReserveResources    - TRUE specifies that the BOOT config needs to be
                          reserved (after re-query).

Return Value:

    Final status code.


--*/
{
    NTSTATUS            status;
    PCM_RESOURCE_LIST   cmResource;
    ULONG               cmLength;

    PAGED_CODE();

    if (    !DeviceNode->ResourceList &&
            !(DeviceNode->Flags & DNF_BOOT_CONFIG_RESERVED)) {

        return STATUS_SUCCESS;
    }
    cmResource  = NULL;
    cmLength    = 0;
    //
    // If needed, re-query for BOOT configs. We need to do this BEFORE we
    // release the BOOT config (otherwise ROOT devices cannot report BOOT
    // config).
    //
    if (ReserveResources && !(DeviceNode->Flags & DNF_MADEUP)) {
        //
        // First query for new BOOT config (order important for ROOT devices).
        //
        status = IopQueryDeviceResources(
                    DeviceNode->PhysicalDeviceObject,
                    QUERY_RESOURCE_LIST,
                    &cmResource,
                    &cmLength);
        if (!NT_SUCCESS(status)) {

            cmResource  = NULL;
            cmLength    = 0;
        }
    }
    //
    // Release resources for this device.
    //
    status = IopLegacyResourceAllocation(
                ArbiterRequestUndefined,
                IoPnpDriverObject,
                DeviceNode->PhysicalDeviceObject,
                NULL,
                NULL);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Request reallocation of resources for conflicting devices.
    //

    PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);

    //
    // If needed, re-query and reserve current BOOT config for this device.
    // We always rereserve the boot config (ie DNF_MADEUP root enumerated
    // and IoReportDetected) devices in IopLegacyResourceAllocation.
    //
    if (ReserveResources && !(DeviceNode->Flags & DNF_MADEUP)) {

        UNICODE_STRING      unicodeName;
        HANDLE              logConfHandle;
        HANDLE              handle;

        ASSERT(DeviceNode->BootResources == NULL);
        status = IopDeviceObjectToDeviceInstance(
                    DeviceNode->PhysicalDeviceObject,
                    &handle,
                    KEY_ALL_ACCESS);
        logConfHandle = NULL;
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopCreateRegistryKeyEx(
                        &logConfHandle,
                        handle,
                        &unicodeName,
                        KEY_ALL_ACCESS,
                        REG_OPTION_NON_VOLATILE,
                        NULL);
            ZwClose(handle);
            if (!NT_SUCCESS(status)) {

                logConfHandle = NULL;
            }
        }
        if (logConfHandle) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_BOOTCONFIG);
            PiLockPnpRegistry(FALSE);
            if (cmResource) {

                ZwSetValueKey(
                    logConfHandle,
                    &unicodeName,
                    TITLE_INDEX_VALUE,
                    REG_RESOURCE_LIST,
                    cmResource,
                    cmLength);
            } else {

                ZwDeleteValueKey(logConfHandle, &unicodeName);
            }
            PiUnlockPnpRegistry();
            ZwClose(logConfHandle);
        }
        //
        // Reserve any remaining BOOT config.
        //
        if (cmResource) {

            DeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            //
            // This device consumes BOOT resources.  Reserve its boot resources
            //
            (*IopAllocateBootResourcesRoutine)(
                ArbiterRequestPnpEnumerated,
                DeviceNode->PhysicalDeviceObject,
                DeviceNode->BootResources = cmResource);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopGetResourceRequirementsForAssignTable (
    IN  PIOP_RESOURCE_REQUEST   RequestTable,
    IN  PIOP_RESOURCE_REQUEST   RequestTableEnd,
    OUT PULONG                  DeviceCount
    )

/*++

Routine Description:

    This function gets resource requirements for entries in the request table.

Parameters:

    RequestTable    - Start of request table.

    RequestTableEnd - End of request table.

    DeviceCount     - Gets number of devices with non-NULL requirements.

Return Value:

    STATUS_SUCCESS if we got one non-NULL requirement, else STATUS_UNSUCCESSFUL.

--*/

{
    PIOP_RESOURCE_REQUEST   request;
    NTSTATUS                status;
    PDEVICE_NODE            deviceNode;
    ULONG                   length;

    PAGED_CODE();

    *DeviceCount = 0;
    for (   request = RequestTable;
            request < RequestTableEnd;
            request++) {
        //
        // Skip uninteresting entries.
        //
        request->ReqList = NULL;
        if (request->Flags & IOP_ASSIGN_IGNORE) {

            continue;
        }
        request->ResourceAssignment             = NULL;
        request->TranslatedResourceAssignment   = NULL;
        deviceNode                              = PP_DO_TO_DN(
                                                    request->PhysicalDevice);
        if (    (deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) &&
                deviceNode->ResourceRequirements) {

            ExFreePool(deviceNode->ResourceRequirements);
            deviceNode->ResourceRequirements = NULL;
            deviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
            //
            // Mark that caller needs to clear DNF_RESOURCE_REQUIREMENTS_CHANGED
            // flag on success.
            //
            request->Flags |= IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG;
        }
        if (!request->ResourceRequirements) {

            if (    deviceNode->ResourceRequirements &&
                    !(deviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED)) {

                IopDbgPrint((   IOP_RESOURCE_VERBOSE_LEVEL,
                                "Resource requirements list already exists for "
                                "%wZ\n",
                                &deviceNode->InstancePath));
                request->ResourceRequirements   = deviceNode->ResourceRequirements;
                request->AllocationType         = ArbiterRequestPnpEnumerated;
            } else {

                IopDbgPrint((   IOP_RESOURCE_INFO_LEVEL,
                                "Query Resource requirements list for %wZ...\n",
                                &deviceNode->InstancePath));
                status = IopQueryDeviceResources(
                            request->PhysicalDevice,
                            QUERY_RESOURCE_REQUIREMENTS,
                            &request->ResourceRequirements,
                            &length);
                if (    !NT_SUCCESS(status) ||
                        !request->ResourceRequirements) {
                    //
                    // Success with NULL ResourceRequirements means no resource
                    // required.
                    //
                    request->Flags  |= IOP_ASSIGN_IGNORE;
                    request->Status = status;
                    continue;
                }
                if (deviceNode->ResourceRequirements) {

                    ExFreePool(deviceNode->ResourceRequirements);
                    deviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
                }
                deviceNode->ResourceRequirements = request->ResourceRequirements;
            }
        }
        //
        // For non-stop case, even though the res req list has changed, we need
        // to guarantee that it will get its current setting, even if the new
        // requirements do not cover the current setting.
        //
        if (request->Flags & IOP_ASSIGN_KEEP_CURRENT_CONFIG) {

            PIO_RESOURCE_REQUIREMENTS_LIST filteredList;
            BOOLEAN exactMatch;

            ASSERT(
                deviceNode->ResourceRequirements ==
                    request->ResourceRequirements);
            status = IopFilterResourceRequirementsList(
                         request->ResourceRequirements,
                         deviceNode->ResourceList,
                         &filteredList,
                         &exactMatch);
            if (NT_SUCCESS(status)) {
                //
                // No need to free the original request->ResourceRequirements
                // since its cached in deviceNode->ResourceRequirements.
                //
                request->ResourceRequirements = filteredList;
            } else {
                //
                // Clear the flag so we dont free request->ResourceRequirements.
                //
                request->Flags &= ~IOP_ASSIGN_KEEP_CURRENT_CONFIG;
            }
        }
        IopDumpResourceRequirementsList(request->ResourceRequirements);
        //
        // Convert the requirements list to our internal representation.
        //
        status = IopResourceRequirementsListToReqList(
                        request,
                        &request->ReqList);
        if (NT_SUCCESS(status) && request->ReqList) {

            PREQ_LIST   reqList = (PREQ_LIST)request->ReqList;
            //
            // Sort the list such that higher priority alternatives are placed
            // in the front of the list.
            //
            IopRearrangeReqList(reqList);
            if (reqList->BestAlternative) {
                //
                // Requests from less flexible devices get higher priority.
                //
                request->Priority = (reqList->AlternativeCount < 3)?
                                        0 : reqList->AlternativeCount;
                request->Status = status;
                (*DeviceCount)++;
                continue;
            }
            //
            // This device has no soft configuration.
            //
            IopFreeResourceRequirementsForAssignTable(request, request + 1);
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        request->Status = status;
        request->Flags  |= IOP_ASSIGN_IGNORE;
    }

    return (*DeviceCount)? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
IopResourceRequirementsListToReqList(
    IN  PIOP_RESOURCE_REQUEST   Request,
    OUT PVOID                   *ResReqList
    )

/*++

Routine Description:

    This routine processes the input Io resource requirements list and
    generates an internal REQ_LIST and its related structures.

Parameters:

    IoResources - supplies a pointer to the Io resource requirements List.

    PhysicalDevice - supplies a pointer to the physical device object requesting
            the resources.

    ReqList - supplies a pointer to a variable to receive the returned REQ_LIST.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIO_RESOURCE_REQUIREMENTS_LIST  ioResources;
    LONG                            ioResourceListCount;
    PIO_RESOURCE_LIST               ioResourceList;
    PIO_RESOURCE_DESCRIPTOR         ioResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR         firstDescriptor;
    PUCHAR                          coreEnd;
    BOOLEAN                         noAlternativeDescriptor;
    ULONG                           reqDescAlternativeCount;
    ULONG                           alternativeDescriptorCount;
    ULONG                           reqAlternativeCount;
    PREQ_LIST                       reqList;
    INTERFACE_TYPE                  interfaceType;
    ULONG                           busNumber;
    NTSTATUS                        status;
    NTSTATUS                        failureStatus;
    NTSTATUS                        finalStatus;

    PAGED_CODE();

    *ResReqList = NULL;
    //
    // Make sure there is some resource requirement to be converted.
    //
    ioResources         = Request->ResourceRequirements;
    ioResourceListCount = (LONG)ioResources->AlternativeLists;
    if (ioResourceListCount == 0) {

        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "No ResReqList to convert to ReqList\n"));
        return STATUS_SUCCESS;
    }
    //
    // ***** Phase 1 *****
    //
    // Parse the requirements list to validate it and determine the sizes of
    // internal structures.
    //
    ioResourceList              = ioResources->List;
    coreEnd                     = (PUCHAR)ioResources + ioResources->ListSize;
    reqDescAlternativeCount     = 0;
    alternativeDescriptorCount  = 0;
    while (--ioResourceListCount >= 0) {

        ioResourceDescriptor    = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceDescriptor == ioResourceDescriptorEnd) {
            //
            // An alternative list with zero descriptor count.
            //
            return STATUS_SUCCESS;
        }
        //
        // Perform sanity check. On failure, simply return failure status.
        //
        if (    ioResourceDescriptor > ioResourceDescriptorEnd ||
                (PUCHAR)ioResourceDescriptor > coreEnd ||
                (PUCHAR)ioResourceDescriptorEnd > coreEnd) {
            //
            // The structure header is invalid (excluding the variable length
            // Descriptors array) or,
            // IoResourceDescriptorEnd is the result of arithmetic overflow or,
            // the descriptor array is outside of the valid memory.
            //
            IopDbgPrint((IOP_RESOURCE_ERROR_LEVEL, "Invalid ResReqList\n"));
            goto InvalidParameter;
        }
        if (ioResourceDescriptor->Type == CmResourceTypeConfigData) {

            ioResourceDescriptor++;
        }
        firstDescriptor         = ioResourceDescriptor;
        noAlternativeDescriptor = TRUE;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {

            switch (ioResourceDescriptor->Type) {
            case CmResourceTypeConfigData:

                 IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Invalid ResReq list !!!\n"
                    "\tConfigData descriptors are per-LogConf and should be at "
                    "the beginning of an AlternativeList\n"));
                 goto InvalidParameter;

            case CmResourceTypeDevicePrivate:

                 while (    ioResourceDescriptor < ioResourceDescriptorEnd &&
                            ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                     if (ioResourceDescriptor == firstDescriptor) {

                        IopDbgPrint((
                            IOP_RESOURCE_ERROR_LEVEL,
                            "Invalid ResReq list !!!\n"
                            "\tThe first descriptor of a LogConf can not be a "
                            "DevicePrivate descriptor.\n"));
                        goto InvalidParameter;
                     }
                     reqDescAlternativeCount++;
                     ioResourceDescriptor++;
                 }
                 noAlternativeDescriptor = TRUE;
                 break;

            default:

                reqDescAlternativeCount++;
                //
                // For non-arbitrated resource type, set its Option to preferred
                // such that we won't get confused.
                //
                if (    (ioResourceDescriptor->Type & CmResourceTypeNonArbitrated) ||
                        ioResourceDescriptor->Type == CmResourceTypeNull) {

                    if (ioResourceDescriptor->Type == CmResourceTypeReserved) {

                        reqDescAlternativeCount--;
                    }
                    ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                    ioResourceDescriptor++;
                    noAlternativeDescriptor = TRUE;
                    break;
                }
                if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {

                    if (noAlternativeDescriptor) {

                        IopDbgPrint((
                            IOP_RESOURCE_ERROR_LEVEL,
                            "Invalid ResReq list !!!\n"
                            "\tAlternative descriptor without Default or "
                            "Preferred descriptor.\n"));
                       goto InvalidParameter;
                    }
                    alternativeDescriptorCount++;
                } else {

                    noAlternativeDescriptor = FALSE;
                }
                ioResourceDescriptor++;
                break;
            }
        }
        ASSERT(ioResourceDescriptor == ioResourceDescriptorEnd);
        ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
    }
    //
    // ***** Phase 2 *****
    //
    // Allocate structures and initialize them according to caller's Io ResReq list.
    //
    {
        ULONG               reqDescCount;
        IOP_POOL            reqAlternativePool;
        IOP_POOL            reqDescPool;
        ULONG               reqListPoolSize;
        ULONG               reqAlternativePoolSize;
        ULONG               reqDescPoolSize;
        PUCHAR              poolStart;
        ULONG               poolSize;
        IOP_POOL            outerPool;
        PREQ_ALTERNATIVE    reqAlternative;
        PPREQ_ALTERNATIVE   reqAlternativePP;
        ULONG               reqAlternativeIndex;
        PREQ_DESC           reqDesc;
        PREQ_DESC           *reqDescPP;
        ULONG               reqDescIndex;
        PARBITER_LIST_ENTRY arbiterListEntry;
#if DBG_SCOPE

        PPREQ_ALTERNATIVE   reqAlternativeEndPP;

#endif
        failureStatus           = STATUS_UNSUCCESSFUL;
        finalStatus             = STATUS_SUCCESS;
        ioResourceList          = ioResources->List;
        ioResourceListCount     = ioResources->AlternativeLists;
        reqAlternativeCount     = ioResourceListCount;
        reqDescCount            = reqDescAlternativeCount -
                                    alternativeDescriptorCount;
        reqDescPoolSize         = reqDescCount * sizeof(REQ_DESC);
        reqAlternativePoolSize  = reqAlternativeCount *
                                    (sizeof(REQ_ALTERNATIVE) +
                                        (reqDescCount - 1) *
                                            sizeof(PREQ_DESC));
        reqListPoolSize         = sizeof(REQ_LIST) +
                                    (reqAlternativeCount - 1) *
                                        sizeof(PREQ_ALTERNATIVE);
        poolSize = reqListPoolSize + reqAlternativePoolSize + reqDescPoolSize;
        if (!(poolStart = ExAllocatePoolRD(PagedPool | POOL_COLD_ALLOCATION, poolSize))) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        //
        // Initialize the main pool.
        //
        IopInitPool(&outerPool, poolStart, poolSize);
        //
        // First part of the pool is used by REQ_LIST.
        //
        IopAllocPool(&reqList, &outerPool, reqListPoolSize);
        //
        // Second part of the main pool is used by REQ_ALTERNATIVEs.
        //
        IopAllocPool(&poolStart, &outerPool, reqAlternativePoolSize);
        IopInitPool(&reqAlternativePool, poolStart, reqAlternativePoolSize);
        //
        // Last part of the main pool is used by REQ_DESCs.
        //
        IopAllocPool(&poolStart, &outerPool, reqDescPoolSize);
        IopInitPool(&reqDescPool, poolStart, reqDescPoolSize);
        if (ioResources->InterfaceType == InterfaceTypeUndefined) {

            interfaceType = PnpDefaultInterfaceType;
        } else {

            interfaceType = ioResources->InterfaceType;
        }
        busNumber = ioResources->BusNumber;
        //
        // Initialize REQ_LIST.
        //
        reqList->AlternativeCount       = reqAlternativeCount;
        reqList->Request                = Request;
        reqList->BusNumber              = busNumber;
        reqList->InterfaceType          = interfaceType;
        reqList->SelectedAlternative    = NULL;
        //
        // Initialize memory for REQ_ALTERNATIVEs.
        //
        reqAlternativePP = reqList->AlternativeTable;
        RtlZeroMemory(
            reqAlternativePP,
            reqAlternativeCount * sizeof(PREQ_ALTERNATIVE));
#if DBG_SCOPE
        reqAlternativeEndPP = reqAlternativePP + reqAlternativeCount;
#endif
        reqAlternativeIndex = 0;
        while (--ioResourceListCount >= 0) {

            ioResourceDescriptor    = ioResourceList->Descriptors;
            ioResourceDescriptorEnd = ioResourceDescriptor +
                                        ioResourceList->Count;
            IopAllocPool(
                &reqAlternative,
                &reqAlternativePool,
                FIELD_OFFSET(REQ_ALTERNATIVE, DescTable));
            ASSERT(reqAlternativePP < reqAlternativeEndPP);
            *reqAlternativePP++ = reqAlternative;
            reqAlternative->ReqList             = reqList;
            reqAlternative->ReqAlternativeIndex = reqAlternativeIndex++;
            reqAlternative->DescCount           = 0;
            //
            // First descriptor of CmResourceTypeConfigData contains priority
            // information.
            //
            if (ioResourceDescriptor->Type == CmResourceTypeConfigData) {

                reqAlternative->Priority = ioResourceDescriptor->u.ConfigData.Priority;
                ioResourceDescriptor++;
            } else {

                reqAlternative->Priority = LCPRI_NORMAL;
            }
            reqDescPP = reqAlternative->DescTable;
            reqDescIndex = 0;
            while (ioResourceDescriptor < ioResourceDescriptorEnd) {

                if (ioResourceDescriptor->Type == CmResourceTypeReserved) {

                    interfaceType = ioResourceDescriptor->u.DevicePrivate.Data[0];
                    if (interfaceType == InterfaceTypeUndefined) {

                        interfaceType = PnpDefaultInterfaceType;
                    }
                    busNumber = ioResourceDescriptor->u.DevicePrivate.Data[1];
                    ioResourceDescriptor++;
                } else {
                    //
                    // Allocate and initialize REQ_DESC.
                    //
                    IopAllocPool(&reqDesc, &reqDescPool, sizeof(REQ_DESC));
                    reqAlternative->DescCount++;
                    *reqDescPP++                    = reqDesc;
                    reqDesc->ReqAlternative         = reqAlternative;
                    reqDesc->TranslatedReqDesc      = reqDesc;
                    reqDesc->ReqDescIndex           = reqDescIndex++;
                    reqDesc->DevicePrivateCount     = 0;
                    reqDesc->DevicePrivate          = NULL;
                    reqDesc->InterfaceType          = interfaceType;
                    reqDesc->BusNumber              = busNumber;
                    reqDesc->ArbitrationRequired    =
                        (ioResourceDescriptor->Type & CmResourceTypeNonArbitrated ||
                            ioResourceDescriptor->Type == CmResourceTypeNull)?
                                FALSE : TRUE;
                    //
                    // Allocate and initialize arbiter entry for this REQ_DESC.
                    //
                    IopAllocPool(&poolStart, &reqAlternativePool, sizeof(PVOID));
                    ASSERT((PREQ_DESC*)poolStart == (reqDescPP - 1));
                    arbiterListEntry = &reqDesc->AlternativeTable;
                    InitializeListHead(&arbiterListEntry->ListEntry);
                    arbiterListEntry->AlternativeCount      = 0;
                    arbiterListEntry->Alternatives          = ioResourceDescriptor;
                    arbiterListEntry->PhysicalDeviceObject  = Request->PhysicalDevice;
                    arbiterListEntry->RequestSource         = Request->AllocationType;
                    arbiterListEntry->WorkSpace             = 0;
                    arbiterListEntry->InterfaceType         = interfaceType;
                    arbiterListEntry->SlotNumber            = ioResources->SlotNumber;
                    arbiterListEntry->BusNumber             = ioResources->BusNumber;
                    arbiterListEntry->Assignment            = &reqDesc->Allocation;
                    arbiterListEntry->Result                = ArbiterResultUndefined;
                    arbiterListEntry->Flags =
                            (reqAlternative->Priority != LCPRI_BOOTCONFIG)?
                                0 : ARBITER_FLAG_BOOT_CONFIG;
                    if (reqDesc->ArbitrationRequired) {
                        //
                        // The BestAlternativeTable and BestAllocation are not initialized.
                        // They will be initialized when needed.

                        //
                        // Initialize the Cm partial resource descriptor to NOT_ALLOCATED.
                        //
                        reqDesc->Allocation.Type = CmResourceTypeMaximum;

                        ASSERT((ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) == 0);

                        arbiterListEntry->AlternativeCount++;
                        ioResourceDescriptor++;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {

                            if (ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                                reqDesc->DevicePrivate = ioResourceDescriptor;
                                while ( ioResourceDescriptor < ioResourceDescriptorEnd &&
                                        ioResourceDescriptor->Type == CmResourceTypeDevicePrivate) {

                                    reqDesc->DevicePrivateCount++;
                                    ioResourceDescriptor++;
                                }
                                break;
                            }
                            if (!(ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE)) {

                                break;
                            }
                            arbiterListEntry->AlternativeCount++;
                            ioResourceDescriptor++;
                        }
                        //
                        // Next query Arbiter and Translator interfaces for the
                        // resource descriptor.
                        //
                        status = IopSetupArbiterAndTranslators(reqDesc);
                        if (!NT_SUCCESS(status)) {

                            IopDbgPrint((
                                IOP_RESOURCE_ERROR_LEVEL, "Unable to setup "
                                "Arbiter and Translators\n"));
                            reqAlternativeIndex--;
                            reqAlternativePP--;
                            reqList->AlternativeCount--;
                            IopFreeReqAlternative(reqAlternative);
                            failureStatus = status;
                            break;
                        }
                    } else {

                        reqDesc->Allocation.Type    = ioResourceDescriptor->Type;
                        reqDesc->Allocation.ShareDisposition =
                            ioResourceDescriptor->ShareDisposition;
                        reqDesc->Allocation.Flags   = ioResourceDescriptor->Flags;
                        reqDesc->Allocation.u.DevicePrivate.Data[0] =
                            ioResourceDescriptor->u.DevicePrivate.Data[0];
                        reqDesc->Allocation.u.DevicePrivate.Data[1] =
                            ioResourceDescriptor->u.DevicePrivate.Data[1];
                        reqDesc->Allocation.u.DevicePrivate.Data[2] =
                            ioResourceDescriptor->u.DevicePrivate.Data[2];
                        ioResourceDescriptor++;
                    }
                }
                if (ioResourceDescriptor >= ioResourceDescriptorEnd) {

                    break;
                }
            }
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
        }
        if (reqAlternativeIndex == 0) {

            finalStatus = failureStatus;
            IopFreeReqList(reqList);
        }
    }

    if (finalStatus == STATUS_SUCCESS) {

        *ResReqList = reqList;
    }
    return finalStatus;

InvalidParameter:
    return STATUS_INVALID_PARAMETER;
}

int
__cdecl
IopCompareReqAlternativePriority (
    const void *arg1,
    const void *arg2
    )

/*++

Routine Description:

    This function is used in C run time sort. It compares the priority of
    REQ_ALTERNATIVE in arg1 and arg2.

Parameters:

    arg1    - LHS PREQ_ALTERNATIVE

    arg2    - RHS PREQ_ALTERNATIVE

Return Value:

    < 0 if arg1 < arg2
    = 0 if arg1 = arg2
    > 0 if arg1 > arg2

--*/

{
    PREQ_ALTERNATIVE ra1 = *(PPREQ_ALTERNATIVE)arg1;
    PREQ_ALTERNATIVE ra2 = *(PPREQ_ALTERNATIVE)arg2;

    PAGED_CODE();

    if (ra1->Priority == ra2->Priority) {

        if (ra1->Position > ra2->Position) {

            return 1;
        } else if (ra1->Position < ra2->Position) {

            return -1;
        } else {

            ASSERT(0);
            if ((ULONG_PTR)ra1 < (ULONG_PTR)ra2) {
    
                return -1;
            } else {
    
                return 1;
            }
        }
    }
    if (ra1->Priority > ra2->Priority) {

        return 1;
    } else {

        return -1;
    }
}

int
__cdecl
IopCompareResourceRequestPriority (
    const void *arg1,
    const void *arg2
    )

/*++

    This function is used in C run time sort. It compares the priority of
    IOP_RESOURCE_REQUEST in arg1 and arg2.

Parameters:

    arg1    - LHS PIOP_RESOURCE_REQUEST

    arg2    - RHS PIOP_RESOURCE_REQUEST

Return Value:

    < 0 if arg1 < arg2
    = 0 if arg1 = arg2
    > 0 if arg1 > arg2

--*/

{
    PIOP_RESOURCE_REQUEST rr1 = (PIOP_RESOURCE_REQUEST)arg1;
    PIOP_RESOURCE_REQUEST rr2 = (PIOP_RESOURCE_REQUEST)arg2;

    PAGED_CODE();

    if (rr1->Priority == rr2->Priority) {

        if (rr1->Position > rr2->Position) {

            return 1;
        } else if (rr1->Position < rr2->Position) {

            return -1;
        } else {

            ASSERT(0);
            if ((ULONG_PTR)rr1 < (ULONG_PTR)rr2) {

                return -1;
            } else {

                return 1;
            }            
        }
    }
    if (rr1->Priority > rr2->Priority) {

        return 1;
    } else {

        return -1;
    }
}

VOID
IopRearrangeReqList (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine sorts the REQ_LIST in ascending priority order of
    REQ_ALTERNATIVES.

Parameters:

    ReqList - Pointer to the REQ_LIST to be sorted.

Return Value:

    None.

--*/

{
    PPREQ_ALTERNATIVE alternative;
    PPREQ_ALTERNATIVE lastAlternative;
    ULONG i;

    PAGED_CODE();

    if (ReqList->AlternativeCount > 1) {

        for (i = 0; i < ReqList->AlternativeCount; i++) {

            ReqList->AlternativeTable[i]->Position = i;
        }
        qsort(
            (void *)ReqList->AlternativeTable,
            ReqList->AlternativeCount,
            sizeof(PREQ_ALTERNATIVE),
            IopCompareReqAlternativePriority);
    }
    //
    // Set the BestAlternative so that we try alternatives with
    // priority <= LCPRI_LASTSOFTCONFIG.
    //
    alternative = &ReqList->AlternativeTable[0];
    for (   lastAlternative = alternative + ReqList->AlternativeCount;
            alternative < lastAlternative;
            alternative++) {

        if ((*alternative)->Priority > LCPRI_LASTSOFTCONFIG) {

            break;
        }
    }

    if (alternative == &ReqList->AlternativeTable[0]) {

        PDEVICE_NODE deviceNode;

        deviceNode = PP_DO_TO_DN(ReqList->Request->PhysicalDevice);
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Invalid priorities in the logical configs for %wZ\n",
            &deviceNode->InstancePath));
        ReqList->BestAlternative = NULL;
    } else {

        ReqList->BestAlternative = alternative;
    }
}

VOID
IopRearrangeAssignTable (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    Count
    )

/*++

Routine Description:

    This routine sorts the resource requirements table in ascending priority
    order.

Parameters:

    RequestTable    - Table of resources requests to be sorted.

    Count           - Length of the RequestTable.

Return Value:

    None.

--*/

{
    ULONG   i;

    PAGED_CODE();

    if (Count > 1) {

        if (PpCallerInitializesRequestTable == FALSE) {

            for (i = 0; i < Count; i++) {
    
                RequestTable[i].Position = i;
            }
        }
        qsort(
            (void *)RequestTable,
            Count,
            sizeof(IOP_RESOURCE_REQUEST),
            IopCompareResourceRequestPriority);
    }
}

VOID
IopBuildCmResourceList (
    IN PIOP_RESOURCE_REQUEST AssignEntry
    )
/*++

Routine Description:

    This routine walks REQ_LIST of the AssignEntry to build a corresponding
    Cm Resource lists.  It also reports the resources to ResourceMap.

Parameters:

    AssignEntry - Supplies a pointer to an IOP_ASSIGN_REQUEST structure

Return Value:

    None.  The ResourceAssignment in AssignEntry is initialized.

--*/

{
    NTSTATUS status;
    HANDLE resourceMapKey;
    PDEVICE_OBJECT physicalDevice;
    PREQ_LIST reqList = AssignEntry->ReqList;
    PREQ_ALTERNATIVE reqAlternative;
    PREQ_DESC reqDesc, reqDescx;
    PIO_RESOURCE_DESCRIPTOR privateData;
    ULONG count = 0, size, i;
    PCM_RESOURCE_LIST cmResources, cmResourcesRaw;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullResource, cmFullResourceRaw;
    PCM_PARTIAL_RESOURCE_LIST cmPartialList, cmPartialListRaw;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor, cmDescriptorRaw, assignment, tAssignment;
#if DBG_SCOPE
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptorEnd, cmDescriptorEndRaw;
#endif

    PAGED_CODE();

    //
    // Determine the size of the CmResourceList
    //

    //
    // Determine the size of the CmResourceList
    //

    reqAlternative = *reqList->SelectedAlternative;
    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i];
        count += reqDesc->DevicePrivateCount + 1;
    }

    size = sizeof(CM_RESOURCE_LIST) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * (count - 1);
    cmResources = (PCM_RESOURCE_LIST) ExAllocatePoolCMRL(PagedPool, size);
    if (!cmResources) {

        //
        // If we can not find memory, the resources will not be committed by arbiter.
        //

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to build Translated CmResourceList\n"));
        AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
        AssignEntry->ResourceAssignment = NULL;
        AssignEntry->TranslatedResourceAssignment = NULL;
        return;
    }
    cmResourcesRaw = (PCM_RESOURCE_LIST) ExAllocatePoolCMRR(PagedPool, size);
    if (!cmResourcesRaw) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to build Raw CmResourceList\n"));
        ExFreePool(cmResources);
        AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
        AssignEntry->ResourceAssignment = NULL;
        AssignEntry->TranslatedResourceAssignment = NULL;
        return;
    }
    cmResources->Count = 1;
    cmFullResource = cmResources->List;

    //
    // The CmResourceList we build here does not distinguish the
    // Interface Type on descriptor level.  This should be fine because
    // for IoReportResourceUsage we ignore the CmResourceList we build
    // here.
    //

    cmFullResource->InterfaceType = reqList->InterfaceType;
    cmFullResource->BusNumber = reqList->BusNumber;
    cmPartialList = &cmFullResource->PartialResourceList;
    cmPartialList->Version = 0;
    cmPartialList->Revision = 0;
    cmPartialList->Count = count;
    cmDescriptor = cmPartialList->PartialDescriptors;
#if DBG_SCOPE
    cmDescriptorEnd = cmDescriptor + count;
#endif
    cmResourcesRaw->Count = 1;
    cmFullResourceRaw = cmResourcesRaw->List;
    cmFullResourceRaw->InterfaceType = reqList->InterfaceType;
    cmFullResourceRaw->BusNumber = reqList->BusNumber;
    cmPartialListRaw = &cmFullResourceRaw->PartialResourceList;
    cmPartialListRaw->Version = 0;
    cmPartialListRaw->Revision = 0;
    cmPartialListRaw->Count = count;
    cmDescriptorRaw = cmPartialListRaw->PartialDescriptors;
#if DBG_SCOPE
    cmDescriptorEndRaw = cmDescriptorRaw + count;
#endif

    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i];

        if (reqDesc->ArbitrationRequired) {

            //
            // Get raw assignment and copy it to our raw resource list
            //

            reqDescx = reqDesc->TranslatedReqDesc;
            if (reqDescx->AlternativeTable.Result != ArbiterResultNullRequest) {
                status = IopParentToRawTranslation(reqDescx);
                if (!NT_SUCCESS(status)) {
                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Parent To Raw translation failed\n"));
                    ExFreePool(cmResources);
                    ExFreePool(cmResourcesRaw);
                    AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    AssignEntry->ResourceAssignment = NULL;
                    return;
                }
                assignment = reqDesc->AlternativeTable.Assignment;
            } else {
                assignment = reqDescx->AlternativeTable.Assignment;
            }
            *cmDescriptorRaw = *assignment;
            cmDescriptorRaw++;

            //
            // Translate assignment and copy it to our translated resource list
            //
            if (reqDescx->AlternativeTable.Result != ArbiterResultNullRequest) {
                status = IopChildToRootTranslation(
                            PP_DO_TO_DN(reqDesc->AlternativeTable.PhysicalDeviceObject),
                            reqDesc->InterfaceType,
                            reqDesc->BusNumber,
                            reqDesc->AlternativeTable.RequestSource,
                            &reqDesc->Allocation,
                            &tAssignment
                            );
                if (!NT_SUCCESS(status)) {
                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Child to Root translation failed\n"));
                    ExFreePool(cmResources);
                    ExFreePool(cmResourcesRaw);
                    AssignEntry->Status = STATUS_INSUFFICIENT_RESOURCES;
                    AssignEntry->ResourceAssignment = NULL;
                    return;
                }
                *cmDescriptor = *tAssignment;
                ExFreePool(tAssignment);
            } else {
                *cmDescriptor = *(reqDescx->AlternativeTable.Assignment);
            }
            cmDescriptor++;

        } else {
            *cmDescriptorRaw = reqDesc->Allocation;
            *cmDescriptor = reqDesc->Allocation;
            cmDescriptorRaw++;
            cmDescriptor++;
        }

        //
        // Next copy the device private descriptors to CmResourceLists
        //

        count = reqDesc->DevicePrivateCount;
        privateData = reqDesc->DevicePrivate;
        while (count != 0) {

            cmDescriptor->Type = cmDescriptorRaw->Type = CmResourceTypeDevicePrivate;
            cmDescriptor->ShareDisposition = cmDescriptorRaw->ShareDisposition =
                         CmResourceShareDeviceExclusive;
            cmDescriptor->Flags = cmDescriptorRaw->Flags = privateData->Flags;
            RtlMoveMemory(&cmDescriptorRaw->u.DevicePrivate,
                          &privateData->u.DevicePrivate,
                          sizeof(cmDescriptorRaw->u.DevicePrivate.Data)
                          );
            RtlMoveMemory(&cmDescriptor->u.DevicePrivate,
                          &privateData->u.DevicePrivate,
                          sizeof(cmDescriptor->u.DevicePrivate.Data)
                          );
            privateData++;
            cmDescriptorRaw++;
            cmDescriptor++;
            count--;
            ASSERT(cmDescriptorRaw <= cmDescriptorEndRaw);
            ASSERT(cmDescriptor <= cmDescriptorEnd);
        }
        ASSERT(cmDescriptor <= cmDescriptorEnd);
        ASSERT(cmDescriptorRaw <= cmDescriptorEndRaw);

    }

    //
    // report assigned resources to ResourceMap
    //

    physicalDevice = AssignEntry->PhysicalDevice;

    //
    // Open ResourceMap key
    //

    status = IopCreateRegistryKeyEx( &resourceMapKey,
                                     (HANDLE) NULL,
                                     &CmRegistryMachineHardwareResourceMapName,
                                     KEY_READ | KEY_WRITE,
                                     REG_OPTION_VOLATILE,
                                     NULL
                                     );
    if (NT_SUCCESS(status )) {
        WCHAR DeviceBuffer[256];
        POBJECT_NAME_INFORMATION NameInformation;
        ULONG NameLength;
        UNICODE_STRING UnicodeClassName;
        UNICODE_STRING UnicodeDriverName;
        UNICODE_STRING UnicodeDeviceName;

        PiWstrToUnicodeString(&UnicodeClassName, PNPMGR_STR_PNP_MANAGER);

        PiWstrToUnicodeString(&UnicodeDriverName, REGSTR_KEY_PNP_DRIVER);

        NameInformation = (POBJECT_NAME_INFORMATION) DeviceBuffer;
        status = ObQueryNameString( physicalDevice,
                                    NameInformation,
                                    sizeof( DeviceBuffer ),
                                    &NameLength );
        if (NT_SUCCESS(status)) {
            NameInformation->Name.MaximumLength = sizeof(DeviceBuffer) - sizeof(OBJECT_NAME_INFORMATION);
            if (NameInformation->Name.Length == 0) {
                NameInformation->Name.Buffer = (PVOID)((ULONG_PTR)DeviceBuffer + sizeof(OBJECT_NAME_INFORMATION));
            }

            UnicodeDeviceName = NameInformation->Name;
            RtlAppendUnicodeToString(&UnicodeDeviceName, IopWstrRaw);

            //
            // IopWriteResourceList should remove all the device private and device
            // specifiec descriptors.
            //

            status = IopWriteResourceList(
                         resourceMapKey,
                         &UnicodeClassName,
                         &UnicodeDriverName,
                         &UnicodeDeviceName,
                         cmResourcesRaw,
                         size
                         );
            if (NT_SUCCESS(status)) {
                UnicodeDeviceName = NameInformation->Name;
                RtlAppendUnicodeToString (&UnicodeDeviceName, IopWstrTranslated);
                status = IopWriteResourceList(
                             resourceMapKey,
                             &UnicodeClassName,
                             &UnicodeDriverName,
                             &UnicodeDeviceName,
                             cmResources,
                             size
                             );
            }
        }
        ZwClose(resourceMapKey);
    }
#if 0 // Ignore the registry writing status.
    if (!NT_SUCCESS(status)) {
        ExFreePool(cmResources);
        ExFreePool(cmResourcesRaw);
        cmResources = NULL;
        cmResourcesRaw = NULL;
    }
#endif
    AssignEntry->ResourceAssignment = cmResourcesRaw;
    AssignEntry->TranslatedResourceAssignment = cmResources;
}

VOID
IopBuildCmResourceLists(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    )

/*++

Routine Description:

    For each AssignTable entry, this routine queries device's IO resource requirements
    list and converts it to our internal REQ_LIST format.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIOP_RESOURCE_REQUEST assignEntry;
    PDEVICE_OBJECT physicalDevice;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    //
    // Go thru each entry, for each Physical device object, we build a CmResourceList
    // from its ListOfAssignedResources.
    //

    for (assignEntry = AssignTable; assignEntry < AssignTableEnd; ++assignEntry) {

        assignEntry->ResourceAssignment = NULL;
        if (assignEntry->Flags & IOP_ASSIGN_IGNORE || assignEntry->Flags & IOP_ASSIGN_RETRY) {
            continue;
        }
        if (assignEntry->Flags & IOP_ASSIGN_EXCLUDE) {
            assignEntry->Status = STATUS_UNSUCCESSFUL;
            continue;
        }
        assignEntry->Status = STATUS_SUCCESS;
        IopBuildCmResourceList (assignEntry);
        if (assignEntry->ResourceAssignment) {
            physicalDevice = assignEntry->PhysicalDevice;
            deviceNode = PP_DO_TO_DN(physicalDevice);
            IopWriteAllocatedResourcesToRegistry(
                  deviceNode,
                  assignEntry->ResourceAssignment,
                  IopDetermineResourceListSize(assignEntry->ResourceAssignment)
                  );
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Building CM resource lists for %ws...\n",
                deviceNode->InstancePath.Buffer));

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Raw resources "));
            IopDumpCmResourceList(assignEntry->ResourceAssignment);
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Translated resources "));
            IopDumpCmResourceList(assignEntry->TranslatedResourceAssignment);
        }
    }
}

BOOLEAN
IopNeedToReleaseBootResources(
    IN PDEVICE_NODE DeviceNode,
    IN PCM_RESOURCE_LIST AllocatedResources
    )

/*++

Routine Description:

    This routine checks the AllocatedResources against boot allocated resources.
    If the allocated resources do not cover all the resource types in boot resources,
    in another words some types of boot resources have not been released by arbiter,
    we will return TRUE to indicate we need to release the boot resources manually.

Parameters:

    DeviceNode -  A device node

    AllocatedResources - the resources assigned to the devicenode by arbiters.

Return Value:

    TRUE or FALSE.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc_a, cmFullDesc_b;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor_a, cmDescriptor_b;
    ULONG size_a, size_b, i, j, k;
    BOOLEAN returnValue = FALSE, found;
    PCM_RESOURCE_LIST bootResources;

    PAGED_CODE();

    bootResources = DeviceNode->BootResources;
    if (AllocatedResources->Count == 1 && bootResources && bootResources->Count != 0) {

        cmFullDesc_a = &AllocatedResources->List[0];
        cmFullDesc_b = &bootResources->List[0];
        for (i = 0; i < bootResources->Count; i++) {
            cmDescriptor_b = &cmFullDesc_b->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc_b->PartialResourceList.Count; j++) {
                size_b = 0;
                switch (cmDescriptor_b->Type) {
                case CmResourceTypeNull:
                    break;
                case CmResourceTypeDeviceSpecific:
                     size_b = cmDescriptor_b->u.DeviceSpecificData.DataSize;
                     break;
                default:
                     if (cmDescriptor_b->Type < CmResourceTypeMaximum) {
                         found = FALSE;
                         cmDescriptor_a = &cmFullDesc_a->PartialResourceList.PartialDescriptors[0];
                         for (k = 0; k < cmFullDesc_a->PartialResourceList.Count; k++) {
                             size_a = 0;
                             if (cmDescriptor_a->Type == CmResourceTypeDeviceSpecific) {
                                 size_a = cmDescriptor_a->u.DeviceSpecificData.DataSize;
                             } else if (cmDescriptor_b->Type == cmDescriptor_a->Type) {
                                 found = TRUE;
                                 break;
                             }
                             cmDescriptor_a++;
                             cmDescriptor_a = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor_a + size_a);
                         }
                         if (found == FALSE) {
                             returnValue = TRUE;
                             goto exit;
                         }
                     }
                }
                cmDescriptor_b++;
                cmDescriptor_b = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor_b + size_b);
            }
            cmFullDesc_b = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor_b;
        }
    }
exit:
    return returnValue;
}

VOID
IopReleaseFilteredBootResources(
    IN PIOP_RESOURCE_REQUEST AssignTable,
    IN PIOP_RESOURCE_REQUEST AssignTableEnd
    )

/*++

Routine Description:

    For each AssignTable entry, this routine checks if we need to manually release the device's
    boot resources.

Parameters:

    AssignTable - supplies a pointer to the first entry of a IOP_RESOURCE_REQUEST table.

    AssignTableEnd - supplies a pointer to the end of IOP_RESOURCE_REQUEST table.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    PIOP_RESOURCE_REQUEST assignEntry;
    PDEVICE_OBJECT physicalDevice;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    //
    // Go thru each entry, for each Physical device object, we build a CmResourceList
    // from its ListOfAssignedResources.
    //

    for (assignEntry = AssignTable; assignEntry < AssignTableEnd; ++assignEntry) {

        if (assignEntry->ResourceAssignment) {
            physicalDevice = assignEntry->PhysicalDevice;
            deviceNode = PP_DO_TO_DN(physicalDevice);

            //
            // Release the device's boot resources if desired
            // (If a driver filters its res req list and removes some boot resources, after arbiter satisfies
            // the new res req list, the filtered out boot resources do not get
            // released by arbiters.  Because they no longer passed to arbiters. )
            // I am not 100% sure we should release the filtered boot resources.  But that's what arbiters try
            // to achieve.  So, we will do it.
            //

            if (IopNeedToReleaseBootResources(deviceNode, assignEntry->ResourceAssignment)) {

                IopReleaseResourcesInternal(deviceNode);
                //
                // Since we released some resources, try to satisfy devices
                // with resource conflict.
                //
                PipRequestDeviceAction(NULL, AssignResources, FALSE, 0, NULL, NULL);

                IopAllocateBootResourcesInternal(
                        ArbiterRequestPnpEnumerated,
                        physicalDevice,
                        assignEntry->ResourceAssignment);
                deviceNode->Flags &= ~DNF_BOOT_CONFIG_RESERVED;  // Keep DeviceNode->BootResources
                deviceNode->ResourceList = assignEntry->ResourceAssignment;
                status = IopRestoreResourcesInternal(deviceNode);
                if (!NT_SUCCESS(status)) {

                    IopDbgPrint((
                        IOP_RESOURCE_WARNING_LEVEL,
                        "Possible boot conflict on %ws\n",
                        deviceNode->InstancePath.Buffer));
                    ASSERT(status == STATUS_SUCCESS);
                    assignEntry->Flags = IOP_ASSIGN_EXCLUDE;
                    assignEntry->Status = status;
                    ExFreePool(assignEntry->ResourceAssignment);
                    assignEntry->ResourceAssignment = NULL;
                }
                deviceNode->ResourceList = NULL;
            }
        }
    }
}

NTSTATUS
IopSetupArbiterAndTranslators(
    IN PREQ_DESC ReqDesc
    )

/*++

Routine Description:

    This routine searches the arbiter and translators which arbitrates and translate
    the resources for the specified device.  This routine tries to find all the
    translator on the path of current device node to root device node

Parameters:

    ReqDesc - supplies a pointer to REQ_DESC which contains all the required information

Return Value:

    NTSTATUS value to indicate success or failure.

--*/

{
    PLIST_ENTRY listHead;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    PDEVICE_OBJECT deviceObject = ReqDesc->AlternativeTable.PhysicalDeviceObject;
    PDEVICE_NODE deviceNode;
    PREQ_DESC reqDesc = ReqDesc, translatedReqDesc;
    BOOLEAN found, arbiterFound = FALSE, restartedAlready;
    BOOLEAN  searchTranslator = TRUE, translatorFound = FALSE;
    NTSTATUS status;
    PPI_RESOURCE_TRANSLATOR_ENTRY translatorEntry;
    UCHAR resourceType = ReqDesc->TranslatedReqDesc->AlternativeTable.Alternatives->Type;
    PINTERFACE interface;
    USHORT resourceMask;

    if ((ReqDesc->AlternativeTable.RequestSource == ArbiterRequestHalReported) &&
        (ReqDesc->InterfaceType == Internal)) {

        // Trust hal if it says internal bus.

        restartedAlready = TRUE;
    } else {
        restartedAlready = FALSE;
    }

    //
    // If ReqDesc contains DeviceObject, this is for regular resources allocation
    // or boot resources preallocation.  Otherwise, it is for resources reservation.
    //

    if (deviceObject && ReqDesc->AlternativeTable.RequestSource != ArbiterRequestHalReported) {
        deviceNode = PP_DO_TO_DN(deviceObject);
        // We want to start with the deviceNode instead of its parent.  Because the
        // deviceNode may provide a translator interface.
        // deviceNode = deviceNode->Parent;
    } else {

        //
        // For resource reservation, we always need to find the arbiter and translators
        // so set the device node to Root.
        //

        deviceNode = IopRootDeviceNode;
    }
    while (deviceNode) {
        if ((deviceNode == IopRootDeviceNode) && (translatorFound == FALSE)) {

            //
            // If we reach the root and have not find any translator, the device is on the
            // wrong way.
            //

            if (restartedAlready == FALSE) {
                restartedAlready = TRUE;

                deviceNode = IopFindLegacyBusDeviceNode (
                                 ReqDesc->InterfaceType,
                                 ReqDesc->BusNumber
                                 );

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((deviceNode == IopRootDeviceNode) &&
                    (ReqDesc->ReqAlternative->ReqList->InterfaceType == Internal)) {
                    deviceNode = IopFindLegacyBusDeviceNode(
                                 Isa,
                                 0
                                 );
                }

                //if ((PVOID)deviceNode == deviceObject->DeviceObjectExtension->DeviceNode) {
                //    deviceNode = IopRootDeviceNode;
                //} else {
                    continue;
                //}
            }
        }

        //
        // Check is there an arbiter for the device node?
        //   if yes, set up ReqDesc->u.Arbiter and set ArbiterFound to true.
        //   else move up to the parent of current device node.
        //

        if ((arbiterFound == FALSE) && (deviceNode->PhysicalDeviceObject != deviceObject)) {
            found = IopFindResourceHandlerInfo(
                               ResourceArbiter,
                               deviceNode,
                               resourceType,
                               &arbiterEntry);
            if (found == FALSE) {

                //
                // no information found on arbiter.  Try to query translator interface ...
                //

                if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                    resourceMask = 1 << resourceType;
                } else {
                    resourceMask = 0;
                }
                status = IopQueryResourceHandlerInterface(ResourceArbiter,
                                                          deviceNode->PhysicalDeviceObject,
                                                          resourceType,
                                                          &interface);
                deviceNode->QueryArbiterMask |= resourceMask;
                if (!NT_SUCCESS(status)) {
                    deviceNode->NoArbiterMask |= resourceMask;
                    if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                        found = TRUE;
                    } else {
                        interface = NULL;
                    }
                }
                if (found == FALSE) {
                    arbiterEntry = (PPI_RESOURCE_ARBITER_ENTRY)ExAllocatePoolAE(
                                       PagedPool | POOL_COLD_ALLOCATION,
                                       sizeof(PI_RESOURCE_ARBITER_ENTRY));
                    if (!arbiterEntry) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        return status;
                    }
                    IopInitializeArbiterEntryState(arbiterEntry);
                    InitializeListHead(&arbiterEntry->DeviceArbiterList);
                    arbiterEntry->ResourceType      = resourceType;
                    arbiterEntry->Level             = deviceNode->Level;
                    listHead = &deviceNode->DeviceArbiterList;
                    InsertTailList(listHead, &arbiterEntry->DeviceArbiterList);
                    arbiterEntry->ArbiterInterface = (PARBITER_INTERFACE)interface;
                    if (!interface) {

                        //
                        // if interface is NULL we really don't have translator.
                        //

                        arbiterEntry = NULL;
                    }
                }
            }

            //
            // If there is an desired resourcetype arbiter in the device node, make sure
            // it handle this resource requriements.
            //

            if (arbiterEntry) {
                arbiterFound = TRUE;
                if (arbiterEntry->ArbiterInterface->Flags & ARBITER_PARTIAL) {

                    //
                    // If the arbiter is partial, ask if it handles the resources
                    // if not, goto its parent.
                    //

                    status = IopCallArbiter(
                                arbiterEntry,
                                ArbiterActionQueryArbitrate,
                                ReqDesc->TranslatedReqDesc,
                                NULL,
                                NULL
                                );
                    if (!NT_SUCCESS(status)) {
                        arbiterFound = FALSE;
                    }
                }
            }
            if (arbiterFound) {
                ReqDesc->u.Arbiter = arbiterEntry;

                //
                // Initialize the arbiter entry
                //

                arbiterEntry->State = 0;
                arbiterEntry->ResourcesChanged = FALSE;
            }

        }

        if (searchTranslator) {
            //
            // First, check if there is a translator for the device node?
            // If yes, translate the req desc and link it to the front of ReqDesc->TranslatedReqDesc
            // else do nothing.
            //

            found = IopFindResourceHandlerInfo(
                        ResourceTranslator,
                        deviceNode,
                        resourceType,
                        &translatorEntry);

            if (found == FALSE) {

                //
                // no information found on translator.  Try to query translator interface ...
                //

                if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                    resourceMask = 1 << resourceType;
                } else {
                    resourceMask = 0;
                }
                status = IopQueryResourceHandlerInterface(ResourceTranslator,
                                                          deviceNode->PhysicalDeviceObject,
                                                          resourceType,
                                                          &interface);
                deviceNode->QueryTranslatorMask |= resourceMask;
                if (!NT_SUCCESS(status)) {
                    deviceNode->NoTranslatorMask |= resourceMask;
                    if (resourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {
                        found = TRUE;
                    } else {
                        interface = NULL;
                    }
                }
                if (found == FALSE) {
                    translatorEntry = (PPI_RESOURCE_TRANSLATOR_ENTRY)ExAllocatePoolTE(
                                       PagedPool | POOL_COLD_ALLOCATION,
                                       sizeof(PI_RESOURCE_TRANSLATOR_ENTRY));
                    if (!translatorEntry) {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        return status;
                    }
                    translatorEntry->ResourceType = resourceType;
                    InitializeListHead(&translatorEntry->DeviceTranslatorList);
                    translatorEntry->TranslatorInterface = (PTRANSLATOR_INTERFACE)interface;
                    translatorEntry->DeviceNode = deviceNode;
                    listHead = &deviceNode->DeviceTranslatorList;
                    InsertTailList(listHead, &translatorEntry->DeviceTranslatorList);
                    if (!interface) {

                        //
                        // if interface is NULL we really don't have translator.
                        //

                        translatorEntry = NULL;
                    }
                }
            }
            if (translatorEntry) {
                translatorFound = TRUE;
            }
            if ((arbiterFound == FALSE) && translatorEntry) {

                //
                // Find a translator to translate the req desc ... Translate it and link it to
                // the front of ReqDesc->TranslatedReqDesc such that the first in the list is for
                // the Arbiter to use.
                //

                reqDesc = ReqDesc->TranslatedReqDesc;
                status = IopTranslateAndAdjustReqDesc(
                              reqDesc,
                              translatorEntry,
                              &translatedReqDesc);
                if (NT_SUCCESS(status)) {
                    ASSERT(translatedReqDesc);
                    resourceType = translatedReqDesc->AlternativeTable.Alternatives->Type;
                    translatedReqDesc->TranslatedReqDesc = ReqDesc->TranslatedReqDesc;
                    ReqDesc->TranslatedReqDesc = translatedReqDesc;
                    //
                    // If the translator is non-hierarchial and performs a complete
                    // translation to root (eg ISA interrups for PCI devices) then
                    // don't pass translations to parent.
                    //

                    if (status == STATUS_TRANSLATION_COMPLETE) {
                        searchTranslator = FALSE;
                    }
                } else {
                    IopDbgPrint((
                        IOP_RESOURCE_INFO_LEVEL,
                        "resreq list TranslationAndAdjusted failed\n"
                        ));
                    return status;
                }
            }

        }

        //
        // Move up to current device node's parent
        //

        deviceNode = deviceNode->Parent;
    }

    if (arbiterFound) {

        return STATUS_SUCCESS;
    } else {        
        //
        // We should BugCheck in this case.
        //
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "can not find resource type %x arbiter\n",
            resourceType));

        ASSERT(arbiterFound);

        return STATUS_RESOURCE_TYPE_NOT_FOUND;
    }

}

VOID
IopUncacheInterfaceInformation (
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function removes all the cached translators and arbiters information
    from the device object.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

Return Value:

    None.

--*/

{
    PDEVICE_NODE                    deviceNode;
    PLIST_ENTRY                     listHead;
    PLIST_ENTRY                     nextEntry;
    PLIST_ENTRY                     entry;
    PPI_RESOURCE_TRANSLATOR_ENTRY   translatorEntry;
    PPI_RESOURCE_ARBITER_ENTRY      arbiterEntry;
    PINTERFACE                      interface;

    deviceNode = PP_DO_TO_DN(DeviceObject);
    //
    // Dereference all the arbiters on this PDO.
    //
    listHead    = &deviceNode->DeviceArbiterList;
    nextEntry   = listHead->Flink;
    while (nextEntry != listHead) {

        entry           = nextEntry;
        arbiterEntry    = CONTAINING_RECORD(
                            entry,
                            PI_RESOURCE_ARBITER_ENTRY,
                            DeviceArbiterList);

        interface = (PINTERFACE)arbiterEntry->ArbiterInterface;
        if (interface != NULL) {

            (interface->InterfaceDereference)(interface->Context);
            ExFreePool(interface);
        }
        nextEntry = entry->Flink;
        ExFreePool(entry);
    }
    //
    // Dereference all the translators on this PDO.
    //
    listHead    = &deviceNode->DeviceTranslatorList;
    nextEntry   = listHead->Flink;
    while (nextEntry != listHead) {
        entry           = nextEntry;
        translatorEntry = CONTAINING_RECORD(
                            entry,
                            PI_RESOURCE_TRANSLATOR_ENTRY,
                            DeviceTranslatorList);
        interface = (PINTERFACE)translatorEntry->TranslatorInterface;
        if (interface != NULL) {

            (interface->InterfaceDereference)(interface->Context);
            ExFreePool(interface);
        }
        nextEntry = entry->Flink;
        ExFreePool(entry);
    }
    InitializeListHead(&deviceNode->DeviceArbiterList);
    InitializeListHead(&deviceNode->DeviceTranslatorList);
    deviceNode->NoArbiterMask       = 0;
    deviceNode->QueryArbiterMask    = 0;
    deviceNode->NoTranslatorMask    = 0;
    deviceNode->QueryTranslatorMask = 0;
}

BOOLEAN
IopFindResourceHandlerInfo (
    IN  RESOURCE_HANDLER_TYPE    HandlerType,
    IN  PDEVICE_NODE             DeviceNode,
    IN  UCHAR                    ResourceType,
    OUT PVOID                   *HandlerEntry
    )

/*++

Routine Description:

    This routine finds the desired resource handler interface for the specified
    resource type in the specified Device node.

Parameters:

    HandlerType     - Specifies the type of handler needed.

    DeviceNode      - Specifies the devicenode on which to search for handler.

    ResourceType    - Specifies the type of resource.

    HandlerEntry    - Supplies a pointer to a variable to receive the handler.

Return Value:

    TRUE + non-NULL HandlerEntry : Found handler info and there is a handler
    TRUE + NULL HandlerEntry     : Found handler info but there is NO handler
    FALSE + NULL HandlerEntry    : No handler info found

--*/
{
    USHORT                      resourceMask;
    USHORT                      noHandlerMask;
    USHORT                      queryHandlerMask;
    PLIST_ENTRY                 listHead;
    PLIST_ENTRY                 entry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;

    *HandlerEntry   = NULL;
    switch (HandlerType) {
    case ResourceArbiter:

        noHandlerMask       = DeviceNode->NoArbiterMask;
        queryHandlerMask    = DeviceNode->QueryArbiterMask;
        listHead            = &DeviceNode->DeviceArbiterList;
        break;

    case ResourceTranslator:

        noHandlerMask       = DeviceNode->NoTranslatorMask;
        queryHandlerMask    = DeviceNode->QueryTranslatorMask;
        listHead            = &DeviceNode->DeviceTranslatorList;
        break;

    default:

        return FALSE;
    }
    resourceMask    = 1 << ResourceType;
    if (noHandlerMask & resourceMask) {
        //
        // There is no desired handler for the resource type.
        //
        return TRUE;
    }
    if (    (queryHandlerMask & resourceMask) ||
            ResourceType > PI_MAXIMUM_RESOURCE_TYPE_TRACKED) {

        entry = listHead->Flink;
        while (entry != listHead) {

            arbiterEntry = CONTAINING_RECORD(
                                entry,
                                PI_RESOURCE_ARBITER_ENTRY,
                                DeviceArbiterList);
            if (arbiterEntry->ResourceType == ResourceType) {

                if (    ResourceType <= PI_MAXIMUM_RESOURCE_TYPE_TRACKED ||
                        arbiterEntry->ArbiterInterface) {

                    *HandlerEntry = arbiterEntry;
                }
                return TRUE;
            }
            entry = entry->Flink;
        }
        if (queryHandlerMask & resourceMask) {
            //
            // There must be one.
            //
            ASSERT(entry != listHead);
        }
    }

    return FALSE;
}

NTSTATUS
IopParentToRawTranslation(
    IN OUT PREQ_DESC ReqDesc
    )

/*++

Routine Description:

    This routine translates an CmPartialResourceDescriptors
    from their translated form to their raw counterparts..

Parameters:

    ReqDesc - supplies a translated ReqDesc to be translated back to its raw form

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PTRANSLATOR_INTERFACE translator;
    NTSTATUS status = STATUS_SUCCESS;
    PREQ_DESC rawReqDesc;

    if (ReqDesc->AlternativeTable.AlternativeCount == 0 ||

        ReqDesc->Allocation.Type == CmResourceTypeMaximum) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Invalid ReqDesc for parent-to-raw translation.\n"));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // If this ReqDesc is the raw reqDesc then we are done.
    // Else call its translator to translate the resource and leave the result
    // in its raw (next level) reqdesc.
    //

    if (IS_TRANSLATED_REQ_DESC(ReqDesc)) {
        rawReqDesc = ReqDesc->TranslatedReqDesc;
        translator = ReqDesc->u.Translator->TranslatorInterface;
        status = (translator->TranslateResources)(
                      translator->Context,
                      ReqDesc->AlternativeTable.Assignment,
                      TranslateParentToChild,
                      rawReqDesc->AlternativeTable.AlternativeCount,
                      rawReqDesc->AlternativeTable.Alternatives,
                      rawReqDesc->AlternativeTable.PhysicalDeviceObject,
                      rawReqDesc->AlternativeTable.Assignment
                      );
        if (NT_SUCCESS(status)) {

            //
            // If the translator is non-hierarchial and performs a complete
            // translation to root (eg ISA interrups for PCI devices) then
            // don't pass translations to parent.
            //

            ASSERT(status != STATUS_TRANSLATION_COMPLETE);
            status = IopParentToRawTranslation(rawReqDesc);
        }
    }
    return status;
}

NTSTATUS
IopChildToRootTranslation(
    IN PDEVICE_NODE DeviceNode, OPTIONAL
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ARBITER_REQUEST_SOURCE ArbiterRequestSource,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates a CmPartialResourceDescriptors from
    their intermediate translated form to their final translated form.
    The translated CM_PARTIAL_RESOURCE_DESCRIPTOR is returned via Target variable.

    The caller is responsible to release the translated descriptor.

Parameters:

    DeviceNode - Specified the device object.  If The DeviceNode is specified,
                 the InterfaceType and BusNumber are ignored and we will
                 use DeviceNode as a starting point to find various translators to
                 translate the Source descriptor.  If DeviceNode is not specified,
                 the InterfaceType and BusNumber must be specified.

    InterfaceType, BusNumber - must be supplied if DeviceNode is not specified.

    Source - A pointer to the resource descriptor to be translated.

    Target - Supplies an address to receive the translated resource descriptor.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PDEVICE_NODE deviceNode;
    PLIST_ENTRY listHead, nextEntry;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR target, source, tmp;
    PPI_RESOURCE_TRANSLATOR_ENTRY translatorEntry;
    PTRANSLATOR_INTERFACE translator;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN done = FALSE, foundTranslator = FALSE, restartedAlready;

    if (ArbiterRequestSource == ArbiterRequestHalReported) {
       restartedAlready = TRUE;
    } else {
       restartedAlready = FALSE;
    }

    source = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                         PagedPool | POOL_COLD_ALLOCATION,
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                         );
    if (source == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    target = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                         PagedPool,
                         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                         );
    if (target == NULL) {
        ExFreePool(source);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    *source = *Source;

    //
    // Move up to current device node's parent to start translation
    //

    if (!ARGUMENT_PRESENT(DeviceNode)) {
        deviceNode = IopFindLegacyBusDeviceNode (InterfaceType, BusNumber);
    } else {
        // We want to start with the deviceNode instead of its parent.  Because the
        // deviceNode may provide a translator interface.
        deviceNode = DeviceNode;
    }
    while (deviceNode && !done) {

        if ((deviceNode == IopRootDeviceNode) && (foundTranslator == FALSE)) {
            if (restartedAlready == FALSE) {
                restartedAlready = TRUE;
                deviceNode = IopFindLegacyBusDeviceNode (InterfaceType, BusNumber);

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((deviceNode == IopRootDeviceNode) && (InterfaceType == Internal)) {
                    deviceNode = IopFindLegacyBusDeviceNode(Isa, 0);
                }

                continue;
            }
        }
        //
        // First, check if there is a translator for the device node?
        // If yes, translate the req desc and link it to the front of ReqDesc->TranslatedReqDesc
        // else do nothing.
        //

        listHead = &deviceNode->DeviceTranslatorList;
        nextEntry = listHead->Flink;
        for (; nextEntry != listHead; nextEntry = nextEntry->Flink) {
            translatorEntry = CONTAINING_RECORD(nextEntry, PI_RESOURCE_TRANSLATOR_ENTRY, DeviceTranslatorList);
            if (translatorEntry->ResourceType == Source->Type) {
                translator = translatorEntry->TranslatorInterface;
                if (translator != NULL) {

                    //
                    // Find a translator to translate the req desc ... Translate it and link it to
                    // the front of ReqDesc->TranslatedReqDesc.
                    //

                    status = (translator->TranslateResources) (
                                  translator->Context,
                                  source,
                                  TranslateChildToParent,
                                  0,
                                  NULL,
                                  DeviceNode ? DeviceNode->PhysicalDeviceObject : NULL,
                                  target
                                  );
                    if (NT_SUCCESS(status)) {
                        tmp = source;
                        source = target;
                        target = tmp;

                        //
                        // If the translator is non-hierarchial and performs a complete
                        // translation to root (eg ISA interrups for PCI devices) then
                        // don't pass translations to parent.
                        //

                        if (status == STATUS_TRANSLATION_COMPLETE) {
                            done = TRUE;
                        }

                    } else {

                        IopDbgPrint((
                            IOP_RESOURCE_ERROR_LEVEL,
                            "Child to Root Translation failed\n"
                            "        DeviceNode %08x (PDO %08x)\n"
                            "        Resource Type %02x Data %08x %08x %08x\n",
                            DeviceNode,
                            DeviceNode->PhysicalDeviceObject,
                            source->Type,
                            source->u.DevicePrivate.Data[0],
                            source->u.DevicePrivate.Data[1],
                            source->u.DevicePrivate.Data[2]
                            ));
                        IopRecordTranslationFailure(DeviceNode, *source);
                        goto exit;
                    }
                }
                break;
            }
        }

        //
        // Move up to current device node's parent
        //

        deviceNode = deviceNode->Parent;
    }
    *Target = source;
    ExFreePool(target);
    return status;
exit:
    ExFreePool(source);
    ExFreePool(target);
    return status;
}

NTSTATUS
IopTranslateAndAdjustReqDesc(
    IN PREQ_DESC ReqDesc,
    IN PPI_RESOURCE_TRANSLATOR_ENTRY TranslatorEntry,
    OUT PREQ_DESC *TranslatedReqDesc
    )

/*++

Routine Description:

    This routine translates and adjusts ReqDesc IoResourceDescriptors to
    their translated and adjusted form.

Parameters:

    ReqDesc - supplies a pointer to the REQ_DESC to be translated.

    TranslatorEntry - supplies a pointer to the translator infor structure.

    TranslatedReqDesc - supplies a pointer to a variable to receive the
                        translated REQ_DESC.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ULONG i, total = 0, *targetCount;
    PTRANSLATOR_INTERFACE translator = TranslatorEntry->TranslatorInterface;
    PIO_RESOURCE_DESCRIPTOR ioDesc, *target, tIoDesc;
    PREQ_DESC tReqDesc;
    PARBITER_LIST_ENTRY arbiterEntry;
    NTSTATUS status = STATUS_UNSUCCESSFUL, returnStatus = STATUS_SUCCESS;
    BOOLEAN reqTranslated = FALSE;

    if (ReqDesc->AlternativeTable.AlternativeCount == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    *TranslatedReqDesc = NULL;

    target = (PIO_RESOURCE_DESCRIPTOR *) ExAllocatePoolIORD(
                           PagedPool | POOL_COLD_ALLOCATION,
                           sizeof(PIO_RESOURCE_DESCRIPTOR) * ReqDesc->AlternativeTable.AlternativeCount
                           );
    if (target == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(target, sizeof(PIO_RESOURCE_DESCRIPTOR) * ReqDesc->AlternativeTable.AlternativeCount);

    targetCount = (PULONG) ExAllocatePool(
                           PagedPool | POOL_COLD_ALLOCATION,
                           sizeof(ULONG) * ReqDesc->AlternativeTable.AlternativeCount
                           );
    if (targetCount == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        ExFreePool(target);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(targetCount, sizeof(ULONG) * ReqDesc->AlternativeTable.AlternativeCount);

    //
    // Determine the number of IO_RESOURCE_DESCRIPTORs after translation.
    //

    ioDesc = ReqDesc->AlternativeTable.Alternatives;
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        status = (translator->TranslateResourceRequirements)(
                           translator->Context,
                           ioDesc,
                           ReqDesc->AlternativeTable.PhysicalDeviceObject,
                           &targetCount[i],
                           &target[i]
                           );
        if (!NT_SUCCESS(status) || targetCount[i] == 0) {
            IopDbgPrint((
                IOP_RESOURCE_WARNING_LEVEL,
                "Translator failed to adjust resreqlist\n"));
            target[i] = ioDesc;
            targetCount[i] = 0;
            total++;
        } else {
            total += targetCount[i];
            reqTranslated = TRUE;
        }
        ioDesc++;
        if (NT_SUCCESS(status) && (returnStatus != STATUS_TRANSLATION_COMPLETE)) {
            returnStatus = status;
        }
    }

    if (!reqTranslated) {

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Failed to translate any requirement for %ws!\n",
            PP_DO_TO_DN(ReqDesc->AlternativeTable.PhysicalDeviceObject)->InstancePath.Buffer));
        returnStatus = status;
    }

    //
    // Allocate memory for the adjusted/translated resources descriptors
    //

    tIoDesc = (PIO_RESOURCE_DESCRIPTOR) ExAllocatePoolIORD(
                           PagedPool | POOL_COLD_ALLOCATION,
                           total * sizeof(IO_RESOURCE_DESCRIPTOR));
    if (!tIoDesc) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    tReqDesc = (PREQ_DESC) ExAllocatePool1RD (PagedPool | POOL_COLD_ALLOCATION, sizeof(REQ_DESC));
    if (tReqDesc == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not Enough memory to perform resreqlist adjustment\n"));
        ExFreePool(tIoDesc);
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }

    //
    // Create and initialize a new REQ_DESC for the translated/adjusted io resources
    //

    RtlCopyMemory(tReqDesc, ReqDesc, sizeof(REQ_DESC));

    //
    // Set the translated req desc's ReqAlternative to NULL to indicated this
    // is not the original req desc.
    //

    tReqDesc->ReqAlternative = NULL;

    tReqDesc->u.Translator = TranslatorEntry;
    tReqDesc->TranslatedReqDesc = NULL;
    arbiterEntry = &tReqDesc->AlternativeTable;
    InitializeListHead(&arbiterEntry->ListEntry);
    arbiterEntry->AlternativeCount = total;
    arbiterEntry->Alternatives = tIoDesc;
    arbiterEntry->Assignment = &tReqDesc->Allocation;

    ioDesc = ReqDesc->AlternativeTable.Alternatives;
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        if (targetCount[i] != 0) {
            RtlCopyMemory(tIoDesc, target[i], targetCount[i] * sizeof(IO_RESOURCE_DESCRIPTOR));
            tIoDesc += targetCount[i];
        } else {

            //
            // Make it become impossible to satisfy.
            //

            RtlCopyMemory(tIoDesc, ioDesc, sizeof(IO_RESOURCE_DESCRIPTOR));
            switch (tIoDesc->Type) {
            case CmResourceTypePort:
            case CmResourceTypeMemory:
                tIoDesc->u.Port.MinimumAddress.LowPart = 2;
                tIoDesc->u.Port.MinimumAddress.HighPart = 0;
                tIoDesc->u.Port.MaximumAddress.LowPart = 1;
                tIoDesc->u.Port.MaximumAddress.HighPart = 0;
                break;
            case CmResourceTypeBusNumber:
                tIoDesc->u.BusNumber.MinBusNumber = 2;
                tIoDesc->u.BusNumber.MaxBusNumber = 1;
                break;

            case CmResourceTypeInterrupt:
                tIoDesc->u.Interrupt.MinimumVector = 2;
                tIoDesc->u.Interrupt.MaximumVector = 1;
                break;

            case CmResourceTypeDma:
                tIoDesc->u.Dma.MinimumChannel = 2;
                tIoDesc->u.Dma.MaximumChannel = 1;
                break;
            default:
                ASSERT(0);
                break;
            }
            tIoDesc += 1;
        }
        ioDesc++;

    }

#if DBG_SCOPE
    //
    // Verify the adjusted resource descriptors are valid
    //

    ioDesc = arbiterEntry->Alternatives;
    ASSERT((ioDesc->Option & IO_RESOURCE_ALTERNATIVE) == 0);
    ioDesc++;
    for (i = 1; i < total; i++) {
        ASSERT(ioDesc->Option & IO_RESOURCE_ALTERNATIVE);
        ioDesc++;
    }
#endif
    *TranslatedReqDesc = tReqDesc;
exit:
    for (i = 0; i < ReqDesc->AlternativeTable.AlternativeCount; i++) {
        if (targetCount[i] != 0) {
            ASSERT(target[i]);
            ExFreePool(target[i]);
        }
    }
    ExFreePool(target);
    ExFreePool(targetCount);
    return returnStatus;
}

NTSTATUS
IopCallArbiter(
    PPI_RESOURCE_ARBITER_ENTRY ArbiterEntry,
    ARBITER_ACTION Command,
    PVOID Input1,
    PVOID Input2,
    PVOID Input3
    )

/*++

Routine Description:

    This routine builds a Parameter block from Input structure and calls specified
    arbiter to carry out the Command.

Parameters:

    ArbiterEntry - Supplies a pointer to our PI_RESOURCE_ARBITER_ENTRY such that
                   we know everything about the arbiter.

    Command - Supplies the Action code for the arbiter.

    Input - Supplies a PVOID pointer to a structure.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ARBITER_PARAMETERS parameters;
    PARBITER_INTERFACE arbiterInterface = ArbiterEntry->ArbiterInterface;
    NTSTATUS status;
    PARBITER_LIST_ENTRY arbiterListEntry;
    LIST_ENTRY listHead;
    PVOID *ExtParams;

    switch (Command) {
    case ArbiterActionTestAllocation:
    case ArbiterActionRetestAllocation:

        //
        // For ArbiterActionTestAllocation, the Input is a pointer to the doubly
        // linked list of ARBITER_LIST_ENTRY's.
        //

        parameters.Parameters.TestAllocation.ArbitrationList = (PLIST_ENTRY)Input1;
        parameters.Parameters.TestAllocation.AllocateFromCount = (ULONG)((ULONG_PTR)Input2);
        parameters.Parameters.TestAllocation.AllocateFrom =
                                            (PCM_PARTIAL_RESOURCE_DESCRIPTOR)Input3;
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    case ArbiterActionBootAllocation:

        //
        // For ArbiterActionBootAllocation, the input is a pointer to the doubly
        // linked list of ARBITER_LIST_ENTRY'S.
        //

        parameters.Parameters.BootAllocation.ArbitrationList = (PLIST_ENTRY)Input1;

        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    case ArbiterActionQueryArbitrate:

        //
        // For QueryArbiter, the input is a pointer to REQ_DESC
        //

        arbiterListEntry = &((PREQ_DESC)Input1)->AlternativeTable;
        ASSERT(IsListEmpty(&arbiterListEntry->ListEntry));
        listHead = arbiterListEntry->ListEntry;
        arbiterListEntry->ListEntry.Flink = arbiterListEntry->ListEntry.Blink = &listHead;
        parameters.Parameters.QueryArbitrate.ArbitrationList = &listHead;
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        arbiterListEntry->ListEntry = listHead;
        break;

    case ArbiterActionCommitAllocation:
    case ArbiterActionWriteReservedResources:

        //
        // Commit, Rollback and WriteReserved do not have parmater.
        //

        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      NULL
                      );
        break;

    case ArbiterActionQueryAllocatedResources:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case ArbiterActionQueryConflict:
        //
        // For QueryConflict
        // Ex0 is PDO
        // Ex1 is PIO_RESOURCE_DESCRIPTOR
        // Ex2 is PULONG
        // Ex3 is PARBITER_CONFLICT_INFO *
        ExtParams = (PVOID*)Input1;

        parameters.Parameters.QueryConflict.PhysicalDeviceObject = (PDEVICE_OBJECT)ExtParams[0];
        parameters.Parameters.QueryConflict.ConflictingResource = (PIO_RESOURCE_DESCRIPTOR)ExtParams[1];
        parameters.Parameters.QueryConflict.ConflictCount = (PULONG)ExtParams[2];
        parameters.Parameters.QueryConflict.Conflicts = (PARBITER_CONFLICT_INFO *)ExtParams[3];
        status = (arbiterInterface->ArbiterHandler)(
                      arbiterInterface->Context,
                      Command,
                      &parameters
                      );
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    return status;
}

NTSTATUS
IopFindResourcesForArbiter (
    IN PDEVICE_NODE DeviceNode,
    IN UCHAR ResourceType,
    OUT ULONG *Count,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *CmDesc
    )

/*++

Routine Description:

    This routine returns the resources required by the ResourceType arbiter in DeviceNode.

Parameters:

    DeviceNode -specifies the device node whose ResourceType arbiter is requesting for resources

    ResourceType - specifies the resource type

    Count - specifies a pointer to a varaible to receive the count of Cm descriptors returned

    CmDesc - specifies a pointer to a varibble to receive the returned cm descriptor.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PIOP_RESOURCE_REQUEST assignEntry;
    PREQ_ALTERNATIVE reqAlternative;
    PREQ_DESC reqDesc;
    ULONG i, count = 0;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;

    *Count = 0;
    *CmDesc = NULL;

    if (DeviceNode->State == DeviceNodeStarted) {
        return STATUS_SUCCESS;
    }

    //
    // Find this device node's IOP_RESOURCE_REQUEST structure first
    //

    for (assignEntry = PiAssignTable + PiAssignTableCount - 1;
         assignEntry >= PiAssignTable;
         assignEntry--) {
        if (assignEntry->PhysicalDevice == DeviceNode->PhysicalDeviceObject) {
            break;
        }
    }
    if (assignEntry < PiAssignTable) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Rebalance: No resreqlist for Arbiter? Can not find Arbiter assign"
            " table entry\n"));
        return STATUS_UNSUCCESSFUL;
    }

    reqAlternative = *((PREQ_LIST)assignEntry->ReqList)->SelectedAlternative;
    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i]->TranslatedReqDesc;
        if (reqDesc->Allocation.Type == ResourceType) {
            count++;
        }
    }

    cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ExAllocatePoolPRD(
                       PagedPool,
                       sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) * count
                       );
    if (!cmDescriptor) {

        //
        // If we can not find memory, the resources will not be committed by arbiter.
        //

        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *Count = count;
    *CmDesc = cmDescriptor;

    for (i = 0; i < reqAlternative->DescCount; i++) {
        reqDesc = reqAlternative->DescTable[i]->TranslatedReqDesc;
        if (reqDesc->Allocation.Type == ResourceType) {
            *cmDescriptor = reqDesc->Allocation;
            cmDescriptor++;
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IopRestoreResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine reassigns the released resources for device specified by DeviceNode.

Parameters:

    DeviceNode - specifies the device node whose resources are goint to be released.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    IOP_RESOURCE_REQUEST requestTable;
    NTSTATUS status;
    LIST_ENTRY  activeArbiterList;

    if (DeviceNode->ResourceList == NULL) {
        return STATUS_SUCCESS;
    }
    requestTable.ResourceRequirements =
        IopCmResourcesToIoResources (0, DeviceNode->ResourceList, LCPRI_FORCECONFIG);
    if (requestTable.ResourceRequirements == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Not enough memory to clean up rebalance failure\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    requestTable.Priority = 0;
    requestTable.Flags = 0;
    requestTable.AllocationType = ArbiterRequestPnpEnumerated;
    requestTable.PhysicalDevice = DeviceNode->PhysicalDeviceObject;
    requestTable.ReqList = NULL;
    requestTable.ResourceAssignment = NULL;
    requestTable.TranslatedResourceAssignment = NULL;
    requestTable.Status = 0;

    //
    // rebuild internal representation of the resource requirements list
    //

    status = IopResourceRequirementsListToReqList(
                    &requestTable,
                    &requestTable.ReqList);

    if (!NT_SUCCESS(status) || requestTable.ReqList == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Not enough memory to restore previous resources\n"));
        ExFreePool (requestTable.ResourceRequirements);
        return status;
    } else {
        PREQ_LIST reqList;

        reqList = (PREQ_LIST)requestTable.ReqList;

        //
        // Sort the ReqList such that the higher priority Alternative list are
        // placed in the front of the list.
        //

        IopRearrangeReqList(reqList);
        if (reqList->BestAlternative == NULL) {

            IopFreeResourceRequirementsForAssignTable(&requestTable, (&requestTable) + 1);
            return STATUS_DEVICE_CONFIGURATION_ERROR;

        }
    }

    status = IopFindBestConfiguration(&requestTable, 1, &activeArbiterList);
    IopFreeResourceRequirementsForAssignTable(&requestTable, (&requestTable) + 1);
    if (NT_SUCCESS(status)) {
        //
        // Ask the arbiters to commit this configuration.
        //
        status = IopCommitConfiguration(&activeArbiterList);
    }
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "IopRestoreResourcesInternal: BOOT conflict for %ws\n",
            DeviceNode->InstancePath.Buffer));
    }
    if (requestTable.ResourceAssignment) {
        ExFreePool(requestTable.ResourceAssignment);
    }
    if (requestTable.TranslatedResourceAssignment) {
        ExFreePool(requestTable.TranslatedResourceAssignment);
    }
    IopWriteAllocatedResourcesToRegistry (
        DeviceNode,
        DeviceNode->ResourceList,
        IopDetermineResourceListSize(DeviceNode->ResourceList)
        );
    return status;
}

VOID
IopReleaseResourcesInternal (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine releases the assigned resources for device specified by DeviceNode.
    Note, this routine does not reset the resource related fields in DeviceNode structure.

Parameters:

    DeviceNode - specifies the device node whose resources are goint to be released.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE device;
    PLIST_ENTRY listHead, listEntry;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    ARBITER_LIST_ENTRY arbiterListEntry;
    INTERFACE_TYPE interfaceType;
    ULONG busNumber, listCount, i, j, size;
    PCM_RESOURCE_LIST resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    BOOLEAN search = TRUE;
#if DBG_SCOPE
    NTSTATUS status;
#endif

    InitializeListHead(&arbiterListEntry.ListEntry);
    arbiterListEntry.AlternativeCount = 0;
    arbiterListEntry.Alternatives = NULL;
    arbiterListEntry.PhysicalDeviceObject = DeviceNode->PhysicalDeviceObject;
    arbiterListEntry.Flags = 0;
    arbiterListEntry.WorkSpace = 0;
    arbiterListEntry.Assignment = NULL;
    arbiterListEntry.RequestSource = ArbiterRequestPnpEnumerated;

    resourceList = DeviceNode->ResourceList;
    if (resourceList == NULL) {
        resourceList = DeviceNode->BootResources;
    }
    if (resourceList && resourceList->Count > 0) {
        listCount = resourceList->Count;
        cmFullDesc = &resourceList->List[0];
    } else {
        listCount = 1;
        resourceList = NULL;
    }
    for (i = 0; i < listCount; i++) {

        if (resourceList) {
            interfaceType = cmFullDesc->InterfaceType;
            busNumber = cmFullDesc->BusNumber;
            if (interfaceType == InterfaceTypeUndefined) {
                interfaceType = PnpDefaultInterfaceType;
            }
        } else {
            interfaceType = PnpDefaultInterfaceType;
            busNumber = 0;
        }

        device = DeviceNode->Parent;
        while (device) {
            if ((device == IopRootDeviceNode) && search) {
                device = IopFindLegacyBusDeviceNode (
                                 interfaceType,
                                 busNumber
                                 );

                //
                // If we did not find a PDO, try again with InterfaceType == Isa. This allows
                // drivers that request Internal to get resources even if there is no PDO
                // that is Internal. (but if there is an Internal PDO, they get that one)
                //

                if ((device == IopRootDeviceNode) && (interfaceType == Internal)) {
                    device = IopFindLegacyBusDeviceNode(Isa, 0);
                }
                search = FALSE;

            }
            listHead = &device->DeviceArbiterList;
            listEntry = listHead->Flink;
            while (listEntry != listHead) {
                arbiterEntry = CONTAINING_RECORD(listEntry, PI_RESOURCE_ARBITER_ENTRY, DeviceArbiterList);
                if (arbiterEntry->ArbiterInterface != NULL) {
                    search = FALSE;
                    ASSERT(IsListEmpty(&arbiterEntry->ResourceList));
                    InitializeListHead(&arbiterEntry->ResourceList);  // Recover from assert
                    InsertTailList(&arbiterEntry->ResourceList, &arbiterListEntry.ListEntry);
    #if DBG_SCOPE
                    status =
    #endif
                    IopCallArbiter(arbiterEntry,
                                   ArbiterActionTestAllocation,
                                   &arbiterEntry->ResourceList,
                                   NULL,
                                   NULL
                                   );
    #if DBG_SCOPE
                    ASSERT(status == STATUS_SUCCESS);
                    status =
    #endif
                    IopCallArbiter(arbiterEntry,
                                   ArbiterActionCommitAllocation,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
    #if DBG_SCOPE
                    ASSERT(status == STATUS_SUCCESS);
    #endif
                    RemoveEntryList(&arbiterListEntry.ListEntry);
                    InitializeListHead(&arbiterListEntry.ListEntry);
                }
                listEntry = listEntry->Flink;
            }
            device = device->Parent;
        }

        //
        // If there are more than 1 list, move to next list
        //

        if (listCount > 1) {
            cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmPartDesc->Type) {
                case CmResourceTypeDeviceSpecific:
                     size = cmPartDesc->u.DeviceSpecificData.DataSize;
                     break;
                }
                cmPartDesc++;
                cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
            }
            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
        }
    }

    IopWriteAllocatedResourcesToRegistry(DeviceNode, NULL, 0);
}

NTSTATUS
IopFindLegacyDeviceNode (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PDEVICE_NODE *LegacyDeviceNode,
    OUT PDEVICE_OBJECT *LegacyPDO
    )

/*++

Routine Description:

    This routine searches for the device node and device object created for legacy resource
    allocation for the DriverObject and DeviceObject.

Parameters:

    DriverObject - specifies the driver object doing the legacy allocation.

    DeviceObject - specifies the device object.

    LegacyDeviceNode - receives the pointer to the legacy device node if found.

    LegacyDeviceObject - receives the pointer to the legacy device object if found.


Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS        status = STATUS_UNSUCCESSFUL;
    PDEVICE_NODE    deviceNode;

    ASSERT(LegacyDeviceNode && LegacyPDO);


    //
    // Use the device object if it exists.
    //

    if (DeviceObject) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        if (deviceNode) {

            *LegacyPDO = DeviceObject;
            *LegacyDeviceNode = deviceNode;
            status = STATUS_SUCCESS;

        } else if (!(DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE)) {

            status = PipAllocateDeviceNode(DeviceObject, &deviceNode);
            if (deviceNode) {

                if (status == STATUS_SYSTEM_HIVE_TOO_LARGE) {

                    IopDestroyDeviceNode(deviceNode);
                } else {

                    deviceNode->Flags |= DNF_LEGACY_RESOURCE_DEVICENODE;
                    IopSetLegacyDeviceInstance (DriverObject, deviceNode);
                    *LegacyPDO = DeviceObject;
                    *LegacyDeviceNode = deviceNode;
                    status = STATUS_SUCCESS;
                }
            } else {

                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Failed to allocate device node for PDO %08X\n",
                    DeviceObject));
                status = STATUS_INSUFFICIENT_RESOURCES;

            }

        } else {

            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "%08X PDO without a device node!\n",
                DeviceObject));
            ASSERT(PP_DO_TO_DN(DeviceObject));

        }

    } else {

        //
        // Search our list of legacy device nodes.
        //

        for (   deviceNode = IopLegacyDeviceNode;
                deviceNode && deviceNode->DuplicatePDO != (PDEVICE_OBJECT)DriverObject;
                deviceNode = deviceNode->NextDeviceNode);

        if (deviceNode) {

            *LegacyPDO = deviceNode->PhysicalDeviceObject;
            *LegacyDeviceNode = deviceNode;
            status = STATUS_SUCCESS;

        } else {

            PDEVICE_OBJECT  pdo;

            //
            // We are seeing this for the first time.
            // Create a madeup device node.
            //

            status = IoCreateDevice( IoPnpDriverObject,
                                     sizeof(IOPNP_DEVICE_EXTENSION),
                                     NULL,
                                     FILE_DEVICE_CONTROLLER,
                                     FILE_AUTOGENERATED_DEVICE_NAME,
                                     FALSE,
                                     &pdo);

            if (NT_SUCCESS(status)) {

                pdo->Flags |= DO_BUS_ENUMERATED_DEVICE;
                PipAllocateDeviceNode(pdo, &deviceNode);
                if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

                    //
                    // Change driver object to the caller even though the owner
                    // of the pdo is IoPnpDriverObject.  This is to support
                    // DriverExclusive for legacy interface.
                    //

                    pdo->DriverObject = DriverObject;
                    deviceNode->Flags = DNF_MADEUP | DNF_LEGACY_RESOURCE_DEVICENODE;

                    PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                    deviceNode->DuplicatePDO = (PDEVICE_OBJECT)DriverObject;
                    IopSetLegacyDeviceInstance (DriverObject, deviceNode);

                    //
                    // Add it to our list of legacy device nodes rather than adding it to the HW tree.
                    //

                    deviceNode->NextDeviceNode = IopLegacyDeviceNode;
                    if (IopLegacyDeviceNode) {

                        IopLegacyDeviceNode->PreviousDeviceNode = deviceNode;

                    }
                    IopLegacyDeviceNode = deviceNode;
                    *LegacyPDO = pdo;
                    *LegacyDeviceNode = deviceNode;

                } else {

                    IopDbgPrint((
                        IOP_RESOURCE_ERROR_LEVEL,
                        "Failed to allocate device node for PDO %08X\n",
                        pdo));
                    IoDeleteDevice(pdo);
                    status = STATUS_INSUFFICIENT_RESOURCES;

                }

            } else {

                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "IoCreateDevice failed with status %08X\n",
                    status));

            }
        }
    }

    return status;
}

VOID
IopRemoveLegacyDeviceNode (
    IN PDEVICE_OBJECT   DeviceObject OPTIONAL,
    IN PDEVICE_NODE     LegacyDeviceNode
    )

/*++

Routine Description:

    This routine removes the device node and device object created for legacy resource
    allocation for the DeviceObject.

Parameters:

    DeviceObject - specifies the device object.

    LegacyDeviceNode - receives the pointer to the legacy device node if found.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ASSERT(LegacyDeviceNode);


    if (!DeviceObject) {

        if (LegacyDeviceNode->DuplicatePDO) {

            LegacyDeviceNode->DuplicatePDO = NULL;
            if (LegacyDeviceNode->PreviousDeviceNode) {

                LegacyDeviceNode->PreviousDeviceNode->NextDeviceNode = LegacyDeviceNode->NextDeviceNode;

            }

            if (LegacyDeviceNode->NextDeviceNode) {

                LegacyDeviceNode->NextDeviceNode->PreviousDeviceNode = LegacyDeviceNode->PreviousDeviceNode;

            }

            if (IopLegacyDeviceNode == LegacyDeviceNode) {

                IopLegacyDeviceNode = LegacyDeviceNode->NextDeviceNode;

            }

        } else {

            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "%ws does not have a duplicate PDO\n",
                LegacyDeviceNode->InstancePath.Buffer));
            ASSERT(LegacyDeviceNode->DuplicatePDO);
            return;

        }
    }

    if (!(DeviceObject && (DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE))) {

        PDEVICE_NODE    resourceDeviceNode;
        PDEVICE_OBJECT  pdo;

        for (   resourceDeviceNode = (PDEVICE_NODE)LegacyDeviceNode->OverUsed1.LegacyDeviceNode;
                resourceDeviceNode;
                resourceDeviceNode = resourceDeviceNode->OverUsed2.NextResourceDeviceNode) {

                if (resourceDeviceNode->OverUsed2.NextResourceDeviceNode == LegacyDeviceNode) {

                    resourceDeviceNode->OverUsed2.NextResourceDeviceNode = LegacyDeviceNode->OverUsed2.NextResourceDeviceNode;
                    break;

                }
        }

        LegacyDeviceNode->Parent = LegacyDeviceNode->Sibling =
            LegacyDeviceNode->Child = LegacyDeviceNode->LastChild = NULL;

        //
        // Delete the dummy PDO and device node.
        //

        pdo = LegacyDeviceNode->PhysicalDeviceObject;
        LegacyDeviceNode->Flags &= ~DNF_LEGACY_RESOURCE_DEVICENODE;
        IopDestroyDeviceNode(LegacyDeviceNode);

        if (!DeviceObject) {

            pdo->DriverObject = IoPnpDriverObject;
            IoDeleteDevice(pdo);
        }
    }
}


VOID
IopSetLegacyResourcesFlag(
    IN PDRIVER_OBJECT DriverObject
    )
{
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    //
    // Once tainted, a driver can never lose it's legacy history
    // (unless unloaded). This is because the device object
    // field is optional, and we don't bother counting here...
    //
    DriverObject->Flags |= DRVO_LEGACY_RESOURCES;
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
}


NTSTATUS
IopLegacyResourceAllocation (
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources OPTIONAL
    )

/*++

Routine Description:

    This routine handles legacy interface IoAssignResources and IoReportResourcesUsage,
    It converts the request to call IopAllocateResources.

Parameters:

    AllocationType - Allocation type for the legacy request.

    DriverObject - Driver object doing the legacy allocation.

    DeviceObject - Device object.

    ResourceRequirements - Legacy resource requirements. If NULL, caller want to free resources.

    AllocatedResources - Pointer to a variable that receives pointer to allocated resources.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_OBJECT      pdo;
    PDEVICE_NODE        deviceNode;
    PDEVICE_NODE        legacyDeviceNode;
    NTSTATUS            status;
    PCM_RESOURCE_LIST   combinedResources;

    ASSERT(DriverObject);

    //
    // Grab the IO registry semaphore to make sure no other device is
    // reporting it's resource usage while we are searching for conflicts.
    //

    IopLockResourceManager();
    status = IopFindLegacyDeviceNode(DriverObject, DeviceObject, &deviceNode, &pdo);
    if (NT_SUCCESS(status)) {

        legacyDeviceNode = NULL;
        if (!deviceNode->Parent && ResourceRequirements) {

            //
            // Make IopRootDeviceNode the bus pdo so we will search the right bus pdo
            // on resource descriptor level.
            //

            if (ResourceRequirements->InterfaceType == InterfaceTypeUndefined) {

                ResourceRequirements->InterfaceType = PnpDefaultInterfaceType;

            }
            deviceNode->Parent = IopRootDeviceNode;

        }

        //
        // Release resources for this device node.
        //

        if (    (!ResourceRequirements && deviceNode->Parent) ||
                deviceNode->ResourceList ||
                deviceNode->BootResources) {

            IopReleaseResources(deviceNode);
        }

        if (ResourceRequirements) {

            IOP_RESOURCE_REQUEST    requestTable;
            IOP_RESOURCE_REQUEST    *requestTablep;
            ULONG                   count;

            //
            // Try to allocate these resource requirements.
            //

            count = 1;
            RtlZeroMemory(&requestTable, sizeof(IOP_RESOURCE_REQUEST));
            requestTable.ResourceRequirements = ResourceRequirements;
            requestTable.PhysicalDevice = pdo;
            requestTable.Flags = IOP_ASSIGN_NO_REBALANCE;
            requestTable.AllocationType =  AllocationType;

            requestTablep = &requestTable;
            IopAllocateResources(&count, &requestTablep, TRUE, TRUE, NULL);

            status = requestTable.Status;
            if (NT_SUCCESS(status)) {

                deviceNode->ResourceListTranslated = requestTable.TranslatedResourceAssignment;
                count = IopDetermineResourceListSize((*AllocatedResources) ? *AllocatedResources : requestTable.ResourceAssignment);
                deviceNode->ResourceList = ExAllocatePoolIORL(PagedPool, count);
                if (deviceNode->ResourceList) {

                    if (*AllocatedResources) {

                        //
                        // We got called from IoReportResourceUsage.
                        //

                        ASSERT(requestTable.ResourceAssignment);
                        ExFreePool(requestTable.ResourceAssignment);

                    } else {

                        //
                        // We got called from IoAssignResources.
                        //

                        *AllocatedResources = requestTable.ResourceAssignment;

                    }
                    RtlCopyMemory(deviceNode->ResourceList, *AllocatedResources, count);
                    legacyDeviceNode = (PDEVICE_NODE)deviceNode->OverUsed1.LegacyDeviceNode;

                } else {

                    deviceNode->ResourceList = requestTable.ResourceAssignment;
                    IopReleaseResources(deviceNode);
                    status = STATUS_INSUFFICIENT_RESOURCES;

                }
            }

            //
            // Remove the madeup PDO and device node if there was some error.
            //

            if (!NT_SUCCESS(status)) {

                IopRemoveLegacyDeviceNode(DeviceObject, deviceNode);

            }

        } else {

            //
            // Caller wants to release resources.
            //

            legacyDeviceNode = (PDEVICE_NODE)deviceNode->OverUsed1.LegacyDeviceNode;
            IopRemoveLegacyDeviceNode(DeviceObject, deviceNode);

        }

        if (NT_SUCCESS(status)) {

            if (legacyDeviceNode) {

                //
                // After the resource is modified, update the allocated resource list
                // for the Root\Legacy_xxxx\0000 device instance.
                //

                combinedResources = IopCombineLegacyResources(legacyDeviceNode);
                if (combinedResources) {

                    IopWriteAllocatedResourcesToRegistry(   legacyDeviceNode,
                                                            combinedResources,
                                                            IopDetermineResourceListSize(combinedResources));
                    ExFreePool(combinedResources);
                }
            }

            if (AllocationType != ArbiterRequestPnpDetected) {

                //
                // Modify the DRVOBJ flags.
                //
                if (ResourceRequirements) {

                    IopSetLegacyResourcesFlag(DriverObject);
                }
            }
        }
    }
    IopUnlockResourceManager();

    return status;
}

NTSTATUS
IopDuplicateDetection (
    IN INTERFACE_TYPE LegacyBusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    OUT PDEVICE_NODE *DeviceNode
    )

/*++

Routine Description:

    This routine searches for the bus device driver for a given legacy device,
    sends a query interface IRP for legacy device detection, and if the driver
    implements this interface, requests the PDO for the given legacy device.

Parameters:

    LegacyBusType - The legacy device's interface type.

    BusNumber - The legacy device's bus number.

    SlotNumber - The legacy device's slot number.

    DeviceNode - specifies a pointer to a variable to receive the duplicated device node

Return Value:

    NTSTATUS code.

--*/

{
    PDEVICE_NODE deviceNode;
    PDEVICE_OBJECT busDeviceObject;
    PLEGACY_DEVICE_DETECTION_INTERFACE interface;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    UNREFERENCED_PARAMETER(SlotNumber);
    //
    // Initialize return parameter to "not found".
    //
    *DeviceNode = NULL;
    //
    // Search the device tree for the bus of the legacy device.
    //
    deviceNode = IopFindLegacyBusDeviceNode(
                     LegacyBusType,
                     BusNumber);
    //
    // Either a bus driver does not exist (or more likely, the legacy bus
    // type and bus number were unspecified).  Either way, we can't make
    // any further progress.
    //
    if (deviceNode == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // We found the legacy device's bus driver.  Query it to determine
    // whether it implements the LEGACY_DEVICE_DETECTION interface.
    //

    busDeviceObject = deviceNode->PhysicalDeviceObject;
    status = IopQueryResourceHandlerInterface(
                 ResourceLegacyDeviceDetection,
                 busDeviceObject,
                 0,
                 (PINTERFACE *)&interface);
    //
    // If it doesn't, we're stuck.
    //
    if (!NT_SUCCESS(status) || interface == NULL) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Invoke the bus driver's legacy device detection method.
    //
    status = (*interface->LegacyDeviceDetection)(
                 interface->Context,
                 LegacyBusType,
                 BusNumber,
                 SlotNumber,
                 &deviceObject);
    //
    // If it found a legacy device, update the return parameter.
    //
    if (NT_SUCCESS(status) && deviceObject != NULL) {

        *DeviceNode = PP_DO_TO_DN(deviceObject);

        status = STATUS_SUCCESS;
    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    //
    // Free the interface.
    //
    (*interface->InterfaceDereference)(interface->Context);

    ExFreePool(interface);

    return status;
}

VOID
IopSetLegacyDeviceInstance (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine sets the Root\Legacy_xxxx\0000 device instance path to the
    madeup PDO (i.e. DeviceNode) which is created only for legacy resource allocation.
    This routine also links the madeup PDO to the Root\Legacy_xxxx\0000 device node
    to keep track what resources are assigned to the driver which services the
    root\legacy_xxxx\0000 device.

Parameters:

    P1 -

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS status;
    UNICODE_STRING instancePath, rootString;
    HANDLE handle;
    PDEVICE_NODE legacyDeviceNode;
    PDEVICE_OBJECT legacyPdo;

    PAGED_CODE();

    DeviceNode->OverUsed1.LegacyDeviceNode = 0;
    instancePath.Length = 0;
    instancePath.Buffer = NULL;

    status = PipServiceInstanceToDeviceInstance (
                 NULL,
                 &DriverObject->DriverExtension->ServiceKeyName,
                 0,
                 &instancePath,
                 &handle,
                 KEY_READ
                 );
    if (NT_SUCCESS(status) && (instancePath.Length != 0)) {
        PiWstrToUnicodeString(&rootString, L"ROOT\\LEGACY");
        if (RtlPrefixUnicodeString(&rootString, &instancePath, TRUE) == FALSE) {
            RtlFreeUnicodeString(&instancePath);
        } else {
            DeviceNode->InstancePath = instancePath;
            legacyPdo = IopDeviceObjectFromDeviceInstance (&instancePath);
            if (legacyPdo) {
                legacyDeviceNode = PP_DO_TO_DN(legacyPdo);
                DeviceNode->OverUsed2.NextResourceDeviceNode =
                    legacyDeviceNode->OverUsed2.NextResourceDeviceNode;
                legacyDeviceNode->OverUsed2.NextResourceDeviceNode = DeviceNode;
                DeviceNode->OverUsed1.LegacyDeviceNode = legacyDeviceNode;
            }
        }
        ZwClose(handle);
    }
}

PCM_RESOURCE_LIST
IopCombineLegacyResources (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine sets the Root\Legacy_xxxx\0000 device instance path to the
    madeup PDO (i.e. DeviceNode) which is created only for legacy resource allocation.
    This routine also links the madeup PDO to the Root\Legacy_xxxx\0000 device node
    to keep track what resources are assigned to the driver which services the
    root\legacy_xxxx\0000 device.

Parameters:

    DeviceNode - The legacy device node whose resources need to be combined.

Return Value:

    Return the combined resource list.

--*/

{
    PCM_RESOURCE_LIST combinedList = NULL;
    PDEVICE_NODE devNode = DeviceNode;
    ULONG size = 0;
    PUCHAR p;

    PAGED_CODE();

    if (DeviceNode) {

        //
        // First determine how much memory is needed for the new combined list.
        //

        while (devNode) {
            if (devNode->ResourceList) {
                size += IopDetermineResourceListSize(devNode->ResourceList);
            }
            devNode = (PDEVICE_NODE)devNode->OverUsed2.NextResourceDeviceNode;
        }
        if (size != 0) {
            combinedList = (PCM_RESOURCE_LIST) ExAllocatePoolCMRL(PagedPool, size);
            devNode = DeviceNode;
            if (combinedList) {
                combinedList->Count = 0;
                p = (PUCHAR)combinedList;
                p += sizeof(ULONG);  // Skip Count
                while (devNode) {
                    if (devNode->ResourceList) {
                        size = IopDetermineResourceListSize(devNode->ResourceList);
                        if (size != 0) {
                            size -= sizeof(ULONG);
                            RtlCopyMemory(
                                p,
                                devNode->ResourceList->List,
                                size
                                );
                            p += size;
                            combinedList->Count += devNode->ResourceList->Count;
                        }
                    }
                    devNode = (PDEVICE_NODE)devNode->OverUsed2.NextResourceDeviceNode;
                }
            }
        }
    }
    return combinedList;
}

VOID
IopReleaseResources (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    IopReleaseResources releases resources owned by the device and release
    the memory pool.  We also release the cached resource requirements list.
    If the device is a root enumerated device with BOOT config, we will preallocate
    boot config resources for this device.

    NOTE, this is a routine INTERNAL to this file.  NO one should call this function
    outside of this file.  Outside of this file, IopReleaseDeviceResources should be
    used.

Arguments:

    DeviceNode - Supplies a pointer to the device node.object.  If present, caller wants to

Return Value:

    None.

--*/
{

    //
    // Release the resources owned by the device
    //

    IopReleaseResourcesInternal(DeviceNode);

#if DBG_SCOPE

    if (DeviceNode->PreviousResourceList) {
        ExFreePool(DeviceNode->PreviousResourceList);
        DeviceNode->PreviousResourceList = NULL;
    }
    if (DeviceNode->PreviousResourceRequirements) {
        ExFreePool(DeviceNode->PreviousResourceRequirements);
        DeviceNode->PreviousResourceRequirements = NULL;
    }
#endif

    if (DeviceNode->ResourceList) {

#if DBG_SCOPE
        if (!NT_SUCCESS(DeviceNode->FailureStatus)) {
            DeviceNode->PreviousResourceList = DeviceNode->ResourceList;
        } else {
            ExFreePool(DeviceNode->ResourceList);
        }
#else
        ExFreePool(DeviceNode->ResourceList);
#endif

        DeviceNode->ResourceList = NULL;
    }
    if (DeviceNode->ResourceListTranslated) {
        ExFreePool(DeviceNode->ResourceListTranslated);
        DeviceNode->ResourceListTranslated = NULL;
    }

    //
    // If this device is a root enumerated device, preallocate its BOOT resources
    //

    if ((DeviceNode->Flags & (DNF_MADEUP | DNF_DEVICE_GONE)) == DNF_MADEUP) {
        if (DeviceNode->Flags & DNF_HAS_BOOT_CONFIG && DeviceNode->BootResources) {
            IopAllocateBootResourcesInternal(ArbiterRequestPnpEnumerated,
                                            DeviceNode->PhysicalDeviceObject,
                                            DeviceNode->BootResources);
        }
    } else {
        DeviceNode->Flags &= ~(DNF_HAS_BOOT_CONFIG | DNF_BOOT_CONFIG_RESERVED);
        if (DeviceNode->BootResources) {
            ExFreePool(DeviceNode->BootResources);
            DeviceNode->BootResources = NULL;
        }
    }
}

VOID
IopReallocateResources(
    IN PDEVICE_NODE DeviceNode
    )
/*++

Routine Description:

    This routine performs the real work for IoInvalidateDeviceState - ResourceRequirementsChanged.

Arguments:

    DeviceNode - Supplies a pointer to the device node.

Return Value:

    None.

--*/
{
    IOP_RESOURCE_REQUEST requestTable, *requestTablep;
    ULONG deviceCount, oldFlags;
    NTSTATUS status;
    LIST_ENTRY  activeArbiterList;

    PAGED_CODE();

    //
    // Grab the IO registry semaphore to make sure no other device is
    // reporting it's resource usage while we are searching for conflicts.
    //

    IopLockResourceManager();

    //
    // Check the flags after acquiring the semaphore.
    //

    if (DeviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) {
        //
        // Save the flags which we may have to restore in case of failure.
        //

        oldFlags = DeviceNode->Flags & DNF_NO_RESOURCE_REQUIRED;
        DeviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;

        if (DeviceNode->Flags & DNF_NON_STOPPED_REBALANCE) {

            //
            // Set up parameters to call real routine
            //

            RtlZeroMemory(&requestTable, sizeof(IOP_RESOURCE_REQUEST));
            requestTable.PhysicalDevice = DeviceNode->PhysicalDeviceObject;
            requestTablep = &requestTable;
            requestTable.Flags |= IOP_ASSIGN_NO_REBALANCE + IOP_ASSIGN_KEEP_CURRENT_CONFIG;

            status = IopGetResourceRequirementsForAssignTable(  requestTablep,
                                                                requestTablep + 1,
                                                                &deviceCount);
            if (deviceCount) {

                //
                // Release the current resources to the arbiters.
                // Memory for ResourceList is not released.
                //

                if (DeviceNode->ResourceList) {

                    IopReleaseResourcesInternal(DeviceNode);
                }

                //
                // Try to do the assignment.
                //

                status = IopFindBestConfiguration(
                            requestTablep,
                            deviceCount,
                            &activeArbiterList);
                if (NT_SUCCESS(status)) {
                    //
                    // Ask the arbiters to commit this configuration.
                    //
                    status = IopCommitConfiguration(&activeArbiterList);
                }
                if (NT_SUCCESS(status)) {

                    DeviceNode->Flags &= ~(DNF_RESOURCE_REQUIREMENTS_CHANGED | DNF_NON_STOPPED_REBALANCE);

                    IopBuildCmResourceLists(requestTablep, requestTablep + 1);

                    //
                    // We need to release the pool space for ResourceList and ResourceListTranslated.
                    // Because the earlier IopReleaseResourcesInternal does not release the pool.
                    //

                    if (DeviceNode->ResourceList) {

                        ExFreePool(DeviceNode->ResourceList);

                    }
                    if (DeviceNode->ResourceListTranslated) {

                        ExFreePool(DeviceNode->ResourceListTranslated);

                    }

                    DeviceNode->ResourceList = requestTablep->ResourceAssignment;
                    DeviceNode->ResourceListTranslated = requestTablep->TranslatedResourceAssignment;

                    ASSERT(DeviceNode->State == DeviceNodeStarted);

                    status = IopStartDevice(DeviceNode->PhysicalDeviceObject);

                    if (!NT_SUCCESS(status)) {

                        PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_NORMAL_CONFLICT);
                    }

                } else {

                    NTSTATUS restoreResourcesStatus;

                    restoreResourcesStatus = IopRestoreResourcesInternal(DeviceNode);
                    if (!NT_SUCCESS(restoreResourcesStatus)) {

                        ASSERT(NT_SUCCESS(restoreResourcesStatus));
                        PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_NEED_RESTART);
                    }
                }

                IopFreeResourceRequirementsForAssignTable(requestTablep, requestTablep + 1);
            }

        } else {

            //
            // The device needs to be stopped to change resources.
            //

            status = IopRebalance(0, NULL);

        }

        //
        // Restore the flags in case of failure.
        //

        if (!NT_SUCCESS(status)) {

            DeviceNode->Flags &= ~DNF_NO_RESOURCE_REQUIRED;
            DeviceNode->Flags |= oldFlags;

        }

    } else {

        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "Resource requirements not changed in "
            "IopReallocateResources, returning error!\n"));
    }

    IopUnlockResourceManager();
}

NTSTATUS
IopQueryConflictList(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    )
/*++

Routine Description:

    This routine performs the querying of device conflicts
    returning data in ConflictList

Arguments:

    PhysicalDeviceObject PDO of device to Query
    ResourceList      CM resource list containing single resource to query
    ResourceListSize  Size of ResourceList
    ConflictList      Conflict list to fill query details in
    ConflictListSize  Size of buffer that we can fill with Conflict information
    Flags             Currently unused (zero) for future passing of flags

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IopLockResourceManager();

    status = IopQueryConflictListInternal(PhysicalDeviceObject, ResourceList, ResourceListSize, ConflictList, ConflictListSize, Flags);

    IopUnlockResourceManager();

    return status;
}



BOOLEAN
IopEliminateBogusConflict(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PDEVICE_OBJECT   ConflictDeviceObject
    )
/*++

Routine Description:

    Determine if we're really conflicting with ourselves
    if this is the case, we ignore it

Arguments:

    PhysicalDeviceObject  PDO we're performing the test for
    ConflictDeviceObject  The object we've determined is conflicting

Return Value:

    TRUE to eliminate the conflict

--*/
{
    PDEVICE_NODE deviceNode;
    PDRIVER_OBJECT driverObject;
    KIRQL           irql;
    PDEVICE_OBJECT  attachedDevice;

    //
    // simple cases
    //
    if (PhysicalDeviceObject == NULL || ConflictDeviceObject == NULL) {
        return FALSE;
    }
    //
    // if ConflictDeviceObject is on PDO's stack, this is a non-conflict
    // nb at least PDO has to be checked
    //
    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (attachedDevice = PhysicalDeviceObject;
         attachedDevice;
         attachedDevice = attachedDevice->AttachedDevice) {

        if (attachedDevice == ConflictDeviceObject) {
            KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
            return TRUE;
        }
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    //
    // legacy case
    //
    deviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    ASSERT(deviceNode);
    if (deviceNode->Flags & DNF_LEGACY_DRIVER) {
        //
        // hmmm, let's see if our ConflictDeviceObject is resources associated with a legacy device
        //
        if (ConflictDeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) {
            //
            // if not, we have a legacy conflicting with non-legacy, we're interested!
            //
            return FALSE;
        }
        //
        // FDO, report driver name
        //
        driverObject = ConflictDeviceObject->DriverObject;
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            return FALSE;
        }
        //
        // compare deviceNode->Service with driverObject->Service
        //
        if (deviceNode->ServiceName.Length != 0 &&
            deviceNode->ServiceName.Length == driverObject->DriverExtension->ServiceKeyName.Length &&
            RtlCompareUnicodeString(&deviceNode->ServiceName,&driverObject->DriverExtension->ServiceKeyName,TRUE)==0) {
            //
            // the driver's service name is the same that this PDO is associated with
            // by ignoring it we could end up ignoring conflicts of simular types of legacy devices
            // but since these have to be hand-config'd anyhow, it's prob better than having false conflicts
            //
            return TRUE;
        }

    }
    return FALSE;
}


NTSTATUS
IopQueryConflictFillString(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PWSTR            Buffer,
    IN OUT PULONG       Length,
    IN OUT PULONG       Flags
    )
/*++

Routine Description:

    Obtain string or string-length for details of conflicting device

Arguments:

    DeviceObject        Device object we want Device-Instance-String or Service Name
    Buffer              Buffer to Fill, NULL if we just want length
    Length              Filled with length of Buffer, including terminated NULL (Words)
    Flags               Apropriate flags set describing what the string represents

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode;
    PDRIVER_OBJECT driverObject;
    PUNICODE_STRING infoString = NULL;
    ULONG MaxLength = 0;        // words
    ULONG ReqLength = 0;        // words
    ULONG flags = 0;

    PAGED_CODE();

    if (Length != NULL) {
        MaxLength = *Length;
    }

    if (Flags != NULL) {
        flags = *Flags;
    }

    if (DeviceObject == NULL) {
        //
        // unknown
        //
        goto final;

    }

    if ((DeviceObject->Flags & DO_BUS_ENUMERATED_DEVICE) == 0 ) {
        //
        // FDO, report driver name
        //
        driverObject = DeviceObject->DriverObject;
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            goto final;
        }
        infoString = & (driverObject->DriverName);
        flags |= PNP_CE_LEGACY_DRIVER;
        goto final;
    }

    //
    // we should in actual fact have a PDO
    //
    if (DeviceObject->DeviceObjectExtension == NULL) {
        //
        // should not be NULL
        //
        ASSERT(DeviceObject->DeviceObjectExtension);
        goto final;
    }

    deviceNode = PP_DO_TO_DN(DeviceObject);
    if (deviceNode == NULL) {
        //
        // should not be NULL
        //
        ASSERT(deviceNode);
        goto final;
    }

    if (deviceNode == IopRootDeviceNode) {
        //
        // owned by root device
        //
        flags |= PNP_CE_ROOT_OWNED;

    } else if (deviceNode -> Parent == NULL) {
        //
        // faked out PDO - must be legacy device
        //
        driverObject = (PDRIVER_OBJECT)(deviceNode->DuplicatePDO);
        if(driverObject == NULL) {
            //
            // should not be NULL
            //
            ASSERT(driverObject);
            goto final;
        }
        infoString = & (driverObject->DriverName);
        flags |= PNP_CE_LEGACY_DRIVER;
        goto final;
    }

    //
    // we should be happy with what we have
    //
    infoString = &deviceNode->InstancePath;

final:

    if (infoString != NULL) {
        //
        // we have a string to copy
        //
        if ((Buffer != NULL) && (MaxLength*sizeof(WCHAR) > infoString->Length)) {
            RtlCopyMemory(Buffer, infoString->Buffer, infoString->Length);
        }
        ReqLength += infoString->Length / sizeof(WCHAR);
    }

    if ((Buffer != NULL) && (MaxLength > ReqLength)) {
        Buffer[ReqLength] = 0;
    }

    ReqLength++;

    if (Length != NULL) {
        *Length = ReqLength;
    }
    if (Flags != NULL) {
        *Flags = flags;
    }

    return status;
}


NTSTATUS
IopQueryConflictFillConflicts(
    PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN ULONG                        ConflictCount,
    IN PARBITER_CONFLICT_INFO       ConflictInfoList,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG                        ConflictListSize,
    IN ULONG                        Flags
    )
/*++

Routine Description:

    Fill ConflictList with information on as many conflicts as possible

Arguments:

    PhysicalDeviceObject The PDO we're performing the test on
    ConflictCount       Number of Conflicts.
    ConflictInfoList    List of conflicting device info, can be NULL if ConflictCount is 0
    ConflictList        Structure to fill in with conflicts
    ConflictListSize    Size of Conflict List
    Flags               if non-zero, dummy conflict is created

Return Value:

    Should be success in most cases

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ConflictListIdealSize;
    ULONG ConflictListCount;
    ULONG Index;
    ULONG ConflictIndex;
    ULONG EntrySize;
    ULONG ConflictStringsOffset;
    ULONG stringSize;
    ULONG stringTotalSize;
    ULONG DummyCount;
    PPLUGPLAY_CONTROL_CONFLICT_STRINGS ConfStrings;

    PAGED_CODE();

    //
    // determine how many conflicts we can
    //
    // for each conflict
    // translate to bus/resource/address in respect to conflicting device
    // add to conflict list
    //
    //

    //
    // preprocessing - given our ConflictInfoList and ConflictCount
    // remove any that appear to be bogus - ie, that are the same device that we are testing against
    // this stops mostly legacy issues
    //
    for(Index = 0;Index < ConflictCount; Index++) {
        if (IopEliminateBogusConflict(PhysicalDeviceObject,ConflictInfoList[Index].OwningObject)) {

            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                " %08x conflicting with self (%08x)\n",
                ConflictInfoList[Index].OwningObject,
                PhysicalDeviceObject));
            //
            // move the last listed conflict into this space
            //
            if (Index+1 < ConflictCount) {
                RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
            }
            //
            // account for deleting this item
            //
            ConflictCount--;
            Index--;
        }
    }

    //
    // preprocessing - in our conflict list, we may have PDO's for legacy devices, and resource nodes for the same
    // or other duplicate entities (we only ever want to report a conflict once, even if there's multiple conflicting ranges)
    //

  RestartScan:

    for(Index = 0;Index < ConflictCount; Index++) {
        if (ConflictInfoList[Index].OwningObject != NULL) {

            ULONG Index2;

            for (Index2 = Index+1; Index2 < ConflictCount; Index2++) {
                if (IopEliminateBogusConflict(ConflictInfoList[Index].OwningObject,ConflictInfoList[Index2].OwningObject)) {
                    //
                    // Index2 is considered a dup of Index
                    //

                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                        " %08x conflicting with PDO %08x\n",
                        ConflictInfoList[Index2].OwningObject,
                        ConflictInfoList[Index].OwningObject));
                    //
                    // move the last listed conflict into this space
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    Index2--;
                } else if (IopEliminateBogusConflict(ConflictInfoList[Index2].OwningObject,ConflictInfoList[Index].OwningObject)) {
                    //
                    // Index is considered a dup of Index2 (some legacy case)
                    //
                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating \"identical\" PDO"
                        " %08x conflicting with PDO %08x\n",
                        ConflictInfoList[Index2].OwningObject,
                        ConflictInfoList[Index].OwningObject));
                    //
                    // move the one we want (Index2) into the space occupied by Index
                    //
                    RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[Index2],sizeof(ARBITER_CONFLICT_INFO));
                    //
                    // move the last listed conflict into the space we just created
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    //
                    // but as this is quirky, restart the scan
                    //
                    goto RestartScan;
                }
            }
        }
    }

    //
    // preprocessing - if we have any known reported conflicts, don't report back any unknown
    //

    for(Index = 0;Index < ConflictCount; Index++) {
        //
        // find first unknown
        //
        if (ConflictInfoList[Index].OwningObject == NULL) {
            //
            // eliminate all other unknowns
            //

            ULONG Index2;

            for (Index2 = Index+1; Index2 < ConflictCount; Index2++) {
                if (ConflictInfoList[Index2].OwningObject == NULL) {

                    IopDbgPrint((
                        IOP_RESOURCE_VERBOSE_LEVEL,
                        "IopQueryConflictFillConflicts: eliminating extra"
                        " unknown\n"));
                    //
                    // move the last listed conflict into this space
                    //
                    if (Index2+1 < ConflictCount) {
                        RtlCopyMemory(&ConflictInfoList[Index2],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                    }
                    //
                    // account for deleting this item
                    //
                    ConflictCount--;
                    Index2--;
                }
            }

            if(ConflictCount != 1) {

                IopDbgPrint((
                    IOP_RESOURCE_VERBOSE_LEVEL,
                    "IopQueryConflictFillConflicts: eliminating first unknown\n"
                    ));
                //
                // there were others, so ignore the unknown
                //
                if (Index+1 < ConflictCount) {
                    RtlCopyMemory(&ConflictInfoList[Index],&ConflictInfoList[ConflictCount-1],sizeof(ARBITER_CONFLICT_INFO));
                }
                ConflictCount --;
            }

            break;
        }
    }

    //
    // set number of actual and listed conflicts
    //

    ConflictListIdealSize = (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) - sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY)) + sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS);
    ConflictListCount = 0;
    stringTotalSize = 0;
    DummyCount = 0;

    ASSERT(ConflictListSize >= ConflictListIdealSize); // we should have checked to see if buffer is at least this big

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Detected %d conflicts\n",
        ConflictCount));

    //
    // estimate sizes
    //
    if (Flags) {
        //
        // flags entry required (ie resource not available for some specified reason)
        //
        stringSize = 1; // null-length string
        DummyCount ++;
        EntrySize = sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY);
        EntrySize += sizeof(WCHAR) * stringSize;

        if((ConflictListIdealSize+EntrySize) <= ConflictListSize) {
            //
            // we can fit this one in
            //
            ConflictListCount++;
            stringTotalSize += stringSize;
        }
        ConflictListIdealSize += EntrySize;
    }
    //
    // report conflicts
    //
    for(Index = 0; Index < ConflictCount; Index ++) {

        stringSize = 0;
        IopQueryConflictFillString(ConflictInfoList[Index].OwningObject,NULL,&stringSize,NULL);

        //
        // account for entry
        //
        EntrySize = sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY);
        EntrySize += sizeof(WCHAR) * stringSize;

        if((ConflictListIdealSize+EntrySize) <= ConflictListSize) {
            //
            // we can fit this one in
            //
            ConflictListCount++;
            stringTotalSize += stringSize;
        }
        ConflictListIdealSize += EntrySize;
    }

    ConflictList->ConflictsCounted = ConflictCount+DummyCount; // number of conflicts detected including any dummy conflict
    ConflictList->ConflictsListed = ConflictListCount;         // how many we could fit in
    ConflictList->RequiredBufferSize = ConflictListIdealSize;  // how much buffer space to supply on next call

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Listing %d conflicts\n",
        ConflictListCount));
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopQueryConflictFillConflicts: Need %08x bytes to list all conflicts\n",
        ConflictListIdealSize));

    ConfStrings = (PPLUGPLAY_CONTROL_CONFLICT_STRINGS)&(ConflictList->ConflictEntry[ConflictListCount]);
    ConfStrings->NullDeviceInstance = (ULONG)(-1);
    ConflictStringsOffset = 0;

    for(ConflictIndex = 0; ConflictIndex < DummyCount; ConflictIndex++) {
        //
        // flags entry required (ie resource not available for some specified reason)
        //
        if (Flags && ConflictIndex == 0) {
            ConflictList->ConflictEntry[ConflictIndex].DeviceInstance = ConflictStringsOffset;
            ConflictList->ConflictEntry[ConflictIndex].DeviceFlags = Flags;
            ConflictList->ConflictEntry[ConflictIndex].ResourceType = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceStart = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceEnd = 0;
            ConflictList->ConflictEntry[ConflictIndex].ResourceFlags = 0;

            ConfStrings->DeviceInstanceStrings[ConflictStringsOffset] = 0; // null string
            stringTotalSize --;
            ConflictStringsOffset ++;
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "IopQueryConflictFillConflicts: Listing flags %08x\n",
                Flags));
        }
    }
    //
    // get/fill in details for all those we can fit into the buffer
    //
    for(Index = 0; ConflictIndex < ConflictListCount ; Index ++, ConflictIndex++) {

        ASSERT(Index < ConflictCount);
        //
        // assign conflict information
        //
        ConflictList->ConflictEntry[ConflictIndex].DeviceInstance = ConflictStringsOffset;
        ConflictList->ConflictEntry[ConflictIndex].DeviceFlags = 0;
        ConflictList->ConflictEntry[ConflictIndex].ResourceType = 0; // NYI
        ConflictList->ConflictEntry[ConflictIndex].ResourceStart = (ULONGLONG)(1); // for now, return totally invalid range (1-0)
        ConflictList->ConflictEntry[ConflictIndex].ResourceEnd = 0;
        ConflictList->ConflictEntry[ConflictIndex].ResourceFlags = 0;

        //
        // fill string details
        //
        stringSize = stringTotalSize;
        IopQueryConflictFillString(ConflictInfoList[Index].OwningObject,
                                    &(ConfStrings->DeviceInstanceStrings[ConflictStringsOffset]),
                                    &stringSize,
                                    &(ConflictList->ConflictEntry[ConflictIndex].DeviceFlags));
        stringTotalSize -= stringSize;
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IopQueryConflictFillConflicts: Listing \"%S\"\n",
            &(ConfStrings->DeviceInstanceStrings[ConflictStringsOffset])));
        ConflictStringsOffset += stringSize;
    }

    //
    // another NULL at end of strings (this is accounted for in the PPLUGPLAY_CONTROL_CONFLICT_STRINGS structure)
    //
    ConfStrings->DeviceInstanceStrings[ConflictStringsOffset] = 0;

    //Clean0:
    ;
    return status;
}


NTSTATUS
IopQueryConflictListInternal(
    PDEVICE_OBJECT        PhysicalDeviceObject,
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize,
    OUT PPLUGPLAY_CONTROL_CONFLICT_LIST ConflictList,
    IN ULONG              ConflictListSize,
    IN ULONG              Flags
    )
/*++

Routine Description:

    Version of IopQueryConflictList without the locking

--*/
{

    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_NODE deviceNode = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST ioResources;
    PREQ_LIST reqList;
    PREQ_DESC reqDesc, reqDescTranslated;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;
    PREQ_ALTERNATIVE RA;
    PPREQ_ALTERNATIVE reqAlternative;
    ULONG ConflictCount = 0;
    PARBITER_CONFLICT_INFO ConflictInfoList = NULL;
    PIO_RESOURCE_DESCRIPTOR ConflictDesc = NULL;
    ULONG ReqDescCount = 0;
    PREQ_DESC *ReqDescTable = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST pIoReqList = NULL;
    PVOID ExtParams[4];
    IOP_RESOURCE_REQUEST request;

    UNREFERENCED_PARAMETER( Flags );

    PAGED_CODE();

    ASSERT(PhysicalDeviceObject);
    ASSERT(ResourceList);
    ASSERT(ResourceListSize);
    //
    // these parameters were generated by umpnpmgr
    // so should be correct - one resource, and one resource only
    //
    ASSERT(ResourceList->Count == 1);
    ASSERT(ResourceList->List[0].PartialResourceList.Count == 1);

    if (ConflictList == NULL || (ConflictListSize < (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) - sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY)) + sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS))) {
        //
        // sanity check
        //
        status = STATUS_BUFFER_TOO_SMALL;
        goto Clean0;
    }
    //
    // whatever other error we return, ensure that ConflictList is interpretable
    //

    ConflictList->ConflictsCounted = 0;
    ConflictList->ConflictsListed = 0;
    ConflictList->RequiredBufferSize = (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) - sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY)) + sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS);

    //
    // Retrieve the devnode from the PDO
    //
    deviceNode = PP_DO_TO_DN(PhysicalDeviceObject);
    if (!deviceNode) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    //
    // type-specific validation
    //
    switch(ResourceList->List[0].PartialResourceList.PartialDescriptors[0].Type) {
        case CmResourceTypePort:
        case CmResourceTypeMemory:
            if(ResourceList->List[0].PartialResourceList.PartialDescriptors[0].u.Generic.Length == 0) {
                //
                // zero-range resource can never conflict
                //
                status = STATUS_SUCCESS;
                goto Clean0;
            }
            break;
        case CmResourceTypeInterrupt:
        case CmResourceTypeDma:
            break;
        default:
            ASSERT(0);
            status = STATUS_INVALID_PARAMETER;
            goto Clean0;
    }

    //
    // apply bus details from node
    //
    if (deviceNode->ChildInterfaceType == InterfaceTypeUndefined) {
        //
        // we have to grovel around to find real Interface Type
        //
        pIoReqList = deviceNode->ResourceRequirements;
        if (pIoReqList != NULL && pIoReqList->InterfaceType != InterfaceTypeUndefined) {
            ResourceList->List[0].InterfaceType = pIoReqList->InterfaceType;
        } else {
            //
            // we should never get here
            // if we do, I need to look at this more
            //
#if MAXDBG
            ASSERT(0);
#endif
            ResourceList->List[0].InterfaceType = PnpDefaultInterfaceType;
        }

    } else {
        //
        // we trust the deviceNode to tell us Interface Type
        //
        ResourceList->List[0].InterfaceType = deviceNode->ChildInterfaceType;
    }
    //
    // Some bus-types we are better off considered as default
    //
    switch(ResourceList->List[0].InterfaceType) {
        case InterfaceTypeUndefined:
        case PCMCIABus:
            ResourceList->List[0].InterfaceType = PnpDefaultInterfaceType;
    }
    if ((deviceNode->ChildBusNumber & 0x80000000) == 0x80000000) {
        //
        // we have to grovel around to find real Bus Number
        //
        pIoReqList = deviceNode->ResourceRequirements;
        if (pIoReqList != NULL && (pIoReqList->BusNumber & 0x80000000) != 0x80000000) {
            ResourceList->List[0].BusNumber = pIoReqList->BusNumber;
        } else {
            //
            // a resonable default, but assert is here so I remember to look at this more
            //
#if MAXDBG
            ASSERT(0);
#endif
            ResourceList->List[0].BusNumber = 0;
        }

    } else {
        //
        // we trust the deviceNode to tell us Bus Number
        //
        ResourceList->List[0].BusNumber = deviceNode->ChildBusNumber;
    }

    //
    // from our CM Resource List, obtain an IO Resource Requirements List
    //
    ioResources = IopCmResourcesToIoResources(0, ResourceList, LCPRI_FORCECONFIG);
    if (!ioResources) {
        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }
    //
    // Convert ioResources to a Request list
    // and in the processess, determine any Arbiters/Translators to use
    //
    request.AllocationType = ArbiterRequestUndefined;
    request.ResourceRequirements = ioResources;
    request.PhysicalDevice = PhysicalDeviceObject;
    status = IopResourceRequirementsListToReqList(
                    &request,
                    &reqList);

    //
    // get arbitrator/translator for current device/bus
    //

    if (NT_SUCCESS(status) && reqList) {

        reqAlternative = reqList->AlternativeTable;
        RA = *reqAlternative;
        reqList->SelectedAlternative = reqAlternative;

        ReqDescCount = RA->DescCount;
        ReqDescTable = RA->DescTable;

        //
        // we should have got only one descriptor, use only the first one
        //
        if (ReqDescCount>0) {

            //
            // get first descriptor & it's arbitor
            //

            reqDesc = *ReqDescTable;
            if (reqDesc->ArbitrationRequired) {
                reqDescTranslated = reqDesc->TranslatedReqDesc;  // Could be reqDesc itself

                arbiterEntry = reqDesc->u.Arbiter;
                ASSERT(arbiterEntry);
                //
                // the descriptor of interest - translated, first alternative in the table
                //
                ConflictDesc = reqDescTranslated->AlternativeTable.Alternatives;
                //
                // skip special descriptor
                // to get to the actual descriptor
                //
                if(ConflictDesc->Type == CmResourceTypeConfigData || ConflictDesc->Type == CmResourceTypeReserved)
                        ConflictDesc++;

                //
                // finally we can call the arbiter to get a conflict list (returning PDO's and Global Address Ranges)
                //
                ExtParams[0] = PhysicalDeviceObject;
                ExtParams[1] = ConflictDesc;
                ExtParams[2] = &ConflictCount;
                ExtParams[3] = &ConflictInfoList;
                status = IopCallArbiter(arbiterEntry, ArbiterActionQueryConflict , ExtParams, NULL , NULL);

                if (NT_SUCCESS(status)) {
                    //
                    // fill in user-memory buffer with conflict
                    //
                    status = IopQueryConflictFillConflicts(PhysicalDeviceObject,ConflictCount,ConflictInfoList,ConflictList,ConflictListSize,0);
                    if(ConflictInfoList != NULL) {
                        ExFreePool(ConflictInfoList);
                    }
                }
                else if(status == STATUS_RANGE_NOT_FOUND) {
                    //
                    // fill in with flag indicating bad range (this means range is not available)
                    // ConflictInfoList should not be allocated
                    //
                    status = IopQueryConflictFillConflicts(NULL,0,NULL,ConflictList,ConflictListSize,PNP_CE_TRANSLATE_FAILED);
                }

            } else {
#if MAXDBG
                ASSERT(0);                         // For now
#endif
                status = STATUS_INVALID_PARAMETER;  // if we failed, it's prob because ResourceList was invalid
            }
        } else {
#if MAXDBG
            ASSERT(0);                         // For now
#endif
            status = STATUS_INVALID_PARAMETER;  // if we failed, it's prob because ResourceList was invalid
        }

        IopCheckDataStructures(IopRootDeviceNode);

        IopFreeReqList(reqList);
    } else {
#if MAXDBG
        ASSERT(0);                         // For now
#endif
        if(NT_SUCCESS(status)) {
            //
            // it was NULL because we had a zero resource count, must be invalid parameter
            //
            status = STATUS_INVALID_PARAMETER;
        }

    }
    ExFreePool(ioResources);

    Clean0:
    ;

    return status;
}

/*++

    SECTION = REBALANCE.

    Description:

        This section contains code that implements functions to performa
        resource rebalance.

--*/

VOID
IopQueryRebalance (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )

/*++

Routine Description:

    This routine walks hardware tree depth first.  For each device node it visits,
    it call IopQueryReconfigureDevice to query-stop device for resource
    reconfiguration.

    Note, Under rebalancing situation, all the participated devices will be asked to
    stop.  Even they support non-stopped rebalancing.

Parameters:

    DeviceNode - supplies a pionter a device node which is the root of the tree to
                 be tested.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT *deviceList, *deviceTable, *device;
    ULONG count;
    PDEVICE_NODE deviceNode;


    //
    // Call worker routine to get a list of devices to be rebalanced.
    //

    deviceTable = *DeviceTable;
    IopQueryRebalanceWorker (DeviceNode, Phase, RebalanceCount, DeviceTable);

    count = *RebalanceCount;
    if (count != 0 && Phase == 0) {

        //
        // At phase 0, we did not actually query-stop the device.
        // We need to do it now.
        //

        deviceList = (PDEVICE_OBJECT *)ExAllocatePoolPDO(PagedPool, count * sizeof(PDEVICE_OBJECT));
        if (deviceList == NULL) {
            *RebalanceCount = 0;
            return;
        }
        RtlCopyMemory(deviceList, deviceTable, sizeof(PDEVICE_OBJECT) * count);

        //
        // Rebuild the returned device list
        //

        *RebalanceCount = 0;
        *DeviceTable = deviceTable;
        for (device = deviceList; device < (deviceList + count); device++) {
            deviceNode = PP_DO_TO_DN(*device);
            IopQueryRebalanceWorker (deviceNode, 1, RebalanceCount, DeviceTable);
        }
        ExFreePool(deviceList);
    }
    return;
}

VOID
IopQueryRebalanceWorker (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )

/*++

Routine Description:

    This routine walks hardware tree depth first.  For each device node it visits,
    it call IopQueryReconfigureDevice to query-stop and stop device for resource
    reconfiguration.

Parameters:

    DeviceNode - supplies a pionter a device node which is the root of the tree to
                 be tested.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    None.

--*/

{
    PDEVICE_NODE node;

    ASSERT(DeviceNode);

    //
    // We dont include following in rebalance
    //  a. non-started devices
    //  b. devices with problem
    //  c. devices with legacy driver
    //
    if (    DeviceNode == NULL ||
            DeviceNode->State != DeviceNodeStarted ||
            PipDoesDevNodeHaveProblem(DeviceNode) ||
            (DeviceNode->Flags & DNF_LEGACY_DRIVER)) {

        return;
    }
    //
    // Recursively test the entire subtree.
    //
    for (node = DeviceNode->Child; node; node = node->Sibling) {

        IopQueryRebalanceWorker(node, Phase, RebalanceCount, DeviceTable);
    }
    //
    // Test the root of the subtree.
    //
    IopTestForReconfiguration(DeviceNode, Phase, RebalanceCount, DeviceTable);
}

VOID
IopTestForReconfiguration (
    IN PDEVICE_NODE DeviceNode,
    IN ULONG Phase,
    IN PULONG RebalanceCount,
    IN PDEVICE_OBJECT **DeviceTable
    )


/*++

Routine Description:

    This routine query-stops a device which is started and owns resources.
    Note the resources for the device are not released at this point.

Parameters:

    DeviceNode - supplies a pointer to the device node to be tested for reconfiguration.

    Phase - Supplies a value to specify the phase of the rebalance.

    RebalanceCount - supplies a pointer to a variable to receive the number of devices
                 participating the rebalance.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PDEVICE_NODE nodex;
    NTSTATUS status;
    BOOLEAN addToList = FALSE;

    if (Phase == 0) {

        //
        // At phase zero, this routine only wants to find out which devices's resource
        // requirements lists chagned.  No one actually gets stopped.
        //

        if ((DeviceNode->Flags & DNF_RESOURCE_REQUIREMENTS_CHANGED) &&
            !(DeviceNode->Flags & DNF_NON_STOPPED_REBALANCE) ) {

            //
            // It's too hard to handle non-stop rebalancing devices during rebalance.
            // So, We will skip it.
            //

            addToList = TRUE;
        } else {

            if (DeviceNode->State == DeviceNodeStarted) {
                status = IopQueryReconfiguration (IRP_MN_QUERY_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
                if (NT_SUCCESS(status)) {
                    if (status == STATUS_RESOURCE_REQUIREMENTS_CHANGED) {

                        //
                        // If we find out a device's resource requirements changed this way,
                        // it will be stopped and reassigned resources even if it supports
                        // non-stopped rebalance.
                        //

                        DeviceNode->Flags |= DNF_RESOURCE_REQUIREMENTS_CHANGED;
                        addToList = TRUE;
                    }
                }
                IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
            }
        }
        if (addToList) {
            *RebalanceCount = *RebalanceCount + 1;
            **DeviceTable = DeviceNode->PhysicalDeviceObject;
            *DeviceTable = *DeviceTable + 1;
        }
    } else {

        //
        // Phase 1
        //

        if (DeviceNode->State == DeviceNodeStarted) {

            //
            // Make sure all the resources required children of the DeviceNode are stopped.
            //

            nodex = DeviceNode->Child;
            while (nodex) {
                if (nodex->State == DeviceNodeUninitialized ||
                    nodex->State == DeviceNodeInitialized ||
                    nodex->State == DeviceNodeDriversAdded ||
                    nodex->State == DeviceNodeQueryStopped ||
                    nodex->State == DeviceNodeRemovePendingCloses ||
                    nodex->State == DeviceNodeRemoved ||
                    (nodex->Flags & DNF_NEEDS_REBALANCE)) {
                    nodex = nodex->Sibling;
                } else {
                    break;
                }
            }

            if (nodex) {

                //
                // If any resource required child of the DeviceNode is not stopped,
                // we won't ask the DeviceNode to stop.
                //

                IopDbgPrint((
                    IOP_RESOURCE_INFO_LEVEL,
                    "Rebalance: Child %ws not stopped for %ws\n",
                    nodex->InstancePath.Buffer,
                    DeviceNode->InstancePath.Buffer));
                return;
            }
        } else if (DeviceNode->State != DeviceNodeDriversAdded ||
                   !(DeviceNode->Flags & DNF_HAS_BOOT_CONFIG) ||
                    (DeviceNode->Flags & DNF_MADEUP)) {

            //
            // The device is not started and has no boot config.  There is no need to query-stop it.
            // Or if the device has BOOT config but there is no driver installed for it.  We don't query
            // stop it. (There may be legacy drivers are using the resources.)
            // We also don't want to query stop root enumerated devices (for performance reason.)
            //

            return;
        }

        status = IopQueryReconfiguration (IRP_MN_QUERY_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
        if (NT_SUCCESS(status)) {
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Rebalance: %ws succeeded QueryStop\n",
                DeviceNode->InstancePath.Buffer));

            if (DeviceNode->State == DeviceNodeStarted) {

                PipSetDevNodeState(DeviceNode, DeviceNodeQueryStopped, NULL);

                *RebalanceCount = *RebalanceCount + 1;
                **DeviceTable = DeviceNode->PhysicalDeviceObject;

                //
                // Add a reference to the device object such that it won't disapear during rebalance.
                //

                ObReferenceObject(DeviceNode->PhysicalDeviceObject);
                *DeviceTable = *DeviceTable + 1;
            } else {

                //
                // We need to release the device's prealloc boot config.  This device will NOT
                // participate in resource rebalancing.
                //

                ASSERT(DeviceNode->Flags & DNF_HAS_BOOT_CONFIG);
                status = IopQueryReconfiguration (IRP_MN_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
                ASSERT(NT_SUCCESS(status));
                IopReleaseBootResources(DeviceNode);

                //
                // Reset BOOT CONFIG flags.
                //

                DeviceNode->Flags &= ~(DNF_HAS_BOOT_CONFIG + DNF_BOOT_CONFIG_RESERVED);
            }
        } else {
            IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, DeviceNode->PhysicalDeviceObject);
        }
    }

}

NTSTATUS
IopRebalance(
    IN ULONG AssignTableCount,
    IN PIOP_RESOURCE_REQUEST AssignTable
    )
/*++

Routine Description:

    This routine performs rebalancing operation.  There are two rebalance phases:
    In the phase 0, we only consider the devices whoes resource requirements changed
    and their children; in phase 1, we consider anyone who succeeds the query-stop.

Parameters:

    AssignTableCount,
    AssignTable - Supplies the number of origianl AssignTableCout and AssignTable which
                  triggers the rebalance operation.

        (if AssignTableCount == 0, we are processing device state change.)

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    ULONG i;
    PIOP_RESOURCE_REQUEST table = NULL, tableEnd, newEntry;
    PIOP_RESOURCE_REQUEST requestTable = NULL, requestTableEnd, entry1, entry2;
    ULONG phase0RebalanceCount = 0, rebalanceCount = 0, deviceCount;
    NTSTATUS status;
    PDEVICE_OBJECT *deviceTable, *deviceTablex;
    PDEVICE_NODE deviceNode;
    ULONG rebalancePhase = 0;
    LIST_ENTRY  activeArbiterList;

    //
    // Query all the device nodes to see who are willing to participate the rebalance
    // process.
    //

    deviceTable = (PDEVICE_OBJECT *) ExAllocatePoolPDO(
                      PagedPool,
                      sizeof(PDEVICE_OBJECT) * IopNumberDeviceNodes);
    if (deviceTable == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


tryAgain:
    deviceTablex = deviceTable + phase0RebalanceCount;

    //
    // Walk device node tree depth-first to query-stop and stop devices.
    // At this point the resources of the stopped devices are not released yet.
    // Also, the leaf nodes are in the front of the device table and non leaf nodes
    // are at the end of the table.
    //

    IopQueryRebalance (IopRootDeviceNode, rebalancePhase, &rebalanceCount, &deviceTablex);
    if (rebalanceCount == 0) {

        //
        // If no one is interested and we are not processing resources req change,
        // move to next phase.
        //

        if (rebalancePhase == 0 && AssignTableCount != 0) {
            rebalancePhase = 1;
            goto tryAgain;
        }
        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "Rebalance: No device participates in rebalance phase %x\n",
            rebalancePhase));
        ExFreePool(deviceTable);
        deviceTable = NULL;
        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    if (rebalanceCount == phase0RebalanceCount) {

        //
        // Phase 0 failed and no new device participates. failed the rebalance.
        //

        status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    if (rebalancePhase == 0) {
        phase0RebalanceCount = rebalanceCount;
    }

    //
    // Allocate pool for the new reconfiguration requests and the original requests.
    //

    table = (PIOP_RESOURCE_REQUEST) ExAllocatePoolIORR(
                 PagedPool,
                 sizeof(IOP_RESOURCE_REQUEST) * (AssignTableCount + rebalanceCount)
                 );
    if (table == NULL) {
        IopDbgPrint((
            IOP_RESOURCE_WARNING_LEVEL,
            "Rebalance: Not enough memory to perform rebalance\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto exit;
    }
    tableEnd = table + AssignTableCount + rebalanceCount;

    //
    // Build a new resource request table.  The original requests will be at the beginning
    // of the table and new requests (reconfigured devices) are at the end.
    // After the new request table is built, the leaf nodes will be in front of the table,
    // and non leaf nodes will be close to the end of the table.  This is for optimization.
    //

    //
    // Copy the original request to the front of our new request table.
    //

    if (AssignTableCount != 0) {
        RtlCopyMemory(table, AssignTable, sizeof(IOP_RESOURCE_REQUEST) * AssignTableCount);
    }

    //
    // Initialize all the new entries of our new request table,
    //

    newEntry = table + AssignTableCount;
    RtlZeroMemory(newEntry, sizeof(IOP_RESOURCE_REQUEST) * rebalanceCount);
    for (i = 0, deviceTablex = deviceTable; i < rebalanceCount; i++, deviceTablex++) {
        newEntry[i].AllocationType = ArbiterRequestPnpEnumerated;
        newEntry[i].PhysicalDevice = *deviceTablex;
    }

    status = IopGetResourceRequirementsForAssignTable(
                 newEntry,
                 tableEnd ,
                 &deviceCount);
    if (deviceCount == 0) {
         IopDbgPrint((
             IOP_RESOURCE_WARNING_LEVEL,
             "Rebalance: GetResourceRequirementsForAssignTable failed\n"));
         goto exit;
    }

    //
    // Process the AssignTable to remove any entry which is marked as IOP_ASSIGN_IGNORE
    //

    if (deviceCount != rebalanceCount) {

        deviceCount += AssignTableCount;
        requestTable = (PIOP_RESOURCE_REQUEST) ExAllocatePoolIORR(
                             PagedPool,
                             sizeof(IOP_RESOURCE_REQUEST) * deviceCount
                             );
        if (requestTable == NULL) {
            IopFreeResourceRequirementsForAssignTable(newEntry, tableEnd);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;
        }
        for (entry1 = table, entry2 = requestTable; entry1 < tableEnd; entry1++) {

            if (!(entry1->Flags & IOP_ASSIGN_IGNORE)) {

                *entry2 = *entry1;
                entry2++;
            } else {

                ASSERT(entry1 >= newEntry);
            }
        }
        requestTableEnd = requestTable + deviceCount;
    } else {
        requestTable = table;
        requestTableEnd = tableEnd;
        deviceCount += AssignTableCount;
    }

    //
    // DO NOT Sort the AssignTable
    //

    //IopRearrangeAssignTable(requestTable, deviceCount);

#if 0

    //
    // We are about to perform rebalance.  Release the resources of the reconfiguration devices
    //

    for (entry1 = newEntry; entry1 < tableEnd; entry1++) {
        if (!(entry1->Flags & IOP_ASSIGN_IGNORE) &&
            !(entry1->Flags & IOP_ASSIGN_RESOURCES_RELEASED)) {
            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);
            if (deviceNode->ResourceList) {

                //
                // Call IopReleaseResourcesInternal instead of IopReleaseResources such that
                // the pool for devicenode->ResourceList is not freed.  We need it to restart
                // the reconfigured devices in case rebalance failed.
                //

                IopReleaseResourcesInternal(deviceNode);
                entry1->Flags |= IOP_ASSIGN_RESOURCES_RELEASED;
            }
        }
    }

#endif

    //
    // Assign the resources. If we succeed, or if
    // there is a memory shortage return immediately.
    //

    status = IopFindBestConfiguration(
                requestTable,
                deviceCount,
                &activeArbiterList);
    if (NT_SUCCESS(status)) {
        //
        // If the rebalance succeeded, we need to restart all the reconfigured devices.
        // For the original devices, we will return and let IopAllocateResources to deal
        // with them.
        //

        IopBuildCmResourceLists(requestTable, requestTableEnd);

        //
        // Copy the new status back to the original AssignTable.
        //

        if (AssignTableCount != 0) {
            RtlCopyMemory(AssignTable, requestTable, sizeof(IOP_RESOURCE_REQUEST) * AssignTableCount);
        }
        //
        // free resource requirements we allocated while here
        //
        IopFreeResourceRequirementsForAssignTable(requestTable+AssignTableCount, requestTableEnd);

        if (table != requestTable) {

            //
            // If we switched request table ... copy the contents of new table back to
            // the old table.
            //

            for (entry1 = table, entry2 = requestTable; entry2 < requestTableEnd;) {

                if (entry1->Flags & IOP_ASSIGN_IGNORE) {
                    entry1++;
                    continue;
                }
                *entry1 = *entry2;
                if (entry2->Flags & IOP_ASSIGN_EXCLUDE) {
                    entry1->Status = STATUS_CONFLICTING_ADDRESSES;
                }
                entry2++;
                entry1++;
            }
        }
        //
        // Go thru the origianl request table to stop each query-stopped/reconfigured device.
        //
        for (entry1 = newEntry; entry1 < tableEnd; entry1++) {

            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);
            if (NT_SUCCESS(entry1->Status)) {

                IopDbgPrint((
                    IOP_RESOURCE_INFO_LEVEL,
                    "STOPPING %wZ during REBALANCE\n",
                    &deviceNode->InstancePath));
                IopQueryReconfiguration(
                    IRP_MN_STOP_DEVICE,
                    entry1->PhysicalDevice);

                PipSetDevNodeState(deviceNode, DeviceNodeStopped, NULL);
            } else {

                IopQueryReconfiguration(
                    IRP_MN_CANCEL_STOP_DEVICE,
                    entry1->PhysicalDevice);

                PipRestoreDevNodeState(deviceNode);
            }
        }

        //
        // Ask the arbiters to commit this configuration.
        //
        status = IopCommitConfiguration(&activeArbiterList);
        //
        // Go thru the origianl request table to start each stopped/reconfigured device.
        //

        for (entry1 = tableEnd - 1; entry1 >= newEntry; entry1--) {
            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);

            if (NT_SUCCESS(entry1->Status)) {

                //
                // We need to release the pool space for ResourceList and ResourceListTranslated.
                // Because the earlier IopReleaseResourcesInternal does not release the pool.
                //

                if (deviceNode->ResourceList) {
                    ExFreePool(deviceNode->ResourceList);
                }
                deviceNode->ResourceList = entry1->ResourceAssignment;
                if (deviceNode->ResourceListTranslated) {
                    ExFreePool(deviceNode->ResourceListTranslated);
                }
                deviceNode->ResourceListTranslated = entry1->TranslatedResourceAssignment;
                if (deviceNode->ResourceList == NULL) {
                    deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                }
                if (entry1->Flags & IOP_ASSIGN_CLEAR_RESOURCE_REQUIREMENTS_CHANGE_FLAG) {

                    //
                    // If we are processing the resource requirements change request,
                    // clear its related flags.
                    //

                    deviceNode->Flags &= ~(DNF_RESOURCE_REQUIREMENTS_CHANGED | DNF_NON_STOPPED_REBALANCE);
                }
            }
        }
        status = STATUS_SUCCESS;
    } else {

        //
        // Rebalance failed. Free our internal representation of the rebalance
        // candidates' resource requirements lists.
        //

        IopFreeResourceRequirementsForAssignTable(requestTable + AssignTableCount, requestTableEnd);
        if (rebalancePhase == 0) {
            rebalancePhase++;
            if (requestTable) {
                ExFreePool(requestTable);
            }
            if (table && (table != requestTable)) {
                ExFreePool(table);
            }
            table = requestTable = NULL;
            goto tryAgain;
        }

        for (entry1 = newEntry; entry1 < tableEnd; entry1++) {

            IopQueryReconfiguration (
                IRP_MN_CANCEL_STOP_DEVICE,
                entry1->PhysicalDevice);
            deviceNode = PP_DO_TO_DN(entry1->PhysicalDevice);

            PipRestoreDevNodeState(deviceNode);
        }
    }
    //
    // Finally release the references of the reconfigured device objects
    //
    for (deviceTablex = (deviceTable + rebalanceCount - 1);
         deviceTablex >= deviceTable;
         deviceTablex--) {
         ObDereferenceObject(*deviceTablex);
    }
    ExFreePool(deviceTable);
    deviceTable = NULL;

exit:

    if (!NT_SUCCESS(status) && deviceTable) {

        //
        // If we failed before trying to perform resource assignment,
        // we will end up here.
        //

        IopDbgPrint((
            IOP_RESOURCE_INFO_LEVEL,
            "Rebalance: Rebalance failed\n"));

        //
        // Somehow we failed to start the rebalance operation.
        // We will cancel the query-stop request for the query-stopped devices bredth first.
        //

        for (deviceTablex = (deviceTable + rebalanceCount - 1);
             deviceTablex >= deviceTable;
             deviceTablex--) {

             deviceNode = PP_DO_TO_DN(*deviceTablex);
             IopQueryReconfiguration (IRP_MN_CANCEL_STOP_DEVICE, *deviceTablex);
             PipRestoreDevNodeState(deviceNode);
             ObDereferenceObject(*deviceTablex);
        }
    }
    if (deviceTable) {
        ExFreePool(deviceTable);
    }
    if (requestTable) {
        ExFreePool(requestTable);
    }
    if (table && (table != requestTable)) {
        ExFreePool(table);
    }
    return status;
}

/*++

    SECTION = OUTER ARBITRATION LOOP.

    Description:

        This section contains code that implements functions to call arbiters
        and come up with the best possible configuration.
--*/

NTSTATUS
IopTestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for TestAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{

    NTSTATUS                    status;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    for (   listEntry = ArbiterList->Flink;
            listEntry != ArbiterList;
            listEntry = listEntry->Flink) {

        arbiterEntry = CONTAINING_RECORD(
                            listEntry,
                            PI_RESOURCE_ARBITER_ENTRY,
                            ActiveArbiterList);
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        if (arbiterEntry->ResourcesChanged == FALSE) {

            if (arbiterEntry->State & PI_ARBITER_TEST_FAILED) {
                //
                // If the resource requirements are the same and
                // it failed before, return failure.
                //
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        } else {

            arbiterInterface = arbiterEntry->ArbiterInterface;
            //
            // Call the arbiter to test the new configuration.
            //
            p.Parameters.TestAllocation.ArbitrationList     =
                                                    &arbiterEntry->ResourceList;
            p.Parameters.TestAllocation.AllocateFromCount   = 0;
            p.Parameters.TestAllocation.AllocateFrom        = NULL;
            status = arbiterInterface->ArbiterHandler(
                                            arbiterInterface->Context,
                                            ArbiterActionTestAllocation,
                                            &p);
            if (NT_SUCCESS(status)) {

                arbiterEntry->State &= ~PI_ARBITER_TEST_FAILED;
                arbiterEntry->State |= PI_ARBITER_HAS_SOMETHING;
                arbiterEntry->ResourcesChanged = FALSE;
            } else {
                //
                // This configuration does not work
                // (no need to try other arbiters).
                //
                arbiterEntry->State |= PI_ARBITER_TEST_FAILED;
                break;
            }
        }
    }

    return status;
}

NTSTATUS
IopRetestConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for RetestAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{
    NTSTATUS                    retestStatus;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    retestStatus = STATUS_UNSUCCESSFUL;
    listEntry    = ArbiterList->Flink;
    while (listEntry != ArbiterList) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        if (arbiterEntry->ResourcesChanged == FALSE) {

            continue;
        }
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        arbiterInterface = arbiterEntry->ArbiterInterface;
        //
        // Call the arbiter to retest the configuration.
        //
        p.Parameters.RetestAllocation.ArbitrationList     =
                                                    &arbiterEntry->ResourceList;
        p.Parameters.RetestAllocation.AllocateFromCount   = 0;
        p.Parameters.RetestAllocation.AllocateFrom        = NULL;
        retestStatus = arbiterInterface->ArbiterHandler(
                                            arbiterInterface->Context,
                                            ArbiterActionRetestAllocation,
                                            &p);
        if (!NT_SUCCESS(retestStatus)) {

            break;
        }
    }

    ASSERT(NT_SUCCESS(retestStatus));

    return retestStatus;
}

NTSTATUS
IopCommitConfiguration (
    IN OUT  PLIST_ENTRY ArbiterList
    )

/*++

Routine Description:

    This routine calls the arbiters in the specified list for CommitAllocation.

Parameters:

    ArbiterList - Head of list of arbiters to be called.

Return Value:

    STATUS_SUCCESS if all arbiters succeed, else first failure code.

--*/

{
    NTSTATUS                    commitStatus;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PARBITER_INTERFACE          arbiterInterface;

    PAGED_CODE();

    commitStatus = STATUS_SUCCESS;
    listEntry    = ArbiterList->Flink;
    while (listEntry != ArbiterList) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        arbiterInterface = arbiterEntry->ArbiterInterface;
        //
        // Call the arbiter to commit the configuration.
        //
        commitStatus = arbiterInterface->ArbiterHandler(
                            arbiterInterface->Context,
                            ArbiterActionCommitAllocation,
                            NULL);
        IopInitializeArbiterEntryState(arbiterEntry);
        if (!NT_SUCCESS(commitStatus)) {

            break;
        }
    }

    ASSERT(NT_SUCCESS(commitStatus));

    IopCheckDataStructures(IopRootDeviceNode);
    return commitStatus;
}

VOID
IopSelectFirstConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    )

/*++

Routine Description:

    This routine selects the first possible configuration and adds the
    descriptors to their corresponding arbiter lists. The arbiters used are
    linked into the list of active arbiters.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
        first selected configuration.

Return Value:

    None.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // For each entry in the request table, set the first configuration
    // as the selected configuration.
    // Update the arbiters with all the descriptors in the selected
    // configuration.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList                         = RequestTable[tableIndex].ReqList;
        reqList->SelectedAlternative    = &reqList->AlternativeTable[0];
        reqAlternative                  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            ActiveArbiterList,
            TRUE);
    }
}

BOOLEAN
IopSelectNextConfiguration (
    IN      PIOP_RESOURCE_REQUEST    RequestTable,
    IN      ULONG                    RequestTableCount,
    IN OUT  PLIST_ENTRY              ActiveArbiterList
    )

/*++

Routine Description:

    This routine selects the next possible configuration and adds the
    descriptors to their corresponding arbiter lists. The arbiters used are
    linked into the list of active arbiters.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
        currently selected configuration.

Return Value:

    FALSE if this the currently selected configuration is the last possible,
    else TRUE.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // Remove all the descriptors from the currently selected alternative
    // for the first entry in the request table.
    // Update the selected configuration to the next possible.
    // Reset the selected configuration to the first possible one if
    // all configurations have been tried and go to the next entry
    // in the request table.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            NULL,
            FALSE);
        if (++reqList->SelectedAlternative < reqList->BestAlternative) {

            break;
        }
        reqList->SelectedAlternative = &reqList->AlternativeTable[0];
    }
    //
    // We are done if there is no next possible configuration.
    //
    if (tableIndex == RequestTableCount) {

        return FALSE;
    }
    //
    // For each entry in the request table, add all the descriptors in
    // the currently selected alternative.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            ActiveArbiterList,
            TRUE);
        if (reqList->SelectedAlternative != &reqList->AlternativeTable[0]) {

            break;
        }
    }

    return TRUE;
}

VOID
IopCleanupSelectedConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    )

/*++

Routine Description:

    This routine removes the descriptors from their corresponding arbiter
    lists.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    None.

--*/

{
    ULONG               tableIndex;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // For each entry in the request table, remove all the descriptors
    // from the currently selected alternative.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        IopAddRemoveReqDescs(
            reqAlternative->DescTable,
            reqAlternative->DescCount,
            NULL,
            FALSE);
    }
}

ULONG
IopComputeConfigurationPriority (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount
    )

/*++

Routine Description:

    This routine computes the overall priority of the set of selected
    configurations for all requests in the request table.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    Computed priority for this configuration.

--*/

{
    ULONG               tableIndex;
    ULONG               priority;
    PREQ_ALTERNATIVE    reqAlternative;
    PREQ_LIST           reqList;

    PAGED_CODE();
    //
    // Compute the current configurations overall priority
    // as the sum of the priorities of currently selected
    // configuration in the request table.
    //
    priority = 0;
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList         = RequestTable[tableIndex].ReqList;
        reqAlternative  = *(reqList->SelectedAlternative);
        priority        += reqAlternative->Priority;
    }

    return priority;
}

VOID
IopSaveRestoreConfiguration (
    IN      PIOP_RESOURCE_REQUEST   RequestTable,
    IN      ULONG                   RequestTableCount,
    IN OUT  PLIST_ENTRY             ArbiterList,
    IN      BOOLEAN                 Save
    )

/*++

Routine Description:

    This routine saves\restores the currently selected configuration.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ArbiterList         - Head of list which contains arbiters used for the
                          currently selected configuration.

    Save                - Specifies if the configuration is to be saved or
                          restored.

Return Value:

    None.

--*/

{
    ULONG                       tableIndex;
    PREQ_ALTERNATIVE            reqAlternative;
    PREQ_DESC                   reqDesc;
    PREQ_DESC                   *reqDescpp;
    PREQ_DESC                   *reqDescTableEnd;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PREQ_LIST                   reqList;

    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_TRACE_LEVEL,
        "%s configuration\n",
        (Save)? "Saving" : "Restoring"));
    //
    // For each entry in the request table, save information for
    // following RETEST.
    //
    for (tableIndex = 0; tableIndex < RequestTableCount; tableIndex++) {

        reqList                     = RequestTable[tableIndex].ReqList;
        if (Save) {

            reqList->BestAlternative        = reqList->SelectedAlternative;
        } else {

            reqList->SelectedAlternative    = reqList->BestAlternative;
        }
        reqAlternative              = *(reqList->BestAlternative);
        reqDescTableEnd             = reqAlternative->DescTable +
                                        reqAlternative->DescCount;
        for (   reqDescpp = reqAlternative->DescTable;
                reqDescpp < reqDescTableEnd;
                reqDescpp++) {

            if ((*reqDescpp)->ArbitrationRequired == FALSE) {

                continue;
            }
            //
            // Save\restore information for the descriptor.
            //
            reqDesc = (*reqDescpp)->TranslatedReqDesc;
            if (Save == TRUE) {

                reqDesc->BestAlternativeTable  = reqDesc->AlternativeTable;
                reqDesc->BestAllocation        = reqDesc->Allocation;
            } else {

                reqDesc->AlternativeTable  = reqDesc->BestAlternativeTable;
                reqDesc->Allocation        = reqDesc->BestAllocation;
            }
        }
    }
    //
    // For each entry in the currently active arbiter list,
    // save information for following RETEST.
    //
    listEntry = ArbiterList->Flink;
    while (listEntry != ArbiterList) {
        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        if (Save == TRUE) {
            arbiterEntry->BestResourceList  = arbiterEntry->ResourceList;
            arbiterEntry->BestConfig        = arbiterEntry->ActiveArbiterList;
        } else {
            arbiterEntry->ResourceList      = arbiterEntry->BestResourceList;
            arbiterEntry->ActiveArbiterList = arbiterEntry->BestConfig;
        }
        listEntry = listEntry->Flink;
    }
}

VOID
IopAddRemoveReqDescs (
    IN      PREQ_DESC   *ReqDescTable,
    IN      ULONG       ReqDescCount,
    IN OUT  PLIST_ENTRY ActiveArbiterList,
    IN      BOOLEAN     Add
    )

/*++

Routine Description:

    This routine adds\removes the descriptors to\from the arbiter lists. It
    also updates the list of arbiters involved.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

    ActiveArbiterList   - Head of list which contains arbiters used for the
                          currently selected configuration.

    Add                 - Specifies if the descriptors are to be added or
                          removed.

Return Value:

    None.

--*/

{
    ULONG                       tableIndex;
    PREQ_DESC                   reqDesc;
    PREQ_DESC                   reqDescTranslated;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    PREQ_ALTERNATIVE            reqAlternative;
    PREQ_LIST                   reqList;
    PDEVICE_NODE                deviceNode;

    PAGED_CODE();

    if (ReqDescCount == 0) {

        return;
    }

    reqList         = ReqDescTable[0]->ReqAlternative->ReqList;
    reqAlternative  = *reqList->SelectedAlternative;
    deviceNode      = PP_DO_TO_DN(reqList->Request->PhysicalDevice);
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "%s %d/%d req alt %s the arbiters for %wZ\n",
        (Add)? "Adding" : "Removing",
        reqAlternative->ReqAlternativeIndex + 1,
        reqList->AlternativeCount,
        (Add)? "to" : "from",
        &deviceNode->InstancePath));
    for (tableIndex = 0; tableIndex < ReqDescCount; tableIndex++) {

        reqDesc = ReqDescTable[tableIndex];
        if (reqDesc->ArbitrationRequired == FALSE) {

            continue;
        }
        arbiterEntry = reqDesc->u.Arbiter;
        ASSERT(arbiterEntry);
        if (arbiterEntry->State & PI_ARBITER_HAS_SOMETHING) {

            arbiterEntry->State &= ~PI_ARBITER_HAS_SOMETHING;
            arbiterEntry->ArbiterInterface->ArbiterHandler(
                                    arbiterEntry->ArbiterInterface->Context,
                                    ArbiterActionRollbackAllocation,
                                    NULL);
        }
        arbiterEntry->ResourcesChanged  = TRUE;
        reqDescTranslated               = reqDesc->TranslatedReqDesc;
        if (Add == TRUE) {

            InitializeListHead(&reqDescTranslated->AlternativeTable.ListEntry);
            InsertTailList(
                &arbiterEntry->ResourceList,
                &reqDescTranslated->AlternativeTable.ListEntry);
            if (IsListEmpty(&arbiterEntry->ActiveArbiterList)) {

                PLIST_ENTRY                 listEntry;
                PPI_RESOURCE_ARBITER_ENTRY  entry;
                //
                // Insert the entry into the sorted list
                // (sorted by depth in the tree).
                //
                for (   listEntry = ActiveArbiterList->Flink;
                        listEntry != ActiveArbiterList;
                        listEntry = listEntry->Flink) {

                    entry = CONTAINING_RECORD(
                                listEntry,
                                PI_RESOURCE_ARBITER_ENTRY,
                                ActiveArbiterList);
                    if (entry->Level >= arbiterEntry->Level) {

                        break;
                    }
                }
                arbiterEntry->ActiveArbiterList.Flink   = listEntry;
                arbiterEntry->ActiveArbiterList.Blink   = listEntry->Blink;
                listEntry->Blink->Flink = &arbiterEntry->ActiveArbiterList;
                listEntry->Blink        = &arbiterEntry->ActiveArbiterList;
            }
        } else {

            ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
            RemoveEntryList(&reqDescTranslated->AlternativeTable.ListEntry);
            InitializeListHead(&reqDescTranslated->AlternativeTable.ListEntry);
            if (IsListEmpty(&arbiterEntry->ResourceList)) {

                RemoveEntryList(&arbiterEntry->ActiveArbiterList);
                InitializeListHead(&arbiterEntry->ActiveArbiterList);
            }
        }
    }
}

NTSTATUS
IopFindBestConfiguration (
    IN PIOP_RESOURCE_REQUEST    RequestTable,
    IN ULONG                    RequestTableCount,
    IN OUT PLIST_ENTRY          ActiveArbiterList
    )

/*++

Routine Description:

    This routine attempts to satisfy the resource requests for all the entries
    in the request table. It also attempts to find the best possible overall
    solution.

Parameters:

    RequestTable        - Table of resource requests.

    RequestTableCount   - Number of requests in the request table.

Return Value:

    Final status.

--*/

{
    LIST_ENTRY      bestArbiterList;
    LARGE_INTEGER   startTime;
    LARGE_INTEGER   currentTime;
    ULONG           timeDiff;
    NTSTATUS        status;
    ULONG           priority;
    ULONG           bestPriority;

    PAGED_CODE();
    //
    // Initialize the arbiter lists used during the search for the best
    // configuration.
    //
    InitializeListHead(ActiveArbiterList);
    InitializeListHead(&bestArbiterList);
    //
    // Start the search from the first possible configuration.
    // Possible configurations are already sorted by priority.
    //
    IopSelectFirstConfiguration(
        RequestTable,
        RequestTableCount,
        ActiveArbiterList);
    //
    // Search for all configurations that work, updating
    // the best configuration until we have tried all
    // possible configurations or timeout has expired.
    //
    KeQuerySystemTime(&startTime);
    bestPriority = (ULONG)-1;
    do {
        //
        // Test the arbiters for this combination.
        //
        status = IopTestConfiguration(ActiveArbiterList);
        if (NT_SUCCESS(status)) {
            //
            // Since the configurations are sorted, we dont need to try others
            // if there is only one entry in the request table.
            //
            bestArbiterList = *ActiveArbiterList;
            if (RequestTableCount == 1) {

                break;
            }
            //
            // Save this configuration if it is better than the best one found
            // so far.
            //
            priority = IopComputeConfigurationPriority(
                            RequestTable,
                            RequestTableCount);
            if (priority < bestPriority) {

                bestPriority = priority;
                IopSaveRestoreConfiguration(
                    RequestTable,
                    RequestTableCount,
                    ActiveArbiterList,
                    TRUE);
            }
        }
        //
        // Check if timeout has expired.
        //
        KeQuerySystemTime(&currentTime);
        timeDiff = (ULONG)((currentTime.QuadPart - startTime.QuadPart) / 10000);
        if (timeDiff >= FIND_BEST_CONFIGURATION_TIMEOUT) {

            IopDbgPrint((
                IOP_RESOURCE_WARNING_LEVEL,
                "IopFindBestConfiguration: Timeout expired"));
            if (IopStopOnTimeout()) {

                IopDbgPrint((
                    IOP_RESOURCE_WARNING_LEVEL,
                    ", terminating search!\n"));
                IopCleanupSelectedConfiguration(
                    RequestTable,
                    RequestTableCount);
                break;
            } else {
                //
                // Re-initialize start time so we spew only every timeout
                // interval.
                //
                startTime = currentTime;
                IopDbgPrint((IOP_RESOURCE_WARNING_LEVEL, "\n"));
           }
        }
        //
        // Select the next possible combination of configurations.
        //
    } while (IopSelectNextConfiguration(
                RequestTable,
                RequestTableCount,
                ActiveArbiterList) == TRUE);
    //
    // Check if we found any working configuration.
    //
    if (IsListEmpty(&bestArbiterList)) {

        status = STATUS_UNSUCCESSFUL;
    } else {

        status = STATUS_SUCCESS;
        //
        // Restore the saved configuration.
        //
        if (RequestTableCount != 1) {

            *ActiveArbiterList = bestArbiterList;
            IopSaveRestoreConfiguration(
                RequestTable,
                RequestTableCount,
                ActiveArbiterList,
                FALSE);
            //
            // Retest this configuration since this may not be the
            // last one tested.
            //
            status = IopRetestConfiguration(ActiveArbiterList);
        }
    }

    return status;
}

/*++

    SECTION = LEGACY BUS INFORMATION TABLE.

    Description:

        This section contains code that implements functions to maintain and
        access the table of Legacy Bus Information.

--*/

VOID
IopInsertLegacyBusDeviceNode (
    IN PDEVICE_NODE     BusDeviceNode,
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine inserts the specified BusDeviceNode in the table according to
    its InterfaceType and BusNumber.

Parameters:

    BusDeviceNode   - Device with the specified InterfaceType and BusNumber.

    InterfaceType   - Specifies the bus devicenode's interface type.

    BusNumber       - Specifies the bus devicenode's bus number.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT(InterfaceType < MaximumInterfaceType && InterfaceType > InterfaceTypeUndefined);
    if (    InterfaceType < MaximumInterfaceType &&
            InterfaceType > InterfaceTypeUndefined &&
            InterfaceType != PNPBus) {

        PLIST_ENTRY listEntry;
        //
        // Eisa == Isa.
        //
        if (InterfaceType == Eisa) {

            InterfaceType = Isa;
        }
        IopLockResourceManager();
        listEntry = IopLegacyBusInformationTable[InterfaceType].Flink;
        while (listEntry != &IopLegacyBusInformationTable[InterfaceType]) {

            PDEVICE_NODE deviceNode = CONTAINING_RECORD(
                                        listEntry,
                                        DEVICE_NODE,
                                        LegacyBusListEntry);
            if (deviceNode->BusNumber == BusNumber) {

                if (deviceNode != BusDeviceNode) {
                    //
                    // There better not be two bus devicenodes with same
                    // interface and bus number.
                    //
                    IopDbgPrint((
                        IOP_RESOURCE_ERROR_LEVEL,
                        "Identical legacy bus devicenodes with "
                        "interface=%08X & bus=%08X...\n"
                        "\t%wZ\n"
                        "\t%wZ\n",
                        InterfaceType,
                        BusNumber,
                        &deviceNode->InstancePath,
                        &BusDeviceNode->InstancePath));
                }
                IopUnlockResourceManager();
                return;
            } else if (deviceNode->BusNumber > BusNumber) {

                break;
            }
            listEntry = listEntry->Flink;
        }
        //
        // Insert the new devicenode before the one with the higher bus number.
        //
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IopInsertLegacyBusDeviceNode: Inserting %wZ with "
            "interface=%08X & bus=%08X into the legacy bus information table\n",
            &BusDeviceNode->InstancePath,
            InterfaceType, BusNumber));
        BusDeviceNode->LegacyBusListEntry.Blink = listEntry->Blink;
        BusDeviceNode->LegacyBusListEntry.Flink = listEntry;
        listEntry->Blink->Flink = &BusDeviceNode->LegacyBusListEntry;
        listEntry->Blink        = &BusDeviceNode->LegacyBusListEntry;
        IopUnlockResourceManager();
    }
}

PDEVICE_NODE
IopFindLegacyBusDeviceNode (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine finds the bus devicenode with the specified InterfaceType
    and BusNumber.

Parameters:

    InterfaceType   - Specifies the bus devicenode's interface type.

    BusNumber       - Specifies the bus devicenode's bus number.

Return Value:

    A pointer to the bus devicenode.

--*/

{
    PDEVICE_NODE busDeviceNode;

    PAGED_CODE();

    busDeviceNode = IopRootDeviceNode;
    if (    InterfaceType < MaximumInterfaceType &&
            InterfaceType > InterfaceTypeUndefined &&
            InterfaceType != PNPBus) {

        PLIST_ENTRY listEntry;
        //
        // Eisa == Isa.
        //
        if (InterfaceType == Eisa) {

            InterfaceType = Isa;
        }
        //
        // Search our table...
        //
        listEntry = IopLegacyBusInformationTable[InterfaceType].Flink;
        while (listEntry != &IopLegacyBusInformationTable[InterfaceType]) {

            PDEVICE_NODE deviceNode = CONTAINING_RECORD(
                                        listEntry,
                                        DEVICE_NODE,
                                        LegacyBusListEntry);
            if (deviceNode->BusNumber == BusNumber) {
                //
                // Return the bus devicenode matching the bus number and
                // interface.
                //
                busDeviceNode = deviceNode;
                break;
            } else if (deviceNode->BusNumber > BusNumber) {
                //
                // We are done since our list of bus numbers is sorted.
                //
                break;
            }
            listEntry = listEntry->Flink;
        }
    }
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "IopFindLegacyBusDeviceNode() Found %wZ with "
        "interface=%08X & bus=%08X\n",
        &busDeviceNode->InstancePath,
        InterfaceType,
        BusNumber));

    return busDeviceNode;
}

/*++

    SECTION = BOOT CONFIG.

    Description:

        This section contains code that implements BOOT config allocation and
        release.

--*/

NTSTATUS
IopAllocateBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine allocates boot resources.
    Before all Boot Bux Extenders are processed, this routine is called only
    for non-madeup devices since arbiters for their boot resources should
    already be initialized by the time the time they got enumerated.
    After all Boot Bus Extenders are processed, this routine is used for all
    boot allocations.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_INFO_LEVEL,
        "Allocating boot resources...\n"));
    //
    // Claim the lock so no other resource allocations\releases can take place.
    //
    IopLockResourceManager();
    //
    // Call the function that does the real work.
    //
    status = IopAllocateBootResourcesInternal(
                ArbiterRequestSource,
                DeviceObject,
                BootResources);
    //
    // Unblock other resource allocations\releases.
    //
    IopUnlockResourceManager();

    return status;
}

NTSTATUS
IopReportBootResources (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine is used to report boot resources.
    This routine gets called before all Boot Bus Extenders are processed. It
    calls the actual allocation function for non-madeup devices. For others,
    it delays the allocation. The postponed allocations take place when the
    arbiters come online by calling IopAllocateLegacyBootResources. Once all
    Boot Bus Extenders are processed, the calls get routed to
    IopAllocateBootResources directly.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    ULONG                           size;
    PDEVICE_NODE                    deviceNode;
    PIOP_RESERVED_RESOURCES_RECORD  resourceRecord;

    IopDbgPrint((
        IOP_RESOURCE_INFO_LEVEL,
        "Reporting boot resources...\n"));
    if ((size = IopDetermineResourceListSize(BootResources)) == 0) {

        return STATUS_SUCCESS;
    }
    if (DeviceObject) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        ASSERT(deviceNode);
        if (!(deviceNode->Flags & DNF_MADEUP)) {
            //
            // Allocate BOOT configs for non-madeup devices right away.
            //
            return IopAllocateBootResources(
                    ArbiterRequestSource,
                    DeviceObject,
                    BootResources);
        }
        if (!deviceNode->BootResources) {

            deviceNode->BootResources = ExAllocatePoolIORL(PagedPool, size);
            if (!deviceNode->BootResources) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }
            RtlCopyMemory(deviceNode->BootResources, BootResources, size);
        }
    } else {

        deviceNode = NULL;
    }
    //
    // Delay BOOT allocation since arbiters may not be around.
    //
    resourceRecord = (PIOP_RESERVED_RESOURCES_RECORD) ExAllocatePoolIORRR(
                        PagedPool,
                        sizeof(IOP_RESERVED_RESOURCES_RECORD));
    if (!resourceRecord) {
        //
        // Free memory we allocated and return failure.
        //
        if (deviceNode && deviceNode->BootResources) {

            ExFreePool(deviceNode->BootResources);
            deviceNode->BootResources = NULL;
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    if (deviceNode) {

        resourceRecord->ReservedResources   = deviceNode->BootResources;
    } else {

        resourceRecord->ReservedResources   = BootResources;
    }
    resourceRecord->DeviceObject            = DeviceObject;
    //
    // Link this record into our list.
    //
    resourceRecord->Next                    = IopInitReservedResourceList;
    IopInitReservedResourceList             = resourceRecord;

    return STATUS_SUCCESS;
}

NTSTATUS
IopAllocateLegacyBootResources (
    IN INTERFACE_TYPE   InterfaceType,
    IN ULONG            BusNumber
    )

/*++

Routine Description:

    This routine is called to reserve legacy BOOT resources for the specified
    InterfaceType and BusNumber. This is done everytime a new bus with a legacy
    InterfaceType gets enumerated.

Parameters:

    InterfaceType   - Legacy InterfaceType.

    BusNumber       - Legacy BusNumber.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                        status;
    PIOP_RESERVED_RESOURCES_RECORD  resourceRecord;
    PIOP_RESERVED_RESOURCES_RECORD  prevRecord;
    PCM_RESOURCE_LIST               newList;
    PCM_RESOURCE_LIST               remainingList;
    PCM_RESOURCE_LIST               resourceList;

    if (IopInitHalDeviceNode && IopInitHalResources) {

        remainingList = NULL;
        newList = IopCreateCmResourceList(
                    IopInitHalResources,
                    InterfaceType,
                    BusNumber,
                    &remainingList);
        if (newList) {
            //
            // Sanity check that there was no error.
            //
            if (remainingList == NULL) {
                //
                // Full match.
                //
                ASSERT(newList == IopInitHalResources);
            } else {
                //
                // Partial match.
                //
                ASSERT(IopInitHalResources != newList);
                ASSERT(IopInitHalResources != remainingList);
            }
            if (remainingList) {

                ExFreePool(IopInitHalResources);
            }
            IopInitHalResources         = remainingList;
            remainingList               = IopInitHalDeviceNode->BootResources;
            IopInitHalDeviceNode->Flags |= DNF_HAS_BOOT_CONFIG;
            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Allocating HAL reported resources on interface=%x and "
                "bus number=%x...\n", InterfaceType, BusNumber));
            status = IopAllocateBootResources(
                        ArbiterRequestHalReported,
                        IopInitHalDeviceNode->PhysicalDeviceObject,
                        newList);
            IopInitHalDeviceNode->BootResources = IopCombineCmResourceList(
                                                    remainingList,
                                                    newList);
            ASSERT(IopInitHalDeviceNode->BootResources);
            //
            // Free previous BOOT config if any.
            //
            if (remainingList) {

                ExFreePool(remainingList);
            }
        } else {
            //
            // No match. Sanity check that there was no error.
            //
            ASSERT(remainingList && remainingList == IopInitHalResources);
        }
    }
    prevRecord      = NULL;
    resourceRecord  = IopInitReservedResourceList;
    while (resourceRecord) {

        resourceList = resourceRecord->ReservedResources;
        if (    resourceList->List[0].InterfaceType == InterfaceType &&
                resourceList->List[0].BusNumber == BusNumber) {

            IopDbgPrint((
                IOP_RESOURCE_INFO_LEVEL,
                "Allocating boot config for made-up device on interface=%x and"
                " bus number=%x...\n", InterfaceType, BusNumber));
            status = IopAllocateBootResources(
                        ArbiterRequestPnpEnumerated,
                        resourceRecord->DeviceObject,
                        resourceList);
            if (resourceRecord->DeviceObject == NULL) {

                ExFreePool(resourceList);
            }
            if (prevRecord) {

                prevRecord->Next            = resourceRecord->Next;
            } else {

                IopInitReservedResourceList = resourceRecord->Next;
            }
            ExFreePool(resourceRecord);
            if (prevRecord) {

                resourceRecord = prevRecord->Next;
            } else {

                resourceRecord = IopInitReservedResourceList;
            }
        } else {

            prevRecord      = resourceRecord;
            resourceRecord  = resourceRecord->Next;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopAllocateBootResourcesInternal (
    IN ARBITER_REQUEST_SOURCE   ArbiterRequestSource,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PCM_RESOURCE_LIST        BootResources
    )

/*++

Routine Description:

    This routine reports boot resources for the specified device to
    arbiters.

Parameters:

    ArbiterRequestSource    - Source of this resource request.

    DeviceObject            - If non-NULL, the boot resources are
        pre-allocated. These resources will not be given out until they are
        released to the arbiters. If NULL, the boot resources get reserved and
        may be given out if there is no other choice.

    BootResources           - Supplies a pointer to the BOOT resources. If
        DeviceObject is NULL, caller should release this pool.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS                        status;
    PDEVICE_NODE                    deviceNode;
    PIO_RESOURCE_REQUIREMENTS_LIST  ioResources;
    PREQ_LIST                       reqList;
    IOP_RESOURCE_REQUEST            request;

    PAGED_CODE();

    ioResources = IopCmResourcesToIoResources(
                    0,
                    BootResources,
                    LCPRI_BOOTCONFIG);
    if (ioResources) {

        deviceNode = PP_DO_TO_DN(DeviceObject);
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "\n===================================\n"
                     ));
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "Boot Resource List:: "));
        IopDumpResourceRequirementsList(ioResources);
        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            " ++++++++++++++++++++++++++++++\n"));
        request.AllocationType = ArbiterRequestSource;
        request.ResourceRequirements = ioResources;
        request.PhysicalDevice = DeviceObject;
        status = IopResourceRequirementsListToReqList(
                    &request,
                    &reqList);
        if (NT_SUCCESS(status)) {

            if (reqList) {

                status = IopBootAllocation(reqList);
                if (NT_SUCCESS(status)) {

                    if (deviceNode) {

                        deviceNode->Flags |= DNF_BOOT_CONFIG_RESERVED;
                        if (!deviceNode->BootResources) {

                            ULONG   size;

                            size = IopDetermineResourceListSize(BootResources);
                            deviceNode->BootResources = ExAllocatePoolIORL(
                                                            PagedPool,
                                                            size);
                            if (!deviceNode->BootResources) {

                                return STATUS_INSUFFICIENT_RESOURCES;
                            }
                            RtlCopyMemory(
                                deviceNode->BootResources,
                                BootResources,
                                size);
                        }
                    }
                }
                IopFreeReqList(reqList);
            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        }
        ExFreePool(ioResources);
    } else {

        status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(status)) {

        IopDbgPrint((
            IOP_RESOURCE_ERROR_LEVEL,
            "IopAllocateBootResourcesInternal: Failed with status = %08X\n",
            status));
    }

    return status;
}

NTSTATUS
IopBootAllocation (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine calls the arbiters for the ReqList to do BootAllocation.

Parameters:

    ReqList - List of BOOT resources in internal format.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    returnStatus;
    LIST_ENTRY                  activeArbiterList;
    PLIST_ENTRY                 listEntry;
    PPI_RESOURCE_ARBITER_ENTRY  arbiterEntry;
    ARBITER_PARAMETERS          p;

    PAGED_CODE();

    returnStatus = STATUS_SUCCESS;
    InitializeListHead(&activeArbiterList);
    ReqList->SelectedAlternative = ReqList->AlternativeTable;
    IopAddRemoveReqDescs(   (*ReqList->SelectedAlternative)->DescTable,
                            (*ReqList->SelectedAlternative)->DescCount,
                            &activeArbiterList,
                            TRUE);
    listEntry = activeArbiterList.Flink;
    while (listEntry != &activeArbiterList){

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        ActiveArbiterList);
        listEntry = listEntry->Flink;
        if (arbiterEntry->ResourcesChanged == FALSE) {

            continue;
        }
        ASSERT(IsListEmpty(&arbiterEntry->ResourceList) == FALSE);
        p.Parameters.BootAllocation.ArbitrationList =
            &arbiterEntry->ResourceList;
        status = arbiterEntry->ArbiterInterface->ArbiterHandler(
                    arbiterEntry->ArbiterInterface->Context,
                    ArbiterActionBootAllocation,
                    &p);

        if (!NT_SUCCESS(status)) {

            PARBITER_LIST_ENTRY arbiterListEntry;

            arbiterListEntry = (PARBITER_LIST_ENTRY)
                                arbiterEntry->ResourceList.Flink;
            IopDbgPrint((
                IOP_RESOURCE_ERROR_LEVEL,
                "Allocate Boot Resources Failed ::\n\tCount = %x, PDO = %x\n",
                arbiterListEntry->AlternativeCount,
                arbiterListEntry->PhysicalDeviceObject));
            IopDumpResourceDescriptor("\t", arbiterListEntry->Alternatives);
            returnStatus = status;
        }
        IopInitializeArbiterEntryState(arbiterEntry);
    }

    IopCheckDataStructures(IopRootDeviceNode);

    return returnStatus;
}

PCM_RESOURCE_LIST
IopCreateCmResourceList (
    IN PCM_RESOURCE_LIST    ResourceList,
    IN INTERFACE_TYPE       InterfaceType,
    IN ULONG                BusNumber,
    OUT PCM_RESOURCE_LIST   *RemainingList
    )

/*++

Routine Description:

    This routine returns the CM_RESOURCE_LIST portion out of the specified list
    that matches the specified BusNumber and InterfaceType.

Parameters:

    ResourceList    - Input resource list.

    InterfaceType   - Interface type.

    BusNumber       - Bus number.

    RemainingList   - Portion not matching BusNumber and InterfaceType.

Return Value:

    Returns the matching CM_RESOURCE_LIST if successful, else NULL.

--*/

{
    ULONG                           i;
    ULONG                           j;
    ULONG                           totalSize;
    ULONG                           matchSize;
    ULONG                           listSize;
    PCM_RESOURCE_LIST               newList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR    newFullResourceDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR    remainingFullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    PAGED_CODE();

    fullResourceDesc    = &ResourceList->List[0];
    totalSize           = FIELD_OFFSET(CM_RESOURCE_LIST, List);
    matchSize           = 0;
    //
    // Determine the size of memory to be allocated for the matching resource
    // list.
    //
    for (i = 0; i < ResourceList->Count; i++) {
        //
        // Add the size of this descriptor.
        //
        listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                PartialResourceList) +
                   FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                PartialDescriptors);
        partialDescriptor =
            &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {

            ULONG descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {

                descriptorSize +=
                    partialDescriptor->u.DeviceSpecificData.DataSize;
            }
            listSize += descriptorSize;
            partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                    ((PUCHAR)partialDescriptor +
                                            descriptorSize);
        }
        if (    fullResourceDesc->InterfaceType == InterfaceType &&
                fullResourceDesc->BusNumber == BusNumber) {

            matchSize += listSize;
        }
        totalSize += listSize;
        fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                  ((PUCHAR)fullResourceDesc + listSize);
    }
    if (!matchSize) {

        *RemainingList  = ResourceList;
        return NULL;
    }
    matchSize += FIELD_OFFSET(CM_RESOURCE_LIST, List);
    if (matchSize == totalSize) {

        *RemainingList  = NULL;
        return ResourceList;
    }
    //
    // Allocate memory for both lists.
    //
    newList = (PCM_RESOURCE_LIST)ExAllocatePoolIORRR(PagedPool, matchSize);
    if (newList == NULL) {

        *RemainingList = NULL;
        return NULL;
    }
    *RemainingList = (PCM_RESOURCE_LIST)
                        ExAllocatePoolIORRR(
                            PagedPool,
                            totalSize - matchSize +
                                FIELD_OFFSET(CM_RESOURCE_LIST, List));
    if (*RemainingList == NULL) {

        ExFreePool(newList);
        return NULL;
    }
    newList->Count              = 0;
    (*RemainingList)->Count     = 0;
    newFullResourceDesc         = &newList->List[0];
    remainingFullResourceDesc   = &(*RemainingList)->List[0];
    fullResourceDesc            = &ResourceList->List[0];
    for (i = 0; i < ResourceList->Count; i++) {

        listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                PartialResourceList) +
                   FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                PartialDescriptors);
        partialDescriptor =
            &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {

            ULONG descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {

                descriptorSize +=
                    partialDescriptor->u.DeviceSpecificData.DataSize;
            }
            listSize += descriptorSize;
            partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                    ((PUCHAR)partialDescriptor +
                                        descriptorSize);
        }
        if (    fullResourceDesc->InterfaceType == InterfaceType &&
                fullResourceDesc->BusNumber == BusNumber) {

            newList->Count++;
            RtlCopyMemory(newFullResourceDesc, fullResourceDesc, listSize);
            newFullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                          ((PUCHAR)newFullResourceDesc +
                                            listSize);
        } else {

            (*RemainingList)->Count++;
            RtlCopyMemory(
                remainingFullResourceDesc,
                fullResourceDesc,
                listSize);
            remainingFullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                          ((PUCHAR)remainingFullResourceDesc +
                                            listSize);
        }
        fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                  ((PUCHAR)fullResourceDesc +
                                    listSize);
    }

    return newList;
}

PCM_RESOURCE_LIST
IopCombineCmResourceList (
    IN PCM_RESOURCE_LIST ResourceListA,
    IN PCM_RESOURCE_LIST ResourceListB
    )

/*++

Routine Description:

    This routine combines the two CM_RESOURCE_LISTs and returns the resulting
    CM_RESOURCE_LIST.

Parameters:

    ResourceListA - ListA.

    ResourceListB - ListB.

Return Value:

    Returns the combined CM_RESOURCE_LIST if successful, else NULL.

--*/

{
    PCM_RESOURCE_LIST   newList;
    ULONG               sizeA;
    ULONG               sizeB;
    ULONG               size;
    ULONG               diff;

    PAGED_CODE();

    if (ResourceListA == NULL) {

        return ResourceListB;
    }

    if (ResourceListB == NULL) {

        return ResourceListA;
    }
    newList = NULL;
    sizeA   = IopDetermineResourceListSize(ResourceListA);
    sizeB   = IopDetermineResourceListSize(ResourceListB);
    if (sizeA && sizeB) {

        diff = sizeof(CM_RESOURCE_LIST) - sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        size = sizeA + sizeB - diff;
        newList = (PCM_RESOURCE_LIST)ExAllocatePoolIORRR(PagedPool, size);
        if (newList) {

            RtlCopyMemory(newList, ResourceListA, sizeA);
            RtlCopyMemory(
                (PUCHAR)newList + sizeA,
                (PUCHAR)ResourceListB + diff,
                sizeB - diff);
            newList->Count += ResourceListB->Count;
        }
    }

    return newList;
}

/*++

    SECTION = CLEANUP.

    Description:

        This section contains code that performs clean up like releasing storage
        for various data structures..

--*/

VOID
IopFreeReqAlternative (
    IN PREQ_ALTERNATIVE ReqAlternative
    )

/*++

Routine Description:

    This routine release the storage for the ReqAlternative by freeing the
    contained descriptors.

Parameters:

    ReqList - REQ_ALTERNATIVE to be freed.

Return Value:

    None.

--*/

{
    PREQ_DESC   reqDesc;
    PREQ_DESC   reqDescx;
    ULONG       i;

    PAGED_CODE();

    if (ReqAlternative) {
        //
        // Free all REQ_DESC making this REQ_ALTERNATIVE.
        //
        for (i = 0; i < ReqAlternative->DescCount; i++) {
            //
            // Free the list of translated REQ_DESCs for this REQ_DESC.
            //
            reqDesc     = ReqAlternative->DescTable[i];
            reqDescx    = reqDesc->TranslatedReqDesc;
            while (reqDescx && IS_TRANSLATED_REQ_DESC(reqDescx)) {
                //
                // Free storage for alternative descriptors if any.
                //
                if (reqDescx->AlternativeTable.Alternatives) {

                    ExFreePool(reqDescx->AlternativeTable.Alternatives);
                }
                reqDesc     = reqDescx;
                reqDescx    = reqDescx->TranslatedReqDesc;
                ExFreePool(reqDesc);
            }
        }
    }
}

VOID
IopFreeReqList (
    IN PREQ_LIST ReqList
    )

/*++

Routine Description:

    This routine release the storage for the ReqList by freeing the contained
    alternatives.

Parameters:

    ReqList - REQ_LIST to be freed.

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE();

    if (ReqList) {
        //
        // Free all alternatives making this REQ_LIST.
        //
        for (i = 0; i < ReqList->AlternativeCount; i++) {

            IopFreeReqAlternative(ReqList->AlternativeTable[i]);
        }
        ExFreePool(ReqList);
    }
}

VOID
IopFreeResourceRequirementsForAssignTable(
    IN PIOP_RESOURCE_REQUEST RequestTable,
    IN PIOP_RESOURCE_REQUEST RequestTableEnd
    )

/*++

Routine Description:

    For each resource request in the table, this routine frees its
    associated REQ_LIST.

Parameters:

    RequestTable    - Start of request table.

    RequestTableEnd - End of request table.

Return Value:

    None.

--*/

{
    PIOP_RESOURCE_REQUEST request;

    PAGED_CODE();

    for (request = RequestTable; request < RequestTableEnd; request++) {

        IopFreeReqList(request->ReqList);
        request->ReqList = NULL;
        if (    request->Flags & IOP_ASSIGN_KEEP_CURRENT_CONFIG &&
                request->ResourceRequirements) {
            //
            // The REAL resreq list is cached in DeviceNode->ResourceRequirements.
            // We need to free the filtered list.
            //
            ExFreePool(request->ResourceRequirements);
            request->ResourceRequirements = NULL;
        }
    }
}

#if DBG_SCOPE
VOID
IopCheckDataStructures (
    IN PDEVICE_NODE DeviceNode
    )

{
    PDEVICE_NODE    sibling;

    PAGED_CODE();

    //
    // Process all the siblings.
    //
    for (sibling = DeviceNode; sibling; sibling = sibling->Sibling) {

        IopCheckDataStructuresWorker(sibling);
    }
    for (sibling = DeviceNode; sibling; sibling = sibling->Sibling) {
        //
        // Recursively check all the children.
        //
        if (sibling->Child) {
            IopCheckDataStructures(sibling->Child);
        }
    }
}

VOID
IopCheckDataStructuresWorker (
    IN PDEVICE_NODE Device
    )

/*++

Routine Description:

    This routine sanity checks the arbiter related data structures for the
    specified device.

Parameters:

    DeviceNode - Device node whose structures are to be checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listHead, listEntry;
    PPI_RESOURCE_ARBITER_ENTRY arbiterEntry;

    PAGED_CODE();

    listHead    = &Device->DeviceArbiterList;
    listEntry   = listHead->Flink;
    while (listEntry != listHead) {

        arbiterEntry = CONTAINING_RECORD(
                        listEntry,
                        PI_RESOURCE_ARBITER_ENTRY,
                        DeviceArbiterList);
        if (arbiterEntry->ArbiterInterface != NULL) {

            if (!IsListEmpty(&arbiterEntry->ResourceList)) {
                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Arbiter on %wZ should have empty resource list\n",
                    &Device->InstancePath));
            }
            if (!IsListEmpty(&arbiterEntry->ActiveArbiterList)) {
                IopDbgPrint((
                    IOP_RESOURCE_ERROR_LEVEL,
                    "Arbiter on %wZ should not be in the active arbiter list\n",
                    &Device->InstancePath));
            }
        }
        listEntry = listEntry->Flink;
    }
}

VOID
IopDumpResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoResources
    )

/*++

Routine Description:

    This routine dumps IoResources

Parameters:

    IoResources - Supplies a pointer to the IO resource requirements list

Return Value:

    None.

--*/

{
    PIO_RESOURCE_LIST       IoResourceList;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptorEnd;
    LONG                    IoResourceListCount;

    PAGED_CODE();

    if (IoResources == NULL) {

        return;
    }
    IoResourceList      = IoResources->List;
    IoResourceListCount = (LONG) IoResources->AlternativeLists;
    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "ResReqList: Interface: %x, Bus: %x, Slot: %x, AlternativeLists: %x\n",
         IoResources->InterfaceType,
         IoResources->BusNumber,
         IoResources->SlotNumber,
         IoResources->AlternativeLists));
    while (--IoResourceListCount >= 0) {

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "  Alternative List: DescCount: %x\n",
            IoResourceList->Count));
        IoResourceDescriptor = IoResourceList->Descriptors;
        IoResourceDescriptorEnd = IoResourceDescriptor + IoResourceList->Count;
        while(IoResourceDescriptor < IoResourceDescriptorEnd) {

            IopDumpResourceDescriptor("    ", IoResourceDescriptor++);
        }
        IoResourceList = (PIO_RESOURCE_LIST) IoResourceDescriptorEnd;
    }
    IopDbgPrint((IOP_RESOURCE_VERBOSE_LEVEL,"\n"));
}

VOID
IopDumpResourceDescriptor (
    IN PUCHAR Indent,
    IN PIO_RESOURCE_DESCRIPTOR  Desc
    )
{
    PAGED_CODE();

    IopDbgPrint((
        IOP_RESOURCE_VERBOSE_LEVEL,
        "%sOpt: %x, Share: %x\t",
        Indent,
        Desc->Option,
        Desc->ShareDisposition));
    switch (Desc->Type) {
    case CmResourceTypePort:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "IO  Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
            Desc->u.Port.MinimumAddress.HighPart,
            Desc->u.Port.MinimumAddress.LowPart,
            Desc->u.Port.MaximumAddress.HighPart,
            Desc->u.Port.MaximumAddress.LowPart,
            Desc->u.Port.Alignment,
            Desc->u.Port.Length));
            break;

    case CmResourceTypeMemory:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "MEM Min: %x:%08x, Max: %x:%08x, Algn: %x, Len %x\n",
            Desc->u.Memory.MinimumAddress.HighPart,
            Desc->u.Memory.MinimumAddress.LowPart,
            Desc->u.Memory.MaximumAddress.HighPart,
            Desc->u.Memory.MaximumAddress.LowPart,
            Desc->u.Memory.Alignment,
            Desc->u.Memory.Length));
            break;

    case CmResourceTypeInterrupt:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "INT Min: %x, Max: %x\n",
            Desc->u.Interrupt.MinimumVector,
            Desc->u.Interrupt.MaximumVector));
            break;

    case CmResourceTypeDma:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "DMA Min: %x, Max: %x\n",
            Desc->u.Dma.MinimumChannel,
            Desc->u.Dma.MaximumChannel));
            break;

    case CmResourceTypeDevicePrivate:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "DevicePrivate Data: %x, %x, %x\n",
            Desc->u.DevicePrivate.Data[0],
            Desc->u.DevicePrivate.Data[1],
            Desc->u.DevicePrivate.Data[2]));
            break;

    default:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "Unknown Descriptor type %x\n",
            Desc->Type));
            break;
    }
}

VOID
IopDumpCmResourceList (
    IN PCM_RESOURCE_LIST CmList
    )
/*++

Routine Description:

    This routine displays CM resource list.

Arguments:

    CmList - CM resource list to be dumped.

Return Value:

    None.

--*/
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullDesc;
    PCM_PARTIAL_RESOURCE_LIST       partialDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR desc;
    ULONG                           count;
    ULONG                           i;

    PAGED_CODE();

    if (CmList->Count > 0) {

        if (CmList) {

            fullDesc = &CmList->List[0];
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "Cm Resource List -\n"));
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "  List Count = %x, Bus Number = %x\n",
                CmList->Count,
                fullDesc->BusNumber));
            partialDesc = &fullDesc->PartialResourceList;
            IopDbgPrint((
                IOP_RESOURCE_VERBOSE_LEVEL,
                "  Version = %x, Revision = %x, Desc count = %x\n",
                partialDesc->Version,
                partialDesc->Revision,
                partialDesc->Count));
            count = partialDesc->Count;
            desc = &partialDesc->PartialDescriptors[0];
            for (i = 0; i < count; i++) {

                IopDumpCmResourceDescriptor("    ", desc);
                desc++;
            }
        }
    }
}

VOID
IopDumpCmResourceDescriptor (
    IN PUCHAR Indent,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Desc
    )
/*++

Routine Description:

    This routine displays a IO_RESOURCE_DESCRIPTOR.

Parameters:

    Indent - # char of indentation.

    Desc - CM_RESOURCE_DESCRIPTOR to be displayed.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    switch (Desc->Type) {
    case CmResourceTypePort:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sIO  Start: %x:%08x, Length:  %x\n",
            Indent,
            Desc->u.Port.Start.HighPart,
            Desc->u.Port.Start.LowPart,
            Desc->u.Port.Length));
        break;

    case CmResourceTypeMemory:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sMEM Start: %x:%08x, Length:  %x\n",
            Indent,
            Desc->u.Memory.Start.HighPart,
            Desc->u.Memory.Start.LowPart,
            Desc->u.Memory.Length));
        break;

    case CmResourceTypeInterrupt:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sINT Level: %x, Vector: %x, Affinity: %x\n",
            Indent,
            Desc->u.Interrupt.Level,
            Desc->u.Interrupt.Vector,
            Desc->u.Interrupt.Affinity));
        break;

    case CmResourceTypeDma:

        IopDbgPrint((
            IOP_RESOURCE_VERBOSE_LEVEL,
            "%sDMA Channel: %x, Port: %x\n",
            Indent,
            Desc->u.Dma.Channel,
            Desc->u.Dma.Port));
        break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpstart.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation
All rights reserved

Module Name:

    pnpstart.c

Abstract:

    This module implements new Plug-And-Play driver entries and IRPs.

Author:

    Shie-Lin Tzong (shielint) June-16-1995

Environment:

    Kernel mode only.

Revision History:

*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ddpP')
#endif

typedef struct _DEVICE_LIST_CONTEXT {
    ULONG DeviceCount;
    BOOLEAN Reallocation;
    PDEVICE_OBJECT DeviceList[1];
} DEVICE_LIST_CONTEXT, *PDEVICE_LIST_CONTEXT;

NTSTATUS
IopAssignResourcesToDevices (
    IN ULONG DeviceCount,
    IN PIOP_RESOURCE_REQUEST RequestTable,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    );

NTSTATUS
IopGetDriverDeviceList(
   IN PDRIVER_OBJECT DriverObject,
   OUT PDEVICE_LIST_CONTEXT *DeviceList
   );

NTSTATUS
IopProcessAssignResourcesWorker(
   IN PDEVICE_NODE  DeviceNode,
   IN PVOID         Context
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopAssignResourcesToDevices)
#pragma alloc_text(PAGE, IopProcessAssignResources)
#pragma alloc_text(PAGE, IopProcessAssignResourcesWorker)
#pragma alloc_text(PAGE, IopWriteAllocatedResourcesToRegistry)
#endif // ALLOC_PRAGMA



//
// The following routines should be removed once the real
// Resource Assign code is done.
//

NTSTATUS
IopAssignResourcesToDevices(
    IN ULONG DeviceCount,
    IN OUT PIOP_RESOURCE_REQUEST RequestTable,
    IN BOOLEAN DoBootConfigs,
    OUT PBOOLEAN RebalancePerformed
    )
/*++

Routine Description:

    This routine takes an input array of IOP_RESOURCE_REQUEST structures, and
    allocates resource for the physical device object specified in
    the structure.   The allocated resources are automatically recorded
    in the registry.

Arguments:

    DeviceCount - Supplies the number of device objects whom we need to
                  allocate resource to.  That is the number of entries
                  in the RequestTable.

    RequestTable - Supplies an array of IOP_RESOURCE_REQUEST structures which
                   contains the Physical device object to allocate resource to.
                   Upon entry, the ResourceAssignment pointer is NULL and on
                   return the allocated resource is returned via the this pointer.

    DoBootConfigs - Allow assignment of BOOT configs.

Return Value:

    The status returned is the final completion status of the operation.

    NOTE:
    If NTSTATUS_SUCCESS is returned, the resource allocation for *all* the devices
    specified is succeeded.  Otherwise, one or more are failed and caller must
    examine the ResourceAssignment pointer in each IOP_RESOURCE_REQUEST structure to
    determine which devices failed and which succeeded.

--*/
{
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    ASSERT(DeviceCount != 0);

    for (i = 0; i < DeviceCount; i++) {

        //
        // Initialize table entry.
        //
        if (PpCallerInitializesRequestTable == TRUE) {

            RequestTable[i].Position = i;
        }
        RequestTable[i].ResourceAssignment = NULL;
        RequestTable[i].Status = 0;
        RequestTable[i].Flags = 0;
        RequestTable[i].AllocationType = ArbiterRequestPnpEnumerated;
        if (((PDEVICE_NODE)(RequestTable[i].PhysicalDevice->DeviceObjectExtension->DeviceNode))->Flags & DNF_MADEUP) {

            ULONG           reportedDevice = 0;
            HANDLE          hInstance;

            status = IopDeviceObjectToDeviceInstance(RequestTable[i].PhysicalDevice, &hInstance, KEY_READ);
            if (NT_SUCCESS(status)) {

                ULONG           resultSize = 0;
                UCHAR           buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG)];
                UNICODE_STRING  unicodeString;

                PiWstrToUnicodeString(&unicodeString, REGSTR_VALUE_DEVICE_REPORTED);
                status = ZwQueryValueKey(   hInstance,
                                            &unicodeString,
                                            KeyValuePartialInformation,
                                            (PVOID)buffer,
                                            sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG),
                                            &resultSize);
                if (NT_SUCCESS(status)) {

                    reportedDevice = *(PULONG)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data);

                }

                ZwClose(hInstance);
            }

            //
            // Change the AllocationType for reported devices.
            //

            if (reportedDevice) {

                RequestTable[i].AllocationType = ArbiterRequestLegacyReported;

            }

        }
        RequestTable[i].ResourceRequirements = NULL;
    }

    //
    // Allocate memory to build a IOP_ASSIGN table to call IopAllocateResources()
    //

    status = IopAllocateResources(  &DeviceCount,
                                    &RequestTable,
                                    FALSE,
                                    DoBootConfigs,
                                    RebalancePerformed);
    return status;
}

BOOLEAN
IopProcessAssignResources(
   IN   PDEVICE_NODE    DeviceNode,
   IN   BOOLEAN         Reallocation,
   OUT  BOOLEAN        *RebalancePerformed
   )
/*++

Routine Description:

    This function attempts to assign resources to device under the subtree on
    which AddDevice has been performed. Prior to the completion of all Boot Bus
    Extenders in the system, this routine attempts allocation first so that devices
    with no requirements and no boot config get processed. If there are no such devices,
    then it attempts to allocate resources for devices with boot config. If there are no
    devices with boot config, then other devices (requirements but no boot config)
    get processed. During later part of boot, it attempts allocation only once
    (since we should have already reserved all the boot configs).

Parameters:

    DeviceNode - specifies the root of the subtree under which resources will be
                 allocated.

    Reallocation - if TRUE, we will attempt allocation for devices with resource conflict
                   problem in addition to other devices.

    RebalancePerformed - recieves whether a rebalance was successfully comp[eted.

Return Value:

    TRUE if resources got assigned to any device, otherwise FALSE.

--*/
{
    PDEVICE_NODE deviceNode;
    PDEVICE_LIST_CONTEXT context;
    BOOLEAN resourcesAssigned, tryAgain;
    ULONG count, i, attempt, maxAttempts;
    PIOP_RESOURCE_REQUEST requestTable;

    PAGED_CODE();

    resourcesAssigned = FALSE;
    tryAgain = TRUE;
    maxAttempts = (IopBootConfigsReserved)? 1 : 2;
    for (attempt = 0; !resourcesAssigned && tryAgain && attempt < maxAttempts; attempt++) {

        tryAgain = FALSE;

        //
        // Allocate and init memory for resource context
        //
        context = (PDEVICE_LIST_CONTEXT) ExAllocatePool(
                                        PagedPool,
                                        sizeof(DEVICE_LIST_CONTEXT) +
                                        sizeof(PDEVICE_OBJECT) * IopNumberDeviceNodes
                                        );
        if (!context) {

            return FALSE;
        }
        context->DeviceCount = 0;
        context->Reallocation = Reallocation;

        //
        // Parse the device node subtree to determine which devices need resources
        //
        IopProcessAssignResourcesWorker(DeviceNode, context);
        count = context->DeviceCount;
        if (count == 0) {

            ExFreePool(context);
            return FALSE;
        }

        //
        // Need to assign resources to devices.  Build the resource request table and call
        // resource assignment routine.
        //
        requestTable = (PIOP_RESOURCE_REQUEST) ExAllocatePool(
                                        PagedPool,
                                        sizeof(IOP_RESOURCE_REQUEST) * count
                                        );
        if (requestTable) {

            for (i = 0; i < count; i++) {

                requestTable[i].Priority = 0;
                requestTable[i].PhysicalDevice = context->DeviceList[i];
            }

            //
            // Assign resources
            //
            IopAssignResourcesToDevices(
                count,
                requestTable,
                (attempt == 0) ? IopBootConfigsReserved : TRUE,
                RebalancePerformed
                );

            //
            // Check the results
            //
            for (i = 0; i < count; i++) {

                deviceNode = (PDEVICE_NODE)
                              requestTable[i].PhysicalDevice->DeviceObjectExtension->DeviceNode;

                if (NT_SUCCESS(requestTable[i].Status)) {

                    if (requestTable[i].ResourceAssignment) {

                        deviceNode->ResourceList = requestTable[i].ResourceAssignment;
                        deviceNode->ResourceListTranslated = requestTable[i].TranslatedResourceAssignment;
                    } else {

                        deviceNode->Flags |= DNF_NO_RESOURCE_REQUIRED;
                    }
                    PipSetDevNodeState(deviceNode, DeviceNodeResourcesAssigned, NULL);
                    resourcesAssigned = TRUE;
                } else {

                    switch (requestTable[i].Status) {
                    
                    case STATUS_RETRY:

                        tryAgain = TRUE;
                        break;

                    case STATUS_DEVICE_CONFIGURATION_ERROR:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_NO_SOFTCONFIG);
                        break;

                    case STATUS_PNP_BAD_MPS_TABLE:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_BIOS_TABLE);
                        break;

                    case STATUS_PNP_TRANSLATION_FAILED:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_TRANSLATION_FAILED);
                        break;

                    case STATUS_PNP_IRQ_TRANSLATION_FAILED:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_IRQ_TRANSLATION_FAILED);
                        break;

                    case STATUS_RESOURCE_TYPE_NOT_FOUND:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_UNKNOWN_RESOURCE);
                        break;

                    default:

                        PipSetDevNodeProblem(deviceNode, CM_PROB_NORMAL_CONFLICT);
                        break;
                    }
                }
            }
            ExFreePool(requestTable);
        }
        ExFreePool(context);
    }

    return resourcesAssigned;
}

NTSTATUS
IopProcessAssignResourcesWorker(
   IN PDEVICE_NODE  DeviceNode,
   IN PVOID         Context
   )
/*++

Routine Description:

    This functions searches the DeviceNode subtree to locate all the device objects
    which have been successfully added to their drivers and waiting for resources to
    be started.

Parameters:

    DeviceNode - specifies the device node whose subtree is to be checked for AssignRes.

    Context - specifies a pointer to a structure to pass resource assignment information.

Return Value:

    TRUE.

--*/
{
    PDEVICE_LIST_CONTEXT resourceContext = (PDEVICE_LIST_CONTEXT) Context;

    PAGED_CODE();

    //
    // If the device node/object has not been add, skip it.
    //

    if (resourceContext->Reallocation &&
        (PipIsDevNodeProblem(DeviceNode, CM_PROB_NORMAL_CONFLICT) ||
         PipIsDevNodeProblem(DeviceNode, CM_PROB_TRANSLATION_FAILED) ||
         PipIsDevNodeProblem(DeviceNode, CM_PROB_IRQ_TRANSLATION_FAILED))) {

        PipClearDevNodeProblem(DeviceNode);
    }

    if (!PipDoesDevNodeHaveProblem(DeviceNode)) {

        //
        // If the device object has not been started and has no resources yet.
        // Append it to our list.
        //

        if (DeviceNode->State == DeviceNodeDriversAdded) {

               resourceContext->DeviceList[resourceContext->DeviceCount] =
                                  DeviceNode->PhysicalDeviceObject;

               resourceContext->DeviceCount++;

        } else {

            //
            // Acquire enumeration mutex to make sure its children won't change by
            // someone else.  Note, the current device node is protected by its parent's
            // Enumeration mutex and it won't disappear either.
            //

            //
            // Recursively mark all of our children deleted.
            //

            PipForAllChildDeviceNodes(DeviceNode, IopProcessAssignResourcesWorker, Context);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopWriteAllocatedResourcesToRegistry (
    PDEVICE_NODE DeviceNode,
    PCM_RESOURCE_LIST CmResourceList,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes allocated resources for a device to its control key of device
    instance path key.

Arguments:

    DeviceNode - Supplies a pointer to the device node structure of the device.

    CmResourceList - Supplies a pointer to the device's allocated CM resource list.

    Length - Supplies the length of the CmResourceList.

Return Value:

    The status returned is the final completion status of the operation.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject = DeviceNode->PhysicalDeviceObject;
    HANDLE handle, handlex;
    UNICODE_STRING unicodeName;

    PiLockPnpRegistry(FALSE);

    status = IopDeviceObjectToDeviceInstance(
                                    deviceObject,
                                    &handlex,
                                    KEY_ALL_ACCESS);
    if (NT_SUCCESS(status)) {

        //
        // Open the LogConfig key of the device instance.
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         handlex,
                                         &unicodeName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        ZwClose(handlex);
        if (NT_SUCCESS(status)) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_ALLOC_CONFIG);
            if (CmResourceList) {
                status = ZwSetValueKey(
                              handle,
                              &unicodeName,
                              TITLE_INDEX_VALUE,
                              REG_RESOURCE_LIST,
                              CmResourceList,
                              Length
                              );
            } else {
                status = ZwDeleteValueKey(handle, &unicodeName);
            }
            ZwClose(handle);
        }
    }
    PiUnlockPnpRegistry();
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnprlist.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    pnprlist.c

Abstract:

    This module contains routines to manipulate relations list.  Relation lists
    are used by Plug and Play during the processing of device removal and
    ejection.

    These routines are all pageable and can't be called at raised IRQL or with
    a spinlock held.

Author:

    Robert Nelson (robertn) Apr, 1998.

Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'lrpP')
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopAddRelationToList)
#pragma alloc_text(PAGE, IopAllocateRelationList)
#pragma alloc_text(PAGE, IopCompressRelationList)
#pragma alloc_text(PAGE, IopEnumerateRelations)
#pragma alloc_text(PAGE, IopFreeRelationList)
#pragma alloc_text(PAGE, IopGetRelationsCount)
#pragma alloc_text(PAGE, IopGetRelationsTaggedCount)
#pragma alloc_text(PAGE, IopIsRelationInList)
#pragma alloc_text(PAGE, IopMergeRelationLists)
#pragma alloc_text(PAGE, IopRemoveIndirectRelationsFromList)
#pragma alloc_text(PAGE, IopRemoveRelationFromList)
#pragma alloc_text(PAGE, IopSetAllRelationsTags)
#pragma alloc_text(PAGE, IopSetRelationsTag)
#endif

#define RELATION_FLAGS              0x00000003

#define RELATION_FLAG_TAGGED        0x00000001
#define RELATION_FLAG_DESCENDANT    0x00000002

NTSTATUS
IopAddRelationToList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DirectDescendant,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Adds an element to a relation list.

    If this is the first DeviceObject of a particular level then a new
    RELATION_LIST_ENTRY will be allocated.

    This routine should only be called on an uncompressed relation list,
    otherwise it is likely that STATUS_INVALID_PARAMETER will be returned.

Arguments:

    List                Relation list to which the DeviceObject is added.

    DeviceObject        DeviceObject to be added to List.  It must be a
                        PhysicalDeviceObject (PDO).

    DirectDescendant    Indicates whether DeviceObject is a direct descendant of
                        the original target device of this remove.

    Tagged              Indicates whether DeviceObject should be tagged in List.

Return Value:

    STATUS_SUCCESS

        The DeviceObject was added successfully.

    STATUS_OBJECT_NAME_COLLISION

        The DeviceObject already exists in the relation list.

    STATUS_INSUFFICIENT_RESOURCES

        There isn't enough PagedPool available to allocate a new
        RELATION_LIST_ENTRY.

    STATUS_INVALID_PARAMETER

        The level of the DEVICE_NODE associated with DeviceObject is less than
        FirstLevel or greater than the MaxLevel.

    STATUS_NO_SUCH_DEVICE

        DeviceObject is not a PhysicalDeviceObject (PDO), it doesn't have a
        DEVICE_NODE associated with it.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;
    ULONG                   flags;

    PAGED_CODE();

    flags = 0;

    if (Tagged) {
        Tagged = 1;
        flags |= RELATION_FLAG_TAGGED;
    }

    if (DirectDescendant) {
        flags |= RELATION_FLAG_DESCENDANT;
    }

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        level = deviceNode->Level;

        //
        // Since this routine is called with the DeviceNode Tree locked and
        // List is initially allocated with enough entries to hold the deepest
        // DEVICE_NODE this ASSERT should never fire.  If it does then either
        // the tree is changing or we were given a compressed list.
        //
        ASSERT(List->FirstLevel <= level && level <= List->MaxLevel);

        if (List->FirstLevel <= level && level <= List->MaxLevel) {

            if ((entry = List->Entries[ level - List->FirstLevel ]) == NULL) {

                //
                // This is the first DeviceObject of its level, allocate a new
                // RELATION_LIST_ENTRY.
                //
                entry = ExAllocatePool( PagedPool,
                                        sizeof(RELATION_LIST_ENTRY) +
                                        IopNumberDeviceNodes * sizeof(PDEVICE_OBJECT));

                if (entry == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                // We always allocate enough Devices to hold the whole tree as
                // a simplification.  Since each entry is a PDEVICE_OBJECT and
                // there is generally under 50 devices on a machine this means
                // under 1K for each entry.  The excess space will be freed when
                // the list is compressed.
                //
                entry->Count = 0;
                entry->MaxCount = IopNumberDeviceNodes;

                List->Entries[ level - List->FirstLevel ] = entry;
            }

            //
            // There should always be room for a DeviceObject since the Entry is
            // initially dimensioned large enough to hold all the DEVICE_NODES
            // in the system.
            //
            ASSERT(entry->Count < entry->MaxCount);

            if (entry->Count < entry->MaxCount) {
                //
                // Search the list to see if DeviceObject has already been
                // added.
                //
                for (index = 0; index < entry->Count; index++) {
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        //
                        // DeviceObject already exists in the list.  However
                        // the Direct Descendant flag may differ.  We will
                        // override it if DirectDescendant is TRUE.  This could
                        // happen if we merged two relation lists.

                        if (DirectDescendant) {
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_DESCENDANT);
                        }

                        return STATUS_OBJECT_NAME_COLLISION;
                    }
                }
            } else {
                //
                // There isn't room in the Entry for another DEVICE_OBJECT, the
                // list has probably already been compressed.
                //
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Take out a reference on DeviceObject, we will release it when we
            // free the list or remove the DeviceObject from the list.
            //
            ObReferenceObject( DeviceObject );

            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)DeviceObject | flags);
            entry->Count++;

            List->Count++;
            List->TagCount += Tagged;

            return STATUS_SUCCESS;
        } else {
            //
            // There isn't an Entry available for the level of this
            // DEVICE_OBJECT, the list has probably already been compressed.
            //

            return STATUS_INVALID_PARAMETER;
        }
    } else {
        //
        // DeviceObject is not a PhysicalDeviceObject (PDO).
        //
        return STATUS_NO_SUCH_DEVICE;
    }
}

PRELATION_LIST
IopAllocateRelationList(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode
    )

/*++

Routine Description:

    Allocate a new Relations List.  The list is initially sized large enough to
    hold the deepest DEVICE_NODE encountered since the system started.

Arguments:

    OperationCode - Type of operation the relation list is being allocated for.

Return Value:

    Newly allocated list if enough PagedPool is available, otherwise NULL.

--*/

{
    PRELATION_LIST  list;
    ULONG           maxLevel;
    ULONG           listSize;

    PAGED_CODE();

    //
    // Level number of the deepest DEVICE_NODE allocated since the system
    // started.
    //
    maxLevel = IopMaxDeviceNodeLevel;
    listSize = sizeof(RELATION_LIST) + maxLevel * sizeof(PRELATION_LIST_ENTRY);

    list = (PRELATION_LIST) PiAllocateCriticalMemory(
        OperationCode,
        PagedPool,
        listSize,
        0
        );

    if (list != NULL) {

        RtlZeroMemory(list, listSize);
        // list->FirstLevel = 0;
        // list->Count = 0;
        // list->Tagged = 0;
        list->MaxLevel = maxLevel;
    }

    return list;
}

NTSTATUS
IopCompressRelationList(
    IN OUT PRELATION_LIST *List
    )

/*++

Routine Description:

    Compresses the relation list by reallocating the list and all the entries so
    that they a just large enough to hold their current contents.

    Once a list has been compressed IopAddRelationToList and
    IopMergeRelationLists targetting this list are both likely to fail.

Arguments:

    List    Relation List to compress.

Return Value:

    STATUS_SUCCESS

        The list was compressed.  Although this routine does allocate memory and
        the allocation can fail, the routine itself will never fail.  Since the
        memory we are allocating is always smaller then the memory it is
        replacing we just keep the old memory if the allocation fails.

--*/

{
    PRELATION_LIST          oldList, newList;
    PRELATION_LIST_ENTRY    oldEntry, newEntry;
    ULONG                   lowestLevel;
    ULONG                   highestLevel;
    ULONG                   index;

    PAGED_CODE();

    oldList = *List;

    //
    // Initialize lowestLevel and highestLevel with illegal values chosen so
    // that the first real entry will override them.
    //
    lowestLevel = oldList->MaxLevel;
    highestLevel = oldList->FirstLevel;

    //
    // Loop through the list looking for allocated entries.
    //
    for (index = 0; index <= (oldList->MaxLevel - oldList->FirstLevel); index++) {

        if ((oldEntry = oldList->Entries[ index ]) != NULL) {
            //
            // This entry is allocated, update lowestLevel and highestLevel if
            // necessary.
            //
            if (lowestLevel > index) {
                lowestLevel = index;
            }

            if (highestLevel < index) {
                highestLevel = index;
            }

            if (oldEntry->Count < oldEntry->MaxCount) {

                //
                // This entry is only partially full.  Allocate a new entry
                // which is just the right size to hold the current number of
                // PDEVICE_OBJECTs.
                //
                newEntry = ExAllocatePool( PagedPool,
                                           sizeof(RELATION_LIST_ENTRY) +
                                           (oldEntry->Count - 1) * sizeof(PDEVICE_OBJECT));

                if (newEntry != NULL) {

                    //
                    // Initialize Count and MaxCount to the number of
                    // PDEVICE_OBJECTs in the old entry.
                    //
                    newEntry->Count = oldEntry->Count;
                    newEntry->MaxCount = oldEntry->Count;

                    //
                    // Copy the PDEVICE_OBJECTs from the old entry to the new
                    // one.
                    //
                    RtlCopyMemory( newEntry->Devices,
                                   oldEntry->Devices,
                                   oldEntry->Count * sizeof(PDEVICE_OBJECT));

                    //
                    // Free the old entry and store the new entry in the list.
                    //
                    ExFreePool( oldEntry );

                    oldList->Entries[ index ] = newEntry;
                }
            }
        }
    }

    //
    // Assert that the old list isn't empty.
    //
    ASSERT(lowestLevel <= highestLevel);

    if (lowestLevel > highestLevel) {
        //
        // The list is empty - we shouldn't get asked to compress an empty list
        // but lets do it anyways.
        //
        lowestLevel = 0;
        highestLevel = 0;
    }

    //
    // Check if the old list had unused entries at the beginning or the end of
    // the Entries array.
    //
    if (lowestLevel != oldList->FirstLevel || highestLevel != oldList->MaxLevel) {

        //
        // Allocate a new List with just enough Entries to hold those between
        // FirstLevel and MaxLevel inclusive.
        //
        newList = ExAllocatePool( PagedPool,
                                  sizeof(RELATION_LIST) +
                                  (highestLevel - lowestLevel) * sizeof(PRELATION_LIST_ENTRY));

        if (newList != NULL) {
            //
            // Copy the old list to the new list and return it to the caller.
            //
            newList->Count = oldList->Count;
            newList->TagCount = oldList->TagCount;
            newList->FirstLevel = lowestLevel;
            newList->MaxLevel = highestLevel;

            RtlCopyMemory( newList->Entries,
                           &oldList->Entries[ lowestLevel ],
                           (highestLevel - lowestLevel + 1) * sizeof(PRELATION_LIST_ENTRY));

            ExFreePool( oldList );

            *List = newList;
        }
    }

    return STATUS_SUCCESS;
}

BOOLEAN
IopEnumerateRelations(
    IN      PRELATION_LIST  List,
    IN OUT  PULONG          Marker,
    OUT     PDEVICE_OBJECT *DeviceObject,
    OUT     BOOLEAN        *DirectDescendant    OPTIONAL,
    OUT     BOOLEAN        *Tagged              OPTIONAL,
    IN      BOOLEAN         Reverse
    )
/*++

Routine Description:

    Enumerates the relations in a list.

Arguments:

    List                Relation list to be enumerated.

    Marker              Cookie used to maintain current place in the list.  It
                        must be initialized to 0 the first time
                        IopEnumerateRelations is called.

    DeviceObject        Returned Relation.

    DirectDescendant    If specified then it is set if the relation is a direct
                        descendant of the original target device of this remove.

    Tagged              If specified then it is set if the relation is tagged
                        otherwise it is cleared.

    Reverse             Direction of traversal, TRUE means from deepest to
                        closest to the root, FALSE means from the root down.

                        If Reverse changes on a subsequent call then the
                        previously enumerated relation is skipped.  For example,
                        given the sequence A, B, C, D, E.  If
                        IopEnumerateRelations is called thrice with Reverse set
                        to FALSE and then called repeatedly with Reverse set to
                        TRUE until it returns FALSE, the sequence would be: A,
                        B, C, B, A.

                        Once the end has been reached it is not possible to
                        change directions.

Return Value:

    TRUE - DeviceObject and optionally Tagged have been set to the next
           relation.

    FALSE - There are no more relations.

--*/
{
    PRELATION_LIST_ENTRY    entry;
    LONG                    levelIndex;
    ULONG                   entryIndex;

    PAGED_CODE();

    //
    // The basic assumptions of our use of Marker is that there will never be
    // more than 16M DeviceNodes at any one level and that the tree will never
    // be more than 127 deep.
    //
    // The format of Marker is
    //      Bit 31      = Valid (used to distinguish the initial call
    //      Bit 30-24   = Current index into entries
    //      Bit 23-0    = Current index into devices, 0xFFFFFF means last
    //
    if (*Marker == ~0U) {
        //
        // We've reached the end.
        //
        return FALSE;
    }

    if (*Marker == 0) {
        //
        // This is the initial call to IopEnumerateRelations
        //
        if (Reverse) {
            //
            // Initialize levelIndex to the last element of Entries
            //
            levelIndex = List->MaxLevel - List->FirstLevel;
        } else {
            //
            // Initialize levelIndex to the first element of Entries
            //
            levelIndex = 0;
        }
        //
        // Initialize entryIndex to unknown element of Devices.  If we are going
        // in reverse then this will appear to be beyond the last element and
        // we'll adjust it the last one.  If we are going forward then this will
        // appear to be just prior to the first element so when we increment it,
        // it will become zero.
        //
        entryIndex = ~0U;
    } else {
        //
        // Bit 31 is our valid bit, used to distinguish level 0, device 0 from
        // the first time call.
        //
        ASSERT(*Marker & ((ULONG)1 << 31));
        //
        // Current level stored in bits 30-24.
        //
        levelIndex = (*Marker >> 24) & 0x7F;
        //
        // Current device stored in bits 23-0.
        //
        entryIndex = *Marker & 0x00FFFFFF;
    }

    if (Reverse) {
        //
        // We are traversing the list bottom up, from the deepest device towards
        // the root.
        //
        for ( ; levelIndex >= 0; levelIndex--) {

            //
            // Since the Entries array can be sparse find the next allocated
            // Entry.
            //
            if ((entry = List->Entries[ levelIndex ]) != NULL) {

                if (entryIndex > entry->Count) {
                    //
                    // entryIndex (the current one) is greater than Count, this
                    // will be the case where it is 0xFFFFFF, in other words
                    // unspecified.  Adjust it so that it is one past the last
                    // one in this Entry.
                    //
                    entryIndex = entry->Count;
                }

                if (entryIndex > 0) {

                    //
                    // The current entry is beyond the first entry so the next
                    // entry (which is the one we are looking for is immediately
                    // prior, adjust entryIndex.
                    //
                    entryIndex--;

                    //
                    // Get the device object and remove the tag.
                    //
                    *DeviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS);

                    if (Tagged != NULL) {
                        //
                        // The caller is interested in the tag value.
                        //
                        *Tagged = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_TAGGED);
                    }

                    if (DirectDescendant != NULL) {
                        //
                        // The caller is interested in the DirectDescendant value.
                        //
                        *DirectDescendant = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_DESCENDANT);
                    }

                    //
                    // Update the marker (info for current device)
                    //
                    *Marker = ((ULONG)1 << 31) | (levelIndex << 24) | (entryIndex & 0x00FFFFFF);

                    return TRUE;
                }
            }

            //
            // The current device object has been deleted or the current
            // device object is the first one in this Entry.
            // We need to continue to search backwards through the other
            // Entries.
            //
            entryIndex = ~0U;
        }
    } else {
        for ( ; levelIndex <= (LONG)(List->MaxLevel - List->FirstLevel); levelIndex++) {

            //
            // Since the Entries array can be sparse find the next allocated
            // Entry.
            //
            if ((entry = List->Entries[ levelIndex ]) != NULL) {

                //
                // entryIndex is the index of the current device or 0xFFFFFFFF
                // if this is the first time we have been called or the current
                // current device is the last one in its Entry.  Increment the
                // index to point to the next device.
                //
                entryIndex++;

                if (entryIndex < entry->Count) {

                    //
                    // The next device is within this entry.
                    //
                    //
                    // Get the device object and remove the tag.
                    //
                    *DeviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS);

                    if (Tagged != NULL) {
                        //
                        // The caller is interested in the tag value.
                        //
                        *Tagged = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_TAGGED);
                    }

                    if (DirectDescendant != NULL) {
                        //
                        // The caller is interested in the DirectDescendant value.
                        //
                        *DirectDescendant = (BOOLEAN)((ULONG_PTR)entry->Devices[ entryIndex ] & RELATION_FLAG_DESCENDANT);
                    }

                    //
                    // Update the marker (info for current device)
                    //
                    *Marker = ((ULONG)1 << 31) | (levelIndex << 24) | (entryIndex & 0x00FFFFFF);

                    return TRUE;
                }
            }

            //
            // The current device has been removed or we have processed the
            // last device in the current entry.
            // Set entryIndex so that it is just before the first device in
            // the next entry.  Continue the search looking for the next
            // allocated Entry.
            //
            entryIndex = ~0U;
        }
    }

    //
    // We are at the end of the list
    //
    *Marker = ~0U;
    *DeviceObject = NULL;

    if (Tagged != NULL) {
        *Tagged = FALSE;
    }

    if (DirectDescendant != NULL) {
        *DirectDescendant = FALSE;
    }

    return FALSE;
}

VOID
IopFreeRelationList(
    IN PRELATION_LIST List
    )
/*++

Routine Description:

    Free a relation list allocated by IopAllocateRelationList.

Arguments:

    List    The list to be freed.

Return Value:

    NONE.

--*/
{
    PRELATION_LIST_ENTRY    entry;
    ULONG                   levelIndex;
    ULONG                   entryIndex;

    PAGED_CODE();

    //
    // Search the list looking for allocated Entries.
    //
    for (levelIndex = 0; levelIndex <= (List->MaxLevel - List->FirstLevel); levelIndex++) {

        if ((entry = List->Entries[ levelIndex ]) != NULL) {
            //
            // This entry has been allocated.
            //
            for (entryIndex = 0; entryIndex < entry->Count; entryIndex++) {
                //
                // Dereference all the Devices in the entry.
                //
                ObDereferenceObject((PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ entryIndex ] & ~RELATION_FLAGS));
            }
            //
            // Free the Entry.
            //
            ExFreePool( entry );
        }
    }

    //
    // Free the list.  It isn't necessary to dereference the DeviceObject that
    // was the original target that caused the list to be created.  This
    // DeviceObject is also in one of the Entries and its reference is taken
    // and released there.
    //
    ExFreePool( List );
}

ULONG
IopGetRelationsCount(
    PRELATION_LIST List
    )

/*++

Routine Description:

    Returns the total number of relations (Device Objects) in all the entries.

Arguments:

    List    Relation List.

Return Value:

    Count of relations (Device Objects).

--*/

{
    PAGED_CODE();

    return List->Count;
}

ULONG
IopGetRelationsTaggedCount(
    PRELATION_LIST List
    )

/*++

Routine Description:

    Returns the total number of relations (Device Objects) in all the entries
    which are tagged.

Arguments:

    List    Relation List.

Return Value:

    Count of tagged relations (Device Objects).

--*/

{
    PAGED_CODE();

    return List->TagCount;
}

BOOLEAN
IopIsRelationInList(
    PRELATION_LIST List,
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Checks if a relation (Device Object) exists in the specified relation list.

Arguments:

    List            Relation list to check.

    DeviceObject    Relation to be checked.


Return Value:

    TRUE

        Relation exists.

    FALSE

        Relation is not in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        //
        // The device object is a PDO.
        //
        level = deviceNode->Level;

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            //
            // The level is within the range of levels stored in this list.
            //
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                //
                // There is an Entry for this level.
                //
                for (index = 0; index < entry->Count; index++) {
                    //
                    // For each Device in the entry, compare it to the given
                    // DeviceObject
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {
                        //
                        // It matches
                        //
                        return TRUE;
                    }
                }
            }
        }
    }

    //
    // It wasn't a PDO
    //      or the level wasn't in the range of levels in this list
    //      or there are no DeviceObjects at the same level in this list
    //      or the DeviceObject isn't in the Entry for its level in this list
    //
    return FALSE;
}

NTSTATUS
IopMergeRelationLists(
    IN OUT PRELATION_LIST TargetList,
    IN PRELATION_LIST SourceList,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Merges two relation lists by copying all the relations from the source list
    to the target list.  Source list remains unchanged.

Arguments:

    TargetList  List to which the relations from Sourcelist are added.

    SourceList  List of relations to be added to TargetList.

    Tagged      TRUE if relations from SourceList should be tagged when added to
                TargetList.  If FALSE then relations added from SourceList are
                untagged.

Return Value:

    STATUS_SUCCESS

        All the relations in SourceList were added to TargetList successfully.

    STATUS_OBJECT_NAME_COLLISION

        One of the relations in SourceList already exists in TargetList.  This
        is a fatal error and TargetList may already have some of the relations
        from SourceList added.  This could be dealt with more gracefully if
        necessary but the current callers of IopMergeRelationLists avoid this
        situation.

    STATUS_INSUFFICIENT_RESOURCES

        There isn't enough PagedPool available to allocate a new
        RELATION_LIST_ENTRY.

    STATUS_INVALID_PARAMETER

        The level of one of the relations in SourceList is less than FirstLevel
        or greater than the MaxLevel.  This is a fatal error and TargetList may
        already have some of the relations from SourceList added.  The only way
        this could happen is if the tree lock isn't held or if TargetList has
        been compressed by IopCompressRelationList.  Both situations would be
        bugs in the caller.

    STATUS_NO_SUCH_DEVICE

        One of the relations in SourceList is not a PhysicalDeviceObject (PDO),
        it doesn't have a DEVICE_NODE associated with it.  This is a fatal error
        and TargetList may already have some of the relations from SourceList
        added.  This should never happen since it was a PDO when it was added to
        SourceList.


--*/

{
    PRELATION_LIST_ENTRY    entry;
    LONG                    levelIndex;
    LONG                    entryIndex;
    LONG                    change;
    LONG                    maxIndex;
    NTSTATUS                status;
    NTSTATUS                finalStatus;

    PAGED_CODE();

    finalStatus = STATUS_SUCCESS;
    change      = 1;
    levelIndex = 0;
    maxIndex    = SourceList->MaxLevel - SourceList->FirstLevel;
    for ( ; ; ) {
        //
        // Stop at maxIndex if moving forward or at 0 otherwise.
        //
        if (    (change == 1 && levelIndex > maxIndex) ||
                (change == -1 && levelIndex < 0)) {
            break;
        }
        entry = SourceList->Entries[levelIndex];
        if (entry) {
            entryIndex = (change == 1)? 0 : entry->Count - 1;
            for ( ; ; ) {
                if (change == 1) {
                    //
                    // Stop if we added all DOs in this entry.
                    //
                    if (entryIndex > (LONG)entry->Count) {
                        break;
                    }
                    //
                    // For each Device in the Entry, add it to the target List.
                    //
                    status = IopAddRelationToList( TargetList,
                                                   (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[entryIndex] & ~RELATION_FLAGS),
                                                   FALSE,
                                                   Tagged);
                    if (!NT_SUCCESS(status)) {
                        //
                        // We need to undo the damage on failure by unwinding and removing DOs we added..
                        //
                        finalStatus = status;
                        change = -1;
                    }
                } else {
                    //
                    // Stop at 0 if we are unwinding.
                    //
                    if (entryIndex < 0) {
                        break;
                    }
                    status = IopRemoveRelationFromList( TargetList,
                                                        (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[entryIndex] & ~RELATION_FLAGS));
                    ASSERT(NT_SUCCESS(status));
                }
                entryIndex += change;
            }
        }
        levelIndex += change;
    }

    return finalStatus;
}

NTSTATUS
IopRemoveIndirectRelationsFromList(
    IN PRELATION_LIST List
    )

/*++

Routine Description:

    Removes all the relations without the DirectDescendant flag from a relation
    list.

Arguments:

    List    List from which to remove the relations.


Return Value:

    STATUS_SUCCESS

        The relations were removed successfully.

--*/

{
    PDEVICE_OBJECT          deviceObject;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    //
    // For each Entry in the list.
    //
    for (level = List->FirstLevel; level <= List->MaxLevel; level++) {

        //
        // If the entry is allocated.
        //
        if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {

            //
            // For each Device in the list.
            //
            for (index = entry->Count - 1; index >= 0; index--) {
                if (!((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_DESCENDANT)) {

                    deviceObject = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS);

                    ObDereferenceObject( deviceObject );

                    if ((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) {
                        List->TagCount--;
                    }

                    if (index < ((LONG)entry->Count - 1)) {

                        RtlMoveMemory( &entry->Devices[ index ],
                                        &entry->Devices[ index + 1 ],
                                        (entry->Count - index - 1) * sizeof(PDEVICE_OBJECT));
                    }

                    if (--entry->Count == 0) {
                        List->Entries[ level - List->FirstLevel ] = NULL;
                        ExFreePool(entry);
                    }

                    List->Count--;
                }
            }
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
IopRemoveRelationFromList(
    PRELATION_LIST List,
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Removes a relation from a relation list.

Arguments:

    List            List from which to remove the relation.

    DeviceObject    Relation to remove.

Return Value:

    STATUS_SUCCESS

        The relation was removed successfully.

    STATUS_NO_SUCH_DEVICE

        The relation doesn't exist in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        level = deviceNode->Level;

        ASSERT(List->FirstLevel <= level && level <= List->MaxLevel);

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                for (index = entry->Count - 1; index >= 0; index--) {
                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        ObDereferenceObject( DeviceObject );

                        if (((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) != 0) {
                            List->TagCount--;
                        }
                        if (index < ((LONG)entry->Count - 1)) {

                            RtlMoveMemory( &entry->Devices[ index ],
                                           &entry->Devices[ index + 1 ],
                                           (entry->Count - index - 1) * sizeof(PDEVICE_OBJECT));
                        }

                        if (--entry->Count == 0) {
                            List->Entries[ level - List->FirstLevel ] = NULL;
                            ExFreePool(entry);
                        }

                        List->Count--;

                        return STATUS_SUCCESS;
                    }
                }
            }
        }
    }
    return STATUS_NO_SUCH_DEVICE;
}

VOID
IopSetAllRelationsTags(
    PRELATION_LIST List,
    BOOLEAN Tagged
    )

/*++

Routine Description:

    Tags or untags all the relations in a relations list.

Arguments:

    List    Relation list containing relations to be tagged or untagged.

    Tagged  TRUE if the relations should be tagged, FALSE if they are to be
            untagged.

Return Value:

    NONE

--*/

{
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    ULONG                   index;

    PAGED_CODE();

    //
    // For each Entry in the list.
    //
    for (level = List->FirstLevel; level <= List->MaxLevel; level++) {

        //
        // If the entry is allocated.
        //
        if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {

            //
            // For each Device in the list.
            //
            for (index = 0; index < entry->Count; index++) {

                //
                // Set or clear the tag based on the argument Tagged.
                //
                if (Tagged) {
                    entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_TAGGED);
                } else {
                    entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAG_TAGGED);
                }
            }
        }
    }

    //
    // If we are setting the tags then update the TagCount to the number of
    // relations in the list.  Otherwise reset it to zero.
    //
    List->TagCount = Tagged ? List->Count : 0;
}

NTSTATUS
IopSetRelationsTag(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Tagged
    )

/*++

Routine Description:

    Sets or clears a tag on a specified relation in a relations list.  This
    routine is also used by some callers to determine if a relation exists in
    a list and if so to set the tag.

Arguments:

    List            List containing relation to be tagged or untagged.

    DeviceObject    Relation to be tagged or untagged.

    Tagged          TRUE if relation is to be tagged, FALSE if it is to be
                    untagged.

Return Value:

    STATUS_SUCCESS

        The relation was tagged successfully.

    STATUS_NO_SUCH_DEVICE

        The relation doesn't exist in the list.

--*/

{
    PDEVICE_NODE            deviceNode;
    PRELATION_LIST_ENTRY    entry;
    ULONG                   level;
    LONG                    index;

    PAGED_CODE();

    if ((deviceNode = DeviceObject->DeviceObjectExtension->DeviceNode) != NULL) {
        //
        // DeviceObject is a PhysicalDeviceObject (PDO), get its level.
        //
        level = deviceNode->Level;

        if (List->FirstLevel <= level && level <= List->MaxLevel) {
            //
            // The level is within the range of levels in this List.
            //
            if ((entry = List->Entries[ level - List->FirstLevel ]) != NULL) {
                //
                // The Entry for this level is allocated.  Search each device
                // in the Entry looking for a match.
                //
                for (index = entry->Count - 1; index >= 0; index--) {

                    if (((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAGS) == (ULONG_PTR)DeviceObject) {

                        //
                        // We found a match
                        //
                        if ((ULONG_PTR)entry->Devices[ index ] & RELATION_FLAG_TAGGED) {
                            //
                            // The relation is already tagged so to simplify the
                            // logic below decrement the TagCount.  We'll
                            // increment it later if the caller still wants it
                            // to be tagged.
                            //
                            List->TagCount--;
                        }

                        if (Tagged) {
                            //
                            // Set the tag and increment the number of tagged
                            // relations.
                            //
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] | RELATION_FLAG_TAGGED);
                            List->TagCount++;
                        } else {
                            //
                            // Clear the tag.
                            //
                            entry->Devices[ index ] = (PDEVICE_OBJECT)((ULONG_PTR)entry->Devices[ index ] & ~RELATION_FLAG_TAGGED);
                        }

                        return STATUS_SUCCESS;
                    }
                }
            }
        }
    }

    //
    // It wasn't a PDO
    //      or the level wasn't in the range of levels in this list
    //      or there are no DeviceObjects at the same level in this list
    //      or the DeviceObject isn't in the Entry for its level in this list
    //
    return STATUS_NO_SUCH_DEVICE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnpsubs.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsubs.c

Abstract:

    This module contains the plug-and-play subroutines for the
    I/O system.


Author:

    Shie-Lin Tzong (shielint) 3-Jan-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

//
// Data structure for each entry in the device reference table.
//
typedef struct _DEVICE_REFERENCE {
    PDEVICE_OBJECT  DeviceObject;   // PDO
    PUNICODE_STRING DeviceInstance; // Pointer to instance path for the devnode for the PDO
} DEVICE_REFERENCE, *PDEVICE_REFERENCE;

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'uspP')
#endif

#define PpLogEvent(s, r, st, d, ds)

//
// Regular data segment
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// Table to map InstancePath to DO.
//
RTL_GENERIC_TABLE PpDeviceReferenceTable;

//
// Lock to synchronize access to the table.
//
FAST_MUTEX PpDeviceReferenceTableLock;

//
// Table of BusType GUIDs
//
GUID *PpBusTypeGuidArray;

//
// Number of entries in the BusTypeGuid table.
//
ULONG PpBusTypeGuidCount;

//
// Maximum number of entries in the BusTypeGuid table.
//
ULONG PpBusTypeGuidCountMax;

//
// Lock used to synchronize access to the BusTypeGuid table.
//
FAST_MUTEX PpBusTypeGuidLock;

//
// Prototype of internal functions
//

VOID
IopDisableDevice(
    IN PDEVICE_NODE DeviceNode
    );

BOOLEAN
IopDeleteKeyRecursiveCallback(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    );

NTSTATUS
PipGenerateMadeupNodeName (
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PUNICODE_STRING MadeupNodeName
    );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareInstancePath (
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

ULONG
PiFixupID(
    IN PWCHAR ID,
    IN ULONG MaxIDLength,
    IN BOOLEAN Multi,
    IN ULONG AllowedSeparators,
    IN PUNICODE_STRING LogString OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpInitializeDeviceReferenceTable)
#pragma alloc_text(INIT, PipRegMultiSzToUnicodeStrings)
#pragma alloc_text(INIT, PipFreeUnicodeStringList)
#pragma alloc_text(INIT, PpBusTypeGuidInitialize)

#pragma alloc_text(PAGE, PipApplyFunctionToServiceInstances)
#pragma alloc_text(PAGE, PipApplyFunctionToSubKeys)
#pragma alloc_text(PAGE, IopCleanupDeviceRegistryValues)
#pragma alloc_text(PAGE, IopCmResourcesToIoResources)
#pragma alloc_text(PAGE, PipConcatenateUnicodeStrings)
#pragma alloc_text(PAGE, PipCreateMadeupNode)
#pragma alloc_text(PAGE, PipGenerateMadeupNodeName)
#pragma alloc_text(PAGE, IopCreateRegistryKeyEx)
#pragma alloc_text(PAGE, IopDeleteKeyRecursive)
#pragma alloc_text(PAGE, IopDeleteKeyRecursiveCallback)
#pragma alloc_text(PAGE, IopDeleteLegacyKey)
#pragma alloc_text(PAGE, IopDetermineResourceListSize)
#pragma alloc_text(PAGE, IopSaveDeviceCapabilities)
#pragma alloc_text(PAGE, IopQueryAndSaveDeviceNodeCapabilities)
#pragma alloc_text(PAGE, IopDeviceObjectFromDeviceInstance)
#pragma alloc_text(PAGE, IopDeviceObjectToDeviceInstance)
#pragma alloc_text(PAGE, IopDisableDevice)
#pragma alloc_text(PAGE, IopDriverLoadingFailed)
#pragma alloc_text(PAGE, IopFilterResourceRequirementsList)
#pragma alloc_text(PAGE, IopGetDeviceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, IopGetDeviceResourcesFromRegistry)
#pragma alloc_text(PAGE, PipGetServiceInstanceCsConfigFlags)
#pragma alloc_text(PAGE, IopIsAnyDeviceInstanceEnabled)
#pragma alloc_text(PAGE, IopIsDeviceInstanceEnabled)
#pragma alloc_text(PAGE, PipIsDuplicatedDevices)
#pragma alloc_text(PAGE, IopIsLegacyDriver)
#pragma alloc_text(PAGE, IopMergeCmResourceLists)
#pragma alloc_text(PAGE, IopMergeFilteredResourceRequirementsList)
#pragma alloc_text(PAGE, IopOpenCurrentHwProfileDeviceInstanceKey)
#pragma alloc_text(PAGE, IopOpenRegistryKeyEx)
#pragma alloc_text(PAGE, PipOpenServiceEnumKeys)
#pragma alloc_text(PAGE, IopPrepareDriverLoading)
#pragma alloc_text(PAGE, PipReadDeviceConfiguration)
#pragma alloc_text(PAGE, IopRestartDeviceNode)
#pragma alloc_text(PAGE, PipServiceInstanceToDeviceInstance)
#pragma alloc_text(PAGE, IopMapDeviceObjectToDeviceInstance)
#pragma alloc_text(PAGE, PiRegSzToString)
#pragma alloc_text(PAGE, PiCompareInstancePath)
#pragma alloc_text(PAGE, PiAllocateGenericTableEntry)
#pragma alloc_text(PAGE, PiFreeGenericTableEntry)
#pragma alloc_text(PAGE, PpSystemHiveLimitCallback)
#pragma alloc_text(PAGE, PpBusTypeGuidGetIndex)
#pragma alloc_text(PAGE, PpBusTypeGuidGet)
#pragma alloc_text(PAGE, PpQueryDeviceID)
#pragma alloc_text(PAGE, PpQueryID)
#pragma alloc_text(PAGE, PiFixupID)
#if DBG

#pragma alloc_text(PAGE, IopDebugPrint)

#endif
#endif

NTSTATUS
PipCreateMadeupNode(
    IN PUNICODE_STRING ServiceKeyName,
    OUT PHANDLE ReturnedHandle,
    OUT PUNICODE_STRING KeyName,
    OUT PULONG InstanceNumber,
    IN BOOLEAN ResourceOwned
    )

/*++

Routine Description:

    This routine creates a new instance node under System\Enum\Root\LEGACY_<ServiceKeyName>
    key and all the required default value entries.  Also a value entry under
    Service\<ServiceKeyName>\Enum is created to point to the newly created madeup
    entry.  A handle and the keyname of the new key are returned to caller.
    Caller must free the unicode string when he is done with it.

Parameters:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    ReturnedHandle - Supplies a variable to receive the handle of the
        newly created key.

    KeyName - Supplies a variable to receive the name of the newly created
        key.

    InstanceNumber - supplies a variable to receive the InstanceNumber value
        entry created under service\name\enum subkey.

    ResourceOwned - supplies a BOOLEAN variable to indicate if caller owns
        the registry resource shared.

        ADRIAO N.B. 08/25/2000 - All users of this function pass in TRUE...

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING tmpKeyName, unicodeInstanceName, unicodeString;
    UNICODE_STRING rootKeyName, unicodeValueName, unicodeKeyName;
    HANDLE handle, enumRootHandle;
    ULONG instance;
    UCHAR unicodeBuffer[20];
    ULONG tmpValue, disposition = 0;
    NTSTATUS status;
    PWSTR p;
    BOOLEAN releaseResource = FALSE;
    BOOLEAN successful;

    if (!ResourceOwned) {
        PiLockPnpRegistry(FALSE);
        releaseResource = TRUE;
    }

    //
    // Open LocalMachine\System\CurrentControlSet\Enum\Root
    //

    status = IopOpenRegistryKeyEx( &enumRootHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        goto local_exit0;
    }

    //
    // Generate the LEGACY_<ServiceKeyName> device id name from the
    // ServiceKeyName.
    //
    status = PipGenerateMadeupNodeName( ServiceKeyName,
                                        &unicodeKeyName);
    if (!NT_SUCCESS(status)) {
        ZwClose(enumRootHandle);
        goto local_exit0;
    }

    //
    // Open, and create if not already exist,
    // System\Enum\Root\LEGACY_<ServiceKeyName>
    //

    status = IopCreateRegistryKeyEx( &handle,
                                     enumRootHandle,
                                     &unicodeKeyName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );
    ZwClose(enumRootHandle);
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(&unicodeKeyName);
        goto local_exit0;
    }

    instance = 1;

    PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);
    status = ZwSetValueKey(
                handle,
                &unicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &instance,
                sizeof(instance)
                );

    instance--;
    *InstanceNumber = instance;
    PiUlongToInstanceKeyUnicodeString(&unicodeInstanceName,
                                      unicodeBuffer + sizeof(WCHAR), // reserve first WCHAR space
                                      20 - sizeof(WCHAR),
                                      instance
                                      );
    status = IopCreateRegistryKeyEx( ReturnedHandle,
                                     handle,
                                     &unicodeInstanceName,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     &disposition
                                     );
    ZwClose(handle);
    if (!NT_SUCCESS(status)) {
        RtlFreeUnicodeString(&unicodeKeyName);
        goto local_exit0;
    }

    //
    // Prepare newly created registry key name for returning to caller
    //

    *(PWSTR)unicodeBuffer = OBJ_NAME_PATH_SEPARATOR;
    unicodeInstanceName.Buffer = (PWSTR)unicodeBuffer;
    unicodeInstanceName.Length += sizeof(WCHAR);
    unicodeInstanceName.MaximumLength += sizeof(WCHAR);
    PiWstrToUnicodeString(&rootKeyName, REGSTR_KEY_ROOTENUM);
    PiWstrToUnicodeString(&tmpKeyName, L"\\");
    successful = PipConcatenateUnicodeStrings(&unicodeString, &tmpKeyName, &unicodeKeyName);
    RtlFreeUnicodeString(&unicodeKeyName);
    if (!successful) {
        goto local_exit0;
    }
    successful = PipConcatenateUnicodeStrings(&tmpKeyName, &rootKeyName, &unicodeString);
    RtlFreeUnicodeString(&unicodeString);
    if (!successful) {
        goto local_exit0;
    }
    successful = PipConcatenateUnicodeStrings(KeyName, &tmpKeyName, &unicodeInstanceName);
    if (!successful) {
        RtlFreeUnicodeString(&tmpKeyName);
        goto local_exit0;
    }

    if (disposition == REG_CREATED_NEW_KEY) {

        //
        // Create all the default value entry for the newly created key.
        // Service = ServiceKeyName
        // FoundAtEnum = 1
        // Class = "LegacyDriver"
        // ClassGUID = GUID for legacy driver class
        // ConfigFlags = 0
        //
        // Create "Control" subkey with "NewlyCreated" value key
        //

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
        status = IopCreateRegistryKeyEx( &handle,
                                         *ReturnedHandle,
                                         &unicodeValueName,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_VOLATILE,
                                         NULL
                                         );
        if (NT_SUCCESS(status)) {
            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEWLY_CREATED);
            tmpValue = 0;
            ZwSetValueKey(handle,
                          &unicodeValueName,
                          TITLE_INDEX_VALUE,
                          REG_DWORD,
                          &tmpValue,
                          sizeof(tmpValue)
                          );
            ZwClose(handle);
        }

        handle = *ReturnedHandle;

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_SERVICE);
        p = (PWSTR)ExAllocatePool(PagedPool,
                                  ServiceKeyName->Length + sizeof(UNICODE_NULL));
        if(p) {
            RtlCopyMemory(p, ServiceKeyName->Buffer, ServiceKeyName->Length);
            p[ServiceKeyName->Length / sizeof (WCHAR)] = UNICODE_NULL;
            ZwSetValueKey(
                        handle,
                        &unicodeValueName,
                        TITLE_INDEX_VALUE,
                        REG_SZ,
                        p,
                        ServiceKeyName->Length + sizeof(UNICODE_NULL)
                        );
            //
            // We'll keep the null-terminated service name buffer around for a while,
            // because we may need it later on for the DeviceDesc in case the service
            // has no DisplayName.
            //
            // ExFreePool(p);
        }

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_LEGACY);
        tmpValue = 1;
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &tmpValue,
                    sizeof(tmpValue)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CONFIG_FLAGS);
        tmpValue = 0;
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_DWORD,
                    &tmpValue,
                    sizeof(tmpValue)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CLASS);
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    REGSTR_VALUE_LEGACY_DRIVER,
                    sizeof(REGSTR_VALUE_LEGACY_DRIVER)
                    );

        PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_CLASSGUID);
        ZwSetValueKey(
                    handle,
                    &unicodeValueName,
                    TITLE_INDEX_VALUE,
                    REG_SZ,
                    (PVOID)&REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID,
                    sizeof(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID)
                    );


        //
        // Initialize DeviceDesc= value entry.  If the service key has a "DisplayName"
        // value entry, it is used as the DeviceDesc value.  Otherwise, the service key
        // name is used.
        //

        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        &handle,
                                        NULL,
                                        FALSE
                                        );
        if (NT_SUCCESS(status)) {

            keyValueInformation = NULL;
            unicodeString.Length = 0;
            status = IopGetRegistryValue(handle,
                                         REGSTR_VALUE_DISPLAY_NAME,
                                         &keyValueInformation
                                        );
            if (NT_SUCCESS(status)) {
                if (keyValueInformation->Type == REG_SZ) {
                    if (keyValueInformation->DataLength > sizeof(UNICODE_NULL)) {
                        IopRegistryDataToUnicodeString(&unicodeString,
                                                       (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                                       keyValueInformation->DataLength
                                                       );
                    }
                }
            }
            if ((unicodeString.Length == 0) && p) {

                //
                // No DisplayName--use the service key name.
                //

                unicodeString.Length = ServiceKeyName->Length;
                unicodeString.MaximumLength = ServiceKeyName->Length + sizeof(UNICODE_NULL);
                unicodeString.Buffer = p;
            }

            if(unicodeString.Length) {
                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_DEVICE_DESC);
                ZwSetValueKey(*ReturnedHandle,
                              &unicodeValueName,
                              TITLE_INDEX_VALUE,
                              REG_SZ,
                              unicodeString.Buffer,
                              unicodeString.Length + sizeof(UNICODE_NULL)
                              );
            }
            if (keyValueInformation) {
                ExFreePool(keyValueInformation);
            }
            ZwClose(handle);
        }

        if(p) {
            ExFreePool(p);
        }
    }

    //
    // Create new value entry under ServiceKeyName\Enum to reflect the newly
    // added made-up device instance node.
    //

    PiUnlockPnpRegistry();
    releaseResource = FALSE;

    status = PpDeviceRegistration( KeyName, TRUE, NULL );

    if (ResourceOwned) {
        PiLockPnpRegistry(FALSE);
    }
    RtlFreeUnicodeString(&tmpKeyName);
    if (!NT_SUCCESS( status )) {

        //
        // There is no registry key for the ServiceKeyName information.
        //

        ZwClose(*ReturnedHandle);
        RtlFreeUnicodeString(KeyName);
    }
local_exit0:
    if (releaseResource) {
        PiUnlockPnpRegistry();
    }
    return status;
}

NTSTATUS
PipGenerateMadeupNodeName (
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PUNICODE_STRING MadeupNodeName
    )

/*++

Routine Description:

    This routine parses the ServiceKeyName string and replaces any space
    characters with an underscore character, and any invalid characters (not
    allowed in a "device instance") with their hexadecimal character
    representation.

    Invalid characters are:
        c <  0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

    The resulting modified ServiceKeyName string is used to create a valid
    device id.  Paged pool space is allocated for the destination string.
    Caller must release the space once done with it.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    MadeupNodeName - Supplies a variable to receive the name of madeup device
        id.  If successful, the caller is responsible for freeing the allocated
        buffer.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/
{
    PWCHAR BufferEnd, p, q;
    ULONG length;
    PWSTR buffer;

    //
    // We'll need at least as much room as the size of the unicode service key
    // name, plus the LEGACY_ prefix and terminating NULL char..
    //
    length = sizeof(REGSTR_KEY_MADEUP) + ServiceKeyName->Length;

    p = ServiceKeyName->Buffer;
    BufferEnd = (PWCHAR)((PUCHAR)p + ServiceKeyName->Length);
    while(p != BufferEnd) {
        if ((*p < L' ') || (*p > (WCHAR)0x7F) || (*p == L',')) {
            //
            // Each "invalid" character will be replaced with a '*' character
            // (size already accounted for in calculated length), plus one
            // character for each nibble of each byte in the invalid character.
            //
            length += 2*sizeof(WCHAR)*sizeof(WCHAR);
        }
        p++;
    }

    //
    // Allocate a buffer large enough to hold the converted
    // LEGACY_<ServiceKeyName> string.
    //
    buffer = (PWSTR)ExAllocatePool(PagedPool, length);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MadeupNodeName->Buffer = buffer;
    MadeupNodeName->Length = (USHORT)(length - sizeof(UNICODE_NULL));
    MadeupNodeName->MaximumLength = (USHORT)length;

    RtlCopyMemory(buffer, REGSTR_KEY_MADEUP, sizeof(REGSTR_KEY_MADEUP));

    q = buffer + (sizeof(REGSTR_KEY_MADEUP) - sizeof(UNICODE_NULL))/sizeof(WCHAR);

    p = ServiceKeyName->Buffer;
    BufferEnd = (PWCHAR)((PUCHAR)p + ServiceKeyName->Length);
    while(p != BufferEnd) {
        if (*p == L' ') {
            //
            // replace ' ' with '_'
            //
            *q = L'_';
            q++;

        } else if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
            //
            // replace invalid characters with '*' plus a character string
            // representation of the hexadecimal digits.
            //
            int i, nibble;

            *q = L'*';
            q++;

            for (i = 1; i <= 2*sizeof(WCHAR); i++) {
                nibble = ((USHORT)((*p) >> (0x10 - 4*i)) & 0xF);
                *q = nibble > 9 ? (nibble - 10 + L'A') : (nibble + L'0');
                q++;
            }

        } else {
            //
            // copy the existing character.
            //
            *q = *p;
            q++;
        }
        p++;
    }

    *q = UNICODE_NULL;

    //
    // Upcase the resulting device id.
    //

    RtlUpcaseUnicodeString(MadeupNodeName, MadeupNodeName, FALSE);

    //
    // Sanity check to make sure that the device id we generated is valid.  At
    // this point, there should be absolutely no reason that it wouldn't be.
    //

    if (!PiFixupID(MadeupNodeName->Buffer, MAX_DEVICE_ID_LEN, FALSE, 0, NULL)) {
        ASSERT(0);
        RtlFreeUnicodeString(MadeupNodeName);
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

BOOLEAN
PipConcatenateUnicodeStrings (
    OUT PUNICODE_STRING Destination,
    IN  PUNICODE_STRING String1,
    IN  PUNICODE_STRING String2  OPTIONAL
    )

/*++

Routine Description:

    This routine returns a buffer containing the concatenation of the
    two specified strings.  Since String2 is optional, this function may
    also be used to make a copy of a unicode string.  Paged pool space
    is allocated for the destination string.  Caller must release the
    space once done with it.

Parameters:

    Destination - Supplies a variable to receive the concatenated
        UNICODE_STRING.

    String1 - Supplies a pointer to the frist UNICODE_STRING.

    String2 - Supplies an optional pointer to the second UNICODE_STRING.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    ULONG length;
    PWSTR buffer;

    length = String1->Length + sizeof(UNICODE_NULL);
    if (ARGUMENT_PRESENT(String2)) {
        length += String2->Length;
    }
    buffer = (PWSTR)ExAllocatePool(PagedPool, length);
    if (!buffer) {
        return FALSE;
    }
    Destination->Buffer = buffer;
    Destination->Length = (USHORT)length - sizeof(UNICODE_NULL);
    Destination->MaximumLength = (USHORT)length;
    RtlCopyMemory (buffer, String1->Buffer, String1->Length);
    if(ARGUMENT_PRESENT(String2)) {
        RtlCopyMemory((PUCHAR)buffer + String1->Length,
                      String2->Buffer,
                      String2->Length
                     );
    }
    buffer[length / sizeof(WCHAR) - 1] = UNICODE_NULL;
    return TRUE;
}

NTSTATUS
IopPrepareDriverLoading (
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN BOOLEAN IsFilter
    )

/*++

Routine Description:

    This routine first checks if the driver is loadable.  If its a
    PnP driver, it will always be loaded (we trust it to do the right
    things.)  If it is a legacy driver, we need to check if its device
    has been disabled.  Once we decide to load the driver, the Enum
    subkey of the service node will be checked for duplicates, if any.

Parameters:

    KeyName - Supplies a pointer to the driver's service key unicode string

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

Return Value:

    The function value is the final status of the load operation.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG tmp, count;
    HANDLE serviceEnumHandle = NULL, sysEnumXxxHandle, controlHandle;
    UNICODE_STRING unicodeKeyName, unicodeValueName;
    BOOLEAN IsPlugPlayDriver;
    PIMAGE_NT_HEADERS header;
    GUID blockedDriverGuid;

    header = RtlImageNtHeader(ImageBase);
    status = STATUS_SUCCESS;
    IsPlugPlayDriver = (header &&
                        (header->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER))? TRUE : FALSE;

    if (!IopIsAnyDeviceInstanceEnabled(KeyName, KeyHandle, (BOOLEAN)(IsPlugPlayDriver ? FALSE : TRUE))) {

        if (!IsPlugPlayDriver) {

            PiLockPnpRegistry(FALSE);

            //
            // First open registry ServiceKeyName\Enum branch
            //

            PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_ENUM);
            status = IopCreateRegistryKeyEx( &serviceEnumHandle,
                                             KeyHandle,
                                             &unicodeKeyName,
                                             KEY_ALL_ACCESS,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );
            if (NT_SUCCESS(status)) {

                //
                // Find out how many device instances listed in the ServiceName's
                // Enum key.
                //

                count = 0;
                status = IopGetRegistryValue ( serviceEnumHandle,
                                               REGSTR_VALUE_COUNT,
                                               &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    if (    keyValueInformation->Type == REG_DWORD &&
                            keyValueInformation->DataLength >= sizeof(ULONG)) {

                        count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);

                    }

                    ExFreePool(keyValueInformation);

                }
                if (    NT_SUCCESS(status) ||
                        status == STATUS_OBJECT_PATH_NOT_FOUND ||
                        status == STATUS_OBJECT_NAME_NOT_FOUND) {

                    if (count) {

                        status = STATUS_PLUGPLAY_NO_DEVICE;

                    } else {

                        //
                        // If there is no Enum key or instance under Enum for the
                        // legacy driver we will create a madeup node for it.
                        //

                        status = PipCreateMadeupNode(   KeyName,
                                                        &sysEnumXxxHandle,
                                                        &unicodeKeyName,
                                                        &tmp,
                                                        TRUE);
                        if (NT_SUCCESS(status)) {

                            RtlFreeUnicodeString(&unicodeKeyName);

                            //
                            // Create and set Control\ActiveService value
                            //

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
                            status = IopCreateRegistryKeyEx( &controlHandle,
                                                             sysEnumXxxHandle,
                                                             &unicodeValueName,
                                                             KEY_ALL_ACCESS,
                                                             REG_OPTION_VOLATILE,
                                                             NULL
                                                             );
                            if (NT_SUCCESS(status)) {

                                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VAL_ACTIVESERVICE);
                                ZwSetValueKey(  controlHandle,
                                                &unicodeValueName,
                                                TITLE_INDEX_VALUE,
                                                REG_SZ,
                                                KeyName->Buffer,
                                                KeyName->Length + sizeof(UNICODE_NULL));
                                ZwClose(controlHandle);

                            }
                            count++;
                            //
                            // Don't forget to update the "Count=" and "NextInstance=" value entries
                            //

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_COUNT);
                            ZwSetValueKey(  serviceEnumHandle,
                                            &unicodeValueName,
                                            TITLE_INDEX_VALUE,
                                            REG_DWORD,
                                            &count,
                                            sizeof(count));

                            PiWstrToUnicodeString(&unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);
                            ZwSetValueKey(  serviceEnumHandle,
                                            &unicodeValueName,
                                            TITLE_INDEX_VALUE,
                                            REG_DWORD,
                                            &count,
                                            sizeof(count));

                            ZwClose(sysEnumXxxHandle);
                            status = STATUS_SUCCESS;
                        }
                    }
                }

                ZwClose(serviceEnumHandle);
            }

            PiUnlockPnpRegistry();
        }
    }
    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&blockedDriverGuid, sizeof(GUID));

        status = PpCheckInDriverDatabase(
            KeyName,
            KeyHandle,
            ImageBase,
            header->OptionalHeader.SizeOfImage,
            IsFilter,
            &blockedDriverGuid);

        if (status == STATUS_DRIVER_BLOCKED ||
            status == STATUS_DRIVER_BLOCKED_CRITICAL) {
            //
            // Notify the user-mode Plug and Play manager that a driver was just
            // blocked.
            //
            PpSetBlockedDriverEvent(&blockedDriverGuid);
        }
    }

    return status;
}

NTSTATUS
PipServiceInstanceToDeviceInstance (
    IN  HANDLE ServiceKeyHandle OPTIONAL,
    IN  PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN  ULONG ServiceInstanceOrdinal,
    OUT PUNICODE_STRING DeviceInstanceRegistryPath OPTIONAL,
    OUT PHANDLE DeviceInstanceHandle OPTIONAL,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine reads the service node enum entry to find the desired device instance
    under the System\Enum tree.  It then optionally returns the registry path of the
    specified device instance (relative to HKLM\System\Enum) and an open handle
    to that registry key.

    It is the caller's responsibility to close the handle returned if
    DeviceInstanceHandle is supplied, and also to free the (PagedPool) memory
    allocated for the unicode string buffer of DeviceInstanceRegistryPath, if
    supplied.

Parameters:

    ServiceKeyHandle - Optionally, supplies a handle to the driver service node in the
        registry that controls this device instance.  If this argument is not specified,
        then ServiceKeyName is used to specify the service entry.

    ServiceKeyName - Optionally supplies the name of the service entry that controls
        the device instance. This must be specified if ServiceKeyHandle isn't given.

    ServiceInstanceOrdinal - Supplies the instance value under the service entry's
        volatile Enum subkey that references the desired device instance.

    DeviceInstanceRegistryPath - Optionally, supplies a pointer to a unicode string
        that will be initialized with the registry path (relative to HKLM\System\Enum)
        to the device instance key.

    DeviceInstanceHandle - Optionally, supplies a pointer to a variable that will
        receive a handle to the opened device instance registry key.

    DesiredAccess - If DeviceInstanceHandle is specified (i.e., the device instance
        key is to be opened), then this variable specifies the access that is needed
        to this key.

Return Value:

    NT status code indicating whether the function was successful.

--*/

{
    WCHAR unicodeBuffer[20];
    UNICODE_STRING unicodeKeyName;
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    //
    // Open registry ServiceKeyName\Enum branch
    //
    if(ARGUMENT_PRESENT(ServiceKeyHandle)) {

        PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx( &handle,
                                       ServiceKeyHandle,
                                       &unicodeKeyName,
                                       KEY_READ
                                       );
    } else {

        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        NULL,
                                        &handle,
                                        FALSE
                                       );
    }

    if (!NT_SUCCESS( status )) {

        //
        // There is no registry key for the ServiceKeyName\Enum information.
        //

        return status;
    }

    //
    // Read a path to System\Enum hardware tree branch specified by the service
    // instance ordinal
    //

    swprintf(unicodeBuffer, REGSTR_VALUE_STANDARD_ULONG_FORMAT, ServiceInstanceOrdinal);
    status = IopGetRegistryValue ( handle,
                                   unicodeBuffer,
                                   &keyValueInformation
                                   );

    ZwClose(handle);
    if (!NT_SUCCESS( status )) {
        return status;
    } else {
        if(keyValueInformation->Type == REG_SZ) {
            IopRegistryDataToUnicodeString(&unicodeKeyName,
                                           (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                           keyValueInformation->DataLength
                                          );
            if(!unicodeKeyName.Length) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
            }
        } else {
            status = STATUS_INVALID_PLUGPLAY_DEVICE_PATH;
        }

        if(!NT_SUCCESS(status)) {
            goto PrepareForReturn;
        }
    }

    //
    // If the DeviceInstanceHandle argument was specified, open the device instance
    // key under HKLM\System\CurrentControlSet\Enum
    //

    if (ARGUMENT_PRESENT(DeviceInstanceHandle)) {

        status = IopOpenRegistryKeyEx( &handle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_READ
                                       );

        if (NT_SUCCESS( status )) {

            status = IopOpenRegistryKeyEx( DeviceInstanceHandle,
                                           handle,
                                           &unicodeKeyName,
                                           DesiredAccess
                                           );
            ZwClose(handle);
        }

        if (!NT_SUCCESS( status )) {
            goto PrepareForReturn;
        }
    }

    //
    // If the DeviceInstanceRegistryPath argument was specified, then store a
    // copy of the device instance path in the supplied unicode string variable.
    //
    if (ARGUMENT_PRESENT(DeviceInstanceRegistryPath)) {

        if (!PipConcatenateUnicodeStrings(DeviceInstanceRegistryPath,
                                          &unicodeKeyName,
                                          NULL)) {

            if(ARGUMENT_PRESENT(DeviceInstanceHandle)) {
                ZwClose(*DeviceInstanceHandle);
            }
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

PrepareForReturn:

    ExFreePool(keyValueInformation);
    return status;
}

NTSTATUS
IopOpenRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    Opens a registry key using the name passed in based at the BaseHandle node.
    This name may specify a key that is actually a registry path.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Optional handle to the base path from which the key must be opened.
        If KeyName specifies a registry path that must be created, then this parameter
        must be specified, and KeyName must be a relative path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Simply attempt to open the path, as specified.
    //
    return ZwOpenKey( Handle, DesiredAccess, &objectAttributes );
}

NTSTATUS
IopCreateRegistryKeyEx(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )

/*++

Routine Description:

    Opens or creates a registry key using the name
    passed in based at the BaseHandle node. This name may specify a key
    that is actually a registry path, in which case each intermediate subkey
    will be created (if Create is TRUE).

    NOTE: Creating a registry path (i.e., more than one of the keys in the path
    do not presently exist) requires that a BaseHandle be specified.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Optional handle to the base path from which the key must be opened.
        If KeyName specifies a registry path that must be created, then this parameter
        must be specified, and KeyName must be a relative path.

    KeyName - Name of the Key that must be opened/created (possibly a registry path)

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    CreateOptions - Options passed to ZwCreateKey.

    Disposition - If Create is TRUE, this optional pointer receives a ULONG indicating
        whether the key was newly created:

            REG_CREATED_NEW_KEY - A new Registry Key was created
            REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition, baseHandleIndex = 0, keyHandleIndex = 1, closeBaseHandle;
    HANDLE handles[2];
    BOOLEAN continueParsing;
    PWCHAR pathEndPtr, pathCurPtr, pathBeginPtr;
    ULONG pathComponentLength;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL
                                );
    //
    // Attempt to create the path as specified. We have to try it this
    // way first, because it allows us to create a key without a BaseHandle
    // (if only the last component of the registry path is not present).
    //
    status = ZwCreateKey(&(handles[keyHandleIndex]),
                         DesiredAccess,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         CreateOptions,
                         &disposition
                         );

    if (status == STATUS_OBJECT_NAME_NOT_FOUND && ARGUMENT_PRESENT(BaseHandle)) {
        //
        // If we get to here, then there must be more than one element of the
        // registry path that does not currently exist.  We will now parse the
        // specified path, extracting each component and doing a ZwCreateKey on it.
        //
        handles[baseHandleIndex] = NULL;
        handles[keyHandleIndex] = BaseHandle;
        closeBaseHandle = 0;
        continueParsing = TRUE;
        pathBeginPtr = KeyName->Buffer;
        pathEndPtr = (PWCHAR)((PCHAR)pathBeginPtr + KeyName->Length);
        status = STATUS_SUCCESS;

        while(continueParsing) {
            //
            // There's more to do, so close the previous base handle (if necessary),
            // and replace it with the current key handle.
            //
            if(closeBaseHandle > 1) {
                ZwClose(handles[baseHandleIndex]);
            }
            baseHandleIndex = keyHandleIndex;
            keyHandleIndex = (keyHandleIndex + 1) & 1;  // toggle between 0 and 1.
            handles[keyHandleIndex] = NULL;

            //
            // Extract next component out of the specified registry path.
            //
            for (pathCurPtr = pathBeginPtr;
                ((pathCurPtr < pathEndPtr) && (*pathCurPtr != OBJ_NAME_PATH_SEPARATOR));
                pathCurPtr++);

            pathComponentLength = (ULONG)((PCHAR)pathCurPtr - (PCHAR)pathBeginPtr);
            if (pathComponentLength != 0) {
                //
                // Then we have a non-empty path component (key name).  Attempt
                // to create this key.
                //
                unicodeString.Buffer = pathBeginPtr;
                unicodeString.Length = unicodeString.MaximumLength = (USHORT)pathComponentLength;

                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeString,
                                           OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                           handles[baseHandleIndex],
                                           (PSECURITY_DESCRIPTOR) NULL
                                          );
                status = ZwCreateKey(&(handles[keyHandleIndex]),
                                     DesiredAccess,
                                     &objectAttributes,
                                     0,
                                     (PUNICODE_STRING) NULL,
                                     CreateOptions,
                                     &disposition
                                    );
                if(NT_SUCCESS(status)) {
                    //
                    // Increment the closeBaseHandle value, which basically tells us whether
                    // the BaseHandle passed in has been 'shifted out' of our way, so that
                    // we should start closing our base handles when we're finished with them.
                    //
                    closeBaseHandle++;
                } else {
                    continueParsing = FALSE;
                    continue;
                }
            } else {
                //
                // Either a path separator ('\') was included at the beginning of
                // the path, or we hit 2 consecutive separators.
                //
                status = STATUS_INVALID_PARAMETER;
                continueParsing = FALSE;
                continue;
            }

            if((pathCurPtr == pathEndPtr) ||
               ((pathBeginPtr = pathCurPtr + 1) == pathEndPtr)) {
                //
                // Then we've reached the end of the path
                //
                continueParsing = FALSE;
            }
        }

        if(closeBaseHandle > 1) {
            ZwClose(handles[baseHandleIndex]);
        }
    }

    if(NT_SUCCESS(status)) {
        *Handle = handles[keyHandleIndex];

        if(ARGUMENT_PRESENT(Disposition)) {
            *Disposition = disposition;
        }
    }

    return status;
}

NTSTATUS
PipOpenServiceEnumKeys (
    IN PUNICODE_STRING ServiceKeyName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE ServiceHandle OPTIONAL,
    OUT PHANDLE ServiceEnumHandle OPTIONAL,
    IN BOOLEAN CreateEnum
    )

/*++

Routine Description:

    This routine opens the HKEY_LOCAL_MACHINE\CurrentControlSet\Services\
    ServiceKeyName and its Enum subkey and returns handles for both key.
    It is caller's responsibility to close the returned handles.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    DesiredAccess - Specifies the desired access to the keys.

    ServiceHandle - Supplies a variable to receive a handle to ServiceKeyName.
        A NULL ServiceHandle indicates caller does not want need the handle to
        the ServiceKeyName.

    ServiceEnumHandle - Supplies a variable to receive a handle to ServiceKeyName\Enum.
        A NULL ServiceEnumHandle indicates caller does not need the handle to
        the ServiceKeyName\Enum.

    CreateEnum - Supplies a BOOLEAN variable to indicate should the Enum subkey be
        created if not present.

Return Value:

    status

--*/

{
    HANDLE handle, serviceHandle, enumHandle;
    UNICODE_STRING enumName;
    NTSTATUS status;

    //
    // Open System\CurrentControlSet\Services
    //

    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetServices,
                                   DesiredAccess
                                   );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Open the registry ServiceKeyName key.
    //

    status = IopOpenRegistryKeyEx( &serviceHandle,
                                   handle,
                                   ServiceKeyName,
                                   DesiredAccess
                                   );

    ZwClose(handle);
    if (!NT_SUCCESS( status )) {

        //
        // There is no registry key for the ServiceKeyName information.
        //

        return status;
    }

    if (ARGUMENT_PRESENT(ServiceEnumHandle) || CreateEnum) {

        //
        // Open registry ServiceKeyName\Enum branch if caller wants
        // the handle or wants to create it.
        //

        PiWstrToUnicodeString(&enumName, REGSTR_KEY_ENUM);

        if (CreateEnum) {
            status = IopCreateRegistryKeyEx( &enumHandle,
                                             serviceHandle,
                                             &enumName,
                                             DesiredAccess,
                                             REG_OPTION_VOLATILE,
                                             NULL
                                             );
        } else {
            status = IopOpenRegistryKeyEx( &enumHandle,
                                           serviceHandle,
                                           &enumName,
                                           DesiredAccess
                                           );

        }

        if (!NT_SUCCESS( status )) {

            //
            // There is no registry key for the ServiceKeyName\Enum information.
            //

            ZwClose(serviceHandle);
            return status;
        }
        if (ARGUMENT_PRESENT(ServiceEnumHandle)) {
            *ServiceEnumHandle = enumHandle;
        } else {
            ZwClose(enumHandle);
        }
    }

    //
    // if caller wants to have the ServiceKey handle, we return it.  Otherwise
    // we close it.
    //

    if (ARGUMENT_PRESENT(ServiceHandle)) {
        *ServiceHandle = serviceHandle;
    } else {
        ZwClose(serviceHandle);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopGetDeviceInstanceCsConfigFlags(
    IN PUNICODE_STRING DeviceInstance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device.

Arguments:

    DeviceInstance - Supplies a pointer to the devnode's instance path

    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle1, handle2;
    UNICODE_STRING tempUnicodeString;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    *CsConfigFlags = 0;

    status = IopOpenRegistryKeyEx( &handle1,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Now, we must open the System\CCS\Enum key under this.
    //
    //
    // Open system\CurrentControlSet under current hardware profile key
    //

    PiWstrToUnicodeString(&tempUnicodeString, REGSTR_PATH_CURRENTCONTROLSET);
    status = IopOpenRegistryKeyEx( &handle2,
                                   handle1,
                                   &tempUnicodeString,
                                   KEY_READ
                                   );
    ZwClose(handle1);

    if (!NT_SUCCESS(status)) {

        return status;
    }

    PiWstrToUnicodeString(&tempUnicodeString, REGSTR_KEY_ENUM);

    status = IopOpenRegistryKeyEx( &handle1,
                                   handle2,
                                   &tempUnicodeString,
                                   KEY_READ
                                   );

    ZwClose(handle2);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    status = IopOpenRegistryKeyEx( &handle2,
                                   handle1,
                                   DeviceInstance,
                                   KEY_READ
                                   );

    ZwClose(handle1);

    if (!NT_SUCCESS(status)) {

        return status;
    }


    status = IopGetRegistryValue( handle2,
                                  REGSTR_VALUE_CSCONFIG_FLAGS,
                                  &keyValueInformation
                                  );

    ZwClose(handle2);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }

    return status;
}

NTSTATUS
PipGetServiceInstanceCsConfigFlags(
    IN PUNICODE_STRING ServiceKeyName,
    IN ULONG Instance,
    OUT PULONG CsConfigFlags
    )

/*++

Routine Description:

    This routine retrieves the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    CsConfigFlags - Supplies a variable to receive the device's CsConfigFlags

Return Value:

    status

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    PAGED_CODE();

    *CsConfigFlags = 0;

    status = IopOpenCurrentHwProfileDeviceInstanceKey(&handle,
                                                      ServiceKeyName,
                                                      Instance,
                                                      KEY_READ,
                                                      FALSE
                                                     );
    if(NT_SUCCESS(status)) {
        status = IopGetRegistryValue(handle,
                                     REGSTR_VALUE_CSCONFIG_FLAGS,
                                     &keyValueInformation
                                    );
        if(NT_SUCCESS(status)) {
            if((keyValueInformation->Type == REG_DWORD) &&
               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                *CsConfigFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        ZwClose(handle);
    }
    return status;
}

NTSTATUS
IopOpenCurrentHwProfileDeviceInstanceKey(
    OUT PHANDLE Handle,
    IN  PUNICODE_STRING ServiceKeyName,
    IN  ULONG Instance,
    IN  ACCESS_MASK DesiredAccess,
    IN  BOOLEAN Create
    )

/*++

Routine Description:

    This routine sets the csconfig flags for the specified device
    which is specified by the instance number under ServiceKeyName\Enum.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load. This is the RegistryPath parameter
        to the DriverEntry routine.

    Instance - Supplies the instance value under ServiceKeyName\Enum key

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING tempUnicodeString;
    HANDLE profileHandle, profileEnumHandle, tmpHandle;

    //
    // See if we can open current hardware profile
    //

    if (Create) {
        status = IopCreateRegistryKeyEx( &profileHandle,
                                         NULL,
                                         &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                         KEY_READ,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
    } else {
        status = IopOpenRegistryKeyEx( &profileHandle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                       KEY_READ
                                       );
    }

    if(NT_SUCCESS(status)) {
        //
        // Now, we must open the System\CCS\Enum key under this.
        //
        //
        // Open system\CurrentControlSet under current hardware profile key
        //

        PiWstrToUnicodeString(&tempUnicodeString, REGSTR_PATH_CURRENTCONTROLSET);
        status = IopOpenRegistryKeyEx( &tmpHandle,
                                       profileHandle,
                                       &tempUnicodeString,
                                       DesiredAccess
                                       );
        ZwClose(profileHandle);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        PiWstrToUnicodeString(&tempUnicodeString, REGSTR_KEY_ENUM);

        if (Create) {
            status = IopCreateRegistryKeyEx( &profileEnumHandle,
                                             tmpHandle,
                                             &tempUnicodeString,
                                             KEY_READ,
                                             REG_OPTION_NON_VOLATILE,
                                             NULL
                                             );
        } else {
            status = IopOpenRegistryKeyEx( &profileEnumHandle,
                                           tmpHandle,
                                           &tempUnicodeString,
                                           KEY_READ
                                           );
        }

        ZwClose(tmpHandle);
        if(NT_SUCCESS(status)) {

            status = PipServiceInstanceToDeviceInstance(NULL,
                                                        ServiceKeyName,
                                                        Instance,
                                                        &tempUnicodeString,
                                                        NULL,
                                                        0
                                                       );
            if (NT_SUCCESS(status)) {
                if (Create) {
                    status = IopCreateRegistryKeyEx( Handle,
                                                     profileEnumHandle,
                                                     &tempUnicodeString,
                                                     DesiredAccess,
                                                     REG_OPTION_NON_VOLATILE,
                                                     NULL
                                                     );
                } else {
                    status = IopOpenRegistryKeyEx( Handle,
                                                   profileEnumHandle,
                                                   &tempUnicodeString,
                                                   DesiredAccess
                                                   );
                }
                RtlFreeUnicodeString(&tempUnicodeString);
            }
            ZwClose(profileEnumHandle);
        }
    }
    return status;
}

NTSTATUS
PipApplyFunctionToSubKeys(
    IN     HANDLE BaseHandle OPTIONAL,
    IN     PUNICODE_STRING KeyName OPTIONAL,
    IN     ACCESS_MASK DesiredAccess,
    IN     ULONG Flags,
    IN     PIOP_SUBKEY_CALLBACK_ROUTINE SubKeyCallbackRoutine,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine enumerates all subkeys under the specified key, and calls
    the specified callback routine for each subkey.

Arguments:

    BaseHandle - Optional handle to the base registry path. If KeyName is also
        specified, then KeyName represents a subkey under this path.  If KeyName
        is not specified, the subkeys are enumerated under this handle.  If this
        parameter is not specified, then the full path to the base key must be
        given in KeyName.

    KeyName - Optional name of the key whose subkeys are to be enumerated.

    DesiredAccess - Specifies the desired access that the callback routine
        needs to the subkeys.  If no desired access is specified (i.e.,
        DesiredAccess is zero), then no handle will be opened for the
        subkeys, and the callback will be passed a NULL for its SubKeyHandle
        parameter.

    Flags - Controls the behavior of subkey enumeration.  Currently, the
        following flags are defined:

        FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS - Specifies whether this
            function should immediately terminate on all errors, or only on
            critical ones.  An example of a non-critical error is when an
            enumerated subkey cannot be opened for the desired access.

        FUNCTION_SUBKEY_DELETE_SUBKEYS - Specifies that each subkey should be
            deleted after the specified SubKeyCallBackRoutine has been performed
            on it.  Note that this is NOT a recursive delete on each of the
            subkeys, just an attempt to delete the subkey itself.  It the subkey
            contains children, this will fail.

    SubKeyCallbackRoutine - Supplies a pointer to a function that will
        be called for each subkey found under the
        specified key.  The prototype of the function
        is as follows:

            typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
                IN     HANDLE SubKeyHandle,
                IN     PUNICODE_STRING SubKeyName,
                IN OUT PVOID Context
                );

        where SubKeyHandle is the handle to an enumerated subkey under the
        specified key, SubKeyName is its name, and Context is a pointer to
        user-defined data.

        This function should return TRUE to continue enumeration, or
        FALSE to terminate it.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each subkey invocation.

Return Value:

    NT status code indicating whether the subkeys were successfully
    enumerated.  Note that this does not provide information on the
    success or failure of the callback routine--if desired, this
    information should be stored in the Context structure.

--*/

{
    NTSTATUS Status;
    BOOLEAN CloseHandle = FALSE, ContinueEnumeration;
    HANDLE Handle, SubKeyHandle;
    ULONG i, RequiredBufferLength;
    PKEY_BASIC_INFORMATION KeyInformation = NULL;
    // Use an initial key name buffer size large enough for a 20-character key
    // (+ terminating NULL)
    ULONG KeyInformationLength = sizeof(KEY_BASIC_INFORMATION) + (20 * sizeof(WCHAR));
    UNICODE_STRING SubKeyName;

    if(ARGUMENT_PRESENT(KeyName)) {

        Status = IopOpenRegistryKeyEx( &Handle,
                                       BaseHandle,
                                       KeyName,
                                       KEY_READ
                                       );
        if(!NT_SUCCESS(Status)) {
            return Status;
        } else {
            CloseHandle = TRUE;
        }

    } else {

        Handle = BaseHandle;
    }

    //
    // Enumerate the subkeys until we run out of them.
    //
    i = 0;
    SubKeyHandle = NULL;

    for ( ; ; ) {

        if (!KeyInformation) {

            KeyInformation = (PKEY_BASIC_INFORMATION)ExAllocatePool(PagedPool,
                                                                    KeyInformationLength
                                                                   );
            if (!KeyInformation) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        }

        Status = ZwEnumerateKey(Handle,
                                i,
                                KeyBasicInformation,
                                KeyInformation,
                                KeyInformationLength,
                                &RequiredBufferLength
                               );

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL) {
                //
                // Try again with larger buffer.
                //
                ExFreePool(KeyInformation);
                KeyInformation = NULL;
                KeyInformationLength = RequiredBufferLength;
                continue;

            } else {

                if (Status == STATUS_NO_MORE_ENTRIES) {
                    //
                    // No more subkeys.
                    //
                    Status = STATUS_SUCCESS;
                }
                //
                // break out of loop
                //
                break;
            }
        }

        //
        // Initialize a unicode string with this key name.  Note that this string
        // WILL NOT be NULL-terminated.
        //
        SubKeyName.Length = SubKeyName.MaximumLength = (USHORT)KeyInformation->NameLength;
        SubKeyName.Buffer = KeyInformation->Name;

        //
        // If DesiredAccess is non-zero, open a handle to this subkey.
        //
        if (DesiredAccess) {
            Status = IopOpenRegistryKeyEx( &SubKeyHandle,
                                           Handle,
                                           &SubKeyName,
                                           DesiredAccess
                                           );
            if (!NT_SUCCESS(Status)) {
                //
                // This is a non-critical error.
                //
                if(Flags & FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS) {
                    goto ContinueWithNextSubKey;
                } else {
                    break;
                }
            }
        }

        //
        // Invoke the supplied callback function for this subkey.
        //
        ContinueEnumeration = SubKeyCallbackRoutine(SubKeyHandle, &SubKeyName, Context);

        if (DesiredAccess) {
            if (ContinueEnumeration &&
                (Flags & FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS)) {
                //
                // Delete the key when asked to, only if the callback routine
                // was successful, otherwise we may not be able to.
                //
                Status = ZwDeleteKey(SubKeyHandle);
            }
            ZwClose(SubKeyHandle);
        }

        if(!ContinueEnumeration) {
            //
            // Enumeration has been aborted.
            //
            Status = STATUS_SUCCESS;
            break;

        }

ContinueWithNextSubKey:
        if (!(Flags & FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS)) {
            //
            // Only increment the enumeration index for non-deleted subkeys
            //
            i++;
        }
    }

    if(KeyInformation) {
        ExFreePool(KeyInformation);
    }

    if(CloseHandle) {
        ZwClose(Handle);
    }

    return Status;
}

NTSTATUS
PipRegMultiSzToUnicodeStrings(
    IN  PKEY_VALUE_FULL_INFORMATION KeyValueInformation,
    OUT PUNICODE_STRING *UnicodeStringList,
    OUT PULONG UnicodeStringCount
    )

/*++

Routine Description:

    This routine takes a KEY_VALUE_FULL_INFORMATION structure containing
    a REG_MULTI_SZ value, and allocates an array of UNICODE_STRINGs,
    initializing each one to a copy of one of the strings in the value entry.
    All the resulting UNICODE_STRINGs will be NULL terminated
    (MaximumLength = Length + sizeof(UNICODE_NULL)).

    It is the responsibility of the caller to free the buffers for each
    unicode string, as well as the buffer containing the UNICODE_STRING
    array. This may be done by calling PipFreeUnicodeStringList.

Arguments:

    KeyValueInformation - Supplies the buffer containing the REG_MULTI_SZ
        value entry data.

    UnicodeStringList - Receives a pointer to an array of UNICODE_STRINGs, each
        initialized with a copy of one of the strings in the REG_MULTI_SZ.

    UnicodeStringCount - Receives the number of strings in the
        UnicodeStringList.

Returns:

    NT status code indicating whether the function was successful.

    NOTE: This function is only available during INIT time!

--*/

{
    PWCHAR p, BufferEnd, StringStart;
    ULONG StringCount, i, StringLength;

    //
    // First, make sure this is really a REG_MULTI_SZ value.
    //
    if(KeyValueInformation->Type != REG_MULTI_SZ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make a preliminary pass through the buffer to count the number of strings
    // There will always be at least one string returned (possibly empty).
    //
    StringCount = 0;
    p = (PWCHAR)KEY_VALUE_DATA(KeyValueInformation);
    BufferEnd = (PWCHAR)((PUCHAR)p + KeyValueInformation->DataLength);
    while(p != BufferEnd) {
        if(!*p) {
            StringCount++;
            if(((p + 1) == BufferEnd) || !*(p + 1)) {
                break;
            }
        }
        p++;
    }
    if(p == BufferEnd) {
        StringCount++;
    }

    *UnicodeStringList = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING) * StringCount);
    if(!(*UnicodeStringList)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now, make a second pass through the buffer making copies of each string.
    //
    i = 0;
    StringStart = p = (PWCHAR)KEY_VALUE_DATA(KeyValueInformation);
    while(p != BufferEnd) {
        if(!*p) {
            StringLength = (ULONG)((PUCHAR)p - (PUCHAR)StringStart) + sizeof(UNICODE_NULL);
            (*UnicodeStringList)[i].Buffer = ExAllocatePool(PagedPool, StringLength);

            if(!((*UnicodeStringList)[i].Buffer)) {
                PipFreeUnicodeStringList(*UnicodeStringList, i);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory((*UnicodeStringList)[i].Buffer, StringStart, StringLength);

            (*UnicodeStringList)[i].Length =
                ((*UnicodeStringList)[i].MaximumLength = (USHORT)StringLength)
                - sizeof(UNICODE_NULL);

            i++;

            if(((p + 1) == BufferEnd) || !*(p + 1)) {
                break;
            } else {
                StringStart = p + 1;
            }
        }
        p++;
    }
    if(p == BufferEnd) {
        StringLength = (ULONG)((PUCHAR)p - (PUCHAR)StringStart);
        (*UnicodeStringList)[i].Buffer = ExAllocatePool(PagedPool,
                                                        StringLength + sizeof(UNICODE_NULL)
                                                       );
        if(!((*UnicodeStringList)[i].Buffer)) {
            PipFreeUnicodeStringList(*UnicodeStringList, i);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if(StringLength) {
            RtlCopyMemory((*UnicodeStringList)[i].Buffer, StringStart, StringLength);
        }
        (*UnicodeStringList)[i].Buffer[CB_TO_CWC(StringLength)] = UNICODE_NULL;

        (*UnicodeStringList)[i].MaximumLength =
                ((*UnicodeStringList)[i].Length = (USHORT)StringLength)
                + sizeof(UNICODE_NULL);
    }

    *UnicodeStringCount = StringCount;

    return STATUS_SUCCESS;
}

NTSTATUS
PipApplyFunctionToServiceInstances(
    IN     HANDLE ServiceKeyHandle OPTIONAL,
    IN     PUNICODE_STRING ServiceKeyName OPTIONAL,
    IN     ACCESS_MASK DesiredAccess,
    IN     BOOLEAN IgnoreNonCriticalErrors,
    IN     PIOP_SUBKEY_CALLBACK_ROUTINE DevInstCallbackRoutine,
    IN OUT PVOID Context,
    OUT    PULONG ServiceInstanceOrdinal OPTIONAL
    )

/*++

Routine Description:

    This routine enumerates all device instances referenced by the instance
    ordinal entries under a service's volatile Enum key, and calls
    the specified callback routine for each instance's corresponding subkey
    under HKLM\System\Enum.

Arguments:

    ServiceKeyHandle - Optional handle to the service entry. If this parameter
        is not specified, then the service key name must be given in
        ServiceKeyName (if both parameters are specified, then ServiceKeyHandle
        is used, and ServiceKeyName is ignored).

    ServiceKeyName - Optional name of the service entry key (under
        HKLM\CurrentControlSet\Services). If this parameter is not specified,
        then ServiceKeyHandle must contain a handle to the desired service key.

    DesiredAccess - Specifies the desired access that the callback routine
        needs to the enumerated device instance keys.  If no desired access is
        specified (i.e., DesiredAccess is zero), then no handle will be opened
        for the device instance keys, and the callback will be passed a NULL for
        its DeviceInstanceHandle parameter.

    IgnoreNonCriticalErrors - Specifies whether this function should
        immediately terminate on all errors, or only on critical ones.
        An example of a non-critical error is when an enumerated device instance
        key cannot be opened for the desired access.

    DevInstCallbackRoutine - Supplies a pointer to a function that will
        be called for each device instance key referenced by a service instance
        entry under the service's volatile Enum subkey. The prototype of the
        function is as follows:

            typedef BOOLEAN (*PIOP_SUBKEY_CALLBACK_ROUTINE) (
                IN     HANDLE DeviceInstanceHandle,
                IN     PUNICODE_STRING DeviceInstancePath,
                IN OUT PVOID Context
                );

        where DeviceInstanceHandle is the handle to an enumerated device instance
        key, DeviceInstancePath is the registry path (relative to
        HKLM\System\Enum) to this device instance, and Context is a pointer to
        user-defined data.

        This function should return TRUE to continue enumeration, or
        FALSE to terminate it.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each device instance key invocation.

    ServiceInstanceOrdinal - Optionally, receives the service instance ordinal (1 based)
        that terminated the enumeration, or the total number of instances enumerated
        if the enumeration completed without being aborted.

Return Value:

    NT status code indicating whether the device instance keys were successfully
    enumerated.  Note that this does not provide information on the success or
    failure of the callback routine--if desired, this information should be
    stored in the Context structure.

--*/

{
    NTSTATUS Status;
    HANDLE ServiceEnumHandle, SystemEnumHandle, DeviceInstanceHandle;
    UNICODE_STRING TempUnicodeString;
    ULONG ServiceInstanceCount, i, junk;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    BOOLEAN ContinueEnumeration;

    //
    // First, open up the volatile Enum subkey under the specified service entry.
    //

    if(ARGUMENT_PRESENT(ServiceKeyHandle)) {
        PiWstrToUnicodeString(&TempUnicodeString, REGSTR_KEY_ENUM);
        Status = IopOpenRegistryKeyEx( &ServiceEnumHandle,
                                       ServiceKeyHandle,
                                       &TempUnicodeString,
                                       KEY_READ
                                       );
    } else {
        Status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        NULL,
                                        &ServiceEnumHandle,
                                        FALSE
                                       );
    }
    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Find out how many instances are referenced in the service's Enum key.
    //

    ServiceInstanceCount = 0;   // assume none.

    Status = IopGetRegistryValue(ServiceEnumHandle,
                                 REGSTR_VALUE_COUNT,
                                 &KeyValueInformation
                                );
    if (NT_SUCCESS(Status)) {

        if((KeyValueInformation->Type == REG_DWORD) &&
           (KeyValueInformation->DataLength >= sizeof(ULONG))) {

            ServiceInstanceCount = *(PULONG)KEY_VALUE_DATA(KeyValueInformation);

        }
        ExFreePool(KeyValueInformation);

    } else if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        goto PrepareForReturn;
    } else {
        //
        // If 'Count' value entry not found, consider this to mean there are simply
        // no device instance controlled by this service.
        //
        Status = STATUS_SUCCESS;
    }

    //
    // Now, enumerate each service instance, and call the specified callback function
    // for the corresponding device instance.
    //

    if (ServiceInstanceCount) {

        if (DesiredAccess) {
            Status = IopOpenRegistryKeyEx( &SystemEnumHandle,
                                           NULL,
                                           &CmRegistryMachineSystemCurrentControlSetEnumName,
                                           KEY_READ
                                           );
            if(!NT_SUCCESS(Status)) {
                goto PrepareForReturn;
            }
        } else {
            //
            // Set DeviceInstanceHandle to NULL, since we won't be opening up the
            // device instance keys.
            //
            DeviceInstanceHandle = NULL;
        }
        KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePool(
                                                              PagedPool,
                                                              PNP_SCRATCH_BUFFER_SIZE);
        if (!KeyValueInformation) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto PrepareForReturn;
        }

        for (i = 0; ; i++) {

            Status = ZwEnumerateValueKey(
                            ServiceEnumHandle,
                            i,
                            KeyValueFullInformation,
                            KeyValueInformation,
                            PNP_SCRATCH_BUFFER_SIZE,
                            &junk
                            );

            if (!NT_SUCCESS (Status)) {
                if (Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                    break;
                } else if (IgnoreNonCriticalErrors) {
                    continue;
                } else {
                    break;
                }
            }

            if (KeyValueInformation->Type != REG_SZ) {
                continue;
            }

            ContinueEnumeration = TRUE;
            TempUnicodeString.Length = 0;
            IopRegistryDataToUnicodeString(&TempUnicodeString,
                                           (PWSTR)KEY_VALUE_DATA(KeyValueInformation),
                                           KeyValueInformation->DataLength
                                           );
            if (TempUnicodeString.Length) {

                //
                // We have retrieved a (non-empty) string for this service instance.
                // If the user specified a non-zero value for the DesiredAccess
                // parameter, we will attempt to open up the corresponding device
                // instance key under HKLM\System\Enum.
                //
                if (DesiredAccess) {
                    Status = IopOpenRegistryKeyEx( &DeviceInstanceHandle,
                                                   SystemEnumHandle,
                                                   &TempUnicodeString,
                                                   DesiredAccess
                                                   );
                }

                if (NT_SUCCESS(Status)) {
                    //
                    // Invoke the specified callback routine for this device instance.
                    //
                    ContinueEnumeration = DevInstCallbackRoutine(DeviceInstanceHandle,
                                                                 &TempUnicodeString,
                                                                 Context
                                                                );
                    if (DesiredAccess) {
                        ZwClose(DeviceInstanceHandle);
                    }
                } else if (IgnoreNonCriticalErrors) {
                    continue;
                } else {
                    break;
                }
            } else {
                continue;
            }
            if (!ContinueEnumeration) {
                break;
            }
        }

        if (ARGUMENT_PRESENT(ServiceInstanceOrdinal)) {
            *ServiceInstanceOrdinal = i;
        }

        if (DesiredAccess) {
            ZwClose(SystemEnumHandle);
        }
        ExFreePool(KeyValueInformation);
    }


PrepareForReturn:

    ZwClose(ServiceEnumHandle);

    return Status;
}

BOOLEAN
PipIsDuplicatedDevices(
    IN PCM_RESOURCE_LIST Configuration1,
    IN PCM_RESOURCE_LIST Configuration2,
    IN PHAL_BUS_INFORMATION BusInfo1 OPTIONAL,
    IN PHAL_BUS_INFORMATION BusInfo2 OPTIONAL
    )

/*++

Routine Description:

    This routine compares two set of configurations and bus information to
    determine if the resources indicate the same device.  If BusInfo1 and
    BusInfo2 both are absent, it means caller wants to compare the raw
    resources.

Arguments:

    Configuration1 - Supplies a pointer to the first set of resource.

    Configuration2 - Supplies a pointer to the second set of resource.

    BusInfo1 - Supplies a pointer to the first set of bus information.

    BusInfo2 - Supplies a pointer to the second set of bus information.

Return Value:

    returns TRUE if the two set of resources indicate the same device;
    otherwise a value of FALSE is returned.

--*/

{
    PCM_PARTIAL_RESOURCE_LIST list1, list2;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR descriptor1, descriptor2;

    ULONG i, j;
    ULONG pass = 0;

    //
    // The BusInfo for both resources must be both present or not present.
    //

    if ((ARGUMENT_PRESENT(BusInfo1) && !ARGUMENT_PRESENT(BusInfo2)) ||
        (!ARGUMENT_PRESENT(BusInfo1) && ARGUMENT_PRESENT(BusInfo2))) {

        //
        // Unable to determine.
        //

        return FALSE;
    }

    //
    // Next check resources used by the two devices.
    // Currently, we *only* check the Io ports.
    //

    if (Configuration1->Count == 0 || Configuration2->Count == 0) {

        //
        // If any one of the configuration data is empty, we assume
        // the devices are not duplicates.
        //

        return FALSE;
    }

RedoScan:

    list1 = &(Configuration1->List[0].PartialResourceList);
    list2 = &(Configuration2->List[0].PartialResourceList);

    for(i = 0, descriptor1 = list1->PartialDescriptors;
        i < list1->Count;
        i++, descriptor1++) {

        //
        // If this is an i/o port or a memory range then look for a match
        // in the other list.
        //

        if((descriptor1->Type == CmResourceTypePort) ||
           (descriptor1->Type == CmResourceTypeMemory)) {

            for(j = 0, descriptor2 = list2->PartialDescriptors;
                j < list2->Count;
                j++, descriptor2++) {

                //
                // If the types match then check to see if both addresses
                // match as well.  If bus info was provided then go ahead
                // and translate the ranges first.
                //

                if(descriptor1->Type == descriptor2->Type) {

                    PHYSICAL_ADDRESS range1, range1Translated;
                    PHYSICAL_ADDRESS range2, range2Translated;
                    ULONG range1IoSpace, range2IoSpace;

                    range1 = descriptor1->u.Generic.Start;
                    range2 = descriptor2->u.Generic.Start;

                    if((range1.QuadPart == 0) ||
                       (BusInfo1 == NULL) ||
                       (HalTranslateBusAddress(
                            BusInfo1->BusType,
                            BusInfo1->BusNumber,
                            range1,
                            &range1IoSpace,
                            &range1Translated) == FALSE)) {

                        range1Translated = range1;
                        range1IoSpace =
                            (descriptor1->Type == CmResourceTypePort) ? TRUE :
                                                                        FALSE;
                    }

                    if((range2.QuadPart == 0) ||
                       (BusInfo2 == NULL) ||
                       (HalTranslateBusAddress(
                            BusInfo2->BusType,
                            BusInfo2->BusNumber,
                            range2,
                            &range2IoSpace,
                            &range2Translated) == FALSE)) {

                        range2Translated = range2;
                        range2IoSpace =
                            (descriptor2->Type == CmResourceTypePort) ? TRUE :
                                                                        FALSE;
                    }

                    //
                    // If the ranges are in the same space and start at the
                    // same location then break out and go on to the next
                    // range
                    //

                    if((range1Translated.QuadPart == range2Translated.QuadPart) &&
                       (range1IoSpace == range2IoSpace)) {

                        break;
                    }
                }
            }

            //
            // If we made it all the way through the resource list without
            // finding a match then these are not duplicates.
            //

            if(j == list2->Count) {
                return FALSE;
            }
        }
    }

    //
    // If every resource in list 1 exists in list 2 then we also need to make
    // sure that every resource in list 2 exists in list 1.
    //

    if(pass == 0) {

        PVOID tmp ;

        tmp = Configuration2;
        Configuration2 = Configuration1;
        Configuration1 = tmp;

        tmp = BusInfo2;
        BusInfo2 = BusInfo1;
        BusInfo1 = tmp;

        pass = 1;

        goto RedoScan;
    }

    return TRUE;
}

VOID
PipFreeUnicodeStringList(
    IN PUNICODE_STRING UnicodeStringList,
    IN ULONG StringCount
    )

/*++

Routine Description:

    This routine frees the buffer for each UNICODE_STRING in the specified list
    (there are StringCount of them), and then frees the memory used for the
    string list itself.

Arguments:

    UnicodeStringList - Supplies a pointer to an array of UNICODE_STRINGs.

    StringCount - Supplies the number of strings in the UnicodeStringList array.

Returns:

    None.

    NOTE: This function is only available during INIT time!

--*/

{
    ULONG i;

    if(UnicodeStringList) {
        for(i = 0; i < StringCount; i++) {
            if(UnicodeStringList[i].Buffer) {
                ExFreePool(UnicodeStringList[i].Buffer);
            }
        }
        ExFreePool(UnicodeStringList);
    }
}

NTSTATUS
IopDriverLoadingFailed(
    IN HANDLE ServiceHandle OPTIONAL,
    IN PUNICODE_STRING ServiceName OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked when driver failed to start.  All the device
    instances controlled by this driver/service are marked as failing to
    start.

Arguments:

    ServiceKeyHandle - Optionally, supplies a handle to the driver service node in the
        registry that controls this device instance.  If this argument is not specified,
        then ServiceKeyName is used to specify the service entry.

    ServiceKeyName - Optionally supplies the name of the service entry that controls
        the device instance. This must be specified if ServiceKeyHandle isn't given.

Returns:

    None.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    BOOLEAN closeHandle = FALSE, deletePdo;
    HANDLE handle, serviceEnumHandle, controlHandle, devInstHandle;
    HANDLE sysEnumHandle = NULL;
    ULONG deviceFlags, count, newCount, i, j;
    UNICODE_STRING unicodeValueName, deviceInstanceName;
    WCHAR unicodeBuffer[20];

    //
    // Open registry ServiceKeyName\Enum branch
    //

    if (!ARGUMENT_PRESENT(ServiceHandle)) {
        status = PipOpenServiceEnumKeys(ServiceName,
                                        KEY_READ,
                                        &ServiceHandle,
                                        &serviceEnumHandle,
                                        FALSE
                                        );
        closeHandle = TRUE;
    } else {
        PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx( &serviceEnumHandle,
                                       ServiceHandle,
                                       &unicodeValueName,
                                       KEY_READ
                                       );
    }
    if (!NT_SUCCESS( status )) {

        //
        // No Service Enum key? no device instance.  Return FALSE.
        //

        return status;
    }

    //
    // Set "STARTFAILED" flags.  So, we won't load it again.
    //

    PiWstrToUnicodeString(&unicodeValueName, L"INITSTARTFAILED");
    deviceFlags = 1;
    ZwSetValueKey(
                serviceEnumHandle,
                &unicodeValueName,
                TITLE_INDEX_VALUE,
                REG_DWORD,
                &deviceFlags,
                sizeof(deviceFlags)
                );

    //
    // Find out how many device instances listed in the ServiceName's
    // Enum key.
    //

    status = IopGetRegistryValue ( serviceEnumHandle,
                                   REGSTR_VALUE_COUNT,
                                   &keyValueInformation
                                   );
    count = 0;
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (count == 0) {
        ZwClose(serviceEnumHandle);
        if (closeHandle) {
            ZwClose(ServiceHandle);
        }
        return status;
    }

    //
    // Open HTREE\ROOT\0 key so later we can remove device instance key
    // from its AttachedComponents value name.
    //

    status = IopOpenRegistryKeyEx( &sysEnumHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_ALL_ACCESS
                                   );

    //
    // Walk through each registered device instance to mark its Problem and
    // StatusFlags as fail to start and reset its ActiveService
    //

    newCount = count;
    for (i = 0; i < count; i++) {
        deletePdo = FALSE;
        status = PipServiceInstanceToDeviceInstance (
                     ServiceHandle,
                     ServiceName,
                     i,
                     &deviceInstanceName,
                     &handle,
                     KEY_ALL_ACCESS
                     );

        if (NT_SUCCESS(status)) {

            PDEVICE_OBJECT deviceObject;
            PDEVICE_NODE deviceNode;

            //
            // If the device instance is a detected device reported during driver's
            // DriverEntry we need to clean it up.
            //

            deviceObject = IopDeviceObjectFromDeviceInstance(&deviceInstanceName);
            if (deviceObject) {
                deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
                if (deviceNode) {

                    IopReleaseDeviceResources(deviceNode, TRUE);

                    if ((deviceNode->Flags & DNF_MADEUP) &&
                        ((deviceNode->State == DeviceNodeStarted) ||
                        (deviceNode->State == DeviceNodeStartPostWork))) {

                        //
                        // Now mark this one deleted.
                        //
                        PipSetDevNodeState(deviceNode, DeviceNodeRemoved, NULL);

                        PipSetDevNodeProblem(deviceNode, CM_PROB_DEVICE_NOT_THERE);

                        deletePdo = TRUE;
                    }
                }
                ObDereferenceObject(deviceObject);  // added via IopDeviceObjectFromDeviceInstance
            }

            PiLockPnpRegistry(FALSE);

            PiWstrToUnicodeString(&unicodeValueName, REGSTR_KEY_CONTROL);
            controlHandle = NULL;
            status = IopOpenRegistryKeyEx( &controlHandle,
                                           handle,
                                           &unicodeValueName,
                                           KEY_ALL_ACCESS
                                           );
            if (NT_SUCCESS(status)) {

                status = IopGetRegistryValue(controlHandle,
                                             REGSTR_VALUE_NEWLY_CREATED,
                                             &keyValueInformation);
                if (NT_SUCCESS(status)) {
                    ExFreePool(keyValueInformation);
                }
                if ((status != STATUS_OBJECT_NAME_NOT_FOUND) &&
                    (status != STATUS_OBJECT_PATH_NOT_FOUND)) {

                    //
                    // Remove the instance value name from service enum key
                    //

                    PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, i);
                    status = ZwDeleteValueKey (serviceEnumHandle, &unicodeValueName);
                    if (NT_SUCCESS(status)) {

                        //
                        // If we can successfaully remove the instance value entry
                        // from service enum key, we then remove the device instance key
                        // Otherwise, we go thru normal path to mark driver loading failed
                        // in the device instance key.
                        //

                        newCount--;

                        ZwDeleteKey(controlHandle);
                        ZwDeleteKey(handle);


                        //
                        // We also want to delete the ROOT\LEGACY_<driver> key
                        //

                        if (sysEnumHandle) {
                            deviceInstanceName.Length -= 5 * sizeof(WCHAR);
                            deviceInstanceName.Buffer[deviceInstanceName.Length / sizeof(WCHAR)] =
                                                 UNICODE_NULL;
                            status = IopOpenRegistryKeyEx( &devInstHandle,
                                                           sysEnumHandle,
                                                           &deviceInstanceName,
                                                           KEY_ALL_ACCESS
                                                           );
                            if (NT_SUCCESS(status)) {
                                ZwDeleteKey(devInstHandle);
                                ZwClose(devInstHandle);
                            }
                        }

                        //
                        // If there is a PDO for this device, remove it
                        //

                        if (deletePdo) {
                            IoDeleteDevice(deviceObject);
                        }

                        ZwClose(controlHandle);
                        ZwClose(handle);
                        IopCleanupDeviceRegistryValues(&deviceInstanceName);

                        ExFreePool(deviceInstanceName.Buffer);
                        PiUnlockPnpRegistry();
                        continue;
                    }
                }
            }

            //
            // Reset Control\ActiveService value name.
            //

            if (controlHandle) {
                PiWstrToUnicodeString(&unicodeValueName, REGSTR_VAL_ACTIVESERVICE);
                ZwDeleteValueKey(controlHandle, &unicodeValueName);
                ZwClose(controlHandle);
            }

            ZwClose(handle);
            ExFreePool(deviceInstanceName.Buffer);

            PiUnlockPnpRegistry();
        }
    }

    //
    // If some instance value entry is deleted, we need to update the count of instance
    // value entries and rearrange the instance value entries under service enum key.
    //

    if (newCount != count) {

        PiLockPnpRegistry(FALSE);

        if (newCount != 0) {
            j = 0;
            i = 0;
            while (i < count) {
                PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, i);
                status = IopGetRegistryValue(serviceEnumHandle,
                                             unicodeValueName.Buffer,
                                             &keyValueInformation
                                             );
                if (NT_SUCCESS(status)) {
                    if (i != j) {

                        //
                        // Need to change the instance i to instance j
                        //

                        ZwDeleteValueKey(serviceEnumHandle, &unicodeValueName);

                        PiUlongToUnicodeString(&unicodeValueName, unicodeBuffer, 20, j);
                        ZwSetValueKey (serviceEnumHandle,
                                       &unicodeValueName,
                                       TITLE_INDEX_VALUE,
                                       REG_SZ,
                                       (PVOID)KEY_VALUE_DATA(keyValueInformation),
                                       keyValueInformation->DataLength
                                       );
                    }
                    ExFreePool(keyValueInformation);
                    j++;
                }
                i++;
            }
        }

        //
        // Don't forget to update the "Count=" and "NextInstance=" value entries
        //

        PiWstrToUnicodeString( &unicodeValueName, REGSTR_VALUE_COUNT);

        ZwSetValueKey(serviceEnumHandle,
                      &unicodeValueName,
                      TITLE_INDEX_VALUE,
                      REG_DWORD,
                      &newCount,
                      sizeof (newCount)
                      );
        PiWstrToUnicodeString( &unicodeValueName, REGSTR_VALUE_NEXT_INSTANCE);

        ZwSetValueKey(serviceEnumHandle,
                      &unicodeValueName,
                      TITLE_INDEX_VALUE,
                      REG_DWORD,
                      &newCount,
                      sizeof (newCount)
                      );

        PiUnlockPnpRegistry();
    }
    ZwClose(serviceEnumHandle);
    if (closeHandle) {
        ZwClose(ServiceHandle);
    }
    if (sysEnumHandle) {
        ZwClose(sysEnumHandle);
    }

    return STATUS_SUCCESS;
}

VOID
IopDisableDevice(
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    This routine tries to ask a bus driver stopping decoding resources

Arguments:

    DeviceNode - Specifies the device to be disabled.

    Handle - specifies the device instance handle.

Returns:

    None.

--*/

{
    NTSTATUS status;

    //
    // If the device has boot config, we will query-remove and remove the device to free
    // the boot config if possible.
    //

    status = IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

    if (NT_SUCCESS(status)) {

        status = IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_REMOVE_DEVICE);
        ASSERT(NT_SUCCESS(status));
        IopReleaseDeviceResources(DeviceNode, TRUE);

    } else {

        IopRemoveDevice (DeviceNode->PhysicalDeviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);
    }

    if (PipDoesDevNodeHaveProblem(DeviceNode)) {
        ASSERT(PipIsDevNodeProblem(DeviceNode, CM_PROB_NOT_CONFIGURED) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_FAILED_INSTALL) ||
               PipIsDevNodeProblem(DeviceNode, CM_PROB_REINSTALL));

        PipClearDevNodeProblem(DeviceNode);
    }

    PipSetDevNodeProblem(DeviceNode, CM_PROB_DISABLED);
}

BOOLEAN
IopIsAnyDeviceInstanceEnabled(
    IN PUNICODE_STRING ServiceKeyName,
    IN HANDLE ServiceHandle OPTIONAL,
    IN BOOLEAN LegacyIncluded
    )

/*++

Routine Description:

    This routine checks if any of the devices instances is turned on for the specified
    service. This routine is used for Pnp Driver only and is temporary function to support
    SUR.

Arguments:

    ServiceKeyName - Specifies the service key unicode name

    ServiceHandle - Optionally supplies a handle to the service key to be checked.

    LegacyIncluded - TRUE, a legacy device instance key is counted as a device instance.
                     FALSE, a legacy device instance key is not counted.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    HANDLE serviceEnumHandle, handle, controlHandle;
    ULONG i, count, deviceFlags;
    UNICODE_STRING unicodeName, instancePath;
    BOOLEAN enabled, closeHandle = FALSE;
    PDEVICE_OBJECT physicalDeviceObject;
    PDEVICE_NODE deviceNode;

    //
    // Open registry ServiceKeyName\Enum branch
    //

    if (!ARGUMENT_PRESENT(ServiceHandle)) {
        status = PipOpenServiceEnumKeys(ServiceKeyName,
                                        KEY_READ,
                                        &ServiceHandle,
                                        &serviceEnumHandle,
                                        FALSE
                                        );
        closeHandle = TRUE;
    } else {
        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_ENUM);
        status = IopOpenRegistryKeyEx( &serviceEnumHandle,
                                       ServiceHandle,
                                       &unicodeName,
                                       KEY_READ
                                       );
    }
    if (!NT_SUCCESS( status )) {

        //
        // No Service Enum key? no device instance.  Return FALSE.
        //

        return FALSE;
    }

    //
    // Find out how many device instances listed in the ServiceName's
    // Enum key.
    //

    status = IopGetRegistryValue ( serviceEnumHandle,
                                   REGSTR_VALUE_COUNT,
                                   &keyValueInformation
                                   );
    ZwClose(serviceEnumHandle);
    count = 0;
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {

            count = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (count == 0) {
        if (closeHandle) {
            ZwClose(ServiceHandle);
        }
        return FALSE;
    }

    //
    // Walk through each registered device instance to check it is enabled.
    //

    enabled = FALSE;
    for (i = 0; i < count; i++) {

        //
        // Get device instance handle.  If it fails, we will skip this device
        // instance.
        //

        status = PipServiceInstanceToDeviceInstance (
                     ServiceHandle,
                     NULL,
                     i,
                     &instancePath,
                     &handle,
                     KEY_ALL_ACCESS
                     );
        if (!NT_SUCCESS(status)) {
            continue;
        }

        physicalDeviceObject = IopDeviceObjectFromDeviceInstance(&instancePath);
        ExFreePool(instancePath.Buffer);
        if (physicalDeviceObject) {
            deviceNode = (PDEVICE_NODE)physicalDeviceObject->DeviceObjectExtension->DeviceNode;
            if (deviceNode && (PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED) || PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED))) {
                ZwClose(handle);
                ObDereferenceObject(physicalDeviceObject);
                continue;
            }
        } else {
            deviceNode = NULL;
        }

        //
        // Check if the device instance has been disabled.
        // First check global flag: CONFIGFLAG and then CSCONFIGFLAG.
        //

        deviceFlags = 0;
        status = IopGetRegistryValue(handle,
                                     REGSTR_VALUE_CONFIG_FLAGS,
                                     &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if ((keyValueInformation->Type == REG_DWORD) &&
                (keyValueInformation->DataLength >= sizeof(ULONG))) {

                deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }

        if (deviceFlags & CONFIGFLAG_DISABLED) {

            //
            // Convert this flag into the hardware profile-specific version, so it'll
            // look the same as the CsConfigFlags we retrieve below.
            //

            deviceFlags = CSCONFIGFLAG_DISABLED;

        } else {

            status = PipGetServiceInstanceCsConfigFlags( ServiceKeyName,
                                                         i,
                                                         &deviceFlags
                                                         );

            if (!NT_SUCCESS(status)) {
                deviceFlags = 0;
            }
        }

        //
        // If the device is disabled (either globally, or specifically for this
        // hardware profile), then mark the devnode as DNF_DISABLED.
        //

        if ((deviceFlags & CSCONFIGFLAG_DISABLED) || (deviceFlags & CSCONFIGFLAG_DO_NOT_START)) {

            if (deviceNode) {
                IopDisableDevice(deviceNode);
            }
        }

        if (physicalDeviceObject) {
            ObDereferenceObject(physicalDeviceObject);
        }

        //
        // Finally, we need to set the STATUSFLAGS of the device instance to
        // indicate if the driver is successfully started.
        //

        if (!(deviceFlags & (CSCONFIGFLAG_DISABLED | CSCONFIGFLAG_DO_NOT_CREATE | CSCONFIGFLAG_DO_NOT_START))) {

            ULONG legacy;

            //
            // Check should legacy instance key be counted as an enabled device
            //

            if (LegacyIncluded == FALSE) {

                //
                // The legacy variable must be initialized to zero.  Because the device
                // instance key may be an enumerated device.  In this case, there is no
                // legacy value name.
                //

                legacy = 0;
                status = IopGetRegistryValue(handle,
                                             REGSTR_VALUE_LEGACY,
                                             &keyValueInformation
                                             );
                if (NT_SUCCESS(status)) {
                    if ((keyValueInformation->Type == REG_DWORD) &&
                        (keyValueInformation->DataLength >= sizeof(ULONG))) {
                        legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                    }
                    ExFreePool(keyValueInformation);
                }
            } else {
                legacy = 0;
            }

            if (legacy == 0) {

                //
                // Mark that the driver has at least a device instance to work with.
                //

                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
                status = IopCreateRegistryKeyEx( &controlHandle,
                                                 handle,
                                                 &unicodeName,
                                                 KEY_ALL_ACCESS,
                                                 REG_OPTION_VOLATILE,
                                                 NULL
                                                 );
                if (NT_SUCCESS(status)) {
                    PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_ACTIVESERVICE);
                    ZwSetValueKey(
                                controlHandle,
                                &unicodeName,
                                TITLE_INDEX_VALUE,
                                REG_SZ,
                                ServiceKeyName->Buffer,
                                ServiceKeyName->Length + sizeof(UNICODE_NULL)
                                );

                    ZwClose(controlHandle);
                }
                enabled = TRUE;
            }
        }
        ZwClose(handle);
    }

    if (closeHandle) {
        ZwClose(ServiceHandle);
    }
    return enabled;
}

BOOLEAN
IopIsDeviceInstanceEnabled(
    IN HANDLE DeviceInstanceHandle      OPTIONAL,
    IN PUNICODE_STRING DeviceInstance,
    IN BOOLEAN DisableIfEnabled
    )

/*++

Routine Description:

    This routine checks if the specified devices instances is enabled.

Arguments:

    DeviceInstanceHandle - Optionally supplies a handle to the device instance
        key to be checked.

    DeviceInstance - Specifies the device instance key unicode name.  Caller
        must at least specified DeviceInstanceHandle or DeviceInstance.

    DisableIfEnabled - If this flag is set, and the device should be disabled
        but is currently disabled, then the device is disabled.

Returns:

    A BOOLEAN value.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    HANDLE handle, handle1;
    ULONG deviceFlags;
    BOOLEAN enabled, closeHandle = FALSE;
    UNICODE_STRING unicodeString;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_NODE deviceNode = NULL;

    //
    // Open registry ServiceKeyName\Enum branch
    //

    if (!ARGUMENT_PRESENT(DeviceInstanceHandle)) {
        status = IopOpenRegistryKeyEx( &handle,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_READ
                                       );

        if (NT_SUCCESS( status )) {

            status = IopOpenRegistryKeyEx( &DeviceInstanceHandle,
                                           handle,
                                           DeviceInstance,
                                           KEY_READ
                                           );
            ZwClose(handle);
        }

        if (!NT_SUCCESS( status )) {
            return FALSE;
        }
        closeHandle = TRUE;
    }

    enabled = TRUE;

    //
    // First check the device node
    //

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    if (deviceObject) {
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode && (PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED) || PipIsDevNodeProblem(deviceNode, CM_PROB_HARDWARE_DISABLED))) {
            enabled = FALSE;
            goto exit;
        }
    }

    //
    // Check if the device instance has been disabled.
    // First check global flag: CONFIGFLAG and then CSCONFIGFLAG.
    //

    deviceFlags = 0;
    status = IopGetRegistryValue(DeviceInstanceHandle,
                                 REGSTR_VALUE_CONFIG_FLAGS,
                                 &keyValueInformation);
    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength >= sizeof(ULONG))) {
            deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (!(deviceFlags & CONFIGFLAG_DISABLED)) {
        enabled = TRUE;

        //
        // See if we can open current hardware profile
        //
        status = IopOpenRegistryKeyEx( &handle1,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent,
                                       KEY_READ
                                       );

        if (NT_SUCCESS(status) && DeviceInstance != NULL) {

            //
            // Now, we must open the System\CCS\Enum key under this.
            //
            //
            // Open system\CurrentControlSet under current hardware profile key
            //

            PiWstrToUnicodeString(&unicodeString, REGSTR_PATH_CURRENTCONTROLSET);
            status = IopOpenRegistryKeyEx( &handle,
                                           handle1,
                                           &unicodeString,
                                           KEY_READ
                                           );
            ZwClose(handle1);
            if (NT_SUCCESS(status)) {
                PiWstrToUnicodeString(&unicodeString, REGSTR_KEY_ENUM);
                status = IopOpenRegistryKeyEx( &handle1,
                                               handle,
                                               &unicodeString,
                                               KEY_READ
                                               );
                ZwClose(handle);
                if (NT_SUCCESS(status)) {
                    status = IopOpenRegistryKeyEx( &handle,
                                                   handle1,
                                                   DeviceInstance,
                                                   KEY_READ
                                                   );
                    ZwClose(handle1);
                    if (NT_SUCCESS(status)) {
                        status = IopGetRegistryValue(
                                        handle,
                                        REGSTR_VALUE_CSCONFIG_FLAGS,
                                        &keyValueInformation
                                        );
                        if (NT_SUCCESS(status)) {
                            if((keyValueInformation->Type == REG_DWORD) &&
                               (keyValueInformation->DataLength >= sizeof(ULONG))) {
                               deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                            }
                            ExFreePool(keyValueInformation);
                        }
                        ZwClose(handle);
                        if (NT_SUCCESS(status)) {
                            if ((deviceFlags & CSCONFIGFLAG_DISABLED) ||
                                (deviceFlags & CSCONFIGFLAG_DO_NOT_CREATE) ||
                                (deviceFlags & CSCONFIGFLAG_DO_NOT_START)) {
                                enabled = FALSE;
                            }
                        }
                    }
                }
            }
        }
    } else {
        enabled = FALSE;
    }

    //
    // If the device is disabled and has device node associated with it.
    // disable the device.
    //

    if (enabled == FALSE && deviceNode && DisableIfEnabled) {
        IopDisableDevice(deviceNode);
    }
exit:
    if (deviceObject) {
        ObDereferenceObject(deviceObject);
    }
    if (closeHandle) {
        ZwClose(DeviceInstanceHandle);
    }
    return enabled;
}

ULONG
IopDetermineResourceListSize(
    IN PCM_RESOURCE_LIST ResourceList
    )

/*++

Routine Description:

    This routine determines size of the passed in ResourceList
    structure.

Arguments:

    Configuration1 - Supplies a pointer to the resource list.

Return Value:

    size of the resource list structure.

--*/

{
    ULONG totalSize, listSize, descriptorSize, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR fullResourceDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    if (!ResourceList) {
        totalSize = 0;
    } else {
        totalSize = FIELD_OFFSET(CM_RESOURCE_LIST, List);
        fullResourceDesc = &ResourceList->List[0];
        for (i = 0; i < ResourceList->Count; i++) {
            listSize = FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR,
                                    PartialResourceList) +
                       FIELD_OFFSET(CM_PARTIAL_RESOURCE_LIST,
                                    PartialDescriptors);
            partialDescriptor = &fullResourceDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < fullResourceDesc->PartialResourceList.Count; j++) {
                descriptorSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                if (partialDescriptor->Type == CmResourceTypeDeviceSpecific) {
                    descriptorSize += partialDescriptor->u.DeviceSpecificData.DataSize;
                }
                listSize += descriptorSize;
                partialDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                                        ((PUCHAR)partialDescriptor + descriptorSize);
            }
            totalSize += listSize;
            fullResourceDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)
                                      ((PUCHAR)fullResourceDesc + listSize);
        }
    }
    return totalSize;
}

VOID
PpInitializeDeviceReferenceTable(
    VOID
    )

/*++

Routine Description:

    This routine initializes data structures associated with the device
    reference table.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ExInitializeFastMutex(&PpDeviceReferenceTableLock);
    RtlInitializeGenericTable(  &PpDeviceReferenceTable,
                                PiCompareInstancePath,
                                PiAllocateGenericTableEntry,
                                PiFreeGenericTableEntry,
                                NULL);
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareInstancePath(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    )

/*++

Routine Description:

    This routine is the callback for the generic table routines.

Arguments:

    Table       - Table for which this is invoked.

    FirstStruct - An element in the table to compare.

    SecondStruct - Another element in the table to compare.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS.

--*/

{
    PUNICODE_STRING lhs = ((PDEVICE_REFERENCE)FirstStruct)->DeviceInstance;
    PUNICODE_STRING rhs = ((PDEVICE_REFERENCE)SecondStruct)->DeviceInstance;
    LONG            result;

    PAGED_CODE();

    result = RtlCompareUnicodeString(lhs, rhs, TRUE);
    if (result < 0) {

        return GenericLessThan;
    } else if (result > 0) {

        return GenericGreaterThan;
    }
    return GenericEqual;
}

PVOID
NTAPI
PiAllocateGenericTableEntry(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  CLONG                       ByteSize
    )

/*++

Routine Description:

    This routine is the callback for allocation for entries in the generic table.

Arguments:

    Table       - Table for which this is invoked.

    ByteSize    - Amount of memory to allocate.

Return Value:

    Pointer to allocated memory if successful, else NULL.

--*/

{
    PAGED_CODE();

    return ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, ByteSize);
}

VOID
NTAPI
PiFreeGenericTableEntry(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       Buffer
    )

/*++

Routine Description:

    This routine is the callback for releasing memory for entries in the generic
    table.

Arguments:

    Table       - Table for which this is invoked.

    Buffer      - Buffer to free.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool(Buffer);
}

NTSTATUS
IopMapDeviceObjectToDeviceInstance(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PUNICODE_STRING  DeviceInstance
    )
/*++

Routine Description:

    This routine adds a reference for the specified device to the
    PpDeviceReferenceTable lookup table.

    Note, caller must own the PpRegistryDeviceResource before calling the
    function.

Arguments:

    DeviceObject - supplies a pointer to a physical device object.

    DeviceInstance - supplies a UNICODE_STRING to specify the device instance path.

Return Value:

    Status code that indicates whether or not the function was successful.

--*/

{
    NTSTATUS    status;
    HANDLE      hEnum, hInstance, hControl;
    UNICODE_STRING unicodeKeyName;
    DEVICE_REFERENCE deviceReference;
#if DBG
    PDEVICE_OBJECT oldDeviceObject;
#endif

#if DBG
    oldDeviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    ASSERT(!oldDeviceObject);
    if (oldDeviceObject) {

        ObDereferenceObject(oldDeviceObject);
    }
#endif

    deviceReference.DeviceObject    = DeviceObject;
    deviceReference.DeviceInstance  = DeviceInstance;
    ExAcquireFastMutex(&PpDeviceReferenceTableLock);
    if (RtlInsertElementGenericTable(&PpDeviceReferenceTable,
                                     (PVOID)&deviceReference,
                                     (CLONG)sizeof(DEVICE_REFERENCE),
                                     NULL)) {
        status = STATUS_SUCCESS;
    } else {

        status = STATUS_UNSUCCESSFUL;
    }
    ExReleaseFastMutex(&PpDeviceReferenceTableLock);

    if (NT_SUCCESS(status)) {
        //
        // Create the volatile Control subkey for this device instance,
        // since user-mode depends on it to be present for non-phantom
        // devices.
        //
        // NTRAID #174944-2000/08/30-jamesca:
        // Remove dependence on the presence of volatile Control subkey
        // for present devices.
        //
        status = IopOpenRegistryKeyEx(&hEnum,
                                      NULL,
                                      &CmRegistryMachineSystemCurrentControlSetEnumName,
                                      KEY_READ);
        if (NT_SUCCESS(status)) {
            status = IopOpenRegistryKeyEx(&hInstance,
                                          hEnum,
                                          DeviceInstance,
                                          KEY_ALL_ACCESS);
            if (NT_SUCCESS(status)) {
                PiWstrToUnicodeString(&unicodeKeyName, REGSTR_KEY_CONTROL);
                status = IopCreateRegistryKeyEx(&hControl,
                                                hInstance,
                                                &unicodeKeyName,
                                                KEY_ALL_ACCESS,
                                                REG_OPTION_VOLATILE,
                                                NULL);
                if (NT_SUCCESS(status)) {
                    ZwClose(hControl);
                }
                ZwClose(hInstance);
            }
            ZwClose(hEnum);
        }

        //
        // The attempt to create the volatile Control subkey should always
        // succeed, but just in case it didn't, make sure to always return
        // STATUS_SUCCESS when the device reference is successfully added to
        // the table.
        //
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;
    }

    return status;
}

PDEVICE_OBJECT
IopDeviceObjectFromDeviceInstance(
    IN PUNICODE_STRING  DeviceInstance
    )

/*++

Routine Description:

    This routine receives a DeviceInstance path (or DeviceInstance handle) and
    returns a reference to a bus device object for the DeviceInstance.

    Note, caller must owner the PpRegistryDeviceResource before calling the function,

Arguments:

    DeviceInstance - supplies a UNICODE_STRING to specify the device instance path.

Returns:

    A reference to the desired bus device object.

--*/

{
    DEVICE_REFERENCE    key;
    PDEVICE_REFERENCE   deviceReference;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_NODE        deviceNode;

    PAGED_CODE();
    //
    // Look-up the DO in our table.
    //
    deviceObject        = NULL;
    key.DeviceObject    = NULL;
    key.DeviceInstance  = DeviceInstance;
    ExAcquireFastMutex(&PpDeviceReferenceTableLock);

    deviceReference = RtlLookupElementGenericTable(&PpDeviceReferenceTable, (PVOID)&key);
    if (deviceReference) {

        deviceObject = deviceReference->DeviceObject;
        ASSERT(deviceObject);
        if (deviceObject) {

            ASSERT(deviceObject->Type == IO_TYPE_DEVICE);
            if (deviceObject->Type != IO_TYPE_DEVICE) {

                deviceObject = NULL;
            } else {

                deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
                ASSERT(deviceNode && (deviceNode->PhysicalDeviceObject == deviceObject));
                if (!deviceNode || deviceNode->PhysicalDeviceObject != deviceObject) {

                    deviceObject = NULL;
                }
            }
        }
    }
    //
    // Take a reference if we found the device object.
    //
    if (deviceObject) {

        ObReferenceObject(deviceObject);
    }

    ExReleaseFastMutex(&PpDeviceReferenceTableLock);

    return deviceObject;
}

NTSTATUS
IopDeviceObjectToDeviceInstance (
    IN PDEVICE_OBJECT DeviceObject,
    IN PHANDLE DeviceInstanceHandle,
    IN  ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine receives a DeviceObject pointer and returns a handle to the device
    instance path under registry System\ENUM key.

    Note, caller must owner the PpRegistryDeviceResource before calling the function,

Arguments:

    DeviceObject - supplies a pointer to a physical device object.

    DeviceInstanceHandle - Supplies a variable to receive the handle to the registry
             device instance key.

    DesiredAccess - specifies the access that is needed to this key.

Returns:

    NTSTATUS code to indicate success or failure.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    status = IopOpenRegistryKeyEx( &handle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;
    if (deviceNode && (deviceNode->InstancePath.Length != 0)) {
        status = IopOpenRegistryKeyEx( DeviceInstanceHandle,
                                       handle,
                                       &deviceNode->InstancePath,
                                       DesiredAccess
                                       );
    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    ZwClose(handle);

    return status;
}

NTSTATUS
IopCleanupDeviceRegistryValues (
    IN PUNICODE_STRING InstancePath
    )

/*++

Routine Description:

    This routine cleans up a device instance key when the device is no
    longer present/enumerated.  If the device is registered to a Service
    the Service's enum key will also been cleaned up.

    Note the caller must lock the RegistryDeviceResource

Arguments:

    InstancePath - supplies a pointer to the name of the device instance key.

Return Value:

    status

--*/

{
    DEVICE_REFERENCE    key;
    NTSTATUS            status;
#if DBG
    PDEVICE_OBJECT      deviceObject;
#endif

    PAGED_CODE();

    //
    // Delete the mapping between this instance path and corresponding DO.
    //
    key.DeviceObject         = NULL;
    key.DeviceInstance       = InstancePath;

    ExAcquireFastMutex(&PpDeviceReferenceTableLock);
    RtlDeleteElementGenericTable(&PpDeviceReferenceTable, (PVOID)&key);
    ExReleaseFastMutex(&PpDeviceReferenceTableLock);
#if DBG
    deviceObject = IopDeviceObjectFromDeviceInstance(InstancePath);
    ASSERT(!deviceObject);
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }
#endif

    //
    // Deregister the device from its controlling service's service enum key
    //

    status = PiDeviceRegistration( InstancePath, FALSE, NULL );

    return status;
}

NTSTATUS
IopGetDeviceResourcesFromRegistry (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ResourceType,
    IN ULONG Preference,
    OUT PVOID *Resource,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine determines the resources decoded by the device specified.
    If the device object is a madeup device, we will try to read the resources
    from registry.  Otherwise, we need to traverse the internal assigned resource
    list to compose the resource list.

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be cleaned up.

    ResourceType - 0 for CM_RESOURCE_LIST and 1 for IO_RESOURCE_REQUIREMENTS_LIS

    Flags - specify the preference.

    Resource - Specified a variable to receive the required resources.

    Length - Specified a variable to receive the length of the resource structure.

Return Value:

    status

--*/

{
    HANDLE handle, handlex;
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    UNICODE_STRING unicodeName;
    PWCHAR valueName = NULL;

    *Resource = NULL;
    *Length = 0;

    //
    // Open the LogConfig key of the device instance.
    //

    status = IopDeviceObjectToDeviceInstance(DeviceObject, &handlex, KEY_READ);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (ResourceType == QUERY_RESOURCE_LIST) {

        //
        // Caller is asking for CM_RESOURCE_LIST
        //

        if (Preference & REGISTRY_ALLOC_CONFIG) {

            //
            // Try alloc config first
            //

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
            status = IopOpenRegistryKeyEx( &handle,
                                           handlex,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {
                status = PipReadDeviceConfiguration (handle, REGISTRY_ALLOC_CONFIG, (PCM_RESOURCE_LIST *)Resource, Length);
                ZwClose(handle);
                if (NT_SUCCESS(status)) {
                    ZwClose(handlex);
                    return status;
                }
            }
        }

        handle = NULL;
        if (Preference & REGISTRY_FORCED_CONFIG) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopOpenRegistryKeyEx( &handle,
                                           handlex,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (NT_SUCCESS(status)) {
                status = PipReadDeviceConfiguration (handle, REGISTRY_FORCED_CONFIG, (PCM_RESOURCE_LIST *)Resource, Length);
                if (NT_SUCCESS(status)) {
                    ZwClose(handle);
                    ZwClose(handlex);
                    return status;
                }
            } else {
                ZwClose(handlex);
                return status;
            }
        }
        if (Preference & REGISTRY_BOOT_CONFIG) {

            //
            // Try alloc config first
            //

            if (handle == NULL) {
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                status = IopOpenRegistryKeyEx( &handle,
                                               handlex,
                                               &unicodeName,
                                               KEY_READ
                                               );
                if (!NT_SUCCESS(status)) {
                    ZwClose(handlex);
                    return status;
                }
            }
            status = PipReadDeviceConfiguration( handle,
                                                 REGISTRY_BOOT_CONFIG,
                                                 (PCM_RESOURCE_LIST *)Resource,
                                                 Length);
        }
        if (handle) {
            ZwClose(handle);
        }
    } else {

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopOpenRegistryKeyEx( &handle,
                                       handlex,
                                       &unicodeName,
                                       KEY_READ
                                       );
        if (NT_SUCCESS(status)) {

            if (Preference & REGISTRY_OVERRIDE_CONFIGVECTOR) {
                valueName = REGSTR_VALUE_OVERRIDE_CONFIG_VECTOR;
            } else if (Preference & REGISTRY_BASIC_CONFIGVECTOR) {
                valueName = REGSTR_VALUE_BASIC_CONFIG_VECTOR;
            }
            if (valueName) {

                //
                // Try to read device's configuration vector
                //

                status = IopGetRegistryValue (handle,
                                              valueName,
                                              &keyValueInformation);
                if (NT_SUCCESS(status)) {

                    //
                    // Try to read what caller wants.
                    //

                    if ((keyValueInformation->Type == REG_RESOURCE_REQUIREMENTS_LIST) &&
                        (keyValueInformation->DataLength != 0)) {

                        *Resource = ExAllocatePool(PagedPool,
                                                   keyValueInformation->DataLength);
                        if (*Resource) {
                            PIO_RESOURCE_REQUIREMENTS_LIST ioResource;

                            *Length = keyValueInformation->DataLength;
                            RtlCopyMemory(*Resource,
                                          KEY_VALUE_DATA(keyValueInformation),
                                          keyValueInformation->DataLength);

                            //
                            // Process the io resource requirements list to change undefined
                            // interface type to our default type.
                            //

                            ioResource = *Resource;
                            if (ioResource->InterfaceType == InterfaceTypeUndefined) {
                                ioResource->BusNumber = 0;
                                ioResource->InterfaceType = PnpDefaultInterfaceType;
                            }
                        } else {
                            status = STATUS_INVALID_PARAMETER_2;
                        }
                    }
                    ExFreePool(keyValueInformation);
                }
            }
            ZwClose(handle);
        }
    }
    ZwClose(handlex);
    return status;
}

NTSTATUS
PipReadDeviceConfiguration (
    IN HANDLE Handle,
    IN ULONG Flags,
    OUT PCM_RESOURCE_LIST *CmResource,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine read the specified ALLOC config or ForcedConfig or Boot config.

Arguments:

    Hanle - supplies a handle to the registry key to read resources.

Return Value:

    status

--*/

{
    NTSTATUS status;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PWCHAR valueName;

    *CmResource = NULL;
    *Length = 0;

    if (Flags == REGISTRY_ALLOC_CONFIG) {
        valueName = REGSTR_VALUE_ALLOC_CONFIG;
    } else if (Flags == REGISTRY_FORCED_CONFIG) {
        valueName = REGSTR_VALUE_FORCED_CONFIG;
    } else if (Flags == REGISTRY_BOOT_CONFIG) {
        valueName = REGSTR_VALUE_BOOT_CONFIG;
    } else {
        return STATUS_INVALID_PARAMETER_2;
    }

    //
    // Read the registry value of the desired value name
    //

    status = IopGetRegistryValue (Handle,
                                  valueName,
                                  &keyValueInformation);
    if (NT_SUCCESS(status)) {

        //
        // Try to read what caller wants.
        //

        if ((keyValueInformation->Type == REG_RESOURCE_LIST) &&
            (keyValueInformation->DataLength != 0)) {
            *CmResource = ExAllocatePool(PagedPool,
                                         keyValueInformation->DataLength);
            if (*CmResource) {
                if (*CmResource) {
                    *Length = keyValueInformation->DataLength;
                    RtlCopyMemory(*CmResource,
                                  KEY_VALUE_DATA(keyValueInformation),
                                  keyValueInformation->DataLength);
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            ExFreePool(keyValueInformation);
            if (*CmResource) {
                PCM_RESOURCE_LIST resourceList;
                PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
                ULONG j, k, size;

                //
                // Process the resource list read from Registry to change undefined
                // interface type to our default interface type.
                //

                resourceList = *CmResource;
                cmFullDesc = &resourceList->List[0];
                for (j = 0; j < resourceList->Count; j++) {
                    if (cmFullDesc->InterfaceType == InterfaceTypeUndefined) {
                        cmFullDesc->BusNumber = 0;
                        cmFullDesc->InterfaceType = PnpDefaultInterfaceType;
                    }
                    cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
                    for (k = 0; k < cmFullDesc->PartialResourceList.Count; k++) {
                        size = 0;
                        switch (cmPartDesc->Type) {
                        case CmResourceTypeDeviceSpecific:
                             size = cmPartDesc->u.DeviceSpecificData.DataSize;
                             break;
                        }
                        cmPartDesc++;
                        cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
                    }
                    cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
                }
            }
        } else if (keyValueInformation->Type != REG_RESOURCE_LIST) {
            status = STATUS_UNSUCCESSFUL;
        }
    }
    return status;
}

PIO_RESOURCE_REQUIREMENTS_LIST
IopCmResourcesToIoResources(
    IN ULONG SlotNumber,
    IN PCM_RESOURCE_LIST CmResourceList,
    IN ULONG Priority
    )

/*++

Routine Description:

    This routines converts the input CmResourceList to IO_RESOURCE_REQUIREMENTS_LIST.

Arguments:

    SlotNumber - supplies the SlotNumber the resources refer to.

    CmResourceList - the cm resource list to convert.

    Priority - specifies the priority of the logconfig

Return Value:

    returns a IO_RESOURCE_REQUIREMENTS_LISTST if succeeds.  Otherwise a NULL value is
    returned.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioResReqList;
    ULONG count = 0, size, i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
    PIO_RESOURCE_DESCRIPTOR ioDesc;

    //
    // First determine number of descriptors required.
    //

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        count += cmFullDesc->PartialResourceList.Count;
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 count--;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }

    if (count == 0) {
        return NULL;
    }

    //
    // Count the extra descriptors for InterfaceType and BusNumber information.
    //

    count += CmResourceList->Count - 1;

    //
    // Allocate heap space for IO RESOURCE REQUIREMENTS LIST
    //

    count++;           // add one for CmResourceTypeConfigData
    ioResReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePool(
                       PagedPool,
                       sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                           count * sizeof(IO_RESOURCE_DESCRIPTOR)
                       );
    if (!ioResReqList) {
        return NULL;
    }

    //
    // Parse the cm resource descriptor and build its corresponding IO resource descriptor
    //

    ioResReqList->InterfaceType = CmResourceList->List[0].InterfaceType;
    ioResReqList->BusNumber = CmResourceList->List[0].BusNumber;
    ioResReqList->SlotNumber = SlotNumber;
    ioResReqList->Reserved[0] = 0;
    ioResReqList->Reserved[1] = 0;
    ioResReqList->Reserved[2] = 0;
    ioResReqList->AlternativeLists = 1;
    ioResReqList->List[0].Version = 1;
    ioResReqList->List[0].Revision = 1;
    ioResReqList->List[0].Count = count;

    //
    // Generate a CmResourceTypeConfigData descriptor
    //

    ioDesc = &ioResReqList->List[0].Descriptors[0];
    ioDesc->Option = IO_RESOURCE_PREFERRED;
    ioDesc->Type = CmResourceTypeConfigData;
    ioDesc->ShareDisposition = CmResourceShareShared;
    ioDesc->Flags = 0;
    ioDesc->Spare1 = 0;
    ioDesc->Spare2 = 0;
    ioDesc->u.ConfigData.Priority = Priority;
    ioDesc++;

    cmFullDesc = &CmResourceList->List[0];
    for (i = 0; i < CmResourceList->Count; i++) {
        if (i != 0) {

            //
            // Set up descriptor to remember the InterfaceType and BusNumber.
            //

            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = CmResourceTypeReserved;
            ioDesc->ShareDisposition = CmResourceShareUndetermined;
            ioDesc->Flags = 0;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;
            if (cmFullDesc->InterfaceType == InterfaceTypeUndefined) {
                ioDesc->u.DevicePrivate.Data[0] = PnpDefaultInterfaceType;
            } else {
                ioDesc->u.DevicePrivate.Data[0] = cmFullDesc->InterfaceType;
            }
            ioDesc->u.DevicePrivate.Data[1] = cmFullDesc->BusNumber;
            ioDesc->u.DevicePrivate.Data[2] = 0;
            ioDesc++;
        }
        cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            ioDesc->Option = IO_RESOURCE_PREFERRED;
            ioDesc->Type = cmPartDesc->Type;
            ioDesc->ShareDisposition = cmPartDesc->ShareDisposition;
            ioDesc->Flags = cmPartDesc->Flags;
            ioDesc->Spare1 = 0;
            ioDesc->Spare2 = 0;

            size = 0;
            switch (cmPartDesc->Type) {
            case CmResourceTypePort:
                 ioDesc->u.Port.MinimumAddress = cmPartDesc->u.Port.Start;
                 ioDesc->u.Port.MaximumAddress.QuadPart = cmPartDesc->u.Port.Start.QuadPart +
                                                             cmPartDesc->u.Port.Length - 1;
                 ioDesc->u.Port.Alignment = 1;
                 ioDesc->u.Port.Length = cmPartDesc->u.Port.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeInterrupt:
#if defined(_X86_)
                ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                   cmPartDesc->u.Interrupt.Level;
#else
                 ioDesc->u.Interrupt.MinimumVector = ioDesc->u.Interrupt.MaximumVector =
                    cmPartDesc->u.Interrupt.Vector;
#endif
                 ioDesc++;
                 break;
            case CmResourceTypeMemory:
                 ioDesc->u.Memory.MinimumAddress = cmPartDesc->u.Memory.Start;
                 ioDesc->u.Memory.MaximumAddress.QuadPart = cmPartDesc->u.Memory.Start.QuadPart +
                                                               cmPartDesc->u.Memory.Length - 1;
                 ioDesc->u.Memory.Alignment = 1;
                 ioDesc->u.Memory.Length = cmPartDesc->u.Memory.Length;
                 ioDesc++;
                 break;
            case CmResourceTypeDma:
                 ioDesc->u.Dma.MinimumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc->u.Dma.MaximumChannel = cmPartDesc->u.Dma.Channel;
                 ioDesc++;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmPartDesc->u.DeviceSpecificData.DataSize;
                 break;
            case CmResourceTypeBusNumber:
                 ioDesc->u.BusNumber.MinBusNumber = cmPartDesc->u.BusNumber.Start;
                 ioDesc->u.BusNumber.MaxBusNumber = cmPartDesc->u.BusNumber.Start +
                                                    cmPartDesc->u.BusNumber.Length - 1;
                 ioDesc->u.BusNumber.Length = cmPartDesc->u.BusNumber.Length;
                 ioDesc++;
                 break;
            default:
                 ioDesc->u.DevicePrivate.Data[0] = cmPartDesc->u.DevicePrivate.Data[0];
                 ioDesc->u.DevicePrivate.Data[1] = cmPartDesc->u.DevicePrivate.Data[1];
                 ioDesc->u.DevicePrivate.Data[2] = cmPartDesc->u.DevicePrivate.Data[2];
                 ioDesc++;
                 break;
            }
            cmPartDesc++;
            cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
    }
    ioResReqList->ListSize = (ULONG)((ULONG_PTR)ioDesc - (ULONG_PTR)ioResReqList);
    return ioResReqList;
}

NTSTATUS
IopFilterResourceRequirementsList(
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList,
    IN PCM_RESOURCE_LIST CmList,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *FilteredList,
    OUT PBOOLEAN ExactMatch
    )

/*++

Routine Description:

    This routines adjusts the input IoList based on input BootConfig.


Arguments:

    IoList - supplies the pointer to an IoResourceRequirementsList

    CmList - supplies the pointer to a BootConfig.

    FilteredList - Supplies a variable to receive the filtered resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    PIO_RESOURCE_LIST ioResourceList, newIoResourceList, selectedResourceList = NULL;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptor, ioResourceDescriptorEnd;
    PIO_RESOURCE_DESCRIPTOR newIoResourceDescriptor, configDataDescriptor;
    LONG ioResourceDescriptorCount = 0;
    USHORT version;
    PCM_FULL_RESOURCE_DESCRIPTOR cmFullDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmDescriptor;
    ULONG cmDescriptorCount = 0;
    ULONG size, i, j, oldCount, phase;
    LONG k, alternativeLists;
    BOOLEAN exactMatch;

    PAGED_CODE();

    *FilteredList = NULL;
    *ExactMatch = FALSE;

    //
    // Make sure there is some resource requirements to be filtered.
    // If no, we will convert CmList/BootConfig to an IoResourceRequirementsList
    //

    if (IoList == NULL || IoList->AlternativeLists == 0) {
        if (CmList && CmList->Count != 0) {
            *FilteredList = IopCmResourcesToIoResources (0, CmList, LCPRI_BOOTCONFIG);
        }
        return STATUS_SUCCESS;
    }

    //
    // Make a copy of the Io Resource Requirements List
    //

    ioList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, IoList->ListSize);
    if (ioList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(ioList, IoList, IoList->ListSize);

    //
    // If there is no BootConfig, simply return the copy of the input Io list.
    //

    if (CmList == NULL || CmList->Count == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // First determine minimum number of descriptors required.
    //

    cmFullDesc = &CmList->List[0];
    for (i = 0; i < CmList->Count; i++) {
        cmDescriptorCount += cmFullDesc->PartialResourceList.Count;
        cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
        for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
            size = 0;
            switch (cmDescriptor->Type) {
            case CmResourceTypeConfigData:
            case CmResourceTypeDevicePrivate:
                 cmDescriptorCount--;
                 break;
            case CmResourceTypeDeviceSpecific:
                 size = cmDescriptor->u.DeviceSpecificData.DataSize;
                 cmDescriptorCount--;
                 break;
            default:

                 //
                 // Invalid cmresource list.  Ignore it and use io resources
                 //

                 if (cmDescriptor->Type == CmResourceTypeNull ||
                     cmDescriptor->Type >= CmResourceTypeMaximum) {
                     cmDescriptorCount--;
                 }
            }
            cmDescriptor++;
            cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
        }
        cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
    }

    if (cmDescriptorCount == 0) {
        *FilteredList = ioList;
        return STATUS_SUCCESS;
    }

    //
    // cmDescriptorCount is the number of BootConfig Descriptors needs.
    //
    // For each IO list Alternative ...
    //

    ioResourceList = ioList->List;
    k = ioList->AlternativeLists;
    while (--k >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            ioResourceDescriptor->Spare1 = 0;
            ioResourceDescriptor++;
        }
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    ioResourceList = ioList->List;
    k = alternativeLists = ioList->AlternativeLists;
    while (--k >= 0) {
        version = ioResourceList->Version;
        if (version == 0xffff) {  // Convert bogus version to valid number
            version = 1;
        }

        //
        // We use Version field to store number of BootConfig found.
        // Count field to store new number of descriptor in the alternative list.
        //

        ioResourceList->Version = 0;
        oldCount = ioResourceList->Count;

        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;

        if (ioResourceDescriptor == ioResourceDescriptorEnd) {

            //
            // An alternative list with zero descriptor count
            //

            ioResourceList->Version = 0xffff;  // Mark it as invalid
            ioList->AlternativeLists--;
            continue;
        }

        exactMatch = TRUE;

        //
        // For each Cm Resource descriptor ... except DevicePrivate and
        // DeviceSpecific...
        //

        cmFullDesc = &CmList->List[0];
        for (i = 0; i < CmList->Count; i++) {
            cmDescriptor = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
            for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {
                size = 0;
                switch (cmDescriptor->Type) {
                case CmResourceTypeDevicePrivate:
                     break;
                case CmResourceTypeDeviceSpecific:
                     size = cmDescriptor->u.DeviceSpecificData.DataSize;
                     break;
                default:
                    if (cmDescriptor->Type == CmResourceTypeNull ||
                        cmDescriptor->Type >= CmResourceTypeMaximum) {
                        break;
                    }

                    //
                    // Check CmDescriptor against current Io Alternative list
                    //

                    for (phase = 0; phase < 2; phase++) {
                        ioResourceDescriptor = ioResourceList->Descriptors;
                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                            if ((ioResourceDescriptor->Type == cmDescriptor->Type) &&
                                (ioResourceDescriptor->Spare1 == 0)) {
                                ULONGLONG min1, max1, min2, max2;
                                ULONG len1 = 1, len2 = 1, align1, align2;
                                UCHAR share1, share2;

                                share2 = ioResourceDescriptor->ShareDisposition;
                                share1 = cmDescriptor->ShareDisposition;
                                if ((share1 == CmResourceShareUndetermined) ||
                                    (share1 > CmResourceShareShared)) {
                                    share1 = share2;
                                }
                                if ((share2 == CmResourceShareUndetermined) ||
                                    (share2 > CmResourceShareShared)) {
                                    share2 = share1;
                                }
                                align1 = align2 = 1;

                                switch (cmDescriptor->Type) {
                                case CmResourceTypePort:
                                case CmResourceTypeMemory:
                                    min1 = cmDescriptor->u.Port.Start.QuadPart;
                                    max1 = cmDescriptor->u.Port.Start.QuadPart + cmDescriptor->u.Port.Length - 1;
                                    len1 = cmDescriptor->u.Port.Length;
                                    min2 = ioResourceDescriptor->u.Port.MinimumAddress.QuadPart;
                                    max2 = ioResourceDescriptor->u.Port.MaximumAddress.QuadPart;
                                    len2 = ioResourceDescriptor->u.Port.Length;
                                    align2 = ioResourceDescriptor->u.Port.Alignment;
                                    break;
                                case CmResourceTypeInterrupt:
                                    max1 = min1 = cmDescriptor->u.Interrupt.Vector;
                                    min2 = ioResourceDescriptor->u.Interrupt.MinimumVector;
                                    max2 = ioResourceDescriptor->u.Interrupt.MaximumVector;
                                    break;
                                case CmResourceTypeDma:
                                    min1 = max1 =cmDescriptor->u.Dma.Channel;
                                    min2 = ioResourceDescriptor->u.Dma.MinimumChannel;
                                    max2 = ioResourceDescriptor->u.Dma.MaximumChannel;
                                    break;
                                case CmResourceTypeBusNumber:
                                    min1 = cmDescriptor->u.BusNumber.Start;
                                    max1 = cmDescriptor->u.BusNumber.Start + cmDescriptor->u.BusNumber.Length - 1;
                                    len1 = cmDescriptor->u.BusNumber.Length;
                                    min2 = ioResourceDescriptor->u.BusNumber.MinBusNumber;
                                    max2 = ioResourceDescriptor->u.BusNumber.MaxBusNumber;
                                    len2 = ioResourceDescriptor->u.BusNumber.Length;
                                    break;
                                default:
                                    ASSERT(0);
                                    break;
                                }
                                if (phase == 0) {
                                    if (share1 == share2 && min2 == min1 && max2 >= max1 && len2 >= len1) {

                                        //
                                        // For phase 0 match, we want near exact match...
                                        //

                                        if (max2 != max1) {
                                            exactMatch = FALSE;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor->Flags = cmDescriptor->Flags;
                                        if (ioResourceDescriptor->Type == CmResourceTypePort ||
                                            ioResourceDescriptor->Type == CmResourceTypeMemory) {
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            ioResourceDescriptor->u.Port.Alignment = 1;
                                        } else if (ioResourceDescriptor->Type == CmResourceTypeBusNumber) {
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                        }
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceDescriptor++;
                                                ioResourceList->Count--;
                                            } else {
                                                break;
                                            }
                                        }
                                        phase = 1;   // skip phase 1
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                } else {
                                    exactMatch = FALSE;
                                    if (share1 == share2 && min2 <= min1 && max2 >= max1 && len2 >= len1 &&
                                        (min1 & (align2 - 1)) == 0) {

                                        //
                                        // Io range covers Cm range ... Change the Io range to what is specified
                                        // in BootConfig.
                                        //
                                        //

                                        switch (cmDescriptor->Type) {
                                        case CmResourceTypePort:
                                        case CmResourceTypeMemory:
                                            ioResourceDescriptor->u.Port.MinimumAddress.QuadPart = min1;
                                            ioResourceDescriptor->u.Port.MaximumAddress.QuadPart = min1 + len2 - 1;
                                            break;
                                        case CmResourceTypeInterrupt:
                                        case CmResourceTypeDma:
                                            ioResourceDescriptor->u.Interrupt.MinimumVector = (ULONG)min1;
                                            ioResourceDescriptor->u.Interrupt.MaximumVector = (ULONG)max1;
                                            break;
                                        case CmResourceTypeBusNumber:
                                            ioResourceDescriptor->u.BusNumber.MinBusNumber = (ULONG)min1;
                                            ioResourceDescriptor->u.BusNumber.MaxBusNumber = (ULONG)(min1 + len2 - 1);
                                            break;
                                        }
                                        ioResourceList->Version++;
                                        ioResourceDescriptor->Spare1 = 0x80;
                                        ioResourceDescriptor->Flags = cmDescriptor->Flags;
                                        if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                            PIO_RESOURCE_DESCRIPTOR ioDesc;

                                            ioDesc = ioResourceDescriptor;
                                            ioDesc--;
                                            while (ioDesc >= ioResourceList->Descriptors) {
                                                ioDesc->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                if (ioDesc->Option == IO_RESOURCE_ALTERNATIVE) {
                                                    ioDesc--;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                        ioResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
                                        ioResourceDescriptor++;
                                        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
                                            if (ioResourceDescriptor->Option & IO_RESOURCE_ALTERNATIVE) {
                                                ioResourceDescriptor->Type = CmResourceTypeNull;
                                                ioResourceList->Count--;
                                                ioResourceDescriptor++;
                                            } else {
                                                break;
                                            }
                                        }
                                        break;
                                    } else {
                                        ioResourceDescriptor++;
                                    }
                                }
                            } else {
                                ioResourceDescriptor++;
                            }
                        } // Don't add any instruction after this ...
                    } // phase
                } // switch

                //
                // Move to next Cm Descriptor
                //

                cmDescriptor++;
                cmDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmDescriptor + size);
            }

            //
            // Move to next Cm List
            //

            cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmDescriptor;
        }

        if (ioResourceList->Version != (USHORT)cmDescriptorCount) {

            //
            // If the current alternative list does not cover all the boot config
            // descriptors, make it as invalid.
            //

            ioResourceList->Version = 0xffff;
            ioList->AlternativeLists--;
        } else {
            if ((ioResourceList->Count == cmDescriptorCount) ||
                (ioResourceList->Count == (cmDescriptorCount + 1) &&
                 ioResourceList->Descriptors[0].Type == CmResourceTypeConfigData)) {
                if (selectedResourceList) {
                    ioResourceList->Version = 0xffff;
                    ioList->AlternativeLists--;
                } else {
                    selectedResourceList = ioResourceList;
                    ioResourceDescriptorCount += ioResourceList->Count;
                    ioResourceList->Version = version;
                    if (exactMatch) {
                        *ExactMatch = TRUE;
                    }
                }
            } else {
                ioResourceDescriptorCount += ioResourceList->Count;
                ioResourceList->Version = version;
            }
        }
        ioResourceList->Count = oldCount;

        //
        // Move to next Io alternative list.
        //

        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }

    //
    // If there is not any valid alternative, convert CmList to Io list.
    //

    if (ioList->AlternativeLists == 0) {
         *FilteredList = IopCmResourcesToIoResources (0, CmList, LCPRI_BOOTCONFIG);
        ExFreePool(ioList);
        return STATUS_SUCCESS;
    }

    //
    // we have finished filtering the resource requirements list.  Now allocate memory
    // and rebuild a new list.
    //

    size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
               sizeof(IO_RESOURCE_LIST) * (ioList->AlternativeLists - 1) +
               sizeof(IO_RESOURCE_DESCRIPTOR) * (ioResourceDescriptorCount);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, size);
    if (newList == NULL) {
        ExFreePool(ioList);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Walk through the io resource requirements list and pick up any valid descriptor.
    //

    newList->ListSize = size;
    newList->InterfaceType = CmList->List->InterfaceType;
    newList->BusNumber = CmList->List->BusNumber;
    newList->SlotNumber = ioList->SlotNumber;
    if (ioList->AlternativeLists > 1) {
        *ExactMatch = FALSE;
    }
    newList->AlternativeLists = ioList->AlternativeLists;
    ioResourceList = ioList->List;
    newIoResourceList = newList->List;
    while (--alternativeLists >= 0) {
        ioResourceDescriptor = ioResourceList->Descriptors;
        ioResourceDescriptorEnd = ioResourceDescriptor + ioResourceList->Count;
        if (ioResourceList->Version == 0xffff) {
            ioResourceList = (PIO_RESOURCE_LIST)ioResourceDescriptorEnd;
            continue;
        }
        newIoResourceList->Version = ioResourceList->Version;
        newIoResourceList->Revision = ioResourceList->Revision;

        newIoResourceDescriptor = newIoResourceList->Descriptors;
        if (ioResourceDescriptor->Type != CmResourceTypeConfigData) {
            newIoResourceDescriptor->Option = IO_RESOURCE_PREFERRED;
            newIoResourceDescriptor->Type = CmResourceTypeConfigData;
            newIoResourceDescriptor->ShareDisposition = CmResourceShareShared;
            newIoResourceDescriptor->Flags = 0;
            newIoResourceDescriptor->Spare1 = 0;
            newIoResourceDescriptor->Spare2 = 0;
            newIoResourceDescriptor->u.ConfigData.Priority = LCPRI_BOOTCONFIG;
            configDataDescriptor = newIoResourceDescriptor;
            newIoResourceDescriptor++;
        } else {
            newList->ListSize -= sizeof(IO_RESOURCE_DESCRIPTOR);
            configDataDescriptor = newIoResourceDescriptor;
        }

        while (ioResourceDescriptor < ioResourceDescriptorEnd) {
            if (ioResourceDescriptor->Type != CmResourceTypeNull) {
                *newIoResourceDescriptor = *ioResourceDescriptor;
                newIoResourceDescriptor++;
            }
            ioResourceDescriptor++;
        }
        newIoResourceList->Count = (ULONG)(newIoResourceDescriptor - newIoResourceList->Descriptors);

        //if (newIoResourceList->Count == (cmDescriptorCount + 1)) {
        configDataDescriptor->u.ConfigData.Priority =  LCPRI_BOOTCONFIG;
        //}

        //
        // Move to next Io alternative list.
        //

        newIoResourceList = (PIO_RESOURCE_LIST) newIoResourceDescriptor;
        ioResourceList = (PIO_RESOURCE_LIST) ioResourceDescriptorEnd;
    }
    ASSERT((PUCHAR)newIoResourceList == ((PUCHAR)newList + newList->ListSize));

    *FilteredList = newList;
    ExFreePool(ioList);
    return STATUS_SUCCESS;
}

NTSTATUS
IopMergeFilteredResourceRequirementsList (
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList1,
    IN PIO_RESOURCE_REQUIREMENTS_LIST IoList2,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first IoResourceRequirementsList

    IoList2 - supplies the pointer to the second IoResourceRequirementsList

    MergedList - Supplies a variable to receive the merged resource
             requirements list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_RESOURCE_REQUIREMENTS_LIST ioList, newList;
    ULONG size;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((IoList1 == NULL || IoList1->AlternativeLists == 0) &&
        (IoList2 == NULL || IoList2->AlternativeLists == 0)) {
        return status;
    }
    ioList = NULL;
    if (IoList1 == NULL || IoList1->AlternativeLists == 0) {
        ioList = IoList2;
    } else if (IoList2 == NULL || IoList2->AlternativeLists == 0) {
        ioList = IoList1;
    }
    if (ioList) {
        newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool, ioList->ListSize);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(newList, ioList, ioList->ListSize);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size = IoList1->ListSize + IoList2->ListSize - FIELD_OFFSET(IO_RESOURCE_REQUIREMENTS_LIST, List);
    newList = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlCopyMemory(p, IoList1, IoList1->ListSize);
    p += IoList1->ListSize;
    RtlCopyMemory(p,
                  &IoList2->List[0],
                  size - IoList1->ListSize
                  );
    newList->ListSize = size;
    newList->AlternativeLists += IoList2->AlternativeLists;
    *MergedList = newList;
    return status;

}

NTSTATUS
IopMergeCmResourceLists (
    IN PCM_RESOURCE_LIST List1,
    IN PCM_RESOURCE_LIST List2,
    IN OUT PCM_RESOURCE_LIST *MergedList
    )

/*++

Routine Description:

    This routines merges two IoLists into one.


Arguments:

    IoList1 - supplies the pointer to the first CmResourceList

    IoList2 - supplies the pointer to the second CmResourceList

    MergedList - Supplies a variable to receive the merged resource
             list.

Return Value:

    A NTSTATUS code to indicate the result of the function.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PCM_RESOURCE_LIST cmList, newList;
    ULONG size, size1, size2;
    PUCHAR p;

    PAGED_CODE();

    *MergedList = NULL;

    //
    // First handle the easy cases that both IO Lists are empty or any one of
    // them is empty.
    //

    if ((List1 == NULL || List1->Count == 0) &&
        (List2 == NULL || List2->Count == 0)) {
        return status;
    }

    cmList = NULL;
    if (List1 == NULL || List1->Count == 0) {
        cmList = List2;
    } else if (List2 == NULL || List2->Count == 0) {
        cmList = List1;
    }
    if (cmList) {
        size =  IopDetermineResourceListSize(cmList);
        newList = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool, size);
        if (newList == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(newList, cmList, size);
        *MergedList = newList;
        return status;
    }

    //
    // Do real work...
    //

    size1 =  IopDetermineResourceListSize(List1);
    size2 =  IopDetermineResourceListSize(List2);
    size = size1 + size2;
    newList = (PCM_RESOURCE_LIST) ExAllocatePool(
                          PagedPool,
                          size
                          );
    if (newList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    p = (PUCHAR)newList;
    RtlCopyMemory(p, List1, size1);
    p += size1;
    RtlCopyMemory(p,
                  &List2->List[0],
                  size2 - FIELD_OFFSET(CM_RESOURCE_LIST, List)
                  );
    newList->Count = List1->Count + List2->Count;
    *MergedList = newList;
    return status;

}

BOOLEAN
IopIsLegacyDriver (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if the driver object specifies a legacy driver.

Arguments:

    DriverObject - supplies a pointer to the driver object to be checked.

Return Value:

    BOOLEAN

--*/

{

    PAGED_CODE();

    //
    // If AddDevice entry is not empty it is a wdm driver
    //

    if (DriverObject->DriverExtension->AddDevice) {
        return FALSE;
    }

    //
    // Else if LEGACY flag is set in the driver object, it's a legacy driver.
    //

    if (DriverObject->Flags & DRVO_LEGACY_DRIVER) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IopDeleteLegacyKey(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine checks if the Legacy= value of the driver's legacy_xxx key
    is one.  If yes, it deletes the Legacy key.

Parameters:

    DriverObject - supplies a pointer to the driver object.

Return Value:

    None.  If anything fails in this routine, the legacy key stays.

--*/

{
    WCHAR buffer[MAX_DEVICE_ID_LEN];
    NTSTATUS status;
    UNICODE_STRING deviceName, instanceName, unicodeName, *serviceName;
    ULONG length;
    HANDLE handle, handle1, handlex, enumHandle;
    ULONG legacy;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    BOOLEAN deletedPDO;

    serviceName = &DriverObject->DriverExtension->ServiceKeyName;

    PiLockPnpRegistry(FALSE);

    status = IopOpenRegistryKeyEx( &enumHandle,
                                   NULL,
                                   &CmRegistryMachineSystemCurrentControlSetEnumName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    status = PipGenerateMadeupNodeName( serviceName,
                                        &deviceName
                                        );
    if (!NT_SUCCESS(status)) {
        goto exit;
    }

    length = _snwprintf(buffer,
                        sizeof(buffer) / sizeof(WCHAR),
                        L"%s\\%s",
                        REGSTR_KEY_ROOTENUM,
                        deviceName.Buffer);

    RtlFreeUnicodeString(&deviceName);

    deviceName.MaximumLength = sizeof(buffer);
    ASSERT(length <= sizeof(buffer) - 10);
    deviceName.Length = (USHORT)(length * sizeof(WCHAR));
    deviceName.Buffer = buffer;

    RtlUpcaseUnicodeString(&deviceName, &deviceName, FALSE);

    status = IopOpenRegistryKeyEx( &handle1,
                                   enumHandle,
                                   &deviceName,
                                   KEY_ALL_ACCESS
                                   );

    if (NT_SUCCESS(status)) {

        deviceName.Buffer[deviceName.Length / sizeof(WCHAR)] =
                   OBJ_NAME_PATH_SEPARATOR;
        deviceName.Length += sizeof(WCHAR);
        PiUlongToInstanceKeyUnicodeString(
                                &instanceName,
                                buffer + deviceName.Length / sizeof(WCHAR),
                                sizeof(buffer) - deviceName.Length,
                                0
                                );
        deviceName.Length += instanceName.Length;

        //
        // deviceName is now the full InstancePath (ROOT\LEGACY_service\0000)
        // and instancePath points to the instance ID (0000)
        //
        status = IopOpenRegistryKeyEx( &handle,
                                       handle1,
                                       &instanceName,
                                       KEY_ALL_ACCESS
                                       );
        if (NT_SUCCESS(status)) {
            legacy = 1;
            status = IopGetRegistryValue (handle,
                                          REGSTR_VALUE_LEGACY,
                                          &keyValueInformation);
            if (NT_SUCCESS(status)) {
                if ((keyValueInformation->Type == REG_DWORD) &&
                    (keyValueInformation->DataLength >= sizeof(ULONG))) {
                    legacy = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
                }
                ExFreePool(keyValueInformation);
            }
            if (legacy != 0) {

                //
                // We also want to delete the madeup device node
                //
                deletedPDO = FALSE;
                deviceObject = IopDeviceObjectFromDeviceInstance(&deviceName);
                if (deviceObject) {

                    PDEVICE_NODE devNodex, devNodey;

                    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
                    if (deviceNode != NULL && (deviceNode->Flags & DNF_MADEUP)) {

                        //
                        // Now mark this one deleted.
                        //
                        if (!PipDoesDevNodeHaveProblem(deviceNode)) {

                            PipSetDevNodeState(deviceNode, DeviceNodeRemoved, NULL);
                            PipSetDevNodeProblem(deviceNode, CM_PROB_DEVICE_NOT_THERE);
                        }

                        //
                        // This is actually doing nothing because DeviceNode->ResourceList is NULL.
                        //

                        IopReleaseDeviceResources(deviceNode, FALSE);
                        devNodex = deviceNode;
                        while (devNodex) {
                            devNodey = devNodex;
                            devNodex = (PDEVICE_NODE)devNodey->OverUsed2.NextResourceDeviceNode;
                            devNodey->OverUsed2.NextResourceDeviceNode = NULL;
                            devNodey->OverUsed1.LegacyDeviceNode = NULL;
                        }

                        deviceNode->Flags &= ~DNF_MADEUP;  // remove its boot config if any
                        IoDeleteDevice(deviceObject);
                        deletedPDO = TRUE;
                    }
                    ObDereferenceObject(deviceObject);  // added via IopDeviceObjectFromDeviceInstance
                }

                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
                status = IopOpenRegistryKeyEx( &handlex,
                                               handle,
                                               &unicodeName,
                                               KEY_ALL_ACCESS
                                               );
                if (NT_SUCCESS(status)) {
                    ZwDeleteKey(handlex);
                }
                PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
                status = IopOpenRegistryKeyEx( &handlex,
                                               handle,
                                               &unicodeName,
                                               KEY_ALL_ACCESS
                                               );
                if (NT_SUCCESS(status)) {
                    ZwDeleteKey(handlex);
                }

                ZwClose(enumHandle);

                //
                // We need to call IopCleanupDeviceRegistryValue even we are going to
                // delete it.  Because, it also cleans up related value names in other
                // keys.
                //
                if (deletedPDO) {

                    IopCleanupDeviceRegistryValues(&deviceName);
                }
                ZwDeleteKey(handle);
                ZwDeleteKey(handle1);
            } else {
                ZwClose(handle);
                ZwClose(handle1);
                ZwClose(enumHandle);
            }
        } else {
            ZwClose(handle1);
            ZwClose(enumHandle);
        }
    } else {
        ZwClose(enumHandle);
    }
exit:
    PiUnlockPnpRegistry();
    return;
}

NTSTATUS
IopQueryAndSaveDeviceNodeCapabilities (
    IN PDEVICE_NODE DeviceNode
    )

/*++

Routine Description:

    Called after start to refresh Capability flags

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be updated.

Return Value:

    status

--*/

{
    NTSTATUS status;
    DEVICE_CAPABILITIES capabilities;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);

    //
    // Open the device instance key
    //

    status = PipQueryDeviceCapabilities(DeviceNode, &capabilities);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    return IopSaveDeviceCapabilities(DeviceNode,&capabilities);
}

NTSTATUS
IopSaveDeviceCapabilities (
    IN PDEVICE_NODE DeviceNode,
    IN PDEVICE_CAPABILITIES Capabilities
    )

/*++

Routine Description:

    This routine updates device capabilities, must be called after a valid device instance key has been created
    Called directly from IopProcessNewDeviceNode, and indirecly via IopQueryAndSaveDeviceNodeCapabilities
    after device is started.

Arguments:

    DeviceObject - supplies a pointer to a device object whose registry
        values are to be updated.

Return Value:

    status

--*/

{
    NTSTATUS status;
    UNICODE_STRING unicodeName;
    ULONG value;
    HANDLE handle;

    PAGED_CODE();

    ASSERT(DeviceNode != NULL);
    ASSERT(Capabilities != NULL);

    //
    // Open the device instance key
    //
    status = IopDeviceObjectToDeviceInstance(DeviceNode->PhysicalDeviceObject, &handle, KEY_ALL_ACCESS);
    if (!NT_SUCCESS(status)) {

        return status;
    }

    if (DeviceNode->Flags & DNF_HAS_BOOT_CONFIG) {
        Capabilities->SurpriseRemovalOK = 0;
    }
    //
    // Assert the bit fields are completely contained in a ULONG. This is a
    // public structure, so it shouldn't ever change, but paranoia is a good
    // thing...
    //
    ASSERT((FIELD_OFFSET(DEVICE_CAPABILITIES, Address) -
            FIELD_OFFSET(DEVICE_CAPABILITIES, Version) -
            FIELD_SIZE  (DEVICE_CAPABILITIES, Version)) == sizeof(ULONG));

    DeviceNode->CapabilityFlags =
        *((PULONG) (((PUCHAR) Capabilities) +
        FIELD_OFFSET(DEVICE_CAPABILITIES, Version) +
        FIELD_SIZE(DEVICE_CAPABILITIES, Version)));

    value =    (Capabilities->LockSupported)          |
               (Capabilities->EjectSupported    << 1) |
               (Capabilities->WarmEjectSupported<< 1) |
               (Capabilities->Removable         << 2) |
               (Capabilities->DockDevice        << 3) |
               (Capabilities->UniqueID          << 4) |
               (Capabilities->SilentInstall     << 5) |
               (Capabilities->RawDeviceOK       << 6) |
               (Capabilities->SurpriseRemovalOK << 7) |
               (Capabilities->HardwareDisabled  << 8) |
               (Capabilities->NonDynamic        << 9);

    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_CAPABILITIES);
    status = ZwSetValueKey(
                  handle,
                  &unicodeName,
                  TITLE_INDEX_VALUE,
                  REG_DWORD,
                  &value,
                  sizeof(value)
                  );

    PiWstrToUnicodeString(&unicodeName, REGSTR_VALUE_UI_NUMBER);
    value = Capabilities->UINumber;
    if(value != (ULONG)-1) {

        ZwSetValueKey(handle,
                      &unicodeName,
                      TITLE_INDEX_VALUE,
                      REG_DWORD,
                      &value,
                      sizeof(value)
                      );
    } else {

        ZwDeleteValueKey(handle, &unicodeName);
    }

    ZwClose(handle);

    return STATUS_SUCCESS;
}

NTSTATUS
IopRestartDeviceNode(
    IN PDEVICE_NODE DeviceNode
    )
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    ASSERT(DeviceNode->State == DeviceNodeRemoved ||
           DeviceNode->State == DeviceNodeInitialized );

    ASSERT(!PipDoesDevNodeHaveProblem(DeviceNode));

    ASSERT(DeviceNode->Flags & DNF_ENUMERATED);

    if (!(DeviceNode->Flags & DNF_ENUMERATED)) {

        PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);
        return STATUS_UNSUCCESSFUL;
    }

    DeviceNode->UserFlags &= ~DNUF_NEED_RESTART;
    DeviceNode->Flags &= ~(DNF_DRIVER_BLOCKED | DNF_HARDWARE_VERIFICATION);

#if DBG_SCOPE
    DeviceNode->FailureStatus = 0;
    if (DeviceNode->PreviousResourceList) {
        ExFreePool(DeviceNode->PreviousResourceList);
        DeviceNode->PreviousResourceList = NULL;
    }
    if (DeviceNode->PreviousResourceRequirements) {
        ExFreePool(DeviceNode->PreviousResourceRequirements);
        DeviceNode->PreviousResourceRequirements = NULL;
    }
#endif

    //
    //     Prepare to set the device state back to DeviceNodeUninitialized. To
    // do this we free any existing devnode strings so we can recreate them
    // during enumeration.
    //
    // ADRIAO N.B. 8/19/2000 -
    //     We don't restore the state to DeviceNodeInitialized to maintain Win2K
    // behavior. We have no idea if anyone actually depends on this. In theory
    // this would let a bus driver get away with changing a child's IDs after a
    // remove.
    //

    if (DeviceNode->State != DeviceNodeUninitialized) {

        DeviceNode->Flags &= ~(DNF_NO_RESOURCE_REQUIRED |
                               DNF_RESOURCE_REQUIREMENTS_CHANGED);

        if (DeviceNode->ServiceName.Length != 0) {
            ExFreePool(DeviceNode->ServiceName.Buffer);
            PiWstrToUnicodeString(&DeviceNode->ServiceName, NULL);
        }

        if (DeviceNode->ResourceRequirements != NULL) {
            ExFreePool(DeviceNode->ResourceRequirements);
            DeviceNode->ResourceRequirements = NULL;
            DeviceNode->Flags &= ~DNF_RESOURCE_REQUIREMENTS_NEED_FILTERED;
        }
    }

    ASSERT(DeviceNode->ServiceName.Length == 0 &&
           DeviceNode->ServiceName.MaximumLength == 0 &&
           DeviceNode->ServiceName.Buffer == NULL);

    ASSERT(!(DeviceNode->Flags &
           ~(DNF_MADEUP | DNF_ENUMERATED | DNF_HAS_BOOT_CONFIG | DNF_IDS_QUERIED |
             DNF_BOOT_CONFIG_RESERVED | DNF_NO_RESOURCE_REQUIRED)));

    PipSetDevNodeState(DeviceNode, DeviceNodeUninitialized, NULL);

    PpDevNodeUnlockTree(PPL_TREEOP_BLOCK_READS_FROM_ALLOW);

    return STATUS_SUCCESS;
}

BOOLEAN
IopDeleteKeyRecursiveCallback(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PVOID Context
    )
/*++

Routine Description:

    This is a callback routine to PipApplyFunctionToSubKeys, that gets called
    through IopDeleteKeyRecursive.  This routine prepares a given key for
    deletion by deleting all of its subkeys.  This is done, using
    PipApplyFunctionToSubKeys, with instructions to delete all enumerated
    subkeys, and calling this routine as a callback routine, if necessary, until
    no subkeys remain.  KeyHandle can then be successfully deleted by the
    caller.

Arguments:

    KeyHandle - Handle to a subkey that has been enumerated by
        PipApplyFunctionToSubKeys.

    KeyName - Name of the subkey whose handle is specified by KeyHandle.

    Context - Supplies a pointer to user-defined data that will be passed
        in to the callback routine at each subkey invocation.

Return Value:

    BOOLEAN that returns whether or not the given key can be safely deleted.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(KeyName);

    //
    // delete any subkeys, recursively if necessary
    //
    status = PipApplyFunctionToSubKeys(
        KeyHandle,
        NULL,
        KEY_ALL_ACCESS,
        FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS |
        FUNCTIONSUBKEY_FLAG_DELETE_SUBKEYS,
        IopDeleteKeyRecursiveCallback,
        Context);

    *((NTSTATUS *)Context) = status;
    return (BOOLEAN)NT_SUCCESS(status);
}

NTSTATUS
IopDeleteKeyRecursive(
    IN HANDLE ParentKey OPTIONAL,
    IN PWCHAR KeyName
    )
/*++

Routine Description:

    Recursively deletes all subkeys of KeyName, then deletes KeyName.

Arguments:

    ParentKey - Handle to the parent key of KeyName.  If NULL then KeyName is
        expected to start with \Registry.

    KeyName - Name of subkey to delete, as a NULL terminated UNICODE string.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    NTSTATUS       status = STATUS_SUCCESS;
    BOOLEAN        result;
    HANDLE         hKey;
    UNICODE_STRING unicodeKeyName;

    PAGED_CODE();

    //
    // Attempt to open the key name we were given
    //
    RtlInitUnicodeString(&unicodeKeyName, KeyName);
    status = IopOpenRegistryKeyEx( &hKey,
                                   ParentKey,
                                   &unicodeKeyName,
                                   KEY_ALL_ACCESS
                                   );
    if (NT_SUCCESS(status)) {
        //
        // Recusively delete all subkeys
        //
        result = IopDeleteKeyRecursiveCallback(hKey,
                                               &unicodeKeyName,
                                               (PVOID)&status);
        if (result) {
            //
            // It is safe to delete this key
            //
            status = ZwDeleteKey(hKey);
        }
        ZwClose(hKey);
    }

    return status;
}

BOOLEAN
PiRegSzToString(
    IN  PWCHAR RegSzData,
    IN  ULONG  RegSzLength,
    OUT PULONG StringLength  OPTIONAL,
    OUT PWSTR  *CopiedString OPTIONAL
    )

/*++

Routine Description:

    This routine takes as input a REG_SZ data buffer (as returned in the DataOffset area
    of the buffer in a KEY_VALUE_FULL_INFORMATION structure), as well as the length
    of the buffer, in bytes (as specified by the DataLength field in the above mentioned
    struct).  It optionally returns the length of the contained string (in bytes), not
    including the terminating NULL, as well as an optional copy of the string itself
    (properly NULL-terminated).

    It is the responsibility of the caller to free the (PagedPool) buffer allocated
    for the string copy.

Arguments:

    RegSzData - Supplies a pointer to the REG_SZ data buffer.

    RegSzLength - Supplies the length of the RegSzData buffer, in bytes.

    StringLength - Optionally supplies a pointer to a variable that will receive
                   the length, in bytes, of the string (excluding terminating NULL).

    CopiedString - Optionally supplies a pointer to a wide character pointer that
                   will recieve a (properly NULL-terminated) copy of the specified
                   string.  If this paramater is NULL, no copy will be made.

Return Value:

    If success, returns TRUE

    If failure (not able to allocate memory for string copy), returns FALSE

--*/

{
    PWCHAR curPos, endOfRegSzData;
    ULONG actualStringLength;

    //
    // Since we're converting a byte count to a wide-character count (and the
    // compiler is converting it back when adding it to a PWCHAR), we are
    // ensuring that endOfRegSzData is not on an odd-byte boundary, even if
    // the RegSzLength passed in was odd.  This takes care of the case where
    // the REG_SZ buffer retrieved from the registry is bogus (e.g., you have
    // a 5-byte buffer, the 1st unicode character of which is a UNICODE_NULL).
    //
    endOfRegSzData = (curPos = RegSzData) + CB_TO_CWC(RegSzLength);

    while ((curPos < endOfRegSzData) && *curPos) {
        curPos++;
    }

    actualStringLength = (ULONG)((PUCHAR)curPos - (PUCHAR)RegSzData);

    if (ARGUMENT_PRESENT(StringLength)) {
        *StringLength = (ULONG)((PUCHAR)curPos - (PUCHAR)RegSzData);
    }

    if (ARGUMENT_PRESENT(CopiedString)) {
        //
        // Allocate memory for the string (+ terminating NULL)
        //
        *CopiedString = (PWSTR)ExAllocatePool(PagedPool, actualStringLength + sizeof(UNICODE_NULL));
        if (*CopiedString == NULL) {
            return FALSE;
        }

        //
        // Copy the string and NULL-terminate it.
        //
        if (actualStringLength) {
            RtlCopyMemory(*CopiedString, RegSzData, actualStringLength);
        }

        *(PWCHAR)((PUCHAR)(*CopiedString) + actualStringLength) = UNICODE_NULL;
    }

    return TRUE;
}

ULONG
IopDebugPrint (
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    )
{
    va_list ap;

    va_start(ap, Format);

    vDbgPrintExWithPrefix("", DPFLTR_NTOSPNP_ID, Level, Format, ap);

    va_end(ap);

    return Level;
}


PCHAR
PpConvertMultiSzWstrToStr(
    IN PWCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PWCHAR  s, sourceEnd;
    PCHAR   dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != UNICODE_NULL; s += wcslen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif

    dest = ExAllocatePool(PagedPool, Length * sizeof(CHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest;
             s < sourceEnd && *s != UNICODE_NULL;
             s += wcslen(s) + 1) {

            RtlInitUnicodeString(&unicodeString, s);
            status = RtlUnicodeStringToAnsiString(&ansiString, &unicodeString, TRUE);
            if (!NT_SUCCESS(status)) {

                ExFreePool(dest);
                return NULL;
            }
            RtlCopyMemory(d, ansiString.Buffer, ansiString.Length + 1);
            d += ansiString.Length + 1;
            RtlFreeAnsiString(&ansiString);
        }
        if (s < sourceEnd) {

            *d = '\0';
        }
    }

    return dest;
}


PWCHAR
PpConvertMultiSzStrToWstr(
    IN PCHAR Source,
    IN ULONG Length
    )
{
    NTSTATUS status;
    PCHAR s, sourceEnd;
    PWCHAR dest, d;
    ANSI_STRING ansiString;
    UNICODE_STRING unicodeString;

    PAGED_CODE();

    if (Length <= 2) {

        return NULL;
    }

#if DBG
    for (s = Source; *s != '\0'; s += strlen(s) + 1) {
    }
    ASSERT(Length == (ULONG)(s - Source) + 1);
#endif

    dest = ExAllocatePool(PagedPool, Length * sizeof(WCHAR));
    if (dest) {

        s = Source;
        for (sourceEnd = s + Length, d = dest;
             s < sourceEnd && *s != '\0';
             s += strlen(s) + 1) {

            RtlInitAnsiString(&ansiString, s);
            status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);
            if (!NT_SUCCESS(status)) {

                ExFreePool(dest);
                return NULL;
            }
            RtlCopyMemory(d, unicodeString.Buffer, unicodeString.Length + sizeof(UNICODE_NULL));
            d += (unicodeString.Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR);
            RtlFreeUnicodeString(&unicodeString);
        }
        if (s < sourceEnd) {

            *d = UNICODE_NULL;
        }
    }

    return dest;
}


VOID
PpSystemHiveLimitCallback(
    PSYSTEM_HIVE_LIMITS HiveLimits,
    ULONG Level
    )
{
    PAGED_CODE();

    if (Level >= HiveLimits->High) {

        PpSystemHiveTooLarge = TRUE;

    } else {

        ASSERT(Level <= HiveLimits->Low);
        PpSystemHiveTooLarge = FALSE;
        PpResetProblemDevices(IopRootDeviceNode, CM_PROB_REGISTRY_TOO_LARGE);
        PipRequestDeviceAction(
            IopRootDeviceNode->PhysicalDeviceObject,
            RestartEnumeration,
            FALSE,
            0,
            NULL,
            NULL
            );

    }
}

NTSTATUS
PpBusTypeGuidInitialize(
    VOID
    )

/*++

Routine Description:

    This routine opens the specified subkey.

Arguments:

    None
    
Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    PpBusTypeGuidCountMax = 16;
    PpBusTypeGuidArray = ExAllocatePool(PagedPool, sizeof(GUID) * PpBusTypeGuidCountMax);
    if (PpBusTypeGuidArray == NULL) {

        PpBusTypeGuidCountMax = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    PpBusTypeGuidCount = 0;

    ExInitializeFastMutex(&PpBusTypeGuidLock);

    return STATUS_SUCCESS;
}

USHORT
PpBusTypeGuidGetIndex(
    IN LPGUID BusTypeGuid
    )

/*++

Routine Description:

    This routine looks up the BusTypeGuid and returns its index into the table.

Arguments:
    
    BusTypeGuid - GUID to lookup.
    
Return Value:

    Index into the table iff successful, else 0xFFFF.

--*/

{
    LPGUID p;
    ULONG i;

    PAGED_CODE();

    ExAcquireFastMutex(&PpBusTypeGuidLock);
    //
    // First look it up.
    //
    for (i = 0; i < PpBusTypeGuidCount; i++) {

        if (IopCompareGuid(BusTypeGuid, &PpBusTypeGuidArray[i])) {

            break;
        }
    }
    //
    // If the GUID is not in the table, add it.
    //
    if (i == PpBusTypeGuidCount) {
        //
        // Grow the table if needed.
        // 
        if (i == PpBusTypeGuidCountMax) {
            //  
            // We grow the table one entry at a time. This should not be a 
            // problem since this should not happen often.
            //
            p  = ExAllocatePool(PagedPool, (i + 1) * sizeof(GUID));
            if (p) {
                //
                // Copy the old table.
                //
                RtlCopyMemory(p, PpBusTypeGuidArray, PpBusTypeGuidCount * sizeof(GUID));
                //
                // Update global data.
                //
                PpBusTypeGuidCountMax++;
                if (PpBusTypeGuidArray) {

                    ExFreePool(PpBusTypeGuidArray);
                }
                PpBusTypeGuidArray = p;

            } else {
                //
                // Return invalid index on failure.
                //
                i = (ULONG)-1;
            }
        }
        //
        // Copy the new entry on success.
        //
        if (i != (ULONG)-1) {
            //
            // Copy the new entry.
            //
            RtlCopyMemory(&PpBusTypeGuidArray[PpBusTypeGuidCount], BusTypeGuid, sizeof(GUID));
            //
            // Update global data.
            //
            PpBusTypeGuidCount++;
        }
    }

    ExReleaseFastMutex(&PpBusTypeGuidLock);

    return (USHORT)i;
}

NTSTATUS
PpBusTypeGuidGet(
    IN USHORT Index,
    IN OUT LPGUID BusTypeGuid
    )

/*++

Routine Description:

    This routine return the BusTypeGuid in the table at the specified index.

Arguments:
    
    Index - BusTypeGuid index.
    
    BusTypeGuid - Recieves the GUID.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    ExAcquireFastMutex(&PpBusTypeGuidLock);

    if (Index < PpBusTypeGuidCount) {

        RtlCopyMemory(BusTypeGuid, &PpBusTypeGuidArray[Index], sizeof(GUID));
        status = STATUS_SUCCESS;
    } else {

        status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    ExReleaseFastMutex(&PpBusTypeGuidLock);

    return status;
}

ULONG
PiFixupID(
    IN PWCHAR ID,
    IN ULONG MaxIDLength,
    IN BOOLEAN Multi,
    IN ULONG AllowedSeparators,
    IN PUNICODE_STRING LogString OPTIONAL
    )

/*++

Routine Description:

    This routine parses the device instance string and replaces any invalid
    characters (not allowed in a "device instance") with an underscore
    character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    ID - ID to be fixed up.
    
    MaxIDLength - Maximum allowed size of ID.
    
    Multi - Specifies if the ID is MULTI_SZ or not.
    
    AllowedSeparators - Number of separators allowed in the ID.

Return Value:

    ID length in number of characters.

--*/

{
    PWCHAR p, pMax, lastNull;
    ULONG separators;
    UNICODE_STRING reason;

    PAGED_CODE();

    //
    // BUGBUG - do we need to uppercase these!?
    //
    separators = 0;
    lastNull = NULL;
    for(p = ID, pMax = p + MaxIDLength; p < pMax; p++) {

        if(*p == UNICODE_NULL) {

            if(Multi == FALSE || (lastNull && p == lastNull + 1)) {

                break;
            }
            pMax += MaxIDLength;
            lastNull = p;
            continue;
        }
        if (*p == L' ') {

            *p = L'_';
        } else if ((*p < L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiFixupID: ID at %p has invalid character %02X\n",
                         ID,
                         *p));

            if(LogString) {

                PiWstrToUnicodeString(&reason, L"invalid character");
                PpLogEvent(LogString, &reason, STATUS_PNP_INVALID_ID, p, sizeof(WCHAR));
            }

            return 0;
        } else if ((*p == OBJ_NAME_PATH_SEPARATOR && ++separators > AllowedSeparators)) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PiFixupID: ID at %p has too many (%d) separators\n",
                         ID,
                         separators));
            if(LogString) {

                PiWstrToUnicodeString(&reason, L"too many separators");
                PpLogEvent(LogString, &reason, STATUS_PNP_INVALID_ID, &separators, sizeof(ULONG));
            }
            return 0;
        }
    }
    if(p >= pMax || (AllowedSeparators != (ULONG)-1 && separators != AllowedSeparators)) {

        IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                     "PiFixupID: ID at %p not terminated, or too long or has invalid number (%d) of separators\n",
                     ID,
                     separators));
        if(LogString) {

            PiWstrToUnicodeString(&reason, L"not terminated, too long or invalid number of separators");
            PpLogEvent(LogString, &reason, STATUS_PNP_INVALID_ID, NULL, 0);
        }
        return 0;
    }

    return (ULONG)(ULONG_PTR)(p - ID) + 1;
}

NTSTATUS
PpQueryDeviceID(
    IN PDEVICE_NODE DeviceNode,
    OUT PWCHAR *BusID,
    OUT PWCHAR *DeviceID
    )

/*++

Routine Description:

    This routine queries the Device ID and fixes it up. It also parses the DeviceID 
    and returns the pointers to BusID and DeviceID parts. If this routine fails, 
    BusID and DeviceID will be set to NULL.

Arguments:

    DeviceNode - The devnode whose DeviceID needs to be queried.
    
    BusID - Recieves the pointer to the bus part of DeviceID.

    DeviceID - Recieves the pointer to the device part of DeviceID.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    PWCHAR id, separator;
    ULONG idLength;

    PAGED_CODE();

    *BusID = NULL;
    *DeviceID= NULL;

    status = PpQueryID(DeviceNode, BusQueryDeviceID, &id, &idLength);
    if(NT_SUCCESS(status)) {

        ASSERT(id && idLength);

        *BusID = id;
        separator = wcschr(id, OBJ_NAME_PATH_SEPARATOR);

        ASSERT(separator);

        *separator = UNICODE_NULL;
        *DeviceID = separator + 1;

    } else {

        ASSERT(id == NULL && idLength == 0);
    }

    return status;
}

NTSTATUS
PpQueryID(
    IN PDEVICE_NODE DeviceNode,
    IN BUS_QUERY_ID_TYPE IDType,
    OUT PWCHAR *ID,
    OUT PULONG IDLength
    )

/*++

Routine Description:

    This routine queries the specified ID and fixes it up. If this 
    routine fails, ID will be set to NULL.

Arguments:

    DeviceNode - The devnode whose IDs need to be queried.
    
    IDType - Type of ID to be queried.

    ID - Receives the ID returned by the driver if any. The caller 
    is expected to free the storage for ID on success.
    
    IDLength - Receives the length of the ID (including terminating NULL) in bytes.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS status;
    UNICODE_STRING reason;

    PAGED_CODE();

    ASSERT(IDType == BusQueryDeviceID || IDType == BusQueryInstanceID || 
          IDType == BusQueryHardwareIDs || IDType == BusQueryCompatibleIDs);

    *IDLength = 0;
    status = PpIrpQueryID(DeviceNode->PhysicalDeviceObject, IDType, ID);
    if(NT_SUCCESS(status)) {

        switch(IDType) {

            case BusQueryDeviceID:

                *IDLength = PiFixupID(*ID, MAX_DEVICE_ID_LEN, FALSE, 1, &DeviceNode->Parent->ServiceName);
                break;

            case BusQueryInstanceID:

                *IDLength = PiFixupID(*ID, MAX_DEVICE_ID_LEN, FALSE, 0, &DeviceNode->Parent->ServiceName);
                break;

            case BusQueryHardwareIDs:
            case BusQueryCompatibleIDs:

                *IDLength = PiFixupID(*ID, MAX_DEVICE_ID_LEN, TRUE, (ULONG)-1, &DeviceNode->Parent->ServiceName);
                break;

            default:

                *IDLength = 0;
                break;
        }
        (*IDLength) *= sizeof(WCHAR);
        if(*IDLength == 0) {

            status = STATUS_PNP_INVALID_ID;
        }
    }

    if(!NT_SUCCESS(status)) {

        if (status == STATUS_PNP_INVALID_ID || IDType == BusQueryDeviceID) {

            PipSetDevNodeProblem(DeviceNode, CM_PROB_INVALID_DATA);
            if ((DeviceNode->Parent->Flags & DNF_CHILD_WITH_INVALID_ID) == 0) {

                DeviceNode->Parent->Flags |= DNF_CHILD_WITH_INVALID_ID;
                PpSetInvalidIDEvent(&DeviceNode->Parent->InstancePath);
            }
        }
        if (status == STATUS_PNP_INVALID_ID) {

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpQueryID: Bogus ID returned by %wZ\n",
                         &DeviceNode->Parent->ServiceName));
            ASSERT(status != STATUS_PNP_INVALID_ID);

        } else if (IDType == BusQueryDeviceID) {
            //
            // DeviceID is not optional.
            //
            PiWstrToUnicodeString(&reason, L"failed IRP_MN_QUERY_ID-BusQueryDeviceID");
            PpLogEvent(&DeviceNode->Parent->ServiceName, &reason, status, NULL, 0);

            IopDbgPrint((IOP_ENUMERATION_ERROR_LEVEL,
                         "PpIrpQueryID: Failed by %wZ, status = %x\n",
                         &DeviceNode->Parent->ServiceName, status));
            ASSERT(IDType != BusQueryDeviceID);
        }

        if(*ID) {

            ExFreePool(*ID);
            *ID = NULL;
            *IDLength = 0;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppcontrol.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ppcontrol.c

Abstract:

    User-mode -> Kernel-mode PnP Manager control routines.

Author:

    Lonny McMichael (lonnym) 02/14/95

Revision History:

--*/

#include "pnpmgrp.h"
#include "picontrol.h"
#pragma hdrstop

//
// ISSUE - 2000/08/19 - ADRIAO: This should be generalized for all of Pnp
//
#if DBG
LONG
PiControlExceptionFilter(
    IN  PEXCEPTION_POINTERS ExceptionPointers
    );
#else
#define PiControlExceptionFilter(a)  EXCEPTION_EXECUTE_HANDLER
#endif

__inline
NTSTATUS
PiControlAllocateBufferForUserModeCaller(
    PVOID           *Dest,
    ULONG           Size,
    KPROCESSOR_MODE CallerMode,
    PVOID           Src
    )
{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (Size) {

        if (CallerMode != KernelMode) {

            *Dest = ExAllocatePoolWithQuota(
                PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                Size
                );
            if (*Dest == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {

            *Dest = Src;
        }
    } else {

        *Dest = NULL;
    }

    return status;
}

__inline
void
PiControlFreeUserModeCallersBuffer(
    KPROCESSOR_MODE CallerMode,
    PVOID           Buffer
    )
{
    if (CallerMode != KernelMode) {

        if (Buffer != NULL) {

            ExFreePool(Buffer);
        }
    }
}

//
// Global driver object that is used by calls to NtPlugPlayControl
// with control type of PlugPlayControlDetectResourceConflict.
//
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
PDRIVER_OBJECT driverObject = NULL;

//
// Define mask of devnode flags that are settable from user-mode via the
// NtPlugPlayControl, PlugPlayControlGetDeviceStatus (which is a misnomer,
// since it can perform both gets and sets).
//
#define DEVICE_NODE_SETTABLE_FLAG_BITS (DNF_HAS_PROBLEM         | \
                                        DNF_HAS_PRIVATE_PROBLEM   \
                                       )

NTSTATUS
PiGetInterfaceDeviceAlias(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  LPGUID AliasClassGuid,
    OUT PWSTR AliasSymbolicLinkName,
    IN OUT PULONG AliasSymbolicLinkNameLength
    );

NTSTATUS
PiGenerateLegacyDeviceInstance(
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PWSTR DeviceInstance,
    IN OUT PULONG DeviceInstanceLength
    );

NTSTATUS
PiQueueQueryAndRemoveEvent(
    IN  PUNICODE_STRING DeviceInstance,
    IN  PPNP_VETO_TYPE VetoType,
    IN  LPWSTR VetoName,
    IN  PULONG VetoNameLength,
    IN  ULONG Flags
    );

NTSTATUS
PiQueueDeviceRequest(
    IN PUNICODE_STRING DeviceInstance,
    IN DEVICE_REQUEST_TYPE RequestType,
    IN ULONG Flags,
    IN BOOLEAN Synchronous
    );

NTSTATUS
PiInitializeDevice(
    IN  PUNICODE_STRING DeviceInstance
    );

NTSTATUS
PiDetectResourceConflict(
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize
    );

NTSTATUS
PiGetInterfaceDeviceList(
    IN  GUID *InterfaceGuid,
    IN  PUNICODE_STRING DeviceInstance,
    IN  ULONG Flags,
    OUT PWSTR InterfaceList,
    IN OUT PULONG InterfaceListSize
    );

NTSTATUS
PiDeviceClassAssociation(
    IN PUNICODE_STRING DeviceInstance,
    IN GUID * ClassGuid,
    IN PUNICODE_STRING Reference,   OPTIONAL
    IN OUT PWSTR SymbolicLink,
    IN OUT PULONG SymbolicLinkLength,
    IN BOOLEAN Register
    );

NTSTATUS
PiGetRelatedDevice(
    IN  PUNICODE_STRING TargetDeviceInstance,
    OUT LPWSTR RelatedDeviceInstance,
    IN OUT PULONG RelatedDeviceInstanceLength,
    IN  ULONG Relation
    );

NTSTATUS
PiQueryDeviceRelations(
    IN PUNICODE_STRING DeviceInstance,
    IN PNP_QUERY_RELATION Operation,
    OUT PULONG BufferLength,
    OUT LPWSTR Buffer
    );

DEVICE_RELATION_TYPE
PiDeviceRelationType(
    PNP_QUERY_RELATION  Operation
    );

NTSTATUS
PiControlGetBlockedDriverData(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA    BlockedDriverData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, PpShutdownSystem)                    // this gets called after paging shutdown
#pragma alloc_text(PAGE, NtPlugPlayControl)
#pragma alloc_text(PAGE, PiControlMakeUserModeCallersCopy)
#pragma alloc_text(PAGE, PiGetInterfaceDeviceAlias)
#pragma alloc_text(PAGE, PiGenerateLegacyDeviceInstance)
#pragma alloc_text(PAGE, PiQueueQueryAndRemoveEvent)
#pragma alloc_text(PAGE, PiInitializeDevice)
#pragma alloc_text(PAGE, PiDetectResourceConflict)
#pragma alloc_text(PAGE, PiGetInterfaceDeviceList)
#pragma alloc_text(PAGE, PiDeviceClassAssociation)
#pragma alloc_text(PAGE, PiGetRelatedDevice)
#pragma alloc_text(PAGE, PiQueryDeviceRelations)
#pragma alloc_text(PAGE, PiDeviceRelationType)
#pragma alloc_text(PAGE, PiControlGetUserFlagsFromDeviceNode)
#pragma alloc_text(PAGE, PiQueueDeviceRequest)
#pragma alloc_text(PAGE, PiControlEnumerateDevice)
#pragma alloc_text(PAGE, PiControlRegisterNewDevice)
#pragma alloc_text(PAGE, PiControlDeregisterDevice)
#pragma alloc_text(PAGE, PiControlInitializeDevice)
#pragma alloc_text(PAGE, PiControlStartDevice)
#pragma alloc_text(PAGE, PiControlResetDevice)
#pragma alloc_text(PAGE, PiControlQueryAndRemoveDevice)
#pragma alloc_text(PAGE, PiControlUserResponse)
#pragma alloc_text(PAGE, PiControlGenerateLegacyDevice)
#pragma alloc_text(PAGE, PiControlGetInterfaceDeviceList)
#pragma alloc_text(PAGE, PiControlGetPropertyData)
#pragma alloc_text(PAGE, PiControlDeviceClassAssociation)
#pragma alloc_text(PAGE, PiControlGetRelatedDevice)
#pragma alloc_text(PAGE, PiControlGetInterfaceDeviceAlias)
#pragma alloc_text(PAGE, PiControlGetSetDeviceStatus)
#pragma alloc_text(PAGE, PiControlGetDeviceDepth)
#pragma alloc_text(PAGE, PiControlQueryDeviceRelations)
#pragma alloc_text(PAGE, PiControlQueryTargetDeviceRelation)
#pragma alloc_text(PAGE, PiControlQueryConflictList)
#pragma alloc_text(PAGE, PiControlGetDevicePowerData)
#pragma alloc_text(PAGE, PiControlRetrieveDockData)
#pragma alloc_text(PAGE, PiControlHaltDevice)
#pragma alloc_text(PAGE, PiControlGetBlockedDriverData)
#if DBG
#pragma alloc_text(PAGE, PiControlExceptionFilter)
#endif
#endif // ALLOC_PRAGMA

//
// This table contains handlers for all the messages coming from the
// umpnpmgr.dll.
//
PLUGPLAY_CONTROL_HANDLER_DATA PlugPlayHandlerTable[] = {

    { PlugPlayControlEnumerateDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlEnumerateDevice },

    { PlugPlayControlRegisterNewDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlRegisterNewDevice },

    { PlugPlayControlDeregisterDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlDeregisterDevice },

    { PlugPlayControlInitializeDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlInitializeDevice },

    { PlugPlayControlStartDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlStartDevice },

    { PlugPlayControlUnlockDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      NULL },

    { PlugPlayControlQueryAndRemoveDevice,
      sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA),
      PiControlQueryAndRemoveDevice },

    { PlugPlayControlUserResponse,
      sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA),
      PiControlUserResponse },

    { PlugPlayControlGenerateLegacyDevice,
      sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA),
      PiControlGenerateLegacyDevice },

    { PlugPlayControlGetInterfaceDeviceList,
      sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA),
      PiControlGetInterfaceDeviceList },

    { PlugPlayControlProperty,
      sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA),
      PiControlGetPropertyData },

    { PlugPlayControlDeviceClassAssociation,
      sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA),
      PiControlDeviceClassAssociation },

    { PlugPlayControlGetRelatedDevice,
      sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA),
      PiControlGetRelatedDevice },

    { PlugPlayControlGetInterfaceDeviceAlias,
      sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA),
      PiControlGetInterfaceDeviceAlias },

    { PlugPlayControlDeviceStatus,
      sizeof(PLUGPLAY_CONTROL_STATUS_DATA),
      PiControlGetSetDeviceStatus },

    { PlugPlayControlGetDeviceDepth,
      sizeof(PLUGPLAY_CONTROL_DEPTH_DATA),
      PiControlGetDeviceDepth },

    { PlugPlayControlQueryDeviceRelations,
      sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA),
      PiControlQueryDeviceRelations },

    { PlugPlayControlTargetDeviceRelation,
      sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA),
      PiControlQueryTargetDeviceRelation },

    { PlugPlayControlQueryConflictList,
      sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA),
      PiControlQueryConflictList },

    { PlugPlayControlRetrieveDock,
      sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA),
      PiControlRetrieveDockData },

    { PlugPlayControlResetDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlResetDevice },

    { PlugPlayControlHaltDevice,
      sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA),
      PiControlHaltDevice },

    { PlugPlayControlGetBlockedDriverList,
      sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA),
      PiControlGetBlockedDriverData },

    { MaxPlugPlayControl,
      0,
      NULL }
};

NTSTATUS
NtPlugPlayControl(
    IN     PLUGPLAY_CONTROL_CLASS   PnPControlClass,
    IN OUT PVOID                    PnPControlData,
    IN     ULONG                    PnPControlDataLength
    )
/*++

Routine Description:

    This Plug and Play Manager API provides a mechanism for the user-mode
    PnP Manager to control the activity of its kernel-mode counterpart.

Arguments:

    PnPControlClass - Specifies what action to perform.

    PnPControlData - Supplies a pointer to data specific to this action.

    PnPControlDataLength - Specifies the size, in bytes, of the buffer pointed
                           to by PnPControlData

Return Value:

    NT status code indicating success or failure.  Set of possible return
    values includes the following:

        STATUS_SUCCESS - normal, successful completion.

        STATUS_INVALID_PARAMETER_1 - The PnPControlClass parameter did not
            specify a valid control class.

        STATUS_INVALID_PARAMETER_MIX - The value of the PnPControlDataLength
            parameter did not match the length required for the control
            class requested by the PnPControlClass parameter.

        STATUS_BUFFER_TOO_SMALL - The size of the supplied output buffer is not
            large enough to hold the output generated by this control class.

        STATUS_ACCESS_VIOLATION - One of the following pointers specified
            an invalid address: (1) the PnPControlData buffer pointer,
            (2) some pointer contained in the PnPControlData buffer.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources exist
            for this request to complete.

--*/
{
    NTSTATUS status, tempStatus;
    KPROCESSOR_MODE previousMode;
    ULONG index;
    PPLUGPLAY_CONTROL_HANDLER_DATA handlerData;
    PLUGPLAY_CONTROL_HANDLER controlHandler;
    PVOID controlDataSnapshot;
    //
    // Get previous processor mode and probe arguments if necessary.
    //
    previousMode = KeGetPreviousMode();
    if (previousMode != KernelMode) {
        //
        // Does the caller have "trusted computer base" privilge?
        //
        if (!SeSinglePrivilegeCheck(SeTcbPrivilege, UserMode)) {

            IopDbgPrint((IOP_IOAPI_WARNING_LEVEL,
                       "NtPlugPlayControl: SecurityCheck failed\n"));
            return STATUS_PRIVILEGE_NOT_HELD;
        }
    }
    //
    // Look through the table to find the appropriate handler. Note that
    // the control class *should* be an index into the table itself.
    //
    index = (ULONG)PnPControlClass;
    handlerData = NULL;
    if (index < MaxPlugPlayControl) {

        if (PlugPlayHandlerTable[index].ControlCode == PnPControlClass) {

            handlerData = &PlugPlayHandlerTable[index];
        } else {
            //
            // Someone broke the table.
            //
            IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                       "NtPlugPlayControl: Lookup table isn't ordered correctly (entry %d)!\n",
                       PnPControlClass
                       ));
            ASSERT(0);

            for(index = 0; index < MaxPlugPlayControl; index++) {

                if (PlugPlayHandlerTable[index].ControlCode == PnPControlClass) {

                    handlerData = &PlugPlayHandlerTable[index];
                    break;
                }
            }
        }
    }
    //
    // Do we have handler data?
    //
    if (handlerData == NULL) {
        //
        // Invalid control class.
        //
        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                   "NtPlugPlayControl: Unknown control class, Class = %d, Size = %d\n",
                   PnPControlClass,
                   PnPControlDataLength));
        return STATUS_INVALID_PARAMETER_1;
    }
    //
    // No control function means not implemented.
    //
    if (handlerData->ControlFunction == NULL) {

        return STATUS_NOT_IMPLEMENTED;
    }
    //
    // Check the data size.
    //
    if (handlerData->ControlDataSize != PnPControlDataLength) {

        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                   "NtPlugPlayControl: Invalid size for control, Class = %d, Size = %d\n",
                   PnPControlClass,
                   PnPControlDataLength));
        return STATUS_INVALID_PARAMETER_MIX;
    }
    //
    // Make copy of caller's buffer.
    //
    status = PiControlMakeUserModeCallersCopy(
        &controlDataSnapshot,
        PnPControlData,
        PnPControlDataLength,
        sizeof(ULONG),
        previousMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Invoke the handler.
    //
    status = handlerData->ControlFunction(
        PnPControlClass,
        controlDataSnapshot,
        PnPControlDataLength,
        previousMode
        );
    //
    // Copy the buffer if the operation was successful or the value is
    // a warning like STATUS_BUFFER_OVERFLOW.
    //
    // ISSUE - 2000/09/11 - Misused STATUS code
    //    Here we hack around the fact that we've been returning
    // STATUS_BUFFER_TOO_SMALL instead of STATUS_BUFFER_OVERFLOW. This
    // should be fixed here and in UMPNPMGR.
    //
    if ((!NT_ERROR(status)) || (status == STATUS_BUFFER_TOO_SMALL)) {

        //
        // Copy result back into caller's buffer.
        //
        tempStatus = PiControlMakeUserModeCallersCopy(
            &PnPControlData,
            controlDataSnapshot,
            PnPControlDataLength,
            sizeof(ULONG),
            previousMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    //
    // Free buffer allocated for user mode caller.
    //
    PiControlFreeUserModeCallersBuffer(previousMode, controlDataSnapshot);

    return status;
}

#if DBG
LONG
PiControlExceptionFilter(
    IN  PEXCEPTION_POINTERS ExceptionPointers
    )
{
    IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
              "PiExceptionFilter: Exception = 0x%08X, Exception Record = 0x%p, Context Record = 0x%p\n",
              ExceptionPointers->ExceptionRecord->ExceptionCode,
              ExceptionPointers->ExceptionRecord,
              ExceptionPointers->ContextRecord));

    DbgBreakPoint();

    return EXCEPTION_EXECUTE_HANDLER;
}
#endif

NTSTATUS
PiControlMakeUserModeCallersCopy(
    PVOID           *Destination,
    PVOID           Src,
    ULONG           Length,
    ULONG           Alignment,
    KPROCESSOR_MODE CallerMode,
    BOOLEAN         AllocateDestination
    )
{
    NTSTATUS    status;

    status = STATUS_SUCCESS;
    if (CallerMode == KernelMode) {

        ASSERT(AllocateDestination == FALSE);
        *Destination = Src;

    } else {

        if (Length) {

            if (AllocateDestination) {

                *Destination = ExAllocatePoolWithQuota(
                    PagedPool | POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                    Length
                    );
                if (*Destination == NULL) {

                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            if (*Destination) {
                try {

                    if (AllocateDestination == FALSE) {

                        ProbeForWrite(
                            *Destination,
                            Length,
                            Alignment
                            );
                    } else {

                        ProbeForRead(
                            Src,
                            Length,
                            Alignment
                            );
                    }
                    RtlCopyMemory(
                        *Destination,
                        Src,
                        Length
                        );

                } except(PiControlExceptionFilter(GetExceptionInformation())) {

                    if (AllocateDestination == TRUE) {

                        ExFreePool(*Destination);
                        *Destination = NULL;
                    }
                    status = GetExceptionCode();
                    IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                               "PiControlMakeUserModeCallersCopy: Exception copying data to or from user's buffer\n"));
                }
            }
        } else {

            *Destination = NULL;
        }
    }

    return status;
}

NTSTATUS
PiGetInterfaceDeviceAlias(
    IN  PUNICODE_STRING SymbolicLinkName,
    IN  LPGUID AliasClassGuid,
    OUT PWSTR AliasSymbolicLinkName,
    IN OUT PULONG AliasSymbolicLinkNameLength
    )

/*++

Routine Description:

    This routine retrieves the interface device of the specified class that aliases
    a particular interface device.  See IoGetAliasForDeviceClassAssociation for
    more details.

Arguments:

    SymbolicLinkName - Supplies the name of the interface device whose alias is to
        be retrieved.

    AliasClassGuid - Supplies a pointer to the GUID representing the interface class
        in which an alias of SymbolicLinkName is to be found.

    AliasSymbolicLinkName - Supplies a character buffer that, upon success, receives
        the name of the alias interface device.

    AliasSymbolicLinkNameLength - Supplies the length, in bytes, of the
        AliasSymbolicLinkName character buffer.

    RequiredLength - Supplies the address of a variable that will be filled in with
        the number of bytes (including terminating NULL) required to store the
        interface device name in the AliasSymbolicLinkName buffer.  This will be
        filled in upon successful return, or when the return is STATUS_BUFFER_TOO_SMALL.

Return Value:

    A NTSTATUS code indicating success or cause of failure.

--*/

{
    NTSTATUS status;
    UNICODE_STRING aliasString;

    status = IoGetDeviceInterfaceAlias( SymbolicLinkName,
                                        AliasClassGuid,
                                        &aliasString
                                        );

    if (NT_SUCCESS(status)) {

        if (aliasString.Length < *AliasSymbolicLinkNameLength) {
            RtlCopyMemory(AliasSymbolicLinkName, aliasString.Buffer, aliasString.Length);
            *(PWCHAR)((PUCHAR)AliasSymbolicLinkName + aliasString.Length) = L'\0';
            *AliasSymbolicLinkNameLength = aliasString.Length;
        } else {
            *AliasSymbolicLinkNameLength = aliasString.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }
        ExFreePool(aliasString.Buffer);
    }

    return status;
}

NTSTATUS
PiGenerateLegacyDeviceInstance(
    IN  PUNICODE_STRING ServiceKeyName,
    OUT PWSTR DeviceInstance,
    IN OUT PULONG DeviceInstanceLength
    )

/*++

Routine Description:

    This routine creates a new instance node under System\Enum\Root\LEGACY_<Name>
    key and all the required default value entries.  Also a value entry under
    Service\ServiceKeyName\Enum is created to point to the newly created madeup
    entry.  A handle and the keyname of the new key are returned to caller.
    Caller must free the unicode string when he is done with it.

Arguments:

    ServiceKeyName - Supplies a pointer to the name of the subkey in the
        system service list (HKEY_LOCAL_MACHINE\CurrentControlSet\Services)
        that caused the driver to load.

    DeviceInstance - Supplies a pointer to the character buffer that receives the
        newly-generated device instance name.

    DeviceInstanceLength - Supplies the size, in bytes, of the DeviceInstance
        buffer.

Return Value:

    A NTSTATUS code.
    If the legacy device instance exists already, this function returns success.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    ULONG junk;
    UNICODE_STRING tempUnicodeString;

    PiLockPnpRegistry(FALSE);

    status = PipCreateMadeupNode(ServiceKeyName,
                                 &handle,
                                 &tempUnicodeString,
                                 &junk,
                                 TRUE
                                 );
    if (NT_SUCCESS(status)) {

        //
        // We have successfully retrieved the newly-generated device instance name.
        // Now store it in the supplied buffer.
        //

        ZwClose(handle);

        if (tempUnicodeString.Length < *DeviceInstanceLength) {
            RtlCopyMemory(DeviceInstance,
                          tempUnicodeString.Buffer,
                          tempUnicodeString.Length
                          );

            *(PWCHAR)((PUCHAR)DeviceInstance + tempUnicodeString.Length) = L'\0';
            *DeviceInstanceLength = tempUnicodeString.Length;
        } else {
            *DeviceInstanceLength = tempUnicodeString.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }

        RtlFreeUnicodeString(&tempUnicodeString);
    }

    PiUnlockPnpRegistry();

    return status;
}

NTSTATUS
PiQueueQueryAndRemoveEvent(
    IN  PUNICODE_STRING DeviceInstance,
    IN  PPNP_VETO_TYPE VetoType,
    IN  LPWSTR VetoName,
    IN  PULONG VetoNameLength,
    IN  ULONG Flags
    )

/*++

Routine Description:

    This routine queues an event to handle the specified operation later in
    the context of a system thread. There is one master event queue and all
    events are handled in the order they were submitted.

    This routine also handles user-mode requests to eject the device specified
    in DeviceInstance.  If the device's capabilities report the device
    ejectable or lockable then it is handled by the same code that processes
    IoRequestDeviceEject, otherwise the driver stack is removed and the device
    node is marked with the problem CM_PROB_DEVICE_NOT_THERE which prevents it
    from being reenumerated until the device is physically removed.  This later
    method is used primarily for things like PCCARD devices.

Arguments:

    DeviceInstance - Supplies the device instance name of the device that is
            the target of the event.

    EventGuid - This is the GUID that uniquely identifies the type of event.

    Synchronous - This is a boolean flag indicating whether the action should
            be performed synchronously or asynchronously (synchronous if TRUE).

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_NODE deviceNode = NULL;
    UNICODE_STRING vetoNameString;
    PUNICODE_STRING vetoNameStringPtr;
    BOOLEAN noRestart, doEject;
    ULONG problem;
    KEVENT userEvent;
    ULONG  eventResult;

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);

    if (!deviceObject) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean1;
    }

    //
    // Retrieve the device node for this device object.
    //

    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean1;
    }

    if (deviceNode == IopRootDeviceNode) {
        status = STATUS_ACCESS_DENIED;
        goto Clean1;
    }

    vetoNameString.Length = 0;
    vetoNameString.MaximumLength = (USHORT)(*VetoNameLength);

    if (vetoNameString.MaximumLength != 0) {

        vetoNameString.Buffer = ExAllocatePool(PagedPool, vetoNameString.MaximumLength);

        if (vetoNameString.Buffer == NULL) {
            vetoNameString.MaximumLength = 0;
        }

        vetoNameStringPtr = &vetoNameString;

    } else {

        vetoNameString.Buffer = NULL;
        vetoNameStringPtr = NULL;
    }

    //
    // Do preprocessing of device node before queueing notification.
    //

    if (Flags & (PNP_QUERY_AND_REMOVE_NO_RESTART |
                 PNP_QUERY_AND_REMOVE_DISABLE |
                 PNP_QUERY_AND_REMOVE_EJECT_DEVICE)) {

        noRestart = TRUE;

    } else {

        noRestart = FALSE;
    }

    //
    // Nobody has ever used this flag. We should not see it here, and we ignore
    // it if we do see it.
    //
    ASSERT(!(Flags & PNP_QUERY_AND_REMOVE_UNINSTALL));

    if (Flags & PNP_QUERY_AND_REMOVE_DISABLE) {

        //
        // this particular problem may cause a
        // "NonDisableable" Veto
        //
        problem = CM_PROB_DISABLED;
        doEject = FALSE;

    } else if (Flags & PNP_QUERY_AND_REMOVE_EJECT_DEVICE) {

        problem = CM_PROB_HELD_FOR_EJECT;
        doEject = TRUE;

    } else {

        problem = CM_PROB_WILL_BE_REMOVED;
        doEject = FALSE;
    }

    //
    // Queue this device event
    //

    KeInitializeEvent(&userEvent, NotificationEvent, FALSE);

    //
    // Queue the event, this call will return immediately. Note that status
    // is the status of the PpSetTargetDeviceChange while result is the
    // outcome of the actual event.
    //

    status = PpSetTargetDeviceRemove(deviceObject,
                                     FALSE,
                                     noRestart,
                                     doEject,
                                     problem,
                                     &userEvent,
                                     &eventResult,
                                     VetoType,
                                     vetoNameStringPtr);
    if (!NT_SUCCESS(status)) {
        goto Clean0;
    }

    //
    // Wait for the event we just queued to finish since synchronous operation
    // was requested (non alertable wait).
    //
    // FUTURE ITEM - Use a timeout here?
    //

    status = KeWaitForSingleObject(&userEvent, Executive, KernelMode, FALSE, NULL);

    if (NT_SUCCESS(status)) {
        status = eventResult;
    }

    if (vetoNameString.Length != 0) {

        if (vetoNameString.Length >= vetoNameString.MaximumLength) {
            vetoNameString.Length--;
        }

        RtlCopyMemory(VetoName, vetoNameString.Buffer, vetoNameString.Length);


        VetoName[ vetoNameString.Length / sizeof(WCHAR) ] = L'\0';
    }

    if (VetoNameLength != NULL) {
        *VetoNameLength = vetoNameString.Length;
    }

Clean0:

    if (vetoNameString.Buffer != NULL) {
        ExFreePool(vetoNameString.Buffer);
    }

Clean1:
    if (deviceObject) {
        ObDereferenceObject(deviceObject);
    }

    return status;

} // PiQueueDeviceEvent

NTSTATUS
PiInitializeDevice(
    IN  PUNICODE_STRING DeviceInstance
    )

/*++

Routine Description:

    This routine creates a devnode for the device instance and performs
    any other necessary initialization of the device instance.

Arguments:

    DeviceInstance - Supplies the path in the registry (relative to
        HKLM\System\Enum) to the device instance to initalize.

Return Value:

    NT status code indicating success or failure of this routine.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING serviceName, unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    ULONG deviceFlags;
    HANDLE hEnum = NULL, hDevInst = NULL, handle = NULL;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode = NULL;

    //
    // Acquire lock on the registry before we do any initialization.
    //
    PiLockPnpRegistry(TRUE);

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);
    if (deviceObject == NULL) {

        //
        // Open a key to HKLM\SYSTEM\CCC\Enum
        //

        status = IopOpenRegistryKeyEx( &hEnum,
                                       NULL,
                                       &CmRegistryMachineSystemCurrentControlSetEnumName,
                                       KEY_ALL_ACCESS
                                       );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        //
        // Open a key to the specified device instance
        //

        status = IopCreateRegistryKeyEx( &hDevInst,
                                         hEnum,
                                         DeviceInstance,
                                         KEY_ALL_ACCESS,
                                         REG_OPTION_NON_VOLATILE,
                                         NULL
                                         );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        //
        // We need to propagate the ConfigFlag to problem and values (devnode flags)
        //

        deviceFlags = 0;
        status = IopGetRegistryValue(hDevInst,
                                     REGSTR_VALUE_CONFIG_FLAGS,
                                     &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if ((keyValueInformation->Type == REG_DWORD) &&
                (keyValueInformation->DataLength >= sizeof(ULONG))) {
                deviceFlags = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }

        //
        // Get the "Service=" value entry from KeyHandle
        //

        keyValueInformation = NULL;
        PiWstrToUnicodeString(&serviceName, NULL);

        status = IopGetRegistryValue(hDevInst,
                                     REGSTR_VALUE_SERVICE,
                                     &keyValueInformation
                                     );
        if (NT_SUCCESS(status)) {

            if ((keyValueInformation->Type == REG_SZ) &&
                (keyValueInformation->DataLength != 0)) {

                //
                // Set up ServiceKeyName unicode string
                //

                IopRegistryDataToUnicodeString(&serviceName,
                                               (PWSTR)KEY_VALUE_DATA(keyValueInformation),
                                               keyValueInformation->DataLength
                                               );
            }

            //
            // Do not Free keyValueInformation.  It contains Service Name.
            //
        }

        //
        // Create madeup PDO and device node to represent the root device.
        //

        status = IoCreateDevice( IoPnpDriverObject,
                                 0,
                                 NULL,
                                 FILE_DEVICE_CONTROLLER,
                                 FILE_AUTOGENERATED_DEVICE_NAME,
                                 FALSE,
                                 &deviceObject );

        if (NT_SUCCESS(status)) {

            deviceObject->Flags |= DO_BUS_ENUMERATED_DEVICE;
            PipAllocateDeviceNode(deviceObject, &deviceNode);
            if (status != STATUS_SYSTEM_HIVE_TOO_LARGE && deviceNode) {

                deviceNode->Flags = DNF_MADEUP | DNF_ENUMERATED;

                PipSetDevNodeState(deviceNode, DeviceNodeInitialized, NULL);

                if (deviceFlags & CONFIGFLAG_REINSTALL) {
                    PipSetDevNodeProblem(deviceNode, CM_PROB_REINSTALL);
                } else if (deviceFlags & CONFIGFLAG_PARTIAL_LOG_CONF) {
                    PipSetDevNodeProblem(deviceNode, CM_PROB_PARTIAL_LOG_CONF);
                }

                //
                // Make a copy of the device instance path and save it in
                // device node.
                //

                status = PipConcatenateUnicodeStrings(&deviceNode->InstancePath,
                                                      DeviceInstance,
                                                      NULL
                                                      );

                if (serviceName.Length != 0) {

                    //
                    // Make a copy of the service name and save it in device node.
                    //
                    status = PipConcatenateUnicodeStrings(&deviceNode->ServiceName,
                                                          &serviceName,
                                                          NULL
                                                          );
                } else {

                    PiWstrToUnicodeString(&deviceNode->ServiceName, NULL);
                }

                //
                // Add an entry into the table to set up a mapping between the DO
                // and the instance path.
                //
                status = IopMapDeviceObjectToDeviceInstance(
                    deviceNode->PhysicalDeviceObject,
                    &deviceNode->InstancePath
                    );

                ASSERT(NT_SUCCESS(status));

                PpDevNodeInsertIntoTree(IopRootDeviceNode, deviceNode);

                //
                // Add an event so user-mode will attempt to install this device later.
                //
                PpSetPlugPlayEvent(&GUID_DEVICE_ENUMERATED,
                                   deviceNode->PhysicalDeviceObject);

            } else {
                IoDeleteDevice(deviceObject);
                deviceObject = NULL;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (keyValueInformation != NULL) {
            ExFreePool(keyValueInformation);
        }

    } else {

        ObDereferenceObject(deviceObject);
    }

    //
    // If we failed, Clean up ...
    //

    if (hDevInst) {
        ZwClose(hDevInst);
    }
    if (hEnum) {
        ZwClose(hEnum);
    }

Clean0:

    //
    // Release the registry lock.
    //

    PiUnlockPnpRegistry();

    return status;

} // PiInitializeDevice




NTSTATUS
PiDetectResourceConflict(
    IN PCM_RESOURCE_LIST  ResourceList,
    IN ULONG              ResourceListSize
    )

/*++

Routine Description:

    This routine is invoked to test whether the specified resource
    list conflicts with any already assigned resources.

Arguments:

    ResourceList - Specifies a resource list buffer.

    ResourceListSize - Specifies the size of the resource list buffer.

Return Value:

    The function value is an NTSTATUS value; STATUS_SUCCESS indicates
    that the resources do not conflict, STATUS_INSUFFICIENT_RESOURCES
    indicates that the resource conflict with already assigned
    resources (or some other NTSTATUS value may indicate a different
    internal error).

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    PWSTR buffer;
    NTSTATUS status;
    UNICODE_STRING DriverName;
    ULONG i;
    BOOLEAN bTemp;
    CM_RESOURCE_LIST EmptyResourceList;


    if (driverObject == NULL) {
        //
        // Driver object has not been created yet, do that now.
        //
        PiWstrToUnicodeString(&DriverName, L"\\Device\\PlugPlay");

        //
        // Begin by creating the permanent driver object.
        //
        InitializeObjectAttributes(&objectAttributes,
                                   &DriverName,
                                   OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                   (HANDLE)NULL,
                                   (PSECURITY_DESCRIPTOR)NULL);

        //
        // Specify "KernelMode" here since it refers to the source of
        // the objectAttributes buffer, not the previous operating system
        // mode.
        //
        status = ObCreateObject(KernelMode,
                                IoDriverObjectType,
                                &objectAttributes,
                                KernelMode,
                                (PVOID)NULL,
                                (ULONG)(sizeof(DRIVER_OBJECT) + sizeof(DRIVER_EXTENSION)),
                                0,
                                0,
                                (PVOID)&driverObject);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        //
        // Initialize the driver object.
        //
        RtlZeroMemory(driverObject,
                      sizeof(DRIVER_OBJECT) + sizeof(DRIVER_EXTENSION));
        driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
        driverObject->DriverExtension->DriverObject = driverObject;
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
            driverObject->MajorFunction[i] = NULL;        // OK???
        }
        driverObject->Type = IO_TYPE_DRIVER;
        driverObject->Size = sizeof(DRIVER_OBJECT);
        driverObject->DriverInit = NULL;

        //
        // Insert the driver object into the object table.
        //
        status = ObInsertObject(driverObject,
                                NULL,
                                FILE_READ_DATA,
                                0,
                                (PVOID *)NULL,
                                &handle);

        if (!NT_SUCCESS(status)) {
//            ObMakeTemporaryObject(driverObject);    //?
//            ObDereferenceObject(driverObject);      //?
            //
            // Object is dereferenced by the object manager if insert fails.
            //
            return status;
        }

        //
        // Save the name of the driver so that it can be easily located by functions
        // such as error logging.
        //
        buffer = ExAllocatePool(PagedPool, DriverName.MaximumLength + 2);

        if (buffer) {
            driverObject->DriverName.Buffer = buffer;
            driverObject->DriverName.MaximumLength = DriverName.MaximumLength;
            driverObject->DriverName.Length = DriverName.Length;

            RtlCopyMemory(driverObject->DriverName.Buffer,
                          DriverName.Buffer,
                          DriverName.MaximumLength);
            buffer[DriverName.Length / sizeof(UNICODE_NULL)] = L'\0';
        }
    }

    //
    // Attempt to acquire the resource, if successful, we know the
    // resource is avaiable, overwise assume it conflicts with another
    // devices resource's.
    //
    status = IoReportResourceUsage(NULL,
                                   driverObject,
                                   ResourceList,
                                   ResourceListSize,
                                   NULL,
                                   NULL,
                                   0,
                                   FALSE,
                                   &bTemp);

    if (NT_SUCCESS(status)) {
        //
        // Clear any resources that might have been assigned to my fake device.
        //
        RtlZeroMemory(&EmptyResourceList, sizeof(CM_RESOURCE_LIST));

        IoReportResourceUsage(NULL,
                              driverObject,
                              &EmptyResourceList,
                              sizeof(CM_RESOURCE_LIST),
                              NULL,
                              NULL,
                              0,
                              FALSE,
                              &bTemp);
    }


    if (status == STATUS_CONFLICTING_ADDRESSES) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;

} // PiDetectResourceConflict



NTSTATUS
PiGetInterfaceDeviceList(
    IN  GUID *InterfaceGuid,
    IN  PUNICODE_STRING DeviceInstance,
    IN  ULONG Flags,
    OUT PWSTR InterfaceList,
    IN OUT PULONG InterfaceListSize
    )

/*++

Routine Description:

    This routine is invoked to return an interface device list based on
    the specified interface device guid class and optional device instance.

Arguments:


Return Value:

    The function value is an NTSTATUS.

--*/

{
    NTSTATUS status;
    PWSTR tempBuffer = NULL;
    ULONG tempSize = 0;

    //
    // Note: This Iop routine allocates a memory buffer and store the
    // interface device list in that buffer. I need to copy it to the
    // users buffer (if any) and then free it before returning.
    //
    if (DeviceInstance->Length == 0) {
        status = IopGetDeviceInterfaces(InterfaceGuid,
                                        NULL,
                                        Flags,
                                        TRUE,    // user-mode format
                                        &tempBuffer,
                                        &tempSize
                                        );
    } else {
        status = IopGetDeviceInterfaces(InterfaceGuid,
                                        DeviceInstance,
                                        Flags,
                                        TRUE,    // user-mode format
                                        &tempBuffer,
                                        &tempSize
                                        );
    }

    if (NT_SUCCESS(status)) {

        if (InterfaceList) {
            //
            // Not just asking for the size, copy the buffer too.
            //
            if (tempSize > *InterfaceListSize) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(InterfaceList, tempBuffer, tempSize);
            }
        }

        *InterfaceListSize = tempSize;

        ExFreePool(tempBuffer);
    }

    return status;

} // PiGetInterfaceDeviceList


NTSTATUS
PiDeviceClassAssociation(
    IN PUNICODE_STRING DeviceInstance,
    IN GUID * InterfaceGuid,
    IN PUNICODE_STRING Reference,   OPTIONAL
    IN OUT LPWSTR SymbolicLink,
    IN OUT PULONG SymbolicLinkLength,
    IN BOOLEAN Register
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING tempString;

    if (Register) {
        //
        // An interface GUID and device instance are required to register a
        // symbolic link.
        //
        if (!ARGUMENT_PRESENT(InterfaceGuid)) {
            return STATUS_INVALID_PARAMETER;
        }

        if ((!ARGUMENT_PRESENT(DeviceInstance)) ||
            (DeviceInstance->Buffer == NULL) ||
            (DeviceInstance->Length == 0)) {
            return STATUS_INVALID_PARAMETER;
        }

        status = IopRegisterDeviceInterface(DeviceInstance,
                                            InterfaceGuid,
                                            Reference,
                                            TRUE,      // user-mode format
                                            &tempString
                                            );
        if (NT_SUCCESS(status)) {

            ASSERT(tempString.Buffer);

            if ((tempString.Length + sizeof(UNICODE_NULL)) <= *SymbolicLinkLength) {
                //
                // copy the returned symbolic link to user buffer
                //
                RtlCopyMemory(SymbolicLink, tempString.Buffer, tempString.Length);
                SymbolicLink[tempString.Length / sizeof(WCHAR)] = L'\0';
                *SymbolicLinkLength = tempString.Length + sizeof(UNICODE_NULL);

            } else {
                //
                // return only the length of the registered symbolic link.
                //
                *SymbolicLinkLength = tempString.Length + sizeof(UNICODE_NULL);
                status = STATUS_BUFFER_TOO_SMALL;
            }

            ExFreePool(tempString.Buffer);
        }

    } else {
        //
        // A symbolic link name is required to unregister a device interface.
        //
        if ((!ARGUMENT_PRESENT(SymbolicLink)) ||
            (!ARGUMENT_PRESENT(SymbolicLinkLength)) ||
            (*SymbolicLinkLength == 0)) {
            return STATUS_INVALID_PARAMETER;
        }

        RtlInitUnicodeString(&tempString, SymbolicLink);

        //
        // Unregister any interfaces using this symbolic link
        //
        status = IopUnregisterDeviceInterface(&tempString);
    }

    return status;

} // PiDeviceClassAssociation



NTSTATUS
PiGetRelatedDevice(
    IN  PUNICODE_STRING TargetDeviceInstance,
    OUT LPWSTR RelatedDeviceInstance,
    IN OUT PULONG RelatedDeviceInstanceLength,
    IN  ULONG Relation
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject, relatedDeviceObject;
    PDEVICE_NODE deviceNode, originalDeviceNode, relatedDeviceNode;

    PpDevNodeLockTree(PPL_SIMPLE_READ);

    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(TargetDeviceInstance);

    if (!deviceObject) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    //
    // Retrieve the devnode from the PDO
    //

    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    originalDeviceNode = deviceNode;

    if ((deviceNode->State == DeviceNodeDeleted) ||
        (deviceNode->State == DeviceNodeDeletePendingCloses)) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    switch (Relation) {
    case PNP_RELATION_PARENT:
        relatedDeviceNode = deviceNode->Parent;
        break;

    case PNP_RELATION_CHILD:
        relatedDeviceNode = deviceNode->Child;
        if (relatedDeviceNode &&
            PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_DEVICE_NOT_THERE) &&
            (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER)) {
            deviceNode = relatedDeviceNode;

            //
            // Fall through...
            //

        } else {
            break;
        }

    case PNP_RELATION_SIBLING:
        relatedDeviceNode = deviceNode->Sibling;
        while (relatedDeviceNode &&
            PipIsDevNodeProblem(relatedDeviceNode, CM_PROB_DEVICE_NOT_THERE) &&
            (relatedDeviceNode->Flags & DNF_LEGACY_DRIVER)) {
            relatedDeviceNode = relatedDeviceNode->Sibling;
        }
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        goto Clean0;
    }

    //
    // We now have what we think is the relatedDeviceNode but we need to make
    // sure that it hasn't been uninstalled or had its registry info
    // removed in some other way.  Otherwise we won't be able to find its
    // siblings.  If we can't map from its InstancePath to a PDO skip it and go
    // on to the next sibling.
    //

    if (Relation != PNP_RELATION_PARENT)  {

        PiLockPnpRegistry(FALSE);

        while (relatedDeviceNode) {
            if (relatedDeviceNode->InstancePath.Length != 0) {

                //
                // Retrieve the PDO from the device instance string.
                //

                relatedDeviceObject = IopDeviceObjectFromDeviceInstance(&relatedDeviceNode->InstancePath);

                if (relatedDeviceObject != NULL) {
                    ObDereferenceObject(relatedDeviceObject);
                    break;
                }
            }

            relatedDeviceNode = relatedDeviceNode->Sibling;
        }

        PiUnlockPnpRegistry();
    }

    if (relatedDeviceNode != NULL) {
        if (*RelatedDeviceInstanceLength > relatedDeviceNode->InstancePath.Length) {

            RtlCopyMemory(RelatedDeviceInstance,
                        relatedDeviceNode->InstancePath.Buffer,
                        relatedDeviceNode->InstancePath.Length);

            *(PWCHAR)((PUCHAR)RelatedDeviceInstance + relatedDeviceNode->InstancePath.Length) = L'\0';
            *RelatedDeviceInstanceLength = relatedDeviceNode->InstancePath.Length;
        } else {
            *RelatedDeviceInstanceLength = relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
            status = STATUS_BUFFER_TOO_SMALL;
        }
    } else {
        status = STATUS_NO_SUCH_DEVICE;
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    if (deviceObject) {
        ObDereferenceObject(deviceObject);
    }

    return status;

} // PiGetRelatedDevice


NTSTATUS
PiQueryDeviceRelations(
    IN PUNICODE_STRING DeviceInstance,
    IN PNP_QUERY_RELATION Operation,
    OUT PULONG BufferLength,
    OUT LPWSTR Buffer
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;
    PDEVICE_NODE deviceNode, relatedDeviceNode;
    IO_STACK_LOCATION irpSp;
    PDEVICE_RELATIONS deviceRelations = NULL;
    DEVICE_RELATION_TYPE relationType;
    ULONG length = 0, i;
    ULONG maxCount, currentCount;
    LPWSTR pBuffer;

    //
    // Map the private operation code into a DEVICE_RELATION_TYPE enum value.
    //

    relationType = PiDeviceRelationType(Operation);
    if (relationType == (ULONG)-1) {

        return STATUS_INVALID_PARAMETER;
    }

    PpDevNodeLockTree(PPL_SIMPLE_READ);

    //
    // Retrieve the device object from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);

    if (!deviceObject) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    deviceNode = deviceObject->DeviceObjectExtension->DeviceNode;

    ASSERT(deviceNode != NULL);

    //
    // We don't want to bother with things not in the tree...
    //
    if ((deviceNode->State == DeviceNodeDeletePendingCloses) ||
        (deviceNode->State == DeviceNodeDeleted)) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    if (relationType == BusRelations) {

        //
        // Querying the bus relations from the FDO has side effects.  Besides
        // we are really interested in the current relations, not those that
        // may be appearing or disappearing.
        //

        //
        // Walk the bus relations list counting the number of children
        //
        maxCount = 0;

        for (relatedDeviceNode = deviceNode->Child;
             relatedDeviceNode != NULL;
             relatedDeviceNode = relatedDeviceNode->Sibling) {

            maxCount++;
        }

        deviceRelations = ExAllocatePool( PagedPool,
                                          sizeof(DEVICE_RELATIONS) +
                                          maxCount * sizeof(PDEVICE_OBJECT));

        if (deviceRelations != NULL) {

            deviceRelations->Count = maxCount;

            currentCount = 0;

            //
            // Walk the bus relations list counting the number of relations.
            // Note that we carefully take into account that legacy devnodes
            // can be added to the root totally asynchronously!
            //
            for (relatedDeviceNode = deviceNode->Child;
                 ((relatedDeviceNode != NULL) && (currentCount < maxCount));
                 relatedDeviceNode = relatedDeviceNode->Sibling) {

                ObReferenceObject(relatedDeviceNode->PhysicalDeviceObject);

                deviceRelations->Objects[currentCount++] =
                    relatedDeviceNode->PhysicalDeviceObject;
            }

            ASSERT(currentCount == deviceRelations->Count);
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        //
        // Initialize the stack location to pass to IopSynchronousCall()
        //

        RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

        //
        // Query the device's relations.
        //

        irpSp.MajorFunction = IRP_MJ_PNP_POWER;
        irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
        irpSp.Parameters.QueryDeviceRelations.Type = relationType;
        status = IopSynchronousCall(deviceObject, &irpSp, (PULONG_PTR)&deviceRelations);

        if (!NT_SUCCESS(status)) {
            deviceRelations = NULL;
        }
    }
    //
    // Convert these relation device objects into a multisz list of device instances
    //

    if (deviceRelations && (deviceRelations->Count > 0)) {
        pBuffer = Buffer;
        length = sizeof(UNICODE_NULL);     // account for that last extra trailing null
        for (i = 0; i < deviceRelations->Count; i++) {

            relatedDeviceNode = deviceRelations->Objects[i]->DeviceObjectExtension->DeviceNode;

            //
            // The devnode might be NULL if:
            // 1) A driver make a mistake
            // 2) We got back a removal/ejection relation on a newly created
            //    PDO that hasn't made it's way back up to the OS (we don't
            //    raise the tree lock to BlockReads while an enumeration
            //    IRP is outstanding...)
            //
            if (relatedDeviceNode) {

                if (pBuffer) {

                    //
                    // We're retrieving the device instance strings (not just determining
                    // required buffer size). Validate buffer size (including room for
                    // null terminator).
                    //
                    if (*BufferLength < length + relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL)) {

                        //
                        // ADRIAO ISSUE 02/06/2001 -
                        //     We aren't returning the proper length here. We
                        // need to continue on, copying nothing more yet
                        // continuing to calculate the length. This should be
                        // fixed this in XP+1, once we have time to verify no
                        // one will get an app compat break.
                        //
                        status = STATUS_BUFFER_TOO_SMALL;
                        goto Clean0;
                    }

                    //
                    // Copy this device instance over to the buffer, null terminate it, and
                    // update the length used in the buffer so far.
                    //

                    RtlCopyMemory(pBuffer,
                                  relatedDeviceNode->InstancePath.Buffer,
                                  relatedDeviceNode->InstancePath.Length);

                    pBuffer += relatedDeviceNode->InstancePath.Length / sizeof(UNICODE_NULL);
                    *pBuffer++ = L'\0';   // always need the single-term
                }

                length += relatedDeviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
            }

            ObDereferenceObject(deviceRelations->Objects[i]);
        }
        if (pBuffer) {

            *pBuffer = L'\0';   // This is the last, double-term
        }
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    if (NT_SUCCESS(status)) {
        *BufferLength = length;
    } else {
        *BufferLength = 0;
    }

    if (deviceRelations) {
        ExFreePool(deviceRelations);
    }

    if (deviceObject) {
        ObDereferenceObject(deviceObject);
    }

    return status;

} // PiQueryDeviceRelations



DEVICE_RELATION_TYPE
PiDeviceRelationType(
    PNP_QUERY_RELATION  Operation
    )

/*++

Routine Description:

    This private routine converts the PNP_QUERY_RELATION enum value into a
    DEVICE_RELATION_TYPE enum value. User-mode and kernel-mode both know about
    PNP_QUERY_RELATION but only kernel-mode knows about DEVICE_RELATION_TYPE.

Arguments:

    Operation - Specifies a PNP_QUERY_RELATION enum value


Return Value:

    The function returns a DEVICE_RELATION_TYPE enum value.

--*/
{
    switch (Operation) {
    case PnpQueryEjectRelations:
        return EjectionRelations;

    case PnpQueryRemovalRelations:
        return RemovalRelations;

    case PnpQueryPowerRelations:
        return PowerRelations;

    case PnpQueryBusRelations:
        return BusRelations;

    default:
        return (ULONG)-1;
    }

} // PiDeviceRelationType



VOID
PiControlGetUserFlagsFromDeviceNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT ULONG          *StatusFlags
    )
/*++

Routine Description:

    This private routine converts the DeviceNode's state into the
    corresponding user-mode StatusFlags.

Arguments:

    DeviceNode - Specifies the DeviceNode get retrieve user flags for.

    StatusFlags - Receives the corresponding user-mode status flags.

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    ULONG returnedFlags;

    //
    // Convert DNF_Xxx flags to the appropriate status and problem values.
    // With problems, order is important since we only keep track of a single
    // problem (use the most recent problem that occured if possible).
    //

    returnedFlags = (DN_NT_DRIVER | DN_NT_ENUMERATOR);

    if (PipAreDriversLoaded(DeviceNode)) {
        returnedFlags |= DN_DRIVER_LOADED;
    }

    if (PipIsDevNodeDNStarted(DeviceNode)) {
        returnedFlags |= DN_STARTED;
    }

    if (DeviceNode->UserFlags & DNUF_WILL_BE_REMOVED) {
        returnedFlags |= DN_WILL_BE_REMOVED;
    }

    if (DeviceNode->UserFlags & DNUF_DONT_SHOW_IN_UI) {
        returnedFlags |= DN_NO_SHOW_IN_DM;
    }

    if (DeviceNode->UserFlags & DNUF_NEED_RESTART) {
        returnedFlags |= DN_NEED_RESTART;
    }

    if (DeviceNode->Flags & DNF_HAS_PRIVATE_PROBLEM) {
        returnedFlags |= DN_PRIVATE_PROBLEM;
    }

    if (DeviceNode->Flags & DNF_HAS_PROBLEM) {
        returnedFlags |= DN_HAS_PROBLEM;
    }

    if ((DeviceNode->Flags & DNF_DRIVER_BLOCKED)) {
        returnedFlags |= DN_DRIVER_BLOCKED;
    }

    if ((DeviceNode->Flags & DNF_LEGACY_DRIVER)) {
        returnedFlags |= DN_LEGACY_DRIVER;
    }

    if ((DeviceNode->Flags & DNF_CHILD_WITH_INVALID_ID)) {
        returnedFlags |= DN_CHILD_WITH_INVALID_ID;
    }

    if (DeviceNode->DisableableDepends == 0) {
        //
        // if there's no reason for us not to be disableable, flag we are disableable
        //
        returnedFlags |= DN_DISABLEABLE;
    }

    //
    // DN_ROOT_ENUMERATED is currently set on umpnpmgr side based on device
    // instance name.  We should be able to simply set this flag
    // based on the devnode's LevelNumber except that we don't want BIOS
    // enumerated devices to have the DN_ROOT_ENUMERATED flag even though they
    // are being enumerated by the root enumerator.
    //

    // DN_REMOVABLE - set on umpnpmgr side based on capabilities bits
    // DN_MANUAL - set on umpnpmgr side based on CONFIGFLAG_MANUAL_INSTALL bit.
    // DN_NO_WAIT_INSTALL ???

    *StatusFlags = returnedFlags;
}

VOID
PpShutdownSystem (
    IN BOOLEAN Reboot,
    IN ULONG Phase,
    IN OUT PVOID *Context
    )

/*++

Routine Description:

    This routine invokes real code to performs Pnp shutdown preparation.
    This is nonpage code and that's why it is so small.

Arguments:

    Reboot - specifies if the system is going to reboot.

    Phase - specifies the shutdown phase.

    Context - at phase 0, it supplies a variable to receive the returned context info.
              at phase 1, it supplies a variable to specify the context info.

Return Value:

    None.

--*/

{
#if defined(_X86_)
    if (Reboot) {
        PnPBiosShutdownSystem(Phase, Context);
    }
#else
    UNREFERENCED_PARAMETER( Reboot );
    UNREFERENCED_PARAMETER( Phase );
    UNREFERENCED_PARAMETER( Context );
#endif
}


NTSTATUS
PiQueueDeviceRequest(
    IN PUNICODE_STRING      DeviceInstance,
    IN DEVICE_REQUEST_TYPE  RequestType,
    IN ULONG                Flags,
    IN BOOLEAN              Synchronous
    )
{
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    KEVENT completionEvent;
    NTSTATUS status;

    deviceObject = IopDeviceObjectFromDeviceInstance(DeviceInstance);

    if (!deviceObject) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    if (Synchronous) {
        KeInitializeEvent( &completionEvent, NotificationEvent, FALSE );
    }

    status = PipRequestDeviceAction( deviceObject,
                                     RequestType,
                                     FALSE,
                                     Flags,
                                     Synchronous ? &completionEvent : NULL,
                                     NULL );

    if (NT_SUCCESS(status) && Synchronous) {

        status = KeWaitForSingleObject( &completionEvent,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
    }

Clean0:

    if (deviceObject != NULL) {
        ObDereferenceObject( deviceObject );
    }

    return status;
}


NTSTATUS
PiControlStartDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine starts the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlStartDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be started.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlStartDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (NT_SUCCESS(status)) {
        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
            &instance,
            StartDevice,
            0,
            TRUE
            );
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}


NTSTATUS
PiControlResetDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine "resets" a devnode, which means bringing it out of the removed
    state without actually starting it.

Arguments:

    PnPControlClass - Should be PlugPlayControlResetDevice

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        DeviceControlData->DeviceInstance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (NT_SUCCESS(status)) {
        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
            &instance,
            ResetDevice,
            0,
            TRUE
            );

        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }
    return status;
}


NTSTATUS
PiControlInitializeDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine initializes the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlInitializeDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be initialized.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlInitializeDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        status = PiInitializeDevice(&instance);
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}


NTSTATUS
PiControlDeregisterDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine deregisters the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlDeregisterDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be deregistered.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlDeregisterDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (NT_SUCCESS(status)) {
        //
        // Acquire PnP device-specific registry resource for exclusive (read/write) access.
        //
        PiLockPnpRegistry(TRUE);

        status = PiDeviceRegistration(&instance,
                                      FALSE,
                                      NULL
                                      );
        if (NT_SUCCESS(status)) {
            //
            // Remove all interfaces to this device.
            //
            IopRemoveDeviceInterfaces(&instance);
        }

        PiUnlockPnpRegistry();
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}

NTSTATUS
PiControlRegisterNewDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine registers the specified device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlRegisterNewDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be registered.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlRegisterNewDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (NT_SUCCESS(status)) {

        status = PpDeviceRegistration(
            &instance,
            TRUE,
            NULL
            );
        //
        // Free the copy of user mode supplied DeviceInstance.
        //
        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }

    return status;
}

NTSTATUS
PiControlEnumerateDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to queue reenumeration of the specified device.

Arguments:

    PnPControlClass - Should be PlugPlayControlEnumerateDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be reenumerated.

        Flags - Specifies type of reenumeration.  The following flags are
                currently defined:

          PNP_ENUMERATE_DEVICE_ONLY - Specifies shallow re-enumeration of
                specified device.  If not specified, perfoms reenumeration of
                the entire device subtree rooted at the specified device.

          PNP_ENUMERATE_ASYNCHRONOUS - Specifies that the re-enumeration should
                be done asynchronously.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlEnumerateDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));

    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Queue a request to enumerate the device
    //
    status = PiQueueDeviceRequest(
        &instance,
        (DeviceControlData->Flags & PNP_ENUMERATE_DEVICE_ONLY)  ? ReenumerateDeviceOnly : ReenumerateDeviceTree,
        0,
        (DeviceControlData->Flags & PNP_ENUMERATE_ASYNCHRONOUS) ? FALSE : TRUE
        );
    //
    // Free the copy of user mode supplied DeviceInstance.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    return status;
}


NTSTATUS
PiControlQueryAndRemoveDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA  QueryAndRemoveData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to queue query removal of the specified device.

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryAndRemoveDevice.

    DeviceControlData - Points to buffer describing the operation.

        DeviceInstance - Specifies the device instance to be query removed.

        VetoType - Vetotype for query remove failure.

        VetoName - Veto information for query remove failure.

        VetoNameLength - Length of VetoName buffer.

        Flags - Remove specific flags.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR  vetoName;
    ULONG   vetoNameLength;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlQueryAndRemoveDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA));

    vetoName = NULL;
    PiWstrToUnicodeString(&instance, NULL);
    //
    // Check if the caller wants veto information or not.
    //
    if (QueryAndRemoveData->VetoNameLength && QueryAndRemoveData->VetoName) {

        vetoNameLength = QueryAndRemoveData->VetoNameLength * sizeof(WCHAR);
    } else {

        QueryAndRemoveData->VetoNameLength = vetoNameLength = 0;
    }
    //
    // Allocate our own buffer for veto information for user mode callers,
    // otherwise use the supplied one.
    //
    status = PiControlAllocateBufferForUserModeCaller(
        &vetoName,
        vetoNameLength,
        CallerMode,
        QueryAndRemoveData->VetoName
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Make a copy of caller supplied DeviceInstance.
    //
    instance.Length = instance.MaximumLength = QueryAndRemoveData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        QueryAndRemoveData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Queue an event to query remove the device
    //
    status = PiQueueQueryAndRemoveEvent(
        &instance,
        &QueryAndRemoveData->VetoType,
        vetoName,
        &vetoNameLength,
        QueryAndRemoveData->Flags
        );
    if (vetoName) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &QueryAndRemoveData->VetoName,
            vetoName,
            QueryAndRemoveData->VetoNameLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    QueryAndRemoveData->VetoNameLength = vetoNameLength / sizeof(WCHAR);
    //
    // Free vetoName buffer if we allocate one on behalf of user mode caller.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, vetoName);

    return status;
}

NTSTATUS
PiControlUserResponse(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_USER_RESPONSE_DATA UserResponseData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine is used to accept user mode response.

Arguments:

    PnPControlClass - Should be PlugPlayControlUserResponse.

    UserResponseData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status;
    PWCHAR vetoName;
    ULONG vetoNameLength;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlUserResponse);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_USER_RESPONSE_DATA));

    if (UserResponseData->VetoNameLength && UserResponseData->VetoName) {

        vetoNameLength = UserResponseData->VetoNameLength * sizeof(WCHAR);
    } else {

        vetoNameLength = 0;
    }
    //
    // Make a copy of callers buffer.
    //
    status = PiControlMakeUserModeCallersCopy(
        &vetoName,
        UserResponseData->VetoName,
        vetoNameLength,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }
    //
    // Copy the user response.
    //
    PiUserResponse(
        UserResponseData->Response,
        UserResponseData->VetoType,
        vetoName,
        vetoNameLength
        );

    PiControlFreeUserModeCallersBuffer(CallerMode, vetoName);

    return STATUS_SUCCESS;
}

NTSTATUS
PiControlGenerateLegacyDevice(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA LegacyDevGenData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine is used to generate legacy device instance.

Arguments:

    PnPControlClass - Should be PlugPlayControlGenerateLegacyDevice.

    UserResponseData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING service;
    ULONG instanceLength;
    PWCHAR instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlGenerateLegacyDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA));

    instance = NULL;
    PiWstrToUnicodeString(&service, NULL);
    instanceLength = LegacyDevGenData->DeviceInstanceLength * sizeof(WCHAR);
    status = PiControlAllocateBufferForUserModeCaller(
        &instance,
        instanceLength,
        CallerMode,
        LegacyDevGenData->DeviceInstance
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    service.Length = service.MaximumLength = LegacyDevGenData->ServiceName.Length;
    status = PiControlMakeUserModeCallersCopy(
        &service.Buffer,
        LegacyDevGenData->ServiceName.Buffer,
        service.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGenerateLegacyDeviceInstance(
        &service,
        instance,
        &instanceLength
        );
    //
    // Copy the instance and length to the callers buffer.
    //
    if (instance) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &LegacyDevGenData->DeviceInstance,
            instance,
            LegacyDevGenData->DeviceInstanceLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    LegacyDevGenData->DeviceInstanceLength = instanceLength / sizeof(WCHAR);
    //
    // Release any allocated storage.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, service.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance);

    return status;
}

NTSTATUS
PiControlGetInterfaceDeviceList(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_LIST_DATA    InterfaceData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get devices with specified interface.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetInterfaceDeviceList.

    InterfaceData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR list;
    ULONG listSize;
    GUID *guid;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlGetInterfaceDeviceList);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));

    list = NULL;
    guid = NULL;
    PiWstrToUnicodeString(&instance, NULL);
    //
    // For user mode callers, allocate storage to retrieve the interfacelist.
    //
    if (InterfaceData->InterfaceListSize && InterfaceData->InterfaceList) {

        listSize = InterfaceData->InterfaceListSize * sizeof(WCHAR);
    } else {

        listSize = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
        &list,
        listSize,
        CallerMode,
        InterfaceData->InterfaceList
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Copy the user supplied interface GUID.
    //
    status = PiControlMakeUserModeCallersCopy(
        &guid,
        InterfaceData->InterfaceGuid,
        sizeof(GUID),
        sizeof(UCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    //
    // Copy the user supplied DeviceInstance.
    //
    if (InterfaceData->DeviceInstance.Buffer) {

        instance.Length = instance.MaximumLength = InterfaceData->DeviceInstance.Length;
        status = PiControlMakeUserModeCallersCopy(
            &instance.Buffer,
            InterfaceData->DeviceInstance.Buffer,
            instance.Length,
            sizeof(WCHAR),
            CallerMode,
            TRUE
            );
        if (!NT_SUCCESS(status)) {

            goto Clean0;
        }
    }
    //
    // Get the interface list.
    //
    status = PiGetInterfaceDeviceList(
        guid,
        &instance,
        InterfaceData->Flags,
        list,
        &listSize
        );
    if (list) {
        //
        // Copy the results into the caller's buffer.
        //
        tempStatus = PiControlMakeUserModeCallersCopy(
            &InterfaceData->InterfaceList,
            list,
            InterfaceData->InterfaceListSize * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    InterfaceData->InterfaceListSize = listSize / sizeof(WCHAR);
    //
    // Clean up.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, list);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);

    return status;
}

NTSTATUS
PiControlGetPropertyData(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_PROPERTY_DATA  PropertyData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine is used to get specified property data.

Arguments:

    PnPControlClass - Should be PlugPlayControlProperty.

    PropertyData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    PVOID buffer;
    ULONG bufferSize;
    DEVICE_REGISTRY_PROPERTY property;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlProperty);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA));

    buffer = NULL;
    instance.Length = instance.MaximumLength = PropertyData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        PropertyData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Retrieve the physical device object that corresponds to this devinst
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (!deviceObject) {

        PpDevNodeUnlockTree(PPL_SIMPLE_READ);
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Retrieve the device node for this device object.
    //
    deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    if (!deviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    bufferSize = PropertyData->BufferSize;
    status = PiControlAllocateBufferForUserModeCaller(
        &buffer,
        bufferSize,
        CallerMode,
        PropertyData->Buffer
        );

    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }

    switch(PropertyData->PropertyType) {

        case PNP_PROPERTY_PDONAME:
            property = DevicePropertyPhysicalDeviceObjectName;
            break;

        case PNP_PROPERTY_BUSTYPEGUID:
            property = DevicePropertyBusTypeGuid;
            break;

        case PNP_PROPERTY_LEGACYBUSTYPE:
            property = DevicePropertyLegacyBusType;
            break;

        case PNP_PROPERTY_BUSNUMBER:
            property = DevicePropertyBusNumber;
            break;

        case PNP_PROPERTY_ADDRESS:
            property = DevicePropertyAddress;
            break;

        case PNP_PROPERTY_POWER_DATA:
            status = PiControlGetDevicePowerData(
                deviceNode,
                CallerMode,
                bufferSize,
                buffer,
                &PropertyData->BufferSize
                );
            if (status == STATUS_BUFFER_OVERFLOW) {

                //
                // See comment in NtPlugPlayControl.
                //
                status = STATUS_BUFFER_TOO_SMALL;
            }
            goto Clean0;

        case PNP_PROPERTY_REMOVAL_POLICY:
            property = DevicePropertyRemovalPolicy;
            break;

        case PNP_PROPERTY_REMOVAL_POLICY_OVERRIDE:

            status = PiGetDeviceRegistryProperty(
                deviceObject,
                REG_DWORD,
                REGSTR_VALUE_REMOVAL_POLICY,
                NULL,
                buffer,
                &PropertyData->BufferSize
                );

            goto Clean0;

        case PNP_PROPERTY_REMOVAL_POLICY_HARDWARE_DEFAULT:

            if (bufferSize >= sizeof(ULONG)) {

                PpHotSwapGetDevnodeRemovalPolicy(
                    deviceNode,
                    FALSE, // Include Registry Override
                    (PDEVICE_REMOVAL_POLICY) buffer
                    );

                status = STATUS_SUCCESS;
            } else {

                status = STATUS_BUFFER_TOO_SMALL;
            }

            PropertyData->BufferSize = sizeof(ULONG);

            goto Clean0;

        case PNP_PROPERTY_INSTALL_STATE:
            property = DevicePropertyInstallState;
            break;

        default:
            status = STATUS_INVALID_PARAMETER;
            property = DevicePropertyInstallState;  // satisfy W4 compiler
            break;
    }
    if (NT_SUCCESS(status)) {

        status = IoGetDeviceProperty( deviceObject,
                                      property,
                                      bufferSize,
                                      buffer,
                                      &PropertyData->BufferSize
                                      );
    }

Clean0:

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    ObDereferenceObject(deviceObject);

    tempStatus = PiControlMakeUserModeCallersCopy(
        &PropertyData->Buffer,
        buffer,
        bufferSize,
        sizeof(UCHAR),
        CallerMode,
        FALSE
        );
    if (!NT_SUCCESS(tempStatus)) {

        status = tempStatus;
    }
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);

    return status;
}

NTSTATUS
PiControlDeviceClassAssociation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA AssociationData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get device class association.

Arguments:

    PnPControlClass - Should be PlugPlayControlDeviceClassAssociation.

    AssociationData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    GUID *guid;
    PWCHAR buffer;
    ULONG symLinkLength;
    PWCHAR symLink;
    UNICODE_STRING instance, reference;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlDeviceClassAssociation);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));

    symLink = NULL;
    guid = NULL;

    PiWstrToUnicodeString(&instance, NULL);
    PiWstrToUnicodeString(&reference, NULL);

    if (AssociationData->SymLinkLength && AssociationData->SymLink) {
        symLinkLength = AssociationData->SymLinkLength * sizeof(WCHAR);
    } else {
        symLinkLength = 0;
    }

    if (AssociationData->Register) {
        //
        // If registering a device interface, allocate a buffer that is the same
        // size as the one supplied by the caller.
        //
        status = PiControlAllocateBufferForUserModeCaller(
            &symLink,
            symLinkLength,
            CallerMode,
            AssociationData->SymLink
            );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        //
        // Copy the user supplied interface GUID, DeviceInstance and Reference.
        //
        status = PiControlMakeUserModeCallersCopy(
            &guid,
            AssociationData->InterfaceGuid,
            AssociationData->InterfaceGuid ? sizeof(GUID) : 0,
            sizeof(UCHAR),
            CallerMode,
            TRUE
            );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        instance.Length = instance.MaximumLength = AssociationData->DeviceInstance.Length;
        status = PiControlMakeUserModeCallersCopy(
            &instance.Buffer,
            AssociationData->DeviceInstance.Buffer,
            AssociationData->DeviceInstance.Length,
            sizeof(WCHAR),
            CallerMode,
            TRUE
            );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        reference.Length = reference.MaximumLength = AssociationData->Reference.Length;
        status = PiControlMakeUserModeCallersCopy(
            &reference.Buffer,
            AssociationData->Reference.Buffer,
            AssociationData->Reference.Length,
            sizeof(WCHAR),
            CallerMode,
            TRUE
            );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

    } else {
        //
        // If unregistering a device interface, allocate and copy only the
        // symbolic link path supplied by the caller.  Interface GUID,
        // DeviceInstance, and Reference are not required for unregistration.
        //
        if (symLinkLength < sizeof(UNICODE_NULL)) {
            status = STATUS_INVALID_PARAMETER;
            goto Clean0;
        }

        status = PiControlMakeUserModeCallersCopy(
            &symLink,
            AssociationData->SymLink,
            symLinkLength,
            sizeof(WCHAR),
            CallerMode,
            TRUE
            );
        if (!NT_SUCCESS(status)) {
            goto Clean0;
        }

        //
        // Make sure the user-supplied buffer is NULL terminated, (the length
        // supplied must reflect that).
        //
        symLink[(symLinkLength - sizeof(UNICODE_NULL)) / sizeof(WCHAR)] = L'\0';
    }

    //
    // Register or unregister the device class association.
    //
    status = PiDeviceClassAssociation(
        &instance,
        guid,
        &reference,
        symLink,
        &symLinkLength,
        AssociationData->Register
        );

    //
    // If a symbolic link was registered, copy the symbolic link name to the
    // caller's buffer.
    //
    if (AssociationData->Register && symLink && NT_SUCCESS(status)) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &AssociationData->SymLink,
            symLink,
            AssociationData->SymLinkLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {
            status = tempStatus;
        }
    }

    //
    // Return the size of the symbolic link name, in characters.
    //
    AssociationData->SymLinkLength = symLinkLength / sizeof(WCHAR);

Clean0:
    //
    // Clean up.
    //
    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, symLink);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, reference.Buffer);

    return status;
}

NTSTATUS
PiControlGetRelatedDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RELATED_DEVICE_DATA    RelatedData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get a related device.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetRelatedDevice.

    RelatedData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    PWCHAR buffer;
    ULONG length;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlGetRelatedDevice);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));

    buffer = NULL;
    PiWstrToUnicodeString(&instance, NULL);
    if (RelatedData->RelatedDeviceInstance && RelatedData->RelatedDeviceInstanceLength) {

        length = RelatedData->RelatedDeviceInstanceLength * sizeof(WCHAR);
    } else {

        length = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
        &buffer,
        length,
        CallerMode,
        RelatedData->RelatedDeviceInstance
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    instance.Length = instance.MaximumLength = RelatedData->TargetDeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        RelatedData->TargetDeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGetRelatedDevice(
        &instance,
        buffer,
        &length,
        RelatedData->Relation
        );
    if (buffer) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &RelatedData->RelatedDeviceInstance,
            buffer,
            RelatedData->RelatedDeviceInstanceLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    RelatedData->RelatedDeviceInstanceLength = length / sizeof(WCHAR);
    //
    // Release any allocated storage.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);

    return status;
}

NTSTATUS
PiControlGetInterfaceDeviceAlias(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA   InterfaceAliasData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is used to get alias for device interface.

Arguments:

    PnPControlClass - Should be PlugPlayControlGetInterfaceDeviceAlias.

    InterfaceAliasData - Points to buffer describing the operation.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    NTSTATUS status, tempStatus;
    PWCHAR alias;
    UNICODE_STRING linkName;
    GUID *guid;
    ULONG aliasLength;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlGetInterfaceDeviceAlias);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA));

    alias = NULL;
    guid = NULL;
    PiWstrToUnicodeString(&linkName, NULL);
    if (InterfaceAliasData->AliasSymbolicLinkName && InterfaceAliasData->AliasSymbolicLinkNameLength) {

        aliasLength = InterfaceAliasData->AliasSymbolicLinkNameLength * sizeof(WCHAR);
    } else {

        aliasLength = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
        &alias,
        aliasLength,
        CallerMode,
        InterfaceAliasData->AliasSymbolicLinkName
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlMakeUserModeCallersCopy(
        &guid,
        InterfaceAliasData->AliasClassGuid,
        sizeof(GUID),
        sizeof(UCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    linkName.Length = linkName.MaximumLength = InterfaceAliasData->SymbolicLinkName.Length;
    status = PiControlMakeUserModeCallersCopy(
        &linkName.Buffer,
        InterfaceAliasData->SymbolicLinkName.Buffer,
        linkName.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiGetInterfaceDeviceAlias(
        &linkName,
        guid,
        alias,
        &aliasLength
        );
    if (alias) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &InterfaceAliasData->AliasSymbolicLinkName,
            alias,
            InterfaceAliasData->AliasSymbolicLinkNameLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    InterfaceAliasData->AliasSymbolicLinkNameLength = aliasLength / sizeof(WCHAR);
    //
    // Release any allocated storage.
    //
Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, alias);
    PiControlFreeUserModeCallersBuffer(CallerMode, guid);
    PiControlFreeUserModeCallersBuffer(CallerMode, linkName.Buffer);

    return status;
}


NTSTATUS
PiControlGetSetDeviceStatus(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_STATUS_DATA    StatusData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine is used to get the cfgmgr32 status and problem values from
    the specified device instance, or to set the appropriate flags on the devnode
    so that they reflect the status and problem values (used by CM_Set_DevNode_Status).

Arguments:

    PnPControlClass - Should be PlugPlayControlDeviceStatus.

    StatusData - Points to buffer describing the operation.

        PNP_GET_STATUS:

            DeviceInstance - specifies the device instance name of the devnode
                             to return status information for.

            Status - returns the current devnode status.

            Problem - returns the current devnode problem (most recent).

        PNP_SET_STATUS or PNP_CLEAR_STATUS:

            DeviceInstance - specifies the device instance name of the devnode
                             whose internal flags are to be modified.

            Status - supplies the address of a variable containing cfgmgr32
                     status flags to be translated into their DNF counterparts
                     to be set/cleared.

            Problem - supplies the address of a variable containing a cfgmgr32
                      problem value to be translated into their DNF
                      counterparts to be set/cleared.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_STATUS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    The function returns an NTSTATUS value.

--*/
{
    UNICODE_STRING instance;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    NTSTATUS status, result;
    KEVENT event;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlDeviceStatus);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_STATUS_DATA));

    instance.Length = instance.MaximumLength = StatusData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        StatusData->DeviceInstance.Buffer,
        StatusData->DeviceInstance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }

    PpDevNodeLockTree(PPL_SIMPLE_READ);

    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject != NULL) {

        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
    }

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    if (deviceObject == NULL || deviceNode == NULL ||
        deviceNode == IopRootDeviceNode) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    switch(StatusData->Operation) {

        case PNP_GET_STATUS:

            //
            // Retrieve the status from the devnode and convert it to a
            // user-mode Win95 style Problem and Status flag values.
            //
            PiControlGetUserFlagsFromDeviceNode(
                deviceNode,
                &StatusData->DeviceStatus
                );

            StatusData->DeviceProblem = deviceNode->Problem;

            status = STATUS_SUCCESS;
            break;

        case PNP_SET_STATUS:

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            status = PipRequestDeviceAction( deviceObject,
                                             SetDeviceProblem,
                                             FALSE,
                                             (ULONG_PTR) StatusData,
                                             &event,
                                             &result );

            if (NT_SUCCESS(status)) {
                status = KeWaitForSingleObject( &event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

                if (status == STATUS_WAIT_0) {

                    status = result;
                }
            }

            break;

        case PNP_CLEAR_STATUS:

            KeInitializeEvent(&event, NotificationEvent, FALSE);

            status = PipRequestDeviceAction( deviceObject,
                                             ClearDeviceProblem,
                                             FALSE,
                                             0,
                                             &event,
                                             &result );

            if (NT_SUCCESS(status)) {
                status = KeWaitForSingleObject( &event,
                                                Executive,
                                                KernelMode,
                                                FALSE,
                                                NULL);

                if (status == STATUS_WAIT_0) {

                    status = result;
                }

            }
            break;

        default:

            //
            // ISSUE - 2000/08/16 - ADRIAO: Maintain behavior?
            //     We always used to succeed anything not understood!
            //
            status = STATUS_SUCCESS;
            //status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // Release any reference to the device object before returning.
    //
Clean0:

    if (deviceObject != NULL) {
        ObDereferenceObject(deviceObject);
    }

    return status;
}


NTSTATUS
PiControlGetDeviceDepth(
    IN     PLUGPLAY_CONTROL_CLASS       PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEPTH_DATA DepthData,
    IN     ULONG                        PnPControlDataLength,
    IN     KPROCESSOR_MODE              CallerMode
    )
/*++

Routine Description:

    This routine is invoked to return the depth of a particular devnode (i.e,
    it's depth in the hierarchical devnode tree of parent-child relations).

Arguments:

    PnPControlClass - Should be PlugPlayControlGetDeviceDepth.

    DepthData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEPTH_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlGetDeviceDepth);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEPTH_DATA));

    instance.Length = instance.MaximumLength = DepthData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DepthData->DeviceInstance.Buffer,
        DepthData->DeviceInstance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        return status;
    }
    status = STATUS_NO_SUCH_DEVICE;
    //
    // Initiliaze output parameter.
    //
    DepthData->DeviceDepth = 0;

    PpDevNodeLockTree(PPL_SIMPLE_READ);

    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject) {

        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;
        if (deviceNode) {

            DepthData->DeviceDepth = deviceNode->Level;
            status = STATUS_SUCCESS;
        }
        ObDereferenceObject(deviceObject);
    }

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);

    return status;
}


NTSTATUS
PiControlQueryDeviceRelations(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA  RelationsData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is invoked to query and return the device relations of a
    particular devnode.

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryDeviceRelations.

    RelationsData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    UNICODE_STRING instance;
    ULONG length;
    PVOID buffer;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlQueryDeviceRelations);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA));

    buffer = NULL;
    PiWstrToUnicodeString(&instance, NULL);
    if (RelationsData->BufferLength && RelationsData->Buffer) {

        length = RelationsData->BufferLength * sizeof(WCHAR);
    } else {

        length = 0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
        &buffer,
        length,
        CallerMode,
        RelationsData->Buffer
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    instance.Length = instance.MaximumLength = RelationsData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        RelationsData->DeviceInstance.Buffer,
        instance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiQueryDeviceRelations(&instance,
                                    RelationsData->Operation,
                                    &length,
                                    buffer);
    if (buffer) {

        tempStatus = PiControlMakeUserModeCallersCopy(
            &RelationsData->Buffer,
            buffer,
            RelationsData->BufferLength * sizeof(WCHAR),
            sizeof(WCHAR),
            CallerMode,
            FALSE
            );
        if (!NT_SUCCESS(tempStatus)) {

            status = tempStatus;
        }
    }
    RelationsData->BufferLength  = length / sizeof(WCHAR);

Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);

    return status;
}

NTSTATUS
PiControlQueryTargetDeviceRelation(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_TARGET_RELATION_DATA   TargetData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine is invoked to query and return the target device relations of a
    particular devnode.

Arguments:

    PnPControlClass - Should be PlugPlayControlTargetDeviceRelation.

    TargetData - Points to buffer that receives the depth.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_NODE deviceNode;
    ULONG requiredLength;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlTargetDeviceRelation);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA));
    //
    // Retrieve the file object for the specified file handle.
    //
    status = ObReferenceObjectByHandle(
        TargetData->UserFileHandle,
        FILE_ANY_ACCESS,
        IoFileObjectType,
        CallerMode,
        (PVOID *)&fileObject,
        NULL
        );
    if (NT_SUCCESS(status)) {
        //
        // Now retrieve the actual target device object associate with this
        // file object.
        //
        status = IopGetRelatedTargetDevice(fileObject, &deviceNode);

        if (NT_SUCCESS(status)) {

            ASSERT(deviceNode);

            requiredLength = deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
            if (TargetData->DeviceInstanceLen >= requiredLength) {

                if (CallerMode != KernelMode) {
                    try {

                        RtlCopyMemory(
                            TargetData->DeviceInstance,
                            deviceNode->InstancePath.Buffer,
                            deviceNode->InstancePath.Length
                            );
                        *(PWCHAR)((PUCHAR)TargetData->DeviceInstance + deviceNode->InstancePath.Length) = L'\0';
                        TargetData->DeviceInstanceLen = deviceNode->InstancePath.Length;
                        status = STATUS_SUCCESS;

                    } except(PiControlExceptionFilter(GetExceptionInformation())) {

                        status = GetExceptionCode();
                        IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                                   "PiControlQueryTargetDeviceRelation: Exception copying device instance to user's buffer\n"));
                    }
                } else {

                    RtlCopyMemory(
                        TargetData->DeviceInstance,
                        deviceNode->InstancePath.Buffer,
                        deviceNode->InstancePath.Length
                        );
                    *(PWCHAR)((PUCHAR)TargetData->DeviceInstance + deviceNode->InstancePath.Length) = L'\0';
                    TargetData->DeviceInstanceLen = deviceNode->InstancePath.Length;
                    status = STATUS_SUCCESS;
                }

            } else {

                TargetData->DeviceInstanceLen = requiredLength;
                status = STATUS_BUFFER_TOO_SMALL;
            }
            TargetData->DeviceInstanceLen /= sizeof(WCHAR);
            //
            // Drop the reference placed by IopGetRelatedTargetDevice.
            //
            ObDereferenceObject(deviceNode->PhysicalDeviceObject);
        }
        ObDereferenceObject(fileObject);
    }

    return status;
}

NTSTATUS
PiControlQueryConflictList(
    IN     PLUGPLAY_CONTROL_CLASS           PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_CONFLICT_DATA  ConflictData,
    IN     ULONG                            PnPControlDataLength,
    IN     KPROCESSOR_MODE                  CallerMode
    )
/*++

Routine Description:

    This routine retrieves device conflict data.

    NOTE: This routine surpasses PiDetectResourceConflict in functionality

Arguments:

    PnPControlClass - Should be PlugPlayControlQueryConflictList

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_NODE deviceNode;
    PVOID list, buffer;
    UNICODE_STRING instance;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlQueryConflictList);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_CONFLICT_DATA));
    //
    // validate buffer is sufficiently big to not return an error
    //
    if (ConflictData->ConflictBufferSize < (sizeof(PLUGPLAY_CONTROL_CONFLICT_LIST) -
                                            sizeof(PLUGPLAY_CONTROL_CONFLICT_ENTRY)) +
                                            sizeof(PLUGPLAY_CONTROL_CONFLICT_STRINGS)) {
        //
        // nope
        //
        return STATUS_BUFFER_TOO_SMALL;
    }
    list = NULL;
    buffer = NULL;
    deviceObject = NULL;
    PiWstrToUnicodeString(&instance, NULL);
    status = PiControlMakeUserModeCallersCopy(
        &list,
        ConflictData->ResourceList,
        ConflictData->ResourceListSize,
        sizeof(UCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    status = PiControlAllocateBufferForUserModeCaller(
        &buffer,
        ConflictData->ConflictBufferSize,
        CallerMode,
        ConflictData->ConflictBuffer
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }
    instance.Length = instance.MaximumLength = ConflictData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        ConflictData->DeviceInstance.Buffer,
        ConflictData->DeviceInstance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );
    if (!NT_SUCCESS(status)) {

        goto Clean0;
    }

    //
    // Preinit for failure
    //
    status = STATUS_NO_SUCH_DEVICE;

    //
    // We don't do simple reads because we want to ensure we don't send this
    // while a remove is in progress...
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Retrieve the PDO from the device instance string.
    //
    deviceObject = IopDeviceObjectFromDeviceInstance(&instance);

    if (deviceObject) {

        //
        // Retrieve the devnode from the PDO
        //
        deviceNode = (PDEVICE_NODE)deviceObject->DeviceObjectExtension->DeviceNode;

        //
        // We don't want to bother with things not in the tree, and we want to
        // skip the root.
        //
        if ((deviceNode && deviceNode != IopRootDeviceNode) &&
            (deviceNode->State != DeviceNodeDeletePendingCloses) &&
            (deviceNode->State != DeviceNodeDeleted)) {

            //
            // parameters validated
            //
            status = IopQueryConflictList(
                deviceObject,
                list,
                ConflictData->ResourceListSize,
                buffer,
                ConflictData->ConflictBufferSize,
                ConflictData->Flags
                );
            tempStatus = PiControlMakeUserModeCallersCopy(
                &ConflictData->ConflictBuffer,
                buffer,
                ConflictData->ConflictBufferSize,
                sizeof(UCHAR),
                CallerMode,
                FALSE
                );
            if (!NT_SUCCESS(tempStatus)) {

                status = tempStatus;
            }
        }
    }

    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

Clean0:

    PiControlFreeUserModeCallersBuffer(CallerMode, list);
    PiControlFreeUserModeCallersBuffer(CallerMode, buffer);
    PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    if (deviceObject) {

        ObDereferenceObject(deviceObject);
    }

    ConflictData->Status = status;
    return status;
}

NTSTATUS
PiControlRetrieveDockData(
    IN     PLUGPLAY_CONTROL_CLASS               PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA DockData,
    IN     ULONG                                PnPControlDataLength,
    IN     KPROCESSOR_MODE                      CallerMode
    )
/*++

Routine Description:

    This routine retrieves dock data.

Arguments:

    PnPControlClass - Should be PlugPlayControlRetrieveDock

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT dockDevice;
    PDEVICE_NODE deviceNode;
    ULONG requiredSize;

    PAGED_CODE();

    ASSERT(PnPControlClass == PlugPlayControlRetrieveDock);
    ASSERT(PnPControlDataLength == sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA));

    dockDevice = PpProfileRetrievePreferredDockToEject();
    if (dockDevice == NULL) {

        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }
    deviceNode = (PDEVICE_NODE)dockDevice->DeviceObjectExtension->DeviceNode;
    if (deviceNode == NULL) {

        ASSERT(deviceNode);
        status = STATUS_NO_SUCH_DEVICE;
        goto Clean0;
    }

    DockData->DeviceInstanceLength *= sizeof(WCHAR);
    requiredSize = deviceNode->InstancePath.Length + sizeof(UNICODE_NULL);
    if (DockData->DeviceInstanceLength >= requiredSize) {

        if (CallerMode != KernelMode) {

            try {

                RtlCopyMemory(
                    DockData->DeviceInstance,
                    deviceNode->InstancePath.Buffer,
                    deviceNode->InstancePath.Length
                    );
                *(PWCHAR)((PUCHAR)DockData->DeviceInstance + deviceNode->InstancePath.Length) = L'\0';
                status = STATUS_SUCCESS;

            } except(PiControlExceptionFilter(GetExceptionInformation())) {

                status = GetExceptionCode();
                IopDbgPrint((IOP_IOAPI_ERROR_LEVEL,
                           "PiControlRetrieveDockData: Exception copying dock instance to user's buffer\n"));
            }
        } else {

            RtlCopyMemory(
                DockData->DeviceInstance,
                deviceNode->InstancePath.Buffer,
                deviceNode->InstancePath.Length
                );
            *(PWCHAR)((PUCHAR)DockData->DeviceInstance + deviceNode->InstancePath.Length) = L'\0';
            status = STATUS_SUCCESS;
        }
        DockData->DeviceInstanceLength = deviceNode->InstancePath.Length;
    } else {

        DockData->DeviceInstanceLength = requiredSize;
        status = STATUS_BUFFER_TOO_SMALL;
    }

    DockData->DeviceInstanceLength /= sizeof(WCHAR);
Clean0:

    if (dockDevice) {

        ObDereferenceObject(dockDevice);
    }

    return status;
}

NTSTATUS
PiControlGetDevicePowerData(
    IN  PDEVICE_NODE        DeviceNode,
    IN  KPROCESSOR_MODE     CallerMode,
    IN  ULONG               OutputBufferLength,
    IN  PVOID               PowerDataBuffer     OPTIONAL,
    OUT ULONG              *BytesWritten
    )
/*++

Routine Description:

    This routine retrieves power information for a given devnode.

Arguments:

    DeviceNode - The device node to retrieve CM_POWER_DATA for.

    CallerMode - Processor mode of caller (UserMode/KernelMode)

    OutputBufferLength - Size of the output buffer.

    PowerDataBuffer - Points to buffer that receives the power data.

    BytesWritten - Receives the number of bytes written into the buffer.

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)
                  If the status is STATUS_BUFFER_OVERFLOW, BytesWritten isn't
                  filled with OutputBufferLength, but rather the full size of
                  the requested structure.

--*/
{
    NTSTATUS status;
    DEVICE_CAPABILITIES deviceCapabilities;
    DEVICE_POWER_STATE dState, deepestDeviceWakeState;
    SYSTEM_POWER_STATE sState;
    ULONG i;
    CM_POWER_DATA cmPowerData;

    //
    // The structure size serves as a versioning mechanism. Since we only have
    // one version of the data today, we don't have to test OutputBufferLength.
    //
    cmPowerData.PD_Size = sizeof(CM_POWER_DATA);

    *BytesWritten = 0;
    if (OutputBufferLength < sizeof(ULONG)) {

        //
        // Assume the *minimum* structure size.
        //
        *BytesWritten = cmPowerData.PD_Size;
        return STATUS_BUFFER_OVERFLOW;
    }

    status = PipQueryDeviceCapabilities(DeviceNode, &deviceCapabilities);

    if (!NT_SUCCESS(status)) {

        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Fill out the "current" power state. Nonstarted devices are said to be
    // in D3.
    //
    if (PipIsDevNodeDNStarted(DeviceNode)) {

        PoGetDevicePowerState(
            DeviceNode->PhysicalDeviceObject,
            &cmPowerData.PD_MostRecentPowerState
            );

    } else {

        cmPowerData.PD_MostRecentPowerState = PowerDeviceD3;
    }

    //
    // Fill out the power data.
    //
    cmPowerData.PD_Capabilities = PDCAP_D0_SUPPORTED | PDCAP_D3_SUPPORTED;

    if (deviceCapabilities.DeviceD1) {

        cmPowerData.PD_Capabilities |= PDCAP_D1_SUPPORTED;
    }

    if (deviceCapabilities.DeviceD2) {

        cmPowerData.PD_Capabilities |= PDCAP_D2_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD0) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D0_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD1) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D1_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD2) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D2_SUPPORTED;
    }

    if (deviceCapabilities.WakeFromD3) {

        cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D3_SUPPORTED;
    }

    if (deviceCapabilities.WarmEjectSupported) {

        cmPowerData.PD_Capabilities |= PDCAP_WARM_EJECT_SUPPORTED;
    }

    RtlCopyMemory(
        cmPowerData.PD_PowerStateMapping,
        deviceCapabilities.DeviceState,
        sizeof(cmPowerData.PD_PowerStateMapping)
        );

    cmPowerData.PD_D1Latency = deviceCapabilities.D1Latency;
    cmPowerData.PD_D2Latency = deviceCapabilities.D2Latency;
    cmPowerData.PD_D3Latency = deviceCapabilities.D3Latency;

    //
    // First examine DeviceWake, then SystemWake, and update the Wake/D-state
    // bits appropriately. This is for those older WDM 1.0 bus drivers that
    // don't bother to set the DeviceDx and WakeFromDx fields.
    //
    dState = deviceCapabilities.DeviceWake;
    for(i=0; i<2; i++) {

        switch(dState) {

            case PowerDeviceD0:
                cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D0_SUPPORTED;
                break;
            case PowerDeviceD1:
                cmPowerData.PD_Capabilities |= ( PDCAP_D1_SUPPORTED |
                                                 PDCAP_WAKE_FROM_D1_SUPPORTED );
                break;
            case PowerDeviceD2:
                cmPowerData.PD_Capabilities |= ( PDCAP_D2_SUPPORTED |
                                                 PDCAP_WAKE_FROM_D2_SUPPORTED );
                break;
            case PowerDeviceD3:
                cmPowerData.PD_Capabilities |= PDCAP_WAKE_FROM_D3_SUPPORTED;
                break;
            default:
                ASSERT(0);
            case PowerDeviceUnspecified:
                break;
        }

        if (deviceCapabilities.SystemWake != PowerSystemUnspecified) {

            dState = deviceCapabilities.DeviceState[deviceCapabilities.SystemWake];

        } else {

            dState = PowerDeviceUnspecified;
        }
    }

    //
    // Calculate the deepest D state for wake
    //
    if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D3_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD3;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D2_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD2;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D1_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD1;

    } else if (cmPowerData.PD_Capabilities & PDCAP_WAKE_FROM_D0_SUPPORTED) {

        deepestDeviceWakeState = PowerDeviceD0;

    } else {

        deepestDeviceWakeState = PowerDeviceUnspecified;
    }

    //
    // Now fill in the SystemWake field. If this field is unspecified, then we
    // should infer it from the D-state information.
    //
    sState = deviceCapabilities.SystemWake;
    if (sState != PowerSystemUnspecified) {

        //
        // The D-state for SystemWake should provide enough power to cover
        // the deepest device wake state we've found. The only reason this field
        // exists is:
        // 1) Some systems can handle WakeFromS4/S5, while most can't.
        // 2) Some systems use the S state as a proxy for describing
        //    D3Hot/D3Cold dependancies.
        //
        ASSERT(deviceCapabilities.DeviceState[sState] <= deepestDeviceWakeState);

    } else if (deepestDeviceWakeState != PowerDeviceUnspecified) {

        //
        // A system wake state wasn't specified, examine each S state and pick
        // the first one that supplies enough power to wake the system. Note
        // that we start with S3. If a driver doesn't set the SystemWake field
        // but can wake the system from D3, we do *not* assume the driver can
        // wake the system from S4 or S5.
        //
        for(sState=PowerSystemSleeping3; sState>=PowerSystemWorking; sState--) {

            if ((deviceCapabilities.DeviceState[i] != PowerDeviceUnspecified) &&
                (deviceCapabilities.DeviceState[i] <= deepestDeviceWakeState)) {

                break;
            }
        }

        //
        // If we didn't find a state, sState is PowerSystemUnspecified.
        //
    }

    cmPowerData.PD_DeepestSystemWake = sState;

    if (OutputBufferLength < cmPowerData.PD_Size) {

        if (ARGUMENT_PRESENT(PowerDataBuffer)) {

            RtlCopyMemory(PowerDataBuffer, &cmPowerData, OutputBufferLength);
        }

        *BytesWritten = cmPowerData.PD_Size;
        status = STATUS_BUFFER_OVERFLOW;

    } else {

        if (ARGUMENT_PRESENT(PowerDataBuffer)) {

            RtlCopyMemory(PowerDataBuffer, &cmPowerData, cmPowerData.PD_Size);
        }

        *BytesWritten = cmPowerData.PD_Size;
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
PiControlHaltDevice(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_DEVICE_CONTROL_DATA    DeviceControlData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine simulates a surprise remove for a given device.

Arguments:

    PnPControlClass - Should be PlugPlayControlHaltDevice

    ConflictData - Points to buffer that receives conflict data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status;
    UNICODE_STRING instance;

    instance.Length = instance.MaximumLength = DeviceControlData->DeviceInstance.Length;
    status = PiControlMakeUserModeCallersCopy(
        &instance.Buffer,
        DeviceControlData->DeviceInstance.Buffer,
        DeviceControlData->DeviceInstance.Length,
        sizeof(WCHAR),
        CallerMode,
        TRUE
        );

    if (NT_SUCCESS(status)) {

        //
        // Queue an event to start the device
        //
        status = PiQueueDeviceRequest(
            &instance,
            HaltDevice,
            DeviceControlData->Flags,
            TRUE
            );

        PiControlFreeUserModeCallersBuffer(CallerMode, instance.Buffer);
    }
    return status;
}

NTSTATUS
PiControlGetBlockedDriverData(
    IN     PLUGPLAY_CONTROL_CLASS                   PnPControlClass,
    IN OUT PPLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA    BlockedDriverData,
    IN     ULONG                                    PnPControlDataLength,
    IN     KPROCESSOR_MODE                          CallerMode
    )
/*++

Routine Description:

    This routine retrieves the information about drivers blocked from loading 
    on this boot.

Arguments:

    PnPControlClass - Should be PlugPlayControlHaltDevice

    BlockedDriverData - Points to buffer that receives blocked driver data.

    PnPControlDataLength - Should be sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA)

    CallerMode - Processor mode of caller (UserMode/KernelMode)

Return Value:

    NTSTATUS code (note: must be convertable to user-mode Win32 error)

--*/
{
    NTSTATUS status, tempStatus;
    PWCHAR buffer;

    status = PiControlAllocateBufferForUserModeCaller(
        &buffer, 
        BlockedDriverData->BufferLength, 
        CallerMode, 
        BlockedDriverData->Buffer);
    if (NT_SUCCESS(status)) {

        status = PpGetBlockedDriverList((GUID *)buffer, &BlockedDriverData->BufferLength, BlockedDriverData->Flags);

        if (NT_SUCCESS(status)) {

            tempStatus = PiControlMakeUserModeCallersCopy(
               &BlockedDriverData->Buffer,
               buffer,
               BlockedDriverData->BufferLength,
               sizeof(ULONG),
               CallerMode,
               FALSE
               );
            if (!NT_SUCCESS(tempStatus)) {

                status = tempStatus;
            }
        }
        PiControlFreeUserModeCallersBuffer(CallerMode, buffer);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppdebug.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppdebug.h

Abstract:

    This header defines debug macros for the Plug and Play subsystem.

Author:

    Adrian J. Oney (AdriaO) Sept 14, 2000.

Revision History:


--*/

//#define DBG_SCOPE 1     // Enable SOME DBG stuff on ALL builds
#define DBG_SCOPE DBG // Enable only on DBG build

/*++

    Debug output is filtered at two levels: A global level and a component
    specific level.

    Each debug output request specifies a component id and a filter level
    or mask. These variables are used to access the debug print filter
    database maintained by the system. The component id selects a 32-bit
    mask value and the level either specified a bit within that mask or is
    as mask value itself.

    If any of the bits specified by the level or mask are set in either the
    component mask or the global mask, then the debug output is permitted.
    Otherwise, the debug output is filtered and not printed.

    The component mask for filtering the debug output of this component is
    Kd_NTOSPNP_Mask and may be set via the registry or the kernel debugger.

    The global mask for filtering the debug output of all components is
    Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.

    The registry key for setting the mask value for this component is:

    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\
        Debug Print Filter\NTOSPNP

    The key "Debug Print Filter" may have to be created in order to create
    the component key.

    Pnp is divided into the following sub-components for debug spew.
        1. LOADUNLOAD: AddDevice, UnloadDriver etc
        2. RESOURCE: Allocation, rebalance etc
        3. ENUMERATION: Starts, enumerations etc
        4. IOAPI: IO APIs etc
        5. IOEVENT: IO events etc
        6. MAPPER: Firmware mapper etc
        7. PNPBIOS: PnP BIOS etc
    Each sub-component gets 5 debug levels. The error level for each component
    maps to the default error level.

 --*/

#define IOP_ERROR_LEVEL                 DPFLTR_ERROR_LEVEL
#define IOP_WARNING_LEVEL               DPFLTR_WARNING_LEVEL
#define IOP_TRACE_LEVEL                 DPFLTR_TRACE_LEVEL
#define IOP_INFO_LEVEL                  DPFLTR_INFO_LEVEL

#define IOP_LOADUNLOAD_LEVEL            (DPFLTR_INFO_LEVEL + 1)
#define IOP_RESOURCE_LEVEL              (DPFLTR_INFO_LEVEL + 5)
#define IOP_ENUMERATION_LEVEL           (DPFLTR_INFO_LEVEL + 9)
#define IOP_IOAPI_LEVEL                 (DPFLTR_INFO_LEVEL + 13)
#define IOP_IOEVENT_LEVEL               (DPFLTR_INFO_LEVEL + 17)
#define IOP_MAPPER_LEVEL                (DPFLTR_INFO_LEVEL + 21)
#define IOP_PNPBIOS_LEVEL               (DPFLTR_INFO_LEVEL + 25)

//
// All error levels map to the default error level.
//
#define IOP_LOADUNLOAD_ERROR_LEVEL      DPFLTR_ERROR_LEVEL
#define IOP_RESOURCE_ERROR_LEVEL        DPFLTR_ERROR_LEVEL
#define IOP_ENUMERATION_ERROR_LEVEL     DPFLTR_ERROR_LEVEL
#define IOP_IOAPI_ERROR_LEVEL           DPFLTR_ERROR_LEVEL
#define IOP_IOEVENT_ERROR_LEVEL         DPFLTR_ERROR_LEVEL
#define IOP_MAPPER_ERROR_LEVEL          DPFLTR_ERROR_LEVEL
#define IOP_PNPBIOS_ERROR_LEVEL         DPFLTR_ERROR_LEVEL
//
// Component sublevels are based off the component base level.
//
#define IOP_LOADUNLOAD_WARNING_LEVEL    (IOP_LOADUNLOAD_LEVEL + 0)
#define IOP_LOADUNLOAD_TRACE_LEVEL      (IOP_LOADUNLOAD_LEVEL + 1)
#define IOP_LOADUNLOAD_INFO_LEVEL       (IOP_LOADUNLOAD_LEVEL + 2)
#define IOP_LOADUNLOAD_VERBOSE_LEVEL    (IOP_LOADUNLOAD_LEVEL + 3)

#define IOP_RESOURCE_WARNING_LEVEL      (IOP_RESOURCE_LEVEL + 0)
#define IOP_RESOURCE_TRACE_LEVEL        (IOP_RESOURCE_LEVEL + 1)
#define IOP_RESOURCE_INFO_LEVEL         (IOP_RESOURCE_LEVEL + 2)
#define IOP_RESOURCE_VERBOSE_LEVEL      (IOP_RESOURCE_LEVEL + 3)

#define IOP_ENUMERATION_WARNING_LEVEL   (IOP_ENUMERATION_LEVEL + 0)
#define IOP_ENUMERATION_TRACE_LEVEL     (IOP_ENUMERATION_LEVEL + 1)
#define IOP_ENUMERATION_INFO_LEVEL      (IOP_ENUMERATION_LEVEL + 2)
#define IOP_ENUMERATION_VERBOSE_LEVEL   (IOP_ENUMERATION_LEVEL + 3)

#define IOP_IOAPI_WARNING_LEVEL         (IOP_IOAPI_LEVEL + 0)
#define IOP_IOAPI_TRACE_LEVEL           (IOP_IOAPI_LEVEL + 1)
#define IOP_IOAPI_INFO_LEVEL            (IOP_IOAPI_LEVEL + 2)
#define IOP_IOAPI_VERBOSE_LEVEL         (IOP_IOAPI_LEVEL + 3)

#define IOP_IOEVENT_WARNING_LEVEL       (IOP_IOEVENT_LEVEL + 0)
#define IOP_IOEVENT_TRACE_LEVEL         (IOP_IOEVENT_LEVEL + 1)
#define IOP_IOEVENT_INFO_LEVEL          (IOP_IOEVENT_LEVEL + 2)
#define IOP_IOEVENT_VERBOSE_LEVEL       (IOP_IOEVENT_LEVEL + 3)

#define IOP_MAPPER_WARNING_LEVEL        (IOP_MAPPER_LEVEL + 0)
#define IOP_MAPPER_TRACE_LEVEL          (IOP_MAPPER_LEVEL + 1)
#define IOP_MAPPER_INFO_LEVEL           (IOP_MAPPER_LEVEL + 2)
#define IOP_MAPPER_VERBOSE_LEVEL        (IOP_MAPPER_LEVEL + 3)

#define IOP_PNPBIOS_WARNING_LEVEL       (IOP_PNPBIOS_LEVEL + 0)
#define IOP_PNPBIOS_TRACE_LEVEL         (IOP_PNPBIOS_LEVEL + 1)
#define IOP_PNPBIOS_INFO_LEVEL          (IOP_PNPBIOS_LEVEL + 2)
#define IOP_PNPBIOS_VERBOSE_LEVEL       (IOP_PNPBIOS_LEVEL + 3)

#if DBG

ULONG
IopDebugPrint (
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    );

#define IopDbgPrint(m)  IopDebugPrint m

#else

#define IopDbgPrint(m)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppdrvdb.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpDrvDB.c

Abstract:

    This module containst PnP routines related to Defective Driver Database
    (DDB) support.

Author:

    Santosh S. Jodh - 22 Jan 2001

Environment:

    Kernel mode

Revision History:


--*/

#include "pnpmgrp.h"
#include "windef.h"
#include "winerror.h"
#include "shimdb.h"
#pragma hdrstop

// Bit 0 indicates policy for filters (0 = critical, 1 = non-critical)
#define DDB_DRIVER_POLICY_CRITICAL_BIT          (1 << 0)
// Bit 1 indicates policy for user-mode setup blocking (0 = block, 1 = no-block)
#define DDB_DRIVER_POLICY_SETUP_NO_BLOCK_BIT    (1 << 1)

#define DDB_BOOT_NOT_LOADED_ERROR       (1 << 0)
#define DDB_BOOT_OUT_OF_MEMORY_ERROR    (1 << 1)
#define DDB_BOOT_INIT_ERROR             (1 << 2)
#define DDB_DRIVER_PATH_ERROR           (1 << 3)
#define DDB_OPEN_FILE_ERROR             (1 << 4)
#define DDB_CREATE_SECTION_ERROR        (1 << 5)
#define DDB_MAP_SECTION_ERROR           (1 << 6)
#define DDB_MAPPED_INIT_ERROR           (1 << 7)
#define DDB_READ_INFORMATION_ERROR      (1 << 8)

//#define USE_HANDLES 0

extern BOOLEAN ExpInTextModeSetup;

#define INVALID_HANDLE_VALUE    ((HANDLE)-1)

typedef struct _DDBCACHE_ENTRY {
    //
    // These fields are used as matching critereon for cache lookup.
    //
    UNICODE_STRING  Name;           // Driver name
    ULONG           TimeDateStamp;  // Link date of the driver
    //
    // Reference data for the cached entry.
    //
    NTSTATUS        Status;         // Status from the DDB lookup
    GUID            Guid;

} DDBCACHE_ENTRY, *PDDBCACHE_ENTRY;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#pragma const_seg("PAGECONST")
#endif

//
// Constants.
//
const PWSTR PiSetupDDBPath = TEXT("\\$WIN_NT$.~BT\\drvmain.sdb");
const PWSTR PiNormalDDBPath = TEXT("\\SystemRoot\\AppPatch\\drvmain.sdb");
//
// Data.
//
// Handle to the driver database.
//
HSDB PpDDBHandle = NULL;
//
// Copy to the in memory image of driver database. Used only during boot.
//
PVOID PpBootDDB = NULL;
//
// Lock for synchronizing access to the driver database.
//
ERESOURCE PiDDBLock;
//
// We use RTL AVL table for our cache.
//
RTL_GENERIC_TABLE PiDDBCacheTable;
//
// Number of drivers blocked this boot.
//
ULONG PpBlockedDriverCount = 0;
//
// Path for the DDB.
//
PWSTR PiDDBPath = NULL;
//
// Mask to record already logged events.
//
ULONG PiLoggedErrorEventsMask = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

NTSTATUS
PiLookupInDDB(
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    IN BOOLEAN          IsFilter,
    OUT LPGUID          EntryGuid
    );

NTSTATUS
PiIsDriverBlocked(
    IN HSDB             SdbHandle,
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    IN BOOLEAN          IsFilter,
    OUT LPGUID          EntryGuid
    );

VOID
PiLogDriverBlockedEvent(
    IN PWCHAR InsertionString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN NTSTATUS Status
    );

NTSTATUS
PiInitializeDDBCache(
    VOID
    );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareDDBCacheEntries(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    );

NTSTATUS
PiLookupInDDBCache(
    IN PUNICODE_STRING    FullPath,
    IN PVOID              ImageBase,
    IN ULONG              ImageSize,
    OUT LPGUID            EntryGuid
    );

VOID
PiUpdateDriverDBCache(
    IN PUNICODE_STRING      FullPath,
    IN PVOID                ImageBase,
    IN ULONG                ImageSize,
    IN NTSTATUS             Status,
    IN GUID                 *Guid
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpInitializeBootDDB)
#pragma alloc_text(PAGE, PpReleaseBootDDB)
#pragma alloc_text(PAGE, PpCheckInDriverDatabase)
#pragma alloc_text(PAGE, PiLookupInDDB)
#pragma alloc_text(PAGE, PiIsDriverBlocked)
#pragma alloc_text(PAGE, PiLogDriverBlockedEvent)
#pragma alloc_text(PAGE, PiInitializeDDBCache)
#pragma alloc_text(PAGE, PiCompareDDBCacheEntries)
#pragma alloc_text(PAGE, PiLookupInDDBCache)
#pragma alloc_text(PAGE, PiUpdateDriverDBCache)
#pragma alloc_text(PAGE, PpGetBlockedDriverList)
#endif

NTSTATUS
PpInitializeBootDDB(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine initializes the DDB from the image copied by ntldr.

Arguments:

    LoaderBlock - Pointer to loader block.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    PpBlockedDriverCount = 0;
    PpDDBHandle = NULL;
    PpBootDDB = NULL;
    //
    // Initialize the lock for serializing access to the DDB.
    //
    ExInitializeResource(&PiDDBLock);
    PiDDBPath = (ExpInTextModeSetup)? PiSetupDDBPath : PiNormalDDBPath;
    //
    // Initialize DDB cache.
    //
    PiInitializeDDBCache();
    //
    // Return failure if the loader did not load the database.
    //
    if (LoaderBlock->Extension->DrvDBSize == 0 ||
        LoaderBlock->Extension->DrvDBImage == NULL) {

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_NOT_LOADED_ERROR)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PpInitializeDriverDB: Driver database not loaded!\n"));

            PiLoggedErrorEventsMask |= DDB_BOOT_NOT_LOADED_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("DATABASE NOT LOADED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_UNSUCCESSFUL;
    }
    //
    // Make a copy of the database in pageable memory since the loader memory
    // will soon get claimed.
    // If this becomes a perf issue, we need to add
    // support for a new loader memory type (PAGEABLE DATA).
    //
    PpBootDDB = ExAllocatePool(PagedPool, LoaderBlock->Extension->DrvDBSize);
    if (PpBootDDB == NULL) {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PpInitializeDriverDB: Failed to allocate memory to copy driver database!\n"));
        ASSERT(PpBootDDB);

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_OUT_OF_MEMORY_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_BOOT_OUT_OF_MEMORY_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("OUT OF MEMORY"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(PpBootDDB, LoaderBlock->Extension->DrvDBImage, LoaderBlock->Extension->DrvDBSize);
    //
    // Initialize the database from the memory image.
    //
    PpDDBHandle = SdbInitDatabaseInMemory(PpBootDDB, LoaderBlock->Extension->DrvDBSize);
    if (PpDDBHandle == NULL) {

        ExFreePool(PpBootDDB);
        PpBootDDB = NULL;
        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PpInitializeDriverDB: Failed to initialize driver database!\n"));
        ASSERT(PpDDBHandle);

        if (!(PiLoggedErrorEventsMask & DDB_BOOT_INIT_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_BOOT_INIT_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("INIT DATABASE FAILED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PpReleaseBootDDB(
    VOID
    )
/*++

Routine Description:

    This routine frees up the boot DDB once we are dont loading most drivers
    during boot.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Lock the DDB before freeing it.
    //
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);
    //
    // Free the DDB if any.
    //
    if (PpDDBHandle) {

        ASSERT(PpBootDDB);
        SdbReleaseDatabase(PpDDBHandle);
        PpDDBHandle = NULL;
        ExFreePool(PpBootDDB);
        PpBootDDB = NULL;
        status = STATUS_SUCCESS;
    } else {

        IopDbgPrint((IOP_WARNING_LEVEL,
                     "PpReleaseBootDDB called with uninitialized database!\n"));
        status = STATUS_UNSUCCESSFUL;
    }
    //
    // Unlock the DDB.
    //
    ExReleaseResourceLite(&PiDDBLock);
    KeLeaveCriticalRegion();

    return status;
}

NTSTATUS
PpCheckInDriverDatabase(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN ULONG ImageSize,
    IN BOOLEAN IsFilter,
    OUT LPGUID EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver.

Arguments:

    KeyName - Supplies a pointer to the driver's service key unicode string

    KeyHandle - Supplies a handle to the driver service node in the registry
        that describes the driver to be loaded.

    Header - Driver image header.

    IsFilter - Specifies whether this is a filter driver or not.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    UNICODE_STRING fullPath;

    PAGED_CODE();
    //
    // No driver blocking during textmode setup.
    //
    if (ExpInTextModeSetup) {
        return STATUS_SUCCESS;
    }

    status = IopBuildFullDriverPath(KeyName, KeyHandle, &fullPath);
    if (NT_SUCCESS(status)) {
        //
        // Lock the database access.
        //
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);
        //
        // First check the cache.
        //
        status = PiLookupInDDBCache(&fullPath, ImageBase, ImageSize, EntryGuid);
        if (status == STATUS_UNSUCCESSFUL) {
            //
            // Cache miss, try the database.
            //
            status = PiLookupInDDB(&fullPath, ImageBase, ImageSize, IsFilter, EntryGuid);
        }
        //
        // Unlock the database.
        //
        ExReleaseResourceLite(&PiDDBLock);
        KeLeaveCriticalRegion();

        ExFreePool(fullPath.Buffer);
    } else {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "IopCheckInDriverDatabase: Failed to build full driver path!\n"));
        ASSERT(NT_SUCCESS(status));

        if (!(PiLoggedErrorEventsMask & DDB_DRIVER_PATH_ERROR)) {

            PiLoggedErrorEventsMask |= DDB_DRIVER_PATH_ERROR;
            PiLogDriverBlockedEvent(
                TEXT("BUILD DRIVER PATH FAILED"),
                NULL,
                0,
                STATUS_DRIVER_DATABASE_ERROR);
        }
    }
    //
    // Ingore errors.
    //
    if (status != STATUS_DRIVER_BLOCKED &&
        status != STATUS_DRIVER_BLOCKED_CRITICAL) {

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
PiLookupInDDB(
    IN PUNICODE_STRING   FullPath,
    IN PVOID             ImageBase,
    IN ULONG             ImageSize,
    IN BOOLEAN           IsFilter,
    OUT LPGUID           EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver. During BOOT,
    it uses the boot DDB loaded by ntldr. Once the system is booted, it maps the
    DDB in memory.

Arguments:

    FullPath - Full driver path

    Header - Driver image header.

    IsFilter - Specifies whether this is a filter driver or not.

Return Value:

    NTSTATUS.

--*/
{
    UNICODE_STRING fileName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE sectionHandle, fileHandle;
    NTSTATUS status, unmapStatus;
    IO_STATUS_BLOCK ioStatus;
    PVOID ddbAddress;
    SIZE_T ddbSize;

    PAGED_CODE();

    fileHandle = (HANDLE)0;
    sectionHandle = (HANDLE)0;
    ddbAddress = NULL;
    if (PpDDBHandle == NULL) {
        //
        // Map the database in memory and initialize it.
        //
        RtlInitUnicodeString(&fileName, PiDDBPath);
        InitializeObjectAttributes(&objectAttributes,
                                   &fileName,
                                   (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                   NULL,
                                   NULL);
        status = ZwOpenFile (&fileHandle,
                             GENERIC_READ,
                             &objectAttributes,
                             &ioStatus,
                             FILE_SHARE_READ | FILE_SHARE_DELETE,
                             0);
        if (!NT_SUCCESS(status)) {

            if (!(PiLoggedErrorEventsMask & DDB_OPEN_FILE_ERROR)) {

                IopDbgPrint((IOP_ERROR_LEVEL,
                             "PiLookupInDDB: Failed to open driver database %wZ!\n", &fileName));

                PiLoggedErrorEventsMask |= DDB_OPEN_FILE_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE OPEN FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        status = ZwCreateSection(
            &sectionHandle,
            SECTION_MAP_READ,
            NULL,
            NULL,
            PAGE_READONLY,
            SEC_COMMIT,
            fileHandle);
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to create section to map driver database %wZ!\n", &fileName));
            ASSERT(NT_SUCCESS(status));

            if (!(PiLoggedErrorEventsMask & DDB_CREATE_SECTION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_CREATE_SECTION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE SECTION FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        ddbSize = 0;
        status = ZwMapViewOfSection(
            sectionHandle,
            NtCurrentProcess(),
            &ddbAddress,
            0,
            0,
            NULL,
            &ddbSize,
            ViewShare,
            0,
            PAGE_READONLY
            );
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to map driver database %wZ!\n", &fileName));
            ASSERT(NT_SUCCESS(status));

            if (!(PiLoggedErrorEventsMask & DDB_MAP_SECTION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_MAP_SECTION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("DATABASE MAPPING FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
        PpDDBHandle = SdbInitDatabaseInMemory(ddbAddress, (ULONG)ddbSize);
        if (PpDDBHandle == NULL) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiLookupInDDB: Failed to initialize mapped driver database %wZ!\n", &fileName));
            status = STATUS_UNSUCCESSFUL;
            ASSERT(PpDDBHandle);

            if (!(PiLoggedErrorEventsMask & DDB_MAPPED_INIT_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_MAPPED_INIT_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("INIT DATABASE FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

            goto Cleanup;
        }
    }
    //
    // Lookup the driver in the DDB.
    //
    status = PiIsDriverBlocked(PpDDBHandle, FullPath, ImageBase, ImageSize, IsFilter, EntryGuid);
    if (ddbAddress) {

        SdbReleaseDatabase(PpDDBHandle);
        PpDDBHandle = NULL;
    }

Cleanup:

    if (ddbAddress) {

        unmapStatus = ZwUnmapViewOfSection(NtCurrentProcess(), ddbAddress);
        ASSERT(NT_SUCCESS(unmapStatus));
    }
    if (sectionHandle) {

        ZwClose(sectionHandle);
    }
    if (fileHandle) {

        ZwClose(fileHandle);
    }

    return status;
}

NTSTATUS
PiIsDriverBlocked(
    IN HSDB             SdbHandle,
    IN PUNICODE_STRING  FullPath,
    IN PVOID            ImageBase,
    IN ULONG            ImageSize,
    IN BOOLEAN          IsFilter,
    OUT LPGUID          EntryGuid
    )
/*++

Routine Description:

    This routine checks the DDB for the presence of this driver. During BOOT,
    it uses the boot DDB loaded by ntldr. Once the system is booted, it maps the
    DDB in memory.

Arguments:

    SdbHandle - Handle to the DDB to be used.

    FullPath - Full driver path

    Header - Driver image header.

    IsFilter - Specifies whether this is a filter driver or not.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    TAGREF driverTag;
    SDBENTRYINFO entryInfo;
    ULONG type, size, policy;
    HANDLE fileHandle;
    PWCHAR fileName;

#ifdef USE_HANDLES
    UNICODE_STRING fileName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
#endif

    PAGED_CODE();

    fileHandle = INVALID_HANDLE_VALUE;

    ASSERT(ARGUMENT_PRESENT(EntryGuid));

#ifdef USE_HANDLES
    if (PnPBootDriversInitialized) {

        RtlInitUnicodeString(&fileName, FullPath->Buffer);
        InitializeObjectAttributes(&objectAttributes,
                                   &fileName,
                                   (OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE),
                                   NULL,
                                   NULL);
        status = ZwOpenFile (&fileHandle,
                             GENERIC_READ,
                             &objectAttributes,
                             &ioStatus,
                             FILE_SHARE_READ | FILE_SHARE_DELETE,
                             0);
        if (!NT_SUCCESS(status)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiIsDriverBlocked: Failed to open driver %wZ!\n", FullPath));
            ASSERT(NT_SUCCESS(status));
            fileHandle = INVALID_HANDLE_VALUE;
        }
    }
#endif

    ASSERT(SdbHandle != NULL);
    driverTag = SdbGetDatabaseMatch(SdbHandle, FullPath->Buffer, fileHandle, ImageBase, ImageSize);
    if (TAGREF_NULL != driverTag) {
        //
        // Read the driver policy (we care only about bit 0).
        //
        size = sizeof(policy);
        type = REG_DWORD;
        if (    SdbQueryDriverInformation(  SdbHandle,
                                            driverTag,
                                            L"Policy",
                                            &type,
                                            &policy,
                                            &size) != ERROR_SUCCESS ||
                (policy & DDB_DRIVER_POLICY_CRITICAL_BIT) == 0 || IsFilter == FALSE) {

            status =  STATUS_DRIVER_BLOCKED_CRITICAL;
        } else {
            //
            // Bit 0 of POLICY==1 for a filter, means ok to start the devnode minus this filter.
            //
            status = STATUS_DRIVER_BLOCKED;
        }
        if (!SdbReadDriverInformation(SdbHandle, driverTag, &entryInfo)) {

            IopDbgPrint((IOP_ERROR_LEVEL,
                         "PiIsDriverBlocked: Failed to read the GUID from the database for driver %wZ!\n", FullPath));
            ASSERT(0);

            if (!(PiLoggedErrorEventsMask & DDB_READ_INFORMATION_ERROR)) {

                PiLoggedErrorEventsMask |= DDB_READ_INFORMATION_ERROR;
                PiLogDriverBlockedEvent(
                    TEXT("READ DRIVER ID FAILED"),
                    NULL,
                    0,
                    STATUS_DRIVER_DATABASE_ERROR);
            }

        } else {

            IopDbgPrint((IOP_INFO_LEVEL,
                         "PiIsDriverBlocked: Driver entry GUID = {%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                         entryInfo.guidID.Data1,
                         entryInfo.guidID.Data2,
                         entryInfo.guidID.Data3,
                         entryInfo.guidID.Data4[0],
                         entryInfo.guidID.Data4[1],
                         entryInfo.guidID.Data4[2],
                         entryInfo.guidID.Data4[3],
                         entryInfo.guidID.Data4[4],
                         entryInfo.guidID.Data4[5],
                         entryInfo.guidID.Data4[6],
                         entryInfo.guidID.Data4[7]
                         ));
        }
    } else {
        //
        // Driver not found in the database.
        //
        status = STATUS_SUCCESS;
    }
    //
    // Write an entry to the event log.
    //
    if (status == STATUS_DRIVER_BLOCKED_CRITICAL ||
        status == STATUS_DRIVER_BLOCKED) {

        IopDbgPrint((IOP_ERROR_LEVEL,
                     "PiIsDriverBlocked: %wZ blocked from loading!!!\n", FullPath));

        fileName = wcsrchr(FullPath->Buffer, L'\\');
        if (fileName == NULL) {

            fileName = FullPath->Buffer;
        } else {

            fileName++;
        }
        PiLogDriverBlockedEvent(
            fileName,
            &entryInfo.guidID,
            sizeof(entryInfo.guidID),
            status);
    }
    //
    // Update the cache if neccessary.
    //
    if (status == STATUS_DRIVER_BLOCKED_CRITICAL ||
        status == STATUS_DRIVER_BLOCKED ||
        status == STATUS_SUCCESS) {
        //
        // Update our cache with the results.
        //
        PiUpdateDriverDBCache(
            FullPath,
            ImageBase,
            ImageSize,
            status,
            &entryInfo.guidID);
    }

    //
    // If the driver was blocked, return the entry GUID.
    //
    if ((status == STATUS_DRIVER_BLOCKED_CRITICAL ||
         status == STATUS_DRIVER_BLOCKED) && (ARGUMENT_PRESENT(EntryGuid))) {
        RtlCopyMemory(EntryGuid, &entryInfo.guidID, sizeof(GUID));
    }

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose(fileHandle);
    }

    return status;
}

VOID
PiLogDriverBlockedEvent(
    IN PWCHAR InsertionString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine logs the driver block event.

Arguments:

    FullPath - Full driver path

    Data - Data to be logged

    DataLength - Length of data (in bytes)

    Status - Status code to be logged

Return Value:

    None.

--*/
{
    PWCHAR name;
    ULONG size, stringLength;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    PAGED_CODE();

    stringLength = (wcslen(InsertionString) * sizeof(WCHAR)) + sizeof(UNICODE_NULL);
    size =  (sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG)) +
            DataLength + stringLength;
    if (size <= ERROR_LOG_MAXIMUM_SIZE) {

        errorLogEntry = IoAllocateGenericErrorLogEntry((UCHAR)size);
        if (errorLogEntry) {

            RtlZeroMemory(errorLogEntry, size);
            errorLogEntry->ErrorCode = Status;
            errorLogEntry->FinalStatus = Status;
            errorLogEntry->DumpDataSize = (USHORT)DataLength;
            if (Data) {

                RtlCopyMemory(&errorLogEntry->DumpData[0], Data, DataLength);
            }
            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(((PUCHAR)&errorLogEntry->DumpData[0] + errorLogEntry->DumpDataSize) - (PUCHAR)errorLogEntry);
            RtlCopyMemory(((PUCHAR)errorLogEntry + errorLogEntry->StringOffset), InsertionString, stringLength);
            IoWriteErrorLogEntry(errorLogEntry);
        }
    } else {

        ASSERT(size <= ERROR_LOG_MAXIMUM_SIZE);
    }
}

NTSTATUS
PiInitializeDDBCache(
    VOID
    )
/*++

Routine Description:

    This routine initializes the RTL Generic table that is used as the cache
    layer on top of DDB.

Arguments:

    None

Return Value:

    None.

--*/
{
    PAGED_CODE();

    RtlInitializeGenericTable(
        &PiDDBCacheTable,
        PiCompareDDBCacheEntries,
        PiAllocateGenericTableEntry,
        PiFreeGenericTableEntry,
        NULL);

    return STATUS_SUCCESS;
}

RTL_GENERIC_COMPARE_RESULTS
NTAPI
PiCompareDDBCacheEntries(
    IN  PRTL_GENERIC_TABLE          Table,
    IN  PVOID                       FirstStruct,
    IN  PVOID                       SecondStruct
    )
/*++

Routine Description:

    This routine is the callback for the generic table routines.

Arguments:

    Table       - Table for which this is invoked.

    FirstStruct - An element in the table to compare.

    SecondStruct - Another element in the table to compare.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS.

--*/
{
    PDDBCACHE_ENTRY lhs = (PDDBCACHE_ENTRY)FirstStruct;
    PDDBCACHE_ENTRY rhs = (PDDBCACHE_ENTRY)SecondStruct;
    LONG result;

    PAGED_CODE();

    result = RtlCompareUnicodeString(&lhs->Name, &rhs->Name, TRUE);
    if (result < 0) {

        return GenericLessThan;
    } else if (result > 0) {

        return GenericGreaterThan;
    }
    if (!Table->TableContext) {
        //
        // Link date as other matching criteria.
        //
        if (lhs->TimeDateStamp < rhs->TimeDateStamp) {

            return GenericLessThan;
        } else if (lhs->TimeDateStamp > rhs->TimeDateStamp) {

            return GenericGreaterThan;
        }
    }

    return GenericEqual;
}

NTSTATUS
PiLookupInDDBCache(
    IN  PUNICODE_STRING     FullPath,
    IN  PVOID               ImageBase,
    IN  ULONG               ImageSize,
    OUT LPGUID              EntryGuid
    )
/*++

Routine Description:

    This routine looks up the driver in the DDB cache.

Arguments:

    FullPath - Full driver path

    Header - Driver image header

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    PDDBCACHE_ENTRY cachedEntry;
    DDBCACHE_ENTRY key;
    PIMAGE_NT_HEADERS header;

    PAGED_CODE();

    ASSERT(ARGUMENT_PRESENT(EntryGuid));

    status = STATUS_UNSUCCESSFUL;
    PiDDBCacheTable.TableContext = NULL;
    if (!RtlIsGenericTableEmpty(&PiDDBCacheTable)) {
        //
        // Lookup in the cache.
        //
        header = RtlImageNtHeader(ImageBase);
        key.Name.Buffer = wcsrchr(FullPath->Buffer, L'\\');
        if (!key.Name.Buffer) {

            key.Name.Buffer = FullPath->Buffer;
        }
        key.Name.Length = wcslen(key.Name.Buffer) * sizeof(WCHAR);
        key.Name.MaximumLength = key.Name.Length + sizeof(UNICODE_NULL);
        key.TimeDateStamp = header->FileHeader.TimeDateStamp;
        cachedEntry = (PDDBCACHE_ENTRY)RtlLookupElementGenericTable(
            &PiDDBCacheTable,
            &key);
        if (cachedEntry) {

            IopDbgPrint((IOP_WARNING_LEVEL,
                         "PiLookupInDDBCache: Found cached entry for %ws (status = %08x)!\n",
                         cachedEntry->Name.Buffer,
                         cachedEntry->Status));
            status = cachedEntry->Status;

            if (ARGUMENT_PRESENT(EntryGuid)) {
                RtlCopyMemory(EntryGuid, &cachedEntry->Guid, sizeof(GUID));
            }
        }
    }

    return status;
}

VOID
PiUpdateDriverDBCache(
    IN PUNICODE_STRING      FullPath,
    IN PVOID                ImageBase,
    IN ULONG                ImageSize,
    IN NTSTATUS             Status,
    IN GUID                 *Guid
    )
/*++

Routine Description:

    This routine updates the DDB cache with information about this driver.

Arguments:

    FullPath - Full driver path

    Header - Driver image header

    Status - Lookup status to be cached.

Return Value:

    NTSTATUS.

--*/
{
    PDDBCACHE_ENTRY cachedEntry;
    DDBCACHE_ENTRY key;
    PWCHAR name;
    PIMAGE_NT_HEADERS header;

    PAGED_CODE();

    header = RtlImageNtHeader(ImageBase);
    //
    // We only want to match using name while updating the cache.
    //
    PiDDBCacheTable.TableContext = (PVOID)1;
    key.Name = *FullPath;
    cachedEntry = (PDDBCACHE_ENTRY)RtlLookupElementGenericTable(
       &PiDDBCacheTable,
       &key);
    if (cachedEntry) {

        IopDbgPrint((IOP_INFO_LEVEL,
                     "PiUpdateDriverDBCache: Found previously cached entry for %wZ with status=%08x!\n",
                     &cachedEntry->Name,
                     cachedEntry->Status));
        if (cachedEntry->Status != STATUS_SUCCESS) {

            PpBlockedDriverCount--;
        }
        //
        // Remove any previous entry.
        //
        name = cachedEntry->Name.Buffer;
        RtlDeleteElementGenericTable(&PiDDBCacheTable, &key);
        ExFreePool(name);
    }
    //
    // Cache the new entry.
    //
    key.Guid = *Guid;
    key.Status = Status;
    key.TimeDateStamp = header->FileHeader.TimeDateStamp;
    name = wcsrchr(FullPath->Buffer, L'\\');
    if (!name) {

        name = FullPath->Buffer;
    }
    key.Name.Length = key.Name.MaximumLength = wcslen(name) * sizeof(WCHAR);
    key.Name.Buffer = ExAllocatePool(PagedPool, key.Name.MaximumLength);
    if (key.Name.Buffer) {

        RtlCopyMemory(key.Name.Buffer, name, key.Name.Length);
        RtlInsertElementGenericTable(
            &PiDDBCacheTable,
            (PVOID)&key,
            (CLONG)sizeof(DDBCACHE_ENTRY),
            NULL);
    } else {

        IopDbgPrint((IOP_WARNING_LEVEL,
                     "PiUpdateDriverDBCache: Could not allocate memory to update driver database cache!\n"));
    }
    if (Status != STATUS_SUCCESS) {

        PpBlockedDriverCount++;
    }
}

NTSTATUS
PpGetBlockedDriverList(
    IN OUT GUID  *Buffer,
    IN OUT PULONG  Size,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine returns the MULTI_SZ list of currently blocked drivers.

Arguments:

    Buffer - Recieves the MULTI_SZ list of drivers blocked.

    Size - Buffer size on input, the actual size gets returned in this (both in
    characters).

Return Value:

    NTSTATUS.

--*/
{
    PDDBCACHE_ENTRY ptr;
    ULONG resultSize;
    GUID *result;
    NTSTATUS status;

    PAGED_CODE();

    resultSize = 0;

    //
    // Lock the database access.
    //
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&PiDDBLock, TRUE);

    //
    // Enumerate all entries in our cache and compute the buffer size to hold
    // the MULTI_SZ string.
    //
    for (ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, TRUE);
         ptr != NULL;
         ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, FALSE)) {

        if (ptr->Status != STATUS_SUCCESS) {

            resultSize += sizeof(GUID);
        }
    }
    if (*Size >= resultSize) {
        //
        // Enumerate all entries in our cache.
        //
        result = Buffer;
        for (ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, TRUE);
             ptr != NULL;
             ptr = (PDDBCACHE_ENTRY)RtlEnumerateGenericTable(&PiDDBCacheTable, FALSE)) {

            if (ptr->Status != STATUS_SUCCESS) {

                *result = ptr->Guid;
                result++;
            }
        }
        *Size = resultSize;
        status = STATUS_SUCCESS;
    } else {

        *Size = resultSize;
        status = STATUS_BUFFER_TOO_SMALL;
    }
    //
    // Unlock the database.
    //
    ExReleaseResourceLite(&PiDDBLock);
    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pnprlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pnprlist.h

Abstract:

    This file declares the routines and data structures used to manipulate
    relations list.  Relation lists are used by Plug and Play during the
    processing of device removal and ejection.

Author:

    Robert Nelson (robertn) Apr, 1998.

Revision History:

--*/

//
// A RELATION_LIST_ENTRY is an element of a relation list.
//
// It contains all the PDEVICE_OBJECTS which exist at the same level in the
// DEVICE_NODE tree.
//
// Individual PDEVICE_OBJECT entries are tagged by setting their lowest bit.
//
// MaxCount indicates the size of the Devices array.  Count indicates the number
// of elements which are currently being used.  When a relation list is
// compressed Count will equal MaxCount.
//
typedef struct _RELATION_LIST_ENTRY {
    ULONG                   Count;          // Number of current entries
    ULONG                   MaxCount;       // Size of Entries list
    PDEVICE_OBJECT          Devices[1];     // Variable length list of device objects
}   RELATION_LIST_ENTRY, *PRELATION_LIST_ENTRY;

//
// A RELATION_LIST contains a number of RELATION_LIST_ENTRY structures.
//
// Each entry in Entries describes all the devices of a given level in the
// DEVICE_NODE tree.  In order to conserve memory, space is only allocated for
// the entries between the lowest and highest levels inclusive.  The member
// FirstLevel indicates which level is at index 0 of Entries.  MaxLevel
// indicates the last level represented in Entries.  The number of entries is
// determined by the formula MaxLevel - FirstLevel + 1.  The Entries array can
// be sparse.  Each element of Entries will either be a PRELATION_LIST_ENTRY or
// NULL.
//
// The total number of PDEVICE_OBJECTs in all PRELATION_LIST_ENTRYs is kept in
// Count.  Individual PDEVICE_OBJECTS may be tagged.  The tag is maintained in
// Bit 0 of the PDEVICE_OBJECT.  The total number of PDEVICE_OBJECTs tagged is
// kept in TagCount.  This is used to rapidly determine whether or not all
// objects have been tagged.
//
typedef struct _RELATION_LIST {
    ULONG                   Count;          // Count of Devices in all Entries
    ULONG                   TagCount;       // Count of Tagged Devices
    ULONG                   FirstLevel;     // Level Number of Entries[0]
    ULONG                   MaxLevel;       // - FirstLevel + 1 = Number of Entries
    PRELATION_LIST_ENTRY    Entries[1];     // Variable length list of entries
}   RELATION_LIST, *PRELATION_LIST;

//
// A PENDING_RELATIONS_LIST_ENTRY is used to track relation lists for operations
// which may pend.  This includes removal when open handles exist and device
// ejection.
//
// The Link field is used to link the PENDING_RELATIONS_LIST_ENTRYs together.
//
// The DeviceObject field is the DEVICE_OBJECT to which the operation was
// originally targetted.  It will also exist as a member of the relations list.
//
// The RelationsList is a list of BusRelations, RemovalRelations, (and
// EjectionRelations in the case of eject) which are related to DeviceObject and
// its relations.
//
// The EjectIrp is pointer to the Eject IRP which has been sent to the PDO.  If
// this is a pending surprise removal then EjectIrp is not used.
//
typedef struct _PENDING_RELATIONS_LIST_ENTRY {
    LIST_ENTRY              Link;
    WORK_QUEUE_ITEM         WorkItem;
    PPNP_DEVICE_EVENT_ENTRY DeviceEvent;
    PDEVICE_OBJECT          DeviceObject;
    PRELATION_LIST          RelationsList;
    PIRP                    EjectIrp;
    ULONG                   Problem;
    BOOLEAN                 ProfileChangingEject;
    BOOLEAN                 DisplaySafeRemovalDialog;
    SYSTEM_POWER_STATE      LightestSleepState;
    PDOCK_INTERFACE         DockInterface;
}   PENDING_RELATIONS_LIST_ENTRY, *PPENDING_RELATIONS_LIST_ENTRY;

//
// Functions exported to other kernel modules.
//
NTSTATUS
IopAddRelationToList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DirectDescendant,
    IN BOOLEAN Tagged
    );

PRELATION_LIST
IopAllocateRelationList(
    IN  PLUGPLAY_DEVICE_DELETE_TYPE     OperationCode
    );

NTSTATUS
IopCompressRelationList(
    IN OUT PRELATION_LIST *List
    );

BOOLEAN
IopEnumerateRelations(
    IN PRELATION_LIST List,
    IN OUT PULONG Marker,
    OUT PDEVICE_OBJECT *PhysicalDevice,
    OUT BOOLEAN *DirectDescendant, OPTIONAL
    OUT BOOLEAN *Tagged, OPTIONAL
    BOOLEAN Reverse
    );

VOID
IopFreeRelationList(
    IN PRELATION_LIST List
    );

ULONG
IopGetRelationsCount(
    IN PRELATION_LIST List
    );

ULONG
IopGetRelationsTaggedCount(
    IN PRELATION_LIST List
    );

BOOLEAN
IopIsRelationInList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopMergeRelationLists(
    IN OUT PRELATION_LIST TargetList,
    IN PRELATION_LIST SourceList,
    IN BOOLEAN Tagged
    );

NTSTATUS
IopRemoveIndirectRelationsFromList(
    IN PRELATION_LIST List
    );

NTSTATUS
IopRemoveRelationFromList(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopSetAllRelationsTags(
    IN PRELATION_LIST List,
    IN BOOLEAN Tagged
    );

NTSTATUS
IopSetRelationsTag(
    IN PRELATION_LIST List,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Tagged
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppdrvdb.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    PpDrvDB.h

Abstract:

    Contains PnP routines to deal with driver load\unload.
    
Author:

    Santosh S. Jodh  - January 22, 2001

Revision History:

--*/

NTSTATUS
PpInitializeBootDDB(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
PpReleaseBootDDB(
    VOID
    );

NTSTATUS
PpGetBlockedDriverList(
    IN OUT GUID *Buffer,
    IN OUT PULONG Size,
    IN ULONG Flags
    );

NTSTATUS
PpCheckInDriverDatabase(
    IN PUNICODE_STRING KeyName,
    IN HANDLE KeyHandle,
    IN PVOID ImageBase,
    IN ULONG ImageSize,
    IN BOOLEAN IsFilter,
    OUT LPGUID EntryGuid
    );

extern ULONG PpBlockedDriverCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pphandle.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PpHandle.c

Abstract:

    This module implements handle location code for the Plug and Play subsystem.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

#include "pnpmgrp.h"
#include "pihandle.h"
#pragma hdrstop

//
// This code is current used only in the checked build for debugging purposes.
//
#if DBG

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(NONPAGE, PpHandleEnumerateHandlesAgainstPdoStack)
#pragma alloc_text(PAGE, PiHandleEnumerateHandlesAgainstDeviceObject)
#pragma alloc_text(PAGE, PiHandleProcessWalkWorker)
#endif


BOOLEAN
PpHandleEnumerateHandlesAgainstPdoStack(
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    )
/*++

Routine Description:

    This routine walks every device object in the WDM device stack along with
    all filesystem device objects on the other side of a VPB. If any handles
    are opened against such device objects, the specified callback is invoked.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the device object at the
                           bottom of the WDM device stack.

    HandleEnumCallBack - Pointer the callback function.

    Context - Pointer to information to be passed into the callback function.

Return Value:

    TRUE if the enumeration was halted, FALSE otherwise.

--*/
{
    PDEVICE_OBJECT currentDevObj, nextDevObj, vpbObj, vpbBottomObj;
    BOOLEAN stopEnum;
    KIRQL oldIrql;
    PVPB vpb;

    //
    // Preinit
    //
    stopEnum = FALSE;

    //
    // Start with the device object at the bottom of the stack
    //
    currentDevObj = PhysicalDeviceObject;
    ObReferenceObject(currentDevObj);

    do {

        //
        // Dump any handles opened directly against the specified device object
        //
        stopEnum = PiHandleEnumerateHandlesAgainstDeviceObject(
            currentDevObj,
            HandleEnumCallBack,
            Context
            );

        if (stopEnum) {

            ObDereferenceObject(currentDevObj);
            break;
        }

        //
        // Look for a VPB
        //
        IoAcquireVpbSpinLock(&oldIrql);

        vpb = currentDevObj->Vpb;
        vpbObj = NULL;

        if (vpb) {

            vpbObj = vpb->DeviceObject;
            if (vpbObj) {

                ObReferenceObject(vpbObj);
            }
        }

        IoReleaseVpbSpinLock(oldIrql);

        //
        // If we have a vpb object, dump any handles queued against it.
        //
        if (vpbObj) {

            vpbBottomObj = IoGetDeviceAttachmentBaseRef(vpbObj);

            stopEnum = PiHandleEnumerateHandlesAgainstDeviceObject(
                vpbBottomObj,
                HandleEnumCallBack,
                Context
                );

            ObDereferenceObject(vpbBottomObj);
            ObDereferenceObject(vpbObj);

            if (stopEnum) {

                ObDereferenceObject(currentDevObj);
                break;
            }
        }

        //
        // Advance to the next DO.
        //
        oldIrql = KeAcquireQueuedSpinLock(LockQueueIoDatabaseLock);

        nextDevObj = currentDevObj->AttachedDevice;

        if (nextDevObj) {

            ObReferenceObject(nextDevObj);
        }

        KeReleaseQueuedSpinLock(LockQueueIoDatabaseLock, oldIrql);

        //
        // Drop ref on old DO.
        //
        ObDereferenceObject(currentDevObj);

        //
        // Loop.
        //
        currentDevObj = nextDevObj;

    } while (currentDevObj);

    return stopEnum;
}


BOOLEAN
PiHandleEnumerateHandlesAgainstDeviceObject(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    )
/*++

Routine Description:

    This routine walks the handle table for each process in the system looking
    for handles opened against the passed in device object.

Arguments:

    PhysicalDeviceObject - Supplies a pointer to the device object at the
                           bottom of the WDM device stack.

    HandleEnumCallBack - Pointer the callback function.

    Context - Pointer to information to be passed into the callback function.

Return Value:

    TRUE if the enumeration was halted, FALSE otherwise.

--*/
{
    PEPROCESS process;
    PHANDLE_TABLE objectTable;
    HANDLE_ENUM_CONTEXT handleEnumContext;
    BOOLEAN stopEnum;

    stopEnum = FALSE;
    for(process = PsGetNextProcess(NULL);
        process != NULL;
        process = PsGetNextProcess(process)) {

        objectTable = ObReferenceProcessHandleTable(process);

        if (objectTable) {

            handleEnumContext.DeviceObject = DeviceObject;
            handleEnumContext.Process = process;
            handleEnumContext.CallBack = HandleEnumCallBack;
            handleEnumContext.Context = Context;

            stopEnum = ExEnumHandleTable(
                objectTable,
                PiHandleProcessWalkWorker,
                (PVOID) &handleEnumContext,
                NULL
                );

            ObDereferenceProcessHandleTable(process);

            if (stopEnum) {

                PsQuitNextProcess(process);
                break;
            }
        }
    }

    return stopEnum;
}


BOOLEAN
PiHandleProcessWalkWorker(
    IN  PHANDLE_TABLE_ENTRY     ObjectTableEntry,
    IN  HANDLE                  HandleId,
    IN  PHANDLE_ENUM_CONTEXT    EnumContext
    )
/*++

Routine Description:

    This routine gets called back for each handle in a given process. It
    examines each handle to see if it is a file object opened against the
    device object we are looking for.

Arguments:

    ObjectTableEntry - Points to the handle table entry of interest.

    HandleId - Supplies the handle.

    EnumContext - Context passed in for the enumeration.

Return Value:

    TRUE if the enumeration should be stopped, FALSE otherwise.

--*/
{
    PDEVICE_OBJECT deviceObject;
    POBJECT_HEADER objectHeader;
    PFILE_OBJECT fileObject;

    objectHeader = OBJECT_FROM_EX_TABLE_ENTRY(ObjectTableEntry);

    if (objectHeader->Type != IoFileObjectType) {

        //
        // Not a file object
        //
        return FALSE;
    }

    fileObject = (PFILE_OBJECT) &objectHeader->Body;

    deviceObject = IoGetBaseFileSystemDeviceObject( fileObject );

    if (deviceObject != EnumContext->DeviceObject) {

        //
        // Not our device object
        //
        return FALSE;
    }

    //
    // Found one, invoke the callback!
    //
    return EnumContext->CallBack(
        EnumContext->DeviceObject,
        EnumContext->Process,
        fileObject,
        HandleId,
        EnumContext->Context
        );
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pphandle.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PpLastGood.h

Abstract:

    This header exposes routines for enumerating handles opened against a PDO
    stack.

Author:

    Adrian J. Oney  - April 4, 2001

Revision History:

--*/

//
// The routines exposed by this header are currently available only in the
// checked build.
//
#if DBG

typedef BOOLEAN (*PHANDLE_ENUMERATION_CALLBACK)(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PEPROCESS       Process,
    IN  PFILE_OBJECT    FileObject,
    IN  HANDLE          HandleId,
    IN  PVOID           Context
    );

BOOLEAN
PpHandleEnumerateHandlesAgainstPdoStack(
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  PHANDLE_ENUMERATION_CALLBACK    HandleEnumCallBack,
    IN  PVOID                           Context
    );

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pphotswap.c ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    PpHotSwap.c

Abstract:

    This file implements support for hotswap devices.

Author:

    Adrian J. Oney (AdriaO) Feb 2001

Revision History:


--*/

#include "pnpmgrp.h"
#include "pihotswap.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpHotSwapInitRemovalPolicy)
#pragma alloc_text(PAGE, PpHotSwapUpdateRemovalPolicy)
#pragma alloc_text(PAGE, PpHotSwapGetDevnodeRemovalPolicy)
#pragma alloc_text(PAGE, PiHotSwapGetDefaultBusRemovalPolicy)
#pragma alloc_text(PAGE, PiHotSwapGetDetachableNode)
#endif


VOID
PpHotSwapInitRemovalPolicy(
    OUT PDEVICE_NODE    DeviceNode
    )
/*++

Routine Description:

    This function initializes the removal policy information for a device node.

Arguments:

    DeviceNode - DevNode to update policy.

Return Value:

    Nothing.

--*/
{
    PAGED_CODE();

    DeviceNode->RemovalPolicy = (UCHAR) RemovalPolicyNotDetermined;
    DeviceNode->HardwareRemovalPolicy = (UCHAR) RemovalPolicyNotDetermined;
}


VOID
PpHotSwapUpdateRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode
    )
/*++

Routine Description:

    This function updates the removal policy by retrieving the appropriate
    data from the registry or drivers.

Arguments:

    DeviceNode - DevNode to update policy on.

Return Value:

    Nothing.

--*/
{
    NTSTATUS status;
    DEVICE_REMOVAL_POLICY deviceRemovalPolicy, parentPolicy;
    PDEVICE_NODE detachableNode;
    ULONG policyLength, policyCharacteristics;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    //
    // First find the detachable node - it holds our policy data, and is
    // special as it may make suggestions.
    //
    PiHotSwapGetDetachableNode(DeviceNode, &detachableNode);

    //
    // We aren't in fact removable. Finish now.
    //
    if (detachableNode == NULL) {

        DeviceNode->RemovalPolicy = (UCHAR) RemovalPolicyExpectNoRemoval;
        DeviceNode->HardwareRemovalPolicy = (UCHAR) RemovalPolicyExpectNoRemoval;
        return;
    }

    //
    // Check the stack for an explicit policy...
    //
    policyCharacteristics =
        ((DeviceNode->PhysicalDeviceObject->Characteristics) &
         FILE_CHARACTERISTICS_REMOVAL_POLICY_MASK);

    if (policyCharacteristics == FILE_CHARACTERISTICS_EXPECT_ORDERLY_REMOVAL) {

        deviceRemovalPolicy = RemovalPolicyExpectOrderlyRemoval;

    } else if (policyCharacteristics == FILE_CHARACTERISTICS_EXPECT_SURPRISE_REMOVAL) {

        deviceRemovalPolicy = RemovalPolicyExpectSurpriseRemoval;

    } else if (DeviceNode != detachableNode) {

        //
        // We didn't get any good guesses. Therefore use the weakest policy.
        //
        deviceRemovalPolicy = RemovalPolicyUnspecified;

    } else {

        //
        // If we're the detach point, then we win.
        //
        PiHotSwapGetDefaultBusRemovalPolicy(DeviceNode, &deviceRemovalPolicy);
    }

    if (DeviceNode != detachableNode) {

        //
        // Do we have a winning policy? There are two possible algorithms for
        // coming to such a decision.
        // 1) Best policy is stored back at the detach point. If a child has a
        //    better policy, the detach point is updated.
        // 2) Policy is inherited downwards from the parent.
        //
        // We choose the second algorithm because devnode start orders may
        // change scenario to scenario, and we favor determinism (same results
        // each time) over opportunism (nonmarked child gets write caching
        // enabled only on Tuesdays.)
        //
        parentPolicy = DeviceNode->Parent->RemovalPolicy;
        if (deviceRemovalPolicy > parentPolicy) {

            //
            // Seems dad was right afterall...
            //
            deviceRemovalPolicy = parentPolicy;
        }
    }

    //
    // Update the policy hardware policy and the overall policy in case there's
    // no registry override.
    //
    DeviceNode->RemovalPolicy = (UCHAR) deviceRemovalPolicy;
    DeviceNode->HardwareRemovalPolicy = (UCHAR) deviceRemovalPolicy;

    //
    // We might not have to ask the stack anything. Check for a registry
    // override.
    //
    policyLength = sizeof(DEVICE_REMOVAL_POLICY);

    status = PiGetDeviceRegistryProperty(
        DeviceNode->PhysicalDeviceObject,
        REG_DWORD,
        REGSTR_VALUE_REMOVAL_POLICY,
        NULL,
        &deviceRemovalPolicy,
        &policyLength
        );

    //
    // If we have an override, set that as the policy.
    //
    if (NT_SUCCESS(status) &&
        ((deviceRemovalPolicy == RemovalPolicyExpectOrderlyRemoval) ||
         (deviceRemovalPolicy == RemovalPolicyExpectSurpriseRemoval))) {

        DeviceNode->RemovalPolicy = (UCHAR) deviceRemovalPolicy;
    }
}


VOID
PpHotSwapGetDevnodeRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    IN  BOOLEAN                 IncludeRegistryOverride,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    )
/*++

Routine Description:

    This function retrieves the removal policy for a device node.

Arguments:

    DeviceNode - DevNode to retrieve policy from.

    IncludeRegistryOverride - TRUE if a registry override should be taken into
                              account if present. FALSE if the check should be
                              restricted to the hardware.

    RemovalPolicy - Receives removal policy.

Return Value:

    Nothing.

--*/
{
    PDEVICE_NODE detachableNode;
    DEVICE_REMOVAL_POLICY reportedPolicy;

    PAGED_CODE();

    //
    // Ensure the tree won't be edited while we examine it.
    //
    PpDevNodeLockTree(PPL_SIMPLE_READ);

    if (IncludeRegistryOverride) {

        reportedPolicy = DeviceNode->RemovalPolicy;

    } else {

        reportedPolicy = DeviceNode->HardwareRemovalPolicy;
    }

    if (reportedPolicy == RemovalPolicyNotDetermined) {

        //
        // We haven't started yet or asked the bus. Our policy is based on
        // whether the device is removable or ejectable.
        //
        PiHotSwapGetDetachableNode(DeviceNode, &detachableNode);

        if (detachableNode == NULL) {

            reportedPolicy = RemovalPolicyExpectNoRemoval;

        } else if (IopDeviceNodeFlagsToCapabilities(detachableNode)->EjectSupported) {

            //
            // Ejectable devices require orderly removal. We will assume the
            // user knows this.
            //
            reportedPolicy = RemovalPolicyExpectOrderlyRemoval;

        } else {

            ASSERT(IopDeviceNodeFlagsToCapabilities(detachableNode)->Removable);

            //
            // Removal nonstarted devices can be pulled at any instant.
            //
            reportedPolicy = RemovalPolicyExpectSurpriseRemoval;
        }

    } else {

        //
        // The devnode has a cached policy. Cut down on the options.
        //
        switch(reportedPolicy) {

            case RemovalPolicyExpectNoRemoval:
            case RemovalPolicyExpectOrderlyRemoval:
            case RemovalPolicyExpectSurpriseRemoval:
                //
                // Leave unchanged.
                //
                break;

            case RemovalPolicySuggestSurpriseRemoval:
                reportedPolicy = RemovalPolicyExpectSurpriseRemoval;
                break;

            default:
                ASSERT(0);

                //
                // Fall through.
                //

            case RemovalPolicyUnspecified:

                //
                // Unspecified is treated as orderly since the diversity of
                // busses favor high-speed orderly connections over consumer
                // connections.
                //
                // Fall through
                //

            case RemovalPolicySuggestOrderlyRemoval:
                reportedPolicy = RemovalPolicyExpectOrderlyRemoval;
                break;
        }
    }

    PpDevNodeUnlockTree(PPL_SIMPLE_READ);
    *RemovalPolicy = reportedPolicy;
}


VOID
PiHotSwapGetDefaultBusRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    )
/*++

Routine Description:

    This function gets the default removal policy for a bus. This should be
    turned into a query in future designs.

Arguments:

    DeviceNode - DevNode to examine. This devnode should be the detach point.

    RemovalPolicy - Receives removal policy for the node.

Return Value:

    None.

--*/
{
    DEVICE_REMOVAL_POLICY deviceRemovalPolicy;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_TREEOP_ALLOW_READS);

    if ((DeviceNode->InstancePath.Length > 8) &&
        (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"USB\\", 4))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 10) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"1394\\", 5))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 10) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"SBP2\\", 5))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 14) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"PCMCIA\\", 7))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else if ((DeviceNode->InstancePath.Length > 8) &&
               (!_wcsnicmp(DeviceNode->InstancePath.Buffer, L"PCI\\", 4)) &&
               (DeviceNode->Parent->ServiceName.Length == 12) &&
               (!_wcsicmp(DeviceNode->Parent->ServiceName.Buffer, L"PCMCIA"))) {

        deviceRemovalPolicy = RemovalPolicySuggestSurpriseRemoval;

    } else {

        deviceRemovalPolicy = RemovalPolicySuggestOrderlyRemoval;
    }

    *RemovalPolicy = deviceRemovalPolicy;
}


VOID
PiHotSwapGetDetachableNode(
    IN  PDEVICE_NODE    DeviceNode,
    OUT PDEVICE_NODE   *DetachableNode
    )
/*++

Routine Description:

    This function starts at the DeviceNode and walks up the tree to find the
    first node that is removable.

Arguments:

    DeviceNode - DevNode to start walk from.

    DetachableNode - Receives detachable node, NULL if none.

Return Value:

    Nothing.

--*/
{
    PDEVICE_NODE currentNode;

    PAGED_CODE();

    PPDEVNODE_ASSERT_LOCK_HELD(PPL_SIMPLE_READ);

    //
    // We haven't started yet or asked the bus. Our policy is based on
    // whether the device is removable or ejectable.
    //
    for(currentNode = DeviceNode;
        currentNode != NULL;
        currentNode = currentNode->Parent) {

        if ((IopDeviceNodeFlagsToCapabilities(currentNode)->Removable) ||
            (IopDeviceNodeFlagsToCapabilities(currentNode)->EjectSupported)) {

            break;
        }
    }

    *DetachableNode = currentNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pplastgood.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PpLastGood.h

Abstract:

    This header exposed various routines needed for last known good processing
    in the IO subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

VOID
PpLastGoodDoBootProcessing(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppmacro.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ppmacro.h

Abstract:

    This header defines various generic macros for the Plug and Play subsystem.

Author:

    Adrian J. Oney (AdriaO) July 26, 2000.

Revision History:


--*/

//
// This is to make all the TEXT(...) macros come out right. As of 07/27/2000,
// UNICODE isn't defined in kernel space by default.
//
#define UNICODE

//
// This macro is used to convert HKLM relative paths from user-mode accessable
// headers into a form usable by kernel mode. Eventually this macro should be
// moved to somewhere like cm.h so the entire kernel can use it.
//
#define CM_REGISTRY_MACHINE(x) L"\\Registry\\Machine\\"##x
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pphotswap.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    PpHotSwap.h

Abstract:

    This file exposes public prototypes for hotswap device support.

Author:

    Adrian J. Oney (AdriaO) Feb 2001

Revision History:


--*/

VOID
PpHotSwapInitRemovalPolicy(
    OUT PDEVICE_NODE    DeviceNode
    );

VOID
PpHotSwapUpdateRemovalPolicy(
    IN  PDEVICE_NODE    DeviceNode
    );

VOID
PpHotSwapGetDevnodeRemovalPolicy(
    IN  PDEVICE_NODE            DeviceNode,
    IN  BOOLEAN                 IncludeRegistryOverride,
    OUT PDEVICE_REMOVAL_POLICY  RemovalPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pplastgood.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PpLastGood.c

Abstract:

    This module handles last known good processing for the IO subsystem.

Author:

    Adrian J. Oney  - April 4, 2000

Revision History:

--*/

#include "pnpmgrp.h"
#include "pilastgood.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpLastGoodDoBootProcessing)
#pragma alloc_text(INIT, PiLastGoodRevertLastKnownDirectory)
#pragma alloc_text(INIT, PiLastGoodRevertCopyCallback)
#pragma alloc_text(INIT, PiLastGoodCopyKeyContents)
#endif

#define POOLTAG_LASTGOOD ('gLpP')

VOID
PpLastGoodDoBootProcessing(
    VOID
    )
/*++

Routine Description:

    This rolls back the system files to the state they were during the last
    known good boot. It should only be called from within a last known good
    boot, and at the earliest point possible.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UNICODE_STRING lastKnownGoodPath, lastKnownGoodTmpPath;
    UNICODE_STRING lastKnownGoodDelKey, lastKnownGoodTmpDelKey;
    NTSTATUS status;

    RtlInitUnicodeString(
        &lastKnownGoodPath,
        L"\\SystemRoot\\LastGood"
        );

    RtlInitUnicodeString(
        &lastKnownGoodDelKey,
        CM_REGISTRY_MACHINE(REGSTR_PATH_LASTGOOD)
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpPath,
        L"\\SystemRoot\\LastGood.Tmp"
        );

    RtlInitUnicodeString(
        &lastKnownGoodTmpDelKey,
        CM_REGISTRY_MACHINE(REGSTR_PATH_LASTGOODTMP)
        );

    if (!CmIsLastKnownGoodBoot()) {

        //
        // If we are in safe mode we don't do anything to commit the current
        // boot.
        //
        if (InitSafeBootMode) {

            return;
        }

        //
        // We are in a non-last known good boot. We immediately move all the
        // previous last known good info into the tmp subtree. We do this
        // because we will taint the normal LKG path prior to marking it good
        // (eg pre-logon server side install of PnP devices). Note that if the
        // tmp directory already exists, we *don't* perform the copy, as a good
        // boot is signified by deleting that directory.
        //
        status = IopFileUtilRename(
            &lastKnownGoodPath,
            &lastKnownGoodTmpPath,
            FALSE
            );

        if (!NT_SUCCESS(status)) {

            return;
        }

        //
        // It worked, now we also take care of the registry info.
        //
        PiLastGoodCopyKeyContents(
            &lastKnownGoodDelKey,
            &lastKnownGoodTmpDelKey,
            TRUE
            );

        return;
    }

    //
    // Revert the LastGood tree. This tree contains the changes made after
    // SMSS.EXE's initialization.
    //
    PiLastGoodRevertLastKnownDirectory(
        &lastKnownGoodPath,
        &lastKnownGoodDelKey
        );

    //
    // Revert the LastGood.Tmp tree. This tree contains the changes made on
    // a prior boot if we crashed between SMSS.EXE's initialization and login.
    //
    PiLastGoodRevertLastKnownDirectory(
        &lastKnownGoodTmpPath,
        &lastKnownGoodTmpDelKey);
}


VOID
PiLastGoodRevertLastKnownDirectory(
    IN PUNICODE_STRING  LastKnownGoodDirectory,
    IN PUNICODE_STRING  LastKnownGoodRegPath
    )
/*++

Routine Description:

    This function commits the changes specified by a given last known good
    directory and reg key. All files in the directory are first copied over any
    existing files. Subsequently, any files specified in the reg key are
    deleted.

Arguments:

    LastKnownGoodDirectory - Directory subtree to copy over \SystemRoot. This
                             path is emptied when the copy is complete.

    LastKnownGoodRegPath   - Key containing files to delete. Each value entry
                             is relative to \SystemRoot, and the value itself
                             contains the name of the file to delete.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    UNICODE_STRING fileToDelete, fileName;
    OBJECT_ATTRIBUTES lastKnownGoodKeyAttributes;
    OBJECT_ATTRIBUTES fileAttributes;
    HANDLE lastGoodRegHandle;
    UCHAR keyBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 256*sizeof(WCHAR) + sizeof(ULONG)];
    WCHAR filePathName[255 + sizeof("\\SystemRoot\\")];
    PKEY_VALUE_FULL_INFORMATION pFullKeyInformation;
    ULONG resultLength, i, j, optionValue;

    //
    // Preinit our pointer to the full information buffer.
    //
    pFullKeyInformation = (PKEY_VALUE_FULL_INFORMATION) keyBuffer;

    //
    // Preform the file copy.
    //
    IopFileUtilWalkDirectoryTreeTopDown(
        LastKnownGoodDirectory,
        ( DIRWALK_INCLUDE_FILES | DIRWALK_CULL_DOTPATHS | DIRWALK_TRAVERSE ),
        PiLastGoodRevertCopyCallback,
        (PVOID) LastKnownGoodDirectory
        );

    //
    // Delete all the files specified in by the registry keys.
    //
    InitializeObjectAttributes(
        &lastKnownGoodKeyAttributes,
        LastKnownGoodRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwOpenKey(
        &lastGoodRegHandle,
        KEY_ALL_ACCESS,
        &lastKnownGoodKeyAttributes
        );

    if (!NT_SUCCESS(status)) {

        return;
    }

    i = 0;
    while (1) {

        status = ZwEnumerateValueKey(
            lastGoodRegHandle,
            i++,
            KeyValueFullInformation,
            pFullKeyInformation,
            sizeof(keyBuffer),
            &resultLength
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;
            }

            break;
        }

        if (resultLength == 0) {

            continue;
        }

        if (pFullKeyInformation->Type != REG_DWORD) {

            continue;
        }

        if (pFullKeyInformation->DataLength != sizeof(ULONG)) {

            continue;
        }

        optionValue = *((PULONG) (((PUCHAR) pFullKeyInformation) +
            pFullKeyInformation->DataOffset));

        //
        // We only understand deletes (and no flags).
        //
        if ((optionValue & 0xFF) != 1) {

            continue;
        }

        fileToDelete.Buffer = filePathName;
        fileToDelete.Length = (USHORT) 0;
        fileToDelete.MaximumLength = sizeof(filePathName);

        fileName.Buffer = (PWSTR) pFullKeyInformation->Name;
        fileName.Length = (USHORT) pFullKeyInformation->NameLength;
        fileName.MaximumLength = fileName.Length;

        RtlAppendUnicodeToString(&fileToDelete, L"\\SystemRoot\\");
        RtlAppendUnicodeStringToString(&fileToDelete, &fileName);

        //
        // Note that the key name has all '\'s changed to '/'s. Here we change
        // them back as the file systems are *almost* but not quite slash-tilt
        // agnostic.
        //
        for(j = sizeof(L"\\SystemRoot\\")/sizeof(WCHAR);
            j < fileToDelete.Length/sizeof(WCHAR);
            j++) {

            if (filePathName[j] == L'/') {

                filePathName[j] = L'\\';
            }
        }

        IopFileUtilClearAttributes(
            &fileToDelete,
            ( FILE_ATTRIBUTE_READONLY |
              FILE_ATTRIBUTE_HIDDEN |
              FILE_ATTRIBUTE_SYSTEM )
            );

        InitializeObjectAttributes(
            &fileAttributes,
            &fileToDelete,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

        ZwDeleteFile(&fileAttributes);
    }

    ZwDeleteKey(&lastGoodRegHandle);
    ZwClose(lastGoodRegHandle);
}


NTSTATUS
PiLastGoodRevertCopyCallback(
    IN PUNICODE_STRING  FullPathName,
    IN PUNICODE_STRING  FileName,
    IN ULONG            FileAttributes,
    IN PVOID            Context
    )
/*++

Routine Description:

    This function is called back for each file in each of the appropriate
    LastKnownGood directories. It's job is to move the specified file into the
    appropriate mainline directory.

Arguments:

    FullPathName - Full path name of the identified file, relative to SystemRoot

    FileName - Filename portion, exempts directory.

    Context - Unicode string name of the root directory scanned. The string
              should not have a trailing '\\'

Return Value:

    NTSTATUS (Unsuccessful statusi abort further copies).

--*/
{
    NTSTATUS status;
    const USHORT rootLength = sizeof(L"\\SystemRoot\\")-sizeof(WCHAR);
    USHORT lastGoodLength;
    UNICODE_STRING targetFile;
    PWCHAR newPathText;

    //
    // Add in an extra character to skip past the '\\'
    //
    lastGoodLength = ((PUNICODE_STRING) Context)->Length + sizeof(WCHAR);

    newPathText = ExAllocatePoolWithTag(
        PagedPool,
        FullPathName->Length,
        POOLTAG_LASTGOOD
        );

    if (newPathText == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Change \\SystemRoot\LastGood\Blah... to \\SystemRoot\Blah...
    //
    RtlCopyMemory(
        newPathText,
        FullPathName->Buffer,
        rootLength
        );

    RtlCopyMemory(
        newPathText + rootLength/sizeof(WCHAR),
        FullPathName->Buffer + lastGoodLength/sizeof(WCHAR),
        FullPathName->Length - lastGoodLength
        );

    //
    // Setup our unicode string path.
    //
    targetFile.Length = FullPathName->Length - lastGoodLength + rootLength;
    targetFile.MaximumLength = targetFile.Length;
    targetFile.Buffer = newPathText;

    //
    // Perform the rename.
    //
    status = IopFileUtilRename(FullPathName, &targetFile, TRUE);

    //
    // Cleanup and exit.
    //
    ExFreePool(newPathText);
    return status;
}


NTSTATUS
PiLastGoodCopyKeyContents(
    IN PUNICODE_STRING  SourceRegPath,
    IN PUNICODE_STRING  DestinationRegPath,
    IN BOOLEAN          DeleteSourceKey
    )
/*++

Routine Description:

    This function copies all the value keys in one source path to the
    destination path.

    NOTE: This function's implementation currently restricts the total of value
          and name lengths to 512 bytes, and is therefore not a generic key
          copy function.

Arguments:

    SourcePath - Registry path to enumerate and copy keys from.

    DestinationPath - Registry path to receive new value keys. This key will
                      be created if it does not exist.

    DeleteSourceKey - If TRUE, source key is deleted upn successful completion
                      of copy.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES sourceKeyAttributes, destinationKeyAttributes;
    HANDLE sourceRegHandle, destinationRegHandle;
    UCHAR keyBuffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 512*sizeof(WCHAR)];
    PKEY_VALUE_FULL_INFORMATION pFullKeyInformation;
    ULONG resultLength, i, disposition;
    UNICODE_STRING valueName;

    //
    // Prep the buffer.
    //
    pFullKeyInformation = (PKEY_VALUE_FULL_INFORMATION) keyBuffer;

    //
    // Open the source key.
    //
    InitializeObjectAttributes(
        &sourceKeyAttributes,
        SourceRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwOpenKey(
        &sourceRegHandle,
        KEY_ALL_ACCESS,
        &sourceKeyAttributes
        );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // Open or create the destination key.
    //
    InitializeObjectAttributes(
        &destinationKeyAttributes,
        DestinationRegPath,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateKey(
        &destinationRegHandle,
        KEY_ALL_ACCESS,
        &destinationKeyAttributes,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        &disposition
        );

    if (!NT_SUCCESS(status)) {

        ZwClose(sourceRegHandle);
        return status;
    }

    //
    // Iterate over all the value keys, copying each.
    //
    i = 0;
    while (1) {

        status = ZwEnumerateValueKey(
            sourceRegHandle,
            i++,
            KeyValueFullInformation,
            pFullKeyInformation,
            sizeof(keyBuffer),
            &resultLength
            );

        if (!NT_SUCCESS(status)) {

            if (status == STATUS_NO_MORE_ENTRIES) {

                status = STATUS_SUCCESS;
            }

            break;
        }

        valueName.Buffer = pFullKeyInformation->Name;
        valueName.Length = (USHORT) pFullKeyInformation->NameLength;
        valueName.MaximumLength = valueName.Length;

        status = ZwSetValueKey(
            destinationRegHandle,
            &valueName,
            0,
            pFullKeyInformation->Type,
            ((PUCHAR) pFullKeyInformation) + pFullKeyInformation->DataOffset,
            pFullKeyInformation->DataLength
            );

        if (!NT_SUCCESS(status)) {

            break;
        }
    }

    //
    // Cleanup time.
    //
    if (NT_SUCCESS(status) && DeleteSourceKey) {

        ZwDeleteKey(sourceRegHandle);
    }

    ZwClose(sourceRegHandle);
    ZwClose(destinationRegHandle);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\pppagepath.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    PpPathPath.c

Abstract:

    The file implements support for managing devices on the paging path.

Author:

    Adrian J. Oney (AdriaO) February 3rd, 2001

Revision History:

    Originally taken from ChuckL's implementation in mm\modwrite.c.

--*/

#include "pnpmgrp.h"
#include "pipagepath.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PpPagePathAssign)
#pragma alloc_text(PAGE, PpPagePathRelease)
#pragma alloc_text(PAGE, PiPagePathSetState)
#endif


NTSTATUS
PpPagePathAssign(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine informs driver stacks that they are now on the paging path.
    Drivers need to take appropriate actions when on the path, such as failing
    IRP_MN_QUERY_STOP and IRP_MN_QUERY_REMOVE, locking their code and clearing
    the DO_POWER_PAGABLE bit, etc.

Arguments:

    FileObject - File object for the paging file itself.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    return PiPagePathSetState(FileObject, TRUE);
}


NTSTATUS
PpPagePathRelease(
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine informs driver stacks that the passed in file is no longer a
    paging file. Each driver stack notified may still be on the paging path
    however if their hardware supports a different paging file on another drive.

Arguments:

    FileObject - File object for the paging file itself.

Return Value:

    NTSTATUS.

--*/
{
    PAGED_CODE();

    return PiPagePathSetState(FileObject, FALSE);
}


NTSTATUS
PiPagePathSetState(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN      InPath
    )
/*++

Routine Description:

    This routine notifies driver stacks when a paging file is shut down on their
    device, or if a paging file is being started up on their device. If a paging
    file is being started up, this request is also a query as the stack may not
    be able to support a pagefile.

Arguments:

    FileObject - File object for the paging file itself.

    InPath - Whether the page file is being started or shut down.

Return Value:

    NTSTATUS.

--*/
{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //
    ObReferenceObject(FileObject);

    //
    // Initialize the local event.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Get the address of the target device object.
    //
    deviceObject = IoGetRelatedDeviceObject(FileObject);

    //
    // Allocate and initialize the irp for this operation.
    //
    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);

    if (irp == NULL) {

        //
        // Don't dereference the file object, our caller will take care of that.
        //
        return STATUS_NO_MEMORY;
    }

    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //
    irp->UserEvent = &event;
    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->UserIosb = &localIoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //
    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->MajorFunction = IRP_MJ_PNP;
    irpSp->MinorFunction = IRP_MN_DEVICE_USAGE_NOTIFICATION;
    irpSp->FileObject = FileObject;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->AssociatedIrp.SystemBuffer = NULL;
    // irp->Flags = 0;

    irpSp->Parameters.UsageNotification.InPath = InPath;
    irpSp->Parameters.UsageNotification.Type = DeviceUsageTypePaging;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //
    IoQueueThreadIrp(irp);

    //
    // Acquire the engine lock to ensure no rebalances, removes, or power
    // operations are in progress during this notification.
    //
    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //
    status = IoCallDriver(deviceObject, irp);

    //
    // Wait for the local event and copy the final status information
    // back to the caller.
    //
    if (status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject(&event,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     NULL);

        status = localIoStatus.Status;
    }

    //
    // Unlock the tree.
    //
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppprofile.c ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    PpProfile.c

Abstract:

    Kernel-mode Plug and Play Manager Docking and Hardware Profile Support
    Routines.

Author:

    Adrian J. Oney (AdriaO) June 1998
    Kenneth D. Ray (kenray) June 1998

Revision History:



--*/

#include "pnpmgrp.h"

//
// ISSUE-2000/07/24-AdriaO - Header mess
//     We should not be including private headers from CM.
//
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#include "..\config\cmp.h"
#include "piprofile.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, PpProfileInit)
#pragma alloc_text(PAGE, PpProfileBeginHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileIncludeInHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileQueryHardwareProfileChange)
#pragma alloc_text(PAGE, PpProfileCommitTransitioningDock)
#pragma alloc_text(PAGE, PpProfileCancelTransitioningDock)
#pragma alloc_text(PAGE, PpProfileCancelHardwareProfileTransition)
#pragma alloc_text(PAGE, PpProfileMarkAllTransitioningDocksEjected)
#pragma alloc_text(PAGE, PiProfileSendHardwareProfileCommit)
#pragma alloc_text(PAGE, PiProfileSendHardwareProfileCancel)
#pragma alloc_text(PAGE, PiProfileConvertFakeDockToRealDock)
#pragma alloc_text(PAGE, PiProfileRetrievePreferredCallback)
#pragma alloc_text(PAGE, PpProfileRetrievePreferredDockToEject)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTree)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTreeWorker)
#pragma alloc_text(PAGE, PiProfileUpdateDeviceTreeCallback)
#endif

//
// List of current dock devices, and the number of dockdevices.
// Must hold PiProfileDeviceListLock to change these values.
//
LIST_ENTRY  PiProfileDeviceListHead;
ULONG       PiProfileDeviceCount;
FAST_MUTEX  PiProfileDeviceListLock;
KSEMAPHORE  PiProfileChangeSemaphore;
BOOLEAN     PiProfileChangeCancelRequired;
LONG        PiProfileDevicesInTransition;


VOID
PpProfileInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes docking support for Win2K.

Arguments:

    None.

Return Value:

    Nope.

--*/
{
    //
    // Initialize the list of dock devices, and its lock.
    //
    InitializeListHead(&PiProfileDeviceListHead);
    ExInitializeFastMutex(&PiProfileDeviceListLock);
    PiProfileDeviceCount = 0;
    KeInitializeSemaphore(&PiProfileChangeSemaphore, 1, 1);
}


VOID
PpProfileBeginHardwareProfileTransition(
    IN BOOLEAN SubsumeExistingDeparture
    )
/*++

Routine Description:

    This routine must be called before any dock devnodes can be marked for
    transition (ie arriving or departing). After calling this function,
    PpProfileIncludeInHardwareProfileTransition should be called for each dock
    that is appearing or disappearing.

    Functionally, this code acquires the profile change semaphore. Future
    changes in the life of the added dock devnodes cause it to be released.

Arguments:

    SubsumeExistingDeparture - Set if we are ejecting the parent of a
                               device that is still in the process of
                               ejecting...

Return Value:

    None.

--*/
{
    NTSTATUS status;

    if (SubsumeExistingDeparture) {

        //
        // We will already have queried in this case. Also, enumeration is
        // locked right now, so the appropriate devices found cannot disappear.
        // Assert everything is consistant.
        //
        ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
        ASSERT(PiProfileDevicesInTransition != 0);
        return;
    }

    //
    // Take the profile change semaphore. We do this whenever a dock is
    // in our list, even if no query is going to occur.
    //
    status = KeWaitForSingleObject(
        &PiProfileChangeSemaphore,
        Executive,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT(status == STATUS_SUCCESS);
}


VOID
PpProfileIncludeInHardwareProfileTransition(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PROFILE_STATUS  ChangeInPresence
    )
/*++

Routine Description:

    This routine is called to mark a dock as "in transition", ie it is either
    disappearing or appearing, the results of which determine our final
    hardware profile state. After all the docks that are transitioning have
    been passed into this function, PiProfileQueryHardwareProfileChange is
    called.

Arguments:

    DeviceNode          - The dock devnode that is appearing or disappearing
    ChangeInPresence    - Either DOCK_DEPARTING or DOCK_ARRIVING

Return Value:

    Nope.

--*/
{
    PWCHAR          deviceSerialNumber;
    PDEVICE_OBJECT  deviceObject;
    NTSTATUS        status;

    //
    // Verify we are under semaphore, we aren't marking the dock twice, and
    // our parameters are sensable.
    //
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_QUIESCENT);
    ASSERT((ChangeInPresence == DOCK_DEPARTING)||
           (ChangeInPresence == DOCK_ARRIVING));

    if (ChangeInPresence == DOCK_ARRIVING) {

        //
        // First, ensure this dock is a member of the dock list.
        //
        // ADRIAO N.B. 07/09/2000 -
        //     We should move this into IopProcessNewDeviceNode, or perhaps
        // PipStartPhaseN.
        //
        if (IsListEmpty(&DeviceNode->DockInfo.ListEntry)) {

            //
            // Acquire the lock on the list of dock devices
            //
            ExAcquireFastMutex(&PiProfileDeviceListLock);

            //
            // Add this element to the head of the list
            //
            InsertHeadList(&PiProfileDeviceListHead,
                           &DeviceNode->DockInfo.ListEntry);
            PiProfileDeviceCount++;

            //
            // Release the lock on the list of dock devices
            //
            ExReleaseFastMutex(&PiProfileDeviceListLock);
        }

        //
        // Retrieve the Serial Number from this dock device. We do this just
        // to test the BIOS today. Later we will be acquiring the information
        // to determine the profile we are *about* to enter.
        //
        deviceObject = DeviceNode->PhysicalDeviceObject;

        status = IopQueryDeviceSerialNumber(
            deviceObject,
            &deviceSerialNumber
            );

        if (NT_SUCCESS(status) && (deviceSerialNumber != NULL)) {

            ExFreePool(deviceSerialNumber);
        }

    } else {

        //
        // DOCK_DEPARTING case, we must be a member of the dock list...
        //
        ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));
    }

    InterlockedIncrement(&PiProfileDevicesInTransition);
    DeviceNode->DockInfo.DockStatus = ChangeInPresence;
}


NTSTATUS
PpProfileQueryHardwareProfileChange(
    IN  BOOLEAN                     SubsumingExistingDeparture,
    IN  PROFILE_NOTIFICATION_TIME   InPnpEvent,
    OUT PPNP_VETO_TYPE              VetoType,
    OUT PUNICODE_STRING             VetoName OPTIONAL
    )
/*++

Routine Description:

    This function queries drivers to see if it is OK to exit the current
    hardware profile and enter next one (as determined by which docks have
    been marked). One of two functions should be used subsequently to this
    call:
        PpProfileCommitTransitioningDock
            (call when a dock has been successfully started or has disappeared)
        PpProfileCancelHardwareProfileTransition
            (call to abort a transition, say if a dock failed to start or a
             query returned failure for eject)

Arguments:

    InPnpEvent  - This argument indicates whether an operation is being done
                  within the context of another PnpEvent or not. If not, we
                  will queue such an event and block on it. If so, we cannot
                  queue&block (we'd deadlock), so we do the query manually.
    VetoType    - If this function returns false, this parameter will describe
                  who failed the query profile change. The below optional
                  parameter will contain the name of said vetoer.
    VetoName    - This optional parameter will get the name of the vetoer (ie
                  devinst, service name, application name, etc). If VetoName
                  is supplied, the caller must free the buffer returned.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS status;
    BOOLEAN arrivingDockFound;
    PLIST_ENTRY listEntry;
    PDEVICE_NODE devNode;

    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices and determine whether any
    // dock devnodes are arriving.
    //
    ExAcquireFastMutex(&PiProfileDeviceListLock);

    ASSERT(PiProfileDevicesInTransition);

    arrivingDockFound = FALSE;
    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE)&&
               (devNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED));

        if (devNode->DockInfo.DockStatus == DOCK_ARRIVING) {

            arrivingDockFound = TRUE;
        }
    }

    //
    // Release the lock on the list of dock devices
    //
    ExReleaseFastMutex(&PiProfileDeviceListLock);

    if (SubsumingExistingDeparture) {

        ASSERT(PiProfileChangeCancelRequired);
        //
        // We're nesting. Work off the last query, and don't requery.
        //
        return STATUS_SUCCESS;
    }

    if (arrivingDockFound) {

        //
        // We currently don't actually query for hardware profile change on a
        // dock event as the user may have the lid closed. If we ever find a
        // piece of hardware that needs to be updated *prior* to actually
        // switching over, we will have to remove this bit of code.
        //
        PiProfileChangeCancelRequired = FALSE;
        return STATUS_SUCCESS;
    }

    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [query]\n"));

    status = IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_QUERY_CHANGE,
        InPnpEvent,
        VetoType,
        VetoName
        );

    if (NT_SUCCESS(status)) {
        PiProfileChangeCancelRequired = TRUE;
    } else {
        PiProfileChangeCancelRequired = FALSE;
    }
    return status;
}


VOID
PpProfileCommitTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    )
/*++

Routine Description:

    This routine finalized the state the specified device in the list of
    current dock devices and requests a Hardware Profile change.

Arguments:

    DeviceNode - The dock devnode that has finished being started or removed.
    ChangeInPresence - Either DOCK_DEPARTING or DOCK_ARRIVING

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PWCHAR deviceSerialNumber;
    BOOLEAN profileChanged;
    LONG remainingDockCount;

    //
    // If we are commiting a dock, the transition list should not be empty.
    // all dock devices present, the list should not be empty.
    //
    ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    if (ChangeInPresence == DOCK_DEPARTING) {

        ASSERT((DeviceNode->DockInfo.DockStatus == DOCK_DEPARTING) ||
               (DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED));

        //
        // Free up the serial number
        //
        if (DeviceNode->DockInfo.SerialNumber != NULL) {

            ExFreePool(DeviceNode->DockInfo.SerialNumber);
            DeviceNode->DockInfo.SerialNumber = NULL;
        }

        //
        // Acquire the lock on the list of dock devices
        //
        ExAcquireFastMutex(&PiProfileDeviceListLock);

        //
        // Remove the current devnode from the list of docks
        //
        RemoveEntryList(&DeviceNode->DockInfo.ListEntry);
        InitializeListHead(&DeviceNode->DockInfo.ListEntry);
        PiProfileDeviceCount--;

        //
        // Release the lock on the list of dock devices
        //
        ExReleaseFastMutex(&PiProfileDeviceListLock);

    } else {

        ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_ARRIVING);

        //
        // We only add one dock at a time. So this should have been the last!
        //
        ASSERT(PiProfileDevicesInTransition == 1);

        //
        // Retrieve the Serial Number from this dock device if we don't already
        // have it.
        //
        if (DeviceNode->DockInfo.SerialNumber == NULL) {

            deviceObject = DeviceNode->PhysicalDeviceObject;

            status = IopQueryDeviceSerialNumber(deviceObject,
                                                &deviceSerialNumber);

            DeviceNode->DockInfo.SerialNumber = deviceSerialNumber;
        }
    }

    DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    remainingDockCount = InterlockedDecrement(&PiProfileDevicesInTransition);
    ASSERT(remainingDockCount >= 0);

    if (remainingDockCount) {

        return;
    }

    profileChanged = FALSE;

    if ((ChangeInPresence == DOCK_ARRIVING) &&
        (DeviceNode->DockInfo.SerialNumber == NULL)) {

        //
        // Couldn't get Serial Number for this dock device, or serial number
        // was NULL. We can make this check here as only one dock at a time
        // can currently arrive.
        //
        status = STATUS_UNSUCCESSFUL;
        goto BroadcastAndLeave;
    }

    //
    // Update the current Hardware Profile now that the transition list has
    // been emptied. This routine does two things for us:
    // 1) It determines whether the profile actually changed and updates
    //    the global flag IopProfileChangeOccured appropriately.
    // 2) If the profile changed, this routine updates the registry.
    //
    status = PiProfileUpdateHardwareProfile(&profileChanged);
    if (!NT_SUCCESS(status)) {

        IopDbgPrint((IOP_TRACE_LEVEL,
                   "PiProfileUpdateHardwareProfile failed with status == %lx\n", status));
    }

BroadcastAndLeave:

    //
    // Clean up
    //
    if (NT_SUCCESS(status) && profileChanged) {

        PiProfileSendHardwareProfileCommit();
        PiProfileUpdateDeviceTree();

    } else if (PiProfileChangeCancelRequired) {

        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );

    return;
}


VOID
PpProfileCancelTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    )
/*++

Routine Description:

    This routine is called when a dock that was marked to disappear didn't (ie,
    after the eject, the dock device still enumerated). We remove it from the
    transition list and complete/cancel the HW profile change as appropriate.
    See PpProfileMarkAllTransitioningDocksEjected.

Arguments:

    DeviceNode - The dock devnode that either didn't start or didn't disappear.
    ChangeInPresence - Either DOCK_DEPARTING or DOCK_ARRIVING

    N.B. - Currently only DOCK_DEPARTING is supported.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    BOOLEAN  profileChanged;
    LONG     remainingDockCount;

    ASSERT(ChangeInPresence == DOCK_DEPARTING);

    //
    // Acquire the lock on the list of dock devices
    //
    ExAcquireFastMutex(&PiProfileDeviceListLock);

    //
    // Since we are about to remove this dock device from the list of
    // all dock devices present, the list should not be empty.
    //
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    ASSERT(DeviceNode->DockInfo.DockStatus == DOCK_EJECTIRP_COMPLETED);
    ASSERT(!IsListEmpty(&DeviceNode->DockInfo.ListEntry));

    DeviceNode->DockInfo.DockStatus = DOCK_QUIESCENT;
    remainingDockCount = InterlockedDecrement(&PiProfileDevicesInTransition);
    ASSERT(remainingDockCount >= 0);

    //
    // Release the lock on the list of dock devices
    //
    ExReleaseFastMutex(&PiProfileDeviceListLock);

    if (remainingDockCount) {

        return;
    }

    //
    // Update the current Hardware Profile after removing this device.
    //
    status = PiProfileUpdateHardwareProfile(&profileChanged);

    if (!NT_SUCCESS(status)) {

        //
        // So we're there physically, but not mentally? Too bad, where broadcasting
        // change either way.
        //
        IopDbgPrint((IOP_TRACE_LEVEL,
                   "PiProfileUpdateHardwareProfile failed with status == %lx\n", status));

        ASSERT(NT_SUCCESS(status));
    }

    if (NT_SUCCESS(status) && profileChanged) {

        PiProfileSendHardwareProfileCommit();
        PiProfileUpdateDeviceTree();

    } else {

        ASSERT(PiProfileChangeCancelRequired);
        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );

    return;
}


VOID
PpProfileCancelHardwareProfileTransition(
    VOID
    )
/*++

Routine Description:

    This routine unmarks any marked devnodes (ie, sets them to no change,
    appearing or disappearing), and sends the CancelQueryProfileChange as
    appropriate. Once called, other profile changes can occur.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;

    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices
    //
    ExAcquireFastMutex(&PiProfileDeviceListLock);

    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus != DOCK_NOTDOCKDEVICE)&&
               (devNode->DockInfo.DockStatus != DOCK_EJECTIRP_COMPLETED));
        if (devNode->DockInfo.DockStatus != DOCK_QUIESCENT) {

            InterlockedDecrement(&PiProfileDevicesInTransition);
            devNode->DockInfo.DockStatus = DOCK_QUIESCENT;
        }
    }

    ASSERT(!PiProfileDevicesInTransition);

    //
    // Release the lock on the list of dock devices
    //
    ExReleaseFastMutex(&PiProfileDeviceListLock);

    if (PiProfileChangeCancelRequired) {

        PiProfileSendHardwareProfileCancel();
    }

    KeReleaseSemaphore(
        &PiProfileChangeSemaphore,
        IO_NO_INCREMENT,
        1,
        FALSE
        );
}


VOID
PpProfileMarkAllTransitioningDocksEjected(
    VOID
    )
/*++

Routine Description:

    This routine moves any departing devnodes to the ejected state. If any
    subsequent enumeration lists the device as present, we know the eject
    failed and we appropriately cancel that piece of the profile change.
    PpProfileCancelTransitioningDock can only be called after this function
    is called.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;

    //
    // The semaphore might not be signalled if the dock was resurrected before
    // the eject completed. This can happen in warm undock scenarios where the
    // machine is resumed inside the dock instead of being detached.
    //
    //ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);

    //
    // Acquire the lock on the list of dock devices
    //
    ExAcquireFastMutex(&PiProfileDeviceListLock);

    for (listEntry  = PiProfileDeviceListHead.Flink;
        listEntry != &(PiProfileDeviceListHead);
        listEntry  = listEntry->Flink ) {

        devNode = CONTAINING_RECORD(listEntry,
                                    DEVICE_NODE,
                                    DockInfo.ListEntry);

        ASSERT((devNode->DockInfo.DockStatus == DOCK_QUIESCENT)||
               (devNode->DockInfo.DockStatus == DOCK_DEPARTING));
        if (devNode->DockInfo.DockStatus != DOCK_QUIESCENT) {

            devNode->DockInfo.DockStatus = DOCK_EJECTIRP_COMPLETED;
        }
    }

    //
    // Release the lock on the list of dock devices
    //
    ExReleaseFastMutex(&PiProfileDeviceListLock);
}


VOID
PiProfileSendHardwareProfileCommit(
    VOID
    )
/*++

Routine Description:

    This routine (internal to ppdock.c) simply sends the change complete message.
    We do not wait for this, as it is asynchronous...

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [commit]\n"));

    IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_CHANGE_COMPLETE,
        PROFILE_PERHAPS_IN_PNPEVENT,
        NULL,
        NULL
        );
}


VOID
PiProfileSendHardwareProfileCancel(
    VOID
    )
/*++

Routine Description:

    This routine (internal to ppdock.c) simply sends the cancel.

Arguments:

    None.

Return Value:

    Nodda.

--*/
{
    ASSERT_SEMA_NOT_SIGNALLED(&PiProfileChangeSemaphore);
    IopDbgPrint((IOP_TRACE_LEVEL,
               "NTOSKRNL: Sending HW profile change [cancel]\n"));

    IopRequestHwProfileChangeNotification(
        (LPGUID) &GUID_HWPROFILE_CHANGE_CANCELLED,
        PROFILE_PERHAPS_IN_PNPEVENT,
        NULL,
        NULL
        );
}


NTSTATUS
PiProfileUpdateHardwareProfile(
    OUT BOOLEAN     *ProfileChanged
    )
/*++

Routine Description:

    This routine scans the list of current dock devices, builds a list of serial
    numbers from those devices, and calls for the Hardware Profile to be
    changed, based on that list.

Arguments:

    ProfileChanged - Supplies a variable to receive TRUE if the current hardware
                     profile changes as a result of calling this routine.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PLIST_ENTRY  listEntry;
    PDEVICE_NODE devNode;
    PWCHAR  *profileSerialNumbers, *p;
    HANDLE  hProfileKey=NULL;
    ULONG   len, numProfiles;
    HANDLE  hCurrent, hIDConfigDB;
    UNICODE_STRING unicodeName;

    //
    // Acquire the lock on the list of dock devices
    //
    ExAcquireFastMutex(&PiProfileDeviceListLock);

    //
    // Update the flag for Ejectable Docks (flag is the count of docks)
    //
    PiWstrToUnicodeString(&unicodeName, CM_HARDWARE_PROFILE_STR_DATABASE);
    if(NT_SUCCESS(IopOpenRegistryKey(&hIDConfigDB,
                                     NULL,
                                     &unicodeName,
                                     KEY_READ,
                                     FALSE) )) {

        PiWstrToUnicodeString(&unicodeName, CM_HARDWARE_PROFILE_STR_CURRENT_DOCK_INFO);
        if(NT_SUCCESS(IopOpenRegistryKey(&hCurrent,
                                         hIDConfigDB,
                                         &unicodeName,
                                         KEY_READ | KEY_WRITE,
                                         FALSE) )) {

            PiWstrToUnicodeString(&unicodeName, REGSTR_VAL_EJECTABLE_DOCKS);
            ZwSetValueKey(hCurrent,
                          &unicodeName,
                          0,
                          REG_DWORD,
                          &PiProfileDeviceCount,
                          sizeof(PiProfileDeviceCount));
            ZwClose(hCurrent);
        }
        ZwClose(hIDConfigDB);
    }

    if (PiProfileDeviceCount == 0) {
        //
        // if there are no dock devices, the list should
        // contain a single null entry, in addition to the null
        // termination.
        //
        numProfiles = 1;
        ASSERT(IsListEmpty(&PiProfileDeviceListHead));
    } else {
        numProfiles = PiProfileDeviceCount;
        ASSERT(!IsListEmpty(&PiProfileDeviceListHead));
    }

    //
    // Allocate space for a null-terminated list of SerialNumber lists.
    //
    len = (numProfiles+1)*sizeof(PWCHAR);
    profileSerialNumbers = ExAllocatePool(NonPagedPool, len);

    if (profileSerialNumbers) {

        p = profileSerialNumbers;

        //
        // Create the list of Serial Numbers
        //
        for (listEntry  = PiProfileDeviceListHead.Flink;
             listEntry != &(PiProfileDeviceListHead);
             listEntry  = listEntry->Flink ) {

            devNode = CONTAINING_RECORD(listEntry,
                                        DEVICE_NODE,
                                        DockInfo.ListEntry);

            ASSERT(devNode->DockInfo.DockStatus == DOCK_QUIESCENT);
            if (devNode->DockInfo.SerialNumber) {
                *p = devNode->DockInfo.SerialNumber;
                p++;
            }
        }

        ExReleaseFastMutex(&PiProfileDeviceListLock);

        if (p == profileSerialNumbers) {
            //
            // Set a single list entry to NULL if we look to be in an "undocked"
            // profile
            //
            *p = NULL;
            p++;
        }

        //
        // Null-terminate the list
        //
        *p = NULL;

        numProfiles = (ULONG)(p - profileSerialNumbers);

        //
        // Change the current Hardware Profile based on the new Dock State
        // and perform notification that the Hardware Profile has changed
        //
        status = IopExecuteHardwareProfileChange(HardwareProfileBusTypeACPI,
                                                 profileSerialNumbers,
                                                 numProfiles,
                                                 &hProfileKey,
                                                 ProfileChanged);
        if (hProfileKey) {
            ZwClose(hProfileKey);
        }
        ExFreePool (profileSerialNumbers);

    } else {

        ExReleaseFastMutex(&PiProfileDeviceListLock);

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


PDEVICE_OBJECT
PpProfileRetrievePreferredDockToEject(
    VOID
    )
/*++

Routine Description:

    This routine is called to retrieve the dock that should be ejected via
    start menu UI.

Arguments:

    None.

Return Value:

    Dock device object if one exists.

++*/
{
    BEST_DOCK_TO_EJECT  bestDock;
    //
    // Search for the Dock Nodes
    //
    bestDock.PhysicalDeviceObject = NULL;
    PipForAllDeviceNodes(PiProfileRetrievePreferredCallback, (PVOID)&bestDock);

    return bestDock.PhysicalDeviceObject;
}


PDEVICE_NODE
PiProfileConvertFakeDockToRealDock(
    IN  PDEVICE_NODE    FakeDockDevnode
    )
/*++

Routine Description:

    Given a docking Physical Device Object for a fake dock, walk its ejection
    relations to find out the corresponding real dock node.

Arguments:

    FakeDockDevnode - Fake Dock node

Returns

    Real Dock (PDO referenced once), NULL if none.

--*/
{
    ULONG               i;
    NTSTATUS            status;
    PDEVICE_OBJECT      devobj;
    PDEVICE_NODE        devnode, realDock;
    PDEVICE_RELATIONS   ejectRelations = NULL;
    IO_STACK_LOCATION   irpSp;

    //
    // Obtain the list of ejection relations.
    //
    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
    irpSp.Parameters.QueryDeviceRelations.Type = EjectionRelations;

    status = IopSynchronousCall(
        FakeDockDevnode->PhysicalDeviceObject,
        &irpSp,
        (PULONG_PTR) &ejectRelations
        );

    if ((!NT_SUCCESS(status)) || (ejectRelations == NULL)) {

        return NULL;
    }

    //
    // Walk the eject relations looking for the depth.
    //
    realDock = NULL;
    for(i = 0; i < ejectRelations->Count; i++) {

        devobj = ejectRelations->Objects[i];

        //
        // The last ejection relation is the one that points to the
        // underlying physically enumerated device.
        //
        if (i == ejectRelations->Count-1) {

            devnode = (PDEVICE_NODE) devobj->DeviceObjectExtension->DeviceNode;

            //
            // The devnode might be NULL if:
            // 1) A driver make a mistake
            // 2) We got back an ejection relation on a newly created PDO
            //    that hasn't made it's way back up to the OS (we don't
            //    raise the tree lock to BlockReads while an enumeration
            //    IRP is outstanding...)
            //
            if (devnode) {

                realDock = devnode;
                ObReferenceObject(devobj);
            }
        }

        ObDereferenceObject(devobj);
    }

    ExFreePool(ejectRelations);
    return realDock;
}


NTSTATUS
PiProfileRetrievePreferredCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID        Context
    )
/*++

Routine Description:

    Scan the list of device nodes for docks, and keep the one with the most
    attractive depth (ie, the one eject PC should select.)

Arguments:

    DeviceNode - Possible docking station DevNode.

    Context - Pointer to the BEST_DOCK_TO_EJECT structure to fill in. The
              PhysicalDeviceObject pointer in this structure should be
              preinited to NULL. The located docking station PDO will be
              referenced.

Returns:

    NTSTATUS (Unsuccessful status's stop the enumeration of devnodes)

--*/
{
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    PBEST_DOCK_TO_EJECT pBestDock;
    PDEVICE_NODE realDock, curDock;
    NTSTATUS status;
    ULONG dockDepth;
    HANDLE hDeviceKey;

    //
    // Cast the context appropriately.
    //
    pBestDock = (PBEST_DOCK_TO_EJECT) Context;

    //
    // If it's not a dock device, we will ignore it...
    //
    if (!IopDeviceNodeFlagsToCapabilities(DeviceNode)->DockDevice) {

        //
        // Continue enumerating.
        //
        return STATUS_SUCCESS;
    }

    //
    // First get the corresponding real dock that goes with the fake dock
    // created by ACPI.
    //
    realDock = PiProfileConvertFakeDockToRealDock(DeviceNode);

    //
    // Search for overrides. Examine the real dock first, then the fake
    //
    curDock = realDock ? realDock : DeviceNode;
    while(1) {

        //
        // Examine the devnode for a specified ejection priority.
        //
        status = IoOpenDeviceRegistryKey(
            curDock->PhysicalDeviceObject,
            PLUGPLAY_REGKEY_DEVICE,
            KEY_READ,
            &hDeviceKey
            );

        if (NT_SUCCESS(status)) {

            RtlZeroMemory(queryTable, sizeof(queryTable));

            dockDepth = 0;
            queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
            queryTable[0].Name          = (PWSTR) REGSTR_VAL_EJECT_PRIORITY;
            queryTable[0].EntryContext  = &dockDepth;
            queryTable[0].DefaultType   = REG_NONE;
            queryTable[0].DefaultData   = NULL;
            queryTable[0].DefaultLength = 0;

            status = RtlQueryRegistryValues(
                RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                hDeviceKey,
                queryTable,
                NULL,
                NULL
                );

            if (NT_SUCCESS(status)) {

                //
                // Promote manually specified priorities over inferred ones.
                // Note that we _add_ in 0x80000000 rather than _or_ it in.
                // This lets us wrap in case we ever need to specify a priority
                // lower than what's inferred.
                //
                dockDepth += 0x80000000;
            }

            ZwClose(hDeviceKey);
        }

        if (NT_SUCCESS(status) || (curDock == DeviceNode)) {

            break;
        }

        curDock = DeviceNode;
    }

    if (!NT_SUCCESS(status)) {

        //
        // If we can find no eject preference order, use the depth of the
        // dock devnode.
        //
        dockDepth = realDock ? realDock->Level : DeviceNode->Level;
    }

    if (realDock) {

        ObDereferenceObject(realDock->PhysicalDeviceObject);
    }

    //
    // The best dock is selected as the dock with the deepest ejected device.
    //
    if ((pBestDock->PhysicalDeviceObject == NULL) ||
        (dockDepth > pBestDock->Depth)) {

        if (pBestDock->PhysicalDeviceObject) {

            ObDereferenceObject(pBestDock->PhysicalDeviceObject);
        }

        pBestDock->PhysicalDeviceObject = DeviceNode->PhysicalDeviceObject;
        pBestDock->Depth = dockDepth;

        ObReferenceObject(pBestDock->PhysicalDeviceObject);
    }

    //
    // Continue enumerating.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
PiProfileUpdateDeviceTree(
    VOID
    )
/*++

Routine Description:

    This function is called after the system has transitioned into a new
    hardware profile. The thread from which it is called may be holding an
    enumeration lock. Calling this function does two tasks:

    1) If a disabled devnode in the tree should be enabled in this new hardware
       profile state, it will be started.

    2) If an enabled devnode in the tree should be disabled in this new hardware
       profile state, it will be (surprise) removed.

    ADRIAO N.B. 02/19/1999 -
        Why surprise remove? There are four cases to be handled:
        a) Dock disappearing, need to enable device in new profile
        b) Dock appearing, need to enable device in new profile
        c) Dock disappearing, need to disable device in new profile
        d) Dock appearing, need to disable device in new profile

        a) and b) are trivial. c) involves treating the appropriate devices as
        if they were in the removal relation lists for the dock. d) is another
        matter altogether as we need to query-remove/remove devices before
        starting another. NT5's PnP state machine cannot handle this, so for
        this release we cleanup rather hastily after the profile change.

Parameters:

    NONE.

Return Value:

    NTSTATUS.

--*/
{
    PWORK_QUEUE_ITEM workQueueItem;

    PAGED_CODE();

    workQueueItem = (PWORK_QUEUE_ITEM) ExAllocatePool(
        NonPagedPool,
        sizeof(WORK_QUEUE_ITEM)
        );

    if (workQueueItem) {

        //
        // Queue this up so we can walk the tree outside of the enumeration lock.
        //
        ExInitializeWorkItem(
            workQueueItem,
            PiProfileUpdateDeviceTreeWorker,
            workQueueItem
            );

        ExQueueWorkItem(
            workQueueItem,
            CriticalWorkQueue
            );

        return STATUS_SUCCESS;

    } else {

        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


VOID
PiProfileUpdateDeviceTreeWorker(
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called on a work thread by PiProfileUpdateDeviceTree
    when the system has transitioned to a new hardware profile.

Parameters:

    NONE.

Return Value:

    NONE.

--*/
{
    PAGED_CODE();

    PpDevNodeLockTree(PPL_TREEOP_ALLOW_READS);
    PipForAllDeviceNodes(PiProfileUpdateDeviceTreeCallback, NULL);
    PpDevNodeUnlockTree(PPL_TREEOP_ALLOW_READS);

    ExFreePool(Context);
}


NTSTATUS
PiProfileUpdateDeviceTreeCallback(
    IN PDEVICE_NODE DeviceNode,
    IN PVOID Context
    )
/*++

Routine Description:

    This function is called for each devnode after the system has transitioned
    hardware profile states.

Parameters:

    NONE.

Return Value:

    NONE.

--*/
{
    PDEVICE_NODE parentDevNode;

    UNREFERENCED_PARAMETER( Context );

    PAGED_CODE();

    if (DeviceNode->State == DeviceNodeStarted) {

        //
        // Calling this function will disable the device if it is appropriate
        // to do so.
        //
        if (!IopIsDeviceInstanceEnabled(NULL, &DeviceNode->InstancePath, FALSE)) {

            PipRequestDeviceRemoval(DeviceNode, FALSE, CM_PROB_DISABLED);
        }

    } else if (((DeviceNode->State == DeviceNodeInitialized) ||
                (DeviceNode->State == DeviceNodeRemoved)) &&
               PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED)) {

        //
        // We might be turning on the device. So we will clear the problem
        // flags iff the device problem was CM_PROB_DISABLED. We must clear the
        // problem code or otherwise IopIsDeviceInstanceEnabled will ignore us.
        //
        PipClearDevNodeProblem(DeviceNode);

        //
        // Make sure the device stays down iff appropriate.
        //
        if (IopIsDeviceInstanceEnabled(NULL, &DeviceNode->InstancePath, FALSE)) {

            //
            // This device should come back online. Bring it out of the
            // removed state and queue up an enumeration at the parent level
            // to resurrect him.
            //
            IopRestartDeviceNode(DeviceNode);

            parentDevNode = DeviceNode->Parent;

            IoInvalidateDeviceRelations(
                parentDevNode->PhysicalDeviceObject,
                BusRelations
                );

        } else {

            //
            // Restore the problem code.
            //
            PipSetDevNodeProblem(DeviceNode, CM_PROB_DISABLED);
        }

    } else {

         ASSERT((!PipIsDevNodeProblem(DeviceNode, CM_PROB_DISABLED)) ||
                ((DeviceNode->State == DeviceNodeAwaitingQueuedRemoval) ||
                 (DeviceNode->State == DeviceNodeAwaitingQueuedDeletion)));
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PpProfile.h

Abstract:

    This header contains prototypes for managing hardware profiles and
    docking stations.

Author:

    Adrian J. Oney (AdriaO) 07/19/2000

Revision History:

--*/

typedef enum _HARDWARE_PROFILE_BUS_TYPE {

    HardwareProfileBusTypeACPI

} HARDWARE_PROFILE_BUS_TYPE, *PHARDWARE_PROFILE_BUS_TYPE;

VOID
PpProfileInit(
    VOID
    );

VOID
PpProfileBeginHardwareProfileTransition(
    IN BOOLEAN SubsumeExistingDeparture
    );

VOID
PpProfileIncludeInHardwareProfileTransition(
    IN  PDEVICE_NODE    DeviceNode,
    IN  PROFILE_STATUS  ChangeInPresence
    );

NTSTATUS
PpProfileQueryHardwareProfileChange(
    IN  BOOLEAN                     SubsumeExistingDeparture,
    IN  PROFILE_NOTIFICATION_TIME   NotificationTime,
    OUT PPNP_VETO_TYPE              VetoType,
    OUT PUNICODE_STRING             VetoName OPTIONAL
    );

VOID
PpProfileCommitTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    );

VOID
PpProfileCancelTransitioningDock(
    IN PDEVICE_NODE     DeviceNode,
    IN PROFILE_STATUS   ChangeInPresence
    );

VOID
PpProfileCancelHardwareProfileTransition(
    VOID
    );

VOID
PpProfileMarkAllTransitioningDocksEjected(
    VOID
    );

PDEVICE_OBJECT
PpProfileRetrievePreferredDockToEject(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\remlock.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:



Revision History:

--*/

#define IO_REMOVE_LOCK_SIG     'COLR'

typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK {
    struct _IO_REMOVE_LOCK_TRACKING_BLOCK * Link;
    PVOID           Tag;
    LARGE_INTEGER   TimeLocked;
    PCSTR           File;
    ULONG           Line;
} IO_REMOVE_LOCK_TRACKING_BLOCK, *PIO_REMOVE_LOCK_TRACKING_BLOCK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\regstrp.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    regstrp.h

Abstract:

    This module contains the registry strings for keys, paths and values,
    that are not already defined in the system regstr.h file.  This is
    generally the "NT" specific registry strings. This module is used by
    kernel mode Pnp managers only.

Author:

    Shie-Lin Tzong (shielint) 10/03/1995


Revision History:


--*/

#ifndef _KERNEL_REGSTRP_H_
#define _KERNEL_REGSTRP_H_

#undef TEXT
#define TEXT(quote) L##quote

#define _IN_KERNEL_
#include <regstr.h>
#include <pnpmgr.h>

//
// Redefine the names used in regstr.h

#define REGSTR_VALUE_SLOTNUMBER                     REGSTR_VAL_SLOTNUMBER
#define REGSTR_VALUE_ATTACHEDCOMPONENTS             REGSTR_VAL_ATTACHEDCOMPONENTS
#define REGSTR_VALUE_BASEDEVICEPATH                 REGSTR_VAL_BASEDEVICEPATH
#define REGSTR_VALUE_SYSTEMBUSNUMBER                REGSTR_VAL_SYSTEMBUSNUMBER
#define REGSTR_VALUE_BUSDATATYPE                    REGSTR_VAL_BUSDATATYPE
#define REGSTR_VALUE_INTERFACETYPE                  REGSTR_VAL_INTERFACETYPE
#define REGSTR_VALUE_SERVICE                        REGSTR_VAL_SERVICE
#define REGSTR_VALUE_DETECTSIGNATURE                REGSTR_VAL_DETECTSIGNATURE
#define REGSTR_VALUE_INSTANCEIDENTIFIER             REGSTR_VAL_INSTANCEIDENTIFIER
#define REGSTR_VALUE_DUPLICATEOF                    REGSTR_VAL_DUPLICATEOF
#define REGSTR_VALUE_STATUSFLAGS                    REGSTR_VAL_STATUSFLAGS
#define REGSTR_VALUE_UNKNOWNPROBLEMS                REGSTR_VAL_UNKNOWNPROBLEMS
#define REGSTR_VALUE_FRIENDLYNAME                   REGSTR_VAL_FRIENDLYNAME
#define REGSTR_VALUE_UPPERFILTERS                   REGSTR_VAL_UPPERFILTERS
#define REGSTR_VALUE_LOWERFILTERS                   REGSTR_VAL_LOWERFILTERS
#define REGSTR_VALUE_REMOVAL_POLICY                 REGSTR_VAL_REMOVAL_POLICY

//
// kernel mode specific definitions
//
#define REGSTR_VALUE_LOCATION_INFORMATION            REGSTR_VAL_LOCATION_INFORMATION
#define REGSTR_VALUE_CAPABILITIES                    REGSTR_VAL_CAPABILITIES
#define REGSTR_VALUE_UI_NUMBER                       REGSTR_VAL_UI_NUMBER
#define REGSTR_VALUE_HARDWAREID                      REGSTR_VAL_HARDWAREID
#define REGSTR_VALUE_COMPATIBLEIDS                   REGSTR_VAL_COMPATIBLEIDS
#define REGSTR_VALUE_CLASSGUID                       REGSTR_VAL_CLASSGUID
#define REGSTR_VALUE_DEVICE_IDS                      TEXT("DeviceIDs")
#define REGSTR_VALUE_COUNT                           TEXT("Count")
#define REGSTR_KEY_INSTANCE_KEY_FORMAT               TEXT("%04u")
#define REGSTR_VALUE_STANDARD_ULONG_FORMAT           TEXT("%u")
#define REGSTR_VALUE_GROUP                           TEXT("Group")
#define REGSTR_VALUE_NT_PHYSICAL_DEVICE_PATHS        TEXT("NtPhysicalDevicePaths")
#define REGSTR_VALUE_NT_LOGICAL_DEVICE_PATHS         TEXT("NtLogicalDevicePaths")
#define REGSTR_VALUE_STATIC                          TEXT("Static")
#define REGSTR_VALUE_NEXT_INSTANCE                   TEXT("NextInstance")
#define REGSTR_KEY_MADEUP                            TEXT("LEGACY_")
#define REGSTR_VALUE_CSCONFIG_FLAGS                  REGSTR_VAL_CSCONFIGFLAGS
#define REGSTR_PATH_CONTROL_IDCONFIGDB               TEXT("Control\\IDConfigDB")
#define REGSTR_VALUE_CURRENT_CONFIG                  REGSTR_VAL_CURCONFIG
#define REGSTR_KEY_BIB_FORMAT                        TEXT("*BIB%04X")
#define REGSTR_VALUE_INTERFACE_TYPE_FORMAT           TEXT("InterfaceType%04u")
#define REGSTR_PATH_CONTROL_CLASS                    TEXT("Control\\Class")
#define REGSTR_VALUE_CLASS                           REGSTR_VAL_CLASS
#define REGSTR_PATH_SYSTEM_RESOURCES_BUS_VALUES      TEXT("Control\\SystemResources\\BusValues")
#define REGSTR_VALUE_DEVICE_STATUS_FORMAT            TEXT("DeviceStatus%u")
#define REGSTR_VALUE_DRIVER                          REGSTR_VAL_DRIVER
#define REGSTR_VALUE_HTREE_ROOT_0                    REGSTR_VAL_ROOT_DEVNODE
// #define REGSTR_VALUE_UNKNOWN_CLASS_GUID              TEXT("{4D36E97E-E325-11CE-BFC1-08002BE10318}")
#define REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID        TEXT("{8ECC055D-047F-11D1-A537-0000F8753ED1}")
// DEFINE_GUID(REGSTR_VALUE_LEGACY_DRIVER_CLASS_GUID, 0x8ECC055D, 0x047F, 0x11D1, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);
// #define REGSTR_VALUE_UNKNOWN                         TEXT("Unknown")
#define REGSTR_VALUE_LEGACY_DRIVER                   TEXT("LegacyDriver")
#define REGSTR_VALUE_DISPLAY_NAME                    REGSTR_VAL_UNINSTALLER_DISPLAYNAME
#define REGSTR_VALUE_DEVICE_DESC                     REGSTR_VAL_DEVDESC
#define REGSTR_VALUE_PROBLEM                         REGSTR_VAL_PROBLEM
#define REGSTR_VALUE_CONFIG_FLAGS                    REGSTR_VAL_CONFIGFLAGS
#define REGSTR_VALUE_NEWLY_CREATED                   TEXT("*NewlyCreated*")
#define REGSTR_VALUE_MIGRATED                        TEXT("Migrated")
#define REGSTR_KEY_LOG_CONF                          TEXT("LogConf")
#define REGSTR_VALUE_ALLOC_CONFIG                    TEXT("AllocConfig")
#define REGSTR_VALUE_FORCED_CONFIG                   TEXT("ForcedConfig")
#define REGSTR_VALUE_BOOT_CONFIG                     TEXT("BootConfig")
#define REGSTR_VALUE_FILTERED_CONFIG_VECTOR          TEXT("FilteredConfigVector")
#define REGSTR_VALUE_OVERRIDE_CONFIG_VECTOR          TEXT("OverrideConfigVector")
#define REGSTR_VALUE_BASIC_CONFIG_VECTOR             TEXT("BasicConfigVector")
#define REGSTR_VALUE_DEVICE_REPORTED                 TEXT("DeviceReported")
#define REGSTR_VALUE_DETECTED_DEVICE                 TEXT("PhysicalDeviceObject")
#define REGSTR_VALUE_LEGACY                          TEXT("Legacy")
#define REGSTR_VALUE_NO_RESOURCE_AT_INIT             TEXT("NoResourceAtInitTime")
#define PNPMGR_STR_PNP_MANAGER                       TEXT("PnP Manager")
#define PNPMGR_STR_PNP_DRIVER                        TEXT("\\Driver\\PnpManager")    // Must be the same
#define REGSTR_KEY_PNP_DRIVER                        TEXT("PnpManager")              // Must be the same
#define REGSTR_FULL_PATH_DEVICE_CLASSES              TEXT("\\Registry\\Machine\\") REGSTR_PATH_DEVICE_CLASSES
#define REGSTR_PATH_CONTROL_PNP                      TEXT("Control\\Pnp")
#define REGSTR_KEY_PARAMETERS                        TEXT("Parameters")
#define REGSTR_VALUE_NEXT_PARENT_ID                  TEXT("NextParentID")
#define REGSTR_VALUE_BUS_TYPE_GUID                   TEXT("BusTypeGuid")
#define REGSTR_VALUE_DISABLE_FIRMWARE_MAPPER         TEXT("DisableFirmwareMapper")
#define REGSTR_VAL_REFERENCECOUNT                    TEXT("ReferenceCount")
#define REGSTR_VAL_FIRMWAREDISABLED                  TEXT("FirmwareDisabled")
#define REGSTR_VAL_WIN2000STARTORDER                 TEXT("Win2000StartOrder")
#endif // _KERNEL_REGSTRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\remlock.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    remlock.c

Abstract:

    This code implements remove locks.

Authors:

    Peter Wieland
    Kenneth Ray

Environment:

    kernel mode only

Notes:



Revision History:

--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <remlock.h>

#pragma alloc_text(PAGE, IoInitializeRemoveLockEx)
#pragma alloc_text(PAGE, IoReleaseRemoveLockAndWaitEx)

#define MinutesToTicks(x) \
        (ULONGLONG) KeQueryTimeIncrement() * \
        10 * \
        1000 * \
        1000 * \
        60 * \
        x

// 10 -> microseconds, 1000 -> miliseconds, 1000 -> seconds, 60 -> minutes


typedef struct _IO_PRIVATE_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
} IO_PRIVATE_REMOVE_LOCK, *PIO_PRIVATE_REMOVE_LOCK;


#define FREESIZE sizeof (IO_REMOVE_LOCK_COMMON_BLOCK)
#define CHECKEDSIZE sizeof (IO_PRIVATE_REMOVE_LOCK)


NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK PublicLock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    )
/*++

Routine Description:

    This routine is called to initialize the remove lock for a device object.

--*/
{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;

    PAGED_CODE ();

    if (Lock) {

        switch (RemlockSize) {

        case CHECKEDSIZE:
            Lock->Dbg.Signature = IO_REMOVE_LOCK_SIG;
            Lock->Dbg.HighWatermark = HighWatermark;
            Lock->Dbg.MaxLockedTicks = MinutesToTicks (MaxLockedMinutes);
            Lock->Dbg.AllocateTag = AllocateTag;
            KeInitializeSpinLock (&Lock->Dbg.Spin);
            Lock->Dbg.LowMemoryCount = 0;
            Lock->Dbg.Blocks = NULL;

            //
            // fall through
            //
        case FREESIZE:
            Lock->Common.Removed = FALSE;
            Lock->Common.IoCount = 1;
            KeInitializeEvent(&Lock->Common.RemoveEvent,
                              SynchronizationEvent,
                              FALSE);
            break;

        default:
            break;
        }
    }
}


NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx(
    IN PIO_REMOVE_LOCK PublicLock,
    IN OPTIONAL PVOID   Tag,
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called to acquire the remove lock for a device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

Arguments:

    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

    File - set to __FILE__ as the location in the code where the lock was taken.

    Line - set to __LINE__.

Return Value:

    Returns whether or not the remove lock was obtained.
    If successful the caller should continue with work calling
    IoReleaseRemoveLock when finished.

    If not successful the lock was not obtained.  The caller should abort the
    work but not call IoReleaseRemoveLock.

--*/

{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG        lockValue;
    NTSTATUS    status;

    PIO_REMOVE_LOCK_TRACKING_BLOCK trackingBlock;

    //
    // Grab the remove lock
    //

    lockValue = InterlockedIncrement(&Lock->Common.IoCount);

    ASSERTMSG("IoAcquireRemoveLock - lock value was negative : ",
              (lockValue > 0));

    if (! Lock->Common.Removed) {

        switch (RemlockSize) {
        case CHECKEDSIZE:

            ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
                      ((0 == Lock->Dbg.HighWatermark) ||
                       (lockValue <= Lock->Dbg.HighWatermark)));

            trackingBlock = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(IO_REMOVE_LOCK_TRACKING_BLOCK),
                                Lock->Dbg.AllocateTag);

            if (NULL == trackingBlock) {

                // ASSERTMSG ("insufficient resources", FALSE);
                InterlockedIncrement (& Lock->Dbg.LowMemoryCount);
                //
                // Let the acquire go through but without adding the
                // tracking block.
                // When we are later releasing the lock, but the tracking
                // block does not exist, deduct from this value to see if the
                // release was still valuable.
                //

            } else {

                KIRQL oldIrql;

                RtlZeroMemory (trackingBlock,
                               sizeof (IO_REMOVE_LOCK_TRACKING_BLOCK));

                trackingBlock->Tag = Tag;
                trackingBlock->File = File;
                trackingBlock->Line = Line;

                KeQueryTickCount(&trackingBlock->TimeLocked);

                ExAcquireSpinLock (&Lock->Dbg.Spin, &oldIrql);
                trackingBlock->Link = Lock->Dbg.Blocks;
                Lock->Dbg.Blocks = trackingBlock;
                ExReleaseSpinLock(&Lock->Dbg.Spin, oldIrql);
            }
            break;

        case FREESIZE:
            break;

        default:
            break;
        }

        status = STATUS_SUCCESS;

    } else {

        if (0 == InterlockedDecrement (&Lock->Common.IoCount)) {
            KeSetEvent (&Lock->Common.RemoveEvent, 0, FALSE);
        }
        status = STATUS_DELETE_PENDING;
    }

    return status;
}


NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK PublicLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    event to release the waiting thread deleting the device object protected
    by this lock.

Arguments:

    DeviceObject - the device object to lock

    Tag - The tag (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/

{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG            lockValue;
    KIRQL           oldIrql;
    LARGE_INTEGER   ticks;
    LONGLONG        difference;
    BOOLEAN         found;

    PIO_REMOVE_LOCK_TRACKING_BLOCK last;
    PIO_REMOVE_LOCK_TRACKING_BLOCK current;

    switch (RemlockSize) {
    case CHECKEDSIZE:

        //
        // Check the tick count and make sure this thing hasn't been locked
        // for more than MaxLockedMinutes.
        //

        found = FALSE;
        ExAcquireSpinLock(&Lock->Dbg.Spin, &oldIrql);
        last = (Lock->Dbg.Blocks);
        current = last;

        KeQueryTickCount((&ticks));

        while (NULL != current) {

            if (Lock->Dbg.MaxLockedTicks) {
                difference = ticks.QuadPart - current->TimeLocked.QuadPart;

                if (Lock->Dbg.MaxLockedTicks < difference) {

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoReleaseRemoveLock: Lock %#08lx (tag %#08lx) "
                                    "locked for %I64d ticks - TOO LONG\n",
                                    Lock,
                                    current->Tag,
                                    difference));

                    IopDbgPrint((   IOP_ERROR_LEVEL,
                                    "IoReleaseRemoveLock: Lock acquired in file "
                                    "%s on line %d\n",
                                    current->File,
                                    current->Line));
                    ASSERT(FALSE);
                }
            }

            if ((!found) && (current->Tag == Tag)) {
                found = TRUE;
                if (current == Lock->Dbg.Blocks) {
                    Lock->Dbg.Blocks = current->Link;
                    ExFreePool (current);
                    current = Lock->Dbg.Blocks;
                } else {
                    last->Link = current->Link;
                    ExFreePool (current);
                    current = last->Link;
                }
                continue;
            }

            last = current;
            current = current->Link;
        }

        ExReleaseSpinLock(&Lock->Dbg.Spin, oldIrql);

        if (!found) {
            //
            // Check to see if we have any credits in our Low Memory Count.
            // In this fassion we can tell if we have acquired any locks without
            // the memory for adding tracking blocks.
            //
            if (InterlockedDecrement (& Lock->Dbg.LowMemoryCount) < 0) {
                //
                // We have just released a lock that neither had a corresponding
                // tracking block, nor a credit in LowMemoryCount.
                //
                InterlockedIncrement (& Lock->Dbg.LowMemoryCount);
                IopDbgPrint ((  IOP_ERROR_LEVEL,
                                "IoReleaseRemoveLock: Couldn't find Tag %#08lx "
                                "in the lock tracking list\n",
                                Tag));
                ASSERT(FALSE);
            }
        }
        break;

    case FREESIZE:
        break;

    default:
        break;
    }

    lockValue = InterlockedDecrement(&Lock->Common.IoCount);

    ASSERT(0 <= lockValue);

    if (0 == lockValue) {

        ASSERT (Lock->Common.Removed);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        KeSetEvent(&Lock->Common.RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    return;
}


NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx (
    IN PIO_REMOVE_LOCK PublicLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    )

/*++

Routine Description:

    This routine is called when the client would like to delete the remove-
    locked resource.
    This routine will block until all the remove locks have completed.

    This routine MUST be called after acquiring once more the lock.

Arguments:

    RemoveLock -

Return Value:

    none

--*/
{
    PIO_PRIVATE_REMOVE_LOCK Lock = (PIO_PRIVATE_REMOVE_LOCK) PublicLock;
    LONG    ioCount;

    PAGED_CODE ();

    Lock->Common.Removed = TRUE;

    ioCount = InterlockedDecrement (&Lock->Common.IoCount);
    ASSERT (0 < ioCount);

    if (0 < InterlockedDecrement (&Lock->Common.IoCount)) {
        KeWaitForSingleObject (&Lock->Common.RemoveEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);
    }

    switch (RemlockSize) {
    case CHECKEDSIZE:

        ASSERT (Lock->Dbg.Blocks);
        if (Tag != Lock->Dbg.Blocks->Tag) {
            IopDbgPrint ((  IOP_ERROR_LEVEL,
                            "IoRelaseRemoveLockAndWait last tag invalid %x %x\n",
                            Tag,
                            Lock->Dbg.Blocks->Tag));

            ASSERT (Tag != Lock->Dbg.Blocks->Tag);
        }

        ExFreePool (Lock->Dbg.Blocks);
        break;

    case FREESIZE:
        break;

    default:
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppvutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ppvutil.h

Abstract:

    This header exposes various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.h

--*/

#ifndef _PPVUTIL_H_
#define _PPVUTIL_H_

typedef enum {

    PPVERROR_DUPLICATE_PDO_ENUMERATED           = 0,
    PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
    PPVERROR_DDI_REQUIRES_PDO

} PPVFAILURE_TYPE;

typedef enum {

    PPVREMOVAL_SHOULD_DELETE           = 0,
    PPVREMOVAL_SHOULDNT_DELETE,
    PPVREMOVAL_MAY_DEFER_DELETION

} PPVREMOVAL_OPTION;

VOID
FASTCALL
PpvUtilInit(
    VOID
    );

NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    );

VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PPVREMOVAL_OPTION
FASTCALL
PpvUtilGetDevnodeRemovalOption(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    );

BOOLEAN
FASTCALL
PpvUtilIsHardwareBeingVerified(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

#endif // _PPVUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\ppvutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ppvutil.c

Abstract:

    This module implements various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\trackirp.c

--*/

#include "pnpmgrp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, PpvUtilInit)
//#pragma alloc_text(PAGEVRFY, PpvUtilFailDriver)
//#pragma alloc_text(PAGEVRFY, PpvUtilCallAddDevice)
//#pragma alloc_text(PAGEVRFY, PpvUtilTestStartedPdoStack)

#ifndef NO_VERIFIER
#pragma alloc_text(PAGEVRFY, PpvUtilGetDevnodeRemovalOption)
#pragma alloc_text(PAGEVRFY, PpvUtilIsHardwareBeingVerified)
#endif // NO_VERIFIER

#endif // ALLOC_PRAGMA


//
// This entire implementation is specific to the verifier
//
#ifndef NO_VERIFIER

BOOLEAN PpvUtilVerifierEnabled = FALSE;


VOID
FASTCALL
PpvUtilInit(
    VOID
    )
{
    PpvUtilVerifierEnabled = TRUE;
}


NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    )
{
    NTSTATUS status;

    if (!PpvUtilVerifierEnabled) {

        return AddDeviceFunction(DriverObject, PhysicalDeviceObject);
    }

    //
    // Notify the verifier prior to AddDevice
    //
    VfDevObjPreAddDevice(
        PhysicalDeviceObject,
        DriverObject,
        AddDeviceFunction,
        DevObjType
        );

    status = AddDeviceFunction(DriverObject, PhysicalDeviceObject);

    //
    // Let the verifier know how it turned out.
    //
    VfDevObjPostAddDevice(
        PhysicalDeviceObject,
        DriverObject,
        AddDeviceFunction,
        DevObjType,
        status
        );

    return status;
}


VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    if (PpvUtilVerifierEnabled) {

        VfMajorTestStartedPdoStack(DeviceObject);
    }
}


VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    )
{
    if (!PpvUtilVerifierEnabled) {

        return;
    }

    switch(FailureType) {

        case PPVERROR_DUPLICATE_PDO_ENUMERATED:
            WDM_FAIL_ROUTINE((
                DCERROR_DUPLICATE_ENUMERATION,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ*2,
                CulpritAddress,
                DeviceObject,
                ExtraneousInfo
                ));
            break;

        case PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS:
            WDM_FAIL_ROUTINE((
                DCERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                CulpritAddress,
                DeviceObject
                ));
            break;

        case PPVERROR_DDI_REQUIRES_PDO:
            WDM_FAIL_ROUTINE((
                DCERROR_DDI_REQUIRES_PDO,
                DCPARAM_ROUTINE + DCPARAM_DEVOBJ,
                CulpritAddress,
                DeviceObject
                ));
            break;

        default:
            break;
    }
}


PPVREMOVAL_OPTION
FASTCALL
PpvUtilGetDevnodeRemovalOption(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
{
    PDEVICE_NODE devNode;

    devNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    if (devNode == NULL) {

        //
        // This must be PartMgr device, we have no opinion
        //
        return PPVREMOVAL_MAY_DEFER_DELETION;
    }

    if (devNode->Flags & DNF_ENUMERATED) {

        //
        // It's still present, so it mustn't delete itself.
        //
        return PPVREMOVAL_SHOULDNT_DELETE;

    } else if (devNode->Flags & DNF_DEVICE_GONE) {

        //
        // It's been reported missing, it must delete itself now as it's parent
        // may already have been removed.
        //
        return PPVREMOVAL_SHOULD_DELETE;

    } else {

        //
        // Corner case - in theory it should delete itself, but it's parent
        // will get a remove immediately after it does. As such it can defer
        // it's deletion.
        //
        return PPVREMOVAL_MAY_DEFER_DELETION;
    }
}


BOOLEAN
FASTCALL
PpvUtilIsHardwareBeingVerified(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    )
{
    PDEVICE_NODE devNode;

    if (!IS_PDO(PhysicalDeviceObject)) {

        return FALSE;
    }

    devNode = PhysicalDeviceObject->DeviceObjectExtension->DeviceNode;

    return ((devNode->Flags & DNF_HARDWARE_VERIFICATION) != 0);
}


#else // NO_VERIFIER


//
// The code below should be built into a future stub that deadens out IO
// support for the verifier.
//

VOID
FASTCALL
PpvUtilInit(
    VOID
    )
{
}


NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    )
{
    UNREFERENCED_PARAMETER(DevObjType);

    return AddDeviceFunction(DriverObject, PhysicalDeviceObject);
}


VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    )
{
    UNREFERENCED_PARAMETER(DeviceObject);
}


VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FailureType);
    UNREFERENCED_PARAMETER(CulpritAddress);
    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(ExtraneousInfo);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=io

TARGETNAME=pnpmgr
TARGETTYPE=LIBRARY
TARGETPATH=obj

# MSC_WARNING_LEVEL=/W4

INCLUDES=..;..\..;\
         ..\..\..\inc;\
         ..\..\..\pnp;\
         $(WINDOWS_INC_PATH);\
         $(DDK_INC_PATH);\
         $(NET_INC_PATH);\
         $(HALKIT_INC_PATH)

SOURCES=   \
        ..\assign.c   \
        ..\devices.c  \
        ..\devnode.c  \
        ..\devintrf.c \
        ..\dockhwp.c  \
        ..\iofileutil.c \
        ..\mapper.c   \
        ..\notify.c   \
        ..\pnpbusno.c \
        ..\pnpcvrt.c  \
        ..\pnpdata.c  \
        ..\pnpdd.c    \
        ..\pnpdel.c   \
        ..\pnpdma.c   \
        ..\pnpeisa.c  \
        ..\pnpenum.c  \
        ..\pnpevent.c  \
        ..\pnpinit.c  \
        ..\pnpioapi.c \
        ..\pnpirp.c   \
        ..\pnpirq.c   \
        ..\pnpmap.c   \
        ..\pnpmemio.c \
        ..\pnppower.c \
        ..\pnpres.c   \
        ..\pnprlist.c \
        ..\pnpstart.c  \
        ..\pnpsubs.c  \
        ..\ppcontrol.c  \
        ..\pphandle.c \
        ..\pphotswap.c \
        ..\pplastgood.c \
        ..\pppagepath.c \
        ..\ppdrvdb.c \
        ..\ppprofile.c  \
        ..\ppvutil.c \
        ..\remlock.c \
        ..\report.c

NTTEST=

PRECOMPILED_INCLUDE=..\pnpmgrp.h
PRECOMPILED_PCH=pnpmgrp.pch
PRECOMPILED_OBJ=pnpmgrp.obj

#  SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\report.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains the subroutines used to report resources used by
    the drivers and the HAL into the registry resource map.

Author:

    Andre Vachon (andreva) 15-Dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "pnpmgrp.h"
#pragma hdrstop

#include <hdlsblk.h>
#include <hdlsterm.h>

#define DBG_AR 0

#define MAX_MEMORY_RUN_LENGTH   ((ULONG)~(PAGE_SIZE - 1))

extern const WCHAR IopWstrRaw[];
extern const WCHAR IopWstrTranslated[];
extern const WCHAR IopWstrBusTranslated[];
extern const WCHAR IopWstrOtherDrivers[];

extern const WCHAR IopWstrHal[];
extern const WCHAR IopWstrSystem[];
extern const WCHAR IopWstrPhysicalMemory[];
extern const WCHAR IopWstrSpecialMemory[];
extern const WCHAR IopWstrLoaderReservedMemory[];

BOOLEAN
IopChangeInterfaceType(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST IoResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResource
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoReportResourceUsageInternal)
#pragma alloc_text(PAGE, IoReportResourceUsage)
#pragma alloc_text(PAGE, IoReportResourceForDetection)
#pragma alloc_text(PAGE, IopChangeInterfaceType)
#pragma alloc_text(PAGE, IopWriteResourceList)
#pragma alloc_text(INIT, IopInitializeResourceMap)
#pragma alloc_text(INIT, IoReportHalResourceUsage)
#endif


VOID
IopInitializeResourceMap (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

    Initializes the resource map by adding in the physical memory
    which is in use by the system.

--*/
{
    ULONG i, j, pass, length;
    LARGE_INTEGER li;
    HANDLE keyHandle;
    UNICODE_STRING  unicodeString, systemString, listString;
    NTSTATUS status;
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    BOOLEAN IncludeType[LoaderMaximum];
    PPHYSICAL_MEMORY_DESCRIPTOR MemoryBlock;
    LONGLONG rangeLength;

    RtlInitUnicodeString( &systemString,  IopWstrSystem);
    for (pass=0; pass < 3; pass += 1) {
        switch (pass) {
            case 0:
                //
                // Add MmPhysicalMemoryBlock to registry
                //

                RtlInitUnicodeString( &unicodeString, IopWstrPhysicalMemory);
                RtlInitUnicodeString( &listString, IopWstrTranslated );

                MemoryBlock = MmPhysicalMemoryBlock;
                break;

            case 1:

                //
                // Add LoaderSpecialMemory and LoaderHALCachedMemory
                // to registry
                //

                RtlInitUnicodeString( &unicodeString, IopWstrSpecialMemory);
                RtlInitUnicodeString( &listString, IopWstrTranslated );

                //
                // Compute memory limits of LoaderSpecialMemory and
                // LoaderHalCachedMemory
                //

                for (j=0; j < LoaderMaximum; j += 1) {
                    IncludeType[j] = FALSE;
                }
                IncludeType[LoaderSpecialMemory] = TRUE;
                IncludeType[LoaderHALCachedMemory] = TRUE;

                MemoryBlock = MmInitializeMemoryLimits (LoaderBlock,
                                                        IncludeType,
                                                        NULL);

                if (MemoryBlock == NULL) {
                    continue;
                }

                break;
            case 2:
                
                //
                // Create registry key that includes:
                //     LoaderBad
                //     LoaderFirmwarePermanent
                //     LoaderSpecialMemory
                //     LoaderBBTMemory
                //     LoaderHALCachedMemory
                //

                RtlInitUnicodeString( &unicodeString, IopWstrLoaderReservedMemory);
                RtlInitUnicodeString( &listString, IopWstrRaw );

                //
                // Compute memory limits of specified loader memory
                // descriptors.
                //

                for (j=0; j < LoaderMaximum; j += 1) {
                    IncludeType[j] = FALSE;
                }
                IncludeType[LoaderBad] = TRUE;
                IncludeType[LoaderFirmwarePermanent] = TRUE;
                IncludeType[LoaderSpecialMemory] = TRUE;
                IncludeType[LoaderBBTMemory] = TRUE;
                IncludeType[LoaderHALCachedMemory] = TRUE;

                MemoryBlock = MmInitializeMemoryLimits (LoaderBlock,
                                                        IncludeType,
                                                        NULL);

                if (MemoryBlock == NULL) {
                    return;
                }
                
                break;
        }

        //
        // Allocate and build a CM_RESOURCE_LIST to describe all
        // of physical memory
        //

        j = MemoryBlock->NumberOfRuns;
        if (j == 0) {
            if (pass != 0) {
                ExFreePool (MemoryBlock);
            }
            continue;
        }

        //
        // This is to take care of systems where individual memory run can 
        // exceed 4G since our current descriptors only have 32-bit length.
        // Account for runs with length > MAX_MEMORY_RUN_LENGTH by splitting
        // them into lengths <= MAX_MEMORY_RUN_LENGTH.
        //

        for (i = 0; i < MemoryBlock->NumberOfRuns; i += 1) {

            rangeLength = ((LONGLONG)MemoryBlock->Run[i].PageCount) << PAGE_SHIFT;
            while ((rangeLength -= MAX_MEMORY_RUN_LENGTH) > 0) {
                j += 1;
            }
        }

        length = sizeof(CM_RESOURCE_LIST) + (j-1) * sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR);
        ResourceList = (PCM_RESOURCE_LIST) ExAllocatePool (PagedPool, length);
        if (!ResourceList) {
            if (pass != 0) {
                ExFreePool (MemoryBlock);
            }
            return;
        }
        RtlZeroMemory ((PVOID) ResourceList, length);

        ResourceList->Count = 1;
        ResourceList->List[0].PartialResourceList.Count = j;
        CmDescriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

        for (i=0; i < MemoryBlock->NumberOfRuns; i += 1) {
            rangeLength = ((LONGLONG)MemoryBlock->Run[i].PageCount) << PAGE_SHIFT;
            li.QuadPart = ((LONGLONG)MemoryBlock->Run[i].BasePage) << PAGE_SHIFT;

            //
            // Split up runs > MAX_MEMORY_RUN_LENGTH into multiple descriptors
            // with lengths <= MAX_MEMORY_RUN_LENGTH. All descriptors (except 
            // the last one) have length = MAX_MEMORY_RUN_LENGTH. Length of the 
            // last one is the remaining portion.
            //

            do {                
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->u.Memory.Start  = li;
                CmDescriptor->u.Memory.Length = MAX_MEMORY_RUN_LENGTH;
                CmDescriptor++;
                li.QuadPart += MAX_MEMORY_RUN_LENGTH;                
            } while ((rangeLength -= MAX_MEMORY_RUN_LENGTH) > 0);
            //
            // Adjust the length of the last one.
            //
            (CmDescriptor - 1)->u.Memory.Length = (ULONG)(rangeLength + MAX_MEMORY_RUN_LENGTH);
        }

        //
        // Add the resource list to the resourcemap
        //

        status = IopOpenRegistryKey( &keyHandle,
                                     (HANDLE) NULL,
                                     &CmRegistryMachineHardwareResourceMapName,
                                     KEY_READ | KEY_WRITE,
                                     TRUE );
        if (NT_SUCCESS( status )) {
            IopWriteResourceList ( keyHandle,
                                   &systemString,
                                   &unicodeString,
                                   &listString,
                                   ResourceList,
                                   length
                                   );
            ZwClose( keyHandle );
        }
        ExFreePool (ResourceList);
        if (pass != 0) {
            ExFreePool (MemoryBlock);
        }
    }
}


NTSTATUS
IoReportHalResourceUsage(
    IN PUNICODE_STRING HalName,
    IN PCM_RESOURCE_LIST RawResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN ULONG ResourceListSize
    )

/*++

Routine Description:

    This routine is called by the HAL to report its resources.
    The HAL is the first component to report its resources, so we don't need
    to acquire the resourcemap semaphore and we do not need to check for
    conflicts.

Arguments:

    HalName - Name of the HAL reporting the resources.

    RawResourceList - Pointer to the HAL's raw resource list.

    TranslatedResourceList - Pointer to the HAL's translated resource list.

    DriverListSize - Value determining the size of the HAL's resource list.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    HANDLE keyHandle;
    UNICODE_STRING halString;
    UNICODE_STRING listString;
    NTSTATUS status;
    PCM_RESOURCE_LIST NewList = NULL;
    ULONG NewListSize;
    PCM_RESOURCE_LIST NewTranslatedList;
    ULONG NewTranslatedListSize;

    PAGED_CODE();

    //
    // First open a handle to the RESOURCEMAP key.
    //

    RtlInitUnicodeString( &halString, IopWstrHal );

    status = IopOpenRegistryKey( &keyHandle,
                                 (HANDLE) NULL,
                                 &CmRegistryMachineHardwareResourceMapName,
                                 KEY_READ | KEY_WRITE,
                                 TRUE );

    //
    // Write out the raw resource list
    //

    if (NT_SUCCESS( status )) {

        RtlInitUnicodeString( &listString, IopWstrRaw);

        //
        // Add any resources that Headless is reserving.
        //
        status = HeadlessTerminalAddResources(RawResourceList,
                                              ResourceListSize,
                                              FALSE,
                                              &NewList,
                                              &NewListSize
                                             );

        if (NT_SUCCESS(status)) {

            status = IopWriteResourceList( keyHandle,
                                           &halString,
                                           HalName,
                                           &listString,
                                           (NewList != NULL) ? NewList : RawResourceList,
                                           (NewList != NULL) ? NewListSize : ResourceListSize
                                         );

        }

        //
        // If we successfully wrote out the raw resource list, write out
        // the translated resource list.
        //

        if (NT_SUCCESS( status )) {

            RtlInitUnicodeString( &listString, IopWstrTranslated);

            //
            // Add any resources that Headless is reserving.
            //
            status = HeadlessTerminalAddResources(TranslatedResourceList,
                                                  ResourceListSize,
                                                  TRUE,
                                                  &NewTranslatedList,
                                                  &NewTranslatedListSize
                                                 );

            if (NT_SUCCESS(status)) {

                status = IopWriteResourceList(keyHandle,
                                              &halString,
                                              HalName,
                                              &listString,
                                              (NewTranslatedList != NULL) ?
                                                   NewTranslatedList : TranslatedResourceList,
                                              (NewTranslatedList != NULL) ?
                                                   NewTranslatedListSize : ResourceListSize
                                             );

                if (NewTranslatedList != NULL) {
                    ExFreePool(NewTranslatedList);
                }

            }

        }

        ZwClose( keyHandle );
    }

    //
    // If every resource looks fine, we will store the copy of the HAL
    // resources so we can call Arbiters to reserve the resources after
    // they are initialized.
    //
    if (NT_SUCCESS(status)) {

        if (NewList != NULL) {

            //
            // An easy way is if headless created a new list for us, just don't free it.
            //
            IopInitHalResources = NewList;

        } else {

            //
            // Otherwise we have to create a copy ourselves.
            //
            IopInitHalResources = (PCM_RESOURCE_LIST) ExAllocatePool(PagedPool,
                                                                     ResourceListSize
                                                                    );
            if (IopInitHalResources != NULL) {
                RtlCopyMemory(IopInitHalResources, RawResourceList, ResourceListSize);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

    } else if (NewList != NULL) {

        //
        // Free any failed list
        //
        ExFreePool(NewList);

    }

    return status;
}

NTSTATUS
IoReportResourceForDetection(
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This routine will automatically search through the configuration
    registry for resource conflicts between resources requested by a device
    and the resources already claimed by previously installed drivers. The
    contents of the DriverList and the DeviceList will be matched against
    all the other resource list stored in the registry to determine
    conflicts.

    The function may be called more than once for a given device or driver.
    If a new resource list is given, the previous resource list stored in
    the registry will be replaced by the new list.

    Note, this function is for the drivers acquiring resources for detection.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the device's
        resource list.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    //
    // Sanity check that the caller did not pass in a PnP PDO.
    //

    if (DeviceObject) {

        if (    DeviceObject->DeviceObjectExtension->DeviceNode &&
                !(((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)DeviceObject, 0, 0);

        }

    }

    return IoReportResourceUsageInternal(   ArbiterRequestPnpDetected,
                                            NULL,
                                            DriverObject,
                                            DriverList,
                                            DriverListSize,
                                            DeviceObject,
                                            DeviceList,
                                            DeviceListSize,
                                            FALSE,
                                            ConflictDetected);
}

NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This routine will automatically search through the configuration
    registry for resource conflicts between resources requested by a device
    and the resources already claimed by previously installed drivers. The
    contents of the DriverList and the DeviceList will be matched against
    all the other resource list stored in the registry to determine
    conflicts.

    If not conflict was detected, or if the OverrideConflict flag is set,
    this routine will create appropriate entries in the system resource map
    (in the registry) that will contain the specified resource lists.

    The function may be called more than once for a given device or driver.
    If a new resource list is given, the previous resource list stored in
    the registry will be replaced by the new list.

Arguments:

    DriverClassName - Optional pointer to a UNICODE_STRING which describes
        the class of driver under which the driver information should be
        stored. A default type is used if none is given.

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    OverrideConflict - Determines if the information should be reported
        in the configuration registry eventhough a conflict was found with
        another driver or device.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    if (DeviceObject) {

        if (    DeviceObject->DeviceObjectExtension->DeviceNode &&
                !(((PDEVICE_NODE)DeviceObject->DeviceObjectExtension->DeviceNode)->Flags & DNF_LEGACY_RESOURCE_DEVICENODE)) {

            PP_SAVE_DRIVEROBJECT_TO_TRIAGE_DUMP(DriverObject);
            PP_SAVE_DEVICEOBJECT_TO_TRIAGE_DUMP(DeviceObject);
            KeBugCheckEx(PNP_DETECTED_FATAL_ERROR, PNP_ERR_INVALID_PDO, (ULONG_PTR)DeviceObject, 0, 0);

        }

    }

    return IoReportResourceUsageInternal(   ArbiterRequestLegacyReported,
                                            DriverClassName,
                                            DriverObject,
                                            DriverList,
                                            DriverListSize,
                                            DeviceObject,
                                            DeviceList,
                                            DeviceListSize,
                                            OverrideConflict,
                                            ConflictDetected);
}

NTSTATUS
IoReportResourceUsageInternal(
    IN ARBITER_REQUEST_SOURCE AllocationType,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    )

/*++

Routine Description:

    This internal routine will do all the work for IoReportResourceUsage.

Arguments:

    AllocationType - Specifies the request type.

    DriverClassName - Optional pointer to a UNICODE_STRING which describes
        the class of driver under which the driver information should be
        stored. A default type is used if none is given.

    DriverObject - Pointer to the driver's driver object.

    DriverList - Optional pointer to the driver's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    DeviceObject - Optional pointer to driver's device object.

    DeviceList - Optional pointer to the device's resource list.

    DriverListSize - Optional value determining the size of the driver's
        resource list.

    OverrideConflict - Determines if the information should be reported
        in the configuration registry eventhough a conflict was found with
        another driver or device.

    ConflictDetected - Supplies a pointer to a boolean that is set to TRUE
        if the resource list conflicts with an already existing resource
        list in the configuration registry.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PCM_RESOURCE_LIST               resourceList;
    PCM_RESOURCE_LIST               allocatedResources;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceRequirements;
    ULONG                           attempt;
    BOOLEAN                         freeAllocatedResources;

    UNREFERENCED_PARAMETER( DriverClassName );
    UNREFERENCED_PARAMETER( DriverListSize );
    UNREFERENCED_PARAMETER( DeviceListSize );
    UNREFERENCED_PARAMETER( OverrideConflict );

    ASSERT(DriverObject && ConflictDetected);

    if (DeviceList) {

        resourceList = DeviceList;

    } else if (DriverList) {

        resourceList = DriverList;

    } else {

        resourceList = NULL;

    }

    resourceRequirements = NULL;

    if (resourceList) {

        if (resourceList->Count && resourceList->List[0].PartialResourceList.Count) {

            resourceRequirements = IopCmResourcesToIoResources (0, resourceList, LCPRI_NORMAL);

            if (resourceRequirements == NULL) {

                return status;

            }

        } else {

            resourceList = NULL;

        }

    }

    *ConflictDetected = TRUE;
    attempt = 0;
    allocatedResources = resourceList;
    freeAllocatedResources = FALSE;
    do {

        //
        // Do the legacy resource allocation.
        //

        status = IopLegacyResourceAllocation (  AllocationType,
                                                DriverObject,
                                                DeviceObject,
                                                resourceRequirements,
                                                &allocatedResources);

        if (NT_SUCCESS(status)) {

            *ConflictDetected = FALSE;
            break;
        }

        //
        // Change the interface type and try again.
        //

        if (!IopChangeInterfaceType(resourceRequirements, &allocatedResources)) {

            break;
        }
        freeAllocatedResources = TRUE;

    } while (++attempt < 2);

    if (resourceRequirements) {

        ExFreePool(resourceRequirements);

    }

    if (freeAllocatedResources) {

        ExFreePool(allocatedResources);
    }

    if (NT_SUCCESS(status)) {

        status = STATUS_SUCCESS;

    } else if (status != STATUS_INSUFFICIENT_RESOURCES) {

        status = STATUS_CONFLICTING_ADDRESSES;

    }

    return status;
}

BOOLEAN
IopChangeInterfaceType(
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST IoResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    )

/*++

Routine Description:

    This routine takes an Io resourcelist and changes its interfacetype
    from internal to default type (isa or eisa or mca).

Arguments:

    IoResources - Pointer to requirement list.

    AllocatedResources - Pointer to a variable that receives the pointer to the resource list.

Return Value:

    BOOLEAN value to indicate if the change was made or not.

--*/

{
    PIO_RESOURCE_LIST       IoResourceList;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR IoResourceDescriptorEnd;
    LONG                    IoResourceListCount;
    BOOLEAN                 changed;

    ASSERT(AllocatedResources);

    changed = FALSE;

    if (!IoResources) {

        return changed;

    }

    if (IoResources->InterfaceType == Internal) {

        IoResources->InterfaceType = PnpDefaultInterfaceType;
        changed = TRUE;

    }

    IoResourceList = IoResources->List;
    IoResourceListCount = IoResources->AlternativeLists;
    while (--IoResourceListCount >= 0) {

        IoResourceDescriptor = IoResourceList->Descriptors;
        IoResourceDescriptorEnd = IoResourceDescriptor + IoResourceList->Count;

        for (;IoResourceDescriptor < IoResourceDescriptorEnd; IoResourceDescriptor++) {

            if (IoResourceDescriptor->Type == CmResourceTypeReserved &&
                IoResourceDescriptor->u.DevicePrivate.Data[0] == Internal) {

                IoResourceDescriptor->u.DevicePrivate.Data[0] = PnpDefaultInterfaceType;
                changed = TRUE;

            }
        }
        IoResourceList = (PIO_RESOURCE_LIST) IoResourceDescriptorEnd;
    }

    if (changed) {

        PCM_RESOURCE_LIST               oldResources = *AllocatedResources;
        PCM_RESOURCE_LIST               newResources;
        PCM_FULL_RESOURCE_DESCRIPTOR    cmFullDesc;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartDesc;
        ULONG                           size;

        if (oldResources) {

            size = IopDetermineResourceListSize(oldResources);
            newResources = ExAllocatePool(PagedPool, size);
            if (newResources == NULL) {

                changed = FALSE;

            } else {

                ULONG   i;
                ULONG   j;


                RtlCopyMemory(newResources, oldResources, size);

                //
                // Fix up the interface type
                //

                cmFullDesc = &newResources->List[0];
                for (i = 0; i < oldResources->Count; i++) {

                    if (cmFullDesc->InterfaceType == Internal) {

                        cmFullDesc->InterfaceType = PnpDefaultInterfaceType;

                    }
                    cmPartDesc = &cmFullDesc->PartialResourceList.PartialDescriptors[0];
                    for (j = 0; j < cmFullDesc->PartialResourceList.Count; j++) {

                        size = 0;
                        switch (cmPartDesc->Type) {

                        case CmResourceTypeDeviceSpecific:
                            size = cmPartDesc->u.DeviceSpecificData.DataSize;
                            break;

                        }
                        cmPartDesc++;
                        cmPartDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)cmPartDesc + size);
                    }

                    cmFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)cmPartDesc;
                }

                *AllocatedResources = newResources;
            }
        }
    }

    return changed;
}

NTSTATUS
IopWriteResourceList(
    HANDLE ResourceMapKey,
    PUNICODE_STRING ClassName,
    PUNICODE_STRING DriverName,
    PUNICODE_STRING DeviceName,
    PCM_RESOURCE_LIST ResourceList,
    ULONG ResourceListSize
    )

/*++

Routine Description:

    This routine takes a resourcelist and stores it in the registry resource
    map, using the ClassName, DriverName and DeviceName as the path of the
    key to store it in.

Arguments:

    ResourceMapKey - Handle to the root of the resource map.

    ClassName - Pointer to a Unicode String that contains the name of the Class
        for this resource list.

    DriverName - Pointer to a Unicode String that contains the name of the
        Driver for this resource list.

    DeviceName - Pointer to a Unicode String that contains the name of the
        Device for this resource list.

    ResourceList - P to the resource list.

    ResourceListSize - Value determining the size of the resource list.

Return Value:

    The status returned is the final completion status of the operation.

--*/


{
    NTSTATUS status;
    HANDLE classKeyHandle;
    HANDLE driverKeyHandle;

    PAGED_CODE();

    status = IopOpenRegistryKey( &classKeyHandle,
                                 ResourceMapKey,
                                 ClassName,
                                 KEY_READ | KEY_WRITE,
                                 TRUE );

    if (NT_SUCCESS( status )) {

        //
        // Take the resulting name to create the key.
        //

        status = IopOpenRegistryKey( &driverKeyHandle,
                                     classKeyHandle,
                                     DriverName,
                                     KEY_READ | KEY_WRITE,
                                     TRUE );

        ZwClose( classKeyHandle );


        if (NT_SUCCESS( status )) {

            //
            // With this key handle, we can now store the required information
            // in the value entries of the key.
            //

            //
            // Store the device name as a value name and the device information
            // as the rest of the data.
            // Only store the information if the CM_RESOURCE_LIST was present.
            //

            if (ResourceList->Count == 0) {

                status = ZwDeleteValueKey( driverKeyHandle,
                                           DeviceName );

            } else {

                status = ZwSetValueKey( driverKeyHandle,
                                        DeviceName,
                                        0L,
                                        REG_RESOURCE_LIST,
                                        ResourceList,
                                        ResourceListSize );

            }

            ZwClose( driverKeyHandle );

        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\i386\pbiosa.asm ===
title  "Pnp Bios Bus Extender ASM support routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    Biosa.asm
;
; Abstract:
;
;    This file contains Pnp Bios ASM support routines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) Jan 15, 1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
.xlist
include callconv.inc                    ; calling convention macros
.list

        EXTRNP  _RtlMoveMemory, 3
        EXTRNP  _KeI386Call16BitCStyleFunction, 4

PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; PbCallPnpBiosWorker (
;     IN ULONG EntryOffset,
;     IN ULONG EntrySelector,
;     IN PUSHORT Parameters,
;     IN ULONG ParameterSize
;     );
;
; Routine Description:
;
;     This routines copies the specified parameters to stack and invokes
;     Pnp Bios Entry point.
;
; Arguments:
;
;     EntryOffset and EntrySelector - supplies the entry point of the bios function.
;
;     Parameters - Supplies a pointer to argument block.
;
;     ParameterSize - Size of the argument block
;
; Return Value:
;
;     Registers/context contains the register values returned from pnp bios.
;
;--

EntryOffset     equ     [ebp + 8]
EntrySelector   equ     [ebp + 12]
Parameters      equ     [ebp + 16]
ParameterSize   equ     [ebp + 20]

cPublicProc _PbCallPnpBiosWorker, 4

        push    ebp
        mov     ebp, esp
        sub     esp, ParameterSize
        mov     eax, esp

        stdCall _RtlMoveMemory, <eax, Parameters, ParameterSize>

        stdCall _KeI386Call16BitCStyleFunction, <EntryOffset, EntrySelector, Parameters, ParameterSize>

        mov     esp, ebp
        pop     ebp
        stdRET  _PbCallPnpBiosWorker

stdENDP _PbCallPnpBiosWorker

PAGELK  ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\io\pnpmgr\i386\pbiosc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pbiosc.c

Abstract:

    This module contains Pnp BIOS dependent routines.  It includes code to initialize
    16 bit GDT selectors and to call pnp bios api.

Author:

    Shie-Lin Tzong (shielint) 15-Jan-1998

Environment:

    Kernel mode only.

Revision History:

--*/


#include "pnpmgrp.h"
#include "pnpcvrt.h"
#include "pbios.h"
#include "..\..\ke\i386\abios.h"

//
// Functions for PNP_BIOS_ENUMERATION_CONTEXT
//

#define PI_SHUTDOWN_EXAMINE_BIOS_DEVICE 1
#define PI_SHUTDOWN_LEGACY_RESOURCES    2

typedef struct _PNP_BIOS_DEVICE_NODE_LIST {
    struct _PNP_BIOS_DEVICE_NODE_LIST *Next;
    PNP_BIOS_DEVICE_NODE DeviceNode;
} PNP_BIOS_DEVICE_NODE_LIST, *PPNP_BIOS_DEVICE_NODE_LIST;

typedef struct _PNP_BIOS_ENUMERATION_CONTEXT {
    PUNICODE_STRING KeyName;
    ULONG Function;
    union {
        struct {
            PVOID BiosInfo;
            ULONG BiosInfoLength;
            PPNP_BIOS_DEVICE_NODE_LIST *DeviceList;
        } ExamineBiosDevice;
        struct {
            PCM_RESOURCE_LIST LegacyResources;
        } LegacyResources;
    } u;
} PNP_BIOS_ENUMERATION_CONTEXT, *PPNP_BIOS_ENUMERATION_CONTEXT;

typedef struct _PNP_BIOS_SHUT_DOWN_CONTEXT {
    PPNP_BIOS_DEVICE_NODE_LIST DeviceList;
    PVOID Resources;
} PNP_BIOS_SHUT_DOWN_CONTEXT, *PPNP_BIOS_SHUT_DOWN_CONTEXT;

//
// A big structure for calling Pnp BIOS functions
//

#define PNP_BIOS_GET_NUMBER_DEVICE_NODES 0
#define PNP_BIOS_GET_DEVICE_NODE 1
#define PNP_BIOS_SET_DEVICE_NODE 2
#define PNP_BIOS_GET_EVENT 3
#define PNP_BIOS_SEND_MESSAGE 4
#define PNP_BIOS_GET_DOCK_INFORMATION 5
// Function 6 is reserved
#define PNP_BIOS_SELECT_BOOT_DEVICE 7
#define PNP_BIOS_GET_BOOT_DEVICE 8
#define PNP_BIOS_SET_OLD_ISA_RESOURCES 9
#define PNP_BIOS_GET_OLD_ISA_RESOURCES 0xA
#define PNP_BIOS_GET_ISA_CONFIGURATION 0x40

//
// Control Flags for Set_Device_node
//

#define SET_CONFIGURATION_NOW 1
#define SET_CONFIGURATION_FOR_NEXT_BOOT 2

typedef struct _PB_PARAMETERS {
    USHORT Function;
    union {
        struct {
            USHORT *NumberNodes;
            USHORT *NodeSize;
        } GetNumberDeviceNodes;

        struct {
            USHORT *Node;
            PPNP_BIOS_DEVICE_NODE NodeBuffer;
            USHORT Control;
        } GetDeviceNode;

        struct {
            USHORT Node;
            PPNP_BIOS_DEVICE_NODE NodeBuffer;
            USHORT Control;
        } SetDeviceNode;

        struct {
            USHORT *Message;
        } GetEvent;

        struct {
            USHORT Message;
        } SendMessage;

        struct {
            PVOID Resources;
        } SetAllocatedResources;
    } u;
} PB_PARAMETERS, *PPB_PARAMETERS;

#define PB_MAXIMUM_STACK_SIZE (sizeof(PB_PARAMETERS) + sizeof(USHORT) * 2)

//
// PbBiosInitialized is set to the return of PnPBiosInitializePnPBios. It
// should not be checked before that function is called.
//

NTSTATUS PbBiosInitialized ;

//
// PbBiosCodeSelector contains the selector of the PNP
// BIOS code.
//

USHORT PbBiosCodeSelector;

//
// PbBiosDataSelector contains the selector of the PNP
// BIOS data area (F0000-FFFFF)
//

USHORT PbBiosDataSelector;

//
// PbSelectors[] contains general purpose preallocated selectors
//

USHORT PbSelectors[2];

//
// PbBiosEntryPoint contains the Pnp Bios entry offset
//

ULONG PbBiosEntryPoint;

//
// SpinLock to serialize Pnp Bios call
//

KSPIN_LOCK PbBiosSpinlock;

//
// PiShutdownContext
//

PNP_BIOS_SHUT_DOWN_CONTEXT PiShutdownContext;

//
// External References
//

extern
USHORT
PbCallPnpBiosWorker (
    IN ULONG EntryOffset,
    IN ULONG EntrySelector,
    IN PUSHORT Parameters,
    IN USHORT Size
    );

//
// Internal prototypes
//

VOID
PnPBiosCollectLegacyDeviceResources (
    IN PCM_RESOURCE_LIST  *ReturnedResources
    );

VOID
PnPBiosReserveLegacyDeviceResources (
    IN PUCHAR BiosResources
    );

NTSTATUS
PnPBiosExamineDeviceKeys (
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    IN OUT PPNP_BIOS_DEVICE_NODE_LIST *DeviceList
    );

BOOLEAN
PnPBiosExamineBiosDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    );

BOOLEAN
PnPBiosExamineBiosDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    );

NTSTATUS
PnPBiosExtractInfo(
    IN ULONG BiosHandle,
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PVOID *Header,
    OUT ULONG *HeaderLength,
    OUT PVOID *Tail,
    OUT ULONG *TailLength
    );

VOID
PnPBiosSetDeviceNodes (
    IN PVOID Context
    );

NTSTATUS
PbHardwareService (
    IN PPB_PARAMETERS Parameters
    );

VOID
PbAddress32ToAddress16 (
    IN PVOID Address32,
    IN PUSHORT Address16,
    IN USHORT Selector
    );

#ifdef ALLOC_PRAGMA
BOOLEAN
PnPBiosGetBiosHandleFromDeviceKey(
    IN HANDLE KeyHandle,
    OUT PULONG BiosDeviceId
    );
NTSTATUS
PnPBiosSetDeviceNodeDynamically(
    IN PDEVICE_OBJECT DeviceObject
    );
#pragma alloc_text(PAGE, PnPBiosGetBiosHandleFromDeviceKey)
#pragma alloc_text(PAGE, PnPBiosCollectLegacyDeviceResources)
#pragma alloc_text(PAGE, PnPBiosExamineDeviceKeys)
#pragma alloc_text(PAGE, PnPBiosExamineBiosDeviceKey)
#pragma alloc_text(PAGE, PnPBiosExamineBiosDeviceInstanceKey)
#pragma alloc_text(PAGE, PnPBiosExtractInfo)
#pragma alloc_text(PAGE, PnPBiosInitializePnPBios)
#pragma alloc_text(PAGE, PnPBiosSetDeviceNodes)
#pragma alloc_text(PAGE, PnPBiosSetDeviceNodeDynamically)
#pragma alloc_text(PAGE, PnPBiosReserveLegacyDeviceResources)
#pragma alloc_text(PAGE, PbAddress32ToAddress16)
#pragma alloc_text(PAGELK, PbHardwareService)
#pragma alloc_text(PAGELK, PnPBiosShutdownSystem)
#endif

VOID
PnPBiosShutdownSystem (
    IN ULONG Phase,
    IN OUT PVOID *Context
    )

/*++

Routine Description:

    This routine performs the Pnp shutdowm preparation.
    At phase 0, it prepares the data for the Pnp bios devices whose states needed to be
    updated to pnp bios.
    At phase 1, we write the data to pnp bios.

Arguments:

    Phase - specifies the shutdown phase.

    Context - at phase 0, it supplies a variable to receive the returned context info.
              at phase 1, it supplies a variable to specify the context info.

Return Value:

    None.

--*/
{
    PVOID               biosInfo;
    ULONG               length;
    NTSTATUS            status;
    PPNP_BIOS_DEVICE_NODE_LIST  pnpBiosDeviceNode;
    PCM_RESOURCE_LIST   legacyResources;
    PUCHAR              biosResources;

    if (Phase == 0) {

        *Context = NULL;

        status = PnPBiosGetBiosInfo(&biosInfo, &length);
        if (NT_SUCCESS( status )) {

            PnPBiosExamineDeviceKeys(
                         biosInfo,
                         length,
                         (PPNP_BIOS_DEVICE_NODE_LIST *) &PiShutdownContext.DeviceList
                         );
            PnPBiosCollectLegacyDeviceResources (&legacyResources);
            if (legacyResources) {
                status = PpCmResourcesToBiosResources (legacyResources, NULL, &biosResources, &length);
                if (NT_SUCCESS(status) && biosResources) {
                    PiShutdownContext.Resources = (PCM_RESOURCE_LIST)ExAllocatePool(NonPagedPool, length);
                    if (PiShutdownContext.Resources) {
                        RtlMoveMemory(PiShutdownContext.Resources, biosResources, length);
                        ExFreePool(biosResources);
                    }
                }
                ExFreePool(legacyResources);
            }
            if (PiShutdownContext.DeviceList || PiShutdownContext.Resources) {
                *Context = &PiShutdownContext;
            }
            ExFreePool(biosInfo);
        }

        return;

    } else if (*Context) {
        ASSERT(*Context == &PiShutdownContext);
        pnpBiosDeviceNode = PiShutdownContext.DeviceList;
        biosResources = PiShutdownContext.Resources;
        if (pnpBiosDeviceNode || biosResources) {

            //
            // Call pnp bios from boot processor
            //

            KeSetSystemAffinityThread(1);

            if (pnpBiosDeviceNode) {
                PnPBiosSetDeviceNodes(pnpBiosDeviceNode);
            }
            if (biosResources) {
                PnPBiosReserveLegacyDeviceResources(biosResources);
            }

            //
            // Restore old affinity for current thread.
            //

            KeRevertToUserAffinityThread();
        }
    }
}

BOOLEAN
PnPBiosGetBiosHandleFromDeviceKey(
    IN HANDLE KeyHandle,
    OUT PULONG BiosDeviceId
    )
/*++

Routine Description:

    This routine takes a handle to System\Enum\Root\<Device Instance> and sets
    BiosDeviceId to the PNPBIOS ID of the device.

Arguments:

    KeyHandle - handle to System\Enum\Root\<Device Instance>

    BiosDeviceId - After this function is ran, this value will be filled with
                   the ID assigned to the device by PNPBIOS.

Return Value:

    FALSE if the handle does not refer to a PNPBIOS device.

--*/
{
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    HANDLE handle;
    ULONG biosDeviceHandle = ~0ul;

    PAGED_CODE();

    //
    // Make sure this is a pnp bios device by checking its pnp bios device
    // handle.
    //
    PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_CONTROL);
    status = IopOpenRegistryKeyEx( &handle,
                                   KeyHandle,
                                   &unicodeName,
                                   KEY_READ
                                   );

    if (!NT_SUCCESS(status)) {
        return FALSE ;
    }

    status = IopGetRegistryValue (handle,
                                  L"PnpBiosDeviceHandle",
                                  &keyValueInformation);
    ZwClose(handle);

    if (NT_SUCCESS(status)) {
        if ((keyValueInformation->Type == REG_DWORD) &&
            (keyValueInformation->DataLength == sizeof(ULONG))) {

            biosDeviceHandle = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
        }
        ExFreePool(keyValueInformation);
    }
    if (biosDeviceHandle > 0xffff) {
        return FALSE;
    }
    *BiosDeviceId = biosDeviceHandle ;
    return TRUE ;
}

VOID
PnPBiosCollectLegacyDeviceResources (
    IN PCM_RESOURCE_LIST *ReturnedResources
    )

/*++

Routine Description:


Arguments:

    ReturnedResources - supplies a pointer to a variable to receive legacy resources.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    PNP_BIOS_ENUMERATION_CONTEXT context;
    PVOID buffer;
    UNICODE_STRING workName, tmpName;

    PAGED_CODE();

    *ReturnedResources = NULL;

    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return;
    }

    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {

        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;
        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.KeyName = &workName;
        context.Function = PI_SHUTDOWN_LEGACY_RESOURCES;
        context.u.LegacyResources.LegacyResources = NULL;
        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_READ,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           PnPBiosExamineBiosDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);
        *ReturnedResources = context.u.LegacyResources.LegacyResources;
    }
    ExFreePool(buffer);
}

NTSTATUS
PnPBiosExamineDeviceKeys (
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    IN OUT PPNP_BIOS_DEVICE_NODE_LIST *DeviceList
    )

/*++

Routine Description:

    This routine scans through System\Enum\Root subtree to build a device node for
    each root device.

Arguments:

    DeviceRelations - supplies a variable to receive the returned DEVICE_RELATIONS structure.

Return Value:

    A NTSTATUS code.

--*/

{
    NTSTATUS status;
    HANDLE baseHandle;
    PNP_BIOS_ENUMERATION_CONTEXT context;
    PVOID buffer;
    UNICODE_STRING workName, tmpName;

    PAGED_CODE();

    buffer = ExAllocatePool(PagedPool, PNP_LARGE_SCRATCH_BUFFER_SIZE);
    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Open System\CurrentControlSet\Enum\Root key and call worker routine to recursively
    // scan through the subkeys.
    //

    status = IopCreateRegistryKeyEx( &baseHandle,
                                     NULL,
                                     &CmRegistryMachineSystemCurrentControlSetEnumRootName,
                                     KEY_READ,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    if (NT_SUCCESS(status)) {
        workName.Buffer = (PWSTR)buffer;
        RtlFillMemory(buffer, PNP_LARGE_SCRATCH_BUFFER_SIZE, 0);
        workName.MaximumLength = PNP_LARGE_SCRATCH_BUFFER_SIZE;
        workName.Length = 0;
        PiWstrToUnicodeString(&tmpName, REGSTR_KEY_ROOTENUM);
        RtlAppendStringToString((PSTRING)&workName, (PSTRING)&tmpName);

        //
        // Enumerate all subkeys under the System\CCS\Enum\Root.
        //

        context.KeyName = &workName;
        context.Function = PI_SHUTDOWN_EXAMINE_BIOS_DEVICE;
        context.u.ExamineBiosDevice.BiosInfo = BiosInfo;
        context.u.ExamineBiosDevice.BiosInfoLength = BiosInfoLength;
        context.u.ExamineBiosDevice.DeviceList = DeviceList;

        status = PipApplyFunctionToSubKeys(baseHandle,
                                           NULL,
                                           KEY_READ,
                                           FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                           PnPBiosExamineBiosDeviceKey,
                                           &context
                                           );
        ZwClose(baseHandle);
    }
    return status;
}

BOOLEAN
PnPBiosExamineBiosDeviceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\CCS\Enum\BusKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    PAGED_CODE();

    if (Context->Function != PI_SHUTDOWN_EXAMINE_BIOS_DEVICE ||
        KeyName->Buffer[0] == L'*') {

        USHORT length;
        PWSTR p;
        PUNICODE_STRING unicodeName = ((PPNP_BIOS_ENUMERATION_CONTEXT)Context)->KeyName;

        length = unicodeName->Length;

        p = unicodeName->Buffer;
        if ( unicodeName->Length / sizeof(WCHAR) != 0) {
            p += unicodeName->Length / sizeof(WCHAR);
            *p = OBJ_NAME_PATH_SEPARATOR;
            unicodeName->Length += sizeof (WCHAR);
        }

        RtlAppendStringToString((PSTRING)unicodeName, (PSTRING)KeyName);

        //
        // Enumerate all subkeys under the current device key.
        //

        PipApplyFunctionToSubKeys(KeyHandle,
                                  NULL,
                                  KEY_ALL_ACCESS,
                                  FUNCTIONSUBKEY_FLAG_IGNORE_NON_CRITICAL_ERRORS,
                                  PnPBiosExamineBiosDeviceInstanceKey,
                                  Context
                                  );
        unicodeName->Length = length;
    }
    return TRUE;
}

BOOLEAN
PnPBiosExamineBiosDeviceInstanceKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING KeyName,
    IN OUT PPNP_BIOS_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine is a callback function for PipApplyFunctionToSubKeys.
    It is called for each subkey under HKLM\System\Enum\Root\DeviceKey.

Arguments:

    KeyHandle - Supplies a handle to this key.

    KeyName - Supplies the name of this key.

    Context - points to the ROOT_ENUMERATOR_CONTEXT structure.

Returns:

    TRUE to continue the enumeration.
    FALSE to abort it.

--*/
{
    UNICODE_STRING unicodeName;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;
    NTSTATUS status;
    HANDLE handle;
    ULONG biosDeviceHandle = ~0ul;
    PCM_RESOURCE_LIST config = NULL;
    ULONG length, totalLength;
    PPNP_BIOS_DEVICE_NODE_LIST deviceNode;
    PUCHAR p;
    PVOID header, tail;
    ULONG headerLength, tailLength ;
    PUCHAR biosResources;
    BOOLEAN isEnabled ;

    UNREFERENCED_PARAMETER( KeyName );

    PAGED_CODE();

    if (Context->Function == PI_SHUTDOWN_LEGACY_RESOURCES) {
        ULONG tmp = 0;

        //
        // Skip any firmware identified device.
        //

        status = IopGetRegistryValue (KeyHandle,
                                      L"FirmwareIdentified",
                                      &keyValueInformation);
        if (NT_SUCCESS(status)) {
            if ((keyValueInformation->Type == REG_DWORD) &&
                (keyValueInformation->DataLength == sizeof(ULONG))) {

                tmp = *(PULONG)KEY_VALUE_DATA(keyValueInformation);
            }
            ExFreePool(keyValueInformation);
        }
        if (tmp != 0) {
            return TRUE;
        }

        //
        // Skip any IoReportDetectedDevice and virtual/madeup device.
        //

        status = IopGetRegistryValue (KeyHandle,
                                      L"Legacy",
                                      &keyValueInformation);
        if (NT_SUCCESS(status)) {
            ExFreePool(keyValueInformation);
        }
        if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
            return TRUE;
        }

        //
        // Process it.
        // Check if the device has BOOT config
        //

        PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
        status = IopOpenRegistryKeyEx( &handle,
                                       KeyHandle,
                                       &unicodeName,
                                       KEY_READ
                                       );
        if (NT_SUCCESS(status)) {
            status = PipReadDeviceConfiguration (
                                    handle,
                                    REGISTRY_BOOT_CONFIG,
                                    &config,
                                    &length);
            ZwClose(handle);
            if (NT_SUCCESS(status) && config && length != 0) {
                PCM_RESOURCE_LIST list;

                list = Context->u.LegacyResources.LegacyResources;
                status = IopMergeCmResourceLists(list, config, &Context->u.LegacyResources.LegacyResources);
                if (NT_SUCCESS(status) && list) {
                    ExFreePool(list);
                }
                ExFreePool(config);
            }
        }
    } else if (Context->Function == PI_SHUTDOWN_EXAMINE_BIOS_DEVICE) {
        //
        // First check if this key was created by firmware mapper.  If yes, make sure
        // the device is still present.
        //

        if (PipIsFirmwareMapperDevicePresent(KeyHandle) == FALSE) {
            return TRUE;
        }

        //
        // Make sure this is a pnp bios device by checking its pnp bios
        // device handle.
        //
        if (!PnPBiosGetBiosHandleFromDeviceKey(KeyHandle, &biosDeviceHandle)) {
            return TRUE ;
        }

        //
        // Get pointers to the header and tail.
        //
        // Gross hack warning -
        //    In the disable case, we need a bios resource template to whack
        // to "off". We will index into header to do this, as header and tail
        // point directly into the BIOS resource list!
        //
        status = PnPBiosExtractInfo (
                            biosDeviceHandle,
                            Context->u.ExamineBiosDevice.BiosInfo,
                            Context->u.ExamineBiosDevice.BiosInfoLength,
                            &header,
                            &headerLength,
                            &tail,
                            &tailLength
                            );

        if (!NT_SUCCESS(status)) {
            return TRUE;
        }

        //
        // Has this PnPBIOS device been disabled?
        //
        // N.B. This check examines flags for the current profile. We actually
        // have no clue what profile we will next be booting into, so the UI
        // should not show disable in current profile for PnPBIOS devices. A
        // work item yet to be done...
        //
        isEnabled = IopIsDeviceInstanceEnabled(KeyHandle, Context->KeyName, FALSE) ;

        if (!isEnabled) {

            //
            // This device is being disabled. Set up and attain a pointer to
            // the appropriately built BIOS resource list.
            //
            biosResources = ((PUCHAR)header) + sizeof(PNP_BIOS_DEVICE_NODE) ;
            PpBiosResourcesSetToDisabled (biosResources, &length);

        } else {

            //
            // Check if the pnp bios device has any assigned ForcedConfig
            //
            PiWstrToUnicodeString(&unicodeName, REGSTR_KEY_LOG_CONF);
            status = IopOpenRegistryKeyEx( &handle,
                                           KeyHandle,
                                           &unicodeName,
                                           KEY_READ
                                           );
            if (!NT_SUCCESS(status)) {
                return TRUE ;
            }

            status = PipReadDeviceConfiguration (
                           handle,
                           REGISTRY_FORCED_CONFIG,
                           &config,
                           &length
                           );

            ZwClose(handle);
            if ((!NT_SUCCESS(status)) || (!config) || (length == 0)) {
                return TRUE ;
            }

            status = PpCmResourcesToBiosResources (
                                config,
                                tail,
                                &biosResources,
                                &length
                                );
            ExFreePool(config);
            if (!NT_SUCCESS(status) || !biosResources) {
                return TRUE;
            }
        }

        //
        // Allocate PNP_BIOS_DEVICE_NODE_LIST structure
        //

        totalLength = headerLength + length + tailLength;
        deviceNode = ExAllocatePool(NonPagedPool, totalLength + sizeof(PVOID));
        if (deviceNode) {
           deviceNode->Next = *(Context->u.ExamineBiosDevice.DeviceList);
               *(Context->u.ExamineBiosDevice.DeviceList) = deviceNode;
               p = (PUCHAR)&deviceNode->DeviceNode;
               RtlCopyMemory(p, header, headerLength);
               p += headerLength;
               RtlCopyMemory(p, biosResources, length);
               p += length;
               RtlCopyMemory(p, tail, tailLength);
               deviceNode->DeviceNode.Size = (USHORT)totalLength;
        }

        if (isEnabled) {
            ExFreePool(biosResources);
        }
    }
    return TRUE;
}

NTSTATUS
PnPBiosExtractInfo(
    IN ULONG BiosHandle,
    IN PVOID BiosInfo,
    IN ULONG BiosInfoLength,
    OUT PVOID *Header,
    OUT ULONG *HeaderLength,
    OUT PVOID *Tail,
    OUT ULONG *TailLength
    )

/*++

Routine Description:

    This routine extracts desired information for the specified bios device.

Arguments:

    BiosHandle - specifies the bios device.

    BiosInfo - The PnP BIOS Installation Check Structure followed by the
        DevNode Structures reported by the BIOS.  The detailed format is
        documented in the PnP BIOS spec.

    BiosInfoLength - Length in bytes of the block whose address is stored in
        BiosInfo.

    Header - specifies a variable to receive the beginning address of the bios
             device node structure.

    HeaderLength - specifies a variable to receive the length of the bios device
             node header.

    Tail - specifies a variable to receive the address of the bios device node's
           PossibleResourceBlock.

    TailLength - specifies a variable to receive the size of the tail.

Return Value:

    STATUS_SUCCESS if no errors, otherwise the appropriate error.

--*/
{
    PCM_PNP_BIOS_INSTALLATION_CHECK biosInstallCheck;
    PCM_PNP_BIOS_DEVICE_NODE        devNodeHeader;
    NTSTATUS                        status = STATUS_UNSUCCESSFUL;
    PUCHAR                          currentPtr;
    int                             lengthRemaining;
    int                             remainingNodeLength;
    int                             numNodes;
    PUCHAR                          configPtr;

    PAGED_CODE();

#if DBG

    //
    // Make sure the data is at least large enough to hold the BIOS Installation
    // Check structure and check that the PnP signature is correct.
    //

    if (BiosInfoLength < sizeof(CM_PNP_BIOS_INSTALLATION_CHECK)) {
        return STATUS_UNSUCCESSFUL;
    }

#endif

    biosInstallCheck = (PCM_PNP_BIOS_INSTALLATION_CHECK)BiosInfo;

#if DBG

    if (biosInstallCheck->Signature[0] != '$' ||
        biosInstallCheck->Signature[1] != 'P' ||
        biosInstallCheck->Signature[2] != 'n' ||
        biosInstallCheck->Signature[3] != 'P') {

        return STATUS_UNSUCCESSFUL;
    }

#endif

    //
    //
    //
    //

    currentPtr = (PUCHAR)BiosInfo + biosInstallCheck->Length;
    lengthRemaining = BiosInfoLength - biosInstallCheck->Length;

    for (numNodes = 0; lengthRemaining > sizeof(CM_PNP_BIOS_DEVICE_NODE); numNodes++) {

        devNodeHeader = (PCM_PNP_BIOS_DEVICE_NODE)currentPtr;

        if (devNodeHeader->Size > lengthRemaining) {
            IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                        "Node # %d, invalid size (%d), length remaining (%d)\n",
                        devNodeHeader->Node,
                        devNodeHeader->Size,
                        lengthRemaining));
            return STATUS_UNSUCCESSFUL;
        }

        if (devNodeHeader->Node == BiosHandle) {
            *Header = devNodeHeader;
            *HeaderLength = sizeof(CM_PNP_BIOS_DEVICE_NODE);

            configPtr = currentPtr + sizeof(*devNodeHeader);
            remainingNodeLength = devNodeHeader->Size - sizeof(*devNodeHeader) - 1;
            while (*configPtr != TAG_COMPLETE_END && remainingNodeLength) {
                configPtr++;
                remainingNodeLength--;
            }
            if (*configPtr == TAG_COMPLETE_END && remainingNodeLength) {
                configPtr += 2;
                remainingNodeLength--;
            }
            *Tail = configPtr;
            *TailLength = remainingNodeLength;
            status = STATUS_SUCCESS;
            break;
        }
        currentPtr += devNodeHeader->Size;
        lengthRemaining -= devNodeHeader->Size;
    }
    return status;
}

NTSTATUS
PnPBiosInitializePnPBios (
    VOID
    )

/*++

Routine Description:

    This routine setup selectors to invoke Pnp BIOS.

Arguments:

    None.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    KGDTENTRY gdtEntry;
    ULONG codeBase, i;
    NTSTATUS status;
    USHORT selectors[4];
    PHYSICAL_ADDRESS physicalAddr;
    PVOID virtualAddr;
    PVOID biosData;
    ULONG biosDataLength;

    //
    // Initialize BIOS call spinlock
    //
    KeInitializeSpinLock (&PbBiosSpinlock);

    //
    // Grab the PnPBIOS settings stored in the registry by NTDetect
    //
    status = PnPBiosGetBiosInfo(&biosData, &biosDataLength);
    if (!NT_SUCCESS(status)) {
       PbBiosInitialized = status ;
       return status ;
    }

    //
    // Call pnp bios from boot processor
    //
    KeSetSystemAffinityThread(1);

    //
    // Initialize stack segment
    //
    KiStack16GdtEntry = KiAbiosGetGdt() + KGDT_STACK16;

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)KiStack16GdtEntry,
                0L,
                0xffff,
                TYPE_DATA
                );

    //
    // Allocate 4 selectors for calling PnP Bios APIs.
    //

    i = 4;
    status = KeI386AllocateGdtSelectors (selectors, (USHORT) i);
    if (!NT_SUCCESS(status)) {
        IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                    "PnpBios: Failed to allocate selectors to call PnP BIOS at shutdown.\n"));
        goto PnpBiosInitExit ;
    }

    PbBiosCodeSelector = selectors[0];
    PbBiosDataSelector = selectors[1];
    PbSelectors[0] = selectors[2];
    PbSelectors[1] = selectors[3];

    PbBiosEntryPoint = (ULONG)
        ((PPNP_BIOS_INSTALLATION_CHECK)biosData)->ProtectedModeEntryOffset;

    //
    // Initialize selectors to use PNP bios code
    //

    //
    // initialize 16 bit code selector
    //

    gdtEntry.LimitLow                   = 0xFFFF;
    gdtEntry.HighWord.Bytes.Flags1      = 0;
    gdtEntry.HighWord.Bytes.Flags2      = 0;
    gdtEntry.HighWord.Bits.Pres         = 1;
    gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    gdtEntry.HighWord.Bits.Type         = 31;
    gdtEntry.HighWord.Bits.Default_Big  = 0;

    physicalAddr.HighPart = 0;
    physicalAddr.LowPart =
        ((PPNP_BIOS_INSTALLATION_CHECK)biosData)->ProtectedModeCodeBaseAddress;
    virtualAddr = MmMapIoSpace (physicalAddr, 0x10000, TRUE);
    codeBase = (ULONG)virtualAddr;

    gdtEntry.BaseLow               = (USHORT) (codeBase & 0xffff);
    gdtEntry.HighWord.Bits.BaseMid = (UCHAR)  (codeBase >> 16) & 0xff;
    gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)  (codeBase >> 24) & 0xff;

    KeI386SetGdtSelector (PbBiosCodeSelector, &gdtEntry);

    //
    // initialize 16 bit data selector for Pnp BIOS
    //

    gdtEntry.LimitLow                   = 0xFFFF;
    gdtEntry.HighWord.Bytes.Flags1      = 0;
    gdtEntry.HighWord.Bytes.Flags2      = 0;
    gdtEntry.HighWord.Bits.Pres         = 1;
    gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    gdtEntry.HighWord.Bits.Type         = 19;
    gdtEntry.HighWord.Bits.Default_Big  = 1;

    physicalAddr.LowPart =
        ((PPNP_BIOS_INSTALLATION_CHECK)biosData)->ProtectedModeDataBaseAddress;
    virtualAddr = MmMapIoSpace (physicalAddr, 0x10000, TRUE);
    codeBase = (ULONG)virtualAddr;

    gdtEntry.BaseLow               = (USHORT) (codeBase & 0xffff);
    gdtEntry.HighWord.Bits.BaseMid = (UCHAR)  (codeBase >> 16) & 0xff;
    gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)  (codeBase >> 24) & 0xff;

    KeI386SetGdtSelector (PbBiosDataSelector, &gdtEntry);

    //
    // Initialize the other two general purpose data selector such that
    // on subsequent init we only need to init the base addr.
    //

    KeI386SetGdtSelector (PbSelectors[0], &gdtEntry);
    KeI386SetGdtSelector (PbSelectors[1], &gdtEntry);

    //
    // Locked in code for Pnp BIOS shutdown processing.
    //

    status = STATUS_SUCCESS;

PnpBiosInitExit:
    //
    // We don't need this data anymore, free it.
    //
    ExFreePool(biosData);

    //
    // Restore old affinity for current thread.
    //
    KeRevertToUserAffinityThread();
    PbBiosInitialized = status ;
    return status;
}

VOID
PnPBiosSetDeviceNodes (
    IN PVOID Context
    )

/*++

Routine Description:

    This function sets the caller specified resource to pnp bios slot/device
    data.

Arguments:

    Context - specifies a list of Pnp bios device to be set.

Return Value:

    NTSTATUS code

--*/
{
    PB_PARAMETERS biosParameters;
    PPNP_BIOS_DEVICE_NODE_LIST deviceList = (PPNP_BIOS_DEVICE_NODE_LIST)Context;
    PPNP_BIOS_DEVICE_NODE deviceNode;

    while (deviceList) {
        deviceNode = &deviceList->DeviceNode;

        //
        // call Pnp Bios to set the resources
        //

        biosParameters.Function = PNP_BIOS_SET_DEVICE_NODE;
        biosParameters.u.SetDeviceNode.Node = deviceNode->Node;
        biosParameters.u.SetDeviceNode.NodeBuffer = deviceNode;
        biosParameters.u.SetDeviceNode.Control = SET_CONFIGURATION_FOR_NEXT_BOOT;
        PbHardwareService (&biosParameters);            // Ignore the return status
        deviceList = deviceList->Next;
    }
}

NTSTATUS
PnPBiosSetDeviceNodeDynamically(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PNP_BIOS_ENUMERATION_CONTEXT context;
    NTSTATUS status;
    PDEVICE_NODE deviceNode ;
    PVOID biosInfo = NULL ;
    ULONG length;
    HANDLE handle;
    PPNP_BIOS_DEVICE_NODE_LIST deviceList = NULL ;
    PB_PARAMETERS biosParameters;
    PPNP_BIOS_DEVICE_NODE biosDevNode;

    //
    // First. get a handle to the device
    //
    status = IopDeviceObjectToDeviceInstance(DeviceObject, &handle, KEY_READ);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Yuck, to see if it is a PnPBIOS device, let us verify the ID starts with
    // the '*'. To do so, we need to see the device ID. Luckily, if the above
    // call succeeded, so should this...
    //
    deviceNode = (PDEVICE_NODE) DeviceObject->DeviceObjectExtension->DeviceNode;
    status = STATUS_NO_SUCH_DEVICE ;
    if (!deviceNode) {
        goto SetDynaExit ;
    }

    if (deviceNode->InstancePath.Length == 0) {
        goto SetDynaExit ;
    }

    if (deviceNode->InstancePath.Buffer[0] != L'*') {
        goto SetDynaExit ;
    }

    //
    // Now get the BIOS data
    //
    status = PnPBiosGetBiosInfo(&biosInfo, &length);
    if (!NT_SUCCESS( status )) {
        goto SetDynaExit ;
    }

    //
    // Fake the call we do during shutdown, as we want the BIOS data for this
    // device if present
    //
    context.Function = PI_SHUTDOWN_EXAMINE_BIOS_DEVICE;
    context.u.ExamineBiosDevice.BiosInfo = biosInfo;
    context.u.ExamineBiosDevice.BiosInfoLength = length;
    context.u.ExamineBiosDevice.DeviceList = &deviceList;
    PnPBiosExamineBiosDeviceInstanceKey(handle, &deviceNode->InstancePath, &context) ;

    if (!deviceList) {
        status = STATUS_UNSUCCESSFUL ;
        goto SetDynaExit ;
    }

    //
    // Call pnp bios from boot processor
    //
    KeSetSystemAffinityThread(1);

    biosDevNode = &deviceList->DeviceNode;

    if (PipIsDevNodeProblem(deviceNode, CM_PROB_DISABLED)) {

       PpBiosResourcesSetToDisabled (((PUCHAR)biosDevNode) + sizeof(PNP_BIOS_DEVICE_NODE), &length);
    }

    //
    // call Pnp Bios to set the resources
    //
    biosParameters.Function = PNP_BIOS_SET_DEVICE_NODE;
    biosParameters.u.SetDeviceNode.Node = biosDevNode->Node;
    biosParameters.u.SetDeviceNode.NodeBuffer = biosDevNode;
    biosParameters.u.SetDeviceNode.Control = SET_CONFIGURATION_NOW ;
    status = PbHardwareService (&biosParameters);

    //
    // Restore old affinity for current thread.
    //
    KeRevertToUserAffinityThread();

SetDynaExit:
    if (biosInfo) {
        ExFreePool(biosInfo) ;
    }
    ZwClose(handle);
    return status ;
}


VOID
PnPBiosReserveLegacyDeviceResources (
    IN PUCHAR biosResources
    )

/*++

Routine Description:


Arguments:

    ReturnedResources - supplies a pointer to a variable to receive legacy resources.

Return Value:

    None.

--*/

{
    PB_PARAMETERS biosParameters;

    //
    // call Pnp Bios to reserve the resources
    //

    biosParameters.Function = PNP_BIOS_SET_OLD_ISA_RESOURCES;
    biosParameters.u.SetAllocatedResources.Resources = biosResources;
    PbHardwareService (&biosParameters);            // Ignore the return status

}

NTSTATUS
PbHardwareService (
    IN PPB_PARAMETERS Parameters
    )

/*++

Routine Description:

    This routine sets up stack parameters and calls an
    assembly worker routine to actually invoke the PNP BIOS code.

Arguments:

    Parameters - supplies a pointer to the parameter block.

Return Value:

    An NTSTATUS code to indicate the result of the operation.

--*/
{
    NTSTATUS status ;
    USHORT stackParameters[PB_MAXIMUM_STACK_SIZE / 2];
    ULONG i = 0;
    USHORT retCode;
    KIRQL oldIrql;

    //
    // Did we initialize correctly?
    //
    status = PbBiosInitialized ;
    if (!NT_SUCCESS(status)) {
        return status ;
    }

    //
    // Convert and copy the caller's parameters to the format that
    // will be used to invoked pnp bios.
    //

    stackParameters[i] = Parameters->Function;
    i++;

    switch (Parameters->Function) {
    case PNP_BIOS_SET_DEVICE_NODE:
         stackParameters[i++] = Parameters->u.SetDeviceNode.Node;
         PbAddress32ToAddress16(Parameters->u.SetDeviceNode.NodeBuffer,
                                &stackParameters[i],
                                PbSelectors[0]);
         i += 2;
         stackParameters[i++] = Parameters->u.SetDeviceNode.Control;
         stackParameters[i++] = PbBiosDataSelector;
         break;

    case PNP_BIOS_SET_OLD_ISA_RESOURCES:
         PbAddress32ToAddress16(Parameters->u.SetAllocatedResources.Resources,
                                &stackParameters[i],
                                PbSelectors[0]);
         i += 2;
         stackParameters[i++] = PbBiosDataSelector;
         break;
    default:
        return STATUS_NOT_IMPLEMENTED;
    }

    MmLockPagableSectionByHandle(ExPageLockHandle);

    //
    // Copy the parameters to stack and invoke Pnp Bios.
    //

    ExAcquireSpinLock (&PbBiosSpinlock, &oldIrql);

    retCode = PbCallPnpBiosWorker (
                  PbBiosEntryPoint,
                  PbBiosCodeSelector,
                  stackParameters,
                  (USHORT)(i * sizeof(USHORT)));

    ExReleaseSpinLock (&PbBiosSpinlock, oldIrql);

    MmUnlockPagableImageSection(ExPageLockHandle);

    //
    // Map Bios returned code to nt status code.
    //

    if (retCode == 0) {
        return STATUS_SUCCESS;
    } else {
        IopDbgPrint((IOP_PNPBIOS_WARNING_LEVEL,
                    "PnpBios: Bios API call failed. Returned Code = %x\n", retCode));
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
PbAddress32ToAddress16 (
    IN PVOID Address32,
    IN PUSHORT Address16,
    IN USHORT Selector
    )

/*++

Routine Description:

    This routine converts the 32 bit address to 16 bit selector:offset address
    and stored in user specified location.

Arguments:

    Address32 - the 32 bit address to be converted.

    Address16 - supplies the location to receive the 16 bit sel:offset address

    Selector - the 16 bit selector for seg:offset address

Return Value:

    None.

--*/
{
    KGDTENTRY  gdtEntry;
    ULONG      baseAddr;

    //
    // Map virtual address to selector:0 address
    //

    gdtEntry.LimitLow                   = 0xFFFF;
    gdtEntry.HighWord.Bytes.Flags1      = 0;
    gdtEntry.HighWord.Bytes.Flags2      = 0;
    gdtEntry.HighWord.Bits.Pres         = 1;
    gdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    gdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    gdtEntry.HighWord.Bits.Type         = 19;
    gdtEntry.HighWord.Bits.Default_Big  = 1;
    baseAddr = (ULONG)Address32;
    gdtEntry.BaseLow               = (USHORT) (baseAddr & 0xffff);
    gdtEntry.HighWord.Bits.BaseMid = (UCHAR)  (baseAddr >> 16) & 0xff;
    gdtEntry.HighWord.Bits.BaseHi  = (UCHAR)  (baseAddr >> 24) & 0xff;
    KeI386SetGdtSelector (Selector, &gdtEntry);
    *Address16 = 0;
    *(Address16 + 1) = Selector;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdapi.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    Implementation of Kernel Debugger portable remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

    John Vert (jvert) 28-May-1991

        Added APIs for reading and writing physical memory
        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)

    Wesley Witt (wesw) 18-Aug-1993

        Added KdpGetVersion, KdpWriteBreakPointEx, & KdpRestoreBreakPointEx


--*/

#include "kdp.h"

#if ACCASM && !defined(_MSC_VER)
long asm(const char *,...);
#pragma intrinsic(asm)
#endif

// XXX drewb - Shortcut to avoid cross-depot checkin
// build delay.  These constants are defined in ntdbg.h
// from the sdktools depot.  Once the internal sdktools
// ntdbg.h is updated from ntdbg.w this can be removed.
#ifndef DBGKD_CACHING_UNKNOWN
#define DBGKD_CACHING_UNKNOWN        0
#define DBGKD_CACHING_CACHED         1
#define DBGKD_CACHING_UNCACHED       2
#define DBGKD_CACHING_WRITE_COMBINED 3
#endif

BOOLEAN KdpContextSent;

LARGE_INTEGER KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

extern LARGE_INTEGER Magic10000;
#define SHIFT10000   13
#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

//
// Define forward referenced function prototypes.
//

VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    );

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    );

LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags
    );

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    );

LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    );

VOID
KdpFillMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpQueryMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT Context
    );


#if i386
VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

long
SymNumFor(
    ULONG_PTR pc
    );

void PotentialNewSymbol (ULONG_PTR pc);

void DumpTraceData(PSTRING MessageData);

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG_PTR pc
    );

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    );

ULONG_PTR
KdpGetReturnAddress(
    IN PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetCallNextOffset (
    ULONG_PTR Pc,
    IN PCONTEXT ContextRecord
    );

LONG
KdpLevelChange (
    ULONG_PTR Pc,
    PCONTEXT ContextRecord,
    IN OUT PBOOLEAN SpecialCall
    );

#endif // i386

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdEnterDebugger)
#pragma alloc_text(PAGEKD, KdExitDebugger)
#pragma alloc_text(PAGEKD, KdpTimeSlipDpcRoutine)
#pragma alloc_text(PAGEKD, KdpTimeSlipWork)
#pragma alloc_text(PAGEKD, KdpSendWaitContinue)
#pragma alloc_text(PAGEKD, KdpReadVirtualMemory)
//#pragma alloc_text(PAGEKD, KdpReadVirtualMemory64)
#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory)
//#pragma alloc_text(PAGEKD, KdpWriteVirtualMemory64)
#pragma alloc_text(PAGEKD, KdpGetContext)
#pragma alloc_text(PAGEKD, KdpSetContext)
#pragma alloc_text(PAGEKD, KdpWriteBreakpoint)
#pragma alloc_text(PAGEKD, KdpRestoreBreakpoint)
#pragma alloc_text(PAGEKD, KdpReportExceptionStateChange)
#pragma alloc_text(PAGEKD, KdpReportLoadSymbolsStateChange)
#pragma alloc_text(PAGEKD, KdpReportCommandStringStateChange)
#pragma alloc_text(PAGEKD, KdpReadPhysicalMemory)
#pragma alloc_text(PAGEKD, KdpWritePhysicalMemory)
#pragma alloc_text(PAGEKD, KdpReadControlSpace)
#pragma alloc_text(PAGEKD, KdpWriteControlSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpace)
#pragma alloc_text(PAGEKD, KdpWriteIoSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpaceExtended)
#pragma alloc_text(PAGEKD, KdpWriteIoSpaceExtended)
#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpGetBusData)
#pragma alloc_text(PAGEKD, KdpSetBusData)
#pragma alloc_text(PAGEKD, KdpGetVersion)
#pragma alloc_text(PAGEKD, KdpNotSupported)
#pragma alloc_text(PAGEKD, KdpCauseBugCheck)
#pragma alloc_text(PAGEKD, KdpWriteBreakPointEx)
#pragma alloc_text(PAGEKD, KdpRestoreBreakPointEx)
#pragma alloc_text(PAGEKD, KdpSearchMemory)
#pragma alloc_text(PAGEKD, KdpSearchHammingDistance)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalPage)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalMemoryRequested)
#pragma alloc_text(PAGEKD, KdpSearchPhysicalPageRange)
#pragma alloc_text(PAGEKD, KdpCheckLowMemory)
#pragma alloc_text(PAGEKD, KdpFillMemory)
#pragma alloc_text(PAGEKD, KdpQueryMemory)
#pragma alloc_text(PAGEKD, KdpSysGetVersion)
#pragma alloc_text(PAGEKD, KdpSysReadBusData)
#pragma alloc_text(PAGEKD, KdpSysWriteBusData)
#pragma alloc_text(PAGEKD, KdpSysCheckLowMemory)
#pragma alloc_text(PAGEKD, KdpSendTraceData)
#pragma alloc_text(PAGEKD, KdReportTraceData)
#if DBG
#pragma alloc_text(PAGEKD, KdpDprintf)
#endif
#if i386
#pragma alloc_text(PAGEKD, InternalBreakpointCheck)
#pragma alloc_text(PAGEKD, KdSetInternalBreakpoint)
#pragma alloc_text(PAGEKD, KdGetTraceInformation)
#pragma alloc_text(PAGEKD, KdGetInternalBreakpoint)
#pragma alloc_text(PAGEKD, SymNumFor)
#pragma alloc_text(PAGEKD, PotentialNewSymbol)
#pragma alloc_text(PAGEKD, DumpTraceData)
#pragma alloc_text(PAGEKD, TraceDataRecordCallInfo)
#pragma alloc_text(PAGEKD, SkippingWhichBP)
#pragma alloc_text(PAGEKD, KdQuerySpecialCalls)
#pragma alloc_text(PAGEKD, KdSetSpecialCall)
#pragma alloc_text(PAGEKD, KdClearSpecialCalls)
#pragma alloc_text(PAGEKD, KdpCheckTracePoint)
#pragma alloc_text(PAGEKD, KdpProcessInternalBreakpoint)
#endif // i386
#endif // ALLOC_PRAGMA


//
// This variable has a count for each time KdDisableDebugger has been called.
//
LONG KdDisableCount = 0 ;
BOOLEAN KdPreviouslyEnabled = FALSE ;


#if DBG
VOID
KdpDprintf(
    IN PCHAR f,
    ...
    )
/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    f - Supplies printf format

Return Value:

    None

--*/
{
    char    buf[100];
    STRING  Output;
    va_list mark;

    va_start(mark, f);
    _vsnprintf(buf, 100, f, mark);
    va_end(mark);

    Output.Buffer = buf;
    Output.Length = (USHORT) strlen(Output.Buffer);
    KdpPrintString(&Output);
}
#endif // DBG


BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function is used to enter the kernel debugger. Its purpose
    is to freeze all other processors and aqcuire the kernel debugger
    comm port.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Returns the previous interrupt enable.

--*/

{

    BOOLEAN Enable;
    TIME_FIELDS TimeFields;
#if DBG
    extern ULONG KiFreezeFlag;
#endif

    //
    // HACKHACK - do some crude timer support
    //            but not if called from KdSetOwedBreakpoints()
    //

    if (TrapFrame) {
        KdTimerStop = KdpQueryPerformanceCounter (TrapFrame);
        KdTimerDifference.QuadPart = KdTimerStop.QuadPart - KdTimerStart.QuadPart;
    } else {
        KdTimerStop.QuadPart = 0;
    }

    //
    // Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug
    // port state.  We lock the port so that KdPollBreakin and a debugger
    // operation don't interfere with each other.
    //

    Enable = KeFreezeExecution(TrapFrame, ExceptionFrame);
    KdpPortLocked = KeTryToAcquireSpinLockAtDpcLevel(&KdpDebuggerLock);
    KdSave(FALSE);
    KdEnteredDebugger = TRUE;

#if DBG

    if ((KiFreezeFlag & FREEZE_BACKUP) != 0) {
        DPRINT(("FreezeLock was jammed!  Backup SpinLock was used!\n"));
    }

    if ((KiFreezeFlag & FREEZE_SKIPPED_PROCESSOR) != 0) {
        DPRINT(("Some processors not frozen in debugger!\n"));
    }

    if (KdpPortLocked == FALSE) {
        DPRINT(("Port lock was not acquired!\n"));
    }

#endif

    return Enable;
}

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function is used to exit the kernel debugger. It is the reverse
    of KdEnterDebugger.

Arguments:

    Enable - Supplies the previous interrupt enable which is to be restored.

Return Value:

    None.

--*/

{
    ULONG ElapsedTime;
    ULARGE_INTEGER TimeDifference;
    TIME_FIELDS TimeFields;
    ULONG Pending;

    //
    // restore stuff and exit
    //

    KdRestore(FALSE);
    if (KdpPortLocked) {
        KdpPortUnlock();
    }

    KeThawExecution(Enable);

    //
    // Do some crude timer support.  If KdEnterDebugger didn't
    // Query the performance counter, then don't do it here either.
    //

    if (KdTimerStop.QuadPart == 0) {
        KdTimerStart = KdTimerStop;
    } else {
        KdTimerStart = KeQueryPerformanceCounter(NULL);
    }

    //
    // Process a time slip
    //

    if (!PoHiberInProgress) {

        Pending = InterlockedIncrement(&KdpTimeSlipPending);

        //
        // If there's wasn't a time slip pending, queue the DPC to handle it
        //

        if (Pending == 1) {
            InterlockedIncrement(&KdpTimeSlipPending);
            KeInsertQueueDpc(&KdpTimeSlipDpc, NULL, NULL);
        }
    }

    return;
}


VOID
KdUpdateTimeSlipEvent(
    PVOID Event
    )

/*++

Routine Description:

    Update the reference to an event object which will be signalled when
    the debugger has caused the system clock to skew.

Arguments:

    Event - Supplies a pointer to an event object

Return Value:

    None

--*/

{
    KIRQL OldIrql;

    KeAcquireSpinLock(&KdpTimeSlipEventLock, &OldIrql);

    //
    // Dereference the old event and forget about it.
    // Remember the new event if there is one.
    //

    if (KdpTimeSlipEvent != NULL) {
        ObDereferenceObject(KdpTimeSlipEvent);
    }

    KdpTimeSlipEvent = Event;

    KeReleaseSpinLock(&KdpTimeSlipEventLock, OldIrql);
}

VOID
KdpTimeSlipDpcRoutine (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LONG OldCount, NewCount, j;

    //
    // Reset pending count.  If the current count is 1, then clear
    // the pending count.  if the current count is greater then 1,
    // then set to one and update the time now.
    //

    j = KdpTimeSlipPending;
    do {
        OldCount = j;
        NewCount = OldCount > 1 ? 1 : 0;

        j = InterlockedCompareExchange(&KdpTimeSlipPending, NewCount, OldCount);

    } while (j != OldCount);

    //
    // If new count is non-zero, then process a time slip now
    //

    if (NewCount) {
        ExQueueWorkItem(&KdpTimeSlipWorkItem, DelayedWorkQueue);
    }
}

VOID
KdpTimeSlipWork (
    IN PVOID Context
    )
{
    KIRQL               OldIrql;
    LARGE_INTEGER       DueTime;

    //
    // Update time from the real time clock.
    // If the lock is held by somebody else, don't bother as it's not worth
    // tying up a worker thread.
    //

    if (ExAcquireTimeRefreshLock(FALSE)) {
        ExUpdateSystemTimeFromCmos (FALSE, 0);
        ExReleaseTimeRefreshLock();

        //
        // If there's a time service installed, signal it's time slip event
        //

        KeAcquireSpinLock(&KdpTimeSlipEventLock, &OldIrql);
        if (KdpTimeSlipEvent) {
            KeSetEvent (KdpTimeSlipEvent, 0, FALSE);
        }
        KeReleaseSpinLock(&KdpTimeSlipEventLock, OldIrql);

        //
        // Insert a forced delay between time slip operations
        //

        DueTime.QuadPart = -1800000000;
        KeSetTimer (&KdpTimeSlipTimer, DueTime, &KdpTimeSlipDpc);
    }
}

#if i386

#if 0
#define INTBP_PRINT(Args) DPRINT(Args)
#else
#define INTBP_PRINT(Args)
#endif

VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LARGE_INTEGER dueTime;
    ULONG i;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
    dueTime.HighPart = -1;

    KeSetTimer(
        &InternalBreakpointTimer,
        dueTime,
        &InternalBreakpointCheckDpc
        );

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {

            PDBGKD_INTERNAL_BREAKPOINT b = KdpInternalBPs + i;
            ULONG callsThisPeriod;

            callsThisPeriod = b->Calls - b->CallsLastCheck;
            if ( callsThisPeriod > b->MaxCallsPerPeriod ) {
                b->MaxCallsPerPeriod = callsThisPeriod;
            }
            b->CallsLastCheck = b->Calls;
        }
    }

    return;

} // InternalBreakpointCheck


VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function sets an internal breakpoint.  "Internal breakpoint"
    means one in which control is not returned to the kernel debugger at
    all, but rather just update internal counting routines and resume.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    ULONG savedFlags;

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( KdpInternalBPs[i].Addr ==
                            m->u.SetInternalBreakpoint.BreakpointAddress ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
            if ( KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
                bp = &KdpInternalBPs[i];
                break;
            }
        }
    }

    if ( !bp ) {
        if ( KdpNumInternalBreakpoints >= DBGKD_MAX_INTERNAL_BREAKPOINTS ) {
            return; // no space.  Probably should report error.
        }
        bp = &KdpInternalBPs[KdpNumInternalBreakpoints++];
        bp->Flags |= DBGKD_INTERNAL_BP_FLAG_INVALID; // force initialization
    }

    if ( bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
        if ( m->u.SetInternalBreakpoint.Flags &
                                        DBGKD_INTERNAL_BP_FLAG_INVALID ) {
            return; // tried clearing a non-existant BP.  Ignore the request
        }
        bp->Calls = bp->MaxInstructions = bp->TotalInstructions = 0;
        bp->CallsLastCheck = bp->MaxCallsPerPeriod = 0;
        bp->MinInstructions = 0xffffffff;
        bp->Handle = 0;
        bp->Thread = 0;
    }

    savedFlags = bp->Flags;
    bp->Flags = m->u.SetInternalBreakpoint.Flags; // this could possibly invalidate the BP
    bp->Addr = m->u.SetInternalBreakpoint.BreakpointAddress;

    if ( bp->Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                      DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {

        if ( (bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (bp->Thread != 0) ) {
            // The breakpoint is active; defer its deletion
            bp->Flags &= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
            bp->Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
        }

        // This is really a CLEAR bp request.

        if ( bp->Handle != 0 ) {
            KdpDeleteBreakpoint( bp->Handle );
        }
        bp->Handle = 0;

        return;
    }

    // now set the real breakpoint and remember its handle.

    if ( savedFlags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
        // breakpoint was invalid; activate it now
        bp->Handle = KdpAddBreakpoint( (PVOID)bp->Addr );

        INTBP_PRINT(("Added intbp %d of %d at %I64x, flags %x, handle %x\n",
                     (ULONG)(bp - KdpInternalBPs), KdpNumInternalBreakpoints,
                     bp->Addr, bp->Flags, bp->Handle));
    }

    if ( BreakpointsSuspended ) {
        KdpSuspendBreakpoint( bp->Handle );
    }

} // KdSetInternalBreakpoint

NTSTATUS
KdGetTraceInformation(
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    in a buffer provided for it.  It is designed to be called from
    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP
    except that it communicates locally, and returns all the breakpoints
    at once.

Arguments:

    SystemInforamtion - the buffer into which to write the result.
    SystemInformationLength - the maximum length to write
    RetrunLength - How much data was really written

Return Value:

    None.

--*/

{
    ULONG numEntries = 0;
    ULONG i = 0;
    PDBGKD_GET_INTERNAL_BREAKPOINT64 outPtr;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            numEntries++;
        }
    }

    *ReturnLength = numEntries * sizeof(DBGKD_GET_INTERNAL_BREAKPOINT64);
    if ( *ReturnLength > SystemInformationLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // We've got enough space.  Copy it in.
    //

    outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT64)SystemInformation;
    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            outPtr->BreakpointAddress = KdpInternalBPs[i].Addr;
            outPtr->Flags = KdpInternalBPs[i].Flags;
            outPtr->Calls = KdpInternalBPs[i].Calls;
            outPtr->MaxCallsPerPeriod = KdpInternalBPs[i].MaxCallsPerPeriod;
            outPtr->MinInstructions = KdpInternalBPs[i].MinInstructions;
            outPtr->MaxInstructions = KdpInternalBPs[i].MaxInstructions;
            outPtr->TotalInstructions = KdpInternalBPs[i].TotalInstructions;
            outPtr++;
        }
    }

    return STATUS_SUCCESS;

} // KdGetTraceInformation

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    to the calling debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                                          DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &&
             (KdpInternalBPs[i].Addr ==
                        m->u.GetInternalBreakpoint.BreakpointAddress) ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        m->u.GetInternalBreakpoint.Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
        m->u.GetInternalBreakpoint.Calls = 0;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
        m->u.GetInternalBreakpoint.MinInstructions = 0;
        m->u.GetInternalBreakpoint.MaxInstructions = 0;
        m->u.GetInternalBreakpoint.TotalInstructions = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->u.GetInternalBreakpoint.Flags = bp->Flags;
        m->u.GetInternalBreakpoint.Calls = bp->Calls;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = bp->MaxCallsPerPeriod;
        m->u.GetInternalBreakpoint.MinInstructions = bp->MinInstructions;
        m->u.GetInternalBreakpoint.MaxInstructions = bp->MaxInstructions;
        m->u.GetInternalBreakpoint.TotalInstructions = bp->TotalInstructions;
        m->ReturnStatus = STATUS_SUCCESS;
    }

    m->ApiNumber = DbgKdGetInternalBreakPointApi;

    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL,
                 &KdpContext
                 );

    return;

} // KdGetInternalBreakpoint
#endif // i386

KCONTINUE_STATUS
KdpSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet, and then waits for a continue message.
    BreakIns received while waiting will always cause a resend of the
    packet originally sent out.  While waiting, manipulate messages
    will be serviced.

    A resend always resends the original event sent to the debugger,
    not the last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)KdpMessageBuffer;
    KdpContextSent = FALSE;

ResendPacket:

    //
    // Send event notification packet to debugger on host.  Come back
    // here any time we see a breakin sequence.
    //

    KdSendPacket(
        OutPacketType,
        OutMessageHeader,
        OutMessageData,
        &KdpContext
        );

    //
    // After sending packet, if there is no response from debugger
    // AND the packet is for reporting symbol (un)load, the debugger
    // will be declared to be not present.  Note If the packet is for
    // reporting exception, the KdSendPacket will never stop.
    //

    if (KdDebuggerNotPresent) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {

            ReturnCode = KdReceivePacket(
                            PACKET_TYPE_KD_STATE_MANIPULATE,
                            &MessageHeader,
                            &MessageData,
                            &Length,
                            &KdpContext
                            );
            if (ReturnCode == (USHORT)KDP_PACKET_RESEND) {
                goto ResendPacket;
            }
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            KdpReadVirtualMemory(&ManipulateState,&MessageData,ContextRecord);
            break;
#if 0
        case DbgKdReadVirtualMemory64Api:
            KdpReadVirtualMemory64(&ManipulateState,&MessageData,ContextRecord);
            break;
#endif
        case DbgKdWriteVirtualMemoryApi:
            KdpWriteVirtualMemory(&ManipulateState,&MessageData,ContextRecord);
            break;
#if 0
        case DbgKdWriteVirtualMemory64Api:
            KdpWriteVirtualMemory64(&ManipulateState,&MessageData,ContextRecord);
            break;
#endif

        case DbgKdCheckLowMemoryApi:
            KdpCheckLowMemory (&ManipulateState);
            break;

        case DbgKdReadPhysicalMemoryApi:
            KdpReadPhysicalMemory(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWritePhysicalMemoryApi:
            KdpWritePhysicalMemory(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdGetContextApi:
            KdpGetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetContextApi:
            KdpSetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            KdpWriteBreakpoint(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdRestoreBreakPointApi:
            KdpRestoreBreakpoint(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadControlSpaceApi:
            KdpReadControlSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteControlSpaceApi:
            KdpWriteControlSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadIoSpaceApi:
            KdpReadIoSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteIoSpaceApi:
            KdpWriteIoSpace(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadIoSpaceExtendedApi:
            KdpReadIoSpaceExtended(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteIoSpaceExtendedApi:
            KdpWriteIoSpaceExtended(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdReadMachineSpecificRegister:
            KdpReadMachineSpecificRegister(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteMachineSpecificRegister:
            KdpWriteMachineSpecificRegister(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdGetBusDataApi:
            KdpGetBusData(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetBusDataApi:
            KdpSetBusData(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                KdpGetStateChange(&ManipulateState,ContextRecord);
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdRebootApi:
            HalReturnToFirmware(HalRebootRoutine);
            break;

#if defined(i386)
        case DbgKdSetSpecialCallApi:
            KdSetSpecialCall(&ManipulateState,ContextRecord);
            break;

        case DbgKdClearSpecialCallsApi:
            KdClearSpecialCalls();
            break;

        case DbgKdSetInternalBreakPointApi:
            KdSetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdGetInternalBreakPointApi:
            KdGetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdClearAllInternalBreakpointsApi:
            KdpNumInternalBreakpoints = 0;
            break;

#endif // i386

        case DbgKdGetVersionApi:
            KdpGetVersion(&ManipulateState);
            break;

        case DbgKdCauseBugCheckApi:
            KdpCauseBugCheck(&ManipulateState);
            break;

        case DbgKdPageInApi:
            KdpNotSupported(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = KdpWriteBreakPointEx(&ManipulateState,
                                          &MessageData,
                                          ContextRecord);
            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }
            break;

        case DbgKdRestoreBreakPointExApi:
            KdpRestoreBreakPointEx(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSwitchProcessor:
            KdRestore(FALSE);
            ContinueStatus = KeSwitchFrozenProcessor(ManipulateState.Processor);
            KdSave(FALSE);
            return ContinueStatus;

        case DbgKdSearchMemoryApi:
            KdpSearchMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdFillMemoryApi:
            KdpFillMemory(&ManipulateState, &MessageData, ContextRecord);
            break;
            
        case DbgKdQueryMemoryApi:
            KdpQueryMemory(&ManipulateState, ContextRecord);
            break;
            
            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, &MessageData, &KdpContext);
            break;
        }
    }
}

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{
    ULONG Length;
    STRING MessageHeader;

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = m->u.ReadMemory.TransferCount;
    if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    }

    //
    // Move the data to the destination buffer.
    //

    m->ReturnStatus =
        KdpCopyMemoryChunks(m->u.ReadMemory.TargetBaseAddress,
                            AdditionalData->Buffer,
                            Length,
                            0,
                            MMDBG_COPY_UNSAFE,
                            &Length);

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    AdditionalData->Length = (USHORT)Length;
    m->u.ReadMemory.ActualBytesRead = Length;

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData,
                 &KdpContext);

    return;
}

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    STRING MessageHeader;

    //
    // Move the data to the destination buffer.
    //

    m->ReturnStatus =
        KdpCopyMemoryChunks(m->u.WriteMemory.TargetBaseAddress,
                            AdditionalData->Buffer,
                            AdditionalData->Length,
                            0,
                            MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE,
                            &m->u.WriteMemory.ActualBytesWritten);

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL,
                 &KdpContext);

    return;
}

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_CONTEXT a = &m->u.GetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (m->Processor >= (USHORT)KeNumberProcessors) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        AdditionalData->Length = sizeof(CONTEXT);
        if (m->Processor == (USHORT)KeGetCurrentPrcb()->Number) {
            KdpQuickMoveMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(CONTEXT));
        } else {
            KdpQuickMoveMemory(AdditionalData->Buffer,
                          (PCHAR)&KiProcessorBlock[m->Processor]->ProcessorState.ContextFrame,
                          sizeof(CONTEXT)
                         );
        }
        KdpContextSent = TRUE;
    }

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_SET_CONTEXT a = &m->u.SetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == sizeof(CONTEXT));

    if ((m->Processor >= (USHORT)KeNumberProcessors) ||
        (KdpContextSent == FALSE)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        if (m->Processor == (USHORT)KeGetCurrentPrcb()->Number) {
            KdpQuickMoveMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(CONTEXT));
        } else {
            KdpQuickMoveMemory((PCHAR)&KiProcessorBlock[m->Processor]->ProcessorState.ContextFrame,
                          AdditionalData->Buffer,
                          sizeof(CONTEXT)
                         );
        }
    }

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    a->BreakPointHandle = KdpAddBreakpoint((PVOID)a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);
    if (KdpDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

#if defined(_X86_)

long
SymNumFor(
    ULONG pc
    )
{
    ULONG index;

    for (index = 0; index < NumTraceDataSyms; index++) {
        if ((TraceDataSyms[index].SymMin <= pc) &&
            (TraceDataSyms[index].SymMax > pc)) return(index);
    }
    return(-1);
}

#if 0
#define TRACE_PRINT(Args) DPRINT(Args)
#else
#define TRACE_PRINT(Args)
#endif

BOOLEAN TraceDataBufferFilled = FALSE;

void PotentialNewSymbol (ULONG pc)
{
    if (!TraceDataBufferFilled &&
        -1 != SymNumFor(pc)) {     // we've already seen this one
        TRACE_PRINT(("PNS %x repeat %d\n", pc, SymNumFor(pc)));
        return;
    }

    TraceDataBufferFilled = FALSE;

    // OK, we've got to start up a TraceDataRecord
    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange = 0;

    if (-1 != SymNumFor(pc)) {
        int sym = SymNumFor(pc);
        TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) sym;
        KdpCurrentSymbolStart = TraceDataSyms[sym].SymMin;
        KdpCurrentSymbolEnd = TraceDataSyms[sym].SymMax;

        TRACE_PRINT(("PNS %x repeat %d at %d\n",
                     pc, sym, TraceDataBufferPosition));
        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = KdpCurrentSymbolStart;
    TraceDataSyms[NextTraceDataSym].SymMax = KdpCurrentSymbolEnd;

    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = NextTraceDataSym;

    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    NextTraceDataSym = (NextTraceDataSym + 1) % 256;
    if (NumTraceDataSyms < NextTraceDataSym) {
        NumTraceDataSyms = NextTraceDataSym;
    }

    TRACE_PRINT(("PNS %x in %x - %x, next %d, num %d\n", pc,
                 KdpCurrentSymbolStart, KdpCurrentSymbolEnd,
                 NextTraceDataSym, NumTraceDataSyms));
}

void DumpTraceData(PSTRING MessageData)
{
    TraceDataBuffer[0].LongNumber = TraceDataBufferPosition;
    MessageData->Length =
        (USHORT)(sizeof(TraceDataBuffer[0]) * TraceDataBufferPosition);
    MessageData->Buffer = (PVOID)TraceDataBuffer;
    TRACE_PRINT(("DumpTraceData returns %d records\n",
                 TraceDataBufferPosition));
    TraceDataBufferPosition = 1;
}

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG pc
    )
{
    // We've just exited a symbol scope.  The InstructionsTraced number goes
    // with the old scope, the CallLevelChange goes with the new, and the
    // pc fills in the symbol for the new TraceData record.

    long SymNum = SymNumFor(pc);

    if (KdpNextCallLevelChange != 0) {
        TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =
                                                (char) KdpNextCallLevelChange;
        KdpNextCallLevelChange = 0;
    }


    if (InstructionsTraced >= TRACE_DATA_INSTRUCTIONS_BIG) {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           TRACE_DATA_INSTRUCTIONS_BIG;
       TraceDataBuffer[TraceDataBufferPosition+1].LongNumber =
           InstructionsTraced;
       TraceDataBufferPosition += 2;
    } else {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           (unsigned short)InstructionsTraced;
       TraceDataBufferPosition++;
    }

    if ((TraceDataBufferPosition + 2 >= TRACE_DATA_BUFFER_MAX_SIZE) ||
        (-1 == SymNum)) {
        if (TraceDataBufferPosition +2 >= TRACE_DATA_BUFFER_MAX_SIZE) {
            TraceDataBufferFilled = TRUE;
        }
       KdpNextCallLevelChange = CallLevelChange;
       TRACE_PRINT(("TDRCI nosym %x, lc %d, pos %d\n", pc, CallLevelChange,
                    TraceDataBufferPosition));
       return FALSE;
    }

    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =(char)CallLevelChange;
    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) SymNum;
    KdpCurrentSymbolStart = TraceDataSyms[SymNum].SymMin;
    KdpCurrentSymbolEnd = TraceDataSyms[SymNum].SymMax;

    TRACE_PRINT(("TDRCI sym %d for %x, %x - %x, lc %d, pos %d\n", SymNum, pc,
                 KdpCurrentSymbolStart, KdpCurrentSymbolEnd, CallLevelChange,
                 TraceDataBufferPosition));
    return TRUE;
}

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    )

/*
 * Return TRUE iff the pc corresponds to an internal breakpoint
 * that has just been replaced for execution.  If TRUE, then return
 * the breakpoint number in BPNum.
 */

{
    ULONG index;

    if (!IntBPsSkipping) return FALSE;

    for (index = 0; index < KdpNumInternalBreakpoints; index++) {
        if (!(KdpInternalBPs[index].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
            (KdpInternalBPs[index].Thread == thread)) {
            *BPNum = index;
            return TRUE;
        }
    }
    return FALSE; // didn't match any
}


NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    ULONG Length,
    PULONG RequiredLength
    )
{
    *RequiredLength = sizeof(DBGKD_MANIPULATE_STATE64) +
                        (sizeof(ULONG) * KdNumberOfSpecialCalls);

    if ( Length < *RequiredLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    m->u.QuerySpecialCalls.NumberOfSpecialCalls = KdNumberOfSpecialCalls;
    KdpQuickMoveMemory(
        (PCHAR)(m + 1),
        (PCHAR)KdSpecialCalls,
        sizeof(ULONG) * KdNumberOfSpecialCalls
        );

    return STATUS_SUCCESS;

} // KdQuerySpecialCalls


VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sets the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    if ( KdNumberOfSpecialCalls >= DBGKD_MAX_SPECIAL_CALLS ) {
        return; // too bad
    }

    KdSpecialCalls[KdNumberOfSpecialCalls++] = (ULONG_PTR)m->u.SetSpecialCall.SpecialCall;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
    KdpNextCallLevelChange = 0;
    if (ContextRecord && !InstrCountInternal) {
        InitialSP = ContextRecord->Esp;
    }

} // KdSetSpecialCall


VOID
KdClearSpecialCalls (
    VOID
    )

/*++

Routine Description:

    This function clears the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KdNumberOfSpecialCalls = 0;
    return;

} // KdClearSpecialCalls


BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )
{
    ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    LONG BpNum;
    ULONG SkippedBPNum;
    BOOLEAN AfterSC = FALSE;

    if (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        if (WatchStepOverSuspended) {
            //
            //  For background, see the comment below where WSOThread is
            //  wrong.  We've now stepped over the breakpoint in the non-traced
            //  thread, and need to replace it and restart the non-traced
            //  thread at full speed.
            //

            WatchStepOverHandle = KdpAddBreakpoint((PVOID)WatchStepOverBreakAddr);
            WatchStepOverSuspended = FALSE;
            ContextRecord->EFlags &= ~0x100L; /* clear trace flag */
            return TRUE; // resume non-traced thread at full speed
        }

        if ((!SymbolRecorded) && (KdpCurrentSymbolStart != 0) && (KdpCurrentSymbolEnd != 0)) {
            //
            //  We need to use oldpc here, because this may have been
            //  a 1 instruction call.  We've ALREADY executed the instruction
            //  that the new symbol is for, and if the pc has moved out of
            //  range, we might mess up.  Hence, use the pc from when
            //  SymbolRecorded was set.  Yuck.
            //

            PotentialNewSymbol(oldpc);
            SymbolRecorded = TRUE;
        }

        if (!InstrCountInternal &&
            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

            //
            //  We just single-stepped over a temporarily removed internal
            //  breakpoint.
            //  If it's a COUNTONLY breakpoint:
            //      Put the breakpoint instruction back and resume
            //      regular execution.
            //

            if (KdpInternalBPs[SkippedBPNum].Flags &
                DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {

                IntBPsSkipping --;

                KdpRestoreAllBreakpoints();

                ContextRecord->EFlags &= ~0x100L;  // Clear trace flag
                KdpInternalBPs[SkippedBPNum].Thread = 0;

                if (KdpInternalBPs[SkippedBPNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                            DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }

                return TRUE;
            }

            //
            //  If it's not:
            //      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd
            //      and bop off into single step land.  We probably ought to
            //      disable all breakpoints here, too, so that we don't do
            //      anything foul like trying two non-COUNTONLY's at the
            //      same time or something...
            //

            KdpCurrentSymbolEnd = 0;
            KdpCurrentSymbolStart = (ULONG_PTR) KdpInternalBPs[SkippedBPNum].ReturnAddress;

            ContextRecord->EFlags |= 0x100L; /* Trace on. */
            InitialSP = ContextRecord->Esp;

            InstructionsTraced = 1;  /* Count the initial call instruction. */
            InstrCountInternal = TRUE;
        }

    } /* if single step */
    else if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        if (WatchStepOver && pc == WatchStepOverBreakAddr) {
            //
            //  This is a breakpoint after completion of a "special call"
            //

            if ((WSOThread != (PVOID)KeGetCurrentThread()) ||
                (WSOEsp + 0x20 < ContextRecord->Esp) ||
                (ContextRecord->Esp + 0x20 < WSOEsp)) {
                //
                //  Here's the story up to this point: the traced thread
                //  cruised along until it it a special call.  The tracer
                //  placed a breakpoint on the instruction immediately after
                //  the special call returns and restarted the traced thread
                //  at full speed.  Then, some *other* thread hit the
                //  breakpoint.  So, to correct for this, we're going to
                //  remove the breakpoint, single step the non-traced
                //  thread one instruction, replace the breakpoint,
                //  restart the non-traced thread at full speed, and wait
                //  for the traced thread to get to this breakpoint, just
                //  like we were when this happened.  The assumption
                //  here is that the traced thread won't hit the breakpoint
                //  while it's removed, which I believe to be true, because
                //  I don't think a context switch can occur during a single
                //  step operation.
                //
                //  For extra added fun, it's possible to execute interrupt
                //  routines IN THE SAME THREAD!!!  That's why we need to keep
                //  the stack pointer as well as the thread address: the APC
                //  code can result in pushing on the stack and doing a call
                //  that's really part on an interrupt service routine in the
                //  context of the current thread.  Lovely, isn't it?
                //

                WatchStepOverSuspended = TRUE;
                KdpDeleteBreakpoint(WatchStepOverHandle);
                ContextRecord->EFlags |= 0x100L; // Set trace flag
                return TRUE; // single step "non-traced" thread
            }

            //
            //  we're in the thread we started in; resume in single-step mode
            //  to continue the trace.
            //

            WatchStepOver = FALSE;
            KdpDeleteBreakpoint(WatchStepOverHandle);
            ContextRecord->EFlags |= 0x100L; // back to single step mode
            AfterSC = TRUE; // put us into the regular watchStep code

        } else {

            for ( BpNum = 0; BpNum < (LONG) KdpNumInternalBreakpoints; BpNum++ ) {
                if ( !(KdpInternalBPs[BpNum].Flags &
                       (DBGKD_INTERNAL_BP_FLAG_INVALID |
                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &&
                     ((ULONG_PTR)KdpInternalBPs[BpNum].Addr == pc) ) {
                    break;
                }
            }

            if ( BpNum < (LONG) KdpNumInternalBreakpoints ) {

                //
                //  This is an internal monitoring breakpoint.
                //  Restore the instruction and start in single-step
                //  mode so that we can retore the breakpoint once the
                //  instruction executes, or continue stepping if this isn't
                //  a COUNTONLY breakpoint.
                //

                KdpProcessInternalBreakpoint( BpNum );
                KdpInternalBPs[BpNum].Thread = (PVOID)KeGetCurrentThread();
                IntBPsSkipping ++;

                KdpSuspendAllBreakpoints();

                ContextRecord->EFlags |= 0x100L;  // Set trace flag
                if (!(KdpInternalBPs[BpNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
                    KdpInternalBPs[BpNum].ReturnAddress =
                                    KdpGetReturnAddress( ContextRecord );
                }
                return TRUE;
            }
        }
    } /* if breakpoint */

//  if (AfterSC) {
//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));
//  }

    if ((AfterSC || ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) &&
        KdpCurrentSymbolStart != 0 &&
        ((KdpCurrentSymbolEnd == 0 && ContextRecord->Esp <= InitialSP) ||
         (KdpCurrentSymbolStart <= pc && pc < KdpCurrentSymbolEnd))) {
        ULONG lc;
        BOOLEAN IsSpecialCall;

        //
        //  We've taken a step trace, but are still executing in the current
        //  function.  Remember that we executed an instruction and see if the
        //  instruction changes the call level.
        //

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced++;
        CallLevelChange += lc;

        //
        //  See if instruction is a transfer to a special routine, one that we
        //  cannot trace through since it may swap contexts
        //

        if (IsSpecialCall) {

//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );

            //
            //  We are about to transfer to a special call routine.  Since we
            //  cannot trace through this routine, we execute it atomically by
            //  setting a breakpoint at the next logical offset.
            //
            //  Note in the case of an indirect jump to a special call routine, the
            //  level change will be -1 and the next offset will be the ULONG that's
            //  on the top of the stack.
            //
            //  However, we've already adjusted the level based on this
            //  instruction.  We need to undo this except for the magic -1 call.
            //

            if (lc != -1) {
                CallLevelChange -= lc;
            }

            //
            //  Set up for stepping over a procedure
            //

            WatchStepOver = TRUE;
            WatchStepOverBreakAddr = KdpGetCallNextOffset( pc, ContextRecord );
            WSOThread = (PVOID)KeGetCurrentThread( );
            WSOEsp = ContextRecord->Esp;

            //
            //  Establish the breakpoint
            //

            WatchStepOverHandle = KdpAddBreakpoint( (PVOID)WatchStepOverBreakAddr );


            //
            //  Note that we are continuing rather than tracing and rely on hitting
            //  the breakpoint in the current thread context to resume the watch
            //  action.
            //

            ContextRecord->EFlags &= ~0x100L;
            return TRUE;
        }

        //
        //  Resume execution with the trace flag set.  Avoid going over the wire to
        //  the remote debugger.
        //

        ContextRecord->EFlags |= 0x100L;  // Set trace flag

        return TRUE;
    }

    if ((AfterSC || (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)) &&
        (KdpCurrentSymbolStart != 0)) {
        //
        // We're WatchTracing, but have just changed symbol range.
        // Fill in the call record and return to the debugger if
        // either we're full or the pc is outside of the known
        // symbol scopes.  Otherwise, resume stepping.
        //
        int lc;
        BOOLEAN IsSpecialCall;

        InstructionsTraced++; // don't forget to count the call/ret instruction.

//  if (AfterSC) {
//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));
//  }

        if (InstrCountInternal) {

            // We've just finished processing a non-COUNTONLY breakpoint.
            // Record the appropriate data and resume full speed execution.

            if (SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

                KdpInternalBPs[SkippedBPNum].Calls++;


                if (KdpInternalBPs[SkippedBPNum].MinInstructions > InstructionsTraced) {
                    KdpInternalBPs[SkippedBPNum].MinInstructions = InstructionsTraced;
                }
                if (KdpInternalBPs[SkippedBPNum].MaxInstructions < InstructionsTraced) {
                    KdpInternalBPs[SkippedBPNum].MaxInstructions = InstructionsTraced;
                }
                KdpInternalBPs[SkippedBPNum].TotalInstructions += InstructionsTraced;

                KdpInternalBPs[SkippedBPNum].Thread = 0;

                IntBPsSkipping--;
                KdpRestoreAllBreakpoints();

                if (KdpInternalBPs[SkippedBPNum].Flags &
                    DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                        DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }
            }

            KdpCurrentSymbolStart = 0;
            InstrCountInternal = FALSE;
            ContextRecord->EFlags &= ~0x100L; // clear trace flag
            return TRUE; // Back to normal execution.
        }

        if (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {

            //
            //  Everything was cool internally.  We can keep executing without
            //  going back to the remote debugger.
            //
            //  We have to compute lc after calling
            //  TraceDataRecordCallInfo, because LevelChange relies on
            //  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to
            //  the pc.
            //

            lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
            InstructionsTraced = 0;
            CallLevelChange = lc;

            //
            //  See if instruction is a transfer to a special routine, one that we
            //  cannot trace through since it may swap contexts
            //

            if (IsSpecialCall) {

//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));

                //
                //  We are about to transfer to a special call routine.  Since we
                //  cannot trace through this routine, we execute it atomically by
                //  setting a breakpoint at the next logical offset.
                //
                //  Note in the case of an indirect jump to a special call routine, the
                //  level change will be -1 and the next offset will be the ULONG that's
                //  on the top of the stack.
                //
                //  However, we've already adjusted the level based on this
                //  instruction.  We need to undo this except for the magic -1 call.
                //

                if (lc != -1) {
                    CallLevelChange -= lc;
                }

                //
                //  Set up for stepping over a procedure
                //

                WatchStepOver = TRUE;
                WSOThread = (PVOID)KeGetCurrentThread();

                //
                //  Establish the breakpoint
                //

                WatchStepOverHandle =
                    KdpAddBreakpoint( (PVOID)KdpGetCallNextOffset( pc, ContextRecord ));

                //
                //  Resume execution with the trace flag set.  Avoid going over the wire to
                //  the remote debugger.
                //

                ContextRecord->EFlags &= ~0x100L;
                return TRUE;
            }

            ContextRecord->EFlags |= 0x100L; // Set trace flag
            return TRUE; // Off we go
        }

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced = 0;
        CallLevelChange = lc;

        // We need to go back to the remote debugger.  Just fall through.

        if ((lc != 0) && IsSpecialCall) {
            // We're hosed
            DPRINT(( "Special call on first entry to symbol scope @ %x\n", pc ));
        }
    }

    SymbolRecorded = FALSE;
    oldpc = pc;

    return FALSE;
}

#endif // defined(_X86_)

VOID
KdpSetCommonState(
    IN ULONG NewState,
    IN PCONTEXT ContextRecord,
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange
    )
{
    BOOLEAN DeletedBps;
    PCHAR PcMemory;
    ULONG InstrCount;
    PUCHAR InstrStream;
    
    WaitStateChange->NewState = NewState;
    WaitStateChange->ProcessorLevel = KeProcessorLevel;
    WaitStateChange->Processor = (USHORT)KeGetCurrentPrcb()->Number;
    WaitStateChange->NumberProcessors = (ULONG)KeNumberProcessors;
    WaitStateChange->Thread = (ULONG64)(LONG64)(LONG_PTR)KeGetCurrentThread();
    PcMemory = (PCHAR)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR)PcMemory;

    RtlZeroMemory(&WaitStateChange->AnyControlReport,
                  sizeof(WaitStateChange->AnyControlReport));
    
    //
    // Copy instruction stream immediately following location of event.
    //

    InstrStream = WaitStateChange->ControlReport.InstructionStream;
    KdpCopyFromPtr(InstrStream, PcMemory, DBGKD_MAXSTREAM, &InstrCount);
    WaitStateChange->ControlReport.InstructionCount = (USHORT)InstrCount;

    //
    // Clear breakpoints in copied area.
    // If there were any breakpoints cleared, recopy the instruction area
    // without them.
    //

    if (KdpDeleteBreakpointRange(PcMemory, PcMemory + InstrCount - 1)) {
        KdpCopyFromPtr(InstrStream, PcMemory, InstrCount, &InstrCount);
    }
}

BOOLEAN
KdpSwitchProcessor (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )
{
    BOOLEAN Status;

    //
    // Save port state
    //

    KdSave(FALSE);

    //
    // Process state change for this processor
    //

    Status = KdpReportExceptionStateChange (
                ExceptionRecord,
                ContextRecord,
                SecondChance
                );

    //
    // Restore port state and return status
    //

    KdRestore(FALSE);
    return Status;
}

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

#if i386
    if (KdpCheckTracePoint(ExceptionRecord,ContextRecord)) return TRUE;
#endif

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdExceptionStateChange, ContextRecord,
                          &WaitStateChange);
        
        if (sizeof(EXCEPTION_RECORD) ==
            sizeof(WaitStateChange.u.Exception.ExceptionRecord)) {
            KdpQuickMoveMemory((PCHAR)&WaitStateChange.u.Exception.ExceptionRecord,
                               (PCHAR)ExceptionRecord,
                               sizeof(EXCEPTION_RECORD));
        } else {
            ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                                  &WaitStateChange.u.Exception.ExceptionRecord);
        }

        WaitStateChange.u.Exception.FirstChance = !SecondChance;

        KdpSetStateChange(&WaitStateChange,
                          ExceptionRecord,
                          ContextRecord,
                          SecondChance
                          );

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

#if i386
        //
        // Construct the wait state change data and data descriptor.
        //

        DumpTraceData(&MessageData);
#else
        MessageData.Length = 0;
#endif

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}


BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdLoadSymbolsStateChange, ContextRecord,
                          &WaitStateChange);
        KdpSetContextState(&WaitStateChange, ContextRecord);
        WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = (ULONG) SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT( PathName )) {
            KdpCopyFromPtr(KdpPathBuffer,
                           PathName->Buffer,
                           PathName->Length,
                           &WaitStateChange.u.LoadSymbols.PathNameLength);
            WaitStateChange.u.LoadSymbols.PathNameLength++;

            MessageData.Buffer = KdpPathBuffer;
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;
        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    AdditionalData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}


VOID
KdpReportCommandStringStateChange (
    IN PSTRING Name,
    IN PSTRING Command,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a command string packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    Name - Identifies the originator of the command.

    Command - Command string.

    ContextRecord - Context information.

Return Value:

    None.

--*/

{

    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;
    ULONG Length, Copied;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetCommonState(DbgKdCommandStringStateChange, ContextRecord,
                          &WaitStateChange);
        KdpSetContextState(&WaitStateChange, ContextRecord);
        RtlZeroMemory(&WaitStateChange.u.CommandString,
                      sizeof(WaitStateChange.u.CommandString));

        //
        // Transfer the string data into the message buffer.
        // The name is just a simple identifier so limit
        // it to a relatively short length.
        //

        MessageData.Buffer = KdpMessageBuffer;

        if (Name->Length > 127) {
            Length = 127;
        } else {
            Length = Name->Length;
        }
        
        KdpCopyFromPtr(MessageData.Buffer, Name->Buffer, Length, &Copied);
        MessageData.Length = (USHORT)Copied + 1;
        MessageData.Buffer[MessageData.Length - 1] = '\0';

        Length = PACKET_MAX_SIZE - sizeof(WaitStateChange) -
            MessageData.Length;
        if (Command->Length < Length) {
            Length = Command->Length;
        }
        KdpCopyFromPtr(MessageData.Buffer + MessageData.Length,
                       Command->Buffer, Length, &Copied);
        Length = Copied + 1;
        MessageData.Length += (USHORT)Length;
        MessageData.Buffer[MessageData.Length - 1] = '\0';
        
        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);
}


VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    ULONG MmFlags;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // make sure that nothing but a read memory message was transmitted
    //

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim transfer count to fit in a single message
    //

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    //
    // Initially there was no way to control the caching
    // flags for physical memory access.  Such control
    // is necessary for robust physical access, though,
    // as the proper kind of access must be made to avoid
    // breaking the processor TBs.  Rather than create a
    // new protocol request, the ActualBytes field
    // has been overridden to pass flags on input.  Prior
    // versions of the debugger set this to zero so this
    // is a compatible change.
    //

    MmFlags = MMDBG_COPY_PHYSICAL | MMDBG_COPY_UNSAFE;
    switch(a->ActualBytesRead)
    {
    case DBGKD_CACHING_CACHED:
        MmFlags |= MMDBG_COPY_CACHED;
        break;
    case DBGKD_CACHING_UNCACHED:
        MmFlags |= MMDBG_COPY_UNCACHED;
        break;
    case DBGKD_CACHING_WRITE_COMBINED:
        MmFlags |= MMDBG_COPY_WRITE_COMBINED;
        break;
    }
    
    m->ReturnStatus =
        KdpCopyMemoryChunks(a->TargetBaseAddress,
                            AdditionalData->Buffer,
                            Length,
                            0,
                            MmFlags,
                            &Length);

    AdditionalData->Length = (USHORT)Length;
    a->ActualBytesRead = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}



VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    STRING MessageHeader;
    ULONG MmFlags;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    // See ReadPhysical for an explanation of the ActualBytes usage.
    MmFlags = MMDBG_COPY_PHYSICAL | MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE;
    switch(a->ActualBytesWritten)
    {
    case DBGKD_CACHING_CACHED:
        MmFlags |= MMDBG_COPY_CACHED;
        break;
    case DBGKD_CACHING_UNCACHED:
        MmFlags |= MMDBG_COPY_UNCACHED;
        break;
    case DBGKD_CACHING_WRITE_COMBINED:
        MmFlags |= MMDBG_COPY_WRITE_COMBINED;
        break;
    }

    m->ReturnStatus =
        KdpCopyMemoryChunks(a->TargetBaseAddress,
                            AdditionalData->Buffer,
                            a->TransferCount,
                            0,
                            MmFlags,
                            &a->ActualBytesWritten);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read control space state
    manipulation message.  Its function is to read implementation
    specific system data.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    m->ReturnStatus = KdpSysReadControlSpace(m->Processor,
                                             a->TargetBaseAddress,
                                             AdditionalData->Buffer,
                                             Length, &Length);

    AdditionalData->Length = (USHORT)Length;
    a->ActualBytesRead = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write control space state
    manipulation message.  Its function is to write implementation
    specific system data.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    m->ReturnStatus = KdpSysWriteControlSpace(m->Processor,
                                              a->TargetBaseAddress,
                                              AdditionalData->Buffer,
                                              AdditionalData->Length,
                                              &Length);

    a->ActualBytesWritten = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read io space state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    // Zero-fill the entire value so that shorter reads
    // do not leave unset bytes.
    a->DataValue = 0;

    m->ReturnStatus = KdpSysReadIoSpace(Isa, 0, 1, a->IoAddress,
                                        &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write io space state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysWriteIoSpace(Isa, 0, 1, a->IoAddress,
                                         &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadIoSpaceExtended(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read io space extended state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m->u.ReadWriteIoExtended;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    // Zero-fill the entire value so that shorter reads
    // do not leave unset bytes.
    a->DataValue = 0;

    m->ReturnStatus = KdpSysReadIoSpace(a->InterfaceType, a->BusNumber,
                                        a->AddressSpace, a->IoAddress,
                                        &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteIoSpaceExtended(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write io space extended state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO_EXTENDED64 a = &m->u.ReadWriteIoExtended;
    STRING MessageHeader;
    ULONG Length;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysWriteIoSpace(a->InterfaceType, a->BusNumber,
                                         a->AddressSpace, a->IoAddress,
                                         &a->DataValue, a->DataSize, &Length);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a read MSR
    manipulation message.  Its function is to read the MSR.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    ULARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = KdpSysReadMsr(a->Msr, &l.QuadPart);

    a->DataValueLow  = l.LowPart;
    a->DataValueHigh = l.HighPart;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write of a MSR
    manipulation message.  Its function is to write to the MSR

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    ULARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    l.HighPart = a->DataValueHigh;
    l.LowPart = a->DataValueLow;

    m->ReturnStatus = KdpSysWriteMsr(a->Msr, &l.QuadPart);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
    UNREFERENCED_PARAMETER(Context);
}

VOID
KdpGetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a get bus data state
    manipulation message.  Its function is to read I/O configuration
    space.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_SET_BUS_DATA a = &m->u.GetSetBusData;
    ULONG Length;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim length to fit in a single message
    //

    if (a->Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->Length;
    }

    m->ReturnStatus = KdpSysReadBusData(a->BusDataType, a->BusNumber,
                                        a->SlotNumber, a->Offset,
                                        AdditionalData->Buffer,
                                        Length, &Length);

    a->Length = Length;
    AdditionalData->Length = (USHORT)Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

VOID
KdpSetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a set bus data state
    manipulation message.  Its function is to write I/O configuration
    space.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_SET_BUS_DATA a = &m->u.GetSetBusData;
    ULONG Length;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    m->ReturnStatus = KdpSysWriteBusData(a->BusDataType, a->BusNumber,
                                         a->SlotNumber, a->Offset,
                                         AdditionalData->Buffer,
                                         a->Length, &Length);

    a->Length = Length;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}



#if i386
VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    )
{
    if ( !(KdpInternalBPs[BreakpointNumber].Flags &
           DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
        return;     // We only deal with COUNTONLY breakpoints
    }

    //
    // We've hit a real internal breakpoint; make sure the timeout is
    // kicked off.
    //

    if ( !BreakPointTimerStarted ) { // ok, maybe there's a prettier way to do this.
        KeInitializeDpc(
            &InternalBreakpointCheckDpc,
            &InternalBreakpointCheck,
            NULL
            );
        KeInitializeTimer( &InternalBreakpointTimer );
        // KeSetTimer can only be called at <= DISPATCH_LEVEL
        // so just queue the timer DPC routine directly for
        // the initial check.
        KeInsertQueueDpc(&InternalBreakpointCheckDpc, NULL, NULL);
        BreakPointTimerStarted = TRUE;
    }

    KdpInternalBPs[BreakpointNumber].Calls++;

} // KdpProcessInternalBreakpoint
#endif


VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    STRING messageHeader;


    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    KdpSysGetVersion(&m->u.GetVersion64);

    //
    // the usual stuff
    //
    m->ReturnStatus = STATUS_SUCCESS;
    m->ApiNumber = DbgKdGetVersionApi;

    KdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL,
                 &KdpContext
                 );

    return;
} // KdGetVersion


NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine returns STATUS_UNSUCCESSFUL to the debugger

Arguments:

    m - Supplies a DBGKD_MANIPULATE_STATE64 struct to answer with

Return Value:

    0, to indicate that the system should not continue

--*/

{
    STRING          MessageHeader;

    //
    // setup packet
    //
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    m->ReturnStatus = STATUS_UNSUCCESSFUL;

    //
    // send back our response
    //
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return 0;
} // KdpNotSupported


VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine causes a bugcheck.  It is used for testing the debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{

    KeBugCheckEx( MANUALLY_INITIATED_CRASH, 0, 0, 0, 0 );

} // KdCauseBugCheck


NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64 b;
    STRING                    MessageHeader;
    ULONG                     i;
    ULONG                     Size;
    DBGKD_WRITE_BREAKPOINT64  BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
        a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64))
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdSendPacket(
            PACKET_TYPE_KD_STATE_MANIPULATE,
            &MessageHeader,
            AdditionalData,
            &KdpContext
            );
        return m->ReturnStatus;
    }

    KdpCopyFromPtr(BpBuf,
                   AdditionalData->Buffer,
                   a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64),
                   &Size);

    if (Size == a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64))
    {
        m->ReturnStatus = STATUS_SUCCESS;
    }
    else
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdSendPacket(
            PACKET_TYPE_KD_STATE_MANIPULATE,
            &MessageHeader,
            AdditionalData,
            &KdpContext
            );
        return m->ReturnStatus;
    }

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = KdpAddBreakpoint( (PVOID)b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    KdpCopyToPtr(AdditionalData->Buffer,
                 BpBuf,
                 a->BreakPointCount * sizeof(DBGKD_WRITE_BREAKPOINT64),
                 &Size);

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return a->ContinueStatus;
}


VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT   b;
    STRING                      MessageHeader;
    ULONG                       i;
    ULONG                       Size;
    DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT))
    {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        KdpCopyFromPtr(BpBuf,
                       AdditionalData->Buffer,
                       a->BreakPointCount * sizeof(DBGKD_RESTORE_BREAKPOINT),
                       &Size);

        if (Size == a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT))
        {
            m->ReturnStatus = STATUS_SUCCESS;

            //
            // loop thru the breakpoint handles passed in from the debugger and
            // clear any breakpoint that has a non-zero handle
            //
            b = BpBuf;
            for (i=0; i<a->BreakPointCount; i++,b++) {
                if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                    m->ReturnStatus = STATUS_UNSUCCESSFUL;
                }
            }
        }
        else
        {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //
    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData,
        &KdpContext
        );
}

VOID
KdDisableDebugger(
    VOID
    )
/*++

Routine Description:

    This function is called to disable the debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL oldIrql ;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql) ;
    KdpPortLock();

    if (!KdDisableCount) {

        KdPreviouslyEnabled = KdDebuggerEnabled && (!KdPitchDebugger) ;
        if (KdDebuggerEnabled) {

            KdpSuspendAllBreakpoints() ;
            KiDebugRoutine = KdpStub;
            KdDebuggerEnabled = FALSE ;
        }
    }
    KdDisableCount++ ;
    KdpPortUnlock();
    KeLowerIrql(oldIrql);
}

VOID
KdEnableDebugger(
   VOID
   )
/*++

Routine Description:

    This function is called to reenable the debugger after a call to
    KdDisableDebugger.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL oldIrql ;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql) ;
    KdpPortLock();

    ASSERT(KdDisableCount > 0) ;
    KdDisableCount-- ;

    if (!KdDisableCount) {
        if (KdPreviouslyEnabled) {

            //
            // Ugly HACKHACK - Make sure the timers aren't reset.
            //
            PoHiberInProgress = TRUE ;
            KdInitSystem(0, NULL);
            KdpRestoreAllBreakpoints();
            PoHiberInProgress = FALSE ;
        }
    }
    KdpPortUnlock();
    KeLowerIrql(oldIrql);
}


VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function implements a memory pattern searcher.  This will
    find an instance of a pattern that begins in the range
    SearchAddress..SearchAddress+SearchLength.  The pattern may
    end outside of the range.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PUCHAR Pattern = AdditionalData->Buffer;
    ULONG_PTR StartAddress = (ULONG_PTR)m->u.SearchMemory.SearchAddress;
    ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m->u.SearchMemory.SearchLength);
    ULONG PatternLength = m->u.SearchMemory.PatternLength;

    STRING MessageHeader;
    ULONG MaskIndex;
    PUCHAR PatternTail;
    ULONG_PTR DataTail;
    ULONG TailLength;
    ULONG Data;
    ULONG FirstWordPattern[4];
    ULONG FirstWordMask[4];
    UCHAR DataTailVal;


    //
    // On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN
    // STATUS_UNSUCCESSFUL!  That return status indicates that the
    // operation is not supported, and the debugger will fall back
    // to a debugger-side search.
    //

    m->ReturnStatus = STATUS_NO_MORE_ENTRIES;

    //
    // Do a fast search for the beginning of the pattern
    //

    if (PatternLength > 3) {
        FirstWordMask[0] = 0xffffffff;
    } else {
        FirstWordMask[0] = 0xffffffff >> (8*(4-PatternLength));
    }

    FirstWordMask[1] = FirstWordMask[0] << 8;
    FirstWordMask[2] = FirstWordMask[1] << 8;
    FirstWordMask[3] = FirstWordMask[2] << 8;

    FirstWordPattern[0] = 0;
    KdpQuickMoveMemory((PVOID)FirstWordPattern,
                       Pattern,
                       PatternLength < 5 ? PatternLength : 4);

    FirstWordPattern[1] = FirstWordPattern[0] << 8;
    FirstWordPattern[2] = FirstWordPattern[1] << 8;
    FirstWordPattern[3] = FirstWordPattern[2] << 8;


/*
{
    int i;
    for (i = 0; i < (int)PatternLength; i++) {
        KdpDprintf("%08x: %02x\n", &Pattern[i], Pattern[i]);
    }
    for (i = 0; i < 4; i++) {
        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);
    }
}
*/



    //
    // Get starting mask
    //

    MaskIndex = (ULONG) (StartAddress & 3);
    StartAddress = StartAddress & ~3;

    while (StartAddress < EndAddress) {

        // Get the current data DWORD.  StartAddress is
        // properly aligned and we only need the one DWORD
        // so we can directly call MmDbgCopyMemory.
        if (!NT_SUCCESS(MmDbgCopyMemory(StartAddress, &Data, 4,
                                        MMDBG_COPY_UNSAFE))) {
//KdpDprintf("\n%08x: Inaccessible\n", StartAddress);
            StartAddress += 4;
            MaskIndex = 0;
            continue;
        }
        
        //
        // search for a match in each of the 4 starting positions
        //

//KdpDprintf("\n%08x: %08x ", StartAddress, Data);

        for ( ; MaskIndex < 4; MaskIndex++) {
//KdpDprintf(" %d", MaskIndex);

            if ( (Data & FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {

                //
                // first word matched
                //

                if ( (4-MaskIndex) >= PatternLength ) {

                    //
                    // string is all in this word; good match
                    //
//KdpDprintf(" %d hit, complete\n", MaskIndex);

                    m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                    m->ReturnStatus = STATUS_SUCCESS;
                    goto done;

                } else {

                    //
                    // string is longer; see if tail matches
                    //
//KdpDprintf(" %d hit, check tail\n", MaskIndex);

                    PatternTail = Pattern + 4 - MaskIndex;
                    DataTail = StartAddress + 4;
                    TailLength = PatternLength - 4 + MaskIndex;

//KdpDprintf("Pattern == %08x\n", Pattern);
//KdpDprintf("PatternTail == %08x\n", PatternTail);
//KdpDprintf("DataTail == %08x\n", DataTail);

                    while (TailLength) {
                        if (!NT_SUCCESS(MmDbgCopyMemory(DataTail,
                                                        &DataTailVal,
                                                        1,
                                                        MMDBG_COPY_UNSAFE))) {
//KdpDprintf("Tail %08x: Inaccessible\n", DataTail);
                            break;
                        }

//KdpDprintf("D: %02x  P: %02x\n", DataTailVal, *PatternTail);

                        if (DataTailVal != *PatternTail) {
//KdpDprintf("Tail failed at %08x\n", DataTail);
                            break;
                        } else {
                            DataTail++;
                            PatternTail++;
                            TailLength--;
                        }
                    }

                    if (TailLength == 0) {

                        //
                        // A winner
                        //

                        m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                        m->ReturnStatus = STATUS_SUCCESS;
                        goto done;

                    }
                }
            }
        }

        StartAddress += 4;
        MaskIndex = 0;
    }

done:
//KdpDprintf("\n");
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );

}


VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 Message
    )

/*++

Routine Description:


Arguments:

    Message - Supplies the state manipulation message.

Return Value:

    None.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*Message);
    MessageHeader.Buffer = (PCHAR)Message;

    Message->ReturnStatus = KdpSysCheckLowMemory();

    //
    // Acknowledge the packet received.
    //

    KdSendPacket (
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}



//
// !search support routines
//



ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    )
/*++

Routine Description:

    This routine computes the Hamming distance (# of positions where the
    values are different).

    If this function becomes a bottleneck we should switch to a function
    table version.

Arguments:

    Left, Right operand.

Return Value:

    Hamming distance.

Environment:

    Any.

--*/

{
    ULONG_PTR Value;
    ULONG Index;
    ULONG Distance;

    Value = Left ^ Right;
    Distance = 0;

    for (Index = 0; Index < 8 * sizeof(ULONG_PTR); Index++) {

        if ((Value & (ULONG_PTR)0x01)) {

            Distance += 1;
        }

        Value >>= 1;
    }

    return Distance;
}



LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags
    )
/*++

Routine Description:

    This routine searches the physical page corresponding to a
    certain PFN index for any ULONG_PTR values in range [Start..End].

Arguments:

    PageFrameIndex - PFN index

    RangeStart - lowest possible value searched for

    RangeEnd - highest possible value searched for

    Flags - flags to control the search

Return Value:

    TRUE if a hit has been found, FALSE otherwise.
    The function stops after the first hit in the page is
    encountered and the information related to the hit (PFN index,
    offset, corresponding VA) is registered in the hit database.

Environment:

    Call triggered only from Kd extension.

--*/

{
    LOGICAL Status;
    NTSTATUS CopyStatus;
    ULONG Index;
    PHYSICAL_ADDRESS Pa;

    Pa.QuadPart = ((ULONGLONG)PageFrameIndex) << PAGE_SHIFT;

    Status = FALSE;

    if (KdpSearchPfnValue) {

        HARDWARE_PTE PteValue;

        //
        // We need to search for a PFN
        //

        for (Index = 0; Index < PAGE_SIZE; Index += sizeof(HARDWARE_PTE)) {

            CopyStatus = MmDbgCopyMemory ((ULONG64)(Pa.QuadPart) + Index,
                                          &PteValue,
                                          sizeof PteValue,
                                          MMDBG_COPY_PHYSICAL | MMDBG_COPY_UNSAFE);

            if (NT_SUCCESS(CopyStatus)) {

                if (PteValue.PageFrameNumber == RangeStart) {

                    if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {

                        KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                        KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;
                        KdpSearchPageHitIndex += 1;
                    }

                    if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE) == 0) {
                        Status = TRUE;
                        break;
                    }
                }
            }
        }
    }
    else {

        ULONG_PTR Value;

        //
        // We need to search for an address pattern
        //
        
        for (Index = 0; Index < PAGE_SIZE; Index += sizeof(ULONG_PTR)) {

            CopyStatus = MmDbgCopyMemory ((ULONG64)(Pa.QuadPart) + Index,
                                          &Value,
                                          sizeof Value,
                                          MMDBG_COPY_PHYSICAL | MMDBG_COPY_UNSAFE);

            if (NT_SUCCESS(CopyStatus)) {

                if ((Value >= RangeStart && Value <= RangeEnd) ||
                    (KdpSearchHammingDistance(Value, RangeStart) == 1)) {

                    if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {
                        KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                        KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;

                        KdpSearchPageHitIndex += 1;
                    }

                    if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE) == 0) {
                        Status = TRUE;
                        break;
                    }
                }
            }
        }
    }

    return Status;
}



LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    )
/*++

Routine Description:

    This routine determines if a physical range search has been
    requested. This is controlled by a global variable set in
    the `!search' debug extension.

Arguments:

    None

Return Value:

    TRUE if physical range search was requested.


Environment:

    Call triggered only from Kd extension.

--*/
{
    if (KdpSearchInProgress) {

        return TRUE;
    }
    else {

        return FALSE;
    }

}



LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    )
/*++

Routine Description:

    This routine will start a search in a range of physical pages in case
    `KdpSearchInProgress' is true. the parameters for the search are picked up
    from global vairiables that are set inside a kernel debugger extension.

Arguments:

    None

Return Value:

    TRUE if the function executed a search and FALSE otherwise.
    The results of the search are specified in the KdpSearchPageHits
    and related variables. this global variables offers the mechanism
    for the debugger extension to pickup the results of the search.


Environment:

    Call triggered only from Kd extension.

    Note. The !search extension make sure that the range requested
    is part of the system memory therefore we do not have to
    worry about sparse PFN databases here.

--*/

{
    PFN_NUMBER CurrentFrame;
    ULONG Flags;

    //
    // The debugger extension is supposed to set KdpSearchInProgress
    // to TRUE if a search is requested.
    //

    if (!KdpSearchInProgress) {

        return FALSE;
    }


    Flags = 0;

    //
    // If the search range is only one page we will give all
    // hits inside a page. By default we get only the first hit inside
    // a page.
    //

    if (KdpSearchEndPageFrame == KdpSearchStartPageFrame) {

        KdpSearchEndPageFrame += 1;

        Flags |= KDP_SEARCH_ALL_OFFSETS_IN_PAGE;
    }

    for (CurrentFrame = KdpSearchStartPageFrame;
         CurrentFrame < KdpSearchEndPageFrame;
         CurrentFrame += 1) {

        KdpSearchPhysicalPage (CurrentFrame,
                              KdpSearchAddressRangeStart,
                              KdpSearchAddressRangeEnd,
                              Flags);

    }

    return TRUE;
}

VOID
KdpFillMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    Fill a section of memory with a given pattern.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length = m->u.FillMemory.Length;
    PUCHAR Pattern = AdditionalData->Buffer;
    PUCHAR Pat = Pattern;
    PUCHAR PatEnd = Pat + m->u.FillMemory.PatternLength;
    ULONG Filled = 0;
    ULONG ChunkFlags = MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE;

    if (m->u.FillMemory.Flags & DBGKD_FILL_MEMORY_PHYSICAL) {
        ChunkFlags |= MMDBG_COPY_PHYSICAL;
    } else if (!(m->u.FillMemory.Flags & DBGKD_FILL_MEMORY_VIRTUAL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(Status)) {
        
        ULONG64 Address = m->u.FillMemory.Address;
        
        while (Length-- > 0) {
            ULONG Done;

            if (!NT_SUCCESS(Status =
                            KdpCopyMemoryChunks(Address, Pat, 1, 0,
                                                ChunkFlags, &Done))) {
                break;
            }

            Address++;
            if (++Pat == PatEnd) {
                Pat = Pattern;
            }
            Filled++;
        }

        // If nothing was filled return an error, otherwise
        // consider it a success.
        Status = Filled > 0 ? STATUS_SUCCESS : Status;
        
    }
        
    m->ReturnStatus = Status;
    m->u.FillMemory.Length = Filled;
    
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpQueryMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    Query what kind of memory a particular address refers to.

Arguments:

    m - Supplies the state manipulation message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    STRING MessageHeader;
    NTSTATUS Status = STATUS_SUCCESS;

    if (m->u.QueryMemory.AddressSpace == DBGKD_QUERY_MEMORY_VIRTUAL) {

        PVOID Addr = (PVOID)(ULONG_PTR)m->u.QueryMemory.Address;

        //
        // Right now all we check for is user/session/kernel.
        //
        
        if (Addr < MM_HIGHEST_USER_ADDRESS) {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_PROCESS;
        } else if (MmIsSessionAddress(Addr)) {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_SESSION;
        } else {
            m->u.QueryMemory.AddressSpace = DBGKD_QUERY_MEMORY_KERNEL;
        }

        // Always return the most permissive flags.
        m->u.QueryMemory.Flags =
            DBGKD_QUERY_MEMORY_READ |
            DBGKD_QUERY_MEMORY_WRITE |
            DBGKD_QUERY_MEMORY_EXECUTE;
    
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }
    
    m->ReturnStatus = Status;
    m->u.QueryMemory.Reserved = 0;
    
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL,
        &KdpContext
        );
}

VOID
KdpSysGetVersion(
    PDBGKD_GET_VERSION64 Version
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    Version - Supplies the structure to fill in

Return Value:

    None.

--*/

{
    *Version = KdVersionBlock;
}

NTSTATUS
KdpSysReadBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads I/O configuration space.

Arguments:

    BusDataType - Bus data type.

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Address - Configuration space address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    *Actual = HalGetBusDataByOffset(BusDataType, BusNumber, SlotNumber,
                                    Buffer, Address, Request);
    return *Actual == Request ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}

NTSTATUS
KdpSysWriteBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes I/O configuration space.

Arguments:

    BusDataType - Bus data type.

    BusNumber - Bus number.

    SlotNumber - Slot number.

    Address - Configuration space address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    *Actual = HalSetBusDataByOffset(BusDataType, BusNumber, SlotNumber,
                                    Buffer, Address, Request);
    return *Actual == Request ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}









NTSTATUS
KdpSysCheckLowMemory(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    NTSTATUS.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
    PFN_NUMBER Page;
    PFN_NUMBER NextPage;
    PHYSICAL_ADDRESS P;
    PVOID64 VirtualAddress;
    ULONG CorruptionOffset;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    if (KdpSearchPhysicalMemoryRequested()) {

        //
        // This is a !search kd extension call.
        //

        KdpSearchPhysicalPageRange();
    }
    else {

        //
        // Check low physical memory on machines with more than 4GB.
        //

        Page = 0;

        do {

            if (! MmDbgIsLowMemOk (Page, &NextPage, &CorruptionOffset)) {
                Status = (NTSTATUS) Page;
                break;
            }

            Page = NextPage;

        } while (Page != 0);
    }

    return Status;
}

//----------------------------------------------------------------------------
//
// Tracing data support.
//
//----------------------------------------------------------------------------

VOID
KdpSendTraceData(
    PSTRING Data
    )
{
    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_TRACE_IO TraceIo;
    
    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Data->Buffer,
                   Data->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(TraceIo) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(TraceIo);
    }

    //
    // Construct the print string message and message descriptor.
    //

    TraceIo.ApiNumber = DbgKdPrintTraceApi;
    TraceIo.ProcessorLevel = KeProcessorLevel;
    TraceIo.Processor = (USHORT)KeGetCurrentPrcb()->Number;
    TraceIo.u.PrintTrace.LengthOfData = Length;
    MessageHeader.Length = sizeof(TraceIo);
    MessageHeader.Buffer = (PCHAR)&TraceIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_TRACE_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );
}

VOID
KdReportTraceData(
    IN struct _WMI_BUFFER_HEADER* Buffer,
    IN PVOID Context
    )
{
    BOOLEAN Enable;
    STRING Data;

    Data.Buffer = (PCHAR)Buffer;
    if (Buffer->Wnode.BufferSize > 0xffff) {
        Data.Length = 0xffff;
    } else {
        Data.Length = (USHORT)Buffer->Wnode.BufferSize;
    }
    
    if (KdDebuggerNotPresent == FALSE) {
        Enable = KdEnterDebugger(NULL, NULL);

        KdpSendTraceData(&Data);

        KdExitDebugger(Enable);
    }
}

//----------------------------------------------------------------------------
//
// Debugger hibernate/suspend support.
//
//----------------------------------------------------------------------------

NTSTATUS
KdPowerTransition(
    DEVICE_POWER_STATE newDeviceState
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    switch(newDeviceState) {
    
    case PowerDeviceD0:
        KdD0Transition();
        break;
        
    case PowerDeviceD3:
        KdD3Transition();
        break;

    default:
        status = STATUS_INVALID_PARAMETER_1;
    }

    return status;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\file.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains kd host machine file I/O support.

Author:

    Drew Bliss (drewb) 21-Feb-2001

Revision History:

--*/

#include "kdp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdCreateRemoteFile)
#pragma alloc_text(PAGEKD, KdReadRemoteFile)
#pragma alloc_text(PAGEKD, KdWriteRemoteFile)
#pragma alloc_text(PAGEKD, KdCloseRemoteFile)
#pragma alloc_text(PAGEKD, KdPullRemoteFile)
#pragma alloc_text(PAGEKD, KdPushRemoteFile)
#endif

NTSTATUS
KdCreateRemoteFile(
    OUT PHANDLE Handle,
    OUT PULONG64 Length, OPTIONAL
    IN PUNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;

    if (FileName->Length > PACKET_MAX_SIZE - sizeof(Irp)) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (KdDebuggerNotPresent != FALSE) {
        return STATUS_DEBUGGER_INACTIVE;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    //
    // Look for an open slot.
    //

    for (Index = 0; Index < KD_MAX_REMOTE_FILES; Index++) {
        if (KdpRemoteFiles[Index].RemoteHandle == 0) {
            break;
        }
    }

    if (Index >= KD_MAX_REMOTE_FILES) {
        Irp.Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCreateFileApi;
    Irp.u.CreateFile.DesiredAccess = DesiredAccess;
    Irp.u.CreateFile.FileAttributes = FileAttributes;
    Irp.u.CreateFile.ShareAccess = ShareAccess;
    Irp.u.CreateFile.CreateDisposition = CreateDisposition;
    Irp.u.CreateFile.CreateOptions = CreateOptions;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG Length;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;

        // Copy the filename to the message buffer
        // so that a terminator can be added.
        KdpCopyFromPtr(KdpMessageBuffer, FileName->Buffer,
                       FileName->Length, &Length);
        MessageData.Length = (USHORT)Length + sizeof(WCHAR);
        MessageData.Buffer = KdpMessageBuffer;
        *(PWCHAR)&MessageData.Buffer[MessageData.Length - sizeof(WCHAR)] =
            UNICODE_NULL;
        
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     &MessageData,
                     &KdpContext);

        if (KdDebuggerNotPresent != FALSE) {
            Irp.Status = STATUS_DEBUGGER_INACTIVE;
            break;
        }
    
        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &Length,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        
        KdpRemoteFiles[Index].RemoteHandle = Irp.u.CreateFile.Handle;
        // Add one so that zero is reserved for invalid-handle.
        *Handle = UlongToHandle(Index + 1);
        if (ARGUMENT_PRESENT(Length)) {
            *Length = Irp.u.CreateFile.Length;
        }
    }
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdReadRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdReadFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.ReadFile.Handle = KdpRemoteFiles[Index].RemoteHandle;
    Irp.u.ReadFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.ReadFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.ReadFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = (USHORT)Irp.u.ReadFile.Length;
        MessageData.Buffer = Buffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += RecvLength;
            Buffer = (PVOID)((PUCHAR)Buffer + RecvLength);
            Irp.u.ReadFile.Offset += RecvLength;
            Length -= RecvLength;
        }
    }
    
    *Completed = _Completed;
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdWriteRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdWriteFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.WriteFile.Handle = KdpRemoteFiles[Index].RemoteHandle;
    Irp.u.WriteFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.WriteFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.WriteFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        MessageData.Length = (USHORT)Irp.u.WriteFile.Length;
        MessageData.Buffer = Buffer;

        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     &MessageData,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += Irp.u.WriteFile.Length;
            Buffer = (PVOID)((PUCHAR)Buffer + Irp.u.WriteFile.Length);
            Irp.u.WriteFile.Offset += Irp.u.WriteFile.Length;
            Length -= Irp.u.WriteFile.Length;
        }
    }
    
    *Completed = _Completed;
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

NTSTATUS
KdCloseRemoteFile(
    IN HANDLE Handle
    )
{
    BOOLEAN Enable;
    DBGKD_FILE_IO Irp;
    ULONG Index;

    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    Enable = KdEnterDebugger(NULL, NULL);

    if (KdpRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCloseFileApi;
    Irp.u.CloseFile.Handle = KdpRemoteFiles[Index].RemoteHandle;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        KdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL,
                     &KdpContext);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = KdpMessageBuffer;

        do {
            ReturnCode = KdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength,
                                         &KdpContext);
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        if (ReturnCode == KDP_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        KdpRemoteFiles[Index].RemoteHandle = 0;
    }
    
 Exit:
    KdExitDebugger(Enable);
    return Irp.Status;
}

#define TRANSFER_LENGTH 8192

NTSTATUS
KdPullRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    NTSTATUS Status;
    PVOID Buffer = NULL;
    ULONG64 Length;
    HANDLE RemoteHandle = NULL;
    HANDLE LocalHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER LargeInt;
    ULONG64 Offset;

    // Allocate a buffer for data transfers.
    Buffer = ExAllocatePoolWithTag(NonPagedPool, TRANSFER_LENGTH, 'oIdK');
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    // Open the remote file for reading.
    Status = KdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ, FILE_OPEN, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Open the local file for writing.
    LargeInt.QuadPart = Length;
    InitializeObjectAttributes(&ObjectAttributes, FileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, NULL);
    Status = ZwCreateFile(&LocalHandle, FILE_GENERIC_WRITE,
                          &ObjectAttributes, &IoStatus, &LargeInt,
                          FileAttributes, 0, CreateDisposition,
                          CreateOptions, NULL, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Copy the file contents.
    Offset = 0;
    while (Length > 0) {
        ULONG ReqLength, ReqCompleted;

        if (Length > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)Length;
        }
        
        Status = KdReadRemoteFile(RemoteHandle, Offset, Buffer,
                                  ReqLength, &ReqCompleted);
        if (!NT_SUCCESS(Status) || ReqCompleted == 0) {
            break;
        }

        LargeInt.QuadPart = Offset;
        Status = ZwWriteFile(LocalHandle, NULL, NULL, NULL,
                             &IoStatus, Buffer, ReqCompleted,
                             &LargeInt, NULL);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        if (IoStatus.Information < ReqCompleted) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Offset += IoStatus.Information;
        Length -= IoStatus.Information;
    }
    
 Exit:
    if (RemoteHandle != NULL) {
        KdCloseRemoteFile(RemoteHandle);
    }
    if (LocalHandle != NULL) {
        ZwClose(LocalHandle);
    }
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}

NTSTATUS
KdPushRemoteFile(
    IN PUNICODE_STRING FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    NTSTATUS Status;
    PVOID Buffer = NULL;
    ULONG64 Length;
    HANDLE RemoteHandle = NULL;
    HANDLE LocalHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER LargeInt;
    ULONG64 Offset;
    FILE_END_OF_FILE_INFORMATION EndOfFile;

    // Allocate a buffer for data transfers.
    Buffer = ExAllocatePoolWithTag(NonPagedPool, TRANSFER_LENGTH, 'oIdK');
    if (Buffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    // Open the remote file for writing.
    Status = KdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_WRITE, FileAttributes,
                                0, CreateDisposition, CreateOptions);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Open the local file for reading.
    InitializeObjectAttributes(&ObjectAttributes, FileName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, NULL);
    Status = ZwOpenFile(&LocalHandle, FILE_GENERIC_READ,
                        &ObjectAttributes, &IoStatus, FILE_SHARE_READ, 0);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = NtQueryInformationFile(LocalHandle, &IoStatus,
                                    &EndOfFile, sizeof(EndOfFile),
                                    FileEndOfFileInformation);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    // Copy the file contents.
    Offset = 0;
    Length = EndOfFile.EndOfFile.QuadPart;
    while (Length > 0) {
        ULONG ReqLength, ReqCompleted;

        if (Length > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)Length;
        }
        
        LargeInt.QuadPart = Offset;
        Status = ZwReadFile(LocalHandle, NULL, NULL, NULL,
                            &IoStatus, Buffer, ReqLength,
                            &LargeInt, NULL);
        if (!NT_SUCCESS(Status) || IoStatus.Information == 0) {
            break;
        }

        Status = KdWriteRemoteFile(RemoteHandle, Offset, Buffer,
                                   (ULONG)IoStatus.Information, &ReqCompleted);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        if (ReqCompleted < IoStatus.Information) {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Offset += ReqCompleted;
        Length -= ReqCompleted;
    }
    
 Exit:
    if (RemoteHandle != NULL) {
        KdCloseRemoteFile(RemoteHandle);
    }
    if (LocalHandle != NULL) {
        ZwClose(LocalHandle);
    }
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdbreak.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdbreak.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "kdp.h"

//
// Define external references.
//

VOID
KdSetOwedBreakpoints(
    VOID
    );

BOOLEAN
KdpLowWriteContent(
    ULONG Index
    );

BOOLEAN
KdpLowRestoreBreakpoint(
    ULONG Index
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpAddBreakpoint)
#pragma alloc_text(PAGEKD, KdpDeleteBreakpoint)
#pragma alloc_text(PAGEKD, KdpDeleteBreakpointRange)
#pragma alloc_text(PAGEKD, KdpSuspendBreakpoint)
#pragma alloc_text(PAGEKD, KdpSuspendAllBreakpoints)
#pragma alloc_text(PAGEKD, KdpRestoreAllBreakpoints)
#pragma alloc_text(PAGEKD, KdpLowWriteContent)
#pragma alloc_text(PAGEKD, KdpLowRestoreBreakpoint)
#if defined(_IA64_)
#pragma alloc_text(PAGEKD, KdpSuspendBreakpointRange)
#pragma alloc_text(PAGEKD, KdpRestoreBreakpointRange)
#endif
#endif


ULONG
KdpAddBreakpoint (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    ULONG Index;
    BOOLEAN Accessible;

    //DPRINT(("KD: Setting breakpoint at 0x%08x\n", Address));

    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & KDP_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }


    //
    // Don't allow setting the same breakpoint twice.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) != 0 &&
            KdpBreakpointTable[Index].Address == Address) {

            if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) != 0) {

                //
                // Breakpoint was set, the page was written out and was not
                // accessible when the breakpoint was cleared.  Now the breakpoint
                // is being set again.  Just clear the defer flag:
                //
                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
                return Index + 1;

            } else {

                DPRINT(("KD: Attempt to set breakpoint %08x twice!\n", Address));
                return 0;

            }
        }
    }

    //
    // Search the breakpoint table for a free entry.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }


    //DPRINT(("KD: using Index %d\n", Index));

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark breakpoint as not accessible.
    //

    Accessible = NT_SUCCESS(KdpCopyFromPtr(&Content,
                                           Address,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL));
    //DPRINT(("KD: memory %saccessible\n", Accessible ? "" : "in"));

#if defined(_IA64_)
    if ( Accessible ) {
        KDP_BREAKPOINT_TYPE mBuf;
        PVOID BundleAddress;

        // change template to type 0 if current instruction is MLI

        // read in intruction template if current instruction is NOT slot 0.
        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.

        if (((ULONG_PTR)Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)Address & ~(0xf);
            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                           BundleAddress,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL))) {
                //DPRINT(("KD: read 0x%08x template failed\n", BundleAddress));
                return 0;
            } else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                     &mBuf,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            return 0;
                         }
                         else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                         }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         return 0;
                    }
                }
            }
        }

        // insert break instruction

        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
            }
            switch ((ULONG_PTR)Address & 0xf) {
            case 0:
                Content = (Content & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
                break;

            case 4:
                Content = (Content & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
                break;

            case 8:
                Content = (Content & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
                break;

            default:
                //DPRINT(("KD: KdpAddBreakpoint bad instruction slot#\n"));
                return 0;
            }
            if (!NT_SUCCESS(KdpCopyToPtr(Address,
                                         &Content,
                                         sizeof(KDP_BREAKPOINT_TYPE),
                                         NULL))) {

                //DPRINT(("KD: Unable to write BP!\n"));
                return 0;
            }
            else {
                //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
            }

    } else {  // memory not accessible
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        //DPRINT(("KD: breakpoint write deferred\n"));
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
    }
#else
    if ( Accessible ) {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
        if (!NT_SUCCESS(KdpCopyToPtr(Address,
                                     &KdpBreakpointInstruction,
                                     sizeof(KDP_BREAKPOINT_TYPE),
                                     NULL))) {

            DPRINT(("KD: Unable to write BP!\n"));
        }
    } else {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE | KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        //DPRINT(("KD: breakpoint write deferred\n"));
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            KdpBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
        }
    }
#endif  // IA64

    return Index + 1;

}



VOID
KdSetOwedBreakpoints(
    VOID
    )

/*++

Routine Description:

    This function is called after returning from memory management calls
    that may cause an inpage.  Its purpose is to store pending
    breakpoints in pages just made valid.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    BOOLEAN Enable;
    LONG Index;

    //
    // If we don't owe any breakpoints then return
    //

    if ( !KdpOweBreakpoint ) {
        return;
    }


    //
    // Freeze all other processors, disable interrupts, and save debug
    // port state.
    //

    Enable = KdEnterDebugger(NULL, NULL);
    KdpOweBreakpoint = FALSE;

    //
    // Search the breakpoint table for breakpoints that need to be
    // written or replaced.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags &
                (KD_BREAKPOINT_NEEDS_WRITE | KD_BREAKPOINT_NEEDS_REPLACE) ) {

            //
            // Breakpoint needs to be written
            //
            //DPRINT(("KD: Breakpoint %d at 0x%08x: trying to %s after page in.\n",
            //    Index,
            //    KdpBreakpointTable[Index].Address,
            //    (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) ?
            //        "set" : "clear"));

            if ((KdpBreakpointTable[Index].Address >= (PVOID)GLOBAL_BREAKPOINT_LIMIT) ||
                (KdpBreakpointTable[Index].DirectoryTableBase ==
                 KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0])) {

                //
                // Breakpoint is global, or its directory base matches
                //

                if (!NT_SUCCESS(KdpCopyFromPtr(&Content,
                                               KdpBreakpointTable[Index].Address,
                                               sizeof(KDP_BREAKPOINT_TYPE),
                                               NULL))) {

                    //DPRINT(("KD: read from 0x%08x failed\n", KdpBreakpointTable[Index].Address));

                    KdpOweBreakpoint = TRUE;

                } else {
                    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {
                        KdpBreakpointTable[Index].Content = Content;
#if defined(_IA64_)
                        switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
                        case 0:
                            Content = (Content & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
                            break;

                        case 4:
                            Content = (Content & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
                            break;

                        case 8:
                            Content = (Content & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
                            break;

                        default:
                            //DPRINT(("KD: illegal instruction address 0x%08x\n", KdpBreakpointTable[Index].Address));
                            break;
                        }
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &Content,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            //DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                        }

                        // read in intruction template if current instruction is NOT slot 0.
                        // check for two-slot MOVL instruction. Reject request if attempt to
                        // set break in slot 2 of MLI template.

                        else if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) != 0) {
                            KDP_BREAKPOINT_TYPE mBuf;
                            PVOID BundleAddress;

                            (ULONG_PTR)BundleAddress = (ULONG_PTR)KdpBreakpointTable[Index].Address  & ~(0xf);
                            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                           BundleAddress,
                                                           sizeof(KDP_BREAKPOINT_TYPE),
                                                           NULL))) {
                                KdpOweBreakpoint = TRUE;
                                //DPRINT(("KD: read 0x%08x template failed\n", KdpBreakpointTable[Index].Address));
                            } else {
                                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                                    if (((ULONG_PTR)KdpBreakpointTable[Index].Address  & 0xf) == 4) {
                                        // if template= type 2 MLI, change to type 0
                                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                                     &mBuf,
                                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                                     NULL))) {
                                            KdpOweBreakpoint = TRUE;
                                            //DPRINT(("KD: write to 0x%08x template failed\n", KdpBreakpointTable[Index].Address));
                                        }
                                        else {
                                            KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
                                            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
                                            //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                                        }
                                    } else {
                                        // set breakpoint at slot 2 of MOVL is illegal
                                        KdpOweBreakpoint = TRUE;
                                        //DPRINT(("KD: illegal attempt to set BP at slot 2 of 0x%08x\n", KdpBreakpointTable[Index].Address));
                                    }
                                }
                                else {
                                    KdpBreakpointTable[Index].Flags &= ~(KD_BREAKPOINT_STATE_MASK);
                                    KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IN_USE;
                                    //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                                }
                            }
                        }
#else
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &KdpBreakpointInstruction,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                        } else {
                            KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
                            DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                        }
#endif
                    } else {
#if defined(_IA64_)

                        KDP_BREAKPOINT_TYPE mBuf;
                        PVOID BundleAddress;

                        // restore original instruction content

                        // Read in memory since adjancent instructions in the same bundle may have
                        // been modified after we save them.
                        if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                       KdpBreakpointTable[Index].Address,
                                                       sizeof(KDP_BREAKPOINT_TYPE),
                                                       NULL))) {
                            KdpOweBreakpoint = TRUE;
                            //DPRINT(("KD: read 0x%08x template failed\n", KdpBreakpointTable[Index].Address));
                        }
                        else {
                            switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
                            case 0:
                                mBuf = (mBuf & ~(INST_SLOT0_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT0_MASK);
                                break;

                            case 4:
                                mBuf = (mBuf & ~(INST_SLOT1_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT1_MASK);
                                break;

                            case 8:
                                mBuf = (mBuf & ~(INST_SLOT2_MASK))
                                             | (KdpBreakpointTable[Index].Content & INST_SLOT2_MASK);
                                break;

                            default:
                                KdpOweBreakpoint = TRUE;
                                //DPRINT(("KD: illegal instruction address 0x%08x\n", KdpBreakpointTable[Index].Address));
                            }

                            if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                         &mBuf,
                                                         sizeof(KDP_BREAKPOINT_TYPE),
                                                         NULL))) {
                                KdpOweBreakpoint = TRUE;
                                //DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                            }
                            else {
                                 // restore template to MLI if displaced instruction was MOVL

                                if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IA64_MOVL) {
                                    (ULONG_PTR)BundleAddress = (ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf);
                                    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                                                   BundleAddress,
                                                                   sizeof(KDP_BREAKPOINT_TYPE),
                                                                   NULL))) {
                                        KdpOweBreakpoint = TRUE;
                                        //DPRINT(("KD: read template 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                                    }
                                    else {
                                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                                        mBuf |= 0x4;

                                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                                     &mBuf,
                                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                                     NULL))) {
                                            KdpOweBreakpoint = TRUE;
                                            //DPRINT(("KD: write template to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                                        } else {
                                            //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                                            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                                KdpBreakpointTable[Index].Flags |= (KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE);
                                            } else {
                                                KdpBreakpointTable[Index].Flags = 0;
                                            }
                                        }
                                    }
                                } else {
                                    //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                                    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                        KdpBreakpointTable[Index].Flags |= (KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE);
                                    } else {
                                        KdpBreakpointTable[Index].Flags = 0;
                                    }
                                }
                            }
                        }
#else
                        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                                     &KdpBreakpointTable[Index].Content,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            KdpOweBreakpoint = TRUE;
                            DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                        } else {
                            //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                                KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE;
                            } else {
                                KdpBreakpointTable[Index].Flags = 0;
                            }
                        }
#endif // _IA64_

                    }
                }

            } else {

                //
                // Breakpoint is local and its directory base does not match
                //

                KdpOweBreakpoint = TRUE;
            }
        }
    }

    KdExitDebugger(Enable);
    return;
}


BOOLEAN
KdpLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, KdpAddBreakpoint,
    KdpLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use KdpOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
#if defined(_IA64_)
    KDP_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Do the contents need to be replaced at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: Breakpoint at 0x%08x never written; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));
        return TRUE;
    }

#if !defined(_IA64_)
    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        //DPRINT(("KD: Breakpoint at 0x%08x; instr is really BP; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));

        return TRUE;
    }
#endif


    //
    // Restore the instruction contents.
    //

#if defined(_IA64_)
    // Read in memory since adjancent instructions in the same bundle may have
    // been modified after we save them.
    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                   KdpBreakpointTable[Index].Address,
                                   sizeof(KDP_BREAKPOINT_TYPE),
                                   NULL))) {
        KdpOweBreakpoint = TRUE;
        //DPRINT(("KD: read 0x%08x failed\n", KdpBreakpointTable[Index].Address));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        return FALSE;
    }
    else {

        switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT0_MASK);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT1_MASK);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK))
                         | (KdpBreakpointTable[Index].Content & INST_SLOT2_MASK);
            break;

        default:
            KdpOweBreakpoint = TRUE;
            //DPRINT(("KD: illegal instruction address 0x%08x\n", KdpBreakpointTable[Index].Address));
            return FALSE;
        }

        if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                     &mBuf,
                                     sizeof(KDP_BREAKPOINT_TYPE),
                                     NULL))) {
            KdpOweBreakpoint = TRUE;
            //DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
            return FALSE;
        }
        else {

            if (NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                          KdpBreakpointTable[Index].Address,
                                          sizeof(KDP_BREAKPOINT_TYPE),
                                          NULL))) {
                //DPRINT(("\tcontent after memory move = 0x%08x 0x%08x\n", (ULONG)(mBuf >> 32), (ULONG)mBuf));
            }

            // restore template to MLI if displaced instruction was MOVL

            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IA64_MOVL) {
                (ULONG_PTR)BundleAddress = (ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf);
                if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                               BundleAddress,
                                               sizeof(KDP_BREAKPOINT_TYPE),
                                               NULL))) {
                    KdpOweBreakpoint = TRUE;
                    //DPRINT(("KD: read template 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                    KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
                    return FALSE;
                }
                else {
                    mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                    mBuf |= 0x4;

                    if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                 &mBuf,
                                                 sizeof(KDP_BREAKPOINT_TYPE),
                                                 NULL))) {
                        KdpOweBreakpoint = TRUE;
                        //DPRINT(("KD: write template to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
                        return FALSE;
                    } else {
                        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                         //   KdpBreakpointTable[Index].Address));
                        return TRUE;
                    }
                }
            }
            else {   // not MOVL
                //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                 //  KdpBreakpointTable[Index].Address));
                return TRUE;
            }
        }
    }
#else
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &KdpBreakpointTable[Index].Content,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        KdpOweBreakpoint = TRUE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        //DPRINT(("KD: Breakpoint at 0x%08x; unable to clear, flag set.\n",
            //KdpBreakpointTable[Index].Address));
        return FALSE;
    } else {
        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
            //KdpBreakpointTable[Index].Address));
        return TRUE;
    }
#endif

}



BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (KdpBreakpointTable[Index].Flags == 0) {
        //DPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
        //DPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) ) {
            //DPRINT(("KD: already clear.\n"));
            KdpBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (KdpLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        //DPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        KdpBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}


BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++)
    {
        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper)) )
        {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            if (KdpDeleteBreakpoint(Index+1))
            {
                ReturnStatus = TRUE;
            }
        }
    }

    return ReturnStatus;

}

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
        !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_SUSPENDED;
        KdpLowWriteContent(Index);
    }

    return;

} // KdpSuspendBreakpoint

VOID
KdpSuspendAllBreakpoints (
    VOID
    )
{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpSuspendBreakpoint(Handle);
    }

    return;

} // KdpSuspendAllBreakpoints

#if defined(_IA64_)


BOOLEAN
KdpSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine suspend all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to suspend BPs.

    Upper - include upper address of range from which to suspend BPs.

Return Value:

    TRUE if any breakpoints suspended, FALSE otherwise.

Notes:
    The order of suspending breakpoints is opposite that of setting
    them in KdpAddBreakpoint() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering KdpSuspendBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = BREAKPOINT_TABLE_SIZE - 1; Index != -1; Index--) {

        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, suspend it.
            //

            KdpSuspendBreakpoint(Index+1);
            ReturnStatus = TRUE;
        }
    }
    //DPRINT(("KD: exiting KdpSuspendBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // KdpSuspendBreakpointRange



BOOLEAN
KdpRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine writes back breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to rewrite BPs.

    Upper - include upper address of range from which to rewrite BPs.

Return Value:

    TRUE if any breakpoints written, FALSE otherwise.

Notes:
    The order of writing breakpoints is opposite that of removing
    them in KdpSuspendBreakpointRange() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering KdpRestoreBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // suspended breakpoint that falls in range, unsuspend it.
            //

            if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {

                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
                ReturnStatus = ReturnStatus || KdpLowRestoreBreakpoint(Index);
            }
        }
    }

    //DPRINT(("KD: exiting KdpRestoreBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // KdpRestoreBreakpointRange

#endif // _IA64_


BOOLEAN
KdpLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
    KDP_BREAKPOINT_TYPE Content;

#if defined(_IA64_)
    KDP_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif
    //
    // Does the breakpoint need to be written at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;
    }

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

#if !defined(_IA64_)
    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }
#endif

    //
    // Replace the instruction contents.
    //

#if defined(_IA64_)

    // read in intruction in case the adjacent instruction has been modified.

    if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                   KdpBreakpointTable[Index].Address,
                                   sizeof(KDP_BREAKPOINT_TYPE),
                                   NULL))) {
        //DPRINT(("KD: read 0x%p template failed\n", KdpBreakpointTable[Index].Address));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;
    }

    switch ((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK)) | (KdpBreakpointInstruction << 5);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK)) | (KdpBreakpointInstruction << 14);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK)) | (KdpBreakpointInstruction << 23);
            break;

        default:
            //DPRINT(("KD: KdpAddBreakpoint bad instruction slot#\n"));
            return FALSE;
    }
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &mBuf,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        //DPRINT(("KD: Unable to write BP!\n"));
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;
    }
    else {

        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.
        // change template to type 0 if current instruction is MLI

        if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)KdpBreakpointTable[Index].Address & ~(0xf);
            if (!NT_SUCCESS(KdpCopyFromPtr(&mBuf,
                                           BundleAddress,
                                           sizeof(KDP_BREAKPOINT_TYPE),
                                           NULL))) {
                //DPRINT(("KD: read template failed at 0x%08x\n", BundleAddress));
                KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                KdpOweBreakpoint = TRUE;
                return FALSE;
            }
            else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)KdpBreakpointTable[Index].Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_IA64_MOVL;
                        if (!NT_SUCCESS(KdpCopyToPtr(BundleAddress,
                                                     &mBuf,
                                                     sizeof(KDP_BREAKPOINT_TYPE),
                                                     NULL))) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                            KdpOweBreakpoint = TRUE;
                            return FALSE;
                        }
                        else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                        }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
                         KdpOweBreakpoint = TRUE;
                         return FALSE;
                    }
                }
            }
        }
        //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
        return TRUE;
    }

#else
    if (!NT_SUCCESS(KdpCopyToPtr(KdpBreakpointTable[Index].Address,
                                 &KdpBreakpointInstruction,
                                 sizeof(KDP_BREAKPOINT_TYPE),
                                 NULL))) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;

    } else {

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        return TRUE;
    }
#endif

}


VOID
KdpRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
            (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

            KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
            KdpLowRestoreBreakpoint(Index);
        }
    }

    return;

} // KdpRestoreAllBreakpoints

VOID
KdDeleteAllBreakpoints(
    VOID
    )
{
    ULONG Handle;

    if (KdDebuggerEnabled == FALSE || KdPitchDebugger != FALSE) {
        return;
    }

    BreakpointsSuspended = FALSE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpDeleteBreakpoint(Handle);
    }

    return;
} // KdDeleteAllBreakpoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdinit.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdinit.c

Abstract:

    This module implements the initialization for the portable kernel debgger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"



BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdInitSystem)
#pragma alloc_text(PAGEKD, KdUpdateDataBlock)
#pragma alloc_text(PAGEKD, KdRegisterDebuggerDataBlock)
#endif

BOOLEAN KdBreakAfterSymbolLoad;

VOID
KdUpdateDataBlock(
    VOID
    )
/*++

Routine Description:

    We have to update this variable seperately since it is initialized at a
    later time by PS.  PS will call us to update the data block.

--*/
{
    KdDebuggerDataBlock.KeUserCallbackDispatcher = (ULONG_PTR) KeUserCallbackDispatcher;
}


ULONG_PTR
KdGetDataBlock(
    VOID
    )
/*++

Routine Description:

    Called by crashdump to get the address of this data block
    This routine can not be paged.

--*/
{
    return (ULONG_PTR)(&KdDebuggerDataBlock);
}



BOOLEAN
KdInitSystem(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock OPTIONAL
    )

/*++

Routine Description:

    This routine initializes the portable kernel debugger.

Arguments:

    Phase - Initialization phase

    LoaderBlock - Supplies a pointer to the LOADER_PARAMETER_BLOCK passed
        in from the OS Loader.

Return Value:

    None.

--*/

{
    PCHAR BaudOption;
    ULONG Index;
    BOOLEAN Initialize;
    PLIST_ENTRY NextEntry;
    PCHAR Options;
    PCHAR PortOption;

    if (Phase == 0) {

        //
        // If kernel debugger is already initialized, then return.
        //

        if (KdDebuggerEnabled != FALSE) {
            return TRUE;
        }

        KiDebugRoutine = KdpStub;
        KdBreakAfterSymbolLoad = FALSE;

        //
        // Determine whether or not the debugger should be enabled.
        //
        // Note that if LoaderBlock == NULL, then KdInitSystem was called
        // from BugCheck code. For this case the debugger is always enabled
        // to report the bugcheck if possible.
        //

        if (!KdpDebuggerDataListHead.Flink)
        {
            InitializeListHead(&KdpDebuggerDataListHead);

            KdRegisterDebuggerDataBlock(KDBG_TAG,
                                        &KdDebuggerDataBlock.Header,
                                        sizeof(KdDebuggerDataBlock));

            KdVersionBlock.MinorVersion = (short)NtBuildNumber;
            KdVersionBlock.MajorVersion = (short)((NtBuildNumber >> 28) & 0xFFFFFFF);

            KdVersionBlock.MaxStateChange =
                (UCHAR)(DbgKdMaximumStateChange - DbgKdMinimumStateChange);
            KdVersionBlock.MaxManipulate =
                (UCHAR)(DbgKdMaximumManipulate - DbgKdMinimumManipulate);

            KdVersionBlock.PsLoadedModuleList =
                (ULONG64)(LONG64)(LONG_PTR)&PsLoadedModuleList;
            KdVersionBlock.DebuggerDataList =
                (ULONG64)(LONG64)(LONG_PTR)&KdpDebuggerDataListHead;

#if !defined(NT_UP)
            KdVersionBlock.Flags |= DBGKD_VERS_FLAG_MP;
#endif

#if defined(_AMD64_) || defined(_X86_)

            //
            // Enable this for all platforms when VersionBlock is added
            // to all the KPCR definitions.
            //

            KeGetPcr()->KdVersionBlock = &KdVersionBlock;
#endif
        }

        if (LoaderBlock != NULL) {

            // If the debugger is being initialized during boot, PsNtosImageBase
            // and PsLoadedModuleList are not yet valid.  KdInitSystem got
            // the image base from the loader block.
            // On the other hand, if the debugger was initialized by a bugcheck,
            // it didn't get a loader block to look at, but the system was
            // running so the other variables are valid.
            //

            KdVersionBlock.KernBase = (ULONG64)(LONG64)(LONG_PTR)
                                      CONTAINING_RECORD(
                                          (LoaderBlock->LoadOrderListHead.Flink),
                                          KLDR_DATA_TABLE_ENTRY,
                                          InLoadOrderLinks)->DllBase;

            //
            // Fill in and register the debugger's debugger data blocks.
            // Most fields are already initialized, some fields will not be
            // filled in until later.
            //

            if (LoaderBlock->LoadOptions != NULL) {
                Options = LoaderBlock->LoadOptions;
                _strupr(Options);

                //
                // If any of the port option, baud option, or debug is
                // specified, then enable the debugger unless it is explictly
                // disabled.
                //

                Initialize = TRUE;
                if (strstr(Options, "DEBUG") == NULL) {
                    Initialize = FALSE;
                }

                //
                // If the debugger is explicitly disabled, then set to NODEBUG.
                //

                if (strstr(Options, "NODEBUG")) {
                    Initialize = FALSE;
                    KdPitchDebugger = TRUE;
                }

                if (strstr(Options, "CRASHDEBUG")) {
                    Initialize = FALSE;
                    KdPitchDebugger = FALSE;
                }

            } else {

                //
                // If the load options are not specified, then set to NODEBUG.
                //

                KdPitchDebugger = TRUE;
                Initialize = FALSE;
            }

        } else {
            KdVersionBlock.KernBase = (ULONG64)(LONG64)(LONG_PTR)PsNtosImageBase;
            Initialize = TRUE;
        }

        KdDebuggerDataBlock.KernBase = (ULONG_PTR) KdVersionBlock.KernBase;

        if (Initialize == FALSE) {
            return(TRUE);
        }

        if (!NT_SUCCESS(KdDebuggerInitialize0(LoaderBlock))) {
            return TRUE;
        }

        //
        // Set address of kernel debugger trap routine.
        //

        KiDebugRoutine = KdpTrap;

        if (!KdpDebuggerStructuresInitialized) {

            KdpContext.KdpControlCPending = FALSE;

            // Retries are set to this after boot
            KdpContext.KdpDefaultRetries = MAXIMUM_RETRIES;

            KiDebugSwitchRoutine = KdpSwitchProcessor;

            //
            // Initialize TimeSlip
            //
            KeInitializeDpc(&KdpTimeSlipDpc, KdpTimeSlipDpcRoutine, NULL);
            KeInitializeTimer(&KdpTimeSlipTimer);
            ExInitializeWorkItem(&KdpTimeSlipWorkItem, KdpTimeSlipWork, NULL);

            KdpDebuggerStructuresInitialized = TRUE ;
        }

        KdTimerStart.HighPart = 0L;
        KdTimerStart.LowPart = 0L;

        //
        // Mark debugger enabled.
        //

        KdPitchDebugger = FALSE;
        KdDebuggerEnabled = TRUE;
        SharedUserData->KdDebuggerEnabled = 0x00000001;

        //
        // If the loader block address is specified, then scan the loaded
        // module list and load the image symbols via the kernel debugger
        // for the system and the HAL. If the host debugger has been started
        // with the -d option a break into the kernel debugger will occur at
        // this point.
        //

        if (LoaderBlock != NULL) {
            Index = 0;
            NextEntry = LoaderBlock->LoadOrderListHead.Flink;
            while ((NextEntry != &LoaderBlock->LoadOrderListHead) &&
                   (Index < 2)) {

                CHAR Buffer[256];
                ULONG Count;
                PKLDR_DATA_TABLE_ENTRY DataTableEntry;
                WCHAR *Filename;
                ULONG Length;
                STRING NameString;

                //
                // Get the address of the data table entry for the next component.
                //

                DataTableEntry = CONTAINING_RECORD(NextEntry,
                                                   KLDR_DATA_TABLE_ENTRY,
                                                   InLoadOrderLinks);

                //
                // Load the symbols for the next component.
                //

                Filename = DataTableEntry->FullDllName.Buffer;
                Length = DataTableEntry->FullDllName.Length / sizeof(WCHAR);
                Count = 0;
                do {
                    Buffer[Count++] = (CHAR)*Filename++;
                } while (Count < Length);

                Buffer[Count] = 0;
                RtlInitString(&NameString, Buffer);
                DbgLoadImageSymbols(&NameString,
                                    DataTableEntry->DllBase,
                                    (ULONG)-1);

                NextEntry = NextEntry->Flink;
                Index += 1;
            }
        }

        //
        // If -b was specified when the host debugger was started, then set up
        // to break after symbols are loaded for the kernel, hal, and drivers
        // that were loaded by the loader.
        //

        if (LoaderBlock != NULL) {
            KdBreakAfterSymbolLoad = KdPollBreakIn();
        }

    } else {

        //
        //  Initialize timer facility - HACKHACK
        //

        KeQueryPerformanceCounter(&KdPerformanceCounterRate);
    }

    return TRUE;
}


BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine is called by a component or driver to register a
    debugger data block.  The data block is made accessible to the
    kernel debugger, thus providing a reliable method of exposing
    random data to debugger extensions.

Arguments:

    Tag - Supplies a unique 4 byte tag which is used to identify the
            data block.

    DataHeader - Supplies the address of the debugger data block header.
            The OwnerTag field must contain a unique value, and the Size
            field must contain the size of the data block, including the
            header.  If this block is already present, or there is
            already a block with the same value for OwnerTag, this one
            will not be inserted.  If Size is incorrect, this code will
            not notice, but the usermode side of the debugger might not
            function correctly.

    Size - Supplies the size of the data block, including the header.

Return Value:

    TRUE if the block was added to the list, FALSE if not.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    KeAcquireSpinLock(&KdpDataSpinLock, &OldIrql);

    //
    // Look for a record with the same tag or address
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);

        List = List->Flink;

        if ((Header == DataHeader) || (Header->OwnerTag == Tag)) {
            KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);
            return FALSE;
        }
    }

    //
    // It wasn't already there, so add it.
    //

    DataHeader->OwnerTag = Tag;
    DataHeader->Size = Size;

    InsertTailList(&KdpDebuggerDataListHead, (PLIST_ENTRY)(&DataHeader->List));

    KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);

    return TRUE;
}


VOID
KdDeregisterDebuggerDataBlock(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    )
/*++

Routine Description:

    This routine is called to deregister a data block previously
    registered with KdRegisterDebuggerDataBlock.  If the block is
    found in the list, it is removed.

Arguments:

    DataHeader - Supplies the address of the data block which is
                to be removed from the list.

Return Value:

    None

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    KeAcquireSpinLock(&KdpDataSpinLock, &OldIrql);

    //
    // Make sure the data block is on our list before removing it.
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);
        List = List->Flink;

        if (DataHeader == Header) {
            RemoveEntryList((PLIST_ENTRY)(&DataHeader->List));
            break;
        }
    }

    KeReleaseSpinLock(&KdpDataSpinLock, OldIrql);
}


VOID
KdLogDbgPrint(
    IN PSTRING String
    )
{
    KIRQL OldIrql;
    ULONG Length;
    ULONG LengthCopied;

    for (; ;) {
        if (KeTestSpinLock (&KdpPrintSpinLock)) {
            KeRaiseIrql (HIGH_LEVEL, &OldIrql);
            if (KeTryToAcquireSpinLockAtDpcLevel(&KdpPrintSpinLock)) {
                break;          // got the lock
            }
            KeLowerIrql(OldIrql);
        }
    }

    if (KdPrintCircularBuffer) {
        Length = String->Length;
        //
        // truncate ridiculous strings
        //
        if (Length > KDPRINTBUFFERSIZE) {
            Length = KDPRINTBUFFERSIZE;
        }

        if (KdPrintWritePointer + Length <= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
            KdpCopyFromPtr(KdPrintWritePointer, String->Buffer, Length, &LengthCopied);
            KdPrintWritePointer += LengthCopied;
            if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                KdPrintWritePointer = KdPrintCircularBuffer;
                KdPrintRolloverCount++;
            }
        } else {
            ULONG First = (ULONG)(KdPrintCircularBuffer + KDPRINTBUFFERSIZE - KdPrintWritePointer);
            KdpCopyFromPtr(KdPrintWritePointer,
                           String->Buffer,
                           First,
                           &LengthCopied);
            if (LengthCopied == First) {
                KdpCopyFromPtr(KdPrintCircularBuffer,
                               String->Buffer + First,
                               Length - First,
                               &LengthCopied);
                LengthCopied += First;
            }
            if (LengthCopied > First) {
                KdPrintWritePointer = KdPrintCircularBuffer + LengthCopied - First;
                KdPrintRolloverCount++;
            } else {
                KdPrintWritePointer += LengthCopied;
                if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                    KdPrintWritePointer = KdPrintCircularBuffer;
                    KdPrintRolloverCount++;
                }
            }
        }
    }

    KiReleaseSpinLock(&KdpPrintSpinLock);
    KeLowerIrql(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdlock.c ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:

    kdlock.c

Abstract:

    This module contains code to synchronize the usage of the port
    used by the kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "kdp.h"


VOID
KdpPortLock(
    VOID
    )

/*++

Routine Description:

    Acquire the spinlock for the debug port.

    Note that user must call this explicitly, the get/put routines
    do NOT make any use of the lock.

    CALLER MUST HAVE SET PROPER IRQL BEFORE CALLING US.

    We use KiAcquireSpinLock and NOT Ke... because our IRQL may
    be above DISPATCH_LEVEL.

Arguments:

    None.

Return value:

    None.

--*/

{
    KiAcquireSpinLock(&KdpDebuggerLock);
}


VOID
KdpPortUnlock(
    VOID
    )

/*++

Routine Description:

    Release the spinlock for the debug port.

    Note that user must call this explicitly, the get/put routines
    do NOT make any use of the lock.

    CALLER MUST HAVE SET PROPER IRQL BEFORE CALLING US.

    We use KiReleaseSpinLock and NOT Ke... because our IRQL may
    be above DISPATCH_LEVEL.

Arguments:

    None.

Return value:

    None.

--*/

{
    KiReleaseSpinLock(&KdpDebuggerLock);
}

BOOLEAN
KdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This procedure raises IRQL to high_level, seizes the Debug port
    spinlock, and checks to see if a breakin packet is pending.
    If a packet is present, return TRUE, else FALSE.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{
    BOOLEAN BreakIn;
    BOOLEAN Enable;
    KIRQL   OldIrql;
    ULONG   Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        Enable = KeDisableInterrupts();

#ifndef _X86_

        KeRaiseIrql(HIGH_LEVEL, &OldIrql);

#endif

        if (KdpContext.KdpControlCPending != FALSE) {
            KdpControlCPressed = TRUE;
            BreakIn = TRUE;
            KdpContext.KdpControlCPending = FALSE;

        } else {
            if (KeTryToAcquireSpinLockAtDpcLevel(&KdpDebuggerLock) != FALSE) {
                Status = KdReceivePacket(PACKET_TYPE_KD_POLL_BREAKIN,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL);
                if (Status == KDP_PACKET_RECEIVED) {
                    BreakIn = TRUE;
                    KdpControlCPressed = TRUE;
                }

                KdpPortUnlock();
            }
        }

#ifndef _X86_

        KeLowerIrql(OldIrql);

#endif

        KeEnableInterrupts(Enable);
    }

    return BreakIn;
}


BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    )

/*++

Routine Description:

    This procedure same as KdPollBreakIn, but assumes the caller
    already holds the port lock.  Returns TRUE if a breakin packet
    is pending.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{

    BOOLEAN BreakIn;
    BOOLEAN Enable;
    ULONG Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        if (KdpContext.KdpControlCPending != FALSE) {
            BreakIn = TRUE;
            KdpContext.KdpControlCPending = FALSE;

        } else {
            Status = KdReceivePacket(PACKET_TYPE_KD_POLL_BREAKIN,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
            if (Status == KDP_PACKET_RECEIVED) {
                BreakIn = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kddata.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kddata.c

Abstract:

    This module contains global data for the portable kernel debgger.

Author:

    Mark Lucovsky 1-Nov-1993

Revision History:

--*/

#include "kdp.h"
#include "ke.h"
#include "pool.h"
#include "stdio.h"


//
// Miscellaneous data from all over the kernel
//



extern PHANDLE_TABLE PspCidTable;

extern LIST_ENTRY ExpSystemResourcesList;
extern PPOOL_DESCRIPTOR ExpPagedPoolDescriptor;
extern ULONG ExpNumberOfPagedPools;

extern ULONG KeTimeIncrement;
extern LIST_ENTRY KeBugCheckCallbackListHead;
extern ULONG_PTR KiBugCheckData[];

extern LIST_ENTRY IopErrorLogListHead;

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_TYPE ObpTypeObjectType;

extern PVOID MmSystemCacheStart;
extern PVOID MmSystemCacheEnd;

extern PVOID MmPfnDatabase;
extern ULONG MmSystemPtesStart[];
extern ULONG MmSystemPtesEnd[];
extern ULONG MmSubsectionBase;
extern ULONG MmNumberOfPagingFiles;

extern ULONG MmLowestPhysicalPage;
extern ULONG MmHighestPhysicalPage;
extern PFN_COUNT MmNumberOfPhysicalPages;

extern ULONG MmMaximumNonPagedPoolInBytes;
extern PVOID MmNonPagedSystemStart;
extern PVOID MmNonPagedPoolStart;
extern PVOID MmNonPagedPoolEnd;

extern PVOID MmPagedPoolStart;
extern PVOID MmPagedPoolEnd;
extern ULONG MmPagedPoolInfo[];
extern ULONG MmSizeOfPagedPoolInBytes;

extern ULONG MmTotalCommitLimit;
extern ULONG MmTotalCommittedPages;
extern ULONG MmSharedCommit;
extern ULONG MmDriverCommit;
extern ULONG MmProcessCommit;
extern ULONG MmPagedPoolCommit;

extern MMPFNLIST MmZeroedPageListHead;
extern MMPFNLIST MmFreePageListHead;
extern MMPFNLIST MmStandbyPageListHead;
extern MMPFNLIST MmModifiedPageListHead;
extern MMPFNLIST MmModifiedNoWritePageListHead;
extern ULONG MmAvailablePages;
extern LONG MmResidentAvailablePages;
extern LIST_ENTRY MmLoadedUserImageList;

extern PPOOL_TRACKER_TABLE PoolTrackTable;
extern POOL_DESCRIPTOR NonPagedPoolDescriptor;

extern PUNLOADED_DRIVERS MmUnloadedDrivers;
extern ULONG MmLastUnloadedDriver;
extern ULONG MmTriageActionTaken;
extern ULONG MmSpecialPoolTag;
extern LOGICAL KernelVerifier;
extern PVOID MmVerifierData;
extern PFN_NUMBER MmAllocatedNonPagedPool;
extern SIZE_T MmPeakCommitment;
extern SIZE_T MmTotalCommitLimitMaximum;

extern ULONG_PTR MmSessionBase;
extern ULONG_PTR MmSessionSize;
#ifdef _IA64_
extern PFN_NUMBER MmSystemParentTablePage;
#endif


//
// These blocks of data needs to always be present because crashdumps
// need the information.  Otherwise, things like PAGE_SIZE are not available
// in crashdumps, and extensions like !pool fail.
//

DBGKD_GET_VERSION64 KdVersionBlock = {
    0,
    0,
    DBGKD_64BIT_PROTOCOL_VERSION2,

#if defined(_M_AMD64)

    DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_AMD64,

#elif defined(_M_IX86)

    DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_I386,

#elif defined(_M_IA64)

    DBGKD_VERS_FLAG_HSS| DBGKD_VERS_FLAG_PTR64 | DBGKD_VERS_FLAG_DATA,
    IMAGE_FILE_MACHINE_IA64,

#endif

    PACKET_TYPE_MAX,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

KDDEBUGGER_DATA64 KdDebuggerDataBlock = {
    {0},                                    //  DBGKD_DEBUG_DATA_HEADER Header;
    (ULONG64)0,
    (ULONG64)RtlpBreakWithStatusInstruction,
    (ULONG64)0,
    (USHORT)FIELD_OFFSET(KTHREAD, CallbackStack),   //  USHORT  ThCallbackStack;

#if defined(_AMD64_)

    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, CallbackStack), //  USHORT  NextCallback;

#else

    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, CbStk),    //  USHORT  NextCallback;

#endif

    #if defined(_X86_)
    (USHORT)FIELD_OFFSET(KCALLOUT_FRAME, Ebp),
    #else
    (USHORT)0,                                      //  USHORT  FramePointer;
    #endif

    #if defined(_X86PAE_) || defined(_AMD64_)
    (USHORT)1,
    #else
    (USHORT)0,                                      //  USHORT  PaeEnabled;
    #endif

    (ULONG64)KiCallUserMode,
    (ULONG64)0,

    (ULONG64)&PsLoadedModuleList,
    (ULONG64)&PsActiveProcessHead,
    (ULONG64)&PspCidTable,

    (ULONG64)&ExpSystemResourcesList,
    (ULONG64)&ExpPagedPoolDescriptor,
    (ULONG64)&ExpNumberOfPagedPools,

    (ULONG64)&KeTimeIncrement,
    (ULONG64)&KeBugCheckCallbackListHead,
    (ULONG64)KiBugCheckData,

    (ULONG64)&IopErrorLogListHead,

    (ULONG64)&ObpRootDirectoryObject,
    (ULONG64)&ObpTypeObjectType,

    (ULONG64)&MmSystemCacheStart,
    (ULONG64)&MmSystemCacheEnd,
    (ULONG64)&MmSystemCacheWs,

    (ULONG64)&MmPfnDatabase,
    (ULONG64)MmSystemPtesStart,
    (ULONG64)MmSystemPtesEnd,
    (ULONG64)&MmSubsectionBase,
    (ULONG64)&MmNumberOfPagingFiles,

    (ULONG64)&MmLowestPhysicalPage,
    (ULONG64)&MmHighestPhysicalPage,
    (ULONG64)&MmNumberOfPhysicalPages,

    (ULONG64)&MmMaximumNonPagedPoolInBytes,
    (ULONG64)&MmNonPagedSystemStart,
    (ULONG64)&MmNonPagedPoolStart,
    (ULONG64)&MmNonPagedPoolEnd,

    (ULONG64)&MmPagedPoolStart,
    (ULONG64)&MmPagedPoolEnd,
    (ULONG64)&MmPagedPoolInfo,
    (ULONG64)PAGE_SIZE,
    (ULONG64)&MmSizeOfPagedPoolInBytes,

    (ULONG64)&MmTotalCommitLimit,
    (ULONG64)&MmTotalCommittedPages,
    (ULONG64)&MmSharedCommit,
    (ULONG64)&MmDriverCommit,
    (ULONG64)&MmProcessCommit,
    (ULONG64)&MmPagedPoolCommit,
    (ULONG64)0,

    (ULONG64)&MmZeroedPageListHead,
    (ULONG64)&MmFreePageListHead,
    (ULONG64)&MmStandbyPageListHead,
    (ULONG64)&MmModifiedPageListHead,
    (ULONG64)&MmModifiedNoWritePageListHead,
    (ULONG64)&MmAvailablePages,
    (ULONG64)&MmResidentAvailablePages,

    (ULONG64)&PoolTrackTable,
    (ULONG64)&NonPagedPoolDescriptor,

    (ULONG64)&MmHighestUserAddress,
    (ULONG64)&MmSystemRangeStart,
    (ULONG64)&MmUserProbeAddress,

    (ULONG64)KdPrintCircularBuffer,
    (ULONG64)KdPrintCircularBuffer+sizeof(KdPrintCircularBuffer),

    (ULONG64)&KdPrintWritePointer,
    (ULONG64)&KdPrintRolloverCount,
    (ULONG64)&MmLoadedUserImageList,

    // Nt 5.1 additions

    (ULONG64)NtBuildLab,
    #if defined(_IA64_)
    (ULONG64)KiNormalSystemCall,
    #else
    (ULONG64)0,
    #endif
    //

    (ULONG64)KiProcessorBlock,
    (ULONG64)&MmUnloadedDrivers,
    (ULONG64)&MmLastUnloadedDriver,
    (ULONG64)&MmTriageActionTaken,
    (ULONG64)&MmSpecialPoolTag,
    (ULONG64)&KernelVerifier,
    (ULONG64)&MmVerifierData,
    (ULONG64)&MmAllocatedNonPagedPool,
    (ULONG64)&MmPeakCommitment,
    (ULONG64)&MmTotalCommitLimitMaximum,
    (ULONG64)&CmNtCSDVersion,

    // Nt 5.1 additions

    (ULONG64)&MmPhysicalMemoryBlock,
    (ULONG64)&MmSessionBase,
    (ULONG64)&MmSessionSize,
#ifdef _IA64_
    (ULONG64)&MmSystemParentTablePage,
#else
    0,
#endif
};

//
// Initialize the component name debug print filter table.
//

ULONG Kd_WIN2000_Mask = 1;

#include "dpfilter.c"

ULONG KdComponentTableSize = sizeof(KdComponentTable) / sizeof(PULONG);

//
// All dta from here on will be paged out if the kernel debugger is
// not enabled.
//

#ifdef _X86_
#ifdef ALLOC_PRAGMA
#pragma data_seg("PAGEKD")
#endif
#endif // _X86_

UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE] = {0};
PUCHAR KdPrintWritePointer = KdPrintCircularBuffer;
ULONG  KdPrintRolloverCount = 0;


BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE] = {0};
// The message buffer needs to be 64-bit aligned.
UCHAR DECLSPEC_ALIGN(8) KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE] = {0};
UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE] = {0};
DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS] = {0};

KD_REMOTE_FILE KdpRemoteFiles[KD_MAX_REMOTE_FILES];

LARGE_INTEGER  KdPerformanceCounterRate = {0,0};
LARGE_INTEGER  KdTimerStart = {0,0} ;
LARGE_INTEGER  KdTimerStop = {0,0};
LARGE_INTEGER  KdTimerDifference = {0,0};

ULONG_PTR KdpCurrentSymbolStart = 0;
ULONG_PTR KdpCurrentSymbolEnd = 0;
LONG      KdpNextCallLevelChange = 0;   // used only over returns to the debugger.

ULONG_PTR KdSpecialCalls[DBGKD_MAX_SPECIAL_CALLS] = {0};
ULONG     KdNumberOfSpecialCalls = 0;
ULONG_PTR InitialSP = 0;
ULONG     KdpNumInternalBreakpoints = 0;
KTIMER    InternalBreakpointTimer = {0};
KDPC      InternalBreakpointCheckDpc = {0};

BOOLEAN   KdpPortLocked = FALSE;


DBGKD_TRACE_DATA TraceDataBuffer[TRACE_DATA_BUFFER_MAX_SIZE] = {0};
ULONG            TraceDataBufferPosition = 1; // Element # to write next
                                   // Recall elt 0 is a length

TRACE_DATA_SYM   TraceDataSyms[256] = {0};
UCHAR NextTraceDataSym = 0;     // what's the next one to be replaced
UCHAR NumTraceDataSyms = 0;     // how many are valid?

ULONG IntBPsSkipping = 0;       // number of exceptions that are being skipped
                                // now

BOOLEAN   WatchStepOver = FALSE;
BOOLEAN   BreakPointTimerStarted = FALSE;
PVOID     WSOThread = NULL;         // thread doing stepover
ULONG_PTR WSOEsp = 0;               // stack pointer of thread doing stepover (yes, we need it)
ULONG     WatchStepOverHandle = 0;
ULONG_PTR WatchStepOverBreakAddr = 0; // where the WatchStepOver break is set
BOOLEAN   WatchStepOverSuspended = FALSE;
ULONG     InstructionsTraced = 0;
BOOLEAN   SymbolRecorded = FALSE;
LONG      CallLevelChange = 0;
LONG_PTR  oldpc = 0;
BOOLEAN   InstrCountInternal = FALSE; // Processing a non-COUNTONLY?

BOOLEAN   BreakpointsSuspended = FALSE;

BOOLEAN KdpControlCPressed   = FALSE;

KDP_BREAKPOINT_TYPE KdpBreakpointInstruction = KDP_BREAKPOINT_VALUE;

KD_CONTEXT KdpContext;

LIST_ENTRY      KdpDebuggerDataListHead = {NULL,NULL};

//
// !search support variables (page hit database)
//

PFN_NUMBER KdpSearchPageHits [SEARCH_PAGE_HIT_DATABASE_SIZE] = {0};
ULONG KdpSearchPageHitOffsets [SEARCH_PAGE_HIT_DATABASE_SIZE] = {0};
ULONG KdpSearchPageHitIndex = 0;

LOGICAL KdpSearchInProgress = FALSE;

PFN_NUMBER KdpSearchStartPageFrame = 0;
PFN_NUMBER KdpSearchEndPageFrame = 0;

ULONG_PTR KdpSearchAddressRangeStart = 0;
ULONG_PTR KdpSearchAddressRangeEnd = 0;

PFN_NUMBER KdpSearchPfnValue = 0;

ULONG KdpSearchCheckPoint = KDP_SEARCH_SYMBOL_CHECK;

BOOLEAN KdpDebuggerStructuresInitialized = FALSE ;

#ifdef _X86_
#ifdef ALLOC_PRAGMA
#pragma data_seg()
#endif
#endif // _X86_

KSPIN_LOCK KdpPrintSpinLock = 0;
KSPIN_LOCK      KdpDataSpinLock = 0;
KSPIN_LOCK      KdpTimeSlipEventLock = 0;
PVOID           KdpTimeSlipEvent = NULL;
KDPC            KdpTimeSlipDpc = {0};
WORK_QUEUE_ITEM KdpTimeSlipWorkItem = {NULL};
KTIMER          KdpTimeSlipTimer = {0};
ULONG           KdpTimeSlipPending = 1;


BOOLEAN KdDebuggerNotPresent = FALSE;
BOOLEAN KdDebuggerEnabled = FALSE;
BOOLEAN KdPitchDebugger = TRUE;
BOOLEAN KdpOweBreakpoint = FALSE;
ULONG KdEnteredDebugger  = FALSE;

#if defined(_AMD64_)

//
// No checks for now.
//

#elif defined(_X86_)

C_ASSERT(sizeof(KPRCB) == X86_NT51_KPRCB_SIZE);
C_ASSERT(sizeof(EPROCESS) == X86_NT51_EPROCESS_SIZE);
C_ASSERT(FIELD_OFFSET(EPROCESS, Peb) == X86_PEB_IN_EPROCESS);
#if !defined (PERF_DATA)
C_ASSERT(sizeof(ETHREAD) == X86_ETHREAD_SIZE);
#endif
C_ASSERT(sizeof(CONTEXT) == sizeof(X86_NT5_CONTEXT));
C_ASSERT(FIELD_OFFSET(KTHREAD, NextProcessor) == X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET);

#elif defined(_IA64_)

C_ASSERT(sizeof(KPRCB) == IA64_KPRCB_SIZE);
C_ASSERT(sizeof(EPROCESS) == IA64_EPROCESS_SIZE);
C_ASSERT(FIELD_OFFSET(EPROCESS, Peb) == IA64_2259_PEB_IN_EPROCESS);
#if !defined (PERF_DATA)
C_ASSERT(sizeof(ETHREAD) == IA64_ETHREAD_SIZE);
#endif
C_ASSERT(sizeof(CONTEXT) == sizeof(IA64_CONTEXT));
C_ASSERT(FIELD_OFFSET(KTHREAD, NextProcessor) == IA64_KTHREAD_NEXTPROCESSOR_OFFSET);
#include <ia64\miia64.h>
C_ASSERT(IA64_PAGE_SIZE              == PAGE_SIZE);
C_ASSERT(IA64_PAGE_SHIFT             == PAGE_SHIFT);
C_ASSERT(IA64_MM_PTE_TRANSITION_MASK == MM_PTE_TRANSITION_MASK);
C_ASSERT(IA64_MM_PTE_PROTOTYPE_MASK  == MM_PTE_PROTOTYPE_MASK);

#else

#error "no target architecture"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kddbgio.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kddbgio.c

Abstract:

    This module implements kernel debugger based Dbg I/O. This
    is the foundation for DbgPrint and DbgPrompt.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpPrintString)
#pragma alloc_text(PAGEKD, KdpPromptString)
#pragma alloc_text(PAGEKD, KdpAcquireBreakpoint)
#endif

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Output->Buffer,
                   Output->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = KeProcessorLevel;
    DebugIo.Processor = (USHORT)KeGetCurrentPrcb()->Number;
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_DEBUG_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );

    return KdpPollBreakInWithPortLock();
}


BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    KdpCopyFromPtr(KdpMessageBuffer,
                   Output->Buffer,
                   Output->Length,
                   &Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = KeProcessorLevel;
    DebugIo.Processor = (USHORT)KeGetCurrentPrcb()->Number;
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(
        PACKET_TYPE_KD_DEBUG_IO,
        &MessageHeader,
        &MessageData,
        &KdpContext
        );


    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do {
        ReturnCode = KdReceivePacket(
            PACKET_TYPE_KD_DEBUG_IO,
            &MessageHeader,
            &MessageData,
            &Length,
            &KdpContext
            );
        if (ReturnCode == KDP_PACKET_RESEND) {
            return TRUE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);


    if (Length > Input->MaximumLength) {
        Length = Input->MaximumLength;
    }

    KdpCopyToPtr(Input->Buffer,
                 KdpMessageBuffer,
                 Length,
                 &Length);
    Input->Length = (USHORT)Length;

    return FALSE;
}





BOOLEAN
KdpAcquireBreakpoint(
    IN ULONG Number
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Number - breakpoint register number being requested.

Return Value:

    TRUE - Breakpoint now reserved for kernel use.
    FALSE - breakpoint not available.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_CONTROL_REQUEST ControlRequest;
    ULONG ReturnCode;

    //
    // Construct the prompt string message and message descriptor.
    //

    ControlRequest.ApiNumber = DbgKdRequestHardwareBp;
    ControlRequest.u.RequestBreakpoint.HardwareBreakPointNumber = Number;
    ControlRequest.u.RequestBreakpoint.Available = FALSE;
    MessageHeader.Length = sizeof(ControlRequest);
    MessageHeader.Buffer = (PCHAR)&ControlRequest;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdSendPacket(PACKET_TYPE_KD_CONTROL_REQUEST,
                 &MessageHeader,
                 NULL,
                 &KdpContext);

    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(PACKET_TYPE_KD_CONTROL_REQUEST);

    MessageData.Buffer = KdpMessageBuffer;
    MessageData.Length = 0;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do
    {
        ReturnCode = KdReceivePacket(PACKET_TYPE_KD_CONTROL_REQUEST,
                                     &MessageHeader,
                                     &MessageData,
                                     &Length,
                                     &KdpContext);

        if (ReturnCode == KDP_PACKET_RESEND)
        {
            return FALSE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    return (ControlRequest.u.RequestBreakpoint.Available == 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdmove.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdmove.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpQuickMoveMemory)
#pragma alloc_text(PAGEKD, KdpCopyMemoryChunks)
#endif

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine does the exact same thing as RtlCopyMemory, BUT it is
    private to the debugger.  This allows folks to set breakpoints and
    watch points in RtlCopyMemory without risk of recursive debugger
    entry and the accompanying hang.

    N.B.  UNLIKE KdpCopyMemoryChunks, this routine does NOT check for
      accessibility and may fault!  Use it ONLY in the debugger and ONLY
      where you could use RtlCopyMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/
{
    while (Length > 0) {
        *Destination = *Source;
        Destination++;
        Source++;
        Length--;
    }
}

NTSTATUS
KdpCopyMemoryChunks(
    ULONG64 Address,
    PVOID Buffer,
    ULONG TotalSize,
    ULONG ChunkSize,
    ULONG Flags,
    PULONG ActualSize OPTIONAL
    )

/*++

Routine Description:

    Copies memory to/from a buffer to/from a system address.
    The address can be physical or virtual.

    The buffer is assumed to be valid for the duration of this call.

Arguments:

    Address - System address.

    Buffer - Buffer to read from or write to.

    TotalSize - Number of bytes to read/write.

    ChunkSize - Maximum single item transfer size, must
                be 1, 2, 4 or 8.
                0 means choose a default.

    Flags - MMDBG_COPY flags for MmDbgCopyMemory.
    
    ActualSize - Number of bytes actually read/written.

Return Value:

    NTSTATUS

--*/

{
    ULONG Length;
    ULONG CopyChunk;
    NTSTATUS Status;
    ULONG64 AddressStart = Address;

    if (ChunkSize > MMDBG_COPY_MAX_SIZE) {
        ChunkSize = MMDBG_COPY_MAX_SIZE;
    } else if (ChunkSize == 0) {
        // Default to 4 byte chunks as that's
        // what the previous code did.
        ChunkSize = 4;
    }

    //
    // MmDbgCopyMemory only copies a single aligned chunk at a
    // time.  It is Kd's responsibility to chunk up a larger
    // request for individual copy requests.  This gives Kd
    // the flexibility to pick a chunk size and also frees
    // Mm from having to worry about more than a page at a time.
    // Additionally, it is important that we access memory with the
    // largest size possible because we could be accessing
    // memory-mapped I/O space.
    //

    Length = TotalSize;
    CopyChunk = 1;
    
    while (Length > 0) {

        // Expand the chunk size as long as:
        //   We haven't hit the chunk limit.
        //   We have enough data left.
        //   The address is properly aligned.
        while (CopyChunk < ChunkSize &&
               (CopyChunk << 1) <= Length &&
               (Address & ((CopyChunk << 1) - 1)) == 0) {
            CopyChunk <<= 1;
        }
        
        // Shrink the chunk size to fit the available data.
        while (CopyChunk > Length) {
            CopyChunk >>= 1;
        }
        
        Status = MmDbgCopyMemory(Address, Buffer, CopyChunk, Flags);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        Address += CopyChunk;
        Buffer = (PVOID)((PUCHAR)Buffer + CopyChunk);
        Length -= CopyChunk;
    }

    if (ActualSize)
    {
        *ActualSize = TotalSize - Length;
    }

    //
    // Flush the instruction cache in case the write was into the instruction
    // stream.  Only do this when writing into the kernel address space,
    // and if any bytes were actually written
    //

    if ((Flags & MMDBG_COPY_WRITE) &&
        Length < TotalSize) {
#if defined(_IA64_)
        KeSweepCurrentIcacheRange((PVOID)AddressStart, TotalSize - Length);
#else
        KeSweepCurrentIcache();
#endif
    }

    return Length != 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=kd

TARGETNAME=kd
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;\
    ..\..\inc;\
    ..\..\ke;\
    ..\..\mm;\
    ..\$(TARGET_DIRECTORY);\
    $(PROJECT_ROOT)\published\$(O);\
    $(SDKTOOLS_INC_PATH)

SOURCES=..\file.c    \
        ..\kdinit.c  \
        ..\kdbreak.c \
        ..\kdlock.c  \
        ..\kdmove.c  \
        ..\kddbgio.c \
        ..\kdapi.c   \
        ..\kddata.c  \
        ..\print.c   \
        ..\query.c

PRECOMPILED_INCLUDE=..\kdp.h
PRECOMPILED_PCH=kdp.pch
PRECOMPILED_OBJ=kdp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\amd64\kdcmsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpQueryPerformanceCounter)
#endif

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:

        This function optionaly calls KeQueryPerformanceCounter for
        the debugger.  If the trap had interrupts off, then no call
        to KeQueryPerformanceCounter is possible and a NULL is returned.

    Return Value:

        returns KeQueryPerformanceCounter if possible.
        otherwise 0

--*/

{

    if (!(TrapFrame->EFlags & EFLAGS_IF_MASK)) {
        LARGE_INTEGER LargeIntegerZero;

        LargeIntegerZero.QuadPart = 0;
        return LargeIntegerZero;

    } else {
        return KeQueryPerformanceCounter(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\i386\kdcmsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpQueryPerformanceCounter)
#endif

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

    Routine Description:

        This function optionaly calls KeQueryPerformanceCounter for
        the debugger.  If the trap had interrupts off, then no call
        to KeQueryPerformanceCounter is possible and a NULL is returned.

    Return Value:

        returns KeQueryPerformanceCounter if possible.
        otherwise 0
--*/
{

    if (!(TrapFrame->EFlags & EFLAGS_INTERRUPT_MASK)) {
        LARGE_INTEGER LargeIntegerZero;

        LargeIntegerZero.QuadPart = 0;
        return LargeIntegerZero;
    } else {
        return KeQueryPerformanceCounter(0);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\amd64\kdcpuapi.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    David N. Cutler (davec) 14-May-2000

Revision History:

--*/

#include "kdp.h"
#include <stdio.h>

#pragma alloc_text(PAGEKD, KdpSetContextState)
#pragma alloc_text(PAGEKD, KdpSetStateChange)
#pragma alloc_text(PAGEKD, KdpGetStateChange)
#pragma alloc_text(PAGEKD, KdpSysReadControlSpace)
#pragma alloc_text(PAGEKD, KdpSysWriteControlSpace)
#pragma alloc_text(PAGEKD, KdpReadIoSpace)
#pragma alloc_text(PAGEKD, KdpWriteIoSpace)
#pragma alloc_text(PAGEKD, KdpReadMachineSpecificRegister)
#pragma alloc_text(PAGEKD, KdpWriteMachineSpecificRegister)

VOID
KdpSetContextState (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )
{

    PKPRCB Prcb;

    //
    // Copy special registers for the AMD64.
    //

    Prcb = KeGetCurrentPrcb();
    WaitStateChange->ControlReport.Dr6 =
                            Prcb->ProcessorState.SpecialRegisters.KernelDr6;

    WaitStateChange->ControlReport.Dr7 =
                            Prcb->ProcessorState.SpecialRegisters.KernelDr7;

    WaitStateChange->ControlReport.SegCs = ContextRecord->SegCs;
    WaitStateChange->ControlReport.SegDs = ContextRecord->SegDs;
    WaitStateChange->ControlReport.SegEs = ContextRecord->SegEs;
    WaitStateChange->ControlReport.SegFs = ContextRecord->SegFs;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = AMD64_REPORT_INCLUDES_SEGS;

    // If the current code segment is a known flat code
    // segment let the debugger know so that it doesn't
    // have to retrieve the descriptor.
    if (ContextRecord->SegCs == KGDT64_R0_CODE ||
        ContextRecord->SegCs == KGDT64_R3_CODE + 3) {
        WaitStateChange->ControlReport.ReportFlags |= AMD64_REPORT_STANDARD_CS;
    }
}

VOID
KdpSetStateChange (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    KdpSetContextState(WaitStateChange, ContextRecord);
}

VOID
KdpGetStateChange (
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from manipulate state message.

Arguments:

    ManipulateState - Supplies pointer to manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    ULONG Number;
    PKPRCB Prcb;

    //
    // If the status of the manipulate state message was successful, then
    // extract the continuation control information.
    //

    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) != FALSE) {

        //
        // Set or clear the TF flag in the EFLAGS field of the context record.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag != FALSE) {
            ContextRecord->EFlags |= EFLAGS_TF_MASK;

        } else {
            ContextRecord->EFlags &= ~EFLAGS_TF_MASK;

        }

        //
        // Clear DR6 and set the specified DR7 value for each of the processors.
        //

        for (Number = 0; Number < (ULONG)KeNumberProcessors; Number += 1) {
            Prcb = KiProcessorBlock[Number];
            Prcb->ProcessorState.SpecialRegisters.KernelDr6 = 0;
            Prcb->ProcessorState.SpecialRegisters.KernelDr7 =
                                ManipulateState->u.Continue2.ControlSet.Dr7;
        }
    }

    return;
}

NTSTATUS
KdpSysReadControlSpace (
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    This function reads implementation specific system data for the specified
    processor.

Arguments:

    Processor - Supplies the source processor number.

    Address - Supplies the type of data to read.

    Buffer - Supplies the address of the output buffer.

    Request - Supplies the requested number of bytes of data.

    Actual - Supplies a point to a variable that receives the actual number
        of bytes of data returned.

Return Value:

    NTSTATUS.

--*/

{

    PVOID Data;
    ULONG Length;
    PKPRCB Prcb;
    PVOID Source;

    //
    // If the specified processor number is greater than the number of
    // processors in the system or the specified processor is not in the
    // host configuration, then return an unsuccessful status.
    //

    *Actual = 0;
    if ((Processor >= (ULONG)KeNumberProcessors) ||
        (KiProcessorBlock[Processor] == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Case on address to determine what part of Control space is being read.
    //

    Prcb = KiProcessorBlock[Processor];
    switch (Address) {

        //
        // Read the address of the PCR for the specified processor.
        //

    case DEBUG_CONTROL_SPACE_PCR:
        Data = CONTAINING_RECORD(Prcb, KPCR, Prcb);
        Source = &Data;
        Length = sizeof(PVOID);
        break;

        //
        // Read the address of the PRCB for the specified processor.
        //

    case DEBUG_CONTROL_SPACE_PRCB:
        Source = &Prcb;
        Length = sizeof(PVOID);
        break;

        //
        // Read the address of the current thread for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_THREAD:
        Source = &Prcb->CurrentThread;
        Length = sizeof(PVOID);
        break;

        //
        // Read the special processor registers structure for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_KSPECIAL:
        Source = &Prcb->ProcessorState.SpecialRegisters;
        Length = sizeof(KSPECIAL_REGISTERS);
        break;

        //
        // Invalid information type.
        //

    default:
        return STATUS_UNSUCCESSFUL;

    }

    //
    // If the length of the data is greater than the request length, then
    // reduce the length to the requested length.
    //

    if (Length > Request) {
        Length = Request;
    }

    //
    // Move the data to the supplied buffer and return status dependent on
    // whether the entire data item can be moved.
    //

    return KdpCopyToPtr(Buffer, Source, Length, Actual);
}

NTSTATUS
KdpSysWriteControlSpace (
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    This function write implementation specific system data for the specified
    processor.

Arguments:

    Processor - Supplies the source processor number.

    Address - Supplies the type of data to write.

    Buffer - Supplies the address of the input buffer.

    Request - Supplies the requested number of bytes of data.

    Actual - Supplies a point to a variable that receives the actual number
        of bytes of data written.

Return Value:

    NTSTATUS.

--*/

{

    PKPRCB Prcb;

    //
    // If the specified processor number is greater than the number of
    // processors in the system or the specified processor is not in the
    // host configuration, then return an unsuccessful status.
    //

    *Actual = 0;
    if ((Processor >= (ULONG)KeNumberProcessors) ||
        (KiProcessorBlock[Processor] == NULL)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Case on address to determine what part of control space is being writen.
    //

    Prcb = KiProcessorBlock[Processor];
    switch (Address) {
    
        //
        // Write the special processor registers structure for the specified
        // processor.
        //

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        //
        // If the length of the data is greater than the request length, then
        // reduce the requested length to the length of the data.
        //

        if (Request > sizeof(KSPECIAL_REGISTERS)) {
            Request = sizeof(KSPECIAL_REGISTERS);
        }
    
        //
        // Move the data to the supplied buffer and return status dependent on
        // whether the entire data item can be moved.
        //

        return KdpCopyFromPtr(&Prcb->ProcessorState.SpecialRegisters,
                              Buffer,
                              Request,
                              Actual);

        //
        // Invalid information type.
        //

    default:
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    if ((InterfaceType != Isa) || (BusNumber != 0) || (AddressSpace != 1)) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch (Request) {
        case 1:
            *(PUCHAR)Buffer = READ_PORT_UCHAR((PUCHAR)Address);
            *Actual = 1;
            break;

        case 2:
            if (Address & 1) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                *(PUSHORT)Buffer = READ_PORT_USHORT((PUSHORT)Address);
                *Actual = 2;
            }

            break;

        case 4:
            if (Address & 3) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                *(PULONG)Buffer = READ_PORT_ULONG((PULONG)Address);
                *Actual = 4;
            }

            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((InterfaceType != Isa) || (BusNumber != 0) || (AddressSpace != 1)) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch (Request) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)Address, *(PUCHAR)Buffer);
            *Actual = 1;
            break;

        case 2:
            if (Address & 1) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)Address, *(PUSHORT)Buffer);
                *Actual = 2;
            }

            break;

        case 4:
            if (Address & 3) {
                Status = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)Address, *(PULONG)Buffer);
                *Actual = 4;
            }

            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Reads an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    try {
        *Data = ReadMSR(Msr);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        *Data = 0;
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Writes an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;

    try {
        WriteMSR(Msr, *Data);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\kdp.h ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdp.h

Abstract:

    Private include file for the Kernel Debugger subcomponent
    of the NTOS project

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#include "ntos.h"
#include "ki.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "string.h"
#include "stdlib.h"
#include "kddll.h"


#if defined(_ALPHA_)

#include "alphaops.h"

//
// Define KD private PCR routines.
//
// Using the following private KD routines allows the kernel debugger to
// step over breakpoints in modules that call the standard PCR routines.
//

PKPCR KdpGetPcr();

ULONG KdpReadInternalProcessorState(PVOID, ULONG);
ULONG KdpReadInternalProcessorCounters(PVOID, ULONG);

struct _KPRCB *
KdpGetCurrentPrcb();

struct _KTHREAD *
KdpGetCurrentThread();

//
// Redefine the standard PCR routines
//

#undef KiPcr
#define KiPcr KdpGetPcr()

#undef KeGetPcr
#undef KeGetCurrentPrcb
#undef KeGetCurrentThread
#undef KeIsExecutingDpc
#define KeGetPcr() KdpGetPcr()
#define KeGetCurrentPrcb() KdpGetCurrentPrcb()
#define KeGetCurrentThread() KdpGetCurrentThread()

//
// Define TYPES
//

#define KDP_BREAKPOINT_TYPE  ULONG
#define KDP_BREAKPOINT_BUFFER sizeof(ULONG)

// longword aligned
#define KDP_BREAKPOINT_ALIGN 3
#define KDP_BREAKPOINT_INSTR_ALIGN 3

// actual instruction is "call_pal kbpt"
#define KDP_BREAKPOINT_VALUE KBPT_FUNC


#elif defined(_IA64_)

// IA64 instruction is in a 128-bit bundle. Each bundle consists of 3 instruction slots.
// Each instruction slot is 41-bit long.
//
//
//            127           87 86           46 45            5 4      1 0
//            ------------------------------------------------------------
//            |    slot 2     |    slot 1     |    slot 0     |template|S|
//            ------------------------------------------------------------
//
//            127        96 95         64 63          32 31             0
//            ------------------------------------------------------------
//            |  byte 3    |  byte 2     |  byte 1      |   byte 0       |
//            ------------------------------------------------------------
//
// This presents two incompatibilities with conventional processors:
//              1. The IA64 IP address is at the bundle bundary. The instruction slot number is
//                 stored in ISR.ei at the time of exception.
//              2. The 41-bit instruction format is not byte-aligned.
//
// Break instruction insertion must be done with proper bit-shifting to align with the selected
// instruction slot. Further, to insert break instruction insertion at a specific slot, we must
// be able to specify instruction slot as part of the address. We therefore define an EM address as
// bundle address + slot number with the least significant two bit always zero:
//
//                      31                 4 3  2  1  0
//                      --------------------------------
//                      |  bundle address    |slot#|0 0|
//                      --------------------------------
//
// The EM address as defined is the byte-aligned address that is closest to the actual instruction slot.
// i.e., The EM instruction address of slot #0 is equal to bundle address.
//                                     slot #1 is equal to bundle address + 4.
//                                     slot #2 is equal to bundle address + 8.

//
//  Upon exception, the bundle address is kept in IIP, and the instruction slot which caused
//  the exception is in ISR.ei. Kernel exception handler will construct the flat address and
//  export it in ExceptionRecord.ExceptionAddress.


#define KDP_BREAKPOINT_TYPE  ULONGLONG          // 64-bit ULONGLONG type is needed to cover 41-bit EM break instruction.
#define KDP_BREAKPOINT_BUFFER (2 * sizeof(ULONGLONG))
#define KDP_BREAKPOINT_ALIGN 0x3                // An EM address consists of bundle and slot number and is 32-bit aligned.
#define KDP_BREAKPOINT_INSTR_ALIGN 0xf
#define KDP_BREAKPOINT_VALUE (BREAK_INSTR | (BREAKPOINT_STOP << 6))

#elif defined(_X86_) || defined(_AMD64_)

#define KDP_BREAKPOINT_TYPE  UCHAR
#define KDP_BREAKPOINT_BUFFER sizeof(UCHAR)
#define KDP_BREAKPOINT_ALIGN 0
#define KDP_BREAKPOINT_INSTR_ALIGN 0
#define KDP_BREAKPOINT_VALUE 0xcc

#endif

//
// Define constants.
//

//
// Addresses above GLOBAL_BREAKPOINT_LIMIT are either in system space
// or part of dynlink, so we treat them as global.
//

#define GLOBAL_BREAKPOINT_LIMIT 1610612736L // 1.5gigabytes

//
// Define breakpoint table entry structure.
//

#define KD_BREAKPOINT_IN_USE        0x00000001
#define KD_BREAKPOINT_NEEDS_WRITE   0x00000002
#define KD_BREAKPOINT_SUSPENDED     0x00000004
#define KD_BREAKPOINT_NEEDS_REPLACE 0x00000008
// IA64 specific defines
#define KD_BREAKPOINT_STATE_MASK    0x0000000f
#define KD_BREAKPOINT_IA64_MASK     0x000f0000
#define KD_BREAKPOINT_IA64_MODE     0x00010000   // IA64 mode
#define KD_BREAKPOINT_IA64_MOVL     0x00020000   // MOVL instruction displaced

typedef struct _BREAKPOINT_ENTRY {
    ULONG Flags;
    ULONG_PTR DirectoryTableBase;
    PVOID Address;
    KDP_BREAKPOINT_TYPE Content;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;

//
// Misc defines
//

#define MAXIMUM_RETRIES 20

#define DBGKD_MAX_SPECIAL_CALLS 10

typedef struct _TRACE_DATA_SYM {
    ULONG SymMin;
    ULONG SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

#define KD_MAX_REMOTE_FILES 16

typedef struct _KD_REMOTE_FILE {
    ULONG64 RemoteHandle;
} KD_REMOTE_FILE, *PKD_REMOTE_FILE;

//
// Define function prototypes.
//

NTSTATUS
KdpPrint(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Message,
    IN USHORT Length,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    OUT PBOOLEAN Completion
    );

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    );

USHORT
KdpPrompt(
    IN PCHAR Message,
    IN USHORT MessageLength,
    IN OUT PCHAR Reply,
    IN USHORT ReplyLength,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

BOOLEAN
KdpReport(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

VOID
KdpSymbol(
    IN PSTRING String,
    IN PKD_SYMBOLS_INFO Symbol,
    IN BOOLEAN Unload,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KdpCommandString(
    IN PSTRING Name,
    IN PSTRING Command,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    );

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    );

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

#if defined(_IA64_)

BOOLEAN
KdpSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

BOOLEAN
KdpRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );
#endif

#if i386

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

NTSTATUS
KdGetTraceInformation (
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength
    );

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    );

#endif

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN ULONG Length,
    OUT PULONG RequiredLength
    );

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PCONTEXT ContextRecord
    );

VOID
KdClearSpecialCalls (
    VOID
    );

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

NTSTATUS
KdpCopyMemoryChunks(
    ULONG64 Address,
    PVOID Buffer,
    ULONG TotalSize,
    ULONG ChunkSize,
    ULONG Flags,
    PULONG ActualSize OPTIONAL
    );

//
// KdpCopyMemoryChunks always copies between an untrusted address
// and a trusted buffer.  The following two macros express a read
// form of this and a write form in a way similar to RtlCopyMemory
// for convenient replacement of RtlCopyMemory calls.
//

// Read memory from an untrusted pointer into a trusted buffer.
#define KdpCopyFromPtr(Dst, Src, Size, Done) \
    KdpCopyMemoryChunks((ULONG_PTR)(Src), Dst, Size, 0,                       \
                        MMDBG_COPY_UNSAFE, Done)
// Write memory from a trusted buffer through an untrusted pointer.
#define KdpCopyToPtr(Dst, Src, Size, Done) \
    KdpCopyMemoryChunks((ULONG_PTR)(Dst), Src, Size, 0,                       \
                        MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE, Done)

ULONG
KdpReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

VOID
KdpSetContextState(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    );

VOID
KdpSetStateChange(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    );

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord64,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpSwitchProcessor (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    );

VOID
KdpReportCommandStringStateChange (
    IN PSTRING Name,
    IN PSTRING Command,
    IN OUT PCONTEXT ContextRecord
    );

KCONTINUE_STATUS
KdpSendWaitContinue(
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    );

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

#if 0
VOID
KdpReadVirtualMemory64(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );
#endif

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

#if 0
VOID
KdpWriteVirtualMemory64(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );
#endif

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadIoSpaceExtended (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteIoSpaceExtended (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpGetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSetBusData (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
KdpSendTraceData(
    PSTRING Data
    );


VOID
KdpSuspendBreakpoint (
    ULONG Handle
    );

VOID
KdpSuspendAllBreakpoints (
    VOID
    );

VOID
KdpRestoreAllBreakpoints (
    VOID
    );

VOID
KdpTimeSlipDpcRoutine (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
KdpTimeSlipWork (
    IN PVOID Context
    );

//
// Routines shared between the debugger and
// NtSystemDebugControl.
//

VOID
KdpSysGetVersion(
    PDBGKD_GET_VERSION64 Version
    );

NTSTATUS
KdpSysReadControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    );

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    );

NTSTATUS
KdpSysReadBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysWriteBusData(
    BUS_DATA_TYPE BusDataType,
    ULONG BusNumber,
    ULONG SlotNumber,
    ULONG Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    );

NTSTATUS
KdpSysCheckLowMemory(
    VOID
    );

//
// Define dummy prototype so the address of the standard breakpoint instruction
// can be captured.
//
// N.B. This function is NEVER called.
//

VOID
RtlpBreakWithStatusInstruction (
    VOID
    );

//
// Define external references.
//

#define KDP_MESSAGE_BUFFER_SIZE 4096

extern BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
extern KD_REMOTE_FILE KdpRemoteFiles[KD_MAX_REMOTE_FILES];
extern KSPIN_LOCK KdpDebuggerLock;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;
extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern UCHAR DECLSPEC_ALIGN(8) KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern BOOLEAN KdpOweBreakpoint;

extern LARGE_INTEGER KdPerformanceCounterRate;
extern LARGE_INTEGER KdTimerStart;
extern LARGE_INTEGER KdTimerStop;
extern LARGE_INTEGER KdTimerDifference;

extern ULONG KdComponentTableSize;
extern PULONG KdComponentTable[];

extern BOOLEAN BreakpointsSuspended;
extern LIST_ENTRY KdpDebuggerDataListHead;

typedef struct {
    ULONG64 Addr;               // pc address of breakpoint
    ULONG Flags;                // Flags bits
    ULONG Calls;                // # of times traced routine called
    ULONG CallsLastCheck;       // # of calls at last periodic (1s) check
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;      // largest number of instructions for 1 call
    ULONG MaxInstructions;      // smallest # of instructions for 1 call
    ULONG TotalInstructions;    // total instructions for all calls
    ULONG Handle;               // handle in (regular) bpt table
    PVOID Thread;               // Thread that's skipping this BP
    ULONG64 ReturnAddress;        // return address (if not COUNTONLY)
} DBGKD_INTERNAL_BREAKPOINT, *PDBGKD_INTERNAL_BREAKPOINT;


extern DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS];

extern ULONG_PTR   KdpCurrentSymbolStart;
extern ULONG_PTR   KdpCurrentSymbolEnd;
extern LONG    KdpNextCallLevelChange;
extern ULONG_PTR   KdSpecialCalls[];
extern ULONG   KdNumberOfSpecialCalls;
extern ULONG_PTR   InitialSP;
extern ULONG   KdpNumInternalBreakpoints;
extern KTIMER  InternalBreakpointTimer;
extern KDPC    InternalBreakpointCheckDpc;
extern BOOLEAN KdpPortLocked;
extern LARGE_INTEGER   KdpTimeEntered;

extern DBGKD_TRACE_DATA TraceDataBuffer[];
extern ULONG            TraceDataBufferPosition;
extern TRACE_DATA_SYM   TraceDataSyms[];
extern UCHAR NextTraceDataSym;
extern UCHAR NumTraceDataSyms;
extern ULONG IntBPsSkipping;
extern BOOLEAN WatchStepOver;
extern BOOLEAN BreakPointTimerStarted;
extern PVOID WSOThread;
extern ULONG_PTR WSOEsp;
extern ULONG WatchStepOverHandle;
extern ULONG_PTR WatchStepOverBreakAddr;
extern BOOLEAN WatchStepOverSuspended;
extern ULONG InstructionsTraced;
extern BOOLEAN SymbolRecorded;
extern LONG CallLevelChange;
extern LONG_PTR oldpc;
extern BOOLEAN InstrCountInternal;
extern BOOLEAN BreakpointsSuspended;
extern BOOLEAN KdpControlCPressed;
extern KD_CONTEXT KdpContext;

extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE];
extern PUCHAR KdPrintWritePointer;
extern ULONG  KdPrintRolloverCount;
extern KSPIN_LOCK KdpPrintSpinLock;
extern KSPIN_LOCK KdpDataSpinLock;
extern LIST_ENTRY KdpDebuggerDataListHead;
extern DBGKD_GET_VERSION64 KdVersionBlock;
extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;
extern KDPC KdpTimeSlipDpc;
extern WORK_QUEUE_ITEM KdpTimeSlipWorkItem;
extern KTIMER KdpTimeSlipTimer;
extern ULONG KdpTimeSlipPending;
extern KSPIN_LOCK KdpTimeSlipEventLock;
extern PVOID KdpTimeSlipEvent;
extern BOOLEAN KdpDebuggerStructuresInitialized;
extern ULONG KdEnteredDebugger;

//
// !search support (page hit database)
//

//
// Hit database where search results are stored (kddata.c).
// The debugger extensions know how to extract the information
// from here.
//
// Note that the size of the hit database is large enough to
// accomodate any searches because the !search extension works
// in batches of pages < PAGE_SIZE and for every page we register only
// one hit.
//

#define SEARCH_PAGE_HIT_DATABASE_SIZE PAGE_SIZE

extern PFN_NUMBER KdpSearchPageHits[SEARCH_PAGE_HIT_DATABASE_SIZE];
extern ULONG KdpSearchPageHitOffsets[SEARCH_PAGE_HIT_DATABASE_SIZE];

extern ULONG KdpSearchPageHitIndex;

//
// Set to true while a physical memory search is in progress.
// Reset at the end of the search. This is done in the debugger
// extension and it is a flag used by KdpCheckLowMemory to get
// onto a different code path.
//

extern LOGICAL KdpSearchInProgress;

//
// These variables store the current state of the search operation.
// They can be used to restore an interrupted search.
//

extern PFN_NUMBER KdpSearchStartPageFrame;
extern PFN_NUMBER KdpSearchEndPageFrame;

extern ULONG_PTR KdpSearchAddressRangeStart;
extern ULONG_PTR KdpSearchAddressRangeEnd;

extern PFN_NUMBER KdpSearchPfnValue;

//
// Checkpoint variable used to test if we have the right
// debugging symbols.
//

#define KDP_SEARCH_SYMBOL_CHECK 0xABCDDCBA

extern ULONG KdpSearchCheckPoint;

//
// Page search flags
//

#define KDP_SEARCH_ALL_OFFSETS_IN_PAGE 0x0001



//
// Private procedure prototypes
//

BOOLEAN
KdpAcquireBreakpoint(
    IN ULONG Number
    );

VOID
KdpInitCom(
    VOID
    );

VOID
KdpPortLock(
    VOID
    );

VOID
KdpPortUnlock(
    VOID
    );

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    );

USHORT
KdpReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    );

#if DBG

#include <stdio.h>
#define DPRINT(s) KdpDprintf s

VOID
KdpDprintf(
    IN PCHAR f,
    ...
    );

#else

#define DPRINT(s)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\query.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    query.c

Abstract:

    This module contains the NT service to query the debug print enable
    for a specified component and level.

Author:

    David N. Cutler (davec) 29-Jan-2000

Revision History:

--*/

#include "kdp.h"
#pragma hdrstop

#pragma alloc_text (PAGE, NtSetDebugFilterState)

NTSTATUS
NtQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    )

/*++

Routine Description:

    This function queries the debug print enable for a specified component
    level.

Arguments:

    ComponentId - Supplies the component id.

    Level - Supplies the debug filter level number or mask.

Return Value:

    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
        valid.

    TRUE is returned if output is enabled for the specified component
        and level or is enabled for the system.

    FALSE is returned if output is not enabled for the specified component
        and level and is not enabled for the system.

--*/

{

    ULONG Mask;
    PULONG Value;

    //
    // If the component id is out of range, then return an invalid parameter
    // status. Otherwise, if output is enabled for the specified component
    // and level or is enabled for the system, then return TRUE. Otherwise,
    // return FALSE.
    //

    Value = &Kd_WIN2000_Mask;
    if (ComponentId < KdComponentTableSize) {
        Value = KdComponentTable[ComponentId];

    } else if (ComponentId != -1) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (Level > 31) {
        Mask = Level;

    } else {
        Mask = 1 << Level;
    }

    if (((Mask & Kd_WIN2000_Mask) == 0) &&
        ((Mask & *Value) == 0)) {
        return FALSE;

    } else {
        return TRUE;
    }
}

NTSTATUS
NtSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    )

/*++

Routine Description:

    This function sets the state of the debug print enable for a specified
    component and level. The debug print enable state for the system is set
    by specifying the distinguished value -1 for the component id.

Arguments:

    ComponentId - Supplies the component id.

    Level - Supplies the debug filter level number or mask.

    State - Supplies a boolean value that determines the new state.

Return Value:

    STATUS_ACCESS_DENIED is returned if the required privilege is not held.

    STATUS_INVALID_PARAMETER_1 is returned if the component id is not
        valid.

    STATUS_SUCCESS  is returned if the debug print enable state is set for
        the specified component.

--*/

{

    ULONG Enable;
    ULONG Mask;
    PULONG Value;

    //
    // If the required privilege is not held, then return a status of access
    // denied. Otherwise, if the component id is out of range, then return an
    // invalid parameter status. Otherwise, the debug print enable state is
    // set for the specified component and a success status is returned.
    //

    if (SeSinglePrivilegeCheck(SeDebugPrivilege, KeGetPreviousMode()) != FALSE) {
        Value = &Kd_WIN2000_Mask;
        if (ComponentId < KdComponentTableSize) {
            Value = KdComponentTable[ComponentId];

        } else if (ComponentId != - 1) {
            return STATUS_INVALID_PARAMETER_1;
        }

        if (Level > 31) {
            Mask = Level;

        } else {
            Mask = 1 << Level;
        }

        Enable = Mask;
        if (State == FALSE) {
            Enable = 0;
        }

        *Value = (*Value & ~Mask) | Enable;
        return STATUS_SUCCESS;

    } else {
        return STATUS_ACCESS_DENIED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\amd64\kdtrap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    David N. Cutler (davec) 14-May-2000

Revision History:

--*/

#include "kdp.h"

#pragma alloc_text(PAGEKD, KdpTrap)
#pragma alloc_text(PAGEKD, KdIsThisAKdTrap)

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN UnloadSymbols = FALSE;
    ULONG64 OldRip;

    //
    // Print, Prompt, Load symbols, Unload symbols, are all special
    // cases of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // Switch on the breakpoint code.
        //

        OldRip = ContextRecord->Rip;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print a debug string.
            //
            // Arguments:
            //
            //     rcx - Supplies a pointer to an output string buffer.
            //     dx - Supplies the length of the output string buffer.
            //     r8d - Supplies the Id of the calling component.
            //     r9d - Supplies the output filter level.
            //

        case BREAKPOINT_PRINT:
            ContextRecord->Rax = KdpPrint((ULONG)ContextRecord->R8,
                                          (ULONG)ContextRecord->R9,
                                          (PCHAR)ContextRecord->Rcx,
                                          (USHORT)ContextRecord->Rdx,
                                          PreviousMode,
                                          TrapFrame,
                                          ExceptionFrame,
                                          &Completion);

            break;

            //
            // Print a debug prompt string, then input a string.
            //
            // Arguments:
            //
            //     rcx - Supplies a pointer to an output string buffer.
            //     dx - Supplies the length of the output string buffer.
            //     r8 - Supplies a pointer to an input string buffer.
            //     r9w - Supplies the length of the input string bufffer.
            //

        case BREAKPOINT_PROMPT:
            ContextRecord->Rax = KdpPrompt((PCHAR)ContextRecord->Rcx,
                                           (USHORT)ContextRecord->Rdx,
                                           (PCHAR)ContextRecord->R8,
                                           (USHORT)ContextRecord->R9,
                                           PreviousMode,
                                           TrapFrame,
                                           ExceptionFrame);

            Completion = TRUE;
            break;

            //
            // Load the symbolic information for an image.
            //
            // Arguments:
            //
            //    rcx - Supplies a pointer to a filename string descriptor.
            //    rdx - Supplies the base address of the image.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
            KdpSymbol((PSTRING)ContextRecord->Rcx,
                      (PKD_SYMBOLS_INFO)ContextRecord->Rdx,
                      UnloadSymbols,
                      PreviousMode,
                      ContextRecord,
                      TrapFrame,
                      ExceptionFrame);

            Completion = TRUE;
            break;

        case BREAKPOINT_COMMAND_STRING:
            KdpCommandString((PSTRING)ContextRecord->Rcx,
                             (PSTRING)ContextRecord->Rdx,
                             PreviousMode,
                             ContextRecord,
                             TrapFrame,
                             ExceptionFrame);
            Completion = TRUE;
            break;
            
            //
            //  Unknown command
            //

        default:
            break;
        }

        //
        // If the kernel debugger did not update RIP, then increment
        // past the breakpoint instruction.
        //

        if (ContextRecord->Rip == OldRip) {
            ContextRecord->Rip += 1;
        }

    } else {

        //
        // Report state change to the kernel debugger.
        //

        Completion = KdpReport(TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               ContextRecord,
                               PreviousMode,
                               SecondChance);

    }

    return Completion;
}

BOOLEAN
KdIsThisAKdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine is called whenever a user mode exception occurs and
    it might be a kernel debugger exception (e.g., DbgPrint/DbgPrompt).

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

Return Value:

    A value of TRUE is returned if this is for the kernel debugger.
    Otherwise, a value of FALSE is returned.

--*/

{

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {
        return TRUE;

    } else {
        return FALSE;
    }
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints in a checked system when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    //
    // If the breakpoint is a debug print or load/unload symbols, then return
    // TRUE. Otherwise, return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {
        ContextRecord->Rip += 1;
        return TRUE;

    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\print.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the common code to filter and print debug
    messages.

Author:

    David N. Cutler (davec) 12-Jan-2000

Revision History:

--*/

#include "kdp.h"
#pragma hdrstop
#include <malloc.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpPrint)
#pragma alloc_text(PAGEKD, KdpPrompt)
#pragma alloc_text(PAGEKD, KdpSymbol)
#pragma alloc_text(PAGEKD, KdpCommandString)
#endif // ALLOC_PRAGMA

#if 0
ULONG gLdrHits;
#endif

NTSTATUS
KdpPrint(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Message,
    IN USHORT Length,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    OUT PBOOLEAN Completion
    )

/*++

Routine Description:

    This function filters debug print requests, probes and saves user mode
    message buffers on the stack, logs the print message, and prints the
    message on the debug terminal if apprpriate.

Arguments:

    ComponentId - Supplies the component id of the component that issued
        the debug print.

    Level - Supplies the debug filer level number or mask.

    Message - Supplies a pointer to the output message.

    Length - Supplies the length of the output message.

    PreviousMode - Supplies the previous processor mode.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

    Completion - Supplies a pointer to the variable that receives the
        debug print completion status.

Return Value:

    STATUS_SUCCESS - Is returned if the debug print is filtered or is
        successfully printed.

    STATUS_BREAKPOINT - Is returned if ...

    STATUS_DEVICE_NOT_CONNECTED - Is returned if the kernel debugger is
        not enabled and the debug print message was not filtered.

    STATUS_ACCESS_VIOLATION - Is returned if an access violation occurs
        while attempting to copy a user mode buffer to the kernel stack.

--*/

{

    PCHAR Buffer;
    BOOLEAN Enable;
    ULONG Mask;
    STRING Output;
    NTSTATUS Status;

    //
    // If the the component id if out of range or output is enabled for the
    // specified filter level, then attempt to print the output. Otherwise,
    // immediately return success.
    //

    *Completion = FALSE;
    if (Level > 31) {
        Mask = Level;

    } else {
        Mask = 1 << Level;
    }

    if (((Mask & Kd_WIN2000_Mask) == 0) &&
        (ComponentId < KdComponentTableSize) &&
        ((Mask & *KdComponentTable[ComponentId]) == 0)) {
        Status = STATUS_SUCCESS;

    } else {

        //
        // Limit the message length to 512 bytes.
        //

        if (Length > 512) {
            Length = 512;
        }

        //
        // If the previous mode is user, then probe and capture the
        // message buffer on the stack.
        //

        if (PreviousMode != KernelMode) {
            try {
                ProbeForRead(Message, Length, sizeof(UCHAR));
                Buffer = alloca(512);
                KdpQuickMoveMemory(Buffer, Message, Length);
                Message = Buffer;

            } except (EXCEPTION_EXECUTE_HANDLER) {
                return STATUS_ACCESS_VIOLATION;
            }
        }

        //
        // Log debug output in circular buffer and print output
        // if debugger is enabled.
        //

        Output.Buffer = Message;
        Output.Length = Length;
        KdLogDbgPrint(&Output);
        if (KdDebuggerNotPresent == FALSE) {
            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
            if (KdpPrintString(&Output)) {
                Status = STATUS_BREAKPOINT;

            } else {
                Status = STATUS_SUCCESS;
            }

            KdExitDebugger(Enable);

        } else {
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    *Completion = TRUE;
    return Status;
}

USHORT
KdpPrompt(
    IN PCHAR Message,
    IN USHORT MessageLength,
    IN OUT PCHAR Reply,
    IN USHORT ReplyLength,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function filters debug print requests, probes and saves user mode
    message buffers on the stack, logs the print message, and prints the
    message on the debug terminal if apprpriate.

Arguments:

    Message - Supplies a pointer to the output message.

    MessageLength - Supplies the length of the output message.

    Reply - Supplies a pointer to the input buffer.

    ReplyLength - Supplies the length of the output message.

    PreviousMode - Supplies the previous processor mode.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

Return Value:

    The length of the input message is returned as the function value.

--*/

{

    PCHAR Buffer;
    BOOLEAN Enable;
    STRING Input;
    STRING Output;

    //
    // Limit the output and input message length to 512 bytes.
    //

    if (MessageLength > 512) {
        MessageLength = 512;
    }

    if (ReplyLength > 512) {
        ReplyLength = 512;
    }

    //
    // If the previous mode is user, then probe and capture the
    // message buffer on the stack.
    //

    if (PreviousMode != KernelMode) {
        try {
            ProbeForRead(Message, MessageLength, sizeof(UCHAR));
            Buffer = alloca(512);
            KdpQuickMoveMemory(Buffer, Message, MessageLength);
            Message = Buffer;
            ProbeForWrite(Reply, ReplyLength, sizeof(UCHAR));
            Buffer = alloca(512);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return 0;
        }

    } else {
        Buffer = Reply;
    }

    Input.Buffer = Buffer;
    Input.Length = 0;
    Input.MaximumLength = ReplyLength;
    Output.Buffer = Message;
    Output.Length = MessageLength;

    //
    // Log debug output in circular buffer and print the prompt message.
    //

    KdLogDbgPrint(&Output);
    Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
    do {
    } while (KdpPromptString(&Output, &Input) == TRUE);

    KdExitDebugger(Enable);

    //
    // If the previous mode was user, then copy the prompt input to the
    // reply buffer.
    //

    if (PreviousMode == UserMode) {
        try {
            KdpQuickMoveMemory(Reply, Input.Buffer, Input.Length);

        } except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Input.Length;
}

BOOLEAN
KdpReport(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This function reports an exception to the host kernel debugger.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the exception.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    The disposition of whether the exception was handled (TRUE) or not is
    returned as the function value.

--*/

{

    BOOLEAN Completion;
    BOOLEAN Enable;
    PKPRCB Prcb;

    //
    // If the exception code is a breakpoint or single step, or stop
    // on exeception is set, or this is the second change to handle
    // the exception, then attempt to enter the kernel debugger.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
        (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)  ||
        ((NtGlobalFlag & FLG_STOP_ON_EXCEPTION) != 0) ||
        (SecondChance != FALSE)) {

        //
        // If this is the first chance to handle the exception and the
        // exception code is either a port disconnected or success code,
        // then do not enter the kernel debugger.
        //

        if ((SecondChance == FALSE) &&
            ((ExceptionRecord->ExceptionCode == STATUS_PORT_DISCONNECTED) ||
            (NT_SUCCESS(ExceptionRecord->ExceptionCode)))) {

            //
            // This exception should not be reported to the kernel debugger.
            //

            return FALSE;
        }

        //
        // Debugging help:
        //
        // For user mode breakpoints going to the kernel debugger,
        // try to get the user mode module list and image headers
        // paged in before we call the debugger.  Walk the list twice
        // in case paging in some modules pages out some
        // previously paged in data.
        //
#if 0
        if (PreviousMode == UserMode)
        {
            PPEB Peb = PsGetCurrentProcess()->Peb;
            PPEB_LDR_DATA Ldr;
            PLIST_ENTRY LdrHead, LdrNext;
            PLDR_DATA_TABLE_ENTRY LdrEntry;
            UCHAR DataHeader;
            ULONG i,j;

            try {

                Ldr = Peb->Ldr;

                LdrHead = &Ldr->InLoadOrderModuleList;

                ProbeForRead (LdrHead, sizeof (LIST_ENTRY), sizeof (UCHAR));

                for (j=0; j<2; j++) {

                    for (LdrNext = LdrHead->Flink, i = 0;
                         LdrNext != LdrHead && i < 500;
                         LdrNext = LdrNext->Flink, i++) {

                    // BUGBUG
                    gLdrHits++;

                        LdrEntry = CONTAINING_RECORD (LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
                        ProbeForRead (LdrEntry, sizeof (LDR_DATA_TABLE_ENTRY), sizeof (UCHAR));

                        DataHeader = ProbeAndReadUchar((PUCHAR)LdrEntry->DllBase);
                    }
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
            }
        }
#endif
        //
        // Report state change to the host kernel debugger.
        //

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        Completion =
            KdpReportExceptionStateChange(ExceptionRecord,
                                          &Prcb->ProcessorState.ContextFrame,
                                          SecondChance);

        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);
        KdExitDebugger(Enable);
        KdpControlCPressed = FALSE;
        return Completion;

    } else {

        //
        // This exception should not be reported to the kernel debugger.
        //

        return FALSE;
    }
}

VOID
KdpSymbol(
    IN PSTRING String,
    IN PKD_SYMBOLS_INFO Symbol,
    IN BOOLEAN Unload,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function loads or unloads debug symbols.

Arguments:

    String - Supplies a pointer to a string descriptor.

    Symbol - Supplies a pointer to the symbol information.

    Unload - Supplies a boolean value that determines whether the symbols
        are being unloaded (TRUE) or loaded (FALSE).

    PreviousMode - Supplies the previous processor mode.

    ContextRecord - Supplies a pointer to a context record.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to a exception.

Return Value:

    None.

--*/

{

    BOOLEAN Enable;
    PKPRCB Prcb;

    //
    // If the previous mode is kernel and the kernel debugger is present,
    // then load or unload symbols.
    //

    if ((PreviousMode == KernelMode) &&
        (KdDebuggerNotPresent == FALSE)) {

        //
        // Save and restore the processor context in case the
        // kernel debugger has been configured to stop on dll
        // loads.
        //

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        KdpReportLoadSymbolsStateChange(String,
                                        Symbol,
                                        Unload,
                                        &Prcb->ProcessorState.ContextFrame);
        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);
        KdExitDebugger(Enable);
    }

    return;
}

VOID
KdpCommandString(
    IN PSTRING Name,
    IN PSTRING Command,
    IN KPROCESSOR_MODE PreviousMode,
    IN PCONTEXT ContextRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function reports an exception to the host kernel debugger.

Arguments:

    Name - Identification of the originator of the command.

    Command - Command string.
    
    PreviousMode - Supplies the previous processor mode.

    ContextRecord - Supplies a pointer to a context record.

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the exception.

Return Value:

    None.

--*/

{
    //
    // Report state change to the host kernel debugger.
    //

    if ((PreviousMode == KernelMode) &&
        (KdDebuggerNotPresent == FALSE)) {

        BOOLEAN Enable;
        PKPRCB Prcb;

        Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

        Prcb = KeGetCurrentPrcb();
        KiSaveProcessorControlState(&Prcb->ProcessorState);
        KdpQuickMoveMemory((PCHAR)&Prcb->ProcessorState.ContextFrame,
                           (PCHAR)ContextRecord,
                           sizeof(CONTEXT));

        KdpReportCommandStringStateChange(Name, Command,
                                          &Prcb->ProcessorState.ContextFrame);
        
        KdpQuickMoveMemory((PCHAR)ContextRecord,
                           (PCHAR)&Prcb->ProcessorState.ContextFrame,
                           sizeof(CONTEXT));

        KiRestoreProcessorControlState(&Prcb->ProcessorState);
        KdExitDebugger(Enable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\ia64\kdcmsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    The module implements code to poll for a kernel debugger breakin attempt.

Author:

    Bryan M. Willman (bryanwi) 19-Jan-92

Revision History:

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function returns the current value of the system performance
    counter.

Arguments:

    None.

Return Value:

    The value returned by KeQueryPerformanceCounter is returned as the
    function value.

--*/

{

    return KeQueryPerformanceCounter(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\i386\kdtrap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 25-Sep-90

Revision History:

--*/

#include "kdp.h"

#pragma alloc_text(PAGEKD, KdpTrap)
#pragma alloc_text(PAGEKD, KdIsThisAKdTrap)

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN UnloadSymbols = FALSE;
    ULONG   OldEip;

    //
    // Print, Prompt, Load symbols, Unload symbols, are all special
    // cases of STATUS_BREAKPOINT
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // Switch on the breakpoint code.
        //

        OldEip = ContextRecord->Eip;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            //  ExceptionInformation[1] - Address of the message.
            //  ExceptionInformation[2] - Length of the message.
            //  ContextRecord->Ebx - the Id of the calling component.
            //  ContextRecord->Edi - the output importance level.
            //

        case BREAKPOINT_PRINT:
            ContextRecord->Eax = KdpPrint((ULONG)ContextRecord->Ebx,
                                          (ULONG)ContextRecord->Edi,
                                          (PCHAR)ExceptionRecord->ExceptionInformation[1],
                                          (USHORT)ExceptionRecord->ExceptionInformation[2],
                                          PreviousMode,
                                          TrapFrame,
                                          ExceptionFrame,
                                          &Completion);

            break;

            //
            //  ExceptionInformation[1] - Address of the message.
            //  ExceptionInformation[2] - Length of the message.
            //  ContextRecord->Ebx - Address of the reply.
            //  ContextRecord->Edi - Maximum length of reply.
            //

        case BREAKPOINT_PROMPT:
            ContextRecord->Eax = KdpPrompt((PCHAR)ExceptionRecord->ExceptionInformation[1],
                                           (USHORT)ExceptionRecord->ExceptionInformation[2],
                                           (PCHAR)ContextRecord->Ebx,
                                           (USHORT)ContextRecord->Edi,
                                           PreviousMode,
                                           TrapFrame,
                                           ExceptionFrame);

            Completion = TRUE;
            break;

            //
            //  ExceptionInformation[1] is file name of new module.
            //  ExceptionInformation[2] is a pointer to the symbol
            //      information.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
            KdpSymbol((PSTRING)ExceptionRecord->ExceptionInformation[1],
                      (PKD_SYMBOLS_INFO)ExceptionRecord->ExceptionInformation[2],
                      UnloadSymbols,
                      PreviousMode,
                      ContextRecord,
                      TrapFrame,
                      ExceptionFrame);

            Completion = TRUE;
            break;

        case BREAKPOINT_COMMAND_STRING:
            KdpCommandString((PSTRING)ExceptionRecord->ExceptionInformation[1],
                             (PSTRING)ExceptionRecord->ExceptionInformation[2],
                             PreviousMode,
                             ContextRecord,
                             TrapFrame,
                             ExceptionFrame);
            Completion = TRUE;
            break;
            
            //
            //  Unknown command
            //

        default:
            // return FALSE
            break;
        }

        //
        // If the kernel debugger did not update the EIP, then increment
        // past the breakpoint instruction.
        //

        if (ContextRecord->Eip == OldEip) {
            ContextRecord->Eip++;
        }

    } else {

        //
        // Report state change to the kernel debugger.
        //

        Completion = KdpReport(TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               ContextRecord,
                               PreviousMode,
                               SecondChance);

    }

    return Completion;
}

BOOLEAN
KdIsThisAKdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine is called whenever a user-mode exception occurs and
    it might be a kernel debugger exception (Like DbgPrint/DbgPrompt ).

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

Return Value:

    A value of TRUE is returned if this is for the kernel debugger.
    Otherwise, a value of FALSE is returned.

--*/

{
    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints in a checked system when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    //
    // If the breakpoint is a debug print, then return TRUE. Otherwise,
    // return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {
        ContextRecord->Eip++;
        return TRUE;

    } else if (KdPitchDebugger == TRUE) {
        return FALSE;

    } else {
        return KdpCheckTracePoint(ExceptionRecord, ContextRecord);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\ia64\kdcpuapi.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Chuck Bauman 14-Aug-1993

Revision History:

    Based on Mark Lucovsky (markl) MIPS version 04-Sep-1990

--*/

#include "kdp.h"
#define END_OF_CONTROL_SPACE    (sizeof(KPROCESSOR_STATE))

ULONG64
KiReadMsr(
   IN ULONG Msr
   );

VOID
KiWriteMsr(
   IN ULONG Msr,
   IN ULONG64 Value
   );

VOID
KdpSetContextState (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record with context information.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    // No CPU specific work necessary.
}

VOID
KdpSetStateChange (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    // No CPU specific work necessary.
}

VOID
KdpGetStateChange (
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from Manipulate_State message

    N.B. This is a noop for MIPS.

Arguments:

    ManipulateState - supplies pointer to Manipulate_State packet

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) == TRUE) {

        //
        // If NT_SUCCESS returns TRUE, then the debugger is doing a
        // continue, and it makes sense to apply control changes.
        // Otherwise the debugger is saying that it doesn't know what
        // to do with this exception, so control values are ignored.
        //


        //
        // Clear .ss (bit 40 - single step) and .tb (bit 26 - taken branch) flags here
        //
        {
            PPSR ContextIPSR = (PPSR)&ContextRecord->StIPSR;

            ContextIPSR->sb.psr_ss =
                ((ManipulateState->u.Continue2.ControlSet.Continue &
                IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_INSTRUCTION) != 0);

            ContextIPSR->sb.psr_tb =
                ((ManipulateState->u.Continue2.ControlSet.Continue &
                IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_TAKEN_BRANCH) != 0);
        }

    
        //
        // Set KernelDebugActive if hardware debug registers are in use
        //
        {
            UCHAR KernelDebugActive = 
                ContextRecord->DbI1 || ContextRecord->DbI3 || 
                ContextRecord->DbI5 || ContextRecord->DbI7 ||
                ContextRecord->DbD1 || ContextRecord->DbD3 || 
                ContextRecord->DbD5 || ContextRecord->DbD7;

            USHORT Proc;
            for (Proc = 0; Proc < KeNumberProcessors; ++Proc) {
                PKPCR Pcr = (PKPCR)(KSEG3_BASE + 
                                    (KiProcessorBlock[Proc]->PcrPage << 
                                     PAGE_SHIFT));
                Pcr->KernelDebugActive = KernelDebugActive;
            }
        }
    }
}

NTSTATUS
KdpSysReadControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads implementation specific system data.

Arguments:

    Processor - Processor's information to access.

    Address - Offset in control space.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    ULONG Length;
    PVOID Pointer;
    PVOID Data;

    if (Processor >= (ULONG)KeNumberProcessors) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Case on address to determine what part of Control space is being read.
    //

    switch ( Address ) {

        //
        // Return the pcr address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PCR:

        Pointer = (PKPCR)(KSEG3_BASE + (KiProcessorBlock[Processor]->PcrPage << PAGE_SHIFT));
        Data = &Pointer;
        Length = sizeof(Pointer);
        break;

        //
        // Return the prcb address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PRCB:

        Pointer = KiProcessorBlock[Processor];
        Data = &Pointer;
        Length = sizeof(Pointer);
        break;

        //
        // Return the pointer to the current thread address for the
        // current processor.
        //

    case DEBUG_CONTROL_SPACE_THREAD:

        Pointer = KiProcessorBlock[Processor]->CurrentThread;
        Data = &Pointer;
        Length = sizeof(Pointer);
        break;

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        Data = &(KiProcessorBlock[Processor]->ProcessorState.SpecialRegisters);
        Length = sizeof( KSPECIAL_REGISTERS );
        break;

    default:

        *Actual = 0;
        return STATUS_UNSUCCESSFUL;

    }

    if (Length > Request) {
        Length = Request;
    }
    return KdpCopyToPtr(Buffer, Data, Length, Actual);
}

NTSTATUS
KdpSysWriteControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes implementation specific system data.

Arguments:

    Processor - Processor's information to access.

    Address - Offset in control space.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    ULONG Length;

    if (Processor >= (ULONG)KeNumberProcessors) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }

    switch ( Address ) {

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        if (Request > sizeof(KSPECIAL_REGISTERS)) {
            Length = sizeof(KSPECIAL_REGISTERS);
        } else {
            Length = Request;
        }
        return KdpCopyFromPtr(&KiProcessorBlock[Processor]->ProcessorState.SpecialRegisters,
                              Buffer,
                              Length,
                              Actual);

    default:
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    PUCHAR b;
    PUSHORT s;
    PULONG l;
    NTSTATUS Status;

    *Actual = 0;

    if (InterfaceType != Isa || BusNumber != 0 || AddressSpace != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch ( Request ) {
        case 1:
            *(PUCHAR)Buffer = READ_PORT_UCHAR((PUCHAR)(ULONG_PTR)Address);
            *Actual = 1;
            break;
        case 2:
            if ( Address & 1 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                *(PUSHORT)Buffer =
                    READ_PORT_USHORT((PUSHORT)(ULONG_PTR)Address);
                *Actual = 2;
            }
            break;
        case 4:
            if ( Address & 3 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                *(PULONG)Buffer =
                    READ_PORT_ULONG((PULONG)(ULONG_PTR)Address);
                *Actual = 4;
            }
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    PUCHAR b;
    PUSHORT s;
    PULONG l;
    HARDWARE_PTE Opaque;
    NTSTATUS Status;
    ULONG Value;

    *Actual = 0;

    if (InterfaceType != Isa || BusNumber != 0 || AddressSpace != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check Size and Alignment
    //

    switch ( Request ) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)Address,
                             *(PUCHAR)Buffer);
            *Actual = 1;
            break;
        case 2:
            if ( Address & 1 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                WRITE_PORT_USHORT((PUSHORT)(ULONG_PTR)Address,
                                  *(PUSHORT)Buffer);
                *Actual = 2;
            }
            break;
        case 4:
            if ( Address & 3 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                WRITE_PORT_ULONG((PULONG)(ULONG_PTR)Address,
                                 *(PULONG)Buffer);
                *Actual = 4;
            }
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Reads an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        *Data = KiReadMsr(Msr);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        *Data = 0;
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Writes an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        KiWriteMsr(Msr, *Data);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\paemp\makefile.inc ===
#
#  Currently the MP and UP files are the same.
#
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\pae\makefile.inc ===
#
#  Currently the MP and UP files are the same.
#
!INCLUDE ..\up\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\i386\kdcpuapi.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

    24-sep-90   bryanwi

        Port to the x86.

--*/

#include <stdio.h>

#include "kdp.h"
#define END_OF_CONTROL_SPACE

extern ULONG KdpCurrentSymbolStart, KdpCurrentSymbolEnd;
extern ULONG KdSpecialCalls[];
extern ULONG KdNumberOfSpecialCalls;

LONG
KdpLevelChange (
    ULONG Pc,
    PCONTEXT ContextRecord,
    PBOOLEAN SpecialCall
    );

LONG
regValue(
    UCHAR reg,
    PCONTEXT ContextRecord
    );

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR ModRM
    );

ULONG
KdpGetReturnAddress (
    PCONTEXT ContextRecord
    );

ULONG
KdpGetCallNextOffset (
    ULONG Pc,
    PCONTEXT ContextRecord
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpLevelChange)
#pragma alloc_text(PAGEKD, regValue)
#pragma alloc_text(PAGEKD, KdpIsSpecialCall)
#pragma alloc_text(PAGEKD, KdpGetReturnAddress)
#pragma alloc_text(PAGEKD, KdpSetContextState)
#pragma alloc_text(PAGEKD, KdpSetStateChange)
#pragma alloc_text(PAGEKD, KdpGetStateChange)
#pragma alloc_text(PAGEKD, KdpSysReadControlSpace)
#pragma alloc_text(PAGEKD, KdpSysWriteControlSpace)
#pragma alloc_text(PAGEKD, KdpSysReadIoSpace)
#pragma alloc_text(PAGEKD, KdpSysWriteIoSpace)
#pragma alloc_text(PAGEKD, KdpSysReadMsr)
#pragma alloc_text(PAGEKD, KdpSysWriteMsr)
#pragma alloc_text(PAGEKD, KdpGetCallNextOffset)
#endif

/**** KdpIsTryFinallyReturn - detect finally optimization
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*
*  Output:
*       returns TRUE if this is a try-finally returning to the same
*       scope
***************************************************************************/


BOOLEAN
KdpIsTryFinallyReturn (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;
    ULONG calldisp;
    UCHAR inst;

    //
    //  The complier generates code for a try-finally that involves having
    //  a ret instruction that does not match with a call instruction.
    //  This ret never returns a value (ie, it's a c3 return and not a
    //  c2).  It always returns into the current symbol scope.  It is never
    //  preceeded by a leave, which (hopefully) should differentiate it
    //  from recursive returns.  Check for this, and if we find it count
    //  it as *0* level change.
    //
    //  As an optimization, the compiler will often change:
    //      CALL
    //      RET
    //  into:
    //      JMP
    //  In either case, we figure out the return address.  It's the first 4 bytes
    //  on the stack.
    //

    if (!NT_SUCCESS(KdpCopyFromPtr(&retaddr, ContextRecord->Esp, 4, NULL))) {
        return FALSE;
    }

//  DPRINT(( "Start %x return %x end %x\n", KdpCurrentSymbolStart, retaddr, KdpCurrentSymbolEnd ));

    if ( (KdpCurrentSymbolStart < retaddr) && (retaddr < KdpCurrentSymbolEnd) ) {

        //
        //  Well, things aren't this nice.  We may have transferred but not yet
        //  updated the start/end.  This case occurs in a call to a thunk.  We
        //  look to see if the instruction before the return address is a call.
        //  Gross and not 100% reliable.
        //

        if (!NT_SUCCESS(KdpCopyFromPtr(&inst, (PCHAR)retaddr - 5, 1, NULL))) {
            return FALSE;
        }
        if (!NT_SUCCESS(KdpCopyFromPtr(&calldisp, (PCHAR)retaddr - 4, 4, NULL))) {
            return FALSE;
        }

        if (inst == 0xe8 && calldisp + retaddr == Pc) {
//  DPRINT(( "call to thunk @ %x\n", Pc ));
            return FALSE;
        }

        //
        //  returning to the current function.  Either a finally
        //  or a recursive return.  Check for a leave.  This is not 100%
        //  reliable since we are betting on an instruction longer than a byte
        //  and not ending with 0xc9.
        //

        if (!NT_SUCCESS(KdpCopyFromPtr(&inst, (PCHAR)Pc - 1, 1, NULL))) {
            return FALSE;
        }

        if ( inst != 0xc9 ) {
            // not a leave.  Assume a try-finally.
//  DPRINT(( "transfer at %x is try-finally\n", Pc ));
            return TRUE;
        }
    }

    //
    //  This appears to be a true RET instruction
    //

    return FALSE;
}

/**** KdpLevelChange - say how the instruction affects the call level
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*       SpecialCall - pointer to returned boolean indicating if the
*           instruction is a transfer to a special routine
*
*  Output:
*       returns -1 for a level pop, 1 for a push and 0 if it is
*       unchanged.
*  NOTE: This function belongs in some other file.  I should move it.
***************************************************************************/


LONG
KdpLevelChange (
    ULONG Pc,
    PCONTEXT ContextRecord,
    PBOOLEAN SpecialCall
    )
{
    UCHAR membuf[2];
    ULONG Addr;

    membuf[0] = 0xcc;
    membuf[1] = 0xcc;
    KdpCopyFromPtr(membuf, Pc, 2, NULL);

    switch (membuf[0]) {
    case 0xe8:  //  CALL direct w/32 bit displacement
        //
        //  For try/finally, the compiler may, in addition to the push/ret trick
        //  below, use a call to the finally thunk.  Since we treat a RET to
        //  within the same symbol scope as not changing levels, we will also
        //  treat such a call as not changing levels either
        //

        if (!NT_SUCCESS(KdpCopyFromPtr(&Addr, (PCHAR)Pc + 1, 4, NULL))) {
            Addr = 0;
        } else {
            Addr += Pc + 5;
        }

        if ((KdpCurrentSymbolStart <= Addr) && (Addr < KdpCurrentSymbolEnd)) {
            *SpecialCall = FALSE;
            return 0;
        }


    case 0x9a:  //  CALL segmented 16:32

        *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
        return 1;

    case 0xff:
        //
        //  This is a compound instruction.  Dispatch on operation
        //
        switch (membuf[1] & 0x38) {
        case 0x10:  //  CALL with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
            return 1;
        case 0x20:  //  JMP with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );

            //
            //  If this is a try/finally, we'd like to treat it as call since the
            //  return inside the destination will bring us back to this context.
            //  However, if it is a jmp to a special routine, we must treat it
            //  as a no-level change operation since we won't see the special
            //  routines's return.
            //
            //  If it is not a try/finally, we'd like to treat it as a no-level
            //  change, unless again, it is a transfer to a special call which
            //  views this as a level up.
            //

            if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
                if (*SpecialCall) {
                    //
                    //  We won't see the return, so pretend it is just
                    //  inline code
                    //

                    return 0;

                } else {
                    //
                    //  The destinations return will bring us back to this
                    //  context
                    //

                    return 1;
                }
            } else if (*SpecialCall) {
                //
                //  We won't see the return but we are, indeed, doing one.
                //
                return -1;
            } else {
                return 0;
            }

        default:
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc3:  //  RET

        //
        //  If we are a try/finally ret, then we indicate that it is NOT a level
        //  change
        //

        if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc2:  //  RET  w/16 bit esp change
    case 0xca:  //  RETF w/16 bit esp change
    case 0xcb:  //  RETF
        *SpecialCall = FALSE;
        return -1;

    default:
        *SpecialCall = FALSE;
        return 0;
    }

} // KdpLevelChange

LONG
regValue(
    UCHAR reg,
    PCONTEXT ContextRecord
    )
{
    switch (reg) {
    case 0x0:
        return(ContextRecord->Eax);
        break;
    case 0x1:
        return(ContextRecord->Ecx);
        break;
    case 0x2:
        return(ContextRecord->Edx);
        break;
    case 0x3:
        return(ContextRecord->Ebx);
        break;
    case 0x4:
        return(ContextRecord->Esp);
        break;
    case 0x5:
        return(ContextRecord->Ebp);
        break;
    case 0x6:
        return(ContextRecord->Esi);
        break;
    case 0x7:
        return(ContextRecord->Edi);
        break;
    }
    return 0;
}

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR modRM
    )

/*++

Routine Description:

    Check to see if the instruction at pc is a call to one of the
    SpecialCall routines.

Argument:

    Pc - program counter of instruction in question.

--*/
{
    UCHAR sib;
    USHORT twoBytes;
    ULONG callAddr;
    ULONG addrAddr;
    LONG offset;
    ULONG i;
    char d8;

    if ( opcode == 0xe8 ) {

        //
        // Signed offset from pc
        //

        if (!NT_SUCCESS(KdpCopyFromPtr(&offset, (PCHAR)Pc + 1, 4, NULL))) {
            callAddr = 0;
        } else {
            callAddr = Pc + offset + 5; // +5 for instr len.
        }

    } else if ( opcode == 0xff ) {

        if ( ((modRM & 0x38) != 0x10) && ((modRM & 0x38) != 0x20) ) {
            // not call or jump
            return FALSE;
        }
        if ( (modRM & 0x08) == 0x08 ) {
            // m16:16 or m16:32 -- we don't handle this
            return FALSE;
        }

        if ( (modRM & 0xc0) == 0xc0 ) {

            /* Direct register addressing */
            callAddr = regValue( (UCHAR)(modRM&0x7), ContextRecord );

        } else if ( (modRM & 0xc7) == 0x05 ) {
            //
            // Calls across dll boundaries involve a call into a jump table,
            // wherein the jump address is set to the real called routine at DLL
            // load time.  Check to see if we're calling such an instruction,
            // and if so, compute its target address and set callAddr there.
            //
            //  ff15 or ff25 -- call or jump indirect with disp32.  Get
            //  address of address
            //
            if (!NT_SUCCESS(KdpCopyFromPtr(&addrAddr, (PCHAR)Pc + 2, 4, NULL))) {
                callAddr = 0;
            } else {
                //
                //  Get real destination address
                //
                if (!NT_SUCCESS(KdpCopyFromPtr(&callAddr, addrAddr, 4, NULL))) {
                    callAddr = 0;
                }
            }
//  DPRINT(( "Indirect call/jmp @ %x\n", Pc ));
        } else if ( (modRM & 0x7) == 0x4 ) {

            LONG indexValue;

            /* sib byte present */
            if (!NT_SUCCESS(KdpCopyFromPtr(&sib, (PCHAR)Pc + 2, 1, NULL))) {
                sib = 0;
            }
            indexValue = regValue( (UCHAR)((sib & 0x31) >> 3), ContextRecord );
            switch ( sib&0xc0 ) {
            case 0x0:  /* x1 */
                break;
            case 0x40:
                indexValue *= 2;
                break;
            case 0x80:
                indexValue *= 4;
                break;
            case 0xc0:
                indexValue *= 8;
                break;
            } /* switch */

            switch ( modRM & 0xc0 ) {

            case 0x0: /* no displacement */
                if ( (sib & 0x7) == 0x5 ) {
//                  DPRINT(("funny call #1 at %x\n", Pc));
                    return FALSE;
                }
                callAddr = indexValue + regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x40:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #2\n")); /* calling into the stack */
                    return FALSE;
                }
                if (!NT_SUCCESS(KdpCopyFromPtr( &d8, (PCHAR)Pc + 3, 1, NULL))) {
                    d8 = 0;
                }
                callAddr = indexValue + d8 +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x80:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #3\n")); /* calling into the stack */
                    return FALSE;
                }
                if (!NT_SUCCESS(KdpCopyFromPtr(&offset, (PCHAR)Pc + 3, 4, NULL))) {
                    offset = 0;
                }
                callAddr = indexValue + offset +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0xc0:
                ASSERT( FALSE );
                break;

            }

        } else {
            //KdPrint(( "undecoded call at %x\n",
            //            CONTEXT_TO_PROGRAM_COUNTER(ContextRecord) ));
            return FALSE;
        }

    } else if ( opcode == 0x9a ) {

        /* Absolute address call (best I can tell, cc doesn't generate this) */
        if (!NT_SUCCESS(KdpCopyFromPtr( &callAddr, (PCHAR)Pc + 1, 4, NULL))) {
            callAddr = 0;
        }

    } else {
        return FALSE;
    }

    //
    // Calls across dll boundaries involve a call into a jump table,
    // wherein the jump address is set to the real called routine at DLL
    // load time.  Check to see if we're calling such an instruction,
    // and if so, compute its target address and set callAddr there.
    //

#if 0
    if (!NT_SUCCESS(KdpCopyFromPtr( &twoBytes, (PCHAR)callAddr, 2, NULL))) {
        twoBytes = 0;
    }
    if ( twoBytes == 0x25ff ) { /* i386 is little-Endian; really 0xff25 */

        //
        // This is a 'jmp dword ptr [mem]' instruction, which is the sort of
        // jump used for a dll-boundary crossing call.  Fixup callAddr.
        //

        if (!NT_SUCCESS(KdpCopyFromPtr( &addrAddr, (PCHAR)callAddr + 2, 4, NULL))) {
            callAddr = 0;
        } else if (!NT_SUCCESS(KdpCopyFromPtr( &callAddr, addrAddr, 4, NULL))) {
            callAddr = 0;
        }
    }
#endif

    for ( i = 0; i < KdNumberOfSpecialCalls; i++ ) {
        if ( KdSpecialCalls[i] == callAddr ) {
            return TRUE;
        }
    }
    return FALSE;

}

/*
 * Find the return address of the current function.  Only works when
 * locals haven't yet been pushed (ie, on the first instruction of the
 * function).
 */

ULONG
KdpGetReturnAddress (
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;

    if (!NT_SUCCESS(KdpCopyFromPtr(&retaddr, ContextRecord->Esp, 4, NULL))) {
        retaddr = 0;
    }
    return retaddr;

} // KdpGetReturnAddress

VOID
KdpSetContextState(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )
{
    PKPRCB Prcb;

    //
    //  Special registers for the x86
    //
    Prcb = KeGetCurrentPrcb();

    WaitStateChange->ControlReport.Dr6 =
        Prcb->ProcessorState.SpecialRegisters.KernelDr6;

    WaitStateChange->ControlReport.Dr7 =
        Prcb->ProcessorState.SpecialRegisters.KernelDr7;

    WaitStateChange->ControlReport.SegCs  = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs  = (USHORT)(ContextRecord->SegDs);
    WaitStateChange->ControlReport.SegEs  = (USHORT)(ContextRecord->SegEs);
    WaitStateChange->ControlReport.SegFs  = (USHORT)(ContextRecord->SegFs);
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;

    WaitStateChange->ControlReport.ReportFlags = X86_REPORT_INCLUDES_SEGS;

    // If the current code segment is a known flat code
    // segment let the debugger know so that it doesn't
    // have to retrieve the descriptor.
    if (ContextRecord->SegCs == KGDT_R0_CODE ||
        ContextRecord->SegCs == KGDT_R3_CODE + 3) {
        WaitStateChange->ControlReport.ReportFlags |= X86_REPORT_STANDARD_CS;
    }
}

VOID
KdpSetStateChange(
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    KdpSetContextState(WaitStateChange, ContextRecord);
}

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from Manipulate_State message

Arguments:

    ManipulateState - supplies pointer to Manipulate_State packet

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;
    ULONG  Processor;

    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) == TRUE) {

        //
        // If NT_SUCCESS returns TRUE, then the debugger is doing a
        // continue, and it makes sense to apply control changes.
        // Otherwise the debugger is saying that it doesn't know what
        // to do with this exception, so control values are ignored.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag == TRUE) {
            ContextRecord->EFlags |= 0x100L;

        } else {
            ContextRecord->EFlags &= ~0x100L;

        }

        for (Processor = 0; Processor < (ULONG)KeNumberProcessors; Processor++) {
            Prcb = KiProcessorBlock[Processor];

            Prcb->ProcessorState.SpecialRegisters.KernelDr7 =
                ManipulateState->u.Continue2.ControlSet.Dr7;

            Prcb->ProcessorState.SpecialRegisters.KernelDr6 = 0L;
        }
        if (ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart != 1) {
            KdpCurrentSymbolStart = ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart;
            KdpCurrentSymbolEnd = ManipulateState->u.Continue2.ControlSet.CurrentSymbolEnd;
        }
    }
}


NTSTATUS
KdpSysReadControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads implementation specific system data.

    IMPLEMENTATION NOTE:

        On the X86, control space is defined as follows:

            0:  Base of KPROCESSOR_STATE structure. (KPRCB.ProcessorState)
                    This includes CONTEXT record,
                    followed by a SPECIAL_REGISTERs record

Arguments:

    Processor - Processor's information to access.

    Address - Offset in control space.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    ULONG Length, t;
    PVOID StartAddr;
    NTSTATUS Status;

    Length = Request;
    
    if ((Address < sizeof(KPROCESSOR_STATE)) &&
        (Processor < (ULONG)KeNumberProcessors)) {
        t = (ULONG)(sizeof(KPROCESSOR_STATE)) - (ULONG)Address;
        if (t < Length) {
            Length = t;
        }
        StartAddr = (PVOID)
            ((ULONG)Address +
             (ULONG)&(KiProcessorBlock[Processor]->ProcessorState));
        Status = KdpCopyToPtr(Buffer,
                              StartAddr,
                              Length,
                              Actual);
    } else {
        Status = STATUS_UNSUCCESSFUL;
        *Actual = 0;
    }

    return Status;
}

NTSTATUS
KdpSysWriteControlSpace(
    ULONG Processor,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes implementation specific system data.

    Control space for x86 is as defined above.

Arguments:

    Processor - Processor's information to access.

    Address - Offset in control space.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    ULONG Length;
    PVOID StartAddr;
    NTSTATUS Status;

    if (((Address + Request) <= sizeof(KPROCESSOR_STATE)) &&
        (Processor < (ULONG)KeNumberProcessors)) {

        StartAddr = (PVOID)
            ((ULONG)Address +
             (ULONG)&(KiProcessorBlock[Processor]->ProcessorState));

        Status = KdpCopyFromPtr(StartAddr,
                                Buffer,
                                Request,
                                Actual);
    } else {
        Status = STATUS_UNSUCCESSFUL;
        *Actual = 0;
    }

    return Status;
}

NTSTATUS
KdpSysReadIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Reads system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if (InterfaceType != Isa || BusNumber != 0 || AddressSpace != 1) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Check Size and Alignment
    //

    switch ( Request ) {
        case 1:
            *(PUCHAR)Buffer = READ_PORT_UCHAR((PUCHAR)(ULONG_PTR)Address);
            *Actual = 1;
            break;
        case 2:
            if ( Address & 1 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                *(PUSHORT)Buffer =
                    READ_PORT_USHORT((PUSHORT)(ULONG_PTR)Address);
                *Actual = 2;
            }
            break;
        case 4:
            if ( Address & 3 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                *(PULONG)Buffer =
                    READ_PORT_ULONG((PULONG)(ULONG_PTR)Address);
                *Actual = 4;
            }
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysWriteIoSpace(
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber,
    ULONG AddressSpace,
    ULONG64 Address,
    PVOID Buffer,
    ULONG Request,
    PULONG Actual
    )

/*++

Routine Description:

    Writes system I/O locations.

Arguments:

    InterfaceType - I/O interface type.

    BusNumber - Bus number.

    AddressSpace - Address space.

    Address - I/O address.

    Buffer - Data buffer.

    Request - Amount of data to move.

    Actual - Amount of data actually moved.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    if (InterfaceType != Isa || BusNumber != 0 || AddressSpace != 1) {
        *Actual = 0;
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Check Size and Alignment
    //

    switch ( Request ) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)Address,
                             *(PUCHAR)Buffer);
            *Actual = 1;
            break;
        case 2:
            if ( Address & 1 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                WRITE_PORT_USHORT((PUSHORT)(ULONG_PTR)Address,
                                  *(PUSHORT)Buffer);
                *Actual = 2;
            }
            break;
        case 4:
            if ( Address & 3 ) {
                Status = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                WRITE_PORT_ULONG((PULONG)(ULONG_PTR)Address,
                                 *(PULONG)Buffer);
                *Actual = 4;
            }
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            *Actual = 0;
            break;
    }

    return Status;
}

NTSTATUS
KdpSysReadMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Reads an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    
    try {
        *Data = RDMSR(Msr);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        *Data = 0;
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}

NTSTATUS
KdpSysWriteMsr(
    ULONG Msr,
    PULONG64 Data
    )

/*++

Routine Description:

    Writes an MSR.

Arguments:

    Msr - MSR index.

    Data - Data buffer.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        WRMSR (Msr, *Data);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_NO_SUCH_DEVICE;
    }

    return Status;
}



/*** KdpGetCallNextOffset - compute "next" instruction on a call-like instruction
*
*   Purpose:
*       Compute how many bytes are in a call-type instruction
*       so that a breakpoint can be set upon this instruction's
*       return.  Treat indirect jmps as if they were call/ret/ret
*
*   Returns:
*       offset to "next" instruction, or 0 if it wasn't a call instruction.
*
*************************************************************************/

ULONG
KdpGetCallNextOffset (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    UCHAR membuf[2];
    UCHAR opcode;
    ULONG sib;
    ULONG disp;

    if (!NT_SUCCESS(KdpCopyFromPtr( membuf, Pc, 2, NULL ))) {
        return 0;
    }

    opcode = membuf[0];

    if ( opcode == 0xe8 ) {         //  CALL 32 bit disp
        return Pc+5;
    } else if ( opcode == 0x9a ) {  //  CALL 16:32
        return Pc+7;
    } else if ( opcode == 0xff ) {
        if ( membuf[1] == 0x25) {   //  JMP indirect
            return KdpGetReturnAddress( ContextRecord );
        }
        sib = ((membuf[1] & 0x07) == 0x04) ? 1 : 0;
        disp = (membuf[1] & 0xc0) >> 6;
        switch (disp) {
        case 0:
            if ( (membuf[1] & 0x07) == 0x05 ) {
                disp = 4; // disp32 alone
            } else {
                // disp = 0; // no displacement with reg or sib
            }
            break;
        case 1:
            // disp = 1; // disp8 with reg or sib
            break;
        case 2:
            disp = 4; // disp32 with reg or sib
            break;
        case 3:
            disp = 0; // direct register addressing (e.g., call esi)
            break;
        }
        return Pc + 2 + sib + disp;
    }

    return 0;

} // KdpGetCallNextOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\aligntrk.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1993, 1994  Digital Equipment Corporation

Module Name:

    aligntrk.c

Abstract:

    This module implements the code necessary to dispatch exceptions to the
    proper mode and invoke the exception dispatcher.

Author:

    David N. Cutler (davec) 3-Apr-1990

Environment:

    Kernel mode only.

Revision History:

    Thomas Van Baak (tvb) 12-May-1992

        Adapted for Alpha AXP.

    Forrest Foltz (forrestf) 30-Dec-1999

        Broke out increasingly complex and common alignment fault handling into
        this file.

--*/

#include "ki.h"

//
// EXINFO_EFFECTIVE_ADDRESS: slot number [0...4] for faulting address.
//

#if defined(_IA64_)
#define EXINFO_EFFECTIVE_ADDRESS 1
#else  // !_IA64_
#define EXINFO_EFFECTIVE_ADDRESS 2
#endif // !_IA64_

//
// Data misalignment exception (auto alignment fixup) control.
//
// If KiEnableAlignmentFaultExceptions is 0, then no alignment
// exceptions are raised and all misaligned user and kernel mode data
// references are emulated. This is consistent with NT/Alpha version
// 3.1 behavior.
//
// If KiEnableAlignmentFaultExceptions is 1, then the
// current thread automatic alignment fixup enable determines whether
// emulation is attempted in user mode. This is consistent with NT/Mips
// behavior.
//
// If KiEnableAlignmentFaultExceptions is 2, then the behavior depends
// on the execution mode at the time of the fault.  Kernel-mode code gets
// type 1 behaivor above (no fixup), user-mode code gets type 0 above
// (fixup).
//
// This last mode is temporary until we flush out the remaining user-mode
// alignment faults, at which point the option will be removed and the
// default value will be set to 1.
//
// N.B. This default value may be reset from the Registry during init.
//

ULONG KiEnableAlignmentFaultExceptions = 1;

#define IsWow64Process() (PsGetCurrentProcess()->Wow64Process != NULL)

#if DBG

//
// Globals to track the number of alignment exception fixups in both user and
// kernel.
//

ULONG KiKernelFixupCount = 0;
ULONG KiUserFixupCount = 0;

//
// Set KiBreakOnAlignmentFault to the desired combination of
// the following flags.
//

#define KE_ALIGNMENT_BREAK_USER   0x01
#define KE_ALIGNMENT_BREAK_KERNEL 0x02

ULONG KiBreakOnAlignmentFault = KE_ALIGNMENT_BREAK_USER;

__inline
BOOLEAN
KI_BREAK_ON_ALIGNMENT_FAULT(
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine description:

    Given that an alignment fault has been encountered, determines whether
    a debug break should occur based on the execution mode of the fault and
    flags in KiBreakOnAlignmentFault.

Arguments:

    PreviousMode - The execution mode at the time of the fault.

Return Value:

    TRUE if a debug break should occur, FALSE otherwise.

--*/

{
    if ((KiBreakOnAlignmentFault & KE_ALIGNMENT_BREAK_USER) != 0 &&
        PreviousMode == UserMode) {

        return TRUE;
    }

    if ((KiBreakOnAlignmentFault & KE_ALIGNMENT_BREAK_KERNEL) != 0 &&
        PreviousMode == KernelMode) {

        return TRUE;
    }

    return FALSE;
}

//
// Structures to track alignment fault locations on a global basis.  These
// are used in the checked kernel only, as an aid in finding and fixing
// alignment faults in the system.
//

#define MAX_IMAGE_NAME_CHARS 15
typedef struct _ALIGNMENT_FAULT_IMAGE *PALIGNMENT_FAULT_IMAGE;
typedef struct _ALIGNMENT_FAULT_LOCATION *PALIGNMENT_FAULT_LOCATION;

typedef struct _ALIGNMENT_FAULT_IMAGE {

    //
    // Head of singly-linked list of fault locations associated with this image
    //

    PALIGNMENT_FAULT_LOCATION LocationHead;

    //
    // Total number of alignment faults associated with this image.
    //

    ULONG   Count;

    //
    // Number of unique alignment fault locations found in this image
    //

    ULONG   Instances;

    //
    // Name of the image
    //

    CHAR    Name[ MAX_IMAGE_NAME_CHARS + 1 ];

} ALIGNMENT_FAULT_IMAGE;

BOOLEAN
KiNewGlobalAlignmentFault(
    IN  PVOID ProgramCounter,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PALIGNMENT_FAULT_IMAGE *AlignmentFaultImage
    );

#endif

NTSTATUS
KipRecordAlignmentException(
    IN  PVOID ProgramCounter,
    OUT PALIGNMENT_EXCEPTION_RECORD *ExceptionRecord
    );

PALIGNMENT_EXCEPTION_RECORD
KipFindAlignmentException(
    IN PVOID ProgramCounter
    );

PALIGNMENT_EXCEPTION_RECORD
KipAllocateAlignmentExceptionRecord( VOID );

BOOLEAN
KiHandleAlignmentFault(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance,
    OUT BOOLEAN *ExceptionForwarded
    )

/*++

Routine description:

    This routine deals with alignment exceptions as appropriate.  See comments
    at the beginning of this module.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean variable that specifies whether this
        is the first (TRUE) or second (FALSE) time that this exception has
        been processed.

    ExceptionForwarded - On return, indicates whether the exception had
        already been forwarded to a user-mode debugger.

Return Value:

    TRUE if the alignment exception was handled, FALSE otherwise.

--*/

{
    BOOLEAN AlignmentFaultHandled;
    BOOLEAN NewAlignmentFault;
    BOOLEAN EmulateAlignmentFault;
    BOOLEAN ExceptionWasForwarded;
    BOOLEAN AutoAlignment;
    NTSTATUS Status;
    PVOID ProgramCounter;
    PVOID EffectiveAddress;
#if DBG
    PALIGNMENT_FAULT_IMAGE FaultImage;
#endif

    //
    // Assume the fault was not handled and that the exception had not
    // been forwarded to a user-mode debugger.
    //

    AlignmentFaultHandled = FALSE;
    ExceptionWasForwarded = FALSE;

    if (FirstChance != FALSE) {

        //
        // This is the first chance for handling an exception... we haven't yet
        // searched for an exception handler.
        //

        EmulateAlignmentFault = FALSE;
        AutoAlignment = FALSE;
        ProgramCounter = (PVOID)ExceptionRecord->ExceptionAddress;

        //
        // Determine whether autoalignment is enabled for thread.  If a DPC or
        // an interrupt is being executed, then we are in an arbitrary thread
        // context.  Per-process and per-thread settings are ignored in this
        // case.
        //

        if (IsWow64Process() != FALSE) {

            //
            // For now, autoalignment is on (both user and kernel) for Wow64
            // processes.
            //

            AutoAlignment = TRUE;
        }

        if (PreviousMode == UserMode &&
            (KeGetCurrentThread()->AutoAlignment != FALSE ||
             KeGetCurrentThread()->ApcState.Process->AutoAlignment != FALSE)) {

            //
            // The fault occured in user mode, and the thread and/or process
            // has autoalignment turned on.
            // 

#if defined(_IA64_)

            //
            // On IA64 platform, reset psr.ac bit to disable alignment check
            //

            TrapFrame->StIPSR &= ~(ULONGLONG)(1ULL << PSR_AC);

#endif // defined(_IA64_)

            AutoAlignment = TRUE;
        }

        if (PreviousMode == UserMode &&
            PsGetCurrentProcess()->DebugPort != NULL &&
            AutoAlignment == FALSE) {

            BOOLEAN DebuggerHandledException;
            PALIGNMENT_EXCEPTION_RECORD AlignmentExceptionRecord;

            //
            // The alignment exception is in user mode, there is a debugger
            // attached, and autoalignment is not enabled for this thread.
            //
            // Determine whether this exception has already been observed
            // and, if so, whether we should break into the debugger.
            //

            Status = KipRecordAlignmentException( ProgramCounter,
                                                  &AlignmentExceptionRecord );
            if (!NT_SUCCESS(Status)) {
                AlignmentExceptionRecord = NULL;
            }

            if (AlignmentExceptionRecord != NULL &&
                AlignmentExceptionRecord->AutoFixup != FALSE) {

                //
                // The alignment exception record for this location
                // indicates that an automatic fixup should be applied
                // without notifying the debugger.  This is because
                // the user entered 'gh' at the debug prompt the last
                // time we reported this fault.
                //

                EmulateAlignmentFault = TRUE;

            } else {

                //
                // Forward the exception to the debugger.
                //

                ExceptionWasForwarded = TRUE;
                DebuggerHandledException =
                    DbgkForwardException( ExceptionRecord, TRUE, FALSE );

                if (DebuggerHandledException != FALSE) {

                    //
                    // The user continued with "gh", so fix up this and all
                    // subsequent alignment exceptions at this address.
                    //

                    EmulateAlignmentFault = TRUE;
                    if (AlignmentExceptionRecord != NULL) {
                        AlignmentExceptionRecord->AutoFixup = TRUE;
                    }
                }
            }

        } else if ((KiEnableAlignmentFaultExceptions == 0) ||

                   (AutoAlignment != FALSE) ||

                   (PreviousMode == UserMode &&
                    KiEnableAlignmentFaultExceptions == 2)) {

            //
            // Emulate the alignment if:
            //
            // KiEnableAlignmentFaultExceptions is 0, OR
            // this thread has enabled alignment fixups, OR
            // the current process is a WOW64 process, OR
            // KiEnableAlignmentFaultExceptions is 2 and the fault occured
            //     in usermode
            //

            EmulateAlignmentFault = TRUE;

        } else {

            //
            // We are not fixing up the alignment fault.
            // 

#if defined(_IA64_)

            //
            // On IA64 platform, set psr.ac bit to enable h/w alignment check
            //

            TrapFrame->StIPSR |= (1ULL << PSR_AC);

#endif // defined(_IA64_)
        }

#if DBG

        //
        // Count alignment faults by mode.
        //

        if (PreviousMode == KernelMode) {
            KiKernelFixupCount += 1;
        } else {
            KiUserFixupCount += 1;
        }

        EffectiveAddress =
            (PVOID)ExceptionRecord->ExceptionInformation[EXINFO_EFFECTIVE_ADDRESS];

        NewAlignmentFault = KiNewGlobalAlignmentFault( ProgramCounter,
                                                       PreviousMode,
                                                       &FaultImage );
        if (NewAlignmentFault != FALSE) {

            //
            // Attempt to determine and display the name of the offending
            // image.
            //

            DbgPrint("KE: %s Fixup: %.16s [%.16s], Pc=%.16p, Addr=%.16p ... Total=%ld %s\n",
                     (PreviousMode == KernelMode) ? "Kernel" : "User",
                     &PsGetCurrentProcess()->ImageFileName[0],
                     FaultImage->Name,
                     ProgramCounter,
                     EffectiveAddress,
                     (PreviousMode == KernelMode) ? KiKernelFixupCount : KiUserFixupCount,
                     IsWow64Process() ? "(Wow64)" : "");

            if (AutoAlignment == FALSE &&
                KI_BREAK_ON_ALIGNMENT_FAULT( PreviousMode ) != FALSE &&
                ExceptionWasForwarded == FALSE) {

                if (EmulateAlignmentFault == FALSE) {
                    DbgPrint("KE: Misaligned access WILL NOT be emulated\n");
                }

                //
                // This alignment fault would not normally have been fixed up,
                // and KiBreakOnAlignmentFault flags indicate that we should
                // break into the kernel debugger.
                //
                // Also, we know that we have not broken into a user-mode
                // debugger as a result of this fault.
                //

                if (PreviousMode != KernelMode) {
                    RtlMakeStackTraceDataPresent();
                }

                DbgBreakPoint();
            }
        }

#endif

        //
        // Emulate the reference according to the decisions made above.
        //

        if (EmulateAlignmentFault != FALSE) {
            if (KiEmulateReference(ExceptionRecord,
                                   ExceptionFrame,
                                   TrapFrame) != FALSE) {
                KeGetCurrentPrcb()->KeAlignmentFixupCount += 1;
                AlignmentFaultHandled = TRUE;
            }
        }
    }

    *ExceptionForwarded = ExceptionWasForwarded;
    return AlignmentFaultHandled;
}

NTSTATUS
KipRecordAlignmentException(
    IN  PVOID ProgramCounter,
    OUT PALIGNMENT_EXCEPTION_RECORD *ExceptionRecord
    )
/*++

Routine Description:

    This routine searches for an existing ALIGNMENT_EXCEPTION_RECORD on the
    per-process list of alignment exceptions.  If a match is not found, then
    a new record is created.

Arguments:

    ProgramCounter - Supplies the address of the faulting instruction.

    ExceptionRecord - Supplies a pointer into which is placed the address
        of the matching alignment exception record.

Return Value:

    STATUS_SUCCESS if the operation was successful, or an appropriate error
        code otherwise.

--*/
{
    PALIGNMENT_EXCEPTION_RECORD exceptionRecord;
    NTSTATUS status;

    //
    // Lock the alignment exception database
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusive( &PsLoadedModuleResource, TRUE );

    exceptionRecord = KipFindAlignmentException( ProgramCounter );
    if (exceptionRecord == NULL) {

        //
        // New exception.  Allocate a new record.
        //

        exceptionRecord = KipAllocateAlignmentExceptionRecord();
        if (exceptionRecord == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exitUnlock;
        }

        exceptionRecord->ProgramCounter = ProgramCounter;
    }

    exceptionRecord->Count += 1;
    *ExceptionRecord = exceptionRecord;

    status = STATUS_SUCCESS;

exitUnlock:

    ExReleaseResourceLite( &PsLoadedModuleResource );
    KeLeaveCriticalRegion();

    return status;
}

PALIGNMENT_EXCEPTION_RECORD
KipAllocateAlignmentExceptionRecord(
    VOID
    )
/*++

Routine Description:

    This is a support routine for KipRecordAlignmentException().  Its purpose
    is to locate an available alignment exception record in the per-process
    alignment exception list.  If none is found, a new alignment exception
    table will be allocated and linked into the per-process list.

Arguments:

    None.

Return Value:

    A pointer to the new alignment exception record if successful, or NULL
    otherwise.

--*/
{
    PKTHREAD thread;
    PKPROCESS process;
    PALIGNMENT_EXCEPTION_RECORD exceptionRecord;
    PALIGNMENT_EXCEPTION_TABLE exceptionTable;
    ULONG exceptionTableCount;

    //
    // Free exception records have a NULL program counter.
    //

    exceptionRecord = KipFindAlignmentException( NULL );
    if (exceptionRecord == NULL) {

        thread = KeGetCurrentThread();
        process = thread->ApcState.Process;

        //
        // Ensure that we haven't exceeded the maximum number of alignment
        // exception tables for this process.  We could keep a count but we
        // do not care about performance here... this code only executes when
        // the process is running under a debugger and we're likely about
        // to break in.
        //

        exceptionTableCount = 0;
        exceptionTable = process->AlignmentExceptionTable;
        while (exceptionTable != NULL) {
            exceptionTableCount += 1;
            exceptionTable = exceptionTable->Next;
        }

        if (exceptionTableCount == MAXIMUM_ALIGNMENT_TABLES) {
            return NULL;
        }

        //
        // Allocate a new exception table and insert it at the
        // head of the per-process list.
        //

        exceptionTable = ExAllocatePoolWithTag( PagedPool,
                                                sizeof(ALIGNMENT_EXCEPTION_TABLE),
                                                'tpcX' );
        if (exceptionTable == NULL) {
            return NULL;
        }

        RtlZeroMemory( exceptionTable, sizeof(ALIGNMENT_EXCEPTION_TABLE) );
        exceptionTable->Next = process->AlignmentExceptionTable;
        process->AlignmentExceptionTable = exceptionTable;

        //
        // Allocate the first record in the array
        //

        exceptionRecord = &exceptionTable->RecordArray[0];
    }

    return exceptionRecord;
}

PALIGNMENT_EXCEPTION_RECORD
KipFindAlignmentException(
    IN PVOID ProgramCounter
    )
/*++

Routine Description:

    This routine searches the alignment exception tables associated with
    the current process for an alignment exception record that matches
    the supplied program counter.

Arguments:

    ProgramCounter - Supplies the address of the faulting instruction.

Return Value:

    A pointer to the matching alignment exception record, or NULL if none
    was found.

--*/
{
    PKTHREAD thread;
    PKPROCESS process;
    PALIGNMENT_EXCEPTION_RECORD exceptionRecord;
    PALIGNMENT_EXCEPTION_RECORD lastExceptionRecord;
    PALIGNMENT_EXCEPTION_TABLE exceptionTable;

    thread = KeGetCurrentThread();
    process = thread->ApcState.Process;

    //
    // Walk the singly-linked list of exception tables dangling
    // off of the process.
    //

    exceptionTable = process->AlignmentExceptionTable;
    while (exceptionTable != NULL) {

        //
        // Scan this table looking for a match.
        //

        exceptionRecord = exceptionTable->RecordArray;
        lastExceptionRecord =
            &exceptionTable->RecordArray[ ALIGNMENT_RECORDS_PER_TABLE ];

        while (exceptionRecord < lastExceptionRecord) {
            if (exceptionRecord->ProgramCounter == ProgramCounter) {

                //
                // Found it.
                //

                return exceptionRecord;
            }
            exceptionRecord++;
        }

        if (ProgramCounter == NULL) {

            //
            // Caller was looking for a free exception record.  If one exists
            // it will be in the first table, which was just examined.
            //

            break;
        }

        //
        // Go look in the next exception table.
        //

        exceptionTable = exceptionTable->Next;
    }
    return NULL;
}

#if DBG

//
// The following routines are used to maintain a global database of alignment
// faults that were found in the system.  Alignment faults are stored according
// to the name of the image and the offset within that image.  In this way an
// existing alignment fault record will be found if it occurs in the same image
// loaded at a different base address in a new process.
//

typedef struct _ALIGNMENT_FAULT_LOCATION {

    //
    // Pointer to fault image associated with this location
    //

    PALIGNMENT_FAULT_IMAGE    Image;

    //
    // Linkage for singly-linked list of fault locations associated with the
    // same image.
    //

    PALIGNMENT_FAULT_LOCATION Next;

    //
    // Offset of the PC address within the image.
    //

    ULONG_PTR                 OffsetFromBase;

    //
    // Number of alignment faults taken at this location.
    //

    ULONG                     Count;

} ALIGNMENT_FAULT_LOCATION;

//
// The maximum number of individual alignment fault locations that will be
// tracked.
//

#define    MAX_FAULT_LOCATIONS  2048
#define    MAX_FAULT_IMAGES     128

ALIGNMENT_FAULT_LOCATION KiAlignmentFaultLocations[ MAX_FAULT_LOCATIONS ];
ULONG KiAlignmentFaultLocationCount = 0;

ALIGNMENT_FAULT_IMAGE KiAlignmentFaultImages[ MAX_FAULT_IMAGES ];
ULONG KiAlignmentFaultImageCount = 0;

KSPIN_LOCK KipGlobalAlignmentDatabaseLock;

VOID
KiCopyLastPathElement(
    IN      PUNICODE_STRING Source,
    IN OUT  PULONG StringBufferLen,
    OUT     PCHAR StringBuffer
    );

PALIGNMENT_FAULT_IMAGE
KiFindAlignmentFaultImage(
    IN PUCHAR ImageName
    );

PLDR_DATA_TABLE_ENTRY
KiFindLoaderDataTableEntry(
    IN PLIST_ENTRY ListHead,
    IN PVOID ProgramCounter,
    IN KPROCESSOR_MODE PreviousMode
    );

BOOLEAN
KiIncrementLocationAlignmentFault(
    IN PALIGNMENT_FAULT_IMAGE FaultImage,
    IN ULONG_PTR OffsetFromBase
    );

BOOLEAN
KiGetLdrDataTableInformation(
    IN      PVOID ProgramCounter,
    IN      KPROCESSOR_MODE PreviousMode,
    IN OUT  PULONG ImageNameBufferLength,
    OUT     PCHAR ImageNameBuffer,
    OUT     PVOID *ImageBase
    )
/*++

Routine Description:

    This routine returns the name of the image that contains the supplied
    address.

Arguments:

    ProgramCounter - Supplies the address for which we would like the
        name of the containing image.

    PreviousMode - Indicates whether the module is a user or kernel image.

    ImageNameBufferLength - Supplies a pointer to a buffer length value.  On
        entry, this value represents the maximum length of StringBuffer.  On
        exit, the value is set to the actual number of characters stored.

    ImageNameBuffer - Supplies a pointer to the output ANSI string into which
        the module name will be placed.  This string will not be null
        terminated.

    ImageBase - Supplies a pointer to a location into which the base address
        of the located image is placed.

Return Value:

    Returns TRUE if a module was located and its name copied to ImageNameBuffer,
    or FALSE otherwise.

--*/
{
    PLIST_ENTRY head;
    PPEB peb;
    PLDR_DATA_TABLE_ENTRY tableEntry;
    BOOLEAN status;

    //
    // Since we may be poking around in user space, be sure to recover
    // gracefully from any exceptions thrown.
    //

    try {

        //
        // Choose the appropriate module list based on whether the fault
        // occured in user- or kernel-space.
        //

        if (PreviousMode == KernelMode) {
            head = &PsLoadedModuleList;
        } else {
            peb = PsGetCurrentProcess()->Peb;
            head = &peb->Ldr->InLoadOrderModuleList;
        }

        tableEntry = KiFindLoaderDataTableEntry( head,
                                                 ProgramCounter,
                                                 PreviousMode );
        if (tableEntry != NULL) {

            //
            // The module of interest was located.  Copy its name and
            // base address to the output paramters.
            //

            KiCopyLastPathElement( &tableEntry->BaseDllName,
                                   ImageNameBufferLength,
                                   ImageNameBuffer );

            *ImageBase = tableEntry->DllBase;
            status = TRUE;

        } else {

            //
            // A module containing the supplied program counter could not be
            // found.
            //

            status = FALSE;
        }

    } except(ExSystemExceptionFilter()) {

        status = FALSE;
    }

    return status;
}

PLDR_DATA_TABLE_ENTRY
KiFindLoaderDataTableEntry(
    IN PLIST_ENTRY ListHead,
    IN PVOID ProgramCounter,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This is a support routine for KiGetLdrDataTableInformation.  Its purpose is
    to search a LDR_DATA_TABLE_ENTRY list, looking for a module that contains
    the supplied program counter.

Arguments:

    ListHead - Supplies a pointer to the LIST_ENTRY that represents the head of
        the LDR_DATA_TABLE_ENTRY list to search.

    ProgramCounter - Supplies the code location of the faulting instruction.

Return Value:

    Returns a pointer to the matching LDR_DATA_TABLE_ENTRY structure, or NULL
        if no match is found.

--*/
{
    ULONG nodeNumber;
    PLIST_ENTRY next;
    PLDR_DATA_TABLE_ENTRY ldrDataTableEntry;
    ULONG_PTR imageStart;
    ULONG_PTR imageEnd;

    //
    // Walk the user- or kernel-mode module list.  It is up to the caller
    // to capture any exceptions as a result of the lists being corrupt.
    //

    nodeNumber = 0;
    next = ListHead;

    if (PreviousMode != KernelMode) {
        ProbeForReadSmallStructure( next,
                                    sizeof(LIST_ENTRY),
                                    PROBE_ALIGNMENT(LIST_ENTRY) );
    }

    while (TRUE) {

        nodeNumber += 1;
        next = next->Flink;
        if (next == ListHead || nodeNumber > 10000) {

            //
            // The end of the module list has been reached, or the
            // list has been corrupted with a cycle.  Indicate that
            // no matching module could be located.
            //

            ldrDataTableEntry = NULL;
            break;
        }

        ldrDataTableEntry = CONTAINING_RECORD( next,
                                               LDR_DATA_TABLE_ENTRY,
                                               InLoadOrderLinks );
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure( ldrDataTableEntry,
                                        sizeof(LDR_DATA_TABLE_ENTRY),
                                        PROBE_ALIGNMENT(LDR_DATA_TABLE_ENTRY) );
        }

        imageStart = (ULONG_PTR)ldrDataTableEntry->DllBase;
        if (imageStart > (ULONG_PTR)ProgramCounter) {

            //
            // The start of this module is past the program counter,
            // keep looking.
            //

            continue;
        }

        imageEnd = imageStart + ldrDataTableEntry->SizeOfImage;
        if (imageEnd > (ULONG_PTR)ProgramCounter) {

            //
            // Found a match.
            //

            break;
        }
    }
    return ldrDataTableEntry;
}

VOID
KiCopyLastPathElement(
    IN      PUNICODE_STRING Source,
    IN OUT  PULONG StringBufferLen,
    OUT     PCHAR StringBuffer
    )
/*++

Routine Description:

    This routine locates the last path element of the path name represented by
    Source and copies it to StringBuffer.

Arguments:

    Source - Supplies a pointer to the source UNICODE_STRING path.

    StringBufferLen - Supplies a pointer to a buffer length value.  On entry,
        this value represents the maximum length of StringBuffer.  On exit, the
        value is set to the actual number of characters stored.

    StringBuffer - Supplies a pointer to the output string buffer that is to
        contain the last path element.  This string is not null terminated.

Return Value:

    None.

--*/
{
    PWCHAR src;
    PCHAR dst;
    USHORT charCount;

    //
    // The name of the module containing the specified address is at
    // ldrDataTableEntry->BaseDllName.  It might contain just the name,
    // or it might contain the whole path.
    //
    // Start at the end of the module path and work back until one
    // of the following is encountered:
    //
    // - ModuleName->MaximumLength characters
    // - the beginning of the module path string
    // - a path seperator
    //

    charCount = Source->Length / sizeof(WCHAR);
    src = &Source->Buffer[ charCount ];

    charCount = 0;
    while (TRUE) {

        if (charCount >= *StringBufferLen) {
            break;
        }

        if (src == Source->Buffer) {
            break;
        }

        if (*(src-1) == L'\\') {
            break;
        }

        src--;
        charCount++;
    }

    //
    // Now copy the characters into the output string.  We do our own
    // ansi-to-unicode conversion because the NLS routines cannot be
    // called at raised IRQL.
    //

    dst = StringBuffer;
    *StringBufferLen = charCount;
    while (charCount > 0) {
        *dst++ = (CHAR)(*src++);
        charCount--;
    }
}

BOOLEAN
KiNewGlobalAlignmentFault(
    IN  PVOID ProgramCounter,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PALIGNMENT_FAULT_IMAGE *AlignmentFaultImage
    )
/*++

Routine Description:

    This routine looks for an existing alignment fault in the global
    fault database.  A new record is created if a match could not be
    found.  The count is incremented, and a pointer to the associated
    image record is returned.

Arguments:

    ProgramCounter - Supplies the code location of the faulting instruction.

    PreviousMode - Supplies the execution mode at the time of the fault.

    AlignmentFaultImage - Supplies a location into which the pointer to the
        associated ALIGNMENT_FAULT_IMAGE structure is placed.

Return Value:

    TRUE if an existing alignment fault match was not found, FALSE otherwise.

--*/
{
    ULONG_PTR imageOffset;
    CHAR imageNameBuffer[ MAX_IMAGE_NAME_CHARS + 1 ];
    ULONG imageNameBufferLength;
    PCHAR imageName;
    PALIGNMENT_FAULT_IMAGE alignmentFaultImage;
    BOOLEAN newFault;
    BOOLEAN foundLdrDataInfo;
    PVOID imageBase;
    KIRQL oldIrql;

    imageNameBufferLength = MAX_IMAGE_NAME_CHARS;
    foundLdrDataInfo = KiGetLdrDataTableInformation( ProgramCounter,
                                                     PreviousMode,
                                                     &imageNameBufferLength,
                                                     imageNameBuffer,
                                                     &imageBase );
    if (foundLdrDataInfo == FALSE) {

        //
        // Couldn't find an image for this program counter.
        //

        imageBase = NULL;
        imageName = "Unavailable";

    } else {

        imageNameBuffer[ imageNameBufferLength ] = '\0';
        imageName = imageNameBuffer;
    }

    //
    // Acquire the spinlock at synch level so that we can handle exceptions
    // from ISRs
    //

    imageOffset = (ULONG_PTR)ProgramCounter - (ULONG_PTR)imageBase;
    oldIrql = KeAcquireSpinLockRaiseToSynch( &KipGlobalAlignmentDatabaseLock );
    alignmentFaultImage = KiFindAlignmentFaultImage( imageName );
    if (alignmentFaultImage == NULL) {

        //
        // Image table must be full
        //

        newFault = FALSE;

    } else {

        newFault = KiIncrementLocationAlignmentFault( alignmentFaultImage,
                                                      imageOffset );
    }
    KeReleaseSpinLock( &KipGlobalAlignmentDatabaseLock, oldIrql );


    *AlignmentFaultImage = alignmentFaultImage;
    return newFault;
}

BOOLEAN
KiIncrementLocationAlignmentFault(
    IN PALIGNMENT_FAULT_IMAGE FaultImage,
    IN ULONG_PTR OffsetFromBase
    )
/*++

Routine Description:

    This is a support routine for KiNewGlobalAligmentFault.  Its purpose is to
    find or create an alignment fault record once the appropriate alignment
    fault image has been found or created.

Arguments:

    FaultImage - Supplies a pointer to the ALIGNMENT_FAULT_IMAGE associated
        with this alignment fault.

    OffsetFromBase - Supplies the image offset within the image of the faulting
        instruction.

Return Value:

    TRUE if an existing alignment fault match was not found, FALSE otherwise.

--*/
{
    PALIGNMENT_FAULT_LOCATION faultLocation;

    //
    // Walk the location table, looking for a match.
    //

    faultLocation = FaultImage->LocationHead;
    while (faultLocation != NULL) {

        if (faultLocation->OffsetFromBase == OffsetFromBase) {
            faultLocation->Count++;
            return FALSE;
        }

        faultLocation = faultLocation->Next;
    }

    //
    // Could not find a match.  Build a new alignment fault record.
    //

    if (KiAlignmentFaultLocationCount >= MAX_FAULT_LOCATIONS) {

        //
        // Table is full.  Indicate that this is not a new alignment fault.
        //

        return FALSE;
    }

    faultLocation = &KiAlignmentFaultLocations[ KiAlignmentFaultLocationCount ];
    faultLocation->Image = FaultImage;
    faultLocation->Next = FaultImage->LocationHead;
    faultLocation->OffsetFromBase = OffsetFromBase;
    faultLocation->Count = 1;

    FaultImage->LocationHead = faultLocation;
    FaultImage->Instances += 1;

    KiAlignmentFaultLocationCount++;
    return TRUE;
}

PALIGNMENT_FAULT_IMAGE
KiFindAlignmentFaultImage(
    IN PUCHAR ImageName
    )
/*++

Routine Description:

    This is a support routine for KiNewGlobalAlignmentFault.  Its purpose is to
    walk the global ALIGNMENT_FAULT_IMAGE list looking for an image name that
    matches ImageName.  If none is found, a new image record is created and
    inserted into the list.

Arguments:

    ImageName - Supplies a pointer to the ANSI image name.

Return Value:

    Returns a pointer to the matching ALIGNMENT_FAULT_IMAGE structure.

--*/
{
    PALIGNMENT_FAULT_IMAGE faultImage;
    PALIGNMENT_FAULT_IMAGE lastImage;

    if (ImageName == NULL || *ImageName == '\0') {

        //
        // No image name was supplied.
        //

        return NULL;
    }

    //
    // Walk the image table, looking for a match.
    //

    faultImage = &KiAlignmentFaultImages[ 0 ];
    lastImage = &KiAlignmentFaultImages[ KiAlignmentFaultImageCount ];

    while (faultImage < lastImage) {

        if (strcmp(ImageName, faultImage->Name) == 0) {

            //
            // Found it.
            //

            faultImage->Count += 1;
            return faultImage;
        }

        faultImage += 1;
    }

    //
    // Create a new fault image if there's room
    //

    if (KiAlignmentFaultImageCount >= MAX_FAULT_IMAGES) {

        //
        // Table is full up.
        //

        return NULL;
    }
    KiAlignmentFaultImageCount += 1;

    //
    // Zero the image record.  The records start out zero-initialized, this
    // is in case KiAlignmentFaultImageCount was manually reset to zero via
    // the debugger.
    //

    RtlZeroMemory( faultImage, sizeof(ALIGNMENT_FAULT_IMAGE) );
    faultImage->Count = 1;
    strcpy( faultImage->Name, ImageName );

    return faultImage;
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\kd64\ia64\kdtrap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1998  Intel Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"
#ifdef _GAMBIT_
#include "ssc.h"
#endif // _GAMBIT_


BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN UnloadSymbols = FALSE;
    ULONGLONG OldStIIP, OldStIPSR;

    //
    // Disable all hardware breakpoints 
    //
    KeSetLowPsrBit(PSR_DB, 0);
    
    //
    // Synchronize processor execution, save processor state, enter debugger,
    // and flush the current TB.
    //

    KeFlushCurrentTb();

    //
    // If this is a breakpoint instruction, then check to determine if is
    // an internal command.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] >= BREAKPOINT_PRINT)) {

        //
        // Switch on the breakpoint code.
        //

        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print a debug string.
            //
            // Arguments: IA64 passes arguments via RSE not GR's. Since arguments are not
            //            part of CONTEXT struct, they need to be copies Temp registers.
            //            (see NTOS/RTL/IA64/DEBUGSTB.S)
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer.
            //   T2 - Supplies the Id of the calling component.
            //   T3 - Supplies the output filter level.
            //

        case BREAKPOINT_PRINT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed.
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            //
            // Print the debug message.
            //

            ContextRecord->IntV0 = KdpPrint((ULONG)ContextRecord->IntT2,
                                            (ULONG)ContextRecord->IntT3,
                                            (PCHAR)ContextRecord->IntT0,
                                            (USHORT)ContextRecord->IntT1,
                                            PreviousMode,
                                            TrapFrame,
                                            ExceptionFrame,
                                            &Completion);

            return Completion;

            //
            // Print a debug prompt string, then input a string.
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer..
            //   T2 - supplies a pointer to an input string buffer.
            //   T3 - Supplies the length of the input string bufffer.
            //

        case BREAKPOINT_PROMPT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed.
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);


            ContextRecord->IntV0 = KdpPrompt((PCHAR)ContextRecord->IntT0,
                                             (USHORT)ContextRecord->IntT1,
                                             (PCHAR)ContextRecord->IntT2,
                                             (USHORT)ContextRecord->IntT3,
                                             PreviousMode,
                                             TrapFrame,
                                             ExceptionFrame);

            return TRUE;

            //
            // Load the symbolic information for an image.
            //
            // Arguments:
            //
            //    T0 - Supplies a pointer to an output string descriptor.
            //    T1 - Supplies a the base address of the image.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
            OldStIPSR = ContextRecord->StIPSR;
            OldStIIP = ContextRecord->StIIP;
            KdpSymbol((PSTRING)ContextRecord->IntT0,
                      (PKD_SYMBOLS_INFO)ContextRecord->IntT1,
                      UnloadSymbols,
                      PreviousMode,
                      ContextRecord,
                      TrapFrame,
                      ExceptionFrame);

            //
            // If the kernel debugger did not update the IP, then increment
            // past the breakpoint instruction.
            //

            if ((ContextRecord->StIIP == OldStIIP) &&
                ((ContextRecord->StIPSR & IPSR_RI_MASK) == (OldStIPSR & IPSR_RI_MASK))) {
            	RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            }

            return TRUE;

        case BREAKPOINT_COMMAND_STRING:
            OldStIPSR = ContextRecord->StIPSR;
            OldStIIP = ContextRecord->StIIP;
            KdpCommandString((PSTRING)ContextRecord->IntT0,
                             (PSTRING)ContextRecord->IntT1,
                             PreviousMode,
                             ContextRecord,
                             TrapFrame,
                             ExceptionFrame);

            //
            // If the kernel debugger did not update the IP, then increment
            // past the breakpoint instruction.
            //

            if ((ContextRecord->StIIP == OldStIIP) &&
                ((ContextRecord->StIPSR & IPSR_RI_MASK) == (OldStIPSR & IPSR_RI_MASK))) {
            	RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            }

            return TRUE;

            //
            // Kernel breakin break
            //

        case BREAKPOINT_BREAKIN:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            break;

            //
            // Basic breakpoint.
            //

        case BREAKPOINT_STOP:
            break;

            //
            // Unknown internal command.
            //

        default:
            return FALSE;
        }
    }

    //
    // Report state change to the kernel debugger.
    //

    return KdpReport(TrapFrame,
                     ExceptionFrame,
                     ExceptionRecord,
                     ContextRecord,
                     PreviousMode,
                     SecondChance);

}

BOOLEAN
KdIsThisAKdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine is called whenever a user-mode exception occurs and
    it might be a kernel debugger exception (Like DbgPrint/DbgPrompt ).

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

Return Value:

    A value of TRUE is returned if this is for the kernel debugger.
    Otherwise, a value of FALSE is returned.

--*/

{

    ULONG_PTR BreakpointCode;

    //
    // Single step is also handled by the kernel debugger
    //

    if (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
#if DEVL

        return TRUE;

#else

        if (PreviousMode == KernelMode) {
            return TRUE;

        } else {
            return FALSE;
        }

#endif
    }

    //
    //  If is is not status breakpoint then it is not a kernel debugger trap.
    //

    if (ExceptionRecord->ExceptionCode != STATUS_BREAKPOINT) {
        
        return FALSE;
    }


    //
    // Isolate the breakpoint code from the breakpoint instruction which
    // is stored by the exception dispatch code in the information field
    // of the exception record.
    //

    BreakpointCode = (ULONG) ExceptionRecord->ExceptionInformation[0];

    //
    // Switch on the breakpoint code.
    //

    switch (BreakpointCode) {

        //
        // Kernel breakpoint codes.
        //

    case KERNEL_BREAKPOINT:

    case BREAKPOINT_BREAKIN:
    case BREAKPOINT_PRINT:
    case BREAKPOINT_PROMPT:
    case BREAKPOINT_STOP:
        return TRUE;


    case BREAKPOINT_LOAD_SYMBOLS:
    case BREAKPOINT_UNLOAD_SYMBOLS:

        if (PreviousMode == KernelMode) {
            return TRUE;

        } else {
            return FALSE;
        }

        //
        // All other codes.
        //

    default:
        return FALSE;
    }
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine that catchs debug
    prints in checked systems when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    PreviousMode - Supplies the previous processor mode.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    ULONG_PTR BreakpointCode;

    //
    // Isolate the breakpoint code from the breakpoint instruction which
    // is stored by the exception dispatch code in the information field
    // of the exception record.
    //

    BreakpointCode = (ULONG) ExceptionRecord->ExceptionInformation[0];


    //
    // If the breakpoint is a debug print, debug load symbols, or debug
    // unload symbols, then return TRUE. Otherwise, return FALSE;
    //

    if ((BreakpointCode == BREAKPOINT_PRINT) ||
        (BreakpointCode == BREAKPOINT_LOAD_SYMBOLS) ||
        (BreakpointCode == BREAKPOINT_UNLOAD_SYMBOLS)) {

        //
        // Advance to next instruction slot so that the BREAK instruction
        // does not get re-executed
        //

        RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                          ContextRecord->StIPSR,
                          ContextRecord->StIIP);


        return TRUE;

    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\balmgr.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    balmgr.c

Abstract:

    This module implements the NT balance set manager. Normally the kernel
    does not contain "policy" code. However, the balance set manager needs
    to be able to traverse the kernel data structures and, therefore, the
    code has been located as logically part of the kernel.

    The balance set manager performs the following operations:

        1. Makes the kernel stack of threads that have been waiting for a
           certain amount of time, nonresident.

        2. Removes processes from the balance set when memory gets tight
           and brings processes back into the balance set when there is
           more memory available.

        3. Makes the kernel stack resident for threads whose wait has been
           completed, but whose stack is nonresident.

        4. Arbitrarily boosts the priority of a selected set of threads
           to prevent priority inversion in variable priority levels.

    In general, the balance set manager only is active during periods when
    memory is tight.

Author:

    David N. Cutler (davec) 13-Jul-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define balance set wait object types.
//

typedef enum _BALANCE_OBJECT {
    TimerExpiration,
    WorkingSetManagerEvent,
    MaximumObject
    } BALANCE_OBJECT;

//
// Define maximum number of thread stacks that can be out swapped in
// a single time period.
//

#define MAXIMUM_THREAD_STACKS 5

//
// Define periodic wait interval value.
//

#define PERIODIC_INTERVAL (1 * 1000 * 1000 * 10)

//
// Define amount of time a thread can be in the ready state without having
// is priority boosted (approximately 4 seconds).
//

#define READY_WITHOUT_RUNNING  (4 * 75)

//
// Define kernel stack protect time. For small systems the protect time
// is 3 seconds. For all other systems, the protect time is 5x seconds.
//

#define SMALL_SYSTEM_STACK_PROTECT_TIME (3 * 75)
#define LARGE_SYSTEM_STACK_PROTECT_TIME (SMALL_SYSTEM_STACK_PROTECT_TIME * 5)
#define STACK_SCAN_PERIOD 4
ULONG KiStackProtectTime;

//
// Define number of threads to scan each period and the priority boost bias.
//

#define THREAD_BOOST_BIAS 1
#define THREAD_BOOST_PRIORITY (LOW_REALTIME_PRIORITY - THREAD_BOOST_BIAS)
#define THREAD_SCAN_PRIORITY (THREAD_BOOST_PRIORITY - 1)
#define THREAD_READY_COUNT 10
#define THREAD_SCAN_COUNT 16

//
// Define local procedure prototypes.
//

VOID
KiAdjustIrpCredits (
    VOID
    );

VOID
KiInSwapKernelStacks (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiInSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiOutSwapKernelStacks (
    VOID
    );

VOID
KiOutSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiScanReadyQueues (
    VOID
    );

// 
// Define global IRP credit adjustment data.
//

#if !defined(NT_UP)

LONG KiLastProcessor = 0;

#endif

//
// Define thread table index static data.
//

ULONG KiReadyQueueIndex = 1;

//
// Define swap request flag.
//

LONG KiStackOutSwapRequest = FALSE;

VOID
KeBalanceSetManager (
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the startup code for the balance set manager. The
    balance set manager thread is created during system initialization
    and begins execution in this function.

Arguments:

    Context - Supplies a pointer to an arbitrary data structure (NULL).

Return Value:

    None.

--*/

{

    LARGE_INTEGER DueTime;
    KIRQL OldIrql;
    KTIMER PeriodTimer;
    ULONG StackScanPeriod;
    NTSTATUS Status;
    PKTHREAD Thread;
    KWAIT_BLOCK WaitBlockArray[MaximumObject];
    PVOID WaitObjects[MaximumObject];

    //
    // Raise the thread priority to the lowest realtime level.
    //

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    //
    // Initialize the periodic timer, set it to expire one period from
    // now, and set the stack scan period.
    //

    KeInitializeTimer(&PeriodTimer);
    DueTime.QuadPart = - PERIODIC_INTERVAL;
    KeSetTimer(&PeriodTimer, DueTime, NULL);
    StackScanPeriod = STACK_SCAN_PERIOD;

    //
    // Compute the stack protect time based on the system size.
    //

    if (MmQuerySystemSize() == MmSmallSystem) {
        KiStackProtectTime = SMALL_SYSTEM_STACK_PROTECT_TIME;

    } else {
        KiStackProtectTime = LARGE_SYSTEM_STACK_PROTECT_TIME;
    }

    //
    // Initialize the wait objects array.
    //

    WaitObjects[TimerExpiration] = (PVOID)&PeriodTimer;
    WaitObjects[WorkingSetManagerEvent] = (PVOID)&MmWorkingSetManagerEvent;

    //
    // Loop forever processing balance set manager events.
    //

    do {

        //
        // Wait for a memory management memory low event, a swap event,
        // or the expiration of the period timout rate that the balance
        // set manager runs at.
        //

        Status = KeWaitForMultipleObjects(MaximumObject,
                                          &WaitObjects[0],
                                          WaitAny,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL,
                                          &WaitBlockArray[0]);

        //
        // Switch on the wait status.
        //

        switch (Status) {

            //
            // Periodic timer expiration.
            //

        case TimerExpiration:

            //
            // Adjust I/O lookaside credits.
            //

#if !defined(NT_UP)

            KiAdjustIrpCredits();

#endif

            //
            // Adjust the depth of lookaside lists.
            //

            ExAdjustLookasideDepth();

            //
            // Scan ready queues and boost thread priorities as appropriate.
            //

            KiScanReadyQueues();

            //
            // Execute the virtual memory working set manager.
            //

            MmWorkingSetManager();

            //
            // Set the timer to expire at the next periodic interval.
            //

            KeSetTimer(&PeriodTimer, DueTime, NULL);

            //
            // Attempt to initiate outswaping of kernel stacks.
            //
            // N.B. If outswapping is initiated, then the dispatcher
            //      lock is not released until the wait at the top
            //      of the loop is executed.
            //

            StackScanPeriod -= 1;
            if (StackScanPeriod == 0) {
                StackScanPeriod = STACK_SCAN_PERIOD;
                if (InterlockedCompareExchange(&KiStackOutSwapRequest,
                                               TRUE,
                                               FALSE) == FALSE) {

                    KiLockDispatcherDatabase(&OldIrql);
                    KiSetSwapEvent();
                    Thread = KeGetCurrentThread();
                    Thread->WaitNext = TRUE;
                    Thread->WaitIrql = OldIrql;
                }
            }

            break;

            //
            // Working set manager event.
            //

        case WorkingSetManagerEvent:

            //
            // Call the working set manager to trim working sets.
            //

            MmWorkingSetManager();
            break;

            //
            // Illegal return status.
            //

        default:
            KdPrint(("BALMGR: Illegal wait status, %lx =\n", Status));
            break;
        }

    } while (TRUE);
    return;
}

VOID
KeSwapProcessOrStack (
    IN PVOID Context
    )

/*++

Routine Description:

    This thread controls the swapping of processes and kernel stacks. The
    order of evaluation is:

        Outswap kernel stacks
        Outswap processes
        Inswap processes
        Inswap kernel stacks

Arguments:

    Context - Supplies a pointer to the routine context - not used.

Return Value:

    None.

--*/

{

    PSINGLE_LIST_ENTRY SwapEntry;

    //
    // Set address of swap thread object and raise the thread priority to
    // the lowest realtime level + 7 (i.e., priority 23).
    //

    KiSwappingThread = KeGetCurrentThread();
    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY + 7);

    //
    // Loop for ever processing swap events.
    //
    // N.B. This is the ONLY thread that processes swap events.
    //

    do {

        //
        // Wait for a swap event to occur.
        //

        KeWaitForSingleObject(&KiSwapEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        //
        // The following events are processed one after the other. If
        // another event of a particular type arrives after having
        // processed the respective event type, them the swap event
        // will have been set and the above wait will immediately be
        // satisifed.
        //
        // Check to determine if there is a kernel stack out swap scan
        // request pending.
        //

        if (InterlockedCompareExchange(&KiStackOutSwapRequest,
                                       FALSE,
                                       TRUE) == TRUE) {

            KiOutSwapKernelStacks();
        }

        //
        // Check if there are any process out swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiProcessOutSwapListHead);
        if (SwapEntry != NULL) {
            KiOutSwapProcesses(SwapEntry);
        }

        //
        // Check if there are any process in swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiProcessInSwapListHead);
        if (SwapEntry != NULL) {
            KiInSwapProcesses(SwapEntry);
        }

        //
        // Check if there are any kernel stack in swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiStackInSwapListHead);
        if (SwapEntry != NULL) {
            KiInSwapKernelStacks(SwapEntry);
        }

    } while (TRUE);

    return;
}

#if !defined(NT_UP)

VOID
KiAdjustIrpCredits (
    VOID
    )

/*++

Routine Description:

    This function adjusts the lookaside IRP float credits for two processors
    during each one second scan interval. IRP credits are adjusted by using
    a moving average of two processors. It is possible for the IRP credits
    for a processor to become negative, but this condition will be self
    correcting.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LONG Average;
    LONG Adjust;
    LONG Last;
    LONG LastCount;
    PKPRCB LastPrcb;
    LONG Next;
    LONG NextCount;
    PKPRCB NextPrcb;

    //
    // Compute the processor number of the next processor.
    //

    Last = KiLastProcessor;
    Next = Last + 1;
    if (Next >= KeNumberProcessors) {
        Next = 0;
    }

    //
    // Compute the average IRP credits of the two processors and apply an
    // adjustment if the average is greater than zero.
    //

    LastPrcb = KiProcessorBlock[Last];
    NextPrcb = KiProcessorBlock[Next];
    LastCount = LastPrcb->LookasideIrpFloat;
    NextCount = NextPrcb->LookasideIrpFloat;
    Average = (LastCount + NextCount) >> 1;
    if (Average > 0) {

        //
        // If the last count is greater than the average, then adjust by
        // an amount equal to the last count minus the average. Otherwise,
        // adjust by an amount equal to the next count minus the average.
        //

        if (LastCount > Average ) {
            Adjust = Average - LastCount;

        } else {
            Adjust = NextCount - Average;
        }

        InterlockedExchangeAdd(&LastPrcb->LookasideIrpFloat, Adjust);
        InterlockedExchangeAdd(&NextPrcb->LookasideIrpFloat, -Adjust);
    }

    //
    // Set new last processor for next scan.
    //

    KiLastProcessor = Next;
    return;
}

#endif

VOID
KiInSwapKernelStacks (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function in swaps the kernel stack for threads whose wait has been
    completed and whose kernel stack is nonresident.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the in swap list.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    //
    // Process the stack in swap SLIST and for each thread removed from the
    // SLIST, make its kernel stack resident, and ready it for execution.
    //

    do {
        Thread = CONTAINING_RECORD(SwapEntry, KTHREAD, SwapListEntry);
        SwapEntry = SwapEntry->Next;
        MmInPageKernelStack(Thread);
        KiLockDispatcherDatabase(&OldIrql);
        Thread->KernelStackResident = TRUE;
        KiReadyThread(Thread);
        KiUnlockDispatcherDatabase(OldIrql);
    } while (SwapEntry != NULL);

    return;
}

VOID
KiInSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function in swaps processes.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the SLIST.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    //
    // Process the process in swap list and for each process removed from
    // the list, make the process resident, and process its ready list.
    //

    do {
        Process = CONTAINING_RECORD(SwapEntry, KPROCESS, SwapListEntry);
        SwapEntry = SwapEntry->Next;
        Process->State = ProcessInSwap;
        MmInSwapProcess(Process);
        KiLockDispatcherDatabase(&OldIrql);
        Process->State = ProcessInMemory;
        NextEntry = Process->ReadyListHead.Flink;
        while (NextEntry != &Process->ReadyListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(NextEntry);
            Thread->ProcessReadyQueue = FALSE;
            KiReadyThread(Thread);
            NextEntry = Process->ReadyListHead.Flink;
        }

        KiUnlockDispatcherDatabase(OldIrql);
    } while (SwapEntry != NULL);

    return;
}

VOID
KiOutSwapKernelStacks (
    VOID
    )

/*++

Routine Description:

    This function attempts to out swap the kernel stack for threads whose
    wait mode is user and which have been waiting longer than the stack
    protect time.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    ULONG NumberOfThreads;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;
    PKTHREAD ThreadObjects[MAXIMUM_THREAD_STACKS];
    ULONG WaitLimit;

    //
    // Scan the waiting in list and check if the wait time exceeds the
    // stack protect time. If the protect time is exceeded, then make
    // the kernel stack of the waiting thread nonresident. If the count
    // of the number of stacks that are resident for the process reaches
    // zero, then insert the process in the outswap list and set its state
    // to transition.
    //
    // Raise IRQL and lock the dispatcher database.
    //

    NumberOfThreads = 0;
    WaitLimit = KiQueryLowTickCount() - KiStackProtectTime;
    KiLockDispatcherDatabase(&OldIrql);
    NextEntry = KiWaitListHead.Flink;
    while ((NextEntry != &KiWaitListHead) &&
           (NumberOfThreads < MAXIMUM_THREAD_STACKS)) {

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);

        ASSERT(Thread->WaitMode == UserMode);

        NextEntry = NextEntry->Flink;

        //
        // Threads are inserted at the end of the wait list in very nearly
        // reverse time order, i.e., the longest waiting thread is at the
        // beginning of the list followed by the next oldest, etc. Thus when
        // a thread is encountered which still has a protected stack it is
        // known that all further threads in the wait also have protected
        // stacks, and therefore, the scan can be terminated.
        //
        // N.B. It is possible due to a race condition in wait that a high
        //      priority thread was placed in the wait list. If this occurs,
        //      then the thread is removed from the wait list without swapping
        //      the stack.
        //

        if (WaitLimit < Thread->WaitTime) {
            break;

        } else if (Thread->Priority >= (LOW_REALTIME_PRIORITY + 9)) {
            RemoveEntryList(&Thread->WaitListEntry);
            Thread->WaitListEntry.Flink = NULL;

        } else if (KiIsThreadNumericStateSaved(Thread)) {
            Thread->KernelStackResident = FALSE;
            ThreadObjects[NumberOfThreads] = Thread;
            NumberOfThreads += 1;
            RemoveEntryList(&Thread->WaitListEntry);
            Thread->WaitListEntry.Flink = NULL;
            Process = Thread->ApcState.Process;
            Process->StackCount -= 1;
            if (Process->StackCount == 0) {
                Process->State = ProcessOutTransition;
                InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                               &Process->SwapListEntry);

                KiSwapEvent.Header.SignalState = 1;
            }
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Out swap the kernel stack for the selected set of threads.
    //

    while (NumberOfThreads > 0) {
        NumberOfThreads -= 1;
        Thread = ThreadObjects[NumberOfThreads];
        MmOutPageKernelStack(Thread);
    }

    return;
}

VOID
KiOutSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function out swaps processes.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the SLIST.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    //
    // Process the process out swap list and for each process removed from
    // the list, make the process nonresident, and process its ready list.
    //

    do {
        Process = CONTAINING_RECORD(SwapEntry, KPROCESS, SwapListEntry);
        SwapEntry = SwapEntry->Next;

        //
        // If there are any threads in the process ready list, then don't
        // out swap the process and ready all threads in the process ready
        // list. Otherwise, out swap the process.
        //

        KiLockDispatcherDatabase(&OldIrql);
        NextEntry = Process->ReadyListHead.Flink;
        if (NextEntry != &Process->ReadyListHead) {
            Process->State = ProcessInMemory;
            while (NextEntry != &Process->ReadyListHead) {
                Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
                RemoveEntryList(NextEntry);
                Thread->ProcessReadyQueue = FALSE;
                KiReadyThread(Thread);
                NextEntry = Process->ReadyListHead.Flink;
            }

            KiUnlockDispatcherDatabase(OldIrql);

        } else {
            Process->State = ProcessOutSwap;
            KiUnlockDispatcherDatabase(OldIrql);
            MmOutSwapProcess(Process);

            //
            // While the process was being outswapped there may have been one
            // or more threads that attached to the process. If the process
            // ready list is not empty, then in swap the process. Otherwise,
            // mark the process as out of memory.
            //

            KiLockDispatcherDatabase(&OldIrql);
            NextEntry = Process->ReadyListHead.Flink;
            if (NextEntry != &Process->ReadyListHead) {
                Process->State = ProcessInTransition;
                InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                               &Process->SwapListEntry);

                KiSwapEvent.Header.SignalState = 1;

            } else {
                Process->State = ProcessOutOfMemory;
            }

            KiUnlockDispatcherDatabase(OldIrql);
        }

    } while (SwapEntry != NULL);

    return;
}

VOID
KiScanReadyQueues (
    VOID
    )

/*++

Routine Description:

    This function scans a section of the ready queues and attempts to
    boost the priority of threads that run at variable priority levels.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Count = 0;
    PLIST_ENTRY Entry;
    ULONG Index;
    PLIST_ENTRY ListHead;
    ULONG Mask;
    ULONG Number = 0;
    KIRQL OldIrql;
    PKPROCESS Process;
    ULONG Summary;
    PKTHREAD Thread;
    ULONG WaitLimit;

    //
    // Lock the dispatcher database and check if there are any ready threads
    // queued at the scanable priority levels.
    //

    Index = KiReadyQueueIndex;
    Count = THREAD_READY_COUNT;
    Mask = 1 << Index;
    Number = THREAD_SCAN_COUNT;
    WaitLimit = KiQueryLowTickCount() - READY_WITHOUT_RUNNING;
    KiLockDispatcherDatabase(&OldIrql);
    Summary = KiReadySummary & ((1 << THREAD_BOOST_PRIORITY) - 2);
    if (Summary != 0) {
        do {

            //
            // If the current ready queue index is beyond the end of the range
            // of priorities that are scanned, then wrap back to the beginning
            // priority.
            //

            if (Index > THREAD_SCAN_PRIORITY) {
                Index = 1;
                Mask = 2;
            }

            //
            // If there are any ready threads queued at the current priority
            // level, then attempt to boost the thread priority.
            //

            if ((Summary & Mask) != 0) {
                Summary ^= Mask;
                ListHead = &KiDispatcherReadyListHead[Index];
                Entry = ListHead->Flink;

                ASSERT(Entry != ListHead);

                do {

                    //
                    // If the thread has been waiting for an extended period,
                    // then boost the priority of the selected.
                    //

                    Thread = CONTAINING_RECORD(Entry, KTHREAD, WaitListEntry);
                    if (WaitLimit >= Thread->WaitTime) {

                        //
                        // Remove the thread from the respective ready queue.
                        //

                        Entry = Entry->Blink;
                        RemoveEntryList(Entry->Flink);
                        if (IsListEmpty(ListHead) != FALSE) {
                            KiReadySummary ^= Mask;
                        }

                        //
                        // Compute the priority decrement value, set the new
                        // thread priority, set the decrement count, set the
                        // thread quantum, and ready the thread for execution.
                        //

                        Thread->PriorityDecrement +=
                                        THREAD_BOOST_PRIORITY - Thread->Priority;

                        Thread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
                        Thread->Priority = THREAD_BOOST_PRIORITY;
                        Process = Thread->ApcState.Process;
                        Thread->Quantum = Process->ThreadQuantum * 2;
                        KiReadyThread(Thread);
                        Count -= 1;
                    }

                    Entry = Entry->Flink;
                    Number -= 1;
                } while ((Entry != ListHead) && (Number != 0) && (Count != 0));
            }

            Index += 1;
            Mask <<= 1;
        } while ((Summary != 0) && (Number != 0) && (Count != 0));
    }

    //
    // Unlock the dispatcher database and save the last read queue index
    // for the next scan.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    if ((Count != 0) && (Number != 0)) {
        KiReadyQueueIndex = 1;

    } else {
        KiReadyQueueIndex = Index;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\apcobj.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    apcobj.c

Abstract:

    This module implements the kernel APC object. Functions are provided
    to initialize, flush, insert, and remove APC objects.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input apc is
// really a kapc and not something else, like deallocated pool.
//

#define ASSERT_APC(E) {             \
    ASSERT((E)->Type == ApcObject); \
}

VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN KAPC_ENVIRONMENT Environment,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ApcMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel APC object. The thread, kernel
    routine, and optionally a normal routine, processor mode, and normal
    context parameter are stored in the APC object.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Environment - Supplies the environment in which the APC will execute.
        Valid values for this parameter are: OriginalApcEnvironment,
        AttachedApcEnvironment, CurrentApcEnvironment, or InsertApcEnvironment

    KernelRoutine - Supplies a pointer to a function that is to be
        executed at IRQL APC_LEVEL in kernel mode.

    RundownRoutine - Supplies an optional pointer to a function that is to be
        called if the APC is in a thread's APC queue when the thread terminates.

    NormalRoutine - Supplies an optional pointer to a function that is
        to be executed at IRQL 0 in the specified processor mode. If this
        parameter is not specified, then the ProcessorMode and NormalContext
        parameters are ignored.

    ApcMode - Supplies the processor mode in which the function specified
        by the NormalRoutine parameter is to be executed.

    NormalContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the NormalRoutine parameter.

Return Value:

    None.

--*/

{

    ASSERT(Environment <= InsertApcEnvironment);

    //
    // Initialize standard control object header.
    //

    Apc->Type = ApcObject;
    Apc->Size = sizeof(KAPC);

    //
    // Initialize the APC environment, thread address, kernel routine address,
    // rundown routine address, normal routine address, processor mode, and
    // normal context parameter. If the normal routine address is null, then
    // the processor mode is defaulted to KernelMode and the APC is a special
    // APC. Otherwise, the processor mode is taken from the argument list.
    //

    if (Environment == CurrentApcEnvironment) {
        Apc->ApcStateIndex = Thread->ApcStateIndex;

    } else {

        ASSERT((Environment <= Thread->ApcStateIndex) || (Environment == InsertApcEnvironment));

        Apc->ApcStateIndex = (CCHAR)Environment;
    }

    Apc->Thread = Thread;
    Apc->KernelRoutine = KernelRoutine;
    Apc->RundownRoutine = RundownRoutine;
    Apc->NormalRoutine = NormalRoutine;
    if (ARGUMENT_PRESENT(NormalRoutine)) {
        Apc->ApcMode = ApcMode;
        Apc->NormalContext = NormalContext;

    } else {
        Apc->ApcMode = KernelMode;
        Apc->NormalContext = NIL;
    }

    Apc->Inserted = FALSE;
    return;
}

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ApcMode
    )

/*++

Routine Description:

    This function flushes the APC queue selected by the specified processor
    mode for the specified thread. An APC queue is flushed by removing the
    listhead from the list, scanning the APC entries in the list, setting
    their inserted variables to FALSE, and then returning the address of the
    doubly linked list as the function value.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    ApcMode - Supplies the processor mode of the APC queue that is to
        be flushed.

Return Value:

    The address of the first entry in the list of APC objects that were flushed
    from the specified APC queue.

--*/

{

    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    if (IsListEmpty(&Thread->ApcState.ApcListHead[ApcMode])) {
        return NULL;
    }

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Get address of first APC in the list and check if the list is
    // empty or contains entries that should be flushed. If entries
    // should be flushed, then scan the list of APC objects and set their
    // inserted state to FALSE.
    //

    FirstEntry = Thread->ApcState.ApcListHead[ApcMode].Flink;
    if (FirstEntry == &Thread->ApcState.ApcListHead[ApcMode]) {
        FirstEntry = (PLIST_ENTRY)NULL;

    } else {
        RemoveEntryList(&Thread->ApcState.ApcListHead[ApcMode]);
        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            Apc->Inserted = FALSE;
            NextEntry = NextEntry->Flink;
        } while (NextEntry != FirstEntry);

        //
        // Reinitialize the header so the current thread may safely attach
        // to another process.
        //

        InitializeListHead(&Thread->ApcState.ApcListHead[ApcMode]);
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return address of
    // first entry in list of APC objects that were flushed.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return FirstEntry;
}

BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into the APC queue specifed by the
    thread and processor mode fields of the APC object. If the APC object
    is already in an APC queue or APC queuing is disabled, then no operation
    is performed. Otherwise the APC object is inserted in the specified queue
    and appropriate scheduling decisions are made.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    SystemArgument1, SystemArgument2 - Supply a set of two arguments that
        contain untyped data provided by the executive.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue or APC queuing is disabled,
    then a value of FALSE is returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    Thread = Apc->Thread;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If APC queuing is disabled, then set inserted to FALSE. Else save
    // system parameter values in APC object, and attempt to queue APC.
    //

    if (Thread->ApcQueueable == FALSE) {
        Inserted = FALSE;

    } else {
        Apc->SystemArgument1 = SystemArgument1;
        Apc->SystemArgument2 = SystemArgument2;
        Inserted = KiInsertQueueApc(Apc, Increment);
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return whether the
    // APC was inserted.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Inserted;
}

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    )

/*++

Routine Description:

    This function removes an APC object from an APC queue. If the APC object
    is not in an APC queue, then no operation is performed. Otherwise the
    APC object is removed from its current queue and its inserted state is
    set FALSE.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    If the APC object is not in an APC queue, then a value of FALSE is returned.
    Otherwise a value of TRUE is returned.

--*/

{

    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    Thread = Apc->Thread;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the APC object is in an APC queue, then remove it from the queue
    // and set its inserted state to FALSE. If the queue becomes empty, set
    // the APC pending state to FALSE.
    //

    Inserted = Apc->Inserted;
    if (Inserted != FALSE) {
        Apc->Inserted = FALSE;
        ApcState = Thread->ApcStatePointer[Apc->ApcStateIndex];
        RemoveEntryList(&Apc->ApcListEntry);
        if (IsListEmpty(&ApcState->ApcListHead[Apc->ApcMode]) != FALSE) {
            if (Apc->ApcMode == KernelMode) {
                ApcState->KernelApcPending = FALSE;

            } else {
                ApcState->UserApcPending = FALSE;
            }
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return whether an
    // APC object was removed from the APC queue.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\debug.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements kernel debugger synchronization routines.

Author:

    Ken Reneris (kenr) 30-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#define IDBG    1


#define FrozenState(a)  (a & 0xF)

// state
#define RUNNING                 0x00
#define TARGET_FROZEN           0x02
#define TARGET_THAW             0x03
#define FREEZE_OWNER            0x04

// flags (bits)
#define FREEZE_ACTIVE           0x20


//
// Define local storage to save the old IRQL.
//

KIRQL KiOldIrql;

#ifndef NT_UP
PKPRCB KiFreezeOwner;
#endif



BOOLEAN
KeFreezeExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function freezes the execution of all other processors in the host
    configuration and then returns to the caller.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Previous interrupt enable.

--*/

{

    BOOLEAN Enable;

#if !defined(NT_UP)

    BOOLEAN Flag;
    PKPRCB Prcb;
    KAFFINITY TargetSet;
    ULONG BitNumber;
    KIRQL OldIrql;

#if IDBG

    ULONG Count = 30000;

#endif
#endif

    //
    // Disable interrupts.
    //

    Enable = KeDisableInterrupts();
    KiFreezeFlag = FREEZE_FROZEN;

#if !defined(NT_UP)
    //
    // Raise IRQL to HIGH_LEVEL.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    if (FrozenState(KeGetCurrentPrcb()->IpiFrozen) == FREEZE_OWNER) {
        //
        // This processor already owns the freeze lock.
        // Return without trying to re-acquire lock or without
        // trying to IPI the other processors again
        //

        return Enable;
    }


    //
    // Try to acquire the KiFreezeExecutionLock before sending the request.
    // To prevent deadlock from occurring, we need to accept and process
    // incoming FreexeExecution requests while we are waiting to acquire
    // the FreezeExecutionFlag.
    //

    while (KeTryToAcquireSpinLockAtDpcLevel(&KiFreezeExecutionLock) == FALSE) {

        //
        // FreezeExecutionLock is busy.  Another processor may be trying
        // to IPI us - go service any IPI.
        //

        KeEnableInterrupts(Enable);
        Flag = KiIpiServiceRoutine((PVOID)TrapFrame, (PVOID)ExceptionFrame);
        KeDisableInterrupts();

#if IDBG

        if (Flag != FALSE) {
            Count = 30000;
            continue;
        }

        KeStallExecutionProcessor (100);
        if (!Count--) {
            Count = 30000;
            if (KeTryToAcquireSpinLockAtDpcLevel(&KiFreezeLockBackup) == TRUE) {
                KiFreezeFlag |= FREEZE_BACKUP;
                break;
            }
        }

#endif

    }

    //
    // After acquiring the lock flag, we send Freeze request to each processor
    // in the system (other than us) and wait for it to become frozen.
    //

    Prcb = KeGetCurrentPrcb();  // Do this after spinlock is acquired.
    TargetSet = KeActiveProcessors & ~(AFFINITY_MASK(Prcb->Number));
    if (TargetSet) {

#if IDBG
        Count = 400;
#endif

        KiFreezeOwner = Prcb;
        Prcb->IpiFrozen = FREEZE_OWNER | FREEZE_ACTIVE;
        Prcb->SkipTick  = TRUE;
        KiIpiSend((KAFFINITY) TargetSet, IPI_FREEZE);
        while (TargetSet != 0) {
            KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
            ClearMember(BitNumber, TargetSet);
            Prcb = KiProcessorBlock[BitNumber];

#if IDBG

            while (Prcb->IpiFrozen != TARGET_FROZEN) {
                if (Count == 0) {
                    KiFreezeFlag |= FREEZE_SKIPPED_PROCESSOR;
                    break;
                }

                KeStallExecutionProcessor (10000);
                Count--;
            }

#else

            while (Prcb->IpiFrozen != TARGET_FROZEN) {
                KeYieldProcessor();
            }
#endif

        }
    }

    //
    // Save the old IRQL and return whether interrupts were previous enabled.
    //

    KiOldIrql = OldIrql;

#endif      // !defined(NT_UP)

    return Enable;
}

VOID
KiFreezeTargetExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function freezes the execution of the current running processor.
    If a trapframe is supplied to current state is saved into the prcb
    for the debugger.

Arguments:

    TrapFrame - Supplies a pointer to the trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to the exception frame that
        describes the trap.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    KIRQL OldIrql;
    PKPRCB Prcb;
    BOOLEAN Enable;
    KCONTINUE_STATUS Status;
    EXCEPTION_RECORD ExceptionRecord;

    Enable = KeDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    Prcb = KeGetCurrentPrcb();
    Prcb->IpiFrozen = TARGET_FROZEN;
    Prcb->SkipTick  = TRUE;
    if (TrapFrame != NULL) {
        KiSaveProcessorState(TrapFrame, ExceptionFrame);
    }

    //
    // Sweep the data cache in case this is a system crash and the bug
    // check code is attempting to write a crash dump file.
    //

    KeSweepCurrentDcache();

    //
    //  Wait for person requesting us to freeze to
    //  clear our frozen flag
    //

    while (FrozenState(Prcb->IpiFrozen) == TARGET_FROZEN) {
        if (Prcb->IpiFrozen & FREEZE_ACTIVE) {

            //
            // This processor has been made the active processor
            //
            if (TrapFrame) {
                RtlZeroMemory (&ExceptionRecord, sizeof ExceptionRecord);
                ExceptionRecord.ExceptionCode = STATUS_WAKE_SYSTEM_DEBUGGER;
                ExceptionRecord.ExceptionRecord  = &ExceptionRecord;
                ExceptionRecord.ExceptionAddress =
                    (PVOID)CONTEXT_TO_PROGRAM_COUNTER (&Prcb->ProcessorState.ContextFrame);

                Status = (KiDebugSwitchRoutine) (
                            &ExceptionRecord,
                            &Prcb->ProcessorState.ContextFrame,
                            FALSE
                            );

            } else {
                Status = ContinueError;
            }

            //
            // If status is anything other then, continue with next
            // processor then reselect master
            //

            if (Status != ContinueNextProcessor) {
                Prcb->IpiFrozen &= ~FREEZE_ACTIVE;
                KiFreezeOwner->IpiFrozen |= FREEZE_ACTIVE;
            }
        }
        KeYieldProcessor();
    }

    if (TrapFrame != NULL) {
        KiRestoreProcessorState(TrapFrame, ExceptionFrame);
    }

    Prcb->IpiFrozen = RUNNING;

    KeFlushCurrentTb();
    KeSweepCurrentIcache();

    KeLowerIrql(OldIrql);
    KeEnableInterrupts(Enable);
#endif      // !define(NT_UP)

    return;
}


KCONTINUE_STATUS
KeSwitchFrozenProcessor (
    IN ULONG ProcessorNumber
    )
{
#if !defined(NT_UP)
    PKPRCB TargetPrcb, CurrentPrcb;

    //
    // If Processor number is out of range, reselect current processor
    //

    if (ProcessorNumber >= (ULONG) KeNumberProcessors) {
        return ContinueProcessorReselected;
    }

    TargetPrcb = KiProcessorBlock[ProcessorNumber];
    CurrentPrcb = KeGetCurrentPrcb();

    //
    // Move active flag to correct processor.
    //

    CurrentPrcb->IpiFrozen &= ~FREEZE_ACTIVE;
    TargetPrcb->IpiFrozen  |= FREEZE_ACTIVE;

    //
    // If this processor is frozen in KiFreezeTargetExecution, return to it
    //

    if (FrozenState(CurrentPrcb->IpiFrozen) == TARGET_FROZEN) {
        return ContinueNextProcessor;
    }

    //
    // This processor must be FREEZE_OWNER, wait to be reselected as the
    // active processor
    //

    if (FrozenState(CurrentPrcb->IpiFrozen) != FREEZE_OWNER) {
        return ContinueError;
    }

    while (!(CurrentPrcb->IpiFrozen & FREEZE_ACTIVE)) {
        KeYieldProcessor();
    }

#endif  // !defined(NT_UP)

    //
    // Reselect this processor
    //

    return ContinueProcessorReselected;
}


VOID
KeThawExecution (
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function thaws the execution of all other processors in the host
    configuration and then returns to the caller. It is intended for use by
    the kernel debugger.

Arguments:

    Enable - Supplies the previous interrupt enable that is to be restored
        after having thawed the execution of all other processors.

Return Value:

    None.

--*/

{
#if !defined(NT_UP)

    KIRQL OldIrql;
    KAFFINITY TargetSet;
    ULONG BitNumber;
    ULONG Flag;
    PKPRCB Prcb;

    //
    // Before releasing FreezeExecutionLock clear any all targets IpiFrozen
    // flag.
    //

    KeGetCurrentPrcb()->IpiFrozen = RUNNING;

    TargetSet = KeActiveProcessors & ~(AFFINITY_MASK(KeGetCurrentPrcb()->Number));
    while (TargetSet != 0) {
        KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
        ClearMember(BitNumber, TargetSet);
        Prcb = KiProcessorBlock[BitNumber];
#if IDBG
        //
        // If the target processor was not forzen, then don't wait
        // for target to unfreeze.
        //

        if (FrozenState(Prcb->IpiFrozen) != TARGET_FROZEN) {
            Prcb->IpiFrozen = RUNNING;
            continue;
        }
#endif

        Prcb->IpiFrozen = TARGET_THAW;
        while (Prcb->IpiFrozen == TARGET_THAW) {
            KeYieldProcessor();
        }
    }

    //
    // Capture the previous IRQL before releasing the freeze lock.
    //

    OldIrql = KiOldIrql;

#if IDBG

    Flag = KiFreezeFlag;
    KiFreezeFlag = 0;

    if ((Flag & FREEZE_BACKUP) != 0) {
        KiReleaseSpinLock(&KiFreezeLockBackup);
    } else {
        KiReleaseSpinLock(&KiFreezeExecutionLock);
    }

#else

    KiFreezeFlag = 0;
    KiReleaseSpinLock(&KiFreezeExecutionLock);

#endif
#endif  // !defined (NT_UP)


    //
    // Flush the current TB, instruction cache, and data cache.
    //

    KeFlushCurrentTb();
    KeSweepCurrentIcache();
    KeSweepCurrentDcache();

    //
    // Lower IRQL and restore interrupt enable
    //

#if !defined(NT_UP)
    KeLowerIrql(OldIrql);
#endif
    KeEnableInterrupts(Enable);
    return;
}

VOID
KiPollFreezeExecution(
    VOID
    )

/*++

Routine Description:

    This routine is called from code that is spinning with interrupts
    disabled, waiting for something to happen, when there is some
    (possibly extremely small) chance that that thing will not happen
    because a system freeze has been initiated.

    N.B. Interrupts are disabled.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Check to see if a freeze is pending for this processor.
    //

    PKPRCB Prcb = KeGetCurrentPrcb();

    if ((Prcb->RequestSummary & IPI_FREEZE) != 0) {

        //
        // Clear the freeze request and freeze this processor.
        //

        InterlockedExchangeAdd((PLONG)&Prcb->RequestSummary, -(IPI_FREEZE));
        KiFreezeTargetExecution(NULL, NULL);

    } else {

        //
        // No freeze pending, assume this processor is spinning.
        //

        KeYieldProcessor();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\apcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apcsup.c

Abstract:

    This module contains the support routines for the APC object. Functions
    are provided to insert in an APC queue and to deliver user and kernel
    mode APC's.

Author:

    David N. Cutler (davec) 14-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define function prototypes for labels that delineate the bounds of the
// pop SLIST code that is susceptable to causing corruption on suspend
// operations.
//

VOID
ExpInterlockedPopEntrySListEnd (
    VOID
    );

VOID
ExpInterlockedPopEntrySListResume (
    VOID
    );

VOID
KiDeliverApc (
    IN KPROCESSOR_MODE PreviousMode,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called from the APC interrupt code and when one or
    more of the APC pending flags are set at system exit and the previous
    IRQL is zero. All special kernel APC's are delivered first, followed
    by normal kernel APC's if one is not already in progress, and finally
    if the user APC queue is not empty, the user APC pending flag is set,
    and the previous mode is user, then a user APC is delivered. On entry
    to this routine IRQL is set to APC_LEVEL.

    N.B. The exception frame and trap frame addresses are only guaranteed
         to be valid if, and only if, the previous mode is user.

Arguments:

    PreviousMode - Supplies the previous processor mode.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    ULONG64 NewPC;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    ULONG64 PC; 
    PKPROCESS Process;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;
    PKTRAP_FRAME OldTrapFrame;

    //
    // If the thread was interrupted in the middle of the SLIST pop code,
    // then back up the PC to the start of the SLIST pop. 
    //

    if (TrapFrame != NULL) {

#if defined(_AMD64_)

        if ((TrapFrame->Rip >= (ULONG64)&ExpInterlockedPopEntrySListResume) &&
            (TrapFrame->Rip <= (ULONG64)&ExpInterlockedPopEntrySListEnd)) {

            TrapFrame->Rip = (ULONG64)&ExpInterlockedPopEntrySListResume;
        }

#elif defined(_IA64_)

        //
        // Add the slot number so we do the right thing for the instruction
        // group containing the interlocked compare exchange.
        //

        PC = TrapFrame->StIIP + ((TrapFrame->StIPSR & IPSR_RI_MASK) >> PSR_RI);
        NewPC = (ULONG64)((PPLABEL_DESCRIPTOR)ExpInterlockedPopEntrySListResume)->EntryPoint;
        if ((PC >= NewPC) &&
            (PC <= (ULONG64)((PPLABEL_DESCRIPTOR)ExpInterlockedPopEntrySListEnd)->EntryPoint)) {

            TrapFrame->StIIP = NewPC;
            TrapFrame->StIPSR &= ~IPSR_RI_MASK;
        }

#elif defined(_X86_)

        if ((TrapFrame->Eip >= (ULONG)&ExpInterlockedPopEntrySListResume) &&
            (TrapFrame->Eip <= (ULONG)&ExpInterlockedPopEntrySListEnd)) {

            TrapFrame->Eip = (ULONG)&ExpInterlockedPopEntrySListResume;
        }

#else
#error "No Target Architecture"
#endif

    }

    //
    // Raise IRQL to dispatcher level and lock the APC queue.
    //

    Thread = KeGetCurrentThread();

    OldTrapFrame = Thread->TrapFrame;
    Thread->TrapFrame = TrapFrame;

    Process = Thread->ApcState.Process;
    KeAcquireInStackQueuedSpinLock(&Thread->ApcQueueLock, &LockHandle);

    //
    // Get address of current thread object, clear kernel APC pending, and
    // check if any kernel mode APC's can be delivered.
    //

    Thread->ApcState.KernelApcPending = FALSE;
    while (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
        NextEntry = Thread->ApcState.ApcListHead[KernelMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {

            //
            // First entry in the kernel APC queue is a special kernel APC.
            // Remove the entry from the APC queue, set its inserted state
            // to FALSE, release dispatcher database lock, and call the kernel
            // routine. On return raise IRQL to dispatcher level and lock
            // dispatcher database lock.
            //

            RemoveEntryList(NextEntry);
            Apc->Inserted = FALSE;
            KeReleaseInStackQueuedSpinLock(&LockHandle);
            (KernelRoutine)(Apc,
                            &NormalRoutine,
                            &NormalContext,
                            &SystemArgument1,
                            &SystemArgument2);

#if DBG

            if (KeGetCurrentIrql() != LockHandle.OldIrql) {
                KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                             KeGetCurrentIrql() << 16 | LockHandle.OldIrql << 8,
                             (ULONG_PTR)KernelRoutine,
                             (ULONG_PTR)Apc,
                             (ULONG_PTR)NormalRoutine);
            }

#endif

            KeAcquireInStackQueuedSpinLock(&Thread->ApcQueueLock, &LockHandle);

        } else {

            //
            // First entry in the kernel APC queue is a normal kernel APC.
            // If there is not a normal kernel APC in progress and kernel
            // APC's are not disabled, then remove the entry from the APC
            // queue, set its inserted state to FALSE, release the APC queue
            // lock, call the specified kernel routine, set kernel APC in
            // progress, lower the IRQL to zero, and call the normal kernel
            // APC routine. On return raise IRQL to dispatcher level, lock
            // the APC queue, and clear kernel APC in progress.
            //

            if ((Thread->ApcState.KernelApcInProgress == FALSE) &&
               (Thread->KernelApcDisable == 0)) {
                RemoveEntryList(NextEntry);
                Apc->Inserted = FALSE;
                KeReleaseInStackQueuedSpinLock(&LockHandle);
                (KernelRoutine)(Apc,
                                &NormalRoutine,
                                &NormalContext,
                                &SystemArgument1,
                                &SystemArgument2);

#if DBG

                if (KeGetCurrentIrql() != LockHandle.OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | LockHandle.OldIrql << 8 | 1,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }

#endif

                if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
                    Thread->ApcState.KernelApcInProgress = TRUE;
                    KeLowerIrql(0);
                    (NormalRoutine)(NormalContext,
                                    SystemArgument1,
                                    SystemArgument2);

                    KeRaiseIrql(APC_LEVEL, &LockHandle.OldIrql);
                }

                KeAcquireInStackQueuedSpinLock(&Thread->ApcQueueLock, &LockHandle);
                Thread->ApcState.KernelApcInProgress = FALSE;

            } else {
                KeReleaseInStackQueuedSpinLock(&LockHandle);
                goto CheckProcess;
            }
        }
    }

    //
    // Kernel APC queue is empty. If the previous mode is user, user APC
    // pending is set, and the user APC queue is not empty, then remove
    // the first entry from the user APC queue, set its inserted state to
    // FALSE, clear user APC pending, release the dispatcher database lock,
    // and call the specified kernel routine. If the normal routine address
    // is not NULL on return from the kernel routine, then initialize the
    // user mode APC context and return. Otherwise, check to determine if
    // another user mode APC can be processed.
    //

    if ((IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE) &&
       (PreviousMode == UserMode) && (Thread->ApcState.UserApcPending != FALSE)) {
        Thread->ApcState.UserApcPending = FALSE;
        NextEntry = Thread->ApcState.ApcListHead[UserMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        RemoveEntryList(NextEntry);
        Apc->Inserted = FALSE;
        KeReleaseInStackQueuedSpinLock(&LockHandle);
        (KernelRoutine)(Apc,
                        &NormalRoutine,
                        &NormalContext,
                        &SystemArgument1,
                        &SystemArgument2);

        if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {
            KeTestAlertThread(UserMode);

        } else {
            KiInitializeUserApc(ExceptionFrame,
                                TrapFrame,
                                NormalRoutine,
                                NormalContext,
                                SystemArgument1,
                                SystemArgument2);
        }

    } else {
        KeReleaseInStackQueuedSpinLock(&LockHandle);
    }

    //
    // Check if process was attached during the APC routine.
    //

CheckProcess:
    if (Thread->ApcState.Process != Process) {
        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    Thread->TrapFrame = OldTrapFrame;
    return;
}

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into a thread's APC queue. The address
    of the thread object, the APC queue, and the type of APC are all derived
    from the APC object. If the APC object is already in an APC queue, then
    no opertion is performed and a function value of FALSE is returned. Else
    the APC is inserted in the specified APC queue, its inserted state is set
    to TRUE, and a function value of TRUE is returned. The APC will actually
    be delivered when proper enabling conditions exist.

    N.B. The thread APC queue lock and the dispatcher database lock must both
         be held when this routine is called.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    KPROCESSOR_MODE ApcMode;
    PKAPC ApcEntry;
    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    PLIST_ENTRY ListEntry;
    PKTHREAD Thread;

    //
    // If the APC object is already in an APC queue, then set inserted to
    // FALSE. Else insert the APC object in the proper queue, set the APC
    // inserted state to TRUE, check to determine if the APC should be delivered
    // immediately, and set inserted to TRUE.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that kernel APC disable count is incremented before checking whether
    // the kernel APC queue is nonempty.
    //
    // See KeLeaveCriticalRegion().
    //

    Thread = Apc->Thread;
    if (Apc->Inserted) {
        Inserted = FALSE;

    } else {
        if (Apc->ApcStateIndex == InsertApcEnvironment) {
            Apc->ApcStateIndex = Thread->ApcStateIndex;
        }

        ApcState = Thread->ApcStatePointer[Apc->ApcStateIndex];

        //
        // Insert the APC after all other special APC entries selected by
        // the processor mode if the normal routine value is NULL. Else
        // insert the APC object at the tail of the APC queue selected by
        // the processor mode unless the APC mode is user and the address
        // of the special APC routine is exit thread, in which case insert
        // the APC at the front of the list and set user APC pending.
        //

        ApcMode = Apc->ApcMode;
        if (Apc->NormalRoutine != NULL) {
            if ((ApcMode != KernelMode) && (Apc->KernelRoutine == PsExitSpecialApc)) {
                Thread->ApcState.UserApcPending = TRUE;
                InsertHeadList(&ApcState->ApcListHead[ApcMode],
                               &Apc->ApcListEntry);

            } else {
                InsertTailList(&ApcState->ApcListHead[ApcMode],
                               &Apc->ApcListEntry);
            }

        } else {
            ListEntry = ApcState->ApcListHead[ApcMode].Blink;
            while (ListEntry != &ApcState->ApcListHead[ApcMode]) {
                ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry);
                if (ApcEntry->NormalRoutine == NULL) {
                    break;
                }

                ListEntry = ListEntry->Blink;
            }

            InsertHeadList(ListEntry, &Apc->ApcListEntry);
        }

        Apc->Inserted = TRUE;

        //
        // If the APC index from the APC object matches the APC Index of
        // the thread, then check to determine if the APC should interrupt
        // thread execution or sequence the thread out of a wait state.
        //

        if (Apc->ApcStateIndex == Thread->ApcStateIndex) {

            //
            // If the processor mode of the APC is kernel, then check if
            // the APC should either interrupt the thread or sequence the
            // thread out of a Waiting state. Else check if the APC should
            // sequence the thread out of an alertable Waiting state.
            //

            if (ApcMode == KernelMode) {
                Thread->ApcState.KernelApcPending = TRUE;
                if (Thread->State == Running) {
                    KiRequestApcInterrupt(Thread->NextProcessor);

                } else if ((Thread->State == Waiting) &&
                          (Thread->WaitIrql == 0) &&
                          ((Apc->NormalRoutine == NULL) ||
                          ((Thread->KernelApcDisable == 0) &&
                          (Thread->ApcState.KernelApcInProgress == FALSE)))) {

                    KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment, NULL);
                }

            } else if ((Thread->State == Waiting) &&
                      (Thread->WaitMode == UserMode) &&
                      (Thread->Alertable || Thread->ApcState.UserApcPending)) {

                Thread->ApcState.UserApcPending = TRUE;
                KiUnwaitThread(Thread, STATUS_USER_APC, Increment, NULL);
            }
        }

        Inserted = TRUE;
    }

    //
    // Return whether the APC object was inserted in an APC queue.
    //

    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\devquobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devquobj.c

Abstract:

    This module implements the kernel device queue object. Functions are
    provided to initialize a device queue object and to insert and remove
    device queue entries in a device queue object.

Author:

    David N. Cutler (davec) 1-Apr-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input device queue
// is really a kdevice_queue and not something else, like deallocated pool.
//

#define ASSERT_DEVICE_QUEUE(E) {            \
    ASSERT((E)->Type == DeviceQueueObject); \
}


VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function initializes a kernel device queue object.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

    SpinLock - Supplies a pointer to an executive spin lock.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    DeviceQueue->Type = DeviceQueueObject;
    DeviceQueue->Size = sizeof(KDEVICE_QUEUE);

    //
    // Initialize the device queue list head, spin lock, and busy indicator.
    //

    InitializeListHead(&DeviceQueue->DeviceListHead);
    KeInitializeSpinLock(&DeviceQueue->Lock);
    DeviceQueue->Busy = FALSE;
    return;
}

BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function inserts a device queue entry at the tail of the specified
    device queue. If the device is not busy, then it is set busy and the entry
    is not placed in the device queue. Otherwise the specified entry is placed
    at the end of the device queue.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(&DeviceQueue->Lock, &LockHandle);

    //
    // Insert the specified device queue entry at the end of the device queue
    // if the device queue is busy. Otherwise set the device queue busy and
    // don't insert the device queue entry.
    //

    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        InsertTailList(&DeviceQueue->DeviceListHead,
                       &DeviceQueueEntry->DeviceListEntry);

    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }

    DeviceQueueEntry->Inserted = Inserted;

    //
    // Unlock specified device queue.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    return Inserted;
}

BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY QueueEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(&DeviceQueue->Lock, &LockHandle);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device queue
    // entry.
    //

    DeviceQueueEntry->SortKey = SortKey;
    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            QueueEntry = CONTAINING_RECORD(NextEntry,
                                           KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);

            if (SortKey < QueueEntry->SortKey) {
                break;
            }

            NextEntry = NextEntry->Flink;
        }

        NextEntry = NextEntry->Blink;
        InsertHeadList(NextEntry, &DeviceQueueEntry->DeviceListEntry);

    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }

    DeviceQueueEntry->Inserted = Inserted;

    //
    // Unlock specified device queue.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    return Inserted;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function removes an entry from the head of the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the next entry is removed
    from the head of the device queue and the address of device queue entry
    is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    ASSERT(DeviceQueue->Busy == TRUE);

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = NULL;

    } else {
        NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
        DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                             KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);

        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the an entry is removed
    from the device queue and the address of device queue entry
    is returned.  The queue is search for the first entry which has a value
    greater than or equal to the SortKey.  If no such entry is found then the
    first entry of the queue is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    ASSERT(DeviceQueue->Busy == TRUE);

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = NULL;

    } else {
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                 KDEVICE_QUEUE_ENTRY,
                                                 DeviceListEntry);

            if (SortKey <= DeviceQueueEntry->SortKey) {
                break;
            }

            NextEntry = NextEntry->Flink;
        }

        if (NextEntry != &DeviceQueue->DeviceListHead) {
            RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);

        } else {
            NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                 KDEVICE_QUEUE_ENTRY,
                                                 DeviceListEntry);
        }

        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device queue if and
    only if the device is currently busy. If the device queue is empty or
    the device is not busy, then the device is set Not-Busy and a NULL is
    returned. Otherwise, an entry is removed from the device queue and the
    address of device queue entry is returned. The queue is search for the
    first entry which has a value greater than or equal to the SortKey. If
    no such entry is found then the first entry of the queue is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLockAtDpcLevel(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is busy, then attempt to remove an entry from
    // the queue using the sort key. Otherwise, set the device queue not
    // busy.
    //

    if (DeviceQueue->Busy != FALSE) {
        if (IsListEmpty(&DeviceQueue->DeviceListHead) != FALSE) {
            DeviceQueue->Busy = FALSE;
            DeviceQueueEntry = NULL;

        } else {
            NextEntry = DeviceQueue->DeviceListHead.Flink;
            while (NextEntry != &DeviceQueue->DeviceListHead) {
                DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);

                if (SortKey <= DeviceQueueEntry->SortKey) {
                    break;
                }

                NextEntry = NextEntry->Flink;
            }

            if (NextEntry != &DeviceQueue->DeviceListHead) {
                RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);

            } else {
                NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
                DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);
            }

            DeviceQueueEntry->Inserted = FALSE;
        }

    } else {
        DeviceQueueEntry = NULL;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    return DeviceQueueEntry;
}

BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function removes a specified entry from the the specified device
    queue. If the device queue entry is not in the device queue, then no
    operation is performed. Otherwise the specified device queue entry is
    removed from the device queue and its inserted status is set to FALSE.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry which is to
        be removed from its device queue.

Return Value:

    A value of TRUE is returned if the device queue entry is removed from its
    device queue. Otherwise a value of FALSE is returned.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    BOOLEAN Removed;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLock(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue entry is not in a device queue, then no operation
    // is performed. Otherwise remove the specified device queue entry from its
    // device queue.
    //

    Removed = DeviceQueueEntry->Inserted;
    if (Removed == TRUE) {
        DeviceQueueEntry->Inserted = FALSE;
        RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);
    }

    //
    // Unlock specified device queue, lower IRQL to its previous level, and
    // return whether the device queue entry was removed from its queue.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Removed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\config.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This module implements the code to find an ARC configuration tree
    entry as constructed by the OS Loader.

Author:

    David N. Cutler (davec) 9-Sep-1991

Environment:

    User mode only.

Revision History:

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KeFindConfigurationEntry)
#pragma alloc_text(INIT,KeFindConfigurationNextEntry)
#endif

PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL
    )
/*++

Routine Description:

    This function search the specified configuration tree and returns a
    pointer to an entry that matches the specified class, type, and key
    parameters.

    This routine is the same as KeFindConfurationEntryNext expect
    that the search is performed from the first entry

    N.B. This routine can only be called during system initialization.

--*/
{
    PCONFIGURATION_COMPONENT_DATA Resume;

    Resume = NULL;
    return KeFindConfigurationNextEntry (Child, Class, Type, Key, &Resume);
}

PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationNextEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL,
    IN PCONFIGURATION_COMPONENT_DATA *Resume
    )

/*++

Routine Description:

    This function search the specified configuration tree and returns a
    pointer to an entry that matches the specified class, type, and key
    parameters.

    N.B. This routine can only be called during system initialization.

Arguments:

    Child - Supplies an optional pointer to an NT configuration component.

    Class - Supplies the configuration class of the entry to locate.

    Type - Supplies the configuration type of the entry to locate.

    Key - Supplies a pointer to an optional key value to use in locating
        the specified entry.

    Resume - Supplies the last returned entry for which the search
        should resume from.

Return Value:

    If the specified entry is located, then a pointer to the configuration
    entry is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PCONFIGURATION_COMPONENT_DATA Entry;
    ULONG MatchKey;
    ULONG MatchMask;
    PCONFIGURATION_COMPONENT_DATA Sibling;

    //
    // Initialize the match key and mask based on whether the optional key
    // value is specified.
    //

    if (ARGUMENT_PRESENT(Key)) {
        MatchMask = 0xffffffff;
        MatchKey = *Key;

    } else {
        MatchMask = 0;
        MatchKey = 0;
    }

    //
    // Search specified configuration tree for an entry that matches the
    // the specified class, type, and key.
    //

    while (Child != NULL) {
        if (*Resume) {
            //
            // If resume location found, clear resume location and continue
            // search with next entry
            //

            if (Child == *Resume) {
                *Resume = NULL;
            }
        } else {

            //
            // If the class, type, and key match, then return a pointer to
            // the child entry.
            //

            if ((Child->ComponentEntry.Class == Class) &&
                (Child->ComponentEntry.Type == Type) &&
                ((Child->ComponentEntry.Key & MatchMask) == MatchKey)) {
                return Child;
            }
        }

        //
        // If the child has a sibling list, then search the sibling list
        // for an entry that matches the specified class, type, and key.
        //

        Sibling = Child->Sibling;
        while (Sibling != NULL) {
            if (*Resume) {
                //
                // If resume location found, clear resume location and continue
                // search with next entry
                //

                if (Sibling == *Resume) {
                    *Resume = NULL;
                }
            } else {

                //
                // If the class, type, and key match, then return a pointer to
                // the child entry.
                //

                if ((Sibling->ComponentEntry.Class == Class) &&
                    (Sibling->ComponentEntry.Type == Type) &&
                    ((Sibling->ComponentEntry.Key & MatchMask) == MatchKey)) {
                    return Sibling;
                }
            }

            //
            // If the sibling has a child tree, then search the child tree
            // for an entry that matches the specified class, type, and key.
            //

            if (Sibling->Child != NULL) {
               Entry = KeFindConfigurationNextEntry (
                                Sibling->Child,
                                Class,
                                Type,
                                Key,
                                Resume
                                );

               if (Entry != NULL) {
                   return Entry;
               }
            }

            Sibling = Sibling->Sibling;
        }

        Child = Child->Child;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\bugcheck.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements bug check and system shutdown code.

Author:

    Mark Lucovsky (markl) 30-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <inbv.h>
#include <hdlsblk.h>
#include <hdlsterm.h>

//
//
//

extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;

extern PVOID ExPoolCodeStart;
extern PVOID ExPoolCodeEnd;
extern PVOID MmPoolCodeStart;
extern PVOID MmPoolCodeEnd;
extern PVOID MmPteCodeStart;
extern PVOID MmPteCodeEnd;

#if defined(_AMD64_)

#define PROGRAM_COUNTER(_trapframe) ((_trapframe)->Rip)

#elif defined(_X86_)

#define PROGRAM_COUNTER(_trapframe) ((_trapframe)->Eip)

#elif defined(_IA64_)

#define PROGRAM_COUNTER(_trapframe) ((_trapframe)->StIIP)

#else

#error "no target architecture"

#endif

//
// Define forward referenced prototypes.
//

VOID
KiScanBugCheckCallbackList (
    VOID
    );

VOID
KiInvokeBugCheckEntryCallbacks (
    VOID
    );

//
// Define bug count recursion counter and a context buffer.
//

ULONG KeBugCheckCount = 1;


VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )
{
    KeBugCheck2(BugCheckCode,0,0,0,0,NULL);
}

VOID
KeBugCheckEx (
    IN ULONG BugCheckCode,
    IN ULONG_PTR P1,
    IN ULONG_PTR P2,
    IN ULONG_PTR P3,
    IN ULONG_PTR P4
    )
{
    KeBugCheck2(BugCheckCode,P1,P2,P3,P4,NULL);
}

ULONG_PTR KiBugCheckData[5];
PUNICODE_STRING KiBugCheckDriver;

BOOLEAN
KeGetBugMessageText(
    IN ULONG MessageId,
    IN PANSI_STRING ReturnedString OPTIONAL
    )
{
    ULONG   i;
    PUCHAR  s;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PUCHAR Buffer;
    BOOLEAN Result;

    Result = FALSE;
    try {
        if (KiBugCodeMessages != NULL) {
            MmMakeKernelResourceSectionWritable ();
            MessageBlock = &KiBugCodeMessages->Blocks[0];
            for (i = KiBugCodeMessages->NumberOfBlocks; i; i -= 1) {
                if (MessageId >= MessageBlock->LowId &&
                    MessageId <= MessageBlock->HighId) {

                    s = (PCHAR)KiBugCodeMessages + MessageBlock->OffsetToEntries;
                    for (i = MessageId - MessageBlock->LowId; i; i -= 1) {
                        s += ((PMESSAGE_RESOURCE_ENTRY)s)->Length;
                    }

                    Buffer = ((PMESSAGE_RESOURCE_ENTRY)s)->Text;

                    i = strlen(Buffer) - 1;
                    while (i > 0 && (Buffer[i] == '\n'  ||
                                     Buffer[i] == '\r'  ||
                                     Buffer[i] == 0
                                    )
                          ) {
                        if (!ARGUMENT_PRESENT( ReturnedString )) {
                            Buffer[i] = 0;
                        }
                        i -= 1;
                    }

                    if (!ARGUMENT_PRESENT( ReturnedString )) {
                        InbvDisplayString(Buffer);
                        }
                    else {
                        ReturnedString->Buffer = Buffer;
                        ReturnedString->Length = (USHORT)(i+1);
                        ReturnedString->MaximumLength = (USHORT)(i+1);
                    }
                    Result = TRUE;
                    break;
                }
                MessageBlock += 1;
            }
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ;
    }

    return Result;
}



PCHAR
KeBugCheckUnicodeToAnsi(
    IN PUNICODE_STRING UnicodeString,
    OUT PCHAR AnsiBuffer,
    IN ULONG MaxAnsiLength
    )
{
    PCHAR Dst;
    PWSTR Src;
    ULONG Length;

    Length = UnicodeString->Length / sizeof( WCHAR );
    if (Length >= MaxAnsiLength) {
        Length = MaxAnsiLength - 1;
        }
    Src = UnicodeString->Buffer;
    Dst = AnsiBuffer;
    while (Length--) {
        *Dst++ = (UCHAR)*Src++;
        }
    *Dst = '\0';
    return AnsiBuffer;
}

VOID
KiBugCheckDebugBreak (
    IN ULONG    BreakStatus
    )
{
    do {

        try {

            //
            // Issue a breakpoint
            //

            DbgBreakPointWithStatus (BreakStatus);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            HEADLESS_RSP_QUERY_INFO Response;
            NTSTATUS Status;
            SIZE_T Length;

            //
            // Failed to issue the breakpoint, must be no debugger.  Now, give
            // the headless terminal a chance to reboot the system, if there is one.
            //
            Length = sizeof(HEADLESS_RSP_QUERY_INFO);
            Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            if (NT_SUCCESS(Status) &&
                (Response.PortType == HeadlessSerialPort) &&
                Response.Serial.TerminalAttached) {

                HeadlessDispatch(HeadlessCmdPutString,
                                 "\r\n",
                                 sizeof("\r\n"),
                                 NULL,
                                 NULL
                                );

                for (;;) {
                    HeadlessDispatch(HeadlessCmdDoBugCheckProcessing, NULL, 0, NULL, NULL);
                }

            }

            //
            // No terminal, or it failed, halt the system
            //

            try {

                HalHaltSystem();

            } except(EXCEPTION_EXECUTE_HANDLER) {

                for (;;) {
                }

            }
        }
    } while (BreakStatus != DBG_STATUS_BUGCHECK_FIRST);
}

PVOID
KiPcToFileHeader(
    IN PVOID PcValue,
    OUT PLDR_DATA_TABLE_ENTRY *DataTableEntry,
    IN LOGICAL DriversOnly,
    OUT PBOOLEAN InKernelOrHal
    )

/*++

Routine Description:

    This function returns the base of an image that contains the
    specified PcValue. An image contains the PcValue if the PcValue
    is within the ImageBase, and the ImageBase plus the size of the
    virtual image.

Arguments:

    PcValue - Supplies a PcValue.

    DataTableEntry - Supplies a pointer to a variable that receives the
        address of the data table entry that describes the image.

    DriversOnly - Supplies TRUE if the kernel and HAL should be skipped.

    InKernelOrHal - Set to TRUE if the PcValue is in the kernel or the HAL.
        This only has meaning if DriversOnly is FALSE.

Return Value:

    NULL - No image was found that contains the PcValue.

    NON-NULL - Returns the base address of the image that contains the
        PcValue.

--*/

{
    ULONG i;
    PLIST_ENTRY ModuleListHead;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Next;
    ULONG_PTR Bounds;
    PVOID ReturnBase, Base;

    //
    // If the module list has been initialized, then scan the list to
    // locate the appropriate entry.
    //

    if (KeLoaderBlock != NULL) {
        ModuleListHead = &KeLoaderBlock->LoadOrderListHead;

    } else {
        ModuleListHead = &PsLoadedModuleList;
    }

    *InKernelOrHal = FALSE;

    ReturnBase = NULL;
    Next = ModuleListHead->Flink;
    if (Next != NULL) {
        i = 0;
        while (Next != ModuleListHead) {
            if (MmIsAddressValid(Next) == FALSE) {
                return NULL;
            }
            i += 1;
            if ((i <= 2) && (DriversOnly == TRUE)) {
                Next = Next->Flink;
                continue;
            }

            Entry = CONTAINING_RECORD(Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InLoadOrderLinks);

            Next = Next->Flink;
            Base = Entry->DllBase;
            Bounds = (ULONG_PTR)Base + Entry->SizeOfImage;
            if ((ULONG_PTR)PcValue >= (ULONG_PTR)Base && (ULONG_PTR)PcValue < Bounds) {
                *DataTableEntry = Entry;
                ReturnBase = Base;
                if (i <= 2) {
                    *InKernelOrHal = TRUE;
                }
                break;
            }
        }
    }

    return ReturnBase;
}



VOID
KiDumpParameterImages(
    IN PCHAR Buffer,
    IN PULONG_PTR BugCheckParameters,
    IN ULONG NumberOfParameters,
    IN PKE_BUGCHECK_UNICODE_TO_ANSI UnicodeToAnsiRoutine
    )

/*++

Routine Description:

    This function formats and displays the image names of boogcheck parameters
    that happen to match an address in an image.

Arguments:

    Buffer - Supplies a pointer to a buffer to be used to output machine
        state information.

    BugCheckParameters - Supplies additional bugcheck information.

    NumberOfParameters - sizeof BugCheckParameters array.
        if just 1 parameter is passed in, just save the string.

    UnicodeToAnsiRoutine - Supplies a pointer to a routine to convert Unicode
        strings to Ansi strings without touching paged translation tables.

Return Value:

    None.

--*/

{
    PUNICODE_STRING BugCheckDriver;
    ULONG i;
    PLDR_DATA_TABLE_ENTRY DataTableEntry;
    PVOID ImageBase;
    UCHAR AnsiBuffer[ 32 ];
    ULONG DateStamp;
    PIMAGE_NT_HEADERS NtHeaders;
    BOOLEAN FirstPrint = TRUE;
    BOOLEAN InKernelOrHal;
    PUNICODE_STRING DriverName;

    //
    // At this point the context record contains the machine state at the
    // call to bug check.
    //
    // Put out the system version and the title line with the PSR and FSR.
    //

    //
    // Check to see if any BugCheckParameters are valid code addresses.
    // If so, print them for the user.
    //

    DriverName = NULL;

    for (i = 0; i < NumberOfParameters; i += 1)
    {
        DateStamp = 0;
        ImageBase = KiPcToFileHeader((PVOID) BugCheckParameters[i],
                                     &DataTableEntry,
                                     TRUE,
                                     &InKernelOrHal);
        if (ImageBase == NULL)
        {
            BugCheckDriver = MmLocateUnloadedDriver ((PVOID)BugCheckParameters[i]);
            if (BugCheckDriver == NULL)
            {
                continue;
            }
            DriverName = BugCheckDriver;
            ImageBase = (PVOID)BugCheckParameters[i];
            (*UnicodeToAnsiRoutine) (BugCheckDriver,
                                     AnsiBuffer,
                                     sizeof (AnsiBuffer));
        }
        else
        {
            if (MmIsAddressValid(DataTableEntry->DllBase) == TRUE)
            {
                NtHeaders = RtlImageNtHeader(DataTableEntry->DllBase);
                if (NtHeaders)
                {
                    DateStamp = NtHeaders->FileHeader.TimeDateStamp;
                }
            }
            DriverName = &DataTableEntry->BaseDllName;
            (*UnicodeToAnsiRoutine)( DriverName,
                                     AnsiBuffer,
                                     sizeof( AnsiBuffer ));
        }

        sprintf(Buffer, "%s**  %12s - Address %p base at %p, DateStamp %08lx\n",
                FirstPrint ? "\n*":"*",
                AnsiBuffer,
                (PVOID)BugCheckParameters[i],
                ImageBase,
                DateStamp);

        //
        // Only print the string if we are called to print multiple.
        //

        if (NumberOfParameters > 1)
        {
            InbvDisplayString(Buffer);
        }
        else
        {
            KiBugCheckDriver = DriverName;
        }

        FirstPrint = FALSE;
    }

    return;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
KeBugCheck2 (
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN PVOID SaveDataPage
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

    BugCheckParameter1-4 - Supplies additional bug check information

Return Value:

    None.

--*/

{
    UCHAR Buffer[103];
    CONTEXT ContextSave;
    ULONG PssMessage;
    PCHAR HardErrorCaption = NULL;
    PCHAR HardErrorMessage = NULL;
    KIRQL OldIrql;
    PKTRAP_FRAME TrapInformation;
    PVOID ExecutionAddress = NULL;
    PVOID ImageBase;
    PVOID VirtualAddress;
    PLDR_DATA_TABLE_ENTRY DataTableEntry;
    CHAR AnsiBuffer[100];
    PKTHREAD Thread = KeGetCurrentThread();
    BOOLEAN InKernelOrHal;
    BOOLEAN Reboot;

#if !defined(NT_UP)

    KAFFINITY TargetSet;

#endif
    BOOLEAN hardErrorCalled = FALSE;

    //
    // Initialization
    //
    
    Reboot = FALSE;
    KiBugCheckDriver = NULL;

    //
    // Try to simulate a power failure for Cluster testing
    //

    if (BugCheckCode == POWER_FAILURE_SIMULATE) {
        KiScanBugCheckCallbackList();
        HalReturnToFirmware(HalRebootRoutine);
    }

    //
    // Capture the callers context as closely as possible into the debugger's
    // processor state area of the Prcb.
    //
    // N.B. There may be some prologue code that shuffles registers such that
    //      they get destroyed.
    //

#if defined(_X86_)

    KiSetHardwareTrigger();

#else

    InterlockedIncrement64((LONGLONG volatile *)&KiHardwareTrigger);

#endif

    RtlCaptureContext(&KeGetCurrentPrcb()->ProcessorState.ContextFrame);
    KiSaveProcessorControlState(&KeGetCurrentPrcb()->ProcessorState);

    //
    // This is necessary on machines where the virtual unwind that happens
    // during KeDumpMachineState() destroys the context record.
    //

    ContextSave = KeGetCurrentPrcb()->ProcessorState.ContextFrame;

    //
    // Get the correct string for bugchecks
    //


    switch (BugCheckCode) {

        case SYSTEM_THREAD_EXCEPTION_NOT_HANDLED:
        case KERNEL_MODE_EXCEPTION_NOT_HANDLED:
        case KMODE_EXCEPTION_NOT_HANDLED:
            PssMessage = KMODE_EXCEPTION_NOT_HANDLED;
            break;

        case DATA_BUS_ERROR:
        case NO_MORE_SYSTEM_PTES:
        case INACCESSIBLE_BOOT_DEVICE:
        case UNEXPECTED_KERNEL_MODE_TRAP:
        case ACPI_BIOS_ERROR:
        case ACPI_BIOS_FATAL_ERROR:
        case FAT_FILE_SYSTEM:
        case DRIVER_CORRUPTED_EXPOOL:
        case THREAD_STUCK_IN_DEVICE_DRIVER:
            PssMessage = BugCheckCode;
            break;

        case DRIVER_CORRUPTED_MMPOOL:
            PssMessage = DRIVER_CORRUPTED_EXPOOL;
            break;

        case NTFS_FILE_SYSTEM:
            PssMessage = FAT_FILE_SYSTEM;
            break;

        case STATUS_SYSTEM_IMAGE_BAD_SIGNATURE:
            PssMessage = BUGCODE_PSS_MESSAGE_SIGNATURE;
            break;
        default:
            PssMessage = BUGCODE_PSS_MESSAGE;
        break;
    }


    //
    // Do further processing on bugcheck codes
    //


    KiBugCheckData[0] = BugCheckCode;
    KiBugCheckData[1] = BugCheckParameter1;
    KiBugCheckData[2] = BugCheckParameter2;
    KiBugCheckData[3] = BugCheckParameter3;
    KiBugCheckData[4] = BugCheckParameter4;

    switch (BugCheckCode) {

    case FATAL_UNHANDLED_HARD_ERROR:
        //
        // If we are called by hard error then we don't want to dump the
        // processor state on the machine.
        //
        // We know that we are called by hard error because the bug check
        // code will be FATAL_UNHANDLED_HARD_ERROR.  If this is so then the
        // error status passed to harderr is the first parameter, and a pointer
        // to the parameter array from hard error is passed as the second
        // argument.
        //
        // The third argument is the OemCaption to be printed.
        // The last argument is the OemMessage to be printed.
        //
        {
        PULONG_PTR parameterArray;

        hardErrorCalled = TRUE;

        HardErrorCaption = (PCHAR)BugCheckParameter3;
        HardErrorMessage = (PCHAR)BugCheckParameter4;
        parameterArray = (PULONG_PTR)BugCheckParameter2;
        KiBugCheckData[0] = (ULONG)BugCheckParameter1;
        KiBugCheckData[1] = parameterArray[0];
        KiBugCheckData[2] = parameterArray[1];
        KiBugCheckData[3] = parameterArray[2];
        KiBugCheckData[4] = parameterArray[3];
        }
        break;

    case IRQL_NOT_LESS_OR_EQUAL:

        ExecutionAddress = (PVOID)BugCheckParameter4;

        if (ExecutionAddress >= ExPoolCodeStart && ExecutionAddress < ExPoolCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_EXPOOL;
        }
        else if (ExecutionAddress >= MmPoolCodeStart && ExecutionAddress < MmPoolCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_MMPOOL;
        }
        else if (ExecutionAddress >= MmPteCodeStart && ExecutionAddress < MmPteCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_SYSPTES;
        }
        else {
            ImageBase = KiPcToFileHeader (ExecutionAddress,
                                          &DataTableEntry,
                                          FALSE,
                                          &InKernelOrHal);
            if (InKernelOrHal == TRUE) {

                //
                // The kernel faulted at raised IRQL.  Quite often this
                // is a driver that has unloaded without deleting its
                // lookaside lists or other resources.  Or its resources
                // are marked pagable and shouldn't be.  Detect both
                // cases here and identify the offending driver
                // whenever possible.
                //

                VirtualAddress = (PVOID)BugCheckParameter1;

                ImageBase = KiPcToFileHeader (VirtualAddress,
                                              &DataTableEntry,
                                              TRUE,
                                              &InKernelOrHal);

                if (ImageBase != NULL) {
                    KiBugCheckDriver = &DataTableEntry->BaseDllName;
                    KiBugCheckData[0] = DRIVER_PORTION_MUST_BE_NONPAGED;
                }
                else {
                    KiBugCheckDriver = MmLocateUnloadedDriver (VirtualAddress);
                    if (KiBugCheckDriver != NULL) {
                        KiBugCheckData[0] = SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD;
                    }
                }
            }
            else {
                KiBugCheckData[0] = DRIVER_IRQL_NOT_LESS_OR_EQUAL;
            }
        }

        ExecutionAddress = NULL;
        break;

    case ATTEMPTED_WRITE_TO_READONLY_MEMORY:

        TrapInformation = (PKTRAP_FRAME)BugCheckParameter3;

        //
        // Extract the execution address from the trap frame to
        // identify the component.
        //

        if (TrapInformation != NULL) {
            ExecutionAddress = (PVOID) PROGRAM_COUNTER (TrapInformation);
        }

        break;

    case DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS:

        ExecutionAddress = (PVOID)BugCheckParameter1;
        break;

    case DRIVER_USED_EXCESSIVE_PTES:

        DataTableEntry = (PLDR_DATA_TABLE_ENTRY)BugCheckParameter1;
        KiBugCheckDriver = &DataTableEntry->BaseDllName;

        break;

    case PAGE_FAULT_IN_NONPAGED_AREA:

        ImageBase = NULL;

        //
        // Extract the execution address from the trap frame to
        // identify the component.
        //

        if (BugCheckParameter3) {

            ExecutionAddress = (PVOID)PROGRAM_COUNTER
                ((PKTRAP_FRAME)BugCheckParameter3);

            KiBugCheckData[3] = (ULONG_PTR)ExecutionAddress;

            ImageBase = KiPcToFileHeader (ExecutionAddress,
                                          &DataTableEntry,
                                          FALSE,
                                          &InKernelOrHal);
        }
        else {

            //
            // No trap frame, so no execution address either.
            //

            InKernelOrHal = TRUE;
        }

        VirtualAddress = (PVOID)BugCheckParameter1;

        if (MmIsSpecialPoolAddress (VirtualAddress) == TRUE) {

            //
            // Update the bugcheck number so the administrator gets
            // useful feedback that enabling special pool has enabled
            // the system to locate the corruptor.
            //

            if (MmIsSpecialPoolAddressFree (VirtualAddress) == TRUE) {
                if (InKernelOrHal == TRUE) {
                    KiBugCheckData[0] = PAGE_FAULT_IN_FREED_SPECIAL_POOL;
                }
                else {
                    KiBugCheckData[0] = DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL;
                }
            }
            else {
                if (InKernelOrHal == TRUE) {
                    KiBugCheckData[0] = PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
                }
                else {
                    KiBugCheckData[0] = DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
                }
            }
        }
        else if ((ExecutionAddress == VirtualAddress) &&
                (MmIsSessionAddress (VirtualAddress) == TRUE) &&
                ((Thread->Teb == NULL) || (IS_SYSTEM_ADDRESS(Thread->Teb)))) {
            //
            // This is a driver reference to session space from a
            // worker thread.  Since the system process has no session
            // space this is illegal and the driver must be fixed.
            //

            KiBugCheckData[0] = TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE;
        }
        else if (ImageBase == NULL) {
            KiBugCheckDriver = MmLocateUnloadedDriver (VirtualAddress);
            if (KiBugCheckDriver != NULL) {
                KiBugCheckData[0] = DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS;
            }
        }

        break;

    case THREAD_STUCK_IN_DEVICE_DRIVER:

        KiBugCheckDriver = (PUNICODE_STRING) BugCheckParameter3;
        break;

    default:
        break;
    }

    if (KiBugCheckDriver)
    {
        KeBugCheckUnicodeToAnsi(KiBugCheckDriver,
                                AnsiBuffer,
                                sizeof(AnsiBuffer));
    }
    else
    {
        //
        // This will set KiBugCheckDriver to 1 if successful.
        //

        if (ExecutionAddress)
        {
            KiDumpParameterImages(AnsiBuffer,
                                  (PULONG_PTR)&ExecutionAddress,
                                  1,
                                  KeBugCheckUnicodeToAnsi);
        }
    }

    if (KdPitchDebugger == FALSE ) {
        KdDebuggerDataBlock.SavedContext = (ULONG_PTR) &ContextSave;
    }

    //
    // If the user manually crashed the machine, skips the DbgPrints and
    // go to the crashdump.
    // Trying to do DbgPrint causes us to reeeter the debugger which causes
    // some problems.
    //
    // Otherwise, if the debugger is enabled, print out the information and
    // stop.
    //

    if ((BugCheckCode != MANUALLY_INITIATED_CRASH) &&
        (KdDebuggerEnabled)) {

        DbgPrint("\n*** Fatal System Error: 0x%08lx\n"
                 "                       (0x%p,0x%p,0x%p,0x%p)\n\n",
                 (ULONG)KiBugCheckData[0],
                 KiBugCheckData[1],
                 KiBugCheckData[2],
                 KiBugCheckData[3],
                 KiBugCheckData[4]);

        //
        // If the debugger is not actually connected, or the user manually
        // crashed the machine by typing .crash in the debugger, proceed to
        // "blue screen" the system.
        //
        // The call to DbgPrint above will have set the state of
        // KdDebuggerNotPresent if the debugger has become disconnected
        // since the system was booted.
        //

        if (KdDebuggerNotPresent == FALSE) {

            if (KiBugCheckDriver != NULL) {
                DbgPrint("Driver at fault: %s.\n", AnsiBuffer);
            }

            if (hardErrorCalled != FALSE) {
                if (HardErrorCaption) {
                    DbgPrint(HardErrorCaption);
                }
                if (HardErrorMessage) {
                    DbgPrint(HardErrorMessage);
                }
            }

            KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_FIRST);
        }
    }

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KeDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    

    //
    // Don't attempt to display message more than once.
    //

    if (InterlockedDecrement (&KeBugCheckCount) == 0) {

#if !defined(NT_UP)

        //
        // Attempt to get the other processors frozen now, but don't wait
        // for them to freeze (in case someone is stuck).
        //

        TargetSet = KeActiveProcessors & ~KeGetCurrentPrcb()->SetMember;
        if (TargetSet != 0) {
            KiIpiSend((KAFFINITY) TargetSet, IPI_FREEZE);

            //
            // Give the other processors one second to flush their data caches.
            //
            // N.B. This cannot be synchronized since the reason for the bug
            //      may be one of the other processors failed.
            //

            KeStallExecutionProcessor(1000 * 1000);
        }

#endif

        //
        // Enable terminal output and turn on bugcheck processing.
        //
        {
            HEADLESS_CMD_ENABLE_TERMINAL HeadlessCmd;
            HEADLESS_CMD_SEND_BLUE_SCREEN_DATA HeadlessCmdBlueScreen;

            HeadlessCmdBlueScreen.BugcheckCode = (ULONG)KiBugCheckData[0];

            HeadlessCmd.Enable = TRUE;

            HeadlessDispatch(HeadlessCmdStartBugCheck, NULL, 0, NULL, NULL);

            HeadlessDispatch(HeadlessCmdEnableTerminal,
                 &HeadlessCmd,
                 sizeof(HEADLESS_CMD_ENABLE_TERMINAL),
                 NULL,
                 NULL
                );

            HeadlessDispatch(HeadlessCmdSendBlueScreenData,
                             &HeadlessCmdBlueScreen,
                             sizeof(HEADLESS_CMD_SEND_BLUE_SCREEN_DATA),
                             NULL,
                             NULL
                            );

        }

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //

        if (InbvIsBootDriverInstalled()) {

            InbvAcquireDisplayOwnership();

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,475);  // set to use entire screen
        }

        if (!hardErrorCalled)
        {

            InbvDisplayString("\n");
            KeGetBugMessageText(BUGCHECK_MESSAGE_INTRO, NULL);
            InbvDisplayString("\n\n");

            if (KiBugCheckDriver) {

                //
                // Output the driver name.
                //

                KeGetBugMessageText(BUGCODE_ID_DRIVER, NULL);

                KeBugCheckUnicodeToAnsi (KiBugCheckDriver, Buffer, sizeof (Buffer));
                InbvDisplayString(" ");
                InbvDisplayString (Buffer);
                InbvDisplayString("\n\n");
            }

            //
            // Display the PSS message.
            // If we have no special text, get the text for the bugcode
            // which will be the bugcode name.
            //

            if (PssMessage == BUGCODE_PSS_MESSAGE)
            {
                KeGetBugMessageText((ULONG)KiBugCheckData[0], NULL);
                InbvDisplayString("\n\n");
            }

            KeGetBugMessageText(PSS_MESSAGE_INTRO, NULL);
            InbvDisplayString("\n\n");
            KeGetBugMessageText(PssMessage, NULL);
            InbvDisplayString("\n\n");

            KeGetBugMessageText(BUGCHECK_TECH_INFO, NULL);

            sprintf((char *)Buffer,
                    "\n\n*** STOP: 0x%08lX (0x%p,0x%p,0x%p,0x%p)\n\n",
                    (ULONG)KiBugCheckData[0],
                    (PVOID)KiBugCheckData[1],
                    (PVOID)KiBugCheckData[2],
                    (PVOID)KiBugCheckData[3],
                    (PVOID)KiBugCheckData[4]);

            InbvDisplayString((char *)Buffer);

            if (KiBugCheckDriver) {
                InbvDisplayString(AnsiBuffer);
            }

            if (!KiBugCheckDriver)
            {
                KiDumpParameterImages(AnsiBuffer,
                                      &(KiBugCheckData[1]),
                                      4,
                                      KeBugCheckUnicodeToAnsi);
            }

        } else {
            if (HardErrorCaption) {
                InbvDisplayString(HardErrorCaption);
            }
            if (HardErrorMessage) {
                InbvDisplayString(HardErrorMessage);
            }
        }

        KiInvokeBugCheckEntryCallbacks();
    
        //
        // If the debugger is not enabled, attempt to enable it.
        //

        if (KdDebuggerEnabled == FALSE && KdPitchDebugger == FALSE ) {
            KdInitSystem(0, NULL);

        } else {
            InbvDisplayString("\n");
        }

        // Restore the original Context frame
        KeGetCurrentPrcb()->ProcessorState.ContextFrame = ContextSave;

        //
        // For some bugchecks we want to change the thread and context before
        // it is written to the dump file IFF it is a minidump.
        // Look at the original bugcheck data, not the processed data from
        // above
        //

#define MINIDUMP_BUGCHECK 0x10000000

        if (IoIsTriageDumpEnabled())
        {
            switch (BugCheckCode) {

            //
            // System thread stores a context record as the 4th parameter.
            // use that.
            // Also save the context record in case someone needs to look
            // at it.
            //

            case SYSTEM_THREAD_EXCEPTION_NOT_HANDLED:
                if (BugCheckParameter4)
                {
                    ContextSave = *((PCONTEXT)BugCheckParameter4);

                    KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                }
                break;

#if defined (_X86_)

            //
            // 3rd parameter is a trap frame.
            //
            // Build a context record out of that only if it's a kernel mode
            // failure because esp may be wrong in that case ???.
            //

            case ATTEMPTED_WRITE_TO_READONLY_MEMORY:
            case KERNEL_MODE_EXCEPTION_NOT_HANDLED:
            case PAGE_FAULT_IN_NONPAGED_AREA:

                if (BugCheckParameter3)
                {
                    PKTRAP_FRAME Trap = (PKTRAP_FRAME) BugCheckParameter3;

                    if ((Trap->SegCs & 1) ||
                        (Trap->EFlags & EFLAGS_V86_MASK))
                    {
                        ContextSave.Esp = Trap->HardwareEsp;
                    }
                    else
                    {
                        ContextSave.Esp = (ULONG)Trap +
                            FIELD_OFFSET(KTRAP_FRAME, HardwareEsp);
                    }
                    if (Trap->EFlags & EFLAGS_V86_MASK)
                    {
                        ContextSave.SegSs = Trap->HardwareSegSs & 0xffff;
                    }
                    else if (Trap->SegCs & 1)
                    {
                        //
                        // It's user mode.
                        // The HardwareSegSs contains R3 data selector.
                        //

                        ContextSave.SegSs =
                            (Trap->HardwareSegSs | 3) & 0xffff;
                    }
                    else
                    {
                        ContextSave.SegSs = KGDT_R0_DATA;
                    }

                    ContextSave.SegGs = Trap->SegGs & 0xffff;
                    ContextSave.SegFs = Trap->SegFs & 0xffff;
                    ContextSave.SegEs = Trap->SegEs & 0xffff;
                    ContextSave.SegDs = Trap->SegDs & 0xffff;
                    ContextSave.SegCs = Trap->SegCs & 0xffff;
                    ContextSave.Eip = Trap->Eip;
                    ContextSave.Ebp = Trap->Ebp;
                    ContextSave.Eax = Trap->Eax;
                    ContextSave.Ebx = Trap->Ebx;
                    ContextSave.Ecx = Trap->Ecx;
                    ContextSave.Edx = Trap->Edx;
                    ContextSave.Edi = Trap->Edi;
                    ContextSave.Esi = Trap->Esi;
                    ContextSave.EFlags = Trap->EFlags;

                    KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                }
                break;

            case THREAD_STUCK_IN_DEVICE_DRIVER:

                // Extract the address of the spinning code from the thread
                // object, so the dump is based off this thread.

                Thread = (PKTHREAD) BugCheckParameter1;

                if (Thread->State == Running)
                {
                    //
                    // If the thread was running, the thread is now in a
                    // frozen state and the registers are in the PRCB
                    // context
                    //
                    ULONG Processor = Thread->NextProcessor;
                    ASSERT(Processor < (ULONG) KeNumberProcessors);
                    ContextSave =
                      KiProcessorBlock[Processor]->ProcessorState.ContextFrame;
                }
                else
                {
                    //
                    // This should be a uniproc machine, and the thread
                    // should be suspended.  Just get the data off the
                    // switch frame.
                    //

                    PKSWITCHFRAME SwitchFrame = (PKSWITCHFRAME)Thread->KernelStack;

                    ASSERT(Thread->State == Ready);

                    ContextSave.Esp = (ULONG)Thread->KernelStack + sizeof(KSWITCHFRAME);
                    ContextSave.Ebp = *((PULONG)(ContextSave.Esp));
                    ContextSave.Eip = SwitchFrame->RetAddr;
                }

                KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                break;

            case UNEXPECTED_KERNEL_MODE_TRAP:

                //
                // Double fault
                //

                if (BugCheckParameter1 == 0x8)
                {
                    // The thread is correct in this case.
                    // Second parameter is the TSS.  If we have a TSS, convert
                    // the context and mark the bugcheck as converted.

                    PKTSS Tss = (PKTSS) BugCheckParameter2;

                    if (Tss)
                    {
                        if (Tss->EFlags & EFLAGS_V86_MASK)
                        {
                            ContextSave.SegSs = Tss->Ss & 0xffff;
                        }
                        else if (Tss->Cs & 1)
                        {
                            //
                            // It's user mode.
                            // The HardwareSegSs contains R3 data selector.
                            //

                            ContextSave.SegSs = (Tss->Ss | 3) & 0xffff;
                        }
                        else
                        {
                            ContextSave.SegSs = KGDT_R0_DATA;
                        }

                        ContextSave.SegGs = Tss->Gs & 0xffff;
                        ContextSave.SegFs = Tss->Fs & 0xffff;
                        ContextSave.SegEs = Tss->Es & 0xffff;
                        ContextSave.SegDs = Tss->Ds & 0xffff;
                        ContextSave.SegCs = Tss->Cs & 0xffff;
                        ContextSave.Esp = Tss->Esp;
                        ContextSave.Eip = Tss->Eip;
                        ContextSave.Ebp = Tss->Ebp;
                        ContextSave.Eax = Tss->Eax;
                        ContextSave.Ebx = Tss->Ebx;
                        ContextSave.Ecx = Tss->Ecx;
                        ContextSave.Edx = Tss->Edx;
                        ContextSave.Edi = Tss->Edi;
                        ContextSave.Esi = Tss->Esi;
                        ContextSave.EFlags = Tss->EFlags;
                    }

                    KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                    break;
                }
#endif
            default:
                break;
            }

            //
            // Write a crash dump and optionally reboot if the system has been
            // so configured.
            //

            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[1]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[2]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[3]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[4]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(SaveDataPage), PAGE_SIZE);

            //
            // If the DPC stack is active, save that data page as well.
            //

#if defined (_X86_)
            if (KeGetCurrentPrcb()->DpcRoutineActive)
            {
                IoAddTriageDumpDataBlock(PAGE_ALIGN(KeGetCurrentPrcb()->DpcRoutineActive), PAGE_SIZE);
            }
#endif
        }

        IoWriteCrashDump((ULONG)KiBugCheckData[0],
                         KiBugCheckData[1],
                         KiBugCheckData[2],
                         KiBugCheckData[3],
                         KiBugCheckData[4],
                         &ContextSave,
                         Thread,
                         &Reboot);
    }

    //
    // Invoke bugcheck callbacks after crashdump, so the callbacks will
    // not prevent us from crashdumping.
    //

    KiScanBugCheckCallbackList();


    //
    // Reboot the machine if necessary.
    //
    
    if (Reboot) {
        DbgUnLoadImageSymbols (NULL, (PVOID)-1, 0);
        HalReturnToFirmware (HalRebootRoutine);
    }

        
    //
    // Attempt to enter the kernel debugger.
    //
    
    KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_SECOND);
}
#ifdef _X86_
#pragma optimize("", on)
#endif


VOID
KeEnterKernelDebugger (
    VOID
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner attempting
    to invoke the kernel debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(i386)
    KIRQL OldIrql;
#endif

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiHardwareTrigger = 1;
    KeDisableInterrupts();
#if !defined(i386)
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            if ( KdPitchDebugger == FALSE ) {
                KdInitSystem(0, NULL);
            }
        }
    }

    KiBugCheckDebugBreak (DBG_STATUS_FATAL);
}

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    )

/*++

Routine Description:

    This function deregisters a bug check callback record.

Arguments:

    CallbackRecord - Supplies a pointer to a bug check callback record.

Return Value:

    If the specified bug check callback record is successfully deregistered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Deregister;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bug check callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently registered, then
    // deregister the callback record.
    //

    Deregister = FALSE;
    if (CallbackRecord->State == BufferInserted) {
        CallbackRecord->State = BufferEmpty;
        RemoveEntryList(&CallbackRecord->Entry);
        Deregister = TRUE;
    }

    //
    // Release the bug check callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // deregistered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Deregister;
}

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    IN PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PUCHAR Component
    )

/*++

Routine Description:

    This function registers a bug check callback record. If the system
    crashes, then the specified function will be called during bug check
    processing so it may dump additional state in the specified bug check
    buffer.

    N.B. Bug check callback routines are called in reverse order of
         registration, i.e., in LIFO order.

Arguments:

    CallbackRecord - Supplies a pointer to a callback record.

    CallbackRoutine - Supplies a pointer to the callback routine.

    Buffer - Supplies a pointer to the bug check buffer.

    Length - Supplies the length of the bug check buffer in bytes.

    Component - Supplies a pointer to a zero terminated component
        identifier.

Return Value:

    If the specified bug check callback record is successfully registered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bug check callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently not registered, then
    // register the callback record.
    //

    Inserted = FALSE;
    if (CallbackRecord->State == BufferEmpty) {
        CallbackRecord->CallbackRoutine = CallbackRoutine;
        CallbackRecord->Buffer = Buffer;
        CallbackRecord->Length = Length;
        CallbackRecord->Component = Component;
        CallbackRecord->Checksum =
            ((ULONG_PTR)CallbackRoutine + (ULONG_PTR)Buffer + Length + (ULONG_PTR)Component);

        CallbackRecord->State = BufferInserted;
        InsertHeadList(&KeBugCheckCallbackListHead, &CallbackRecord->Entry);
        Inserted = TRUE;
    }

    //
    // Release the bug check callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // registered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Inserted;
}

VOID
KiScanBugCheckCallbackList (
    VOID
    )

/*++

Routine Description:

    This function scans the bug check callback list and calls each bug
    check callback routine so it can dump component specific information
    that may identify the cause of the bug check.

    N.B. The scan of the bug check callback list is performed VERY
        carefully. Bug check callback routines are called at HIGH_LEVEL
        and may not acquire ANY resources.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKBUGCHECK_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    ULONG Index;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Source;

    //
    // If the bug check callback listhead is not initialized, then the
    // bug check has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckCallbackListHead;
    if ((ListHead->Flink != NULL) && (ListHead->Blink != NULL)) {

        //
        // Scan the bug check callback list.
        //

        LastEntry = ListHead;
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {

            //
            // The next entry address must be aligned properly, the
            // callback record must be readable, and the callback record
            // must have back link to the last entry.
            //

            if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
                return;

            } else {
                CallbackRecord = CONTAINING_RECORD(NextEntry,
                                                   KBUGCHECK_CALLBACK_RECORD,
                                                   Entry);

                Source = (PUCHAR)CallbackRecord;
                for (Index = 0; Index < sizeof(KBUGCHECK_CALLBACK_RECORD); Index += 1) {
                    if (MmIsAddressValid((PVOID)Source) == FALSE) {
                        return;
                    }

                    Source += 1;
                }

                if (CallbackRecord->Entry.Blink != LastEntry) {
                    return;
                }

                //
                // If the callback record has a state of inserted and the
                // computed checksum matches the callback record checksum,
                // then call the specified bug check callback routine.
                //

                Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
                Checksum += (ULONG_PTR)CallbackRecord->Buffer;
                Checksum += CallbackRecord->Length;
                Checksum += (ULONG_PTR)CallbackRecord->Component;
                if ((CallbackRecord->State == BufferInserted) &&
                    (CallbackRecord->Checksum == Checksum)) {

                    //
                    // Call the specified bug check callback routine and
                    // handle any exceptions that occur.
                    //

                    CallbackRecord->State = BufferStarted;
                    try {
                        (CallbackRecord->CallbackRoutine)(CallbackRecord->Buffer,
                                                          CallbackRecord->Length);

                        CallbackRecord->State = BufferFinished;

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        CallbackRecord->State = BufferIncomplete;
                    }
                }
            }

            LastEntry = NextEntry;
            NextEntry = NextEntry->Flink;
        }
    }

    return;
}

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    )

/*++

Routine Description:

    This function deregisters a bug check callback record.

Arguments:

    CallbackRecord - Supplies a pointer to a bug check callback record.

Return Value:

    If the specified bug check callback record is successfully deregistered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Deregister;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bug check callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently registered, then
    // deregister the callback record.
    //

    Deregister = FALSE;
    if (CallbackRecord->State == BufferInserted) {
        CallbackRecord->State = BufferEmpty;
        RemoveEntryList(&CallbackRecord->Entry);
        Deregister = TRUE;
    }

    //
    // Release the bug check callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // deregistered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Deregister;
}

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    IN PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    IN PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    IN KBUGCHECK_CALLBACK_REASON Reason,
    IN PUCHAR Component
    )

/*++

Routine Description:

    This function registers a bug check callback record. If the system
    crashes, then the specified function will be called during bug check
    processing.

    N.B. Bug check callback routines are called in reverse order of
         registration, i.e., in LIFO order.

Arguments:

    CallbackRecord - Supplies a pointer to a callback record.

    CallbackRoutine - Supplies a pointer to the callback routine.

    Reason - Specifies the conditions under which the callback
             should be called.

    Component - Supplies a pointer to a zero terminated component
        identifier.

Return Value:

    If the specified bug check callback record is successfully registered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bug check callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently not registered, then
    // register the callback record.
    //

    Inserted = FALSE;
    if (CallbackRecord->State == BufferEmpty) {
        CallbackRecord->CallbackRoutine = CallbackRoutine;
        CallbackRecord->Reason = Reason;
        CallbackRecord->Component = Component;
        CallbackRecord->Checksum =
            ((ULONG_PTR)CallbackRoutine + Reason + (ULONG_PTR)Component);

        CallbackRecord->State = BufferInserted;
        InsertHeadList(&KeBugCheckReasonCallbackListHead,
                       &CallbackRecord->Entry);
        Inserted = TRUE;
    }

    //
    // Release the bug check callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // registered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Inserted;
}

VOID
KiInvokeBugCheckEntryCallbacks (
    VOID
    )
/*++

Routine Description:

    This function scans the bug check reason callback list and calls
    each bug check entry callback routine.

    This may seem like a duplication of KiScanBugCheckCallbackList
    but the critical difference is that the bug check entry callbacks
    are called immediately upon entry to KeBugCheck2 whereas
    KSBCCL does not invoke its callbacks until after all bug check
    processing has finished.

    In order to avoid people from abusing this callback it's
    semi-private and the reason -- KbCallbackReserved1 -- has
    an obscure name.
    
    N.B. The scan of the bug check callback list is performed VERY
        carefully. Bug check callback routines may be called at HIGH_LEVEL
        and may not acquire ANY resources.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    ULONG Index;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Source;

    //
    // If the bug check callback listhead is not initialized, then the
    // bug check has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckReasonCallbackListHead;
    if (ListHead->Flink == NULL || ListHead->Blink == NULL) {
        return;
    }

    //
    // Scan the bug check callback list.
    //

    LastEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {

        //
        // The next entry address must be aligned properly, the
        // callback record must be readable, and the callback record
        // must have back link to the last entry.
        //

        if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
            return;
        }

        CallbackRecord = CONTAINING_RECORD(NextEntry,
                                           KBUGCHECK_REASON_CALLBACK_RECORD,
                                           Entry);

        Source = (PUCHAR)CallbackRecord;
        for (Index = 0; Index < sizeof(*CallbackRecord); Index += 1) {
            if (MmIsAddressValid((PVOID)Source) == FALSE) {
                return;
            }
            
            Source += 1;
        }

        if (CallbackRecord->Entry.Blink != LastEntry) {
            return;
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Flink;

        //
        // If the callback record has a state of inserted and the
        // computed checksum matches the callback record checksum,
        // then call the specified bug check callback routine.
        //

        Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
        Checksum += (ULONG_PTR)CallbackRecord->Reason;
        Checksum += (ULONG_PTR)CallbackRecord->Component;
        if ((CallbackRecord->State != BufferInserted) ||
            (CallbackRecord->Checksum != Checksum) ||
            (CallbackRecord->Reason != KbCallbackReserved1) ||
            MmIsAddressValid((PVOID)(ULONG_PTR)CallbackRecord->
                             CallbackRoutine) == FALSE) {
            continue;
        }

        //
        // Call the specified bug check callback routine and
        // handle any exceptions that occur.
        //

        try {
            (CallbackRecord->CallbackRoutine)(KbCallbackReserved1,
                                              CallbackRecord,
                                              NULL, 0);
            CallbackRecord->State = BufferFinished;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CallbackRecord->State = BufferIncomplete;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\channel.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    channel.c

Abstract:

   This module implements the executive channel object. Channel obects
   provide a very high speed local interprocess communication mechanism.

Author:

    David N. Cutler (davec) 26-Mar-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define local function prototypes.
//

VOID
KiAllocateReceiveBufferChannel (
    VOID
    );

VOID
KiCloseChannel (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    );

VOID
KiDeleteChannel (
    IN PVOID Object
    );

NTSTATUS
KiListenChannel (
    IN PRECHANNEL ServerChannel,
    IN KPROCESSOR_MODE WaitMode,
    OUT PCHANNEL_MESSAGE *Message
    );

PKTHREAD
KiRendezvousWithThread (
    IN PRECHANNEL WaitChannel,
    IN ULONG WaitMode
    );

//
// Address of event object type descriptor.
//

POBJECT_TYPE KeChannelType;

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for event objects.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif
const GENERIC_MAPPING KiChannelMapping = {
    STANDARD_RIGHTS_READ |
        CHANNEL_READ_MESSAGE,
    STANDARD_RIGHTS_WRITE |
        CHANNEL_WRITE_MESSAGE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE,
    CHANNEL_ALL_ACCESS
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

//
// Define function sections.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KiAllocateReceiveBufferChannel)
#pragma alloc_text(INIT, KiChannelInitialization)
#pragma alloc_text(PAGE, KiDeleteChannel)
#pragma alloc_text(PAGE, KiRundownChannel)
#pragma alloc_text(PAGE, NtCreateChannel)
#pragma alloc_text(PAGE, NtListenChannel)
#pragma alloc_text(PAGE, NtOpenChannel)
#pragma alloc_text(PAGE, NtSetContextChannel)
#endif

NTSTATUS
NtCreateChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL
    )

/*++

Routine Description:

    This function creates a server listen channel object and opens a handle
    to the object with the specified desired access.

Arguments:

    ChannelHandle - Supplies a pointer to a variable that will receive the
        channel object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    If the channel object is created, then a success status is returned.
    Otherwise, a failure status is returned.

--*/

{

#if 0

    PVOID ChannelObject;
    KPROCESSOR_MODE PreviousMode;
    PRECHANNEL ServerChannel;
    HANDLE ServerHandle;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe and zero the output handle
    // address, and attempt to create a channel object. If the probe fails
    // or access to the object attributes fails, then return the exception
    // code as the service status.
    //

    PreviousMode = KeGetPreviousMode();
    try {

        //
        // Get previous processor mode and probe output handle address if
        // necessary.
        //

        if (PreviousMode != KernelMode) {
            ProbeAndZeroHandle(ChannelHandle);
        }

        //
        // Allocate channel object.
        //

        Status = ObCreateObject(PreviousMode,
                                KeChannelType,
                                ObjectAttributes,
                                PreviousMode,
                                NULL,
                                sizeof(ECHANNEL),
                                0,
                                0,
                                &ChannelObject);

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // If the channel object was successfully created, then initialize the
    // channel object and insert the channel object in the process handle
    // table.
    //

    if (NT_SUCCESS(Status)) {
        ServerChannel = (PRECHANNEL)ChannelObject;
        ServerChannel->Type = LISTEN_CHANNEL;
        ServerChannel->State = ServerIdle;
        ServerChannel->OwnerProcess = &PsGetCurrentProcess()->Pcb;
        ServerChannel->ClientThread = NULL;
        ServerChannel->ServerThread = NULL;
        ServerChannel->ServerContext = NULL;
        ServerChannel->ServerChannel = NULL;
        KeInitializeEvent(&ServerChannel->ReceiveEvent,
                          SynchronizationEvent,
                          FALSE);

        KeInitializeEvent(&ServerChannel->ClearToSendEvent,
                          SynchronizationEvent,
                          FALSE);

        Status = ObInsertObject(ServerChannel,
                                NULL,
                                CHANNEL_ALL_ACCESS,
                                0,
                                NULL,
                                &ServerHandle);

        //
        // If the channel object was successfully inserted in the process
        // handle table, then attempt to write the channel object handle
        // value. If the write attempt fails, then do not report an error.
        // When the caller attempts to access the handle value, an access
        // violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            try {
                *ChannelHandle = ServerHandle;

            } except(ExSystemExceptionFilter()) {
            }
        }
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

NTSTATUS
NtListenChannel (
    IN HANDLE ChannelHandle,
    OUT PCHANNEL_MESSAGE *Message
    )

/*++

Routine Description:

    This function listens for a client message.

    N.B. This function can only be executed from a server thread.

Arguments:

    ChannelHandle - Supplies a handle to a listen channel on which the
        server thread listens.

    Message - Supplies a pointer to a variable that receives a pointer
        to the client message header.

Return Value:

    If the function is successfully completed, then a success status is
    returned. Otherwise, a failure status is returned.

--*/

{

#if 0

    KPROCESSOR_MODE PreviousMode;
    PRECHANNEL ServerChannel;
    PRKTHREAD ServerThread;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output message address,
    // and allocate a receive buffer if necessary. If the probe fails or
    // the receive buffer allocation is not successful, then return the
    // exception code as the service status.
    //

    ServerThread = KeGetCurrentThread();
    try {

        //
        // Get previous processor mode and probe output message address.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeAndNullPointer(Message);
        }

        //
        // If the current thread does not have an associated receive buffer,
        // then attempt to allocate one now. If the allocation fails, then
        // an exception is raised.
        //

        if (ServerThread->Section == NULL) {
            KiAllocateReceiveBufferChannel();
        }

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // Reference channel object by handle.
    //

    Status = ObReferenceObjectByHandle(ChannelHandle,
                                       CHANNEL_ALL_ACCESS,
                                       KeChannelType,
                                       PreviousMode,
                                       &ServerChannel,
                                       NULL);

    //
    // If the reference was successful and the channel is a listen channel,
    // then wait for a client message to arrive.
    //

    if (NT_SUCCESS(Status)) {
        if (ServerChannel->ServerChannel != NULL) {
            Status = STATUS_INVALID_PARAMETER; // **** fix ****

        } else {
            Status = KiListenChannel(ServerChannel, PreviousMode, Message);
        }

        ObDereferenceObject(ServerChannel);
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

NTSTATUS
NtOpenChannel (
    OUT PHANDLE ChannelHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This function opens a handle to a server channel by creating a message
    channel that is connected to the specified server channel.

Arguments:

    ChannelHandle - Supplies a pointer to a variable that will receive the
        channel object handle.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

Return Value:

    If the channel object is opened, then a success status is returned.
    Otherwise, a failure status is returned.

--*/

{

#if 0

    PRECHANNEL ClientChannel;
    HANDLE ClientHandle;
    PKTHREAD ClientThread;
    KPROCESSOR_MODE PreviousMode;
    PRECHANNEL ServerChannel;
    PVOID ServerObject;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe and zero the output handle
    // address, and attempt to open the server channel object. If the
    // probe fails, then return the exception code as the service status.
    //

    try {

        //
        // Get previous processor mode and probe output handle address
        // if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeAndZeroHandle(ChannelHandle);
        }

        //
        // Reference the server channel object with the specified desired
        // access.
        //

        Status = ObReferenceObjectByName(ObjectAttributes->ObjectName,
                                        ObjectAttributes->Attributes,
                                        NULL,
                                        CHANNEL_ALL_ACCESS,
                                        KeChannelType,
                                        PreviousMode,
                                        NULL,
                                        (PVOID *)&ServerObject);

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // If the reference was successful, then attempt to create a client
    // channel object.
    //

    if (NT_SUCCESS(Status)) {

        //
        // If the owner process of the server channel is the same as
        // the current process, then a server thread is attempting to
        // open a client handle. This is not allowed since it would
        // not be possible to distinguish the server from the cient.
        //

        ClientThread = KeGetCurrentThread();
        ServerChannel = (PECHANNEL)ServerObject;
        if (ServerChannel->OwnerProcess == ClientThread->ApcState.Process) {
            Status = STATUS_INVALID_PARAMETER; // **** fix ***

        } else {
            Status = ObCreateObject(PreviousMode,
                                    KeChannelType,
                                    NULL,
                                    PreviousMode,
                                    NULL,
                                    sizeof(ECHANNEL),
                                    0,
                                    0,
                                    (PVOID *)&ClientChannel);

            //
            // If the channel object was successfully created, then
            // initialize the channel object and attempt to insert the
            // channel object in the server process channel table.
            //

            if (NT_SUCCESS(Status)) {
                ClientChannel->Type = MESSAGE_CHANNEL;
                ClientChannel->State = ClientIdle;
                ClientChannel->OwnerProcess = &PsGetCurrentProcess()->Pcb;
                ClientChannel->ClientThread = NULL;
                ClientChannel->ServerThread = NULL;
                ClientChannel->ServerContext = NULL;
                ClientChannel->ServerChannel = ServerChannel;
                KeInitializeEvent(&ClientChannel->ReceiveEvent,
                                  SynchronizationEvent,
                                  FALSE);

                KeInitializeEvent(&ClientChannel->ClearToSendEvent,
                                  SynchronizationEvent,
                                  FALSE);

                //
                // Create a handle to the message channel object.
                //

                Status = ObInsertObject(ClientChannel,
                                        NULL,
                                        CHANNEL_ALL_ACCESS,
                                        0,
                                        NULL,
                                        &ClientHandle);

                //
                // If the channel object was successfully inserted in the
                // client process handle table, then attempt to write the
                // client channel object handle value. If the write attempt
                // fails, then do not report an error. When the caller
                // attempts to access the handle value, an access violation
                // will occur.
                //

                if (NT_SUCCESS(Status)) {
                    try {
                        *ChannelHandle = ClientHandle;

                    } except(ExSystemExceptionFilter()) {
                    }

                }

                return Status;
            }
        }

        ObDereferenceObject(ServerChannel);
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

NTSTATUS
NtReplyWaitSendChannel (
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    )

/*++

Routine Description:

    This function sends a reply message to a client and waits for a send.

    N.B. This function can only be executed from a server thread that
        has an assoicated message channel.

Arguments:

    Text - Supplies a pointer to the message text.

    Length - Supplies the length of the message text.

    Message - Supplies a pointer to a variable that receives the send
        message header.

Return Value:

    If the function is successfully completed, then a succes status is
    returned. Otherwise, a failure status is returned.

--*/

{

#if 0

    PKTHREAD ClientThread;
    PCHANNEL_MESSAGE ClientView;
    PRECHANNEL MessageChannel;
    KPROCESSOR_MODE PreviousMode;
    PECHANNEL ServerChannel;
    PKTHREAD ServerThread;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output message address,
    // probe the message text, and allocate a receive buffer if necessary.
    // If either of the probes fail or the receive buffer allocation is
    // not successful, then return the exception code as the service
    // status.
    //

    ServerThread = KeGetCurrentThread();
    try {

        //
        // Get previous processor mode and probe output message address and
        // the message text if necessary.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForRead(Text, Length, sizeof(CHAR));
            ProbeAndNullPointer(Message);
        }

        //
        // If the current thread does not have an associated receive buffer,
        // then attempt to allocate one now. If the allocation fails, then
        // an exception is raised.
        //

        if (ServerThread->Section == NULL) {
            KiAllocateReceiveBufferChannel();
        }

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // If the message length is greater than the host page size minus
    // the message header length, then return an error.
    //

    if (Length >= (PAGE_SIZE - sizeof(CHANNEL_MESSAGE))) {
        return  STATUS_BUFFER_OVERFLOW;
    }

    //
    // If the server thread has an associated message channel, the channel
    // is in server receive message state, and the channel server thread
    // matches the current thread.
    //
    // This implies that:
    //
    // 1. The channel is a message channel.
    //
    // 2. The channel is being accessed by the server thread.
    //
    // 3. The channel is associated with a listen channel.
    //
    // 4. There is currently a server channel owner.
    //
    // 5. There is currently a client channel owner.
    //

    KiLockDispatcherDatabase(&ServerThread->WaitIrql);
    MessageChannel = ServerThread->Channel;
    if ((MessageChannel == NULL) ||
        (MessageChannel->State != ServerReceiveMessage) ||
        (MessageChannel->ServerThread != ServerThread)) {

        //
        // A message is not associated with the current thread,
        // the message channel is in the wrong state, or the
        // current thread is not the owner of the channel.
        //

        KiUnlockDispatcherDatabase(ServerThread->WaitIrql);
        Status = STATUS_INVALID_PARAMETER; // **** fix ****

    } else {

        //
        // Rendezvous with the client thread so a transfer of the
        // reply text to the client thread can occur.
        //

        ClientThread = KiRendezvousWithThread(MessageChannel, PreviousMode);

        //
        // Control is returned when:
        //
        // 1. The server thread is being terminated (USER_APC).
        //
        // 2. A rendezvous with a client thread has occured.
        //
        // N.B. If the status value is less than zero, then it
        //      is the address of the client thread.
        //

        if ((LONG)ClientThread < 0) {

            //
            // The client thread is returned as the rendezvous status
            // with the thread in the transition state. Get the address
            // of the client thread system view, establish an exception
            // handler, and transfer the  message text from the server's
            // buffer to the client's receive buffer. If an exception
            // occurs during the copy, then return the exception code
            // as the service status.
            //

            ClientView = ClientThread->SystemView;
            Status = STATUS_SUCCESS;
            if (Length != 0) {
                try {
                    RtlCopyMemory(ClientView + 1, Text, Length);

                } except (ExSystemExceptionFilter()) {
                    Status = GetExceptionCode();
                }
            }

            //
            // Set the channel message parameters.
            //

            ClientView->Text = (PVOID)(ClientThread->ThreadView + 1);
            ClientView->Length = Length;
            ClientView->Context = NULL;
            ClientView->Base = Text;
            ClientView->Close = FALSE;

            //
            // Raise IRQL to dispatch level, lock the dispatcher
            // database, and check if the message was successfully
            // transfered to the client's receive buffer. If the
            // message was successfully transfered to the client's
            // receive buffer. then reset the channel state, fill
            // in the message parameters, ready the client thread,
            // and listen for the next message. Otherwise, set the
            // client wait status and ready the client thread for
            // execution.
            //

            KiLockDispatcherDatabase(&ServerThread->WaitIrql);
            if (NT_SUCCESS(Status)) {
                MessageChannel->State = ClientIdle;
                MessageChannel->ClientThread = NULL;
                MessageChannel->ServerThread = NULL;
                ClientThread->WaitStatus = STATUS_SUCCESS;

                //
                // Reference the server channel and dereference the
                // message channel.
                //

                ServerChannel = MessageChannel->ServerChannel;
                ObReferenceObject(ServerChannel);
                ObDereferenceObject(MessageChannel);

                //
                // If there are no clients waiting to send to the server,
                // then switch directly to the client thread. Otherwise,
                // ready the client thread, then listen for the next
                // message.
                //

                if (IsListEmpty(&ServerChannel->ClearToSendEvent.Header.WaitListHead) == FALSE) {
                    KiReadyThread(ClientThread);
                    KiUnlockDispatcherDatabase(ServerThread->WaitIrql);
                    Status = KiListenChannel(ServerChannel,
                                             PreviousMode,
                                             Message);

                } else {
                    Status = KiSwitchToThread(ClientThread,
                                              WrRendezvous,
                                              PreviousMode,
                                              &ServerChannel->ReceiveEvent);

                    //
                    // If a client message was successfully received, then
                    // attempt to write the address of the send message
                    // address. If the write attempt fails, then do not
                    // report an error. When the caller attempts to access
                    // the message address, an access violation will occur.
                    //

                    if (NT_SUCCESS(Status)) {
                        try {
                            *Message = ServerThread->ThreadView;

                        } except(ExSystemExceptionFilter()) {
                        }
                    }
                }

                ObDereferenceObject(ServerChannel);

            } else {

                //
                // The reply message was not successfully transfered
                // to the client receive buffer because of an access
                // violation encountered durring the access to the
                // server buffer.
                //

                ClientThread->WaitStatus = STATUS_KERNEL_APC;
                KiReadyThread(ClientThread);
                KiUnlockDispatcherDatabase(ServerThread->WaitIrql);
            }

        } else {

            //
            // The server thread is terminating and the channel
            // structures will be cleaned up by the termiantion
            // code.
            //

            Status = (NTSTATUS)ClientThread;
        }
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

NTSTATUS
NtSendWaitReplyChannel (
    IN HANDLE ChannelHandle,
    IN PVOID Text,
    IN ULONG Length,
    OUT PCHANNEL_MESSAGE *Message
    )

/*++

Routine Description:

    This function sends a message to a server and waits for a reply.

    N.B. This function can only be executed from a client thread.

Arguments:

    ChannelHandle - Supplies a handle to a message channel over which the
        specified message text is sent.

    Text - Supplies a pointer to the message text.

    Length - Supplies the length of the message text.

    Message - Supplies a pointer to a variable that receives a pointer
        to the reply message header.

Return Value:

    If the function is successfully completed, then a success status is
    returned. Otherwise, a failure status is returned.

--*/

{

#if 0

    PKTHREAD ClientThread;
    PRECHANNEL MessageChannel;
    KPROCESSOR_MODE PreviousMode;
    PRECHANNEL ServerChannel;
    PKTHREAD ServerThread;
    PCHANNEL_MESSAGE ServerView;
    NTSTATUS Status;

    //
    // Establish an exception handler, probe the output message address,
    // probe the message text, and allocate a receive buffer if necessary.
    // If either of the probes fail or the receive buffer allocation is
    // not successful, then return the exception code as the service
    // status.
    //

    ClientThread = KeGetCurrentThread();
    try {

        //
        // Get previous processor mode and probe output message address
        // and the message text.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForRead(Text, Length, sizeof(UCHAR));
            ProbeAndNullPointer(Message);
        }

        //
        // If the current thread does not have an associated receive buffer,
        // then attempt to allocate one now. If the allocation fails, then
        // an exception is raised.
        //

        if (ClientThread->Section == NULL) {
            KiAllocateReceiveBufferChannel();
        }

    } except(ExSystemExceptionFilter()) {
        return GetExceptionCode();
    }

    //
    // If the message length is greater than the host page size minus
    // the message header length, then return an error.
    //

    if (Length >= (PAGE_SIZE - sizeof(CHANNEL_MESSAGE))) {
        return STATUS_BUFFER_OVERFLOW;
    }

    //
    // Reference channel object by handle.
    //

    Status = ObReferenceObjectByHandle(ChannelHandle,
                                       CHANNEL_ALL_ACCESS,
                                       KeChannelType,
                                       PreviousMode,
                                       (PVOID *)&MessageChannel,
                                       NULL);

    //
    // If the reference was successful, then check if the channel is in
    // the client idle state.
    //
    // This implies that:
    //
    // 1. The channel is a message channel.
    //
    // 2. The channel is being accessed by a client thread.
    //
    // 3. The channel is connected to a listen channel.
    //
    // 4. There is currently no client thread channel owner.
    //
    // 5. There is currently no server thread channel owner.
    //

    if (NT_SUCCESS(Status)) {
        KiLockDispatcherDatabase(&ClientThread->WaitIrql);
        if (MessageChannel->State != ClientIdle) {

            //
            // The message channel is in the wrong state.
            //

            KiUnlockDispatcherDatabase(ClientThread->WaitIrql);
            Status = STATUS_INVALID_PARAMETER; // **** fix ****

        } else {

            //
            // Set the channel state, set the client owner thread, and
            // rendezvous with a server thread.
            //

            MessageChannel->State = ClientSendWaitReply;
            MessageChannel->ClientThread = ClientThread;
            ClientThread->Channel = MessageChannel;
            ServerChannel = MessageChannel->ServerChannel;
            ServerThread = KiRendezvousWithThread(ServerChannel, PreviousMode);

            //
            // Control is returned when:
            //
            // 1. The client thread is being terminated (USER_APC).
            //
            // 2. A rendezvous with a server thread has occured.
            //
            // N.B. If the status value is less than zero, then it
            //      is the address of the server thread.
            //

            if ((LONG)ServerThread < 0) {

                //
                // The server thread is returned as the rendezvous status
                // with the thread in the transition state. Get the address
                // of the server thread system view, establish an exception
                // handler, and transfer the message text from the client's
                // buffer to the server's receive buffer. If an exception
                // occurs during the copy, then return the exception code
                // as the service status.
                //

                ServerView = ServerThread->SystemView;
                if (Length != 0) {
                    try {
                        RtlCopyMemory(ServerView + 1, Text, Length);

                    } except (ExSystemExceptionFilter()) {
                        Status = GetExceptionCode();
                    }
                }

                //
                // Set the channel message parameters.
                //

                ServerView->Text = (PVOID)(ServerThread->ThreadView + 1);
                ServerView->Length = Length;
                ServerView->Context = MessageChannel->ServerContext;
                ServerView->Base = Text;
                ServerView->Close = FALSE;

                //
                // Raise IRQL to dispatch level, lock the dispatcher
                // database and check if the message was successfully
                // transfered to the server's receive buffer. If the
                // message was successfully transfered, then set the
                // channel state, set the server thread address, set
                // the address of the message channel in the server
                // thread, increment the message channel reference
                // count, fill in the message parameters, and switch
                // directly to the server thread. Otherwise, set the
                // channel state, and reready the server thread for
                // execution.
                //

                KiLockDispatcherDatabase(&ClientThread->WaitIrql);
                if (NT_SUCCESS(Status)) {
                    MessageChannel->State = ServerReceiveMessage;
                    MessageChannel->ServerThread = ServerThread;
                    ObReferenceObject(MessageChannel);
                    ServerThread->Channel = MessageChannel;
                    Status = KiSwitchToThread(ServerThread,
                                              WrRendezvous,
                                              PreviousMode,
                                              &MessageChannel->ReceiveEvent);

                    //
                    // If the send and subsequent reply from the server
                    // thread is successful, then attempt to write the
                    // address of the reply message address. If the write
                    // attempt fails, then do not report an error. When
                    // the caller attempts to access the message address,
                    // an access violation will occur.
                    //

                    if (NT_SUCCESS(Status)) {
                        try {
                            *Message = ClientThread->ThreadView;

                        } except(ExSystemExceptionFilter()) {
                        }
                    }

                } else {

                    //
                    // The send message was not successfully transfered
                    // to the server receive buffer because of an access
                    // violation encountered durring the access to the
                    // client buffer.
                    //

                    MessageChannel->State = ClientIdle;
                    MessageChannel->ClientThread = NULL;
                    ClientThread->Channel = NULL;
                    ServerThread->WaitStatus = STATUS_KERNEL_APC;
                    KiReadyThread(ServerThread);
                    KiUnlockDispatcherDatabase(ClientThread->WaitIrql);
                }

            } else {

                //
                // The client thread is terminating and the channel
                // structures will be cleaned up by the termination
                // code.
                //

                Status = (NTSTATUS)ServerThread;
            }
        }

        ObDereferenceObject(MessageChannel);
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

NTSTATUS
NtSetContextChannel (
    IN PVOID Context
    )

/*++

Routine Description:

    This function stores a context value for the current associated
    message channel.

    N.B. This function can only be executed from a server thread that
        has an associated message channel.

Arguments:

    Context - Supplies a context value that is to be stored in the
        associated message channel.

Return Value:

    If the channel information is set, then a success status is returned.
    Otherwise, a failure status is returned.

--*/

{

#if 0

    PRECHANNEL MessageChannel;
    PKTHREAD CurrentThread;
    NTSTATUS Status;

    //
    // If the thread has an assoicated channel and the server thread for
    // the channel is the current thread, then store the channel context.
    //

    CurrentThread = KeGetCurrentThread();
    MessageChannel = CurrentThread->Channel;
    if ((MessageChannel == NULL) ||
        (CurrentThread != MessageChannel->ServerThread)) {
        Status = STATUS_INVALID_PARAMETER; // ****** FIX *****

    } else {
        MessageChannel->ServerContext = Context;
        Status = STATUS_SUCCESS;
    }

    //
    // Return service status.
    //

    return Status;

#else

    return STATUS_NOT_IMPLEMENTED;

#endif

}

#if 0


VOID
KiAllocateReceiveBufferChannel (
    VOID
    )

/*++

Routine Description:

    This function creates an unnamed section with a single page, maps
    a view of the section into the current process and into the system
    address space, and associates the view with the current thread.

Arguments:

    None.

Return Value:

    If a channel receive buffer is not allocated, then raise an exception.

--*/

{

    LARGE_INTEGER MaximumSize;
    PEPROCESS Process;
    NTSTATUS Status;
    PKTHREAD Thread;
    LARGE_INTEGER ViewOffset;
    ULONG ViewSize;

    //
    // Create an unnamed section object.
    //

    Thread = KeGetCurrentThread();

    ASSERT(Thread->Section == NULL);

    MaximumSize.QuadPart = PAGE_SIZE;
    Status = MmCreateSection(&Thread->Section,
                             0,
                             NULL,
                             &MaximumSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL,
                             NULL);

    if (NT_SUCCESS(Status)) {

        //
        // Map a view of the section into the current process.
        //

        Process = PsGetCurrentProcess();
        ViewOffset.QuadPart = 0;
        ViewSize = PAGE_SIZE;
        Status = MmMapViewOfSection(Thread->Section,
                                    Process,
                                    &Thread->ThreadView,
                                    0,
                                    ViewSize,
                                    &ViewOffset,
                                    &ViewSize,
                                    ViewUnmap,
                                    0,
                                    PAGE_READWRITE);

        if (NT_SUCCESS(Status)) {

            //
            // Map a view of the section into the system address
            // space.
            //

            Status = MmMapViewInSystemSpace(Thread->Section,
                                            &Thread->SystemView,
                                            &ViewSize);

            if (NT_SUCCESS(Status)) {
                return;
            }

            MmUnmapViewOfSection(Process, Thread->ThreadView);
        }

        ObDereferenceObject(Thread->Section);
    }

    //
    // The allocation of a receive buffer was not successful. Raise an
    // exception that will be caught by the caller.
    //

    ExRaiseStatus(Status);
    return;
}

BOOLEAN
KiChannelInitialization (
    VOID
    )

/*++

Routine Description:

    This function creates the channel object type descriptor at system
    initialization and stores the address of the object type descriptor
    in global storage.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if the channel object type descriptor is
    successfully initialized. Otherwise a value of FALSE is returned.

--*/

{

    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    NTSTATUS Status;
    UNICODE_STRING TypeName;

    //
    // Initialize string descriptor.
    //

    RtlInitUnicodeString(&TypeName, L"Channel");

    //
    // Create channel object type descriptor.
    //

    RtlZeroMemory(&ObjectTypeInitializer, sizeof(ObjectTypeInitializer));
    ObjectTypeInitializer.Length = sizeof(ObjectTypeInitializer);
    ObjectTypeInitializer.GenericMapping = KiChannelMapping;
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof(ECHANNEL);
    ObjectTypeInitializer.ValidAccessMask = CHANNEL_ALL_ACCESS;
    ObjectTypeInitializer.InvalidAttributes = OBJ_EXCLUSIVE | OBJ_INHERIT | OBJ_PERMANENT;
    ObjectTypeInitializer.CloseProcedure = KiCloseChannel;
    ObjectTypeInitializer.DeleteProcedure = KiDeleteChannel;
    Status = ObCreateObjectType(&TypeName,
                                &ObjectTypeInitializer,
                                NULL,
                                &KeChannelType);

    //
    // If the channel object type descriptor was successfully created, then
    // return a value of TRUE. Otherwise return a value of FALSE.
    //

    return (BOOLEAN)(NT_SUCCESS(Status));
}

VOID
KiCloseChannel (
    IN PEPROCESS Process,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG ProcessHandleCount,
    IN ULONG SystemHandleCount
    )

/*++

Routine Description:

    This function is called when a handle to a channel is closed. If the
    hanlde is the last handle in the process to the channel object and
    the channel object is a message channel, then send a message to the
    server indicating that the client handle is being closed.

Arguments:

    Object - Supplies a pointer to an executive channel.

Return Value:

    None.

--*/

{
    PECHANNEL MessageChannel = (PECHANNEL)Object;

    //
    // If the object is a message channel and hte last handle is being
    // closed, then send a message to the server indicating that the
    // channel is being closed.
    //

    if ((MessageChannel->ServerChannel != NULL) &&
        (ProcessHandleCount == 1)) {
    }

    return;
}

VOID
KiDeleteChannel (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for channel objects. Its function
    is to ...

Arguments:

    Object - Supplies a pointer to an executive channel.

Return Value:

    None.

--*/

{

    PRECHANNEL ChannelObject = (PECHANNEL)Object;

    //
    // If the channel is a message channel, then dereference the connnected
    // server channel.
    //

    if (ChannelObject->ServerChannel != NULL) {
        ObDereferenceObject(ChannelObject->ServerChannel);
    }

    return;
}

VOID
KiRundownChannel (
    VOID
    )

/*++

Routine Description:

    This function runs down associated channel object and receive buffers
    when the a thread is terminated.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // If the current thread has an associated receive buffer, then unmap
    // the receive buffer and dereference the underlying section.
    //

    Thread = KeGetCurrentThread();
    if (Thread->Section != NULL) {
        MmUnmapViewOfSection(PsGetCurrentProcess(), Thread->ThreadView);
        MmUnmapViewInSystemSpace(Thread->SystemView);
        ObDereferenceObject(Thread->Section);
        Thread->Section = NULL;
    }

    //
    // If the current thread has an associated channel, then ...
    //

    return;
}

NTSTATUS
KiListenChannel (
    IN PRECHANNEL ServerChannel,
    IN KPROCESSOR_MODE WaitMode,
    OUT PCHANNEL_MESSAGE *Message
    )

/*++

Routine Description:

    This function listens for a client message to arrive.

    N.B. This function can only be executed from a server thread.

Arguments:

    ServerChannel - Supplies a pointer to a litent channel on which the
        server thread listens.

    WaitMode - Supplies the processor wait mode.

    Message - Supplies a pointer to a variable that receives a pointer
        to the client message header.

Return Value:

    If the function is successfully completed, then a success status is
    returned. Otherwise, a failure status is returned.

--*/

{

    PKEVENT ClearToSendEvent;
    PKTHREAD ClientThread;
    PKQUEUE Queue;
    PKTHREAD ServerThread;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;
    NTSTATUS WaitStatus;

    //
    // Raise IRQL to dispatch level and lock the dispatcher database.
    //

    ServerThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&ServerThread->WaitIrql);

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //

    do {

        //
        // Check if there is a thread waiting on the clear to send event.
        //

        ClearToSendEvent = &ServerChannel->ClearToSendEvent;
        WaitEntry = ClearToSendEvent->Header.WaitListHead.Flink;
        if (WaitEntry != &ClearToSendEvent->Header.WaitListHead) {
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            ClientThread = WaitBlock->Thread;

            //
            // Remove the wait block from the wait list of the receive event,
            // and remove the client thread from the wait list.
            //

            RemoveEntryList(&WaitBlock->WaitListEntry);
            RemoveEntryList(&ClientThread->WaitListEntry);

            //
            // If the client thread is processing a queue entry, then increment the
            // count of currently active threads.
            //

            Queue = ClientThread->Queue;
            if (Queue != NULL) {
                Queue->CurrentCount += 1;
            }

            //
            // Set the wait completion status to kernel APC so the client
            // will attempt another rendezvous and ready the client thread
            // for execution.
            //

            ClientThread->WaitStatus = STATUS_KERNEL_APC;
            KiReadyThread(ClientThread);
        }

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor
        // just after IRQL was raised to DISPATCH_LEVEL, but before the
        // dispatcher database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (ServerThread->ApcState.KernelApcPending &&
            (ServerThread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its
            // previous value. An APC interrupt will immediately occur
            // which will result in the delivery of the kernel APC if
            // possible.
            //

            KiUnlockDispatcherDatabase(ServerThread->WaitIrql);

        } else {

            //
            // Test if a user APC is pending.
            //

            if ((WaitMode != KernelMode) &&
                (ServerThread->ApcState.UserApcPending)) {
                WaitStatus = STATUS_USER_APC;
                break;
            }

            //
            // Construct a wait block for the clear to send event object.
            //

            WaitBlock = &ServerThread->WaitBlock[0];
            ServerThread->WaitBlockList = WaitBlock;
            ServerThread->WaitStatus = (NTSTATUS)0;
            WaitBlock->Object = (PVOID)&ServerChannel->ReceiveEvent;
            WaitBlock->NextWaitBlock = WaitBlock;
            WaitBlock->WaitKey = (CSHORT)STATUS_SUCCESS;
            WaitBlock->WaitType = WaitAny;
            InsertTailList(&ServerChannel->ReceiveEvent.Header.WaitListHead,
                           &WaitBlock->WaitListEntry);

            //
            // If the current thread is processing a queue entry, then
            // attempt to activate another thread that is blocked on the
            // queue object.
            //

            Queue = ServerThread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher
            // state to Waiting, and insert the thread in the wait list.
            //

            ServerThread->Alertable = FALSE;
            ServerThread->WaitMode = WaitMode;
            ServerThread->WaitReason = WrRendezvous;
            ServerThread->WaitTime = KiQueryLowTickCount();
            ServerThread->State = Waiting;
            KiInsertWaitList(WaitMode, ServerThread);

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(KeIsExecutingDpc() == FALSE);
            ASSERT(ServerThread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = KiSwapThread();

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {

                //
                // If a client message was successfully received, then
                // attempt to write the address of the send message
                // address. If the write attempt fails, then do not
                // report an error. When the caller attempts to access
                // the message address, an access violation will occur.
                //

                  if (NT_SUCCESS(WaitStatus)) {
                      try {
                          *Message = ServerThread->ThreadView;

                      } except(ExSystemExceptionFilter()) {
                      }
                  }

                return WaitStatus;
            }
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&ServerThread->WaitIrql);
    } while (TRUE);

    //
    // Unlock the dispatcher database and return the target thread.
    //

    KiUnlockDispatcherDatabase(ServerThread->WaitIrql);
    return WaitStatus;
}

PKTHREAD
KiRendezvousWithThread (
    IN PRECHANNEL WaitChannel,
    IN ULONG WaitMode
    )

/*++

Routine Description:

    This function performs a rendezvous with a thread waiting on the
    channel receive event.

    N.B. This routine is called with the dispatcher database locked.

    N.B. The wait IRQL is assumed to be set for the current thread.

    N.B. Control is returned from this function with the dispatcher
        database unlocked.

Arguments:

    WaitChannel - Supplies a pointer to a channel whose receive event
        is the target of the rendezvous operation.

    WaitMode - Supplies the processor wait mode.

Return Value:

    If a thread rendezvous is successfully performed, then the address
    of the thread object is returned as the completion status. Otherwise,
    if the wait completes because of a timeout or because the thread is
    being terminated, then the appropriate status is returned.

--*/

{

    PKTHREAD CurrentThread;
    PKQUEUE Queue;
    PKTHREAD TargetThread;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;
    NTSTATUS WaitStatus;

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //
    // If the rendezvous event wait list is not empty, then remove the first
    // entry from the list, compute the address of the respective thread,
    // cancel the thread timer if appropraite, and return the thread address.
    // Otherwise, wait for a thread to rendezvous with.
    //

    CurrentThread = KeGetCurrentThread();
    do {

        //
        // Check if there is a thread waiting on the rendezvous event.
        //

        WaitEntry = WaitChannel->ReceiveEvent.Header.WaitListHead.Flink;
        if (WaitEntry != &WaitChannel->ReceiveEvent.Header.WaitListHead) {
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            TargetThread = WaitBlock->Thread;

            //
            // Remove the wait block from the wait list of the receive event,
            // and remove the target thread from the wait list.
            //

            RemoveEntryList(&WaitBlock->WaitListEntry);
            RemoveEntryList(&TargetThread->WaitListEntry);

            //
            // If the target thread is processing a queue entry, then increment the
            // count of currently active threads.
            //

            Queue = TargetThread->Queue;
            if (Queue != NULL) {
                Queue->CurrentCount += 1;
            }

            //
            // Set the thread state to transistion.
            //

            TargetThread->State = Transition;
            break;

        } else {

            //
            // Test to determine if a kernel APC is pending.
            //
            // If a kernel APC is pending and the previous IRQL was less than
            // APC_LEVEL, then a kernel APC was queued by another processor
            // just after IRQL was raised to DISPATCH_LEVEL, but before the
            // dispatcher database was locked.
            //
            // N.B. that this can only happen in a multiprocessor system.
            //

            if (CurrentThread->ApcState.KernelApcPending &&
                (CurrentThread->WaitIrql < APC_LEVEL)) {

                //
                // Unlock the dispatcher database and lower IRQL to its
                // previous value. An APC interrupt will immediately occur
                // which will result in the delivery of the kernel APC if
                // possible.
                //

                KiUnlockDispatcherDatabase(CurrentThread->WaitIrql);

            } else {

                //
                // Test if a user APC is pending.
                //

                if ((WaitMode != KernelMode) &&
                    (CurrentThread->ApcState.UserApcPending)) {
                    TargetThread = (PKTHREAD)STATUS_USER_APC;
                    break;
                }

                //
                // Construct a wait block for the clear to send event object.
                //

                WaitBlock = &CurrentThread->WaitBlock[0];
                CurrentThread->WaitBlockList = WaitBlock;
                CurrentThread->WaitStatus = (NTSTATUS)0;
                WaitBlock->Object = (PVOID)&WaitChannel->ClearToSendEvent;
                WaitBlock->NextWaitBlock = WaitBlock;
                WaitBlock->WaitKey = (CSHORT)STATUS_SUCCESS;
                WaitBlock->WaitType = WaitAny;
                InsertTailList(&WaitChannel->ClearToSendEvent.Header.WaitListHead,
                               &WaitBlock->WaitListEntry);

                //
                // If the current thread is processing a queue entry, then
                // attempt to activate another thread that is blocked on the
                // queue object.
                //

                Queue = CurrentThread->Queue;
                if (Queue != NULL) {
                    KiActivateWaiterQueue(Queue);
                }

                //
                // Set the thread wait parameters, set the thread dispatcher
                // state to Waiting, and insert the thread in the wait list.
                //

                CurrentThread->Alertable = FALSE;
                CurrentThread->WaitMode = (KPROCESSOR_MODE)WaitMode;
                CurrentThread->WaitReason = WrRendezvous;
                CurrentThread->WaitTime = KiQueryLowTickCount();
                CurrentThread->State = Waiting;
                KiInsertWaitList(WaitMode, CurrentThread);

                //
                // Switch context to selected thread.
                //
                // Control is returned at the original IRQL.
                //

                ASSERT(KeIsExecutingDpc() == FALSE);
                ASSERT(CurrentThread->WaitIrql <= DISPATCH_LEVEL);

                WaitStatus = KiSwapThread();

                //
                // If the thread was not awakened to deliver a kernel mode APC,
                // then return wait status.
                //

                if (WaitStatus != STATUS_KERNEL_APC) {
                    return (PKTHREAD)WaitStatus;
                }
            }

            //
            // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
            //

            KiLockDispatcherDatabase(&CurrentThread->WaitIrql);
        }

    } while (TRUE);

    //
    // Unlock the dispatcher database and return the target thread.
    //

    KiUnlockDispatcherDatabase(CurrentThread->WaitIrql);
    return TargetThread;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\dpcobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcobj.c

Abstract:

    This module implements the kernel DPC object. Functions are provided
    to initialize, insert, and remove DPC objects.

Author:

    David N. Cutler (davec) 6-Mar-1989

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, KeFlushQueuedDpcs)
#endif


//
// The following assert macro is used to check that an input dpc is
// really a kdpc and not something else, like deallocated pool.
//

#define ASSERT_DPC(E) {             \
    ASSERT((E)->Type == DpcObject); \
}

VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    )

/*++

Routine Description:

    This function initializes a kernel DPC object. The deferred routine
    and context parameter are stored in the DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Dpc->Type = DpcObject;
    Dpc->Number = 0;
    Dpc->Importance = MediumImportance;

    //
    // Initialize deferred routine address and deferred context parameter.
    //

    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->DeferredContext = DeferredContext;
    Dpc->Lock = NULL;
    return;
}

BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function inserts a DPC object into the DPC queue. If the DPC object
    is already in the DPC queue, then no operation is performed. Otherwise,
    the DPC object is inserted in the DPC queue and a dispatch interrupt is
    requested.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    SystemArgument1, SystemArgument2  - Supply a set of two arguments that
        contain untyped data provided by the executive.

Return Value:

    If the DPC object is already in a DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    ULONG Index;
    PKSPIN_LOCK Lock;
    KIRQL OldIrql;
    PKPRCB Prcb;
    ULONG Processor;

    ASSERT_DPC(Dpc);

    //
    // Disable interrupts.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Acquire the DPC queue lock for the specified target processor.
    //

#if !defined(NT_UP)

    if (Dpc->Number >= MAXIMUM_PROCESSORS) {
        Processor = Dpc->Number - MAXIMUM_PROCESSORS;
        Prcb = KiProcessorBlock[Processor];

    } else {
        Prcb = KeGetCurrentPrcb();
    }

    KiAcquireSpinLock(&Prcb->DpcLock);

#else

    Prcb = KeGetCurrentPrcb();

#endif

    //
    // If the DPC object is not in a DPC queue, then store the system
    // arguments, insert the DPC object in the DPC queue, increment the
    // number of DPCs queued to the target processor, increment the DPC
    // queue depth, set the address of the DPC target DPC spinlock, and
    // request a dispatch interrupt if appropriate.
    //

    if ((Lock = InterlockedCompareExchangePointer(&Dpc->Lock, &Prcb->DpcLock, NULL)) == NULL) {
        Prcb->DpcCount += 1;
        Prcb->DpcQueueDepth += 1;
        Dpc->SystemArgument1 = SystemArgument1;
        Dpc->SystemArgument2 = SystemArgument2;

        //
        // If the DPC is of high importance, then insert the DPC at the
        // head of the DPC queue. Otherwise, insert the DPC at the end
        // of the DPC queue.
        //

        if (Dpc->Importance == HighImportance) {
            InsertHeadList(&Prcb->DpcListHead, &Dpc->DpcListEntry);

        } else {
            InsertTailList(&Prcb->DpcListHead, &Dpc->DpcListEntry);
        }

        //
        // If a DPC routine is not active on the target processor, then
        // request a dispatch interrupt if appropriate.
        //

        if ((Prcb->DpcRoutineActive == FALSE) &&
            (Prcb->DpcInterruptRequested == FALSE)) {

            //
            // Request a dispatch interrupt on the current processor if
            // the DPC is not of low importance, the length of the DPC
            // queue has exceeded the maximum threshold, or if the DPC
            // request rate is below the minimum threshold.
            //

#if defined(NT_UP)

            if ((Dpc->Importance != LowImportance) ||
                (Prcb->DpcQueueDepth >= Prcb->MaximumDpcQueueDepth) ||
                (Prcb->DpcRequestRate < Prcb->MinimumDpcRate)) {
                Prcb->DpcInterruptRequested = TRUE;
                KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
            }

            //
            // If the DPC is being queued to another processor and the
            // DPC is of high importance, or the length of the other
            // processor's DPC queue has exceeded the maximum threshold,
            // then request a dispatch interrupt.
            //

#else

            if (Prcb != KeGetCurrentPrcb()) {
                if (((Dpc->Importance == HighImportance) ||
                     (Prcb->DpcQueueDepth >= Prcb->MaximumDpcQueueDepth))) {
                    Prcb->DpcInterruptRequested = TRUE;
                    KiIpiSend(AFFINITY_MASK(Processor), IPI_DPC);
                }

            } else {

                //
                // Request a dispatch interrupt on the current processor if
                // the DPC is not of low importance, the length of the DPC
                // queue has exceeded the maximum threshold, or if the DPC
                // request rate is below the minimum threshold.
                //

                if ((Dpc->Importance != LowImportance) ||
                    (Prcb->DpcQueueDepth >= Prcb->MaximumDpcQueueDepth) ||
                    (Prcb->DpcRequestRate < Prcb->MinimumDpcRate)) {
                    Prcb->DpcInterruptRequested = TRUE;
                    KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
                }
            }

#endif

        }
     }

     //
     // Release the DPC lock, enable interrupts, and return whether the
     // DPC was queued or not.
     //

#if !defined(NT_UP)

     KiReleaseSpinLock(&Prcb->DpcLock);

#endif

     KeLowerIrql(OldIrql);
     return (Lock == NULL);
}

BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    )

/*++

Routine Description:

    This function removes a DPC object from the DPC queue. If the DPC object
    is not in the DPC queue, then no operation is performed. Otherwise, the
    DPC object is removed from the DPC queue and its inserted state is set
    FALSE.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

Return Value:

    If the DPC object is not in the DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    PKSPIN_LOCK Lock;
    PKPRCB Prcb;

    ASSERT_DPC(Dpc);

    //
    // If the DPC object is in the DPC queue, then remove it from the queue
    // and set its inserted state to FALSE.
    //

    _disable();
    Lock = Dpc->Lock;
    if (Lock != NULL) {

        //
        // Acquire the DPC lock of the target processor.
        //

#if !defined(NT_UP)

        KiAcquireSpinLock(Lock);

#endif

        //
        // If the specified DPC is still in the DPC queue, then remove
        // it.
        //
        // N.B. It is possible for specified DPC to be removed from the
        //      specified DPC queue before the DPC lock is obtained.
        //
        //

        if (Lock == Dpc->Lock) {
            Prcb = CONTAINING_RECORD(Lock, KPRCB, DpcLock);
            Prcb->DpcQueueDepth -= 1;
            RemoveEntryList(&Dpc->DpcListEntry);
            Dpc->Lock = NULL;
        }

        //
        // Release the DPC lock of the target processor.
        //

#if !defined(NT_UP)

        KiReleaseSpinLock(Lock);

#endif

    }

    //
    // Enable interrupts and return whether the DPC was removed from a DPC
    // queue.
    //

    _enable();
    return (Lock != NULL);
}

VOID
KeSetImportanceDpc (
    IN PRKDPC Dpc,
    IN KDPC_IMPORTANCE Importance
    )

/*++

Routine Description:

    This function sets the importance of a DPC.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    Number - Supplies the importance of the DPC.

Return Value:

    None.

--*/

{

    //
    // Set the importance of the DPC.
    //

    Dpc->Importance = (UCHAR)Importance;
    return;
}

VOID
KeSetTargetProcessorDpc (
    IN PRKDPC Dpc,
    IN CCHAR Number
    )

/*++

Routine Description:

    This function sets the processor number to which the DPC is targeted.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    Number - Supplies the target processor number.

Return Value:

    None.

--*/

{

    //
    // Set target processor number.
    //
    // The target processor number if biased by the maximum number of
    // processors that are supported.
    //

    Dpc->Number = MAXIMUM_PROCESSORS + Number;
    return;
}

VOID
KeFlushQueuedDpcs(
    VOID
    )
/*++

Routine Description:

    This function causes all current DPCs on all processors to execute to completion.
    This is used at driver unload to make sure all driver DPC processing has exited the
    driver image before the code and data is deleted

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PKTHREAD CurrentThread;
    KPRIORITY OldPriority;
    KAFFINITY ProcessorMask;
    BOOLEAN SetAffinity;

#endif

    PAGED_CODE ();

#if !defined(NT_UP)

    //
    // Set the priority of this thread high so we will always run on the target processor
    //

    CurrentThread = KeGetCurrentThread();
    OldPriority = KeSetPriorityThread(CurrentThread, HIGH_PRIORITY);
    ProcessorMask = KeActiveProcessors;
    SetAffinity = FALSE;

    //
    // Subtract the processor we are running on now from the affinity mask and let the
    // kernel select the next processor we can run on.
    //

    ProcessorMask &= ~(AFFINITY_MASK(KeGetCurrentProcessorNumber()));
    while (ProcessorMask) {
       KeSetSystemAffinityThread(ProcessorMask);
       SetAffinity = TRUE;
       ProcessorMask &= ~(AFFINITY_MASK(KeGetCurrentProcessorNumber()));
    }

    //
    // Put affinity and priority back as it was
    //

    if (SetAffinity) {
        KeRevertToUserAffinityThread ();
    }

    OldPriority = KeSetPriorityThread(CurrentThread, OldPriority);

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\genxx.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifndef LONG_MAX
#define LONG_MAX ((LONG)0x7FFFFFFF)
#endif

#ifndef LONG_MIN
#define LONG_MIN ((LONG)0x80000000)
#endif


#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genOff(Pc, KPCR, MinorVersion, 128)
//
// -> #define PcMinorVersion 0xffffff80
//

#define genOff(Prefix, Type, Member, Offset) \
    { SEF_EQUATE, OFFSET(Type, Member) - Offset, #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
//

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//

define(`makezeros',`ifelse(eval($1),0,,`0,makezeros(eval($1-1))')')

//
// Define a concatenation macro.
//

define(`cat',`$1$2')

//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
//

define(`BITFIELD_STRUCS',`')

//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//

define(`startBitStruc', `define(`BIT_STRUC_NAME',`$1')
                         define(`BITFIELD_STRUCS',
                                 BITFIELD_STRUCS
                                 )
                         define(`ZERO_FIELDS',0)
                         define(`SEF_TYPE',$2)
                        ')

//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by DUMP_BITFIELDS, below.  If I were more proficient with M4 I
// would know how to get around this.
//

define(`genBitField', `define(`VAR_NAME', cat(cat(BIT_STRUC_NAME,`_'),$1))
                      `#'define `def_'VAR_NAME
                      BIT_STRUC_NAME VAR_NAME = {'
                      `makezeros(ZERO_FIELDS)'
                      `(ULONG_PTR)-1 };'
                      `define(`PAD_VAR_NAME', cat(cat(BIT_STRUC_NAME,`p'),$1))'
                      `ULONG64 PAD_VAR_NAME = 0x8000000000000000UI64;'
                      `define(`ZERO_FIELDS',incr(ZERO_FIELDS))'
                      `define(`FIELD_NAME', $1)'
                      `define(`FIELD_ASMNAME', $2)'
                      `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `dec_'VAR_NAME
                               `#de'fine `dec_'VAR_NAME
                               { SEF_BITFLD | SEF_TYPE cma (ULONG_PTR)&VAR_NAME cma "FIELD_ASMNAME" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                      )

define(`genBitAlias', `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `deca_'VAR_NAME
                               `#de'fine `deca_'VAR_NAME
                               { SEF_BITALIAS | SEF_TYPE cma 0 cma "$1" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                    )

//
// DUMP_BITFIELDS dumps the array initializers accumulated by BITFIELD_STRUCS,
// after replacing each 'cma' with an actual comma.
//

define(`DUMP_BITFIELDS',`define(`cma',`,') BITFIELD_STRUCS')

#endif  // SKIP_M4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\eventobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventobj.c

Abstract:

    This module implements the kernel event objects. Functions are
    provided to initialize, pulse, read, reset, and set event objects.

Author:

    David N. Cutler (davec) 27-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text (PAGE, KeInitializeEventPair)

#undef KeClearEvent

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

//
// The following assert macro is used to check that an input event is
// really a kernel event pair and not something else, like deallocated
// pool.
//

#define ASSERT_EVENT_PAIR(E) {                        \
    ASSERT((E)->Type == EventPairObject);             \
}


#undef KeInitializeEvent

VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    )

/*++

Routine Description:

    This function initializes a kernel event object. The initial signal
    state of the object is set to the specified value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Type - Supplies the type of event; NotificationEvent or
        SynchronizationEvent.

    State - Supplies the initial signal state of the event object.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header, set initial signal
    // state of event object, and set the type of event object.
    //

    Event->Header.Type = (UCHAR)Type;
    Event->Header.Size = sizeof(KEVENT) / sizeof(LONG);
    Event->Header.SignalState = State;
    InitializeListHead(&Event->Header.WaitListHead);
    return;
}

VOID
KeInitializeEventPair (
    IN PKEVENT_PAIR EventPair
    )

/*++

Routine Description:

    This function initializes a kernel event pair object. A kernel event
    pair object contains two separate synchronization event objects that
    are used to provide a fast interprocess synchronization capability.

Arguments:

    EventPair - Supplies a pointer to a control object of type event pair.

Return Value:

    None.

--*/

{

    //
    // Initialize the type and size of the event pair object and initialize
    // the two event object as synchronization events with an initial state
    // of FALSE.
    //

    EventPair->Type = (USHORT)EventPairObject;
    EventPair->Size = sizeof(KEVENT_PAIR);
    KeInitializeEvent(&EventPair->EventLow, SynchronizationEvent, FALSE);
    KeInitializeEvent(&EventPair->EventHigh, SynchronizationEvent, FALSE);
    return;
}

VOID
KeClearEvent (
    IN PRKEVENT Event
    )

/*++

Routine Description:

    This function clears the signal state of an event object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    ASSERT_EVENT(Event);

    //
    // Clear signal state of event object.
    //

    Event->Header.SignalState = 0;
    return;
}

LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function atomically sets the signal state of an event object to
    Signaled, attempts to satisfy as many Waits as possible, and then resets
    the signal state of the event object to Not-Signaled. The previous signal
    state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current state of the event object is Not-Signaled and
    // the wait queue is not empty, then set the state of the event
    // to Signaled, satisfy as many Waits as possible, and then reset
    // the state of the event to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    if ((OldState == 0) && (IsListEmpty(&Event->Header.WaitListHead) == FALSE)) {
        Event->Header.SignalState = 1;
        KiWaitTest(Event, Increment);
    }

    Event->Header.SignalState = 0;

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to the
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitIrql = OldIrql;
        Thread->WaitNext = Wait;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeReadStateEvent (
    IN PRKEVENT Event
    )

/*++

Routine Description:

    This function reads the current signal state of an event object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The current signal state of the event object.

--*/

{

    ASSERT_EVENT(Event);

    //
    // Return current signal state of event object.
    //

    return Event->Header.SignalState;
}

LONG
KeResetEvent (
    IN PRKEVENT Event
    )

/*++

Routine Description:

    This function resets the signal state of an event object to
    Not-Signaled. The previous state of the event object is returned
    as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of event object and then reset
    // the state of the event object to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    Event->Header.SignalState = 0;

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of an event object to Signaled
    and attempts to satisfy as many Waits as possible. The previous
    signal state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Collect call data.
    //

#if defined(_COLLECT_SET_EVENT_CALLDATA_)

    RECORD_CALL_DATA(&KiSetEventCallData);

#endif

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the wait list is empty, then set the state of the event to signaled.
    // Otherwise, check if the wait can be satisfied immediately.
    //

    OldState = Event->Header.SignalState;
    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // If the event is a notification event or the wait is not a wait any,
        // then set the state of the event to signaled and attempt to satisfy
        // as many waits as possible. Otherwise, the wait can be satisfied by
        // directly unwaiting the thread.
        //

        WaitBlock = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                      KWAIT_BLOCK,
                                      WaitListEntry);

        if ((Event->Header.Type == NotificationEvent) ||
            (WaitBlock->WaitType != WaitAny)) {
            if (OldState == 0) {
                Event->Header.SignalState = 1;
                KiWaitTest(Event, Increment);
            }

        } else {
            KiUnwaitThread(WaitBlock->Thread,
                           (NTSTATUS)WaitBlock->WaitKey,
                           Increment,
                           NULL);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
       Thread = KeGetCurrentThread();
       Thread->WaitNext = Wait;
       Thread->WaitIrql = OldIrql;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    )

/*++

Routine Description:

    This function conditionally sets the signal state of an event object
    to Signaled, and attempts to unwait the first waiter, and optionally
    returns the thread address of the unwatied thread.

    N.B. This function can only be called with synchronization events.
         It is assumed that the waiter is NEVER waiting on multiple
         objects.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Thread - Supplies an optional pointer to a variable that receives
        the address of the thread that is awakened.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    KIRQL OldIrql;
    KPRIORITY Priority;
    PKWAIT_BLOCK WaitBlock;
    PRKTHREAD WaitThread;

    ASSERT(Event->Header.Type == SynchronizationEvent);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the the wait list is not empty, then satisfy the wait of the
    // first thread in the wait list. Otherwise, set the signal state
    // of the event object.
    //

    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // Get the address of the first wait block in the event list.
        // If the wait is a wait any, then set the state of the event
        // to signaled and attempt to satisfy as many waits as possible.
        // Otherwise, unwait the first thread and apply an appropriate
        // priority boost to help prevent lock convoys from forming.
        //
        // N.B. Internal calls to this function for resource and fast
        //      mutex boosts NEVER call with a possibility of having
        //      a wait type of WaitAll. Calls from the NT service to
        //      set event and boost priority are restricted as to the
        //      event type, but not the wait type.
        //

        WaitBlock = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                      KWAIT_BLOCK,
                                      WaitListEntry);

        if (WaitBlock->WaitType == WaitAll) {
            Event->Header.SignalState = 1;
            KiWaitTest(Event, EVENT_INCREMENT);

        } else {

            //
            // Get the address of the waiting thread and return the address
            // if requested.
            //

            WaitThread = WaitBlock->Thread;
            if (ARGUMENT_PRESENT(Thread)) {
                *Thread = WaitThread;
            }

            //
            // If the current thread has received an unusual boost (most
            // likely when it acquired the lock associated with the event
            // being set), then remove the boost.
            //

            CurrentThread->Priority -= CurrentThread->PriorityDecrement;
            CurrentThread->PriorityDecrement = 0;

            //
            // If the priority of the waiting thread is less than or equal
            // to the priority of the current thread and the waiting thread
            // priority is less than the time critical priority bound and
            // boosts are not disabled for the waiting thread, then boost
            // the priority of the waiting thread to the minimum of the
            // priority of the current thread priority plus one and the time
            // critical bound minus one. This boost will be taken away at
            // quantum end.
            //

            if ((WaitThread->Priority <= CurrentThread->Priority) &&
                (WaitThread->Priority < TIME_CRITICAL_PRIORITY_BOUND) &&
                (WaitThread->DisableBoost == FALSE)) {
                WaitThread->Priority -= WaitThread->PriorityDecrement;
                Priority = min(CurrentThread->Priority + 1,
                               TIME_CRITICAL_PRIORITY_BOUND - 1);

                WaitThread->PriorityDecrement = (SCHAR)(Priority - WaitThread->Priority);
                WaitThread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
                WaitThread->Priority = (SCHAR)Priority;
            }

            //
            // Make sure the thread has a quantum that is appropriate for
            // lock ownership.
            //

            if (WaitThread->Quantum < (WAIT_QUANTUM_DECREMENT * 4)) {
                WaitThread->Quantum = WAIT_QUANTUM_DECREMENT * 4;
            }

            //
            // Unlink the thread from the appropriate wait queues, set
            // the wait completion status, charge quantum for the wait,
            // and ready the thread for execution.
            //

            KiUnlinkThread(WaitThread, STATUS_SUCCESS);
            WaitThread->Quantum -= WAIT_QUANTUM_DECREMENT;
            KiReadyThread(WaitThread);
        }
    }

    //
    // Unlock dispatcher database lock and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\interobj.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    interobj.c

Abstract:

    This module implements functions to acquire and release the spin lock
    associated with an interrupt object.

Author:

    David N. Cutler (davec) 10-Apr-2000


Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"


KIRQL
KeAcquireInterruptSpinLock (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function raises the IRQL to the interrupt synchronization level
    and acquires the actual spin lock associated with an interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to interrupt synchronization level and acquire the actual
    // spin lock associated with the interrupt object.
    //

    KeRaiseIrql(Interrupt->SynchronizeIrql, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(Interrupt->ActualLock);
    return OldIrql;
}

VOID
KeReleaseInterruptSpinLock (
    IN PKINTERRUPT Interrupt,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases the actual spin lock associated with an interrupt
    object and lowers the IRQL to its previous value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    OldIrql - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    //
    // Release the actual spin lock associated with the interrupt object
    // and lower IRQL to its previous value.
    //

    KeReleaseSpinLockFromDpcLevel(Interrupt->ActualLock);
    KeLowerIrql(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\dpcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcsup.c

Abstract:

    This module contains the support routines for the system DPC objects.
    Functions are provided to process quantum end, the power notification
    queue, and timer expiration.

Author:

    David N. Cutler (davec) 22-Apr-1989

Environment:

    Kernel mode only, IRQL DISPATCH_LEVEL.

Revision History:

--*/

#include "ki.h"

//
// Define DPC entry structure and maximum DPC List size.
//

#define MAXIMUM_DPC_LIST_SIZE 16

typedef struct _DPC_ENTRY {
    PRKDPC Dpc;
    PKDEFERRED_ROUTINE Routine;
    PVOID Context;
} DPC_ENTRY, *PDPC_ENTRY;

PRKTHREAD
KiQuantumEnd (
    VOID
    )

/*++

Routine Description:

    This function is called when a quantum end event occurs on the current
    processor. Its function is to determine whether the thread priority should
    be decremented and whether a redispatch of the processor should occur.

Arguments:

    None.

Return Value:

    The next thread to be schedule on the current processor is returned as
    the function value. If this value is not NULL, then the return is with
    the dispatcher database locked. Otherwise, the dispatcher database is
    unlocked.

--*/

{

    KPRIORITY NewPriority;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PKPROCESS Process;
    PRKTHREAD Thread;
    PRKTHREAD NextThread;

    //
    // Acquire the dispatcher database lock.
    //

    Prcb = KeGetCurrentPrcb();
    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the quantum has expired for the current thread, then update its
    // quantum and priority.
    //

    if (Thread->Quantum <= 0) {

        //
        // If quantum runout is disabled for the thread's process and
        // the thread is running at a realtime priority, then set the
        // thread quantum to the highest value and do not round robin
        // at the thread's priority level. Otherwise, reset the thread
        // quantum and decay the thread's priority as appropriate.
        //

        Process = Thread->ApcState.Process;
        if ((Process->DisableQuantum != FALSE) &&
            (Thread->Priority >= LOW_REALTIME_PRIORITY)) {
            Thread->Quantum = MAXCHAR;

        } else {
            Thread->Quantum = Process->ThreadQuantum;

            //
            // Decrement the thread's current priority if the thread is not
            // running in a realtime priority class and check to determine
            // if the processor should be redispatched.
            //

            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                NewPriority = Priority - Thread->PriorityDecrement - 1;
                if (NewPriority < Thread->BasePriority) {
                    NewPriority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            } else {
                NewPriority = Priority;
            }

            //
            // If the new thread priority is different that the current thread
            // priority, then the thread does not run at a realtime level and
            // its priority should be set. Otherwise, attempt to round robin
            // at the current level.
            //

            if (Priority != NewPriority) {
                KiSetPriorityThread(Thread, NewPriority);

            } else {
                if (Prcb->NextThread == NULL) {
                    NextThread = KiFindReadyThread(Thread->NextProcessor, Priority);

                    if (NextThread != NULL) {
                        NextThread->State = Standby;
                        Prcb->NextThread = NextThread;
                    }

                } else {
                    Thread->Preempted = FALSE;
                }
            }
        }
    }

    //
    // If a thread was scheduled for execution on the current processor,
    // then return the address of the thread with the dispatcher database
    // locked. Otherwise, return NULL with the dispatcher data unlocked.
    //

    NextThread = Prcb->NextThread;
    if (NextThread == NULL) {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return NextThread;
}

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER CurrentTime
    )

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;

    //
    // Raise IRQL to highest level and scan timer table for timers that
    // have expired.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {
                DbgBreakPoint();
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);

    //
    // Lower IRQL to the previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

#endif

VOID
KiTimerExpiration (
    IN PKDPC TimerDpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the clock interupt routine discovers that
    a timer has expired.

Arguments:

    TimerDpc - Not used.

    DeferredContext - Not used.

    SystemArgument1 - Supplies the starting timer table index value to
        use for the timer table scan.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{

    ULARGE_INTEGER CurrentTime;
    LIST_ENTRY ExpiredListHead;
    LONG HandLimit;
    LONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;

    //
    // Acquire the dispatcher database lock and read the current interrupt
    // time to determine which timers have expired.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiQueryInterruptTime((PLARGE_INTEGER)&CurrentTime);

    //
    // If the timer table has not wrapped, then start with the specified
    // timer table index value, and scan for timer entries that have expired.
    // Otherwise, start with the first entry in the timer table and scan the
    // entire table for timer entries that have expired.
    //
    // N.B. This later condition exists when DPC processing is blocked for a
    //      period longer than one round trip throught the timer table.
    //

    HandLimit = (LONG)KiQueryLowTickCount();
    if (((ULONG)(HandLimit - PtrToLong(SystemArgument1))) >= TIMER_TABLE_SIZE) {
        Index = - 1;
        HandLimit = TIMER_TABLE_SIZE - 1;

    } else {
        Index = (PtrToLong(SystemArgument1) - 1) & (TIMER_TABLE_SIZE - 1);
        HandLimit &= (TIMER_TABLE_SIZE - 1);
    }

    InitializeListHead(&ExpiredListHead);
    do {
        Index = (Index + 1) & (TIMER_TABLE_SIZE - 1);
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {

                //
                // The next timer in the current timer list has expired.
                // Remove the entry from the timer list and insert the
                // timer in the expired list.
                //

                RemoveEntryList(&Timer->TimerListEntry);
                InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
                NextEntry = ListHead->Flink;

            } else {
                break;
            }
        }

    } while(Index != HandLimit);

#if DBG

    if ((PtrToUlong(SystemArgument2) == 0) && (KeNumberProcessors == 1)) {
        KiCheckTimerTable(CurrentTime);
    }

#endif

    //
    // Process the expired timer list.
    //
    // N.B. The following function returns with the dispatcher database
    //      unlocked.
    //

    KiTimerListExpire(&ExpiredListHead, OldIrql);
    return;
}

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is called to process a list of timers that have expired.

    N.B. This function is called with the dispatcher database locked and
        returns with the dispatcher database unlocked.

Arguments:

    ExpiredListHead - Supplies a pointer to a list of timers that have
        expired.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    LONG Count;
    PKDPC Dpc;
    DPC_ENTRY DpcList[MAXIMUM_DPC_LIST_SIZE];
    LONG Index;
    LARGE_INTEGER Interval;
    KIRQL OldIrql1;
    LARGE_INTEGER SystemTime;
    PKTIMER Timer;
    LONG Period;
    LOGICAL PerfLogging;
    LARGE_INTEGER TimeStamp;
    PERFINFO_DPC_INFORMATION DpcInfo;

    

    //
    // Capture the timer expiration time.
    //

    KiQuerySystemTime(&SystemTime);

    //
    // Remove the next timer from the expired timer list, set the state of
    // the timer to signaled, reinsert the timer in the timer tree if it is
    // periodic, and optionally call the DPC routine if one is specified.
    //

RestartScan:
    Count = 0;
    while (ExpiredListHead->Flink != ExpiredListHead) {
        Timer = CONTAINING_RECORD(ExpiredListHead->Flink, KTIMER, TimerListEntry);
        KiRemoveTreeTimer(Timer);
        Timer->Header.SignalState = 1;

        //
        // Capture the DPC and Period fields from the timer object. Once we have
        // called KiWaitTest, we must not touch the KTIMER again (unless it is 
        // periodic). A thread may allocate a KTIMER on its local stack and wait
        // on it. KiWaitTest will cause that thread to immediately start running.
        // If it returns, the KTIMER will be corrupted.
        // 

        Dpc = Timer->Dpc;
        Period = Timer->Period;
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer. If this happens, then the
        //      insertion is retried.
        //

        if (Period != 0) {
            Interval.QuadPart = Int32x32To64(Period, - 10 * 1000);
            do {
            } while (KiInsertTreeTimer(Timer, Interval) == FALSE);
        }

        if (Dpc != NULL) {

            //
            // If the DPC is explicitly targeted to another processor, then
            // queue the DPC to the target processor. Otherwise, capture the
            // DPC parameters for execution on the current processor.
            //

#if defined(NT_UP)

            DpcList[Count].Dpc = Dpc;
            DpcList[Count].Routine = Dpc->DeferredRoutine;
            DpcList[Count].Context = Dpc->DeferredContext;
            Count += 1;
            if (Count == MAXIMUM_DPC_LIST_SIZE) {
                break;
            }

#else

            if ((Dpc->Number >= MAXIMUM_PROCESSORS) &&
                (((ULONG)Dpc->Number - MAXIMUM_PROCESSORS) != (ULONG)KeGetCurrentProcessorNumber())) {
                KeInsertQueueDpc(Dpc,
                                 ULongToPtr(SystemTime.LowPart),
                                 ULongToPtr(SystemTime.HighPart));

            } else {
                DpcList[Count].Dpc = Dpc;
                DpcList[Count].Routine = Dpc->DeferredRoutine;
                DpcList[Count].Context = Dpc->DeferredContext;
                Count += 1;
                if (Count == MAXIMUM_DPC_LIST_SIZE) {
                    break;
                }
            }

#endif

        }
    }

    //
    // Unlock the dispacher database and process DPC list entries.
    //

    if (Count != 0) {
        KiUnlockDispatcherDatabase(DISPATCH_LEVEL);

        if (PERFINFO_IS_GROUP_ON(PERF_DPC)) {
            PerfLogging = TRUE;
            PerfTimeStamp(TimeStamp);
        } else {
            PerfLogging = FALSE;
        }
        
        Index = 0;
        do {

#if DBG && defined(i386)

            //
            // Reset the dpc tick count. If the tick count handler,
            // which increments this value, detects that it has crossed
            // a certain threshold, a breakpoint will be generated.
            //

            KeGetCurrentPrcb()->DebugDpcTime = 0;

#endif

            (DpcList[Index].Routine)(DpcList[Index].Dpc,
                                     DpcList[Index].Context,
                                     ULongToPtr(SystemTime.LowPart),
                                     ULongToPtr(SystemTime.HighPart));

            if (PerfLogging != FALSE) {
                DpcInfo.InitialTime = TimeStamp.QuadPart;
                DpcInfo.DpcRoutine = DpcList[Index].Routine;
                
                PerfInfoLogBytes(PERFINFO_LOG_TYPE_TIMERDPC,
                            (PVOID) &DpcInfo,
                            sizeof(DpcInfo));

                //
                // Get time for next iteration
                //
                
                PerfTimeStamp(TimeStamp);
            }


            Index += 1;
        } while (Index < Count);

        //
        // If processing of the expired timer list was terminated because
        // the DPC List was full, then process any remaining entries.
        //

        if (Count == MAXIMUM_DPC_LIST_SIZE) {
            KiLockDispatcherDatabase(&OldIrql1);
            goto RestartScan;
        }

        KeLowerIrql(OldIrql);

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\kevutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kevutil.c

Abstract:

    This module implements various utilities required to do driver verification.

Author:

    Adrian J. Oney (adriao) 20-Apr-1998

Environment:

    Kernel mode

Revision History:

    AdriaO      02/10/2000 - Seperated out from ntos\io\ioassert.c

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEVRFY, KevUtilAddressToFileHeader)
#endif // ALLOC_PRAGMA

NTSTATUS
KevUtilAddressToFileHeader(
    IN  PVOID                   Address,
    OUT UINT_PTR                *OffsetIntoImage,
    OUT PUNICODE_STRING         *DriverName,
    OUT BOOLEAN                 *InVerifierList
    )
/*++

Routine Description:

    This function returns the name of a driver based on the specified
    Address. In addition, the offset into the driver is returned along
    with an indication as to whether the driver is among the list of those
    being verified.

Arguments:

    Address         - Supplies an address to resolve to a driver name.

    OffsetIntoImage - Recieves the offset relative to the base of the driver.

    DriverName      - Recieves a pointer to the name of the driver.

    InVerifierList  - Receives TRUE if the driver is in the verifier list,
                      FALSE otherwise.

Return Value:

    NTSTATUS (On failure, OffsetIntoImage receives NULL, DriverName receives
              NULL, and InVerifierList receives FALSE).

--*/
{
    PLIST_ENTRY pModuleListHead, next;
    PLDR_DATA_TABLE_ENTRY pDataTableEntry;
    UINT_PTR bounds, pReturnBase, pCurBase;

    //
    // Preinit for failure
    //
    *DriverName = NULL;
    *InVerifierList = FALSE;
    *OffsetIntoImage = 0;

    //
    // Set initial values for the module walk
    //
    pReturnBase = 0;
    pModuleListHead = &PsLoadedModuleList;

    //
    // It would be nice if we could call MiLookupDataTableEntry, but it's
    // pageable, so we do what the bugcheck stuff does...
    //
    next = pModuleListHead->Flink;
    if (next != NULL) {
        while (next != pModuleListHead) {

            //
            // Extract the data table entry
            //
            pDataTableEntry = CONTAINING_RECORD(
                next,
                LDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks
                );

            next = next->Flink;
            pCurBase = (UINT_PTR) pDataTableEntry->DllBase;
            bounds = pCurBase + pDataTableEntry->SizeOfImage;
            if ((UINT_PTR)Address >= pCurBase && (UINT_PTR)Address < bounds) {

                //
                // We have a match, record it and get out of here.
                //
                pReturnBase = pCurBase;
                break;
            }
        }
    }

    if (!pReturnBase) {

        //
        // ADRIAO BUGBUG 02/16/2000 -
        //     Get better error code.
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Here we go!
    //
    *OffsetIntoImage = (UINT_PTR) Address - pReturnBase;
    *DriverName = &pDataTableEntry->BaseDllName;

    //
    // Now record whether this is in the verifying table.
    //
    if (pDataTableEntry->Flags & LDRP_IMAGE_VERIFYING) {

        *InVerifierList = TRUE;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\kernldat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kernldat.c

Abstract:

    This module contains the declaration and allocation of kernel data
    structures.

Author:

    David N. Cutler (davec) 12-Mar-1989

--*/

#include "ki.h"

//
// The following data is read/write data that is grouped together for
// performance. The layout of this data is important and must not be
// changed.
//
// KiDispatcherReadyListHead - This is an array of type list entry. The
//      elements of the array are indexed by priority. Each element is a list
//      head for a set of threads that are in a ready state for the respective
//      priority. This array is used by the find next thread code to speed up
//      search for a ready thread when a thread becomes unrunnable. See also
//      KiReadySummary.
//

LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];

//
// KiTimerTableListHead - This is a array of list heads that anchor the
//      individual timer lists.
//

LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];

//
// KiTimeUpdateNotifyRoutine - This is the address of a callout routine
//      which is called when the runtime for a thread is updated if the
//      address is not NULL.
//

PTIME_UPDATE_NOTIFY_ROUTINE KiTimeUpdateNotifyRoutine;

//
// Public kernel data declaration and allocation.
//
// KeActiveProcessors - This is the set of processors that active in the
//      system.
//

KAFFINITY KeActiveProcessors = 0;

//
// KeBootTime - This is the absolute time when the system was booted.
//

LARGE_INTEGER KeBootTime;

//
// KeBootTimeBias - The time for which KeBootTime has ever been biased
//

ULONGLONG KeBootTimeBias;

//
// KeInterruptTimeBias - The time for which InterrupTime has ever been biased
//

ULONGLONG KeInterruptTimeBias;

//
// KeBugCheckCallbackListHead - This is the list head for registered
//      bug check callback routines.
//

LIST_ENTRY KeBugCheckCallbackListHead;
LIST_ENTRY KeBugCheckReasonCallbackListHead;

//
// KeBugCheckCallbackLock - This is the spin lock that guards the bug
//      check callback list.
//

KSPIN_LOCK KeBugCheckCallbackLock;

//
// KeDcacheFlushCount - This is the number of data cache flushes that have
//      been performed since the system was booted.
//

ULONG KeDcacheFlushCount = 0;

//
// KeIcacheFlushCount - This is the number of instruction cache flushes that
//      have been performed since the system was booted.
//

ULONG KeIcacheFlushCount = 0;

//
// KeGdiFlushUserBatch - This is the address of the GDI user batch flush
//      routine which is initialized when the win32k subsystem is loaded.
//

PGDI_BATCHFLUSH_ROUTINE KeGdiFlushUserBatch;

//
// KeLoaderBlock - This is a pointer to the loader parameter block which is
//      constructed by the OS Loader.
//

PLOADER_PARAMETER_BLOCK KeLoaderBlock = NULL;

//
// KeMinimumIncrement - This is the minimum time between clock interrupts
//      in 100ns units that is supported by the host HAL.
//

ULONG KeMinimumIncrement;

//
// KeNumberProcessors - This is the number of processors in the configuration.
//      If is used by the ready thread and spin lock code to determine if a
//      faster algorithm can be used for the case of a single processor system.
//      The value of this variable is set when processors are initialized.
//

CCHAR KeNumberProcessors = 0;

//
// KeRegisteredProcessors - This is the maximum number of processors which
// can utilized by the system.
//

#if !defined(NT_UP)

#if DBG

ULONG KeRegisteredProcessors = 4;
ULONG KeLicensedProcessors;

#else

ULONG KeRegisteredProcessors = 2;
ULONG KeLicensedProcessors;

#endif

#endif

//
// KeProcessorArchitecture - Architecture of all processors present in system.
//      See PROCESSOR_ARCHITECTURE_ defines in ntexapi.h
//

USHORT KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

//
// KeProcessorLevel - Architectural specific processor level of all processors
//      present in system.
//

USHORT KeProcessorLevel = 0;

//
// KeProcessorRevision - Architectural specific processor revision number that is
//      the least common denominator of all processors present in system.
//

USHORT KeProcessorRevision = 0;

//
// KeFeatureBits - Architectural specific processor features present
// on all processors.
//

ULONG KeFeatureBits = 0;

//
// KeServiceDescriptorTable - This is a table of descriptors for system
//      service providers. Each entry in the table describes the base
//      address of the dispatch table and the number of services provided.
//

KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES];
KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES];

//
// KeThreadSwitchCounters - These counters record the number of times a
//      thread can be scheduled on the current processor, any processor,
//      or the last processor it ran on.
//

KTHREAD_SWITCH_COUNTERS KeThreadSwitchCounters;

//
// KeTimeIncrement - This is the nominal number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is set by the HAL and is used to compute the dure time for
//      timer table entries.
//

ULONG KeTimeIncrement;

//
// KeTimeSynchronization - This variable controls whether time synchronization
//      is performed using the realtime clock (TRUE) or whether it is under the
//      control of a service (FALSE).
//

BOOLEAN KeTimeSynchronization = TRUE;

//
// KeUserApcDispatcher - This is the address of the user mode APC dispatch
//      code. This address is looked up in NTDLL.DLL during initialization
//      of the system.
//

PVOID KeUserApcDispatcher;

//
// KeUserCallbackDispatcher - This is the address of the user mode callback
//      dispatch code. This address is looked up in NTDLL.DLL during
//      initialization of the system.
//

PVOID KeUserCallbackDispatcher;

//
// KeUserExceptionDispatcher - This is the address of the user mode exception
//      dispatch code. This address is looked up in NTDLL.DLL during system
//      initialization.
//

PVOID KeUserExceptionDispatcher;

//
// KeRaiseUserExceptionDispatcher - This is the address of the raise user
//      mode exception dispatch code. This address is looked up in NTDLL.DLL
//      during system initialization.
//

PVOID KeRaiseUserExceptionDispatcher;

//
// KeLargestCacheLine - This variable contains the size in bytes of
//      the largest cache line discovered during system initialization.
//      It is used to provide the recommend alignment (and padding)
//      for data that may be used heavily by more than one processor.
//      The initial value was chosen as a reasonable value to use on
//      systems where the discovery process doesn't find a value.
//

ULONG KeLargestCacheLine = 64;

//
// Private kernel data declaration and allocation.
//
// KiBugCodeMessages - Address of where the BugCode messages can be found.
//

PMESSAGE_RESOURCE_DATA KiBugCodeMessages = NULL;

//
// KiDmaIoCoherency - This determines whether the host platform supports
//      coherent DMA I/O.
//

ULONG KiDmaIoCoherency;

//
// KiMaximumSearchCount - this is the maximum number of timers entries that
//      have had to be examined to insert in the timer tree.
//

ULONG KiMaximumSearchCount = 0;

//
// KiDebugRoutine - This is the address of the kernel debugger. Initially
//      this is filled with the address of a routine that just returns. If
//      the system debugger is present in the system, then it sets this
//      location to the address of the systemn debugger's routine.
//

PKDEBUG_ROUTINE KiDebugRoutine;

//
// KiDebugSwitchRoutine - This is the address of the kernel debuggers
//      processor switch routine.  This is used on an MP system to
//      switch host processors while debugging.
//

PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;

//
// KiDispatcherLock - This is the spin lock that guards the dispatcher
//      database.
//

extern KSPIN_LOCK KiDispatcherLock;

const CCHAR KiFindFirstSetRight[256] = {
        0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
        4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};

const CCHAR KiFindFirstSetLeft[256] = {
        0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
        4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

//
// KiFreezeExecutionLock - This is the spin lock that guards the freezing
//      of execution.
//

extern KSPIN_LOCK KiFreezeExecutionLock;

//
// KiFreezeLockBackup - For debug builds only.  Allows kernel debugger to
//      be entered even FreezeExecutionLock is jammed.
//

extern KSPIN_LOCK KiFreezeLockBackup;

//
// KiFreezeFlag - For debug builds only.  Flags to track and signal non-
//      normal freezelock conditions.
//

ULONG KiFreezeFlag;

//
// KiSuspenState - Flag to track suspend/resume state of processors.
//

volatile ULONG KiSuspendState;

//
// KiProcessorBlock - This is an array of pointers to processor control blocks.
//      The elements of the array are indexed by processor number. Each element
//      is a pointer to the processor control block for one of the processors
//      in the configuration. This array is used by various sections of code
//      that need to effect the execution of another processor.
//

PKPRCB KiProcessorBlock[MAXIMUM_PROCESSORS];

//
// KeNumberNodes - This is the number of ccNUMA nodes in the system. Logically
// an SMP system is the same as a single node ccNUMA system.
//

UCHAR KeNumberNodes = 1;

//
// KeNodeBlock - This is an array of pointers to KNODE structures. A KNODE
// structure describes the resources of a NODE in a ccNUMA system.
//

KNODE KiNode0;

#if defined(KE_MULTINODE)

PKNODE KeNodeBlock[MAXIMUM_CCNUMA_NODES];
UCHAR KeProcessNodeSeed;

#else

PKNODE KeNodeBlock[1] = { &KiNode0 };

#endif

//
// KiSwapEvent - This is the event that is used to wake up the balance set
//      thread to inswap processes, outswap processes, and to inswap kernel
//      stacks.
//

KEVENT KiSwapEvent;

//
// KiSwappingThread - This is a pointer to the swap thread object.
//

PKTHREAD KiSwappingThread;

//
// KiProcessInSwapListHead - This is the list of processes that are waiting
//      to be inswapped.
//

SINGLE_LIST_ENTRY KiProcessInSwapListHead;

//
// KiProcessOutSwapListHead - This is the list of processes that are waiting
//      to be outswapped.
//

SINGLE_LIST_ENTRY KiProcessOutSwapListHead;

//
// KiStackInSwapListHead - This is the list of threads that are waiting
//      to get their stack inswapped before they can run. Threads are
//      inserted in this list in ready thread and removed by the balance
//      set thread.
//

SINGLE_LIST_ENTRY KiStackInSwapListHead;

//
// KiProfileSourceListHead - The list of profile sources that are currently
//      active.
//

LIST_ENTRY KiProfileSourceListHead;

//
// KiProfileAlignmentFixup - Indicates whether alignment fixup profiling
//      is active.
//

BOOLEAN KiProfileAlignmentFixup;

//
// KiProfileAlignmentFixupInterval - Indicates the current alignment fixup
//      profiling interval.
//

ULONG KiProfileAlignmentFixupInterval;

//
// KiProfileAlignmentFixupCount - Indicates the current alignment fixup
//      count.
//

ULONG KiProfileAlignmentFixupCount;

//
// KiProfileInterval - The profile interval in 100ns units.
//

#if !defined(_IA64_)

ULONG KiProfileInterval = DEFAULT_PROFILE_INTERVAL;

#endif // !_IA64_

//
// KiProfileListHead - This is the list head for the profile list.
//

LIST_ENTRY KiProfileListHead;

//
// KiProfileLock - This is the spin lock that guards the profile list.
//

extern KSPIN_LOCK KiProfileLock;

//
// KiTimerExpireDpc - This is the Deferred Procedure Call (DPC) object that
//      is used to process the timer queue when a timer has expired.
//

KDPC KiTimerExpireDpc;

//
// KiTimeIncrementReciprocal - This is the reciprocal fraction of the time
//      increment value that is specified by the HAL when the system is
//      booted.
//

LARGE_INTEGER KiTimeIncrementReciprocal;

//
// KiTimeIncrementShiftCount - This is the shift count that corresponds to
//      the time increment reciprocal value.
//

CCHAR KiTimeIncrementShiftCount;

//
// KiWaitListHead - This is a list of threads that are waiting with a
//      resident kernel stack and are elligible to have their stack
//      swapped.
//

LIST_ENTRY KiWaitListHead;

//
// KiIpiCounts - This is the instrumentation counters for IPI requests. Each
//      processor has its own set.  Intstrumentation build only.
//

#if NT_INST

KIPI_COUNTS KiIpiCounts[MAXIMUM_PROCESSORS];

#endif  // NT_INST

//
// KxUnexpectedInterrupt - This is the interrupt object that is used to
//      populate the interrupt vector table for interrupt that are not
//      connected to any interrupt.
//

#if defined(_IA64_)

KINTERRUPT KxUnexpectedInterrupt;

#endif

//
// Performance data declaration and allocation.
//
// KiFlushSingleCallData - This is the call performance data for the kernel
//      flush single TB function.
//

#if defined(_COLLECT_FLUSH_SINGLE_CALLDATA_)

CALL_PERFORMANCE_DATA KiFlushSingleCallData;

#endif

//
// KiSetEventCallData - This is the call performance data for the kernel
//      set event function.
//

#if defined(_COLLECT_SET_EVENT_CALLDATA_)

CALL_PERFORMANCE_DATA KiSetEventCallData;

#endif

//
// KiWaitSingleCallData - This is the call performance data for the kernel
//      wait for single object function.
//

#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)

CALL_PERFORMANCE_DATA KiWaitSingleCallData;

#endif

//
// KiEnableTimerWatchdog - Flag to enable/disable timer latency watchdog.
//

#if (DBG)
ULONG KiEnableTimerWatchdog = 1;
#else
ULONG KiEnableTimerWatchdog = 0;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\kiinit.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kiinit.c

Abstract:

    This module implements architecture independent kernel initialization.

Author:

    David N. Cutler 11-May-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// External data.
//

extern KSPIN_LOCK AfdWorkQueueSpinLock;
extern KSPIN_LOCK CcBcbSpinLock;
extern KSPIN_LOCK CcMasterSpinLock;
extern KSPIN_LOCK CcVacbSpinLock;
extern KSPIN_LOCK CcWorkQueueSpinLock;
extern KSPIN_LOCK IopCancelSpinLock;
extern KSPIN_LOCK IopCompletionLock;
extern KSPIN_LOCK IopDatabaseLock;
extern KSPIN_LOCK IopVpbSpinLock;
extern KSPIN_LOCK KiContextSwapLock;
extern KSPIN_LOCK KiDispatcherLock;
extern KSPIN_LOCK NtfsStructLock;
extern KSPIN_LOCK MmPfnLock;
extern KSPIN_LOCK NonPagedPoolLock;
extern KSPIN_LOCK MmSystemSpaceLock;

#if DBG && !defined(_X86_)
extern KSPIN_LOCK KipGlobalAlignmentDatabaseLock;
#endif
//
//
// The following exist to allow testing of NUMA support.
//

ULONG KeVerifyNumaPageShift;
ULONG KeVerifyNumaAffinityShift;
ULONG KeVerifyNumaNodeCount;
ULONG KeVerifyNumaAffinity;
ULONG KeVerifyNumaPageMask;

// End numa test support variables.


//
// Put all code for kernel initialization in the INIT section. It will be
// deallocated by memory management when phase 1 initialization is completed.
//

#if defined(ALLOC_PRAGMA)

#pragma alloc_text(INIT, KeInitSystem)
#pragma alloc_text(INIT, KiInitQueuedSpinLocks)
#pragma alloc_text(INIT, KiInitSystem)
#pragma alloc_text(INIT, KiComputeReciprocal)
#pragma alloc_text(INIT, KeNumaInitialize)

#endif

BOOLEAN
KeInitSystem (
    VOID
    )

/*++

Routine Description:

    This function initializes executive structures implemented by the
    kernel.

    N.B. This function is only called during phase 1 initialization.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if initialization is successful. Otherwise,
    a value of FALSE is returned.

--*/

{

    //
    // Perform platform dependent initialization.
    //

    return KiInitMachineDependent();
}

VOID
KiInitQueuedSpinLocks (
    PKPRCB Prcb,
    ULONG Number
    )

/*++

Routine Description:

    This function initializes the queued spinlock structures in the per
    processor PRCB. This function is called once for each processor as
    it is initialized in an MP system.

Arguments:

    Prcb - Supplies a pointer to a PRCB.

    Number - Supplies the number of respective processor.

Return Value:

    None.

--*/

{

    //
    // Initialize queued spinlock structures.
    //

    Prcb->LockQueue[LockQueueDispatcherLock].Next = NULL;
    Prcb->LockQueue[LockQueueDispatcherLock].Lock = &KiDispatcherLock;

    Prcb->LockQueue[LockQueueContextSwapLock].Next = NULL;
    Prcb->LockQueue[LockQueueContextSwapLock].Lock = &KiContextSwapLock;

    Prcb->LockQueue[LockQueuePfnLock].Next = NULL;
    Prcb->LockQueue[LockQueuePfnLock].Lock = &MmPfnLock;

    Prcb->LockQueue[LockQueueSystemSpaceLock].Next = NULL;
    Prcb->LockQueue[LockQueueSystemSpaceLock].Lock = &MmSystemSpaceLock;

    Prcb->LockQueue[LockQueueBcbLock].Next = NULL;
    Prcb->LockQueue[LockQueueBcbLock].Lock = &CcBcbSpinLock;

    Prcb->LockQueue[LockQueueMasterLock].Next = NULL;
    Prcb->LockQueue[LockQueueMasterLock].Lock = &CcMasterSpinLock;

    Prcb->LockQueue[LockQueueVacbLock].Next = NULL;
    Prcb->LockQueue[LockQueueVacbLock].Lock = &CcVacbSpinLock;

    Prcb->LockQueue[LockQueueWorkQueueLock].Next = NULL;
    Prcb->LockQueue[LockQueueWorkQueueLock].Lock = &CcWorkQueueSpinLock;

    Prcb->LockQueue[LockQueueNonPagedPoolLock].Next = NULL;
    Prcb->LockQueue[LockQueueNonPagedPoolLock].Lock = &NonPagedPoolLock;

    Prcb->LockQueue[LockQueueIoCancelLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoCancelLock].Lock = &IopCancelSpinLock;

    Prcb->LockQueue[LockQueueIoVpbLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoVpbLock].Lock = &IopVpbSpinLock;

    Prcb->LockQueue[LockQueueIoDatabaseLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoDatabaseLock].Lock = &IopDatabaseLock;

    Prcb->LockQueue[LockQueueIoCompletionLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoCompletionLock].Lock = &IopCompletionLock;

    Prcb->LockQueue[LockQueueNtfsStructLock].Next = NULL;
    Prcb->LockQueue[LockQueueNtfsStructLock].Lock = &NtfsStructLock;

    Prcb->LockQueue[LockQueueAfdWorkQueueLock].Next = NULL;
    Prcb->LockQueue[LockQueueAfdWorkQueueLock].Lock = &AfdWorkQueueSpinLock;

    //
    // If this is processor zero, then also initialize the queued spin lock
    // home address.
    //

    if (Number == 0) {
        KeInitializeSpinLock(&KiContextSwapLock);
        KeInitializeSpinLock(&KiDispatcherLock);
        KeInitializeSpinLock(&MmPfnLock);
        KeInitializeSpinLock(&MmSystemSpaceLock);
        KeInitializeSpinLock(&CcBcbSpinLock);
        KeInitializeSpinLock(&CcMasterSpinLock);
        KeInitializeSpinLock(&CcVacbSpinLock);
        KeInitializeSpinLock(&CcWorkQueueSpinLock);
        KeInitializeSpinLock(&IopCancelSpinLock);
        KeInitializeSpinLock(&IopCompletionLock);
        KeInitializeSpinLock(&IopDatabaseLock);
        KeInitializeSpinLock(&IopVpbSpinLock);
        KeInitializeSpinLock(&NonPagedPoolLock);
        KeInitializeSpinLock(&NtfsStructLock);
        KeInitializeSpinLock(&AfdWorkQueueSpinLock);
    }

    return;
}

VOID
KiInitSystem (
    VOID
    )

/*++

Routine Description:

    This function initializes architecture independent kernel structures.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize dispatcher ready queue listheads.
    //

    for (Index = 0; Index < MAXIMUM_PRIORITY; Index += 1) {
        InitializeListHead(&KiDispatcherReadyListHead[Index]);
    }

    //
    // Initialize bug check callback listhead and spinlock.
    //

    InitializeListHead(&KeBugCheckCallbackListHead);
    InitializeListHead(&KeBugCheckReasonCallbackListHead);
    KeInitializeSpinLock(&KeBugCheckCallbackLock);

    //
    // Initialize the timer expiration DPC object.
    //

    KeInitializeDpc(&KiTimerExpireDpc,
                    (PKDEFERRED_ROUTINE)KiTimerExpiration, NIL);

    //
    // Initialize the profile listhead and profile locks
    //

    KeInitializeSpinLock(&KiProfileLock);
    InitializeListHead(&KiProfileListHead);

#if DBG && !defined(_X86_)

    //
    // Initialize the global alignment fault database lock
    //

    KeInitializeSpinLock(&KipGlobalAlignmentDatabaseLock);
#endif

    //
    // Initialize the active profile source listhead.
    //

    InitializeListHead(&KiProfileSourceListHead);

    //
    // Initialize the timer table, the timer completion listhead, and the
    // timer completion DPC.
    //

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        InitializeListHead(&KiTimerTableListHead[Index]);
    }

    //
    // Initialize the swap event, the process inswap listhead, the
    // process outswap listhead, the kernel stack inswap listhead,
    // the wait in listhead, and the wait out listhead.
    //

    KeInitializeEvent(&KiSwapEvent,
                      SynchronizationEvent,
                      FALSE);

    KiProcessInSwapListHead.Next = NULL;
    KiProcessOutSwapListHead.Next = NULL;
    KiStackInSwapListHead.Next = NULL;
    InitializeListHead(&KiWaitListHead);

    //
    // Initialize the system service descriptor table.
    //

    KeServiceDescriptorTable[0].Base = &KiServiceTable[0];
    KeServiceDescriptorTable[0].Count = NULL;
    KeServiceDescriptorTable[0].Limit = KiServiceLimit;

    //
    // The global pointer associated with the table base is placed just
    // before the service table on the ia64.
    //

#if defined(_IA64_)

    KeServiceDescriptorTable[0].TableBaseGpOffset =
                    (LONG)(*(KiServiceTable-1) - (ULONG_PTR)KiServiceTable);

#endif

    KeServiceDescriptorTable[0].Number = &KiArgumentTable[0];
    for (Index = 1; Index < NUMBER_SERVICE_TABLES; Index += 1) {
        KeServiceDescriptorTable[Index].Limit = 0;
    }

    //
    // Copy the system service descriptor table to the shadow table
    // which is used to record the Win32 system services.
    //

    RtlCopyMemory(KeServiceDescriptorTableShadow,
                  KeServiceDescriptorTable,
                  sizeof(KeServiceDescriptorTable));

    //
    // Initialize call performance data structures.
    //

#if defined(_COLLECT_FLUSH_SINGLE_CALLDATA_)

    ExInitializeCallData(&KiFlushSingleCallData);

#endif

#if defined(_COLLECT_SET_EVENT_CALLDATA_)

    ExInitializeCallData(&KiSetEventCallData);

#endif

#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)

    ExInitializeCallData(&KiWaitSingleCallData);

#endif

    return;
}

LARGE_INTEGER
KiComputeReciprocal (
    IN LONG Divisor,
    OUT PCCHAR Shift
    )

/*++

Routine Description:

    This function computes the large integer reciprocal of the specified
    value.

Arguments:

    Divisor - Supplies the value for which the large integer reciprocal is
        computed.

    Shift - Supplies a pointer to a variable that receives the computed
        shift count.

Return Value:

    The large integer reciprocal is returned as the fucntion value.

--*/

{

    LARGE_INTEGER Fraction;
    LONG NumberBits;
    LONG Remainder;

    //
    // Compute the large integer reciprocal of the specified value.
    //

    NumberBits = 0;
    Remainder = 1;
    Fraction.LowPart = 0;
    Fraction.HighPart = 0;
    while (Fraction.HighPart >= 0) {
        NumberBits += 1;
        Fraction.HighPart = (Fraction.HighPart << 1) | (Fraction.LowPart >> 31);
        Fraction.LowPart <<= 1;
        Remainder <<= 1;
        if (Remainder >= Divisor) {
            Remainder -= Divisor;
            Fraction.LowPart |= 1;
        }
    }

    if (Remainder != 0) {
        if ((Fraction.LowPart == 0xffffffff) && (Fraction.HighPart == 0xffffffff)) {
            Fraction.LowPart = 0;
            Fraction.HighPart = 0x80000000;
            NumberBits -= 1;

        } else {
            if (Fraction.LowPart == 0xffffffff) {
                Fraction.LowPart = 0;
                Fraction.HighPart += 1;

            } else {
                Fraction.LowPart += 1;
            }
        }
    }

    //
    // Compute the shift count value and return the reciprocal fraction.
    //

    *Shift = (CCHAR)(NumberBits - 64);
    return Fraction;
}

VOID
KeNumaInitialize (
    VOID
    )

/*++

Routine Description:

  Initialize ntos kernel structures needed to support NUMA.

Arguments:

  None.

Return Value:

  None.

--*/

{

#if defined(KE_MULTINODE)

    NTSTATUS Status;
    HAL_NUMA_TOPOLOGY_INTERFACE HalNumaInfo;
    ULONG ReturnedLength;

    extern PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode;
    extern PHALNUMAPAGETONODE MmPageToNode;

    //
    // Mega Kludge:   For testing purposes on NON-Numa systems,
    // we can have non-numa MP systems report a NUMA configuration.
    //
    // Pass the information obtained from the registry to the HAL
    // in the return info buffer.
    //

    if (KeVerifyNumaNodeCount                         &&
        (KeVerifyNumaNodeCount < 8)                   &&
        KeVerifyNumaAffinity                          &&
        KeVerifyNumaAffinityShift                     &&
        (KeVerifyNumaAffinityShift < 32)              &&
        KeVerifyNumaPageMask                          &&
        (KeVerifyNumaPageMask < KeVerifyNumaNodeCount)&&
        KeVerifyNumaPageShift                         &&
        (KeVerifyNumaPageShift < 32)                      ) {

        struct {
            ULONG Nodes:3;
            ULONG AffinityShift:6;
            ULONG PageShift:6;
            ULONG Signature:17;
            ULONG Affinity;
            ULONG Mask;
        } Fake;

        C_ASSERT(sizeof(Fake) <= sizeof(HalNumaInfo));

        Fake.Signature     = 0x15a5a;
        Fake.PageShift     = KeVerifyNumaPageShift;
        Fake.AffinityShift = KeVerifyNumaAffinityShift;
        Fake.Nodes         = KeVerifyNumaNodeCount;
        Fake.Affinity      = KeVerifyNumaAffinity;
        Fake.Mask          = KeVerifyNumaPageMask;

        RtlCopyMemory(&HalNumaInfo, &Fake, sizeof(Fake));
    }

    //
    // End Mega Kludge.
    //

    Status = HalQuerySystemInformation (HalNumaTopologyInterface,
                                        sizeof(HalNumaInfo),
                                        &HalNumaInfo,
                                        &ReturnedLength);

    if (NT_SUCCESS(Status)) {

        ASSERT (ReturnedLength == sizeof(HalNumaInfo));
        ASSERT (HalNumaInfo.NumberOfNodes <= MAXIMUM_CCNUMA_NODES);
        ASSERT (HalNumaInfo.QueryProcessorNode);
        ASSERT (HalNumaInfo.PageToNode);

        if (HalNumaInfo.NumberOfNodes > 1) {
            KeNumberNodes = (UCHAR)HalNumaInfo.NumberOfNodes;
            MmPageToNode = HalNumaInfo.PageToNode;
            KiQueryProcessorNode = HalNumaInfo.QueryProcessorNode;
        }
    }


#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\ki.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ki.h

Abstract:

    This module contains the private (internal) header file for the
    kernel.

Author:

    David N. Cutler (davec) 28-Feb-1989

Revision History:

--*/

#ifndef _KI_
#define _KI_
#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "zwapi.h"

//
// Private (internal) constant definitions.
//
// Priority increment value definitions
//

#define ALERT_INCREMENT 2           // Alerted unwait priority increment
#define BALANCE_INCREMENT 10        // Balance set priority increment
#define RESUME_INCREMENT 0          // Resume thread priority increment
#define TIMER_EXPIRE_INCREMENT 0    // Timer expiration priority increment

//
// Define time critical priority class base.
//

#define TIME_CRITICAL_PRIORITY_BOUND 14

//
// Define NIL pointer value.
//

#define NIL (PVOID)NULL             // Null pointer to void

//
// Define macros which are used in the kernel only
//
// Clear member in set
//

#define ClearMember(Member, Set) \
    Set = Set & (~(1 << (Member)))

//
// Set member in set
//

#define SetMember(Member, Set) \
    Set = Set | (1 << (Member))

//
// Lock and unlock context swap lock.
//

#define KiLockContextSwap(OldIrql) \
    *(OldIrql) = KeAcquireQueuedSpinLockRaiseToSynch(LockQueueContextSwapLock)

#define KiUnlockContextSwap(OldIrql) \
    KeReleaseQueuedSpinLock(LockQueueContextSwapLock, OldIrql)

VOID
FASTCALL
KiUnlockDispatcherDatabase (
    IN KIRQL OldIrql
    );


// VOID
// KiBoostPriorityThread (
//    IN PKTHREAD Thread,
//    IN KPRIORITY Increment
//    )
//
//*++
//
// Routine Description:
//
//    This function boosts the priority of the specified thread using
//    the same algorithm used when a thread gets a boost from a wait
//    operation.
//
// Arguments:
//
//    Thread  - Supplies a pointer to a dispatcher object of type thread.
//
//    Increment - Supplies the priority increment that is to be applied to
//        the thread's priority.
//
// Return Value:
//
//    None.
//
//--*

#define KiBoostPriorityThread(Thread, Increment) {              \
    KPRIORITY NewPriority;                                      \
    PKPROCESS Process;                                          \
                                                                \
    if ((Thread)->Priority < LOW_REALTIME_PRIORITY) {           \
        if ((Thread)->PriorityDecrement == 0) {                 \
            NewPriority = (Thread)->BasePriority + (Increment); \
            if (NewPriority > (Thread)->Priority) {             \
                if (NewPriority >= LOW_REALTIME_PRIORITY) {     \
                    NewPriority = LOW_REALTIME_PRIORITY - 1;    \
                }                                               \
                                                                \
                Process = (Thread)->ApcState.Process;           \
                (Thread)->Quantum = Process->ThreadQuantum;     \
                KiSetPriorityThread((Thread), NewPriority);     \
            }                                                   \
        }                                                       \
    }                                                           \
}

FORCEINLINE
LOGICAL
KiIsKernelStackSwappable (
    IN KPROCESSOR_MODE WaitMode,
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function determines whether the kernel stack is swappabel for the
    the specified thread in a wait operation.

Arguments:

    WaitMode - Supplies the processor mode of the wait operation.

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    If the kernel stack for the specified thread is swappable, then TRUE is
    returned. Otherwise, FALSE is returned.

--*/

{

    return ((WaitMode != KernelMode) &&                         
            (Thread->EnableStackSwap != FALSE) &&               
            (Thread->Priority < (LOW_REALTIME_PRIORITY + 9)));
}

//
// Private (internal) structure definitions.
//
// APC Parameter structure.
//

typedef struct _KAPC_RECORD {
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC_RECORD, *PKAPC_RECORD;

//
// Executive initialization.
//

VOID
ExpInitializeExecutive (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// Interprocessor interrupt function definitions.
//
// Define immediate interprocessor commands.
//

#define IPI_APC 1                       // APC interrupt request
#define IPI_DPC 2                       // DPC interrupt request
#define IPI_FREEZE 4                    // freeze execution request
#define IPI_PACKET_READY 8              // packet ready request
#define IPI_SYNCH_REQUEST 16            // reverse stall packet request

//
// Define interprocess interrupt types.
//

typedef ULONG KIPI_REQUEST;

typedef
ULONG_PTR
(*PKIPI_BROADCAST_WORKER)(
    IN ULONG_PTR Argument
    );

#if NT_INST

#define IPI_INSTRUMENT_COUNT(a,b) KiIpiCounts[a].b++;

#else

#define IPI_INSTRUMENT_COUNT(a,b)

#endif

//
// Define interprocessor interrupt function prototypes.
//

ULONG_PTR
KiIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    );

#if defined(_AMD64_) || defined(_IA64_)

ULONG
KiIpiProcessRequests (
    VOID
    );

#endif // defined(_AMD64_) || defined(_IA64_)

VOID
FASTCALL
KiIpiSend (
    IN KAFFINITY TargetProcessors,
    IN KIPI_REQUEST Request
    );

VOID
KiIpiSendPacket (
    IN KAFFINITY TargetProcessors,
    IN PKIPI_WORKER WorkerFunction,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
FASTCALL
KiIpiSignalPacketDone (
    IN PKIPI_CONTEXT SignalDone
    );

VOID
KiIpiStallOnPacketTargets (
    KAFFINITY TargetSet
    );

//
// Private (internal) function definitions.
//

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PKQUEUE Queue
    );

BOOLEAN
KiAdjustInterruptTime (
    IN LONGLONG TimeDelta
    );

VOID
KiAllProcessorsStarted (
    VOID
    );

VOID
KiApcInterrupt (
    VOID
    );

NTSTATUS
KiCallUserMode (
    IN PVOID *OutputBuffer,
    IN PULONG OutputLength
    );

typedef struct {
    ULONGLONG               Adjustment;
    LARGE_INTEGER           NewCount;
    volatile LONG           KiNumber;
    volatile LONG           HalNumber;
    volatile LONG           Barrier;
} ADJUST_INTERRUPT_TIME_CONTEXT, *PADJUST_INTERRUPT_TIME_CONTEXT;

VOID
KiCalibrateTimeAdjustment (
    PADJUST_INTERRUPT_TIME_CONTEXT Adjust
    );

VOID
KiChainedDispatch (
    VOID
    );

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER SystemTime
    );

#endif

LARGE_INTEGER
KiComputeReciprocal (
    IN LONG Divisor,
    OUT PCCHAR Shift
    );

ULONG
KiComputeTimerTableIndex (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentCount,
    IN PKTIMER Timer
    );

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    );

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDeliverApc (
    IN KPROCESSOR_MODE PreviousMode,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    );

KCONTINUE_STATUS
KiSetDebugProcessor (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN KPROCESSOR_MODE PreviousMode
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

VOID
KiDispatchInterrupt (
    VOID
    );

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN ULONG Processor,
    KPRIORITY LowPriority
    );

VOID
KiFloatingDispatch (
    VOID
    );

#if !defined(_IA64_) && !defined(_AMD64_)

VOID
FASTCALL
KiFlushSingleTb (
    IN BOOLEAN Invalid,
    IN PVOID Virtual
    );

#endif // !_IA64_ && !_AMD64_

VOID
KiFlushMultipleTb (
    IN BOOLEAN Invalid,
    IN PVOID *Virtual,
    IN ULONG Count
    );

//
// VOID
// KiSetTbFlushTimeStampBusy (
//    VOID
//    )
//
//*++
//
// Routine Description:
//
//    This function sets the TB flush time stamp busy by setting the high
//    order bit of the TB flush time stamp. All readers of the time stamp
//    value will spin until the bit is cleared.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--*

__inline
VOID
KiSetTbFlushTimeStampBusy (
   VOID
   )

{

    LONG Value;

    //
    // While the TB flush time stamp counter is being updated the high
    // order bit of the time stamp value is set. Otherwise, the bit is
    // clear.
    //

    do {
        do {
        } while ((Value = KiTbFlushTimeStamp) < 0);

        //
        // Attempt to set the high order bit.
        //

    } while (InterlockedCompareExchange((PLONG)&KiTbFlushTimeStamp,
                                        Value | 0x80000000,
                                        Value) != Value);

    return;
}

// VOID
// KiClearTbFlushTimeStampBusy (
//    VOID
//    )
//
//*++
//
// Routine Description:
//
//    This function ckears the TB flush time stamp busy by clearing the high
//    order bit of the TB flush time stamp and incrementing the low 32-bit
//    value.
//
//    N.B. It is assumed that the high order bit of the time stamp value
//         is set on entry to this routine.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--*

__inline
VOID
KiClearTbFlushTimeStampBusy (
   VOID
   )

{

    LONG Value;

    //
    // Get the current TB flush time stamp value, compute the next value,
    // and store the result clearing the busy bit.
    //

    Value = (KiTbFlushTimeStamp + 1) & 0x7fffffff;
    InterlockedExchange((PLONG)&KiTbFlushTimeStamp, Value);
    return;
}

PULONG
KiGetUserModeStackAddress (
    VOID
    );

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL
    );

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
KiInitQueuedSpinLocks (
    PKPRCB Prcb,
    ULONG Number
    );

VOID
KiInitSystem (
    VOID
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

LONG
FASTCALL
KiInsertQueue (
    IN PKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    );

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER Interval
    );

VOID
KiInterruptDispatch (
    VOID
    );

VOID
KiInterruptDispatchRaise (
    IN PKINTERRUPT Interrupt
    );

VOID
KiInterruptDispatchSame (
    IN PKINTERRUPT Interrupt
    );

VOID
KiPassiveRelease (
    VOID
    );

PKTHREAD
KiQuantumEnd (
    VOID
    );

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
FASTCALL
KiReadyThread (
    IN PKTHREAD Thread
    );

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    );

#if DBG

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry); \
    (Timer)->TimerListEntry.Flink = NULL;      \
    (Timer)->TimerListEntry.Blink = NULL

#else

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry)

#endif

#if defined(NT_UP)

#define KiRequestApcInterrupt(Processor) KiRequestSoftwareInterrupt(APC_LEVEL)

#else

#define KiRequestApcInterrupt(Processor)                  \
    if (KeGetCurrentPrcb()->Number == (CCHAR)Processor) { \
        KiRequestSoftwareInterrupt(APC_LEVEL);            \
    } else {                                              \
        KiIpiSend(AFFINITY_MASK(Processor), IPI_APC);     \
    }

#endif

#if defined(NT_UP)

#define KiRequestDispatchInterrupt(Processor)

#else

#define KiRequestDispatchInterrupt(Processor)             \
    if (KeGetCurrentPrcb()->Number != (CCHAR)Processor) { \
        KiIpiSend(AFFINITY_MASK(Processor), IPI_DPC);     \
    }

#endif

PKTHREAD
FASTCALL
KiSelectNextThread (
    IN ULONG Processor
    );

KAFFINITY
FASTCALL
KiSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

VOID
KiSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

VOID
KiSuspendNop (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
KiSuspendRundown (
    IN PKAPC Apc
    );

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
KiSwapProcess (
    IN PKPROCESS NewProcess,
    IN PKPROCESS OldProcess
    );

LONG_PTR
FASTCALL
KiSwapThread (
    VOID
    );

VOID
KiThreadStartup (
    IN PVOID StartContext
    );

VOID
KiTimerExpiration (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    );

VOID
KiUnexpectedInterrupt (
    VOID
    );

VOID
FASTCALL
KiUnlinkThread (
    IN PKTHREAD Thread,
    IN LONG_PTR WaitStatus
    );

VOID
FASTCALL
KiUnwaitThread (
    IN PKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment,
    IN PLIST_ENTRY ThreadList OPTIONAL
    );

VOID
KiUserApcDispatcher (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN PKNORMAL_ROUTINE NormalRoutine
    );

VOID
KiUserExceptionDispatcher (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextFrame
    );

BOOLEAN
FASTCALL
KiSwapContext (
    IN PKTHREAD Thread
    );

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PKWAIT_BLOCK WaitBlock
    );

//
// VOID
// FASTCALL
// KiWaitSatisfyAny (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object and performs
//    any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyAny(_Object_, _Thread_) {                               \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    } else if ((_Object_)->Header.Type == MutantObject) {                    \
        (_Object_)->Header.SignalState -= 1;                                 \
        if ((_Object_)->Header.SignalState == 0) {                           \
            (_Thread_)->KernelApcDisable -= (_Object_)->ApcDisable;          \
            (_Object_)->OwnerThread = (_Thread_);                            \
            if ((_Object_)->Abandoned == TRUE) {                             \
                (_Object_)->Abandoned = FALSE;                               \
                (_Thread_)->WaitStatus = STATUS_ABANDONED;                   \
            }                                                                \
                                                                             \
            InsertHeadList((_Thread_)->MutantListHead.Blink,                 \
                           &(_Object_)->MutantListEntry);                    \
        }                                                                    \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyMutant (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for a mutant object.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyMutant(_Object_, _Thread_) {                            \
    (_Object_)->Header.SignalState -= 1;                                     \
    if ((_Object_)->Header.SignalState == 0) {                               \
        (_Thread_)->KernelApcDisable -= (_Object_)->ApcDisable;              \
        (_Object_)->OwnerThread = (_Thread_);                                \
        if ((_Object_)->Abandoned == TRUE) {                                 \
            (_Object_)->Abandoned = FALSE;                                   \
            (_Thread_)->WaitStatus = STATUS_ABANDONED;                       \
        }                                                                    \
                                                                             \
        InsertHeadList((_Thread_)->MutantListHead.Blink,                     \
                       &(_Object_)->MutantListEntry);                        \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyOther (
//    IN PKMUTANT Object
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object except a mutant
//    and performs any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyOther(_Object_) {                                       \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    }                                                                        \
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    );

VOID
KiFreezeTargetExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiPollFreezeExecution (
    VOID
    );

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiSaveProcessorControlState (
    IN PKPROCESSOR_STATE ProcessorState
    );

VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiRestoreProcessorControlState (
    IN PKPROCESSOR_STATE ProcessorState
    );

#define KiEnableAlignmentExceptions()
#define KiDisableAlignmentExceptions()

BOOLEAN
KiHandleAlignmentFault(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance,
    OUT BOOLEAN *ExceptionForwarded
    );

//
// External references to private kernel data structures
//

extern PMESSAGE_RESOURCE_DATA  KiBugCodeMessages;
extern ULONG KiDmaIoCoherency;
extern ULONG KiMaximumDpcQueueDepth;
extern ULONG KiMinimumDpcRate;
extern ULONG KiAdjustDpcThreshold;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;
extern LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];
extern const CCHAR KiFindFirstSetLeft[256];
extern CALL_PERFORMANCE_DATA KiFlushSingleCallData;
extern ULONG_PTR KiHardwareTrigger;
extern KAFFINITY KiIdleSummary;
extern KAFFINITY KiIdleSMTSummary;
extern KEVENT KiSwapEvent;
extern PKTHREAD KiSwappingThread;
extern KNODE KiNode0;
extern KNODE KiNodeInit[];
extern SINGLE_LIST_ENTRY KiProcessInSwapListHead;
extern SINGLE_LIST_ENTRY KiProcessOutSwapListHead;
extern SINGLE_LIST_ENTRY KiStackInSwapListHead;
extern LIST_ENTRY KiProfileSourceListHead;
extern BOOLEAN KiProfileAlignmentFixup;
extern ULONG KiProfileAlignmentFixupInterval;
extern ULONG KiProfileAlignmentFixupCount;
#if defined(_IA64_)
// KiProfileInterval value should be replaced by a call:
// HalQuerySystemInformation(HalProfileSourceInformation)
#else  // !_IA64_
extern ULONG KiProfileInterval;
#endif // !_IA64_
extern LIST_ENTRY KiProfileListHead;
extern KSPIN_LOCK KiProfileLock;
extern ULONG KiReadySummary;
extern UCHAR KiArgumentTable[];
extern ULONG KiServiceLimit;
extern ULONG_PTR KiServiceTable[];
extern CALL_PERFORMANCE_DATA KiSetEventCallData;
extern ULONG KiTickOffset;
extern LARGE_INTEGER KiTimeIncrementReciprocal;
extern CCHAR KiTimeIncrementShiftCount;
extern LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];
extern KAFFINITY KiTimeProcessor;
extern KDPC KiTimerExpireDpc;
extern KSPIN_LOCK KiFreezeExecutionLock;
extern BOOLEAN KiSlavesStartExecution;
extern PTIME_UPDATE_NOTIFY_ROUTINE KiTimeUpdateNotifyRoutine;
extern LIST_ENTRY KiWaitListHead;
extern CALL_PERFORMANCE_DATA KiWaitSingleCallData;
extern ULONG KiEnableTimerWatchdog;

#if defined(_IA64_)

extern ULONG KiMasterRid;
extern ULONGLONG KiMasterSequence;
extern ULONG KiIdealDpcRate;

#if !defined(UP_NT)

extern KSPIN_LOCK KiMasterRidLock;

#endif

VOID
KiSaveEmDebugContext (
    IN OUT PCONTEXT Context
    );

VOID
KiLoadEmDebugContext (
    IN PCONTEXT Context
    );

VOID
KiFlushRse (
    VOID
    );

VOID
KiInvalidateStackedRegisters (
    VOID
    );

NTSTATUS
Ki386CheckDivideByZeroTrap(
    IN PKTRAP_FRAME Frame
    );

#endif // defined(_IA64_)

#if defined(_IA64_)

extern KINTERRUPT KxUnexpectedInterrupt;

#endif

#if NT_INST

extern KIPI_COUNTS KiIpiCounts[MAXIMUM_PROCESSORS];

#endif

extern KSPIN_LOCK KiFreezeLockBackup;
extern ULONG KiFreezeFlag;
extern volatile ULONG KiSuspendState;

#if DBG

extern ULONG KiMaximumSearchCount;

#endif

// VOID
// KiSetSwapEvent (
//    VOID
//    )
//
//*++
//
// Routine Description:
//
//    This function sets the swap event or unwaits the swap thread.
//
//    N.B. The dispatcher lock must be held to call this routine.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--*

__inline
VOID
KiSetSwapEvent (
    VOID
    )

{

    PLIST_ENTRY WaitEntry;

    //
    // If the swap event wait queue is not empty, then unwait the swap
    // thread (there is only one swap thread). Otherwise, set the swap
    // event.
    //

    WaitEntry = KiSwapEvent.Header.WaitListHead.Flink;
    if (WaitEntry != &KiSwapEvent.Header.WaitListHead) {
        KiUnwaitThread(KiSwappingThread, 0, BALANCE_INCREMENT, NULL);

    } else {
        KiSwapEvent.Header.SignalState = 1;
    }

    return;
}

//
// Include platform specific internal kernel header file.
//

#if defined(_AMD64_)

#include "amd64\kiamd64.h"

#elif defined(_X86_)

#include "i386\kix86.h"

#endif // defined(_AMD64_)

#endif // defined(_KI_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\mutntobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mutntobj.c

Abstract:

    This module implements the kernel mutant object. Functions are
    provided to initialize, read, and release mutant objects.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Author:

    David N. Cutler (davec) 16-Oct-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input mutant is
// really a kmutant and not something else, like deallocated pool.
//

#define ASSERT_MUTANT(E) {                    \
    ASSERT((E)->Header.Type == MutantObject); \
}

VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function initializes a kernel mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    InitialOwner - Supplies a boolean value that determines whether the
        current thread is to be the initial owner of the mutant object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListEntry;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, and set the APC disable count
    // to zero (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    if (InitialOwner == TRUE) {
        Thread = KeGetCurrentThread();
        Mutant->Header.SignalState = 0;
        Mutant->OwnerThread = Thread;
        KiLockDispatcherDatabase(&OldIrql);
        ListEntry = Thread->MutantListHead.Blink;
        InsertHeadList(ListEntry, &Mutant->MutantListEntry);
        KiUnlockDispatcherDatabase(OldIrql);

    } else {
        Mutant->Header.SignalState = 1;
        Mutant->OwnerThread = (PKTHREAD)NULL;
    }

    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->Abandoned = FALSE;
    Mutant->ApcDisable = 0;
    return;
}

VOID
KeInitializeMutex (
    IN PRKMUTANT Mutant,
    IN ULONG Level
    )

/*++

Routine Description:

    This function initializes a kernel mutex object. The level number
    is ignored.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Arguments:

    Mutex - Supplies a pointer to a dispatcher object of type mutex.

    Level - Ignored.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListEntry;

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, adn set the APC disable count
    // to one (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    Mutant->Header.SignalState = 1;
    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->OwnerThread = (PKTHREAD)NULL;
    Mutant->Abandoned = FALSE;
    Mutant->ApcDisable = 1;
    return;
}

LONG
KeReadStateMutant (
    IN PRKMUTANT Mutant
    )

/*++

Routine Description:

    This function reads the current signal state of a mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

Return Value:

    The current signal state of the mutant object.

--*/

{

    ASSERT_MUTANT(Mutant);

    //
    // Return current signal state of mutant object.
    //

    return Mutant->Header.SignalState;
}

LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutant object by incrementing the mutant
    count. If the resultant value is one, then an attempt is made to
    satisfy as many Waits as possible. The previous signal state of
    the mutant is returned as the function value. If the Abandoned
    parameter is TRUE, then the mutant object is released by settings
    the signal state to one.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    Increment - Supplies the priority increment that is to be applied
        if setting the event causes a Wait to be satisfied.

    Abandoned - Supplies a boolean value that signifies whether the
        mutant object is being abandoned.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutant will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutant object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;


    ASSERT_MUTANT(Mutant);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the mutant object.
    //

    OldState = Mutant->Header.SignalState;

    //
    // If the Abandoned parameter is TRUE, then force the release of the
    // mutant object by setting its ownership count to one and setting its
    // abandoned state to TRUE. Otherwise increment mutant ownership count.
    // If the result count is one, then remove the mutant object from the
    // thread's owned mutant list, set the owner thread to NULL, and attempt
    // to satisfy a Wait for the mutant object if the mutant object wait
    // list is not empty.
    //

    Thread = KeGetCurrentThread();
    if (Abandoned != FALSE) {
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;

    } else {

        //
        // If the Mutant object is not owned by the current thread, then
        // unlock the dispatcher data base and raise an exception. Otherwise
        // increment the ownership count.
        //

        if (Mutant->OwnerThread != Thread) {
            KiUnlockDispatcherDatabase(OldIrql);
            ExRaiseStatus(Mutant->Abandoned ?
                          STATUS_ABANDONED : STATUS_MUTANT_NOT_OWNED);
        }

        Mutant->Header.SignalState += 1;
    }

    if (Mutant->Header.SignalState == 1) {
        if (OldState <= 0) {
            RemoveEntryList(&Mutant->MutantListEntry);
            Thread->KernelApcDisable += Mutant->ApcDisable;
            if ((Thread->KernelApcDisable == 0) &&
                (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE)) {
                Thread->ApcState.KernelApcPending = TRUE;
                KiRequestSoftwareInterrupt(APC_LEVEL);
            }
        }

        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) == FALSE) {
            KiWaitTest(Mutant, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to
    // caller with IRQL raised and the dispatcher database locked.
    // Else release the dispatcher database lock and lower IRQL to
    // its previous value.
    //

    if (Wait != FALSE) {
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of mutant object.
    //

    return OldState;
}

LONG
KeReleaseMutex (
    IN PRKMUTANT Mutex,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutex object.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Arguments:

    Mutex - Supplies a pointer to a dispatcher object of type mutex.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutex will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutex object.

--*/

{

    ASSERT_MUTANT(Mutex);

    //
    // Release the specified mutex object with defaults for increment
    // and abandoned parameters.
    //

    return KeReleaseMutant(Mutex, 1, FALSE, Wait);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\miscc.c ===
/*++

Copyright (c) 1989-1992  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This module implements machine independent miscellaneous kernel functions.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeAddSystemServiceTable)
#pragma alloc_text(PAGE, KeRemoveSystemServiceTable)
#pragma alloc_text(PAGE, KeSetTimeUpdateNotifyRoutine)
#pragma alloc_text(PAGE, KeQueryActiveProcessors)
#pragma alloc_text(PAGELK, KiCalibrateTimeAdjustment)

#undef KeEnterCriticalRegion

VOID
KeEnterCriticalRegion (
   VOID
   )

/*++

Routine Description:

   This function disables kernel APC's.

   N.B. The following code does not require any interlocks. There are
        two cases of interest: 1) On an MP system, the thread cannot
        be running on two processors as once, and 2) if the thread is
        is interrupted to deliver a kernel mode APC which also calls
        this routine, the values read and stored will stack and unstack
        properly.

Arguments:

   None.

Return Value:

   None.

--*/

{
    //
    // Simply directly disable kernel APCs.
    //

    KeGetCurrentThread()->KernelApcDisable -= 1;
    return;
}

#undef KeLeaveCriticalRegion

VOID
KeLeaveCriticalRegion (
    VOID
    )

/*++

Routine Description:

    This function enables kernel APC's and requests an APC interrupt if
    appropriate.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Increment the kernel APC disable count. If the resultant count is
    // zero and the thread's kernel APC List is not empty, then request an
    // APC interrupt.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that queuing an APC is done by first queuing the APC, then checking
    // the AST disable count. The following code increments the disable
    // count first, checks to determine if it is zero, and then checks the
    // kernel AST queue.
    //
    // See also KiInsertQueueApc().
    //

    KiLeaveCriticalRegion();
    return;
}

ULONGLONG
KeQueryInterruptTime (
    VOID
    )

/*++

Routine Description:

    This function returns the current interrupt time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    LARGE_INTEGER CurrentTime;

    KiQueryInterruptTime(&CurrentTime);
    return CurrentTime.QuadPart;
}

VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    KiQuerySystemTime(CurrentTime);
    return;
}

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    )

/*++

Routine Description:

    This function returns the current tick count by determining when the
    count is stable and then returning its value.

Arguments:

    CurrentCount - Supplies a pointer to a variable that will receive the
        current tick count.

Return Value:

    None.

--*/

{

    KiQueryTickCount(CurrentCount);
    return;
}

ULONG
KeQueryTimeIncrement (
    VOID
    )

/*++

Routine Description:

    This function returns the time increment value in 100ns units. This
    is the value that is added to the system time at each interval clock
    interrupt.

Arguments:

    None.

Return Value:

    The time increment value is returned as the function value.

--*/

{

    return KeMaximumIncrement;
}

VOID
KeEnableInterrupts (
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function enables interrupts based on the specified enable state.

Arguments:

    Enable - Supplies a boolean value that determines whether interrupts
        are to be enabled.

Return Value:

    None.

--*/

{

    if (Enable != FALSE) {
        _enable();
    }

    return;
}

VOID
KeSetDmaIoCoherency (
    IN ULONG Attributes
    )

/*++

Routine Description:

    This function sets (enables/disables) DMA I/O coherency with data
    caches.

Arguments:

    Attributes - Supplies the set of DMA I/O coherency attributes for
        the host system.

Return Value:

    None.

--*/

{

    KiDmaIoCoherency = Attributes;
}

#if defined(_AMD64_) || defined(_X86_)

#pragma alloc_text(INIT, KeSetProfileIrql)

VOID
KeSetProfileIrql (
    IN KIRQL ProfileIrql
    )

/*++

Routine Description:

    This function sets the profile IRQL.

    N.B. There are only two valid values for the profile IRQL which are
        PROFILE_LEVEL and HIGH_LEVEL.

Arguments:

    Irql - Supplies the synchronization IRQL value.

Return Value:

    None.

--*/

{

    ASSERT((ProfileIrql == PROFILE_LEVEL) || (ProfileIrql == HIGH_LEVEL));

    KiProfileIrql = ProfileIrql;
}

#endif

VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime,
    IN BOOLEAN AdjustInterruptTime,
    IN PLARGE_INTEGER HalTimeToSet OPTIONAL
    )

/*++

Routine Description:

    This function sets the system time to the specified value and updates
    timer queue entries to reflect the difference between the old system
    time and the new system time.

Arguments:

    NewTime - Supplies a pointer to a variable that specifies the new system
        time.

    OldTime - Supplies a pointer to a variable that will receive the previous
        system time.

    AdjustInterruptTime - If TRUE the amount of time being adjusted is
        also applied to InterruptTime and TickCount.

    HalTimeToSet - Supplies an optional time that if specified is to be used
        to set the time in the realtime clock.

Return Value:

    None.

--*/

{

    LIST_ENTRY AbsoluteListHead;
    LIST_ENTRY ExpiredListHead;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;
    KIRQL OldIrql2;
    LARGE_INTEGER TimeDelta;
    TIME_FIELDS TimeFields;
    PKTIMER Timer;

    ASSERT((NewTime->HighPart & 0xf0000000) == 0);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // If a realtime clock value is specified, then convert the time value
    // to time fields.
    //

    if (ARGUMENT_PRESENT(HalTimeToSet)) {
        RtlTimeToTimeFields(HalTimeToSet, &TimeFields);
    }

    //
    // Set affinity to the processor that keeps the system time, raise IRQL
    // to dispatcher level and lock the dispatcher database, then raise IRQL
    // to HIGH_LEVEL to synchronize with the clock interrupt routine.
    //

    KeSetSystemAffinityThread((KAFFINITY)1);
    KiLockDispatcherDatabase(&OldIrql1);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql2);

    //
    // Save the previous system time, set the new system time, and set
    // the realtime clock, if a time value is specified.
    //

    KiQuerySystemTime(OldTime);
    SharedUserData->SystemTime.High2Time = NewTime->HighPart;
    SharedUserData->SystemTime.LowPart   = NewTime->LowPart;
    SharedUserData->SystemTime.High1Time = NewTime->HighPart;

    if (ARGUMENT_PRESENT(HalTimeToSet)) {
        ExCmosClockIsSane = HalSetRealTimeClock(&TimeFields);
    }

    //
    // Compute the difference between the previous system time and the new
    // system time.
    //

    TimeDelta.QuadPart = NewTime->QuadPart - OldTime->QuadPart;

    //
    // Update the boot time to reflect the delta. This keeps time based
    // on boot time constant
    //

    KeBootTime.QuadPart = KeBootTime.QuadPart + TimeDelta.QuadPart;

    //
    // Track the overall bias applied to the boot time.
    //

    KeBootTimeBias = KeBootTimeBias + TimeDelta.QuadPart;

    //
    // Lower IRQL to dispatch level and if needed adjust the physical
    // system interrupt time.
    //

    KeLowerIrql(OldIrql2);
    if (AdjustInterruptTime) {

        //
        // Adjust the physical time of the system
        //

        AdjustInterruptTime = KiAdjustInterruptTime (TimeDelta.QuadPart);
    }

    //
    // If the physical interrupt time of the system was not adjusted,
    // recompute any absolute timers in the system for the new
    // system time.
    //

    if (!AdjustInterruptTime) {

        //
        // Remove all absolute timers from the timer queue so their due time
        // can be recomputed.
        //

        InitializeListHead(&AbsoluteListHead);
        for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
            ListHead = &KiTimerTableListHead[Index];
            NextEntry = ListHead->Flink;
            while (NextEntry != ListHead) {
                Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
                NextEntry = NextEntry->Flink;
                if (Timer->Header.Absolute != FALSE) {
                    RemoveEntryList(&Timer->TimerListEntry);
                    InsertTailList(&AbsoluteListHead, &Timer->TimerListEntry);
                }
            }
        }

        //
        // Recompute the due time and reinsert all absolute timers in the timer
        // tree. If a timer has already expired, then insert the timer in the
        // expired timer list.
        //

        InitializeListHead(&ExpiredListHead);
        while (AbsoluteListHead.Flink != &AbsoluteListHead) {
            Timer = CONTAINING_RECORD(AbsoluteListHead.Flink, KTIMER, TimerListEntry);
            KiRemoveTreeTimer(Timer);
            Timer->DueTime.QuadPart -= TimeDelta.QuadPart;
            if (KiReinsertTreeTimer(Timer, Timer->DueTime) == FALSE) {
                Timer->Header.Inserted = TRUE;
                InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
            }
        }

        //
        // If any of the attempts to reinsert a timer failed, then timers have
        // already expired and must be processed.
        //
        // N.B. The following function returns with the dispatcher database
        //      unlocked.
        //

        KiTimerListExpire(&ExpiredListHead, OldIrql1);

    } else {

        KiUnlockDispatcherDatabase(OldIrql1);

    }


    //
    // Set affinity back to its original value.
    //

    KeRevertToUserAffinityThread();

    return;
}

BOOLEAN
KiAdjustInterruptTime (
    IN LONGLONG TimeDelta
    )

/*++

Routine Description:

    This function moves the physical interrupt time of the system foreward by
    the specified time delta after a system wake has occurred.

Arguments:

    TimeDelta - Supplies the time delta to be added to the interrupt time, tick
        count and the perforamnce counter in 100ns units.

Return Value:

    None.

--*/

{

    ADJUST_INTERRUPT_TIME_CONTEXT Adjust;

    //
    // Time can only be moved forward.
    //

    if (TimeDelta < 0) {
        return FALSE;

    } else {
        Adjust.KiNumber = KeNumberProcessors;
        Adjust.HalNumber = KeNumberProcessors;
        Adjust.Adjustment = (ULONGLONG) TimeDelta;
        Adjust.Barrier = 1;
        KiIpiGenericCall((PKIPI_BROADCAST_WORKER)KiCalibrateTimeAdjustment,
                         (ULONG_PTR)(&Adjust));

        return TRUE;
    }
}

VOID
KiCalibrateTimeAdjustment (
    PADJUST_INTERRUPT_TIME_CONTEXT  Adjust
    )

/*++

Routine Description:

    Worker function to calibrate the adjustment of time on all processors.

Arguments:

    Adjust - Supplies the operation context.

Return Value:

    None.

--*/

{

    BOOLEAN             Enable;
    LARGE_INTEGER       InterruptTime;
    LARGE_INTEGER       SetTime;
    LARGE_INTEGER       PerfFreq;
    ULARGE_INTEGER      li;
    LARGE_INTEGER       NewTickCount;
    ULONG               NewTickOffset;
    ULONG               cl, divisor;
    LARGE_INTEGER       PerfCount;

    //
    // As each processor arrives, subtract one off the remaining processor
    // count.  If this is the last processor to arrive compute the time
    // change, and signal all processor when to apply the performance
    // counter change.
    //

    if (InterlockedDecrement((PLONG)&Adjust->KiNumber)) {
        Enable = KeDisableInterrupts();

        //
        // It is possible to deadlock here if one or more of the
        // other processors gets and processes a freeze request
        // while this processor has interrupts disabled.  Poll
        // for IPI_FREEZE requests until all processors are known
        // to be in this code and hence wont be requesting a
        // freeze.
        //

        do {
            KiPollFreezeExecution();
        } while (Adjust->KiNumber != (ULONG)-1);

        //
        // Wait to perform the time set
        //

        while (Adjust->Barrier) ;

    } else {

        //
        // Set timer expiration dpc to scan the timer queues once for any
        // expired timers.
        //

        KeRemoveQueueDpc (&KiTimerExpireDpc);
        KeInsertQueueDpc (&KiTimerExpireDpc, (PVOID) TIMER_TABLE_SIZE, NULL);

        //
        // Disable interrupts and indicate that this processor is now
        // in final portion of this code.
        //

        Enable = KeDisableInterrupts();
        InterlockedDecrement((PLONG) &Adjust->KiNumber);

        //
        // Adjust Interrupt Time.
        //

        InterruptTime.QuadPart = KeQueryInterruptTime() + Adjust->Adjustment;
        SetTime.QuadPart = Adjust->Adjustment;
        
        //
        // Get the current times
        //

        PerfCount = KeQueryPerformanceCounter (&PerfFreq);

        //
        // Compute performance counter for current SetTime
        //

        //
        // Multiply SetTime * PerfCount and obtain 96bit result
        // in cl, li.LowPart, li.HighPart.  Then divide the 96bit
        // result by 10,000,000 to get new performance counter value.
        //

        li.QuadPart = RtlEnlargedUnsignedMultiply (
                            (ULONG) SetTime.LowPart,
                            (ULONG) PerfFreq.LowPart
                            ).QuadPart;

        cl = li.LowPart;
        li.QuadPart = li.HighPart +
                      RtlEnlargedUnsignedMultiply (
                            (ULONG) SetTime.LowPart,
                            (ULONG) PerfFreq.HighPart
                            ).QuadPart;

        li.QuadPart = li.QuadPart +
                      RtlEnlargedUnsignedMultiply (
                            (ULONG) SetTime.HighPart,
                            (ULONG) PerfFreq.LowPart
                            ).QuadPart;

        li.HighPart = li.HighPart + SetTime.HighPart * PerfFreq.HighPart;

        divisor = 10000000;
        Adjust->NewCount.HighPart =
            RtlEnlargedUnsignedDivide (
                li,
                divisor,
                &li.HighPart
                );

        li.LowPart = cl;
        Adjust->NewCount.LowPart =
            RtlEnlargedUnsignedDivide (
                li,
                divisor,
                NULL
                );

        Adjust->NewCount.QuadPart += PerfCount.QuadPart;

        //
        // Compute tick count and tick offset for current InterruptTime
        //

        NewTickCount = RtlExtendedLargeIntegerDivide(
                            InterruptTime,
                            KeMaximumIncrement,
                            &NewTickOffset
                            );

        //
        // Apply changes to InterruptTime, TickCount, TickOffset, and the
        // performance counter
        //

        KiTickOffset = KeMaximumIncrement - NewTickOffset;
        KeInterruptTimeBias += Adjust->Adjustment;
        SharedUserData->TickCountLow = NewTickCount.LowPart;

#if defined(_AMD64_) || defined(_IA64_)

        KeTickCount = NewTickCount;

#else

        KeTickCount.High2Time = NewTickCount.HighPart;
        KeTickCount.LowPart   = NewTickCount.LowPart;
        KeTickCount.High1Time = NewTickCount.HighPart;

#endif

        SharedUserData->InterruptTime.High2Time = InterruptTime.HighPart;
        SharedUserData->InterruptTime.LowPart   = InterruptTime.LowPart;
        SharedUserData->InterruptTime.High1Time = InterruptTime.HighPart;

        //
        // Apply the performance counter change
        //

        Adjust->Barrier = 0;
    }

    HalCalibratePerformanceCounter (
        (LONG volatile *) &Adjust->HalNumber,
        (ULONGLONG) Adjust->NewCount.QuadPart
        );

    KeEnableInterrupts(Enable);
}

VOID
KeSetTimeIncrement (
    IN ULONG MaximumIncrement,
    IN ULONG MinimumIncrement
    )

/*++

Routine Description:

    This function sets the time increment value in 100ns units. This
    value is added to the system time at each interval clock interrupt.

Arguments:

    MaximumIncrement - Supplies the maximum time between clock interrupts
        in 100ns units supported by the host HAL.

    MinimumIncrement - Supplies the minimum time between clock interrupts
        in 100ns units supported by the host HAL.

Return Value:

    None.

--*/

{

    KeMaximumIncrement = MaximumIncrement;
    KeMinimumIncrement = max(MinimumIncrement, 10 * 1000);
    KeTimeAdjustment = MaximumIncrement;
    KeTimeIncrement = MaximumIncrement;
    KiTickOffset = MaximumIncrement;
}

BOOLEAN
KeAddSystemServiceTable(
    IN PULONG_PTR Base,
    IN PULONG Count OPTIONAL,
    IN ULONG Limit,
    IN PUCHAR Number,
    IN ULONG Index
    )

/*++

Routine Description:

    This function allows the caller to add a system service table
    to the system

Arguments:

    Base - Supplies the address of the system service table dispatch
        table.

    Count - Supplies an optional pointer to a table of per system service
        counters.

    Limit - Supplies the limit of the service table. Services greater
        than or equal to this limit will fail.

    Arguments - Supplies the address of the argument count table.

    Index - Supplies index of the service table.

Return Value:

    TRUE - The operation was successful.

    FALSE - the operation failed. A service table is already bound to
        the specified location, or the specified index is larger than
        the maximum allowed index.

--*/

{

    PAGED_CODE();

    //
    // If a system service table is already defined for the specified
    // index, then return FALSE. Otherwise, establish the new system
    // service table.
    //

    if ((Index > NUMBER_SERVICE_TABLES - 1) ||
        (KeServiceDescriptorTable[Index].Base != NULL) ||
        (KeServiceDescriptorTableShadow[Index].Base != NULL)) {
        return FALSE;

    } else {

        //
        // If the service table index is equal to the Win32 table, then
        // only update the shadow system service table. Otherwise, both
        // the shadow and static system service tables are updated.
        //

        KeServiceDescriptorTableShadow[Index].Base = Base;
        KeServiceDescriptorTableShadow[Index].Count = Count;
        KeServiceDescriptorTableShadow[Index].Limit = Limit;

        //
        // The global pointer associated with the table base is
        // placed just before the service table.
        //

#if defined(_IA64_)

        KeServiceDescriptorTableShadow[Index].TableBaseGpOffset =
                                        (LONG)(*(Base-1) - (ULONG_PTR)Base);

#endif

        KeServiceDescriptorTableShadow[Index].Number = Number;
        if (Index != 1) {
            KeServiceDescriptorTable[Index].Base = Base;
            KeServiceDescriptorTable[Index].Count = Count;
            KeServiceDescriptorTable[Index].Limit = Limit;

#if defined(_IA64_)

            KeServiceDescriptorTable[Index].TableBaseGpOffset =
                                        (LONG)(*(Base-1) - (ULONG_PTR)Base);

#endif

            KeServiceDescriptorTable[Index].Number = Number;
        }

        return TRUE;
    }
}

BOOLEAN
KeRemoveSystemServiceTable(
    IN ULONG Index
    )

/*++

Routine Description:

    This function allows the caller to remove a system service table
    from the system. This can only be called at system shutdown.

Arguments:

    Index - Supplies index of the service table.

Return Value:

    TRUE - The operation was successful.

    FALSE - the operation failed. A service table is is not bound or is illegal to remove

--*/

{

    PAGED_CODE();

    if ((Index > NUMBER_SERVICE_TABLES - 1) ||
        ((KeServiceDescriptorTable[Index].Base == NULL) &&
         (KeServiceDescriptorTableShadow[Index].Base == NULL))) {

        return FALSE;

    } else {
        KeServiceDescriptorTableShadow[Index].Base = NULL;
        KeServiceDescriptorTableShadow[Index].Count = 0;
        KeServiceDescriptorTableShadow[Index].Limit = 0;

#if defined(_IA64_)

        KeServiceDescriptorTableShadow[Index].TableBaseGpOffset = 0;

#endif

        KeServiceDescriptorTableShadow[Index].Number = 0;
        if (Index != 1) {
            KeServiceDescriptorTable[Index].Base = NULL;
            KeServiceDescriptorTable[Index].Count = 0;
            KeServiceDescriptorTable[Index].Limit = 0;

#if defined(_IA64_)

            KeServiceDescriptorTable[Index].TableBaseGpOffset = 0;

#endif

            KeServiceDescriptorTable[Index].Number = 0;
        }

        return TRUE;
    }
}

VOID
FASTCALL
KeSetTimeUpdateNotifyRoutine(
    IN PTIME_UPDATE_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function sets the address of a callout routine which will be called
    each time the runtime for a thread is updated.

Arguments:

    RoutineNotify - Supplies the address of the time update notify callout
        routine.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    KiTimeUpdateNotifyRoutine = NotifyRoutine;
    return;
}

KAFFINITY
KeQueryActiveProcessors(
    VOID
    )

/*++

Routine Description:

    This function returns the current set of active processors
    in the system.

Arguments:

    None.

Return Value:

    KAFFINITY bitmask representing the set of active processors

--*/

{
    PAGED_CODE();

    return(KeActiveProcessors);
}

#undef KeIsAttachedProcess

BOOLEAN
KeIsAttachedProcess(
    VOID
    )

/*++

Routine Description:

    This function determines if the current thread is attached to a process.

Arguments:

    None.

Return Value:

    TRUE is returned if the current thread is attached to a process. Otherwise,
    FALSE is returned.

--*/

{
    return KiIsAttachedProcess();
}

#undef KeAreApcsDisabled

BOOLEAN
KeAreApcsDisabled(
    VOID
    )

/*++

Routine Description:

    This function determines if APCs are disabled for the current thread.

Arguments:

    None.

Return Value:

    TRUE is returned if APCs are disabled for the current thread. Otherwise,
    FALE is returned.

--*/

{
    return KeGetCurrentThread()->KernelApcDisable != 0;
}

ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    )

/*++

Routine Description:

    This function returns the size of the largest cache line in the system.
    This value should be used as a recommended alignment / granularity for
    shared data.

Arguments:

    None.

Return Value:

    The size of the largest cache line in the system is returned as the
    function value.

--*/

{
    return KeLargestCacheLine;
}

PKPRCB
KeGetPrcb(
    ULONG ProcessorNumber
    )

/*++

Routine Description:

    This function returns the address of the Processor Control Block (PRCB)
    for the specified processor.

Arguments:

    ProcessorNumber - Supplies the number of the processor the PRCB 
    is to be returned for.

Return Value:

    Returns the address of the requested PRCB or NULL if ProcessorNumber
    is not valid.

--*/

{

    ASSERT(ProcessorNumber < MAXIMUM_PROCESSORS);

    if (ProcessorNumber < (ULONG)KeNumberProcessors) {
        return KiProcessorBlock[ProcessorNumber];
    }

    return NULL;
}

NTSTATUS
KeCopySafe(
    VOID UNALIGNED *Destination,
    CONST VOID UNALIGNED *Source,
    SIZE_T Length
    )

/*++

Routine Description:
    This function attempts to safely copy a block of memory.  If an excpetion occurs the
    exception status is returned.  
    
Arguments:

    Destination - Supplies a pointer to the destination memory.
    
    Source - Supplies a pointer to the source memory.
    
    Length - Supplies the size of memory in bytes to be copied.

Return Value:

    Return the status of the copy.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    try {
        RtlCopyMemory(Destination, Source, Length);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

          Status = _exception_code();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\genxx.inc ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    genxx.inc

Abstract:

    This file contains common code to generate assembler definitions.

Author:

    David N. Cutler (davec) 9-Aug-1995

Revision History:

    Forrest C. Foltz (forrestf) 26-Jan-1998

        Modified for use with genxx.exe utility

--*/

    //
    // Size of a pointer in bytes.
    //

    genCom("Pointer size in bytes")

    genVal(SizeofPointer, sizeof(PVOID))

    //
    // Process state enumerated type definitions.
    //

    genCom("Process State Enumerated Type Values")

    genVal(ProcessInMemory, ProcessInMemory)
    genVal(ProcessOutOfMemory, ProcessOutOfMemory)
    genVal(ProcessInTransition, ProcessInTransition)

    //
    // Thread state enumerated type definitions.
    //

    genCom("Thread State Enumerated Type Values")

    genVal(Initialized, Initialized)
    genVal(Ready, Ready)
    genVal(Running, Running)
    genVal(Standby, Standby)
    genVal(Terminated, Terminated)
    genVal(Waiting, Waiting)

    //
    // Wait reason and wait type enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Wait Reason and Wait Type Enumerated Type Values")

    genVal(WrExecutive, Executive)

    DisableInc(HAL)

    genVal(WrEventPair, WrEventPair)
    genVal(WaitAny, WaitAny)
    genVal(WaitAll, WaitAll)

    //
    // APC state structure offset definitions.
    //

    genCom("Apc State Structure Offset Definitions")

    genDef(As, KAPC_STATE, ApcListHead)
    genDef(As, KAPC_STATE, Process)
    genDef(As, KAPC_STATE, KernelApcInProgress)
    genDef(As, KAPC_STATE, KernelApcPending)
    genDef(As, KAPC_STATE, UserApcPending)

    //
    // Bug check code definitions
    //

    EnableInc(HAL)

    genCom("Bug Check Code Definitions")

    genVal(APC_INDEX_MISMATCH, APC_INDEX_MISMATCH)
    genVal(ATTEMPTED_SWITCH_FROM_DPC, ATTEMPTED_SWITCH_FROM_DPC)
    genVal(DATA_BUS_ERROR, DATA_BUS_ERROR)
    genVal(DATA_COHERENCY_EXCEPTION, DATA_COHERENCY_EXCEPTION)
    genVal(HAL1_INITIALIZATION_FAILED, HAL1_INITIALIZATION_FAILED)
    genVal(INSTRUCTION_BUS_ERROR, INSTRUCTION_BUS_ERROR)
    genVal(INSTRUCTION_COHERENCY_EXCEPTION, INSTRUCTION_COHERENCY_EXCEPTION)
    genVal(INTERRUPT_EXCEPTION_NOT_HANDLED, INTERRUPT_EXCEPTION_NOT_HANDLED)
    genVal(INTERRUPT_UNWIND_ATTEMPTED, INTERRUPT_UNWIND_ATTEMPTED)
    genVal(INVALID_AFFINITY_SET, INVALID_AFFINITY_SET)
    genVal(INVALID_DATA_ACCESS_TRAP, INVALID_DATA_ACCESS_TRAP)
    genVal(IRQL_GT_ZERO_AT_SYSTEM_SERVICE, IRQL_GT_ZERO_AT_SYSTEM_SERVICE)
    genVal(IRQL_NOT_LESS_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL)
    genVal(KMODE_EXCEPTION_NOT_HANDLED, KMODE_EXCEPTION_NOT_HANDLED)
    genVal(NMI_HARDWARE_FAILURE, NMI_HARDWARE_FAILURE)
    genVal(NO_USER_MODE_CONTEXT, NO_USER_MODE_CONTEXT)
    genVal(PAGE_FAULT_WITH_INTERRUPTS_OFF, PAGE_FAULT_WITH_INTERRUPTS_OFF)
    genVal(PANIC_STACK_SWITCH, PANIC_STACK_SWITCH)
    genVal(SPIN_LOCK_INIT_FAILURE, SPIN_LOCK_INIT_FAILURE)
    genVal(SYSTEM_EXIT_OWNED_MUTEX, SYSTEM_EXIT_OWNED_MUTEX)
    genVal(SYSTEM_SERVICE_EXCEPTION, SYSTEM_SERVICE_EXCEPTION)
    genVal(SYSTEM_UNWIND_PREVIOUS_USER, SYSTEM_UNWIND_PREVIOUS_USER)
    genVal(TRAP_CAUSE_UNKNOWN, TRAP_CAUSE_UNKNOWN)
    genVal(UNEXPECTED_KERNEL_MODE_TRAP, UNEXPECTED_KERNEL_MODE_TRAP)
    genVal(HARDWARE_INTERRUPT_STORM, HARDWARE_INTERRUPT_STORM)

    DisableInc(HAL)

    //
    // Breakpoint types
    //

    EnableInc(HAL)

    genCom("Breakpoint type definitions")

    genVal(DBG_STATUS_CONTROL_C, DBG_STATUS_CONTROL_C)

    DisableInc(HAL)

    //
    // Client Id structure offset definitions.
    //

    genCom("Client Id Structure Offset Definitions")

    genDef(Cid, CLIENT_ID, UniqueProcess)
    genDef(Cid, CLIENT_ID, UniqueThread)

    //
    // Critical section structure offset definitions.
    //

    genCom("Critical Section Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION, DebugInfo)
    genDef(Cs, RTL_CRITICAL_SECTION, LockCount)
    genDef(Cs, RTL_CRITICAL_SECTION, RecursionCount)
    genDef(Cs, RTL_CRITICAL_SECTION, OwningThread)
    genDef(Cs, RTL_CRITICAL_SECTION, LockSemaphore)
    genDef(Cs, RTL_CRITICAL_SECTION, SpinCount)

    //
    // Critical section debug information structure offset definitions.
    //

    genCom("Critical Section Debug Information Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, Type)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, CreatorBackTraceIndex)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, CriticalSection)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, ProcessLocksList)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, EntryCount)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, ContentionCount)

    //
    // Exception record offset, flag, and enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Exception Record Offset, Flag, and Enumerated Type Definitions")

    genVal(EXCEPTION_NONCONTINUABLE, EXCEPTION_NONCONTINUABLE)
    genVal(EXCEPTION_UNWINDING, EXCEPTION_UNWINDING)
    genVal(EXCEPTION_EXIT_UNWIND, EXCEPTION_EXIT_UNWIND)
    genVal(EXCEPTION_STACK_INVALID, EXCEPTION_STACK_INVALID)
    genVal(EXCEPTION_NESTED_CALL, EXCEPTION_NESTED_CALL)
    genVal(EXCEPTION_TARGET_UNWIND, EXCEPTION_TARGET_UNWIND)
    genVal(EXCEPTION_COLLIDED_UNWIND, EXCEPTION_COLLIDED_UNWIND)
    genVal(EXCEPTION_UNWIND, EXCEPTION_UNWIND)
    genVal(EXCEPTION_EXECUTE_HANDLER, EXCEPTION_EXECUTE_HANDLER)
    genVal(EXCEPTION_CONTINUE_SEARCH, EXCEPTION_CONTINUE_SEARCH)
    genVal(EXCEPTION_CONTINUE_EXECUTION, EXCEPTION_CONTINUE_EXECUTION)

#if defined(_X86_)

    genVal(EXCEPTION_CHAIN_END, (ULONG)EXCEPTION_CHAIN_END)

    genVal(FIXED_NTVDMSTATE_LINEAR, (ULONG)FIXED_NTVDMSTATE_LINEAR_PC_AT)
#endif

    genSpc()

    genVal(ExceptionContinueExecution, ExceptionContinueExecution)
    genVal(ExceptionContinueSearch, ExceptionContinueSearch)
    genVal(ExceptionNestedException, ExceptionNestedException)
    genVal(ExceptionCollidedUnwind, ExceptionCollidedUnwind)

    genSpc()

    genDef(Er, EXCEPTION_RECORD, ExceptionCode)
    genDef(Er, EXCEPTION_RECORD, ExceptionFlags)
    genDef(Er, EXCEPTION_RECORD, ExceptionRecord)
    genDef(Er, EXCEPTION_RECORD, ExceptionAddress)
    genDef(Er, EXCEPTION_RECORD, NumberParameters)
    genDef(Er, EXCEPTION_RECORD, ExceptionInformation)
    genVal(ExceptionRecordLength, (sizeof(EXCEPTION_RECORD) + 15) & (~15))

    DisableInc(HAL)

    //
    // Fast Mutex structure offset definitions.
    //

    EnableInc(HAL)

    genCom("Fast Mutex Structure Offset Definitions")

    genDef(Fm, FAST_MUTEX, Count)
    genDef(Fm, FAST_MUTEX, Owner)
    genDef(Fm, FAST_MUTEX, Contention)
    genDef(Fm, FAST_MUTEX, Event)
    genDef(Fm, FAST_MUTEX, OldIrql)

    //
    // Interrupt priority request level definitions
    //

    genCom("Interrupt Priority Request Level Definitions")

    genVal(PASSIVE_LEVEL, PASSIVE_LEVEL)
    genVal(APC_LEVEL, APC_LEVEL)
    genVal(DISPATCH_LEVEL, DISPATCH_LEVEL)

#if defined(_AMD64_)

    genVal(CLOCK_LEVEL, CLOCK_LEVEL)

#endif

#if defined(_X86_)

    genVal(CLOCK1_LEVEL, CLOCK1_LEVEL)
    genVal(CLOCK2_LEVEL, CLOCK2_LEVEL)

#endif

    genVal(IPI_LEVEL, IPI_LEVEL)
    genVal(POWER_LEVEL, POWER_LEVEL)
    genVal(PROFILE_LEVEL, PROFILE_LEVEL)
    genVal(HIGH_LEVEL, HIGH_LEVEL)

#if defined(_X86_) || defined(_AMD64_)

    genTxt("ifdef NT_UP\n")
    genVal(SYNCH_LEVEL, DISPATCH_LEVEL)
    genTxt("else\n")
    genVal(SYNCH_LEVEL, IPI_LEVEL - 1)
    genTxt("endif\n")

#else

    genTxt("#ifdef NT_UP\n")
    genVal(SYNCH_LEVEL, DISPATCH_LEVEL)
    genTxt("#else\n")
    genVal(SYNCH_LEVEL, IPI_LEVEL - 1)
    genTxt("#endif\n")

#endif

    //
    // Large integer structure offset definitions.
    //

    genCom("Large Integer Structure Offset Definitions")

    genDef(Li, LARGE_INTEGER, LowPart)
    genDef(Li, LARGE_INTEGER, HighPart)

    //
    // List entry structure offset definitions.
    //

    genCom("List Entry Structure Offset Definitions")

    genDef(Ls, LIST_ENTRY, Flink)
    genDef(Ls, LIST_ENTRY, Blink)

    //
    // String structure offset definitions.
    //

    genCom("String Structure Offset Definitions")

    genDef(Str, STRING, Length)
    genDef(Str, STRING, MaximumLength)
    genDef(Str, STRING, Buffer)

    //
    // System time structure offset definitions.
    //

#if defined(_X86_)

    genCom("System Time Structure Offset Definitions")

    genAlt(StLowTime, KSYSTEM_TIME, LowPart)
    genDef(St, KSYSTEM_TIME, High1Time)
    genDef(St, KSYSTEM_TIME, High2Time)

#endif

    //
    // Time structure offset definitions.
    //

    genCom("Time Structure Offset Definitions")

    genAlt(TmLowTime, LARGE_INTEGER, LowPart)
    genAlt(TmHighTime, LARGE_INTEGER , HighPart)

    DisableInc(HAL)

    //
    // Thread switch counter structure offset definitions.
    //

    genCom("Thread Switch Counter Offset Definitions")

    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindIdeal)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleCurrent)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleIdeal)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptCurrent)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, SwitchToIdle)

    //
    // Status code definitions
    //

    genCom("Status Code Definitions")

#if defined(_IA64_)

    genVal(STATUS_IA64_INVALID_STACK, STATUS_IA64_INVALID_STACK)

#endif

    genVal(STATUS_ACCESS_VIOLATION, STATUS_ACCESS_VIOLATION)
    genVal(STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED)
    genVal(STATUS_BAD_COMPRESSION_BUFFER, STATUS_BAD_COMPRESSION_BUFFER)
    genVal(STATUS_BREAKPOINT, STATUS_BREAKPOINT)
    genVal(STATUS_DATATYPE_MISALIGNMENT, STATUS_DATATYPE_MISALIGNMENT)
    genVal(STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND)
    genVal(STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO)
    genVal(STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT)
    genVal(STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION)
    genVal(STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW)
    genVal(STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK)
    genVal(STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW)
    genVal(STATUS_FLOAT_MULTIPLE_FAULTS, STATUS_FLOAT_MULTIPLE_FAULTS)
    genVal(STATUS_FLOAT_MULTIPLE_TRAPS, STATUS_FLOAT_MULTIPLE_TRAPS)
    genVal(STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION)
    genVal(STATUS_ILLEGAL_FLOAT_CONTEXT, STATUS_ILLEGAL_FLOAT_CONTEXT)
    genVal(STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION)
    genVal(STATUS_INSTRUCTION_MISALIGNMENT, STATUS_INSTRUCTION_MISALIGNMENT)
    genVal(STATUS_INVALID_HANDLE, STATUS_INVALID_HANDLE)
    genVal(STATUS_INVALID_LOCK_SEQUENCE, STATUS_INVALID_LOCK_SEQUENCE)
    genVal(STATUS_INVALID_OWNER, STATUS_INVALID_OWNER)
    genVal(STATUS_INVALID_PARAMETER_1, STATUS_INVALID_PARAMETER_1)
    genVal(STATUS_INVALID_SYSTEM_SERVICE, STATUS_INVALID_SYSTEM_SERVICE)
    genVal(STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO)
    genVal(STATUS_INTEGER_OVERFLOW, STATUS_INTEGER_OVERFLOW)
    genVal(STATUS_IN_PAGE_ERROR, STATUS_IN_PAGE_ERROR)
    genVal(STATUS_KERNEL_APC, STATUS_KERNEL_APC)
    genVal(STATUS_LONGJUMP, STATUS_LONGJUMP)
    genVal(STATUS_NO_CALLBACK_ACTIVE, STATUS_NO_CALLBACK_ACTIVE)
    genVal(STATUS_NO_EVENT_PAIR, STATUS_NO_EVENT_PAIR)
    genVal(STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION)
    genVal(STATUS_SINGLE_STEP, STATUS_SINGLE_STEP)
    genVal(STATUS_STACK_OVERFLOW, STATUS_STACK_OVERFLOW)
    genVal(STATUS_SUCCESS, STATUS_SUCCESS)
    genVal(STATUS_THREAD_IS_TERMINATING, STATUS_THREAD_IS_TERMINATING)
    genVal(STATUS_TIMEOUT, STATUS_TIMEOUT)
    genVal(STATUS_UNWIND, STATUS_UNWIND)
    genVal(STATUS_UNWIND_CONSOLIDATE, STATUS_UNWIND_CONSOLIDATE)
    genVal(STATUS_WAKE_SYSTEM_DEBUGGER, STATUS_WAKE_SYSTEM_DEBUGGER)

    //
    // Define kernel object structure definitions.
    //
    // APC object structure defintions.
    //

    genCom("APC Object Structure Offset Definitions")

    genDef(Ap, KAPC, Type)
    genDef(Ap, KAPC, Size)
    genDef(Ap, KAPC, Thread)
    genDef(Ap, KAPC, ApcListEntry)
    genDef(Ap, KAPC, KernelRoutine)
    genDef(Ap, KAPC, RundownRoutine)
    genDef(Ap, KAPC, NormalRoutine)
    genDef(Ap, KAPC, NormalContext)
    genDef(Ap, KAPC, SystemArgument1)
    genDef(Ap, KAPC, SystemArgument2)
    genDef(Ap, KAPC, ApcStateIndex)
    genDef(Ap, KAPC, ApcMode)
    genDef(Ap, KAPC, Inserted)
    genVal(ApcObjectLength, sizeof(KAPC))

    //
    // DPC Object structure definitions.
    //

    EnableInc(HAL)

    genCom("DPC object Structure Offset Definitions")

    genDef(Dp, KDPC, Type)
    genDef(Dp, KDPC, Number)
    genDef(Dp, KDPC, Importance)
    genDef(Dp, KDPC, DpcListEntry)
    genDef(Dp, KDPC, DeferredRoutine)
    genDef(Dp, KDPC, DeferredContext)
    genDef(Dp, KDPC, SystemArgument1)
    genDef(Dp, KDPC, SystemArgument2)
    genDef(Dp, KDPC, Lock)
    genVal(DpcObjectLength, sizeof(KDPC))

    DisableInc(HAL)

    //
    // Device queue object structure definitions.
    //

    genCom("Device Queue Object Structure Offset Definitions")

    genDef(Dv, KDEVICE_QUEUE, Type)
    genDef(Dv, KDEVICE_QUEUE, Size)
    genDef(Dv, KDEVICE_QUEUE, DeviceListHead)
    genAlt(DvSpinLock, KDEVICE_QUEUE, Lock)
    genDef(Dv, KDEVICE_QUEUE, Busy)
    genVal(DeviceQueueObjectLength, sizeof(KDEVICE_QUEUE))

    //
    // Device object entry structure definitions.
    //

    genCom("Device Queue Entry Structure Offset Definitions")

    genDef(De, KDEVICE_QUEUE_ENTRY, DeviceListEntry)
    genDef(De, KDEVICE_QUEUE_ENTRY, SortKey)
    genDef(De, KDEVICE_QUEUE_ENTRY, Inserted)
    genVal(DeviceQueueEntryLength, sizeof(KDEVICE_QUEUE_ENTRY))

    //
    // Event object structure definitions.
    //

    genCom("Event Object Structure Offset Definitions")

    genDef(Ev, DISPATCHER_HEADER, Type)
    genDef(Ev, DISPATCHER_HEADER, Size)
    genDef(Ev, DISPATCHER_HEADER, SignalState)
    genAlt(EvWaitListHead, KEVENT, Header.WaitListHead)
    genVal(EventObjectLength, sizeof(KEVENT))

    //
    // Event pair object structure definitions.
    //

    genCom("Event Pair Object Structure Offset Definitions")

    genDef(Ep, KEVENT_PAIR, Type)
    genDef(Ep, KEVENT_PAIR, Size)
    genDef(Ep, KEVENT_PAIR, EventLow)
    genDef(Ep, KEVENT_PAIR, EventHigh)

#if defined(_IA64_)

    #define EventOffset (OFFSET(KEVENT_PAIR, EventHigh) - \
                         OFFSET(KEVENT_PAIR, EventLow))

//    if ((EventOffset & (EventOffset - 1)) != 0) {
//        fprintf(stderr, "GENXX: Event offset not log2N\n")
//    }

    genVal(SET_LOW_WAIT_HIGH, - (LONG)(EventOffset * 2))
    genVal(SET_HIGH_WAIT_LOW, - (LONG)EventOffset)
    genVal(SET_EVENT_PAIR_MASK, (LONG)EventOffset)

#endif

    //
    // Interrupt object structure definitions.
    //

#if defined(_AMD64_) || defined(_IA64_)

    EnableInc(HAL)

#endif

    genCom("Interrupt Object Structure Offset Definitions")

    genVal(InLevelSensitive, LevelSensitive)
    genVal(InLatched, Latched)

    genSpc()

    genDef(In, KINTERRUPT, Type)
    genDef(In, KINTERRUPT, Size)
    genDef(In, KINTERRUPT, InterruptListEntry)
    genDef(In, KINTERRUPT, ServiceRoutine)
    genDef(In, KINTERRUPT, ServiceContext)
    genDef(In, KINTERRUPT, SpinLock)
    genDef(In, KINTERRUPT, TickCount)
    genDef(In, KINTERRUPT, ActualLock)
    genDef(In, KINTERRUPT, DispatchAddress)
    genDef(In, KINTERRUPT, Vector)
    genDef(In, KINTERRUPT, Irql)
    genDef(In, KINTERRUPT, SynchronizeIrql)
    genDef(In, KINTERRUPT, FloatingSave)
    genDef(In, KINTERRUPT, Connected)
    genDef(In, KINTERRUPT, Number)
    genDef(In, KINTERRUPT, ShareVector)
    genDef(In, KINTERRUPT, Mode)
    genDef(In, KINTERRUPT, ServiceCount)
    genDef(In, KINTERRUPT, DispatchCount)

#if defined(_AMD64_)

    genDef(In, KINTERRUPT, TrapFrame)

#endif

    genDef(In, KINTERRUPT, DispatchCode)
    genVal(InterruptObjectLength, sizeof(KINTERRUPT))

#if defined(_X86_)

    genSpc()

    genVal(NORMAL_DISPATCH_LENGTH, NORMAL_DISPATCH_LENGTH * sizeof(ULONG))
    genVal(DISPATCH_LENGTH, DISPATCH_LENGTH * sizeof(ULONG))

#endif

#if defined(_AMD64_) || defined(_IA64_)

    DisableInc(HAL)

#endif

    //
    // Process object structure offset definitions.
    //

    genCom("Process Object Structure Offset Definitions")

    genDef(Pr, DISPATCHER_HEADER, Type)
    genDef(Pr, DISPATCHER_HEADER, Size)
    genDef(Pr, DISPATCHER_HEADER, SignalState)
    genDef(Pr, KPROCESS, ProfileListHead)
    genDef(Pr, KPROCESS, DirectoryTableBase)

#if defined(_X86_)

    genDef(Pr, KPROCESS, LdtDescriptor)
    genDef(Pr, KPROCESS, Int21Descriptor)
    genDef(Pr, KPROCESS, IopmOffset)
    genDef(Pr, KPROCESS, Iopl)
    genDef(Pr, KPROCESS, VdmTrapcHandler)
    genDef(Pr, EPROCESS, VdmObjects)
    genDef(Pr, EPROCESS, Flags)

#endif

#if defined(_AMD64_)

    genDef(Pr, KPROCESS, IopmOffset)

#endif

#if defined(_IA64_)

    genDef(Pr, KPROCESS, ProcessRegion)
    genDef(Pr, KPROCESS, SessionMapInfo)
    genDef(Pr, KPROCESS, SessionParentBase)

#endif

    genDef(Pr, KPROCESS, ActiveProcessors)
    genDef(Pr, KPROCESS, KernelTime)
    genDef(Pr, KPROCESS, UserTime)
    genDef(Pr, KPROCESS, ReadyListHead)
    genDef(Pr, KPROCESS, SwapListEntry)
    genDef(Pr, KPROCESS, ThreadListHead)
    genDef(Pr, KPROCESS, ProcessLock)
    genDef(Pr, KPROCESS, Affinity)
    genDef(Pr, KPROCESS, StackCount)
    genDef(Pr, KPROCESS, BasePriority)
    genDef(Pr, KPROCESS, ThreadQuantum)
    genDef(Pr, KPROCESS, AutoAlignment)
    genDef(Pr, KPROCESS, State)
    genVal(ProcessObjectLength, ((sizeof(KPROCESS) + 15) & ~15))
    genVal(ExtendedProcessObjectLength, ((sizeof(EPROCESS) + 15) & ~15))

    //
    // Profile object structure offset definitions.
    //

    genCom("Profile Object Structure Offset Definitions")

    genDef(Pf, KPROFILE, Type)
    genDef(Pf, KPROFILE, Size)
    genDef(Pf, KPROFILE, ProfileListEntry)
    genDef(Pf, KPROFILE, Process)
    genDef(Pf, KPROFILE, RangeBase)
    genDef(Pf, KPROFILE, RangeLimit)
    genDef(Pf, KPROFILE, BucketShift)
    genDef(Pf, KPROFILE, Buffer)
    genDef(Pf, KPROFILE, Segment)
    genDef(Pf, KPROFILE, Affinity)
    genDef(Pf, KPROFILE, Source)
    genDef(Pf, KPROFILE, Started)
    genVal(ProfileObjectLength, sizeof(KPROFILE))

    //
    // Queue object structure offset definitions.
    //

    genCom("Queue Object Structure Offset Definitions")

    genDef(Qu, DISPATCHER_HEADER, Type)
    genDef(Qu, DISPATCHER_HEADER, Size)
    genDef(Qu, DISPATCHER_HEADER, SignalState)
    genDef(Qu, KQUEUE, EntryListHead)
    genDef(Qu, KQUEUE, CurrentCount)
    genDef(Qu, KQUEUE, MaximumCount)
    genDef(Qu, KQUEUE, ThreadListHead)
    genVal(QueueObjectLength, sizeof(KQUEUE))

    //
    // Thread object structure offset definitions
    //

    genCom("Thread Object Structure Offset Definitions")

    genDef(Ee, EEVENT_PAIR, KernelEventPair)
    genDef(Et, ETHREAD, Cid)

#if defined (PERF_DATA)

    genDef(Et, ETHREAD, PerformanceCountLow)
    genDef(Et, ETHREAD, PerformanceCountHigh)

#endif

    genVal(EtEthreadLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

    genDef(Th, DISPATCHER_HEADER, Type)
    genDef(Th, DISPATCHER_HEADER, Size)
    genDef(Th, DISPATCHER_HEADER, SignalState)
    genDef(Th, KTHREAD, MutantListHead)
    genDef(Th, KTHREAD, InitialStack)
    genDef(Th, KTHREAD, StackLimit)
    genDef(Th, KTHREAD, Teb)
    genDef(Th, KTHREAD, TlsArray)
    genDef(Th, KTHREAD, KernelStack)
    genDef(Th, KTHREAD, DebugActive)
    genDef(Th, KTHREAD, State)
    genDef(Th, KTHREAD, Alerted)
    genDef(Th, KTHREAD, Iopl)
    genDef(Th, KTHREAD, NpxState)
    genDef(Th, KTHREAD, Saturation)
    genDef(Th, KTHREAD, Priority)
    genDef(Th, KTHREAD, ApcState)
    genDef(Th, KTHREAD, IdleSwapBlock)
    genDef(Th, KTHREAD, ContextSwitches)
    genDef(Th, KTHREAD, WaitStatus)
    genDef(Th, KTHREAD, WaitIrql)
    genDef(Th, KTHREAD, WaitMode)
    genDef(Th, KTHREAD, WaitNext)
    genDef(Th, KTHREAD, WaitReason)
    genDef(Th, KTHREAD, WaitBlockList)
    genDef(Th, KTHREAD, WaitListEntry)
    genDef(Th, KTHREAD, WaitTime)
    genDef(Th, KTHREAD, BasePriority)
    genDef(Th, KTHREAD, DecrementCount)
    genDef(Th, KTHREAD, PriorityDecrement)
    genDef(Th, KTHREAD, Quantum)
    genDef(Th, KTHREAD, WaitBlock)
    genDef(Th, KTHREAD, KernelApcDisable)
    genDef(Th, KTHREAD, UserAffinity)
    genDef(Th, KTHREAD, SystemAffinityActive)
    genDef(Th, KTHREAD, ServiceTable)
//    genDef(Th, KTHREAD, Channel)
//    genDef(Th, KTHREAD, Section)
//    genDef(Th, KTHREAD, SystemView)
//    genDef(Th, KTHREAD, ThreadView)
    genDef(Th, KTHREAD, Queue)
    genDef(Th, KTHREAD, ApcQueueLock)
    genDef(Th, KTHREAD, Timer)
    genDef(Th, KTHREAD, QueueListEntry)
    genDef(Th, KTHREAD, Affinity)
    genDef(Th, KTHREAD, Preempted)
    genDef(Th, KTHREAD, ProcessReadyQueue)
    genDef(Th, KTHREAD, KernelStackResident)
    genDef(Th, KTHREAD, NextProcessor)
    genDef(Th, KTHREAD, CallbackStack)
    genDef(Th, KTHREAD, Win32Thread)
    genDef(Th, KTHREAD, TrapFrame)
    genDef(Th, KTHREAD, ApcStatePointer)
    genDef(Th, KTHREAD, PreviousMode)
    genDef(Th, KTHREAD, EnableStackSwap)
    genDef(Th, KTHREAD, LargeStack)
    genDef(Th, KTHREAD, KernelTime)
    genDef(Th, KTHREAD, UserTime)
    genDef(Th, KTHREAD, SavedApcState)
    genDef(Th, KTHREAD, Alertable)
    genDef(Th, KTHREAD, ApcStateIndex)
    genDef(Th, KTHREAD, ApcQueueable)
    genDef(Th, KTHREAD, AutoAlignment)
    genDef(Th, KTHREAD, StackBase)
    genDef(Th, KTHREAD, SuspendApc)
    genDef(Th, KTHREAD, SuspendSemaphore)
    genDef(Th, KTHREAD, ThreadListEntry)
    genDef(Th, KTHREAD, FreezeCount)
    genDef(Th, KTHREAD, SuspendCount)
    genDef(Th, KTHREAD, IdealProcessor)
    genDef(Th, KTHREAD, DisableBoost)
    genDef(Th, KTHREAD, SoftAffinity)

#if defined(_IA64_)

    genDef(Th, KTHREAD, InitialBStore)
    genDef(Th, KTHREAD, BStoreLimit)
    genDef(Th, KTHREAD, Number)
    genDef(Th, KTHREAD, KernelBStore)
    genDef(Th, KTHREAD, CallbackBStore)

#endif // defined(_IA64_)

    genVal(ThreadObjectLength, ((sizeof(KTHREAD) + 15) & ~15))
    genVal(ExtendedThreadObjectLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

    genVal(EVENT_WAIT_BLOCK_OFFSET, OFFSET(KTHREAD, WaitBlock) + (sizeof(KWAIT_BLOCK) * EVENT_WAIT_BLOCK))

#if defined(_X86_)

    genVal(NPX_STATE_NOT_LOADED, NPX_STATE_NOT_LOADED)
    genVal(NPX_STATE_LOADED, NPX_STATE_LOADED)

#endif

    //
    // Timer object structure offset definitions
    //

    genCom("Timer object Structure Offset Definitions")

    genDef(Ti, DISPATCHER_HEADER, Type)
    genDef(Ti, DISPATCHER_HEADER, Size)
    genDef(Ti, DISPATCHER_HEADER, Inserted)
    genDef(Ti, DISPATCHER_HEADER, SignalState)
    genDef(Ti, KTIMER, DueTime)
    genDef(Ti, KTIMER, TimerListEntry)
    genDef(Ti, KTIMER, Dpc)
    genDef(Ti, KTIMER, Period)
    genVal(TimerObjectLength, sizeof(KTIMER))

    genSpc()

    genVal(TIMER_TABLE_SIZE, TIMER_TABLE_SIZE)

    //
    // Wait block structure offset definitions
    //

    genCom("Wait Block Structure Offset Definitions")

    genDef(Wb, KWAIT_BLOCK, WaitListEntry)
    genDef(Wb, KWAIT_BLOCK, Thread)
    genDef(Wb, KWAIT_BLOCK, Object)
    genDef(Wb, KWAIT_BLOCK, NextWaitBlock)
    genDef(Wb, KWAIT_BLOCK, WaitKey)
    genDef(Wb, KWAIT_BLOCK, WaitType)

    //
    // Fiber structure offset definitions.
    //

    genCom("Fiber Structure Offset Definitions")

    genDef(Fb, FIBER, FiberData)
    genDef(Fb, FIBER, ExceptionList)
    genDef(Fb, FIBER, StackBase)
    genDef(Fb, FIBER, StackLimit)
    genDef(Fb, FIBER, DeallocationStack)
    genDef(Fb, FIBER, FiberContext)
    genDef(Fb, FIBER, Wx86Tib)

#if defined(_IA64_)

    genDef(Fb, FIBER, DeallocationBStore)
    genDef(Fb, FIBER, BStoreLimit)

#endif // defined(_IA64_)

    //
    // Process environment block structure offset definitions.
    //

    genCom("Process Environment Block Structure Offset Definitions")

    genDef(Pe, PEB, KernelCallbackTable)

    //
    // Define System Service Descriptor Table structures.
    //

    genCom("System Service Descriptor Table Structure Definitions")

    genVal(NUMBER_SERVICE_TABLES, NUMBER_SERVICE_TABLES)
    genVal(SERVICE_NUMBER_MASK, SERVICE_NUMBER_MASK)
    genVal(SERVICE_TABLE_SHIFT, SERVICE_TABLE_SHIFT)
    genVal(SERVICE_TABLE_MASK, SERVICE_TABLE_MASK)
    genVal(SERVICE_TABLE_TEST, SERVICE_TABLE_TEST)

    genSpc()

    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Base)
    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Count)
    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Limit)

#if defined(_IA64_)

    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, TableBaseGpOffset)

#endif

    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Number)

    //
    // Common TEB structure offset definitions
    //

    genCom("Thread Environment Block Structure Offset Definitions")

#if defined(_WIN64)

    genAlt(TeCmTeb, NT_TIB, ExceptionList)

#endif

    genDef(Te, NT_TIB, StackBase)
    genDef(Te, NT_TIB, StackLimit)
    genDef(Te, NT_TIB, FiberData)
    genDef(Te, NT_TIB, Self)
    genDef(Te, TEB, EnvironmentPointer)
    genDef(Te, TEB, ClientId)
    genDef(Te, TEB, ActiveRpcHandle)
    genDef(Te, TEB, ThreadLocalStoragePointer)
    genDef(Te, TEB, CountOfOwnedCriticalSections)
    genAlt(TePeb, TEB, ProcessEnvironmentBlock)
    genDef(Te, TEB, CsrClientThread)
    genDef(Te, TEB, WOW32Reserved)
    genAlt(TeSoftFpcr, TEB, FpSoftwareStatusRegister)
    genDef(Te, TEB, ExceptionCode)
    genDef(Te, TEB, GdiClientPID)
    genDef(Te, TEB, GdiClientTID)
    genDef(Te, TEB, GdiThreadLocalInfo)
    genDef(Te, TEB, glDispatchTable)
    genDef(Te, TEB, glReserved1)
    genDef(Te, TEB, glReserved2)
    genDef(Te, TEB, glSectionInfo)
    genDef(Te, TEB, glSection)
    genDef(Te, TEB, glTable)
    genDef(Te, TEB, glCurrentRC)
    genDef(Te, TEB, glContext)
    genDef(Te, TEB, DeallocationStack)
    genDef(Te, TEB, TlsSlots)
    genDef(Te, TEB, Vdm)
    genDef(Te, TEB, GdiBatchCount)
    genDef(Te, TEB, Instrumentation)

#if defined(_IA64_)

    genDef(Te, NT_TIB, ExceptionList)
    genDef(Te, TEB, DeallocationBStore)
    genDef(Te, TEB, BStoreLimit)
    genDef(Te, TEB, DbgSsReserved)

#endif // defined(_IA64_)

    genVal(ThreadEnvironmentBlockLength, sizeof(TEB))

    genVal(CmThreadEnvironmentBlockOffset, ROUND_TO_PAGES(sizeof(TEB)))

    //
    // Lock Queue structure definitions.
    //

#if defined(_X86_)

    EnableInc(HAL)

#endif

    genCom("Lock Queue Structure Offset Definitions")

    genNam(LOCK_QUEUE_WAIT)
    genNam(LOCK_QUEUE_OWNER)
    genVal(LOCK_QUEUE_HEADER_SIZE, sizeof(KSPIN_LOCK_QUEUE))
    genSpc()

    genNam(LockQueueDispatcherLock)
    genNam(LockQueueContextSwapLock)
    genSpc()

    genDef(Lq, KSPIN_LOCK_QUEUE, Next)
    genDef(Lq, KSPIN_LOCK_QUEUE, Lock)
    genSpc()

    genAlt(LqhNext, KLOCK_QUEUE_HANDLE, LockQueue.Next)
    genAlt(LqhLock, KLOCK_QUEUE_HANDLE, LockQueue.Lock)
    genAlt(LqhOldIrql, KLOCK_QUEUE_HANDLE, OldIrql)

#if defined(_X86_)

    DisableInc(HAL)

#endif

    genCom("Performance Definitions")

    genVal(PERF_CONTEXTSWAP_OFFSET,
        PERF_GET_MASK_INDEX( PERF_CONTEXT_SWITCH ) * sizeof( ULONG ) )
    genVal(PERF_CONTEXTSWAP_FLAG,
        PERF_GET_MASK_GROUP( PERF_CONTEXT_SWITCH ))
    genVal(PERF_DPC_OFFSET,
        PERF_GET_MASK_INDEX( PERF_DPC ) * sizeof( ULONG ) )
    genVal(PERF_DPC_FLAG,
        PERF_GET_MASK_GROUP( PERF_DPC ))
    genVal(PERF_INTERRUPT_OFFSET,
        PERF_GET_MASK_INDEX( PERF_INTERRUPT ) * sizeof( ULONG ) )
    genVal(PERF_INTERRUPT_FLAG,
        PERF_GET_MASK_GROUP( PERF_INTERRUPT ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\profobj.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    profobj.c

Abstract:

    This module implements the kernel Profile Object. Functions are
    provided to initialize, start, and stop profile objects and to set
    and query the profile interval.

Author:

    Bryan M. Willman (bryanwi) 19-Sep-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text (PAGE, KeQueryIntervalProfile)

//
// The following assert macro is used to check that an input profile object is
// really a kprofile and not something else, like deallocated pool.
//

#define ASSERT_PROFILE(E) {             \
    ASSERT((E)->Type == ProfileObject); \
}

//
// Structure representing an active profile source
//
typedef struct _KACTIVE_PROFILE_SOURCE {
    LIST_ENTRY ListEntry;
    KPROFILE_SOURCE Source;
    KAFFINITY Affinity;
    ULONG ProcessorCount[1];            // variable-sized, one per processor
} KACTIVE_PROFILE_SOURCE, *PKACTIVE_PROFILE_SOURCE;

//
// Prototypes for IPI target functions
//
VOID
KiStartProfileInterrupt (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiStopProfileInterrupt (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );


VOID
KeInitializeProfile (
    IN PKPROFILE Profile,
    IN PKPROCESS Process OPTIONAL,
    IN PVOID RangeBase,
    IN SIZE_T RangeSize,
    IN ULONG BucketSize,
    IN ULONG Segment,
    IN KPROFILE_SOURCE ProfileSource,
    IN KAFFINITY ProfileAffinity
    )

/*++

Routine Description:

    This function initializes a kernel profile object. The process,
    address range, bucket size, and buffer are set. The profile is
    set to the stopped state.

Arguments:

    Profile - Supplies a pointer to control object of type profile.

    Process - Supplies an optional pointer to a process object that
        describes the address space to profile. If not specified,
        then all address spaces are included in the profile.

    RangeBase - Supplies the address of the first byte of the address
        range for which profiling information is to be collected.

    RangeSize - Supplies the size of the address range for which profiling
        information is to be collected.  The RangeBase and RangeSize
        parameters are interpreted such that RangeBase <= address <
        RangeBase + RangeSize generates a profile hit.

    BucketSize - Supplies the log base 2 of the size of a profiling bucket.
        Thus, BucketSize = 2 yields 4-byte buckets, BucketSize = 7 yields
        128-byte buckets.

    Segment - Supplies the non-Flat code segment to profile.  If this
        is zero, then the flat profiling is done.  This will only
        be non-zero on an x86 machine.

    ProfileSource - Supplies the profile interrupt source.

    ProfileAffinity - Supplies the set of processor to count hits for.

Return Value:

    None.

--*/

{

#if !defined(i386)

    ASSERT(Segment == 0);

#endif

    //
    // Initialize the standard control object header.
    //

    Profile->Type = ProfileObject;
    Profile->Size = sizeof(KPROFILE);

    //
    // Initialize the process address space, range base, range limit,
    // bucket shift count, and set started FALSE.
    //

    if (ARGUMENT_PRESENT(Process)) {
        Profile->Process = Process;

    } else {
        Profile->Process = NULL;
    }

    Profile->RangeBase = RangeBase;
    Profile->RangeLimit = (PUCHAR)RangeBase + RangeSize;
    Profile->BucketShift = BucketSize - 2;
    Profile->Started = FALSE;
    Profile->Segment = Segment;
    Profile->Source = (CSHORT)ProfileSource;
    Profile->Affinity = ProfileAffinity & KeActiveProcessors;
    if (Profile->Affinity == 0) {
        Profile->Affinity = KeActiveProcessors;
    }
    return;
}

ULONG
KeQueryIntervalProfile (
    IN KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This function returns the profile sample interval the system is
    currently using.

Arguments:

    ProfileSource - Supplies the profile source to be queried.

Return Value:

    Sample interval in units of 100ns.

--*/

{

    HAL_PROFILE_SOURCE_INFORMATION ProfileSourceInfo;
    ULONG ReturnedLength;
    NTSTATUS Status;

#if !defined(_IA64_)
    if (ProfileSource == ProfileTime) {

        //
        // Return the current sampling interval in 100ns units.
        //

        return KiProfileInterval;

    } 
    else 
#endif // !_IA64_
    if (ProfileSource == ProfileAlignmentFixup) {
        return KiProfileAlignmentFixupInterval;
    } else {

        //
        // The HAL is responsible for tracking this profile interval.
        //

        ProfileSourceInfo.Source = ProfileSource;
        Status = HalQuerySystemInformation(HalProfileSourceInformation,
                                           sizeof(HAL_PROFILE_SOURCE_INFORMATION),
                                           &ProfileSourceInfo,
                                           &ReturnedLength);

        if (NT_SUCCESS(Status) && ProfileSourceInfo.Supported) {
            return ProfileSourceInfo.Interval;

        } else {
            return 0;
        }
    }
}

VOID
KeSetIntervalProfile (
    IN ULONG Interval,
    IN KPROFILE_SOURCE Source
    )

/*++

Routine Description:

    This function sets the profile sampling interval. The interval is in
    100ns units. The interval will actually be set to some value in a set
    of preset values (at least on pc based hardware), using the one closest
    to what the user asked for.

Arguments:

    Interval - Supplies the length of the sampling interval in 100ns units.

Return Value:

    None.

--*/

{

    HAL_PROFILE_SOURCE_INTERVAL ProfileSourceInterval;

#if !defined(_IA64_)
    if (Source == ProfileTime) {

        //
        // If the specified sampling interval is less than the minimum
        // sampling interval, then set the sampling interval to the minimum
        // sampling interval.
        //

        if (Interval < MINIMUM_PROFILE_INTERVAL) {
            Interval = MINIMUM_PROFILE_INTERVAL;
        }

        //
        // Set the sampling interval.
        //

        KiProfileInterval = (ULONG)KiIpiGenericCall(HalSetProfileInterval, Interval);

    } 
    else 
#endif // !_IA64_
    if (Source == ProfileAlignmentFixup) {
        KiProfileAlignmentFixupInterval = Interval;
    } else {

        //
        // The HAL is responsible for setting this profile interval.
        //

        ProfileSourceInterval.Source = Source;
        ProfileSourceInterval.Interval = Interval;
        HalSetSystemInformation(HalProfileSourceInterval,
                                sizeof(HAL_PROFILE_SOURCE_INTERVAL),
                                &ProfileSourceInterval);
    }

    return;
}

BOOLEAN
KeStartProfile (
    IN PKPROFILE Profile,
    IN PULONG Buffer
    )

/*++

Routine Description:

    This function starts profile data gathering on the specified profile
    object. The profile object is marked started, and is registered with
    the profile interrupt procedure.

    If the number of active profile objects was previously zero, then the
    profile interrupt is enabled.

    N.B. For the current implementation, an arbitrary number of profile
        objects may be active at once. This can present a large system
        overhead. It is assumed that the caller appropriately limits the
        the number of active profiles.

Arguments:

    Profile - Supplies a pointer to a control object of type profile.

    Buffer - Supplies a pointer to an array of counters, which record
        the number of hits in the corresponding bucket.

Return Value:

    A value of TRUE is returned if profiling was previously stopped for
    the specified profile object. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql, OldIrql2;
    PKPROCESS Process;
    BOOLEAN Started;
    KAFFINITY TargetProcessors;
    PKPRCB Prcb;
    PKACTIVE_PROFILE_SOURCE ActiveSource = NULL;
    PKACTIVE_PROFILE_SOURCE CurrentActiveSource;
    PKACTIVE_PROFILE_SOURCE AllocatedPool;
    PLIST_ENTRY ListEntry;
    ULONG SourceSize;
    KAFFINITY AffinitySet;
    PULONG Reference;

    ASSERT_PROFILE(Profile);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Allocate pool that may be required before raising to PROFILE_LEVEL.
    //

    SourceSize = sizeof(KACTIVE_PROFILE_SOURCE) + sizeof(ULONG) *
                 (KeNumberProcessors - 1);
    AllocatedPool = ExAllocatePoolWithTag(NonPagedPool, SourceSize, 'forP');
    if (AllocatedPool == NULL) {
        return(TRUE);
    }

    //
    // Raise to dispatch level
    //

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    Prcb = KeGetCurrentPrcb();

    //
    // Raise IRQL to PROFILE_LEVEL and acquire the profile lock.
    //

    KeRaiseIrql(KiProfileIrql, &OldIrql2);
    KiAcquireSpinLock(&KiProfileLock);

    //
    // Assume object already started
    //

    Started = FALSE;
    AffinitySet = 0L;
    TargetProcessors = 0L;

    //
    // If the specified profile object is not started, set started to TRUE,
    // set the address of the profile buffer, set the profile object to started,
    // insert the profile object in the appropriate profile list, and start
    // profile interrupts if the number of active profile objects was previously zero.
    //

    if (Profile->Started == FALSE) {

        Started = TRUE;
        Profile->Buffer = Buffer;
        Profile->Started = TRUE;
        Process = Profile->Process;

        if (Profile->Buffer) {
            
            if (Process != NULL) {
                InsertTailList(&Process->ProfileListHead, &Profile->ProfileListEntry);

            } else {
                InsertTailList(&KiProfileListHead, &Profile->ProfileListEntry);
            }
        } else {

            //
            //  If we don't have a buffer passed, we'll use only the
            //  event profiling
            //

            InitializeListHead(&Profile->ProfileListEntry);
        }

        //
        // Check the profile source list to see if this profile source is
        // already started. If so, update the reference counts. If not,
        // allocate a profile source object, initialize the reference
        // counts, and add it to the list.
        //

        ListEntry = KiProfileSourceListHead.Flink;
        while (ListEntry != &KiProfileSourceListHead) {
            CurrentActiveSource = CONTAINING_RECORD(ListEntry,
                                                    KACTIVE_PROFILE_SOURCE,
                                                    ListEntry);

            if (CurrentActiveSource->Source == Profile->Source) {
                ActiveSource = CurrentActiveSource;
                break;
            }
            ListEntry = ListEntry->Flink;
        }

        if (ActiveSource == NULL) {

            //
            // This source was not found, allocate and initialize a new entry and add
            // it to the head of the list.
            //

            ActiveSource = AllocatedPool;
            AllocatedPool = NULL;
            RtlZeroMemory(ActiveSource, SourceSize);
            ActiveSource->Source = Profile->Source;
            InsertHeadList(&KiProfileSourceListHead, &ActiveSource->ListEntry);
            if (Profile->Source == ProfileAlignmentFixup) {
                KiProfileAlignmentFixup = TRUE;
            }
        }

        //
        // Increment the reference counts for each processor in the
        // affinity set.
        //

        AffinitySet = Profile->Affinity;
        Reference = &ActiveSource->ProcessorCount[0];
        while (AffinitySet != 0) {
            if (AffinitySet & 1) {
                *Reference = *Reference + 1;
            }

            AffinitySet = AffinitySet >> 1;
            Reference = Reference + 1;
        }

        //
        // Compute the processors which the profile interrupt is
        // required and not already started
        //

        AffinitySet = Profile->Affinity & ~ActiveSource->Affinity;
        TargetProcessors = AffinitySet & ~Prcb->SetMember;

        //
        // Update set of processors on which this source is active.
        //

        ActiveSource->Affinity |= Profile->Affinity;
    }

    //
    // Release the profile lock, lower IRQL to its previous value, and
    // return whether profiling was started.
    //

    KiReleaseSpinLock(&KiProfileLock);
    KeLowerIrql(OldIrql2);

    //
    // Start profile interrupt on pending processors
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiStartProfileInterrupt,
                        (PVOID)Profile->Source,
                        NULL,
                        NULL);
    }

#endif

    if (AffinitySet & Prcb->SetMember) {
        if (Profile->Source == ProfileAlignmentFixup) {
            KiEnableAlignmentExceptions();
        }
        HalStartProfileInterrupt(Profile->Source);
    }

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Lower to original IRQL
    //

    KeLowerIrql(OldIrql);

    //
    // If the allocated pool was not used, free it now.
    //

    if (AllocatedPool != NULL) {
        ExFreePool(AllocatedPool);
    }

    return Started;
}

BOOLEAN
KeStopProfile (
    IN PKPROFILE Profile
    )

/*++

Routine Description:

    This function stops profile data gathering on the specified profile
    object. The object is marked stopped, and is removed from the active
    profile list.

    If the number of active profile objects goes to zero, then the profile
    interrupt is disabled.

Arguments:

    Profile - Supplies a pointer to a control object of type profile.

Return Value:

    A value of TRUE is returned if profiling was previously started for
    the specified profile object. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql, OldIrql2;
    BOOLEAN Stopped;
    KAFFINITY TargetProcessors;
    PKPRCB Prcb;
    BOOLEAN StopInterrupt = TRUE;
    PLIST_ENTRY ListEntry;
    PKACTIVE_PROFILE_SOURCE ActiveSource;
    PKACTIVE_PROFILE_SOURCE PoolToFree=NULL;
    KAFFINITY AffinitySet = 0;
    KAFFINITY CurrentProcessor;
    PULONG Reference;

    ASSERT_PROFILE(Profile);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise to disaptch level
    //

    KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);
    Prcb = KeGetCurrentPrcb();

    //
    // Raise IRQL to PROFILE_LEVEL and acquire the profile lock.
    //

    KeRaiseIrql(KiProfileIrql, &OldIrql2);
    KiAcquireSpinLock(&KiProfileLock);

    //
    // Assume object already stopped
    //

    Stopped = FALSE;
    AffinitySet = 0L;
    TargetProcessors = 0L;

    //
    // If the specified profile object is not stopped, set stopped to TRUE, set
    // the profile object to stopped, remove the profile object object from the
    // appropriate profilelist, and stop profile interrupts if the number of
    // active profile objects is zero.
    //

    if (Profile->Started != FALSE) {

        Stopped = TRUE;
        Profile->Started = FALSE;
        
        if (!IsListEmpty(&Profile->ProfileListEntry)) {

            RemoveEntryList(&Profile->ProfileListEntry);
        }

        //
        // Search the profile source list to find the entry for this
        // profile source.
        //

        ListEntry = KiProfileSourceListHead.Flink;
        do {
            ASSERT(ListEntry != &KiProfileSourceListHead);
            ActiveSource = CONTAINING_RECORD(ListEntry,
                                             KACTIVE_PROFILE_SOURCE,
                                             ListEntry);
            ListEntry = ListEntry->Flink;
        } while ( ActiveSource->Source != Profile->Source );

        //
        // Decrement the reference counts for each processor in the
        // affinity set and build up a mask of the processors that
        // now have a reference count of zero.
        //

        CurrentProcessor = 1;
        TargetProcessors = 0;
        AffinitySet = Profile->Affinity;
        Reference = &ActiveSource->ProcessorCount[0];
        while (AffinitySet != 0) {
            if (AffinitySet & 1) {
                *Reference = *Reference - 1;
                if (*Reference == 0) {
                    TargetProcessors = TargetProcessors | CurrentProcessor;
                }
            }

            AffinitySet = AffinitySet >> 1;
            Reference = Reference + 1;
            CurrentProcessor = CurrentProcessor << 1;
        }

        //
        // Compute the processors whose profile interrupt reference
        // count has dropped to zero.
        //

        AffinitySet = TargetProcessors;
        TargetProcessors = AffinitySet & ~Prcb->SetMember;

        //
        // Update set of processors on which this source is active.
        //

        ActiveSource->Affinity &= ~AffinitySet;

        //
        // Determine whether this profile source is stopped on all
        // processors. If so, remove it from the list and free it.
        //

        if (ActiveSource->Affinity == 0) {
            RemoveEntryList(&ActiveSource->ListEntry);
            PoolToFree = ActiveSource;
            if (Profile->Source == ProfileAlignmentFixup) {
                KiProfileAlignmentFixup = FALSE;
            }
        }
    }

    //
    // Release the profile lock, lower IRQL to its previous value, and
    // return whether profiling was stopped.
    //

    KiReleaseSpinLock(&KiProfileLock);
    KeLowerIrql(OldIrql2);

    //
    // Stop profile interrupt on pending processors
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiStopProfileInterrupt,
                        (PVOID)Profile->Source,
                        NULL,
                        NULL);
    }

#endif

    if (AffinitySet & Prcb->SetMember) {
        if (Profile->Source == ProfileAlignmentFixup) {
            KiDisableAlignmentExceptions();
        }
        HalStopProfileInterrupt(Profile->Source);
    }

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Lower to original IRQL
    //

    KeLowerIrql (OldIrql);

    //
    // Now that IRQL has been lowered, free the profile source if
    // necessary.
    //

    if (PoolToFree != NULL) {
        ExFreePool(PoolToFree);
    }

    return Stopped;
}

#if !defined(NT_UP)


VOID
KiStopProfileInterrupt (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for stopping the profile interrupt on target
    processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Supplies the profile source

    Parameter2 - Parameter3 - not used

Return Value:

    None.

--*/

{

    KPROFILE_SOURCE ProfileSource;

    //
    // Stop the profile interrupt on the current processor and clear the
    // data cache packet address to signal the source to continue.
    //

    ProfileSource = (KPROFILE_SOURCE) PtrToUlong(Parameter1);
    if (ProfileSource == ProfileAlignmentFixup) {
        KiDisableAlignmentExceptions();
    }
    HalStopProfileInterrupt(ProfileSource);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

VOID
KiStartProfileInterrupt (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for stopping the profile interrupt on target
    processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Supplies the profile source

    Parameter2 - Parameter3 - not used

Return Value:

    None.

--*/

{

    KPROFILE_SOURCE ProfileSource;

    //
    // Start the profile interrupt on the current processor and clear the
    // data cache packet address to signal the source to continue.
    //

    ProfileSource = (KPROFILE_SOURCE)PtrToUlong(Parameter1);
    if (ProfileSource == ProfileAlignmentFixup) {
        KiEnableAlignmentExceptions();
    }
    HalStartProfileInterrupt(ProfileSource);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\procobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    procobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel process object. Functions are provided to initialize, attach,
    detach, exclude, include, and set the base priority of process objects.

Author:

    David N. Cutler (davec) 7-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeInitializeProcess)

//
// Define forward referenced function prototypes.
//

VOID
KiAttachProcess (
    IN PRKTHREAD Thread,
    IN PRKPROCESS Process,
    IN KIRQL OldIrql,
    OUT PRKAPC_STATE SavedApcState
    );

VOID
KiMoveApcState (
    IN PKAPC_STATE Source,
    OUT PKAPC_STATE Destination
    );

//
// The following assert macro is used to check that an input process is
// really a kprocess and not something else, like deallocated pool.
//

#define ASSERT_PROCESS(E) {             \
    ASSERT((E)->Header.Type == ProcessObject); \
}

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY BasePriority,
    IN KAFFINITY Affinity,
    IN ULONG_PTR DirectoryTableBase[2],
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function initializes a kernel process object. The base priority,
    affinity, and page frame numbers for the process page table directory
    and hyper space are stored in the process object.

    N.B. It is assumed that the process object is zeroed.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    BasePriority - Supplies the base priority of the process.

    Affinity - Supplies the set of processors on which children threads
        of the process can execute.

    DirectoryTableBase - Supplies a pointer to an array whose fist element
        is the value that is to be loaded into the Directory Table Base
        register when a child thread is dispatched for execution and whose
        second element contains the page table entry that maps hyper space.

    Enable - Supplies a boolean value that determines the default
        handling of data alignment exceptions for child threads. A value
        of TRUE causes all data alignment exceptions to be automatically
        handled by the kernel. A value of FALSE causes all data alignment
        exceptions to be actually raised as exceptions.

Return Value:

    None.

--*/

{

    PKNODE Node;
    UCHAR NodeNumber;
    ULONG i;

    //
    // Initialize the standard dispatcher object header and set the initial
    // signal state of the process object.
    //

    Process->Header.Type = ProcessObject;
    Process->Header.Size = sizeof(KPROCESS) / sizeof(LONG);
    InitializeListHead(&Process->Header.WaitListHead);

    //
    // Initialize the base priority, affinity, directory table base values,
    // autoalignment, and stack count.
    //
    // N.B. The distinguished value MAXSHORT is used to signify that no
    //      threads have been created for the process.
    //

    Process->BasePriority = (SCHAR)BasePriority;
    Process->Affinity = Affinity;
    Process->AutoAlignment = Enable;
    Process->DirectoryTableBase[0] = DirectoryTableBase[0];
    Process->DirectoryTableBase[1] = DirectoryTableBase[1];
    Process->StackCount = MAXSHORT;

    //
    // Initialize the stack count, profile listhead, ready queue list head,
    // accumulated runtime, process quantum, thread quantum, and thread list
    // head.
    //

    InitializeListHead(&Process->ProfileListHead);
    InitializeListHead(&Process->ReadyListHead);
    InitializeListHead(&Process->ThreadListHead);
    Process->ThreadQuantum = THREAD_QUANTUM;

    //
    // Initialize the process state and set the thread processor selection
    // seed.
    //

    Process->State = ProcessInMemory;

    //
    // Set the ideal node for this process.
    //

#if defined(KE_MULTINODE)

    if (KeNumberNodes > 1) {
        NodeNumber = (KeProcessNodeSeed + 1) % KeNumberNodes;
        KeProcessNodeSeed = NodeNumber;
        for (i = 0; i < KeNumberNodes; i++) {
            if (KeNodeBlock[NodeNumber]->ProcessorMask & Affinity) {
                break;
            }

            NodeNumber = (NodeNumber + 1) % KeNumberNodes;
        }

    } else {
        NodeNumber = 0;
    }

    Process->IdealNode = NodeNumber;
    Node = KeNodeBlock[NodeNumber];
    Process->ThreadSeed = KeFindNextRightSetAffinity(Node->Seed,
                                                     Node->ProcessorMask & Affinity);

    Node->Seed = Process->ThreadSeed;

#else

    Process->ThreadSeed = (UCHAR)KiQueryLowTickCount() % KeNumberProcessors;

#endif

    //
    // Initialize IopmBase and Iopl flag for this process (i386 only)
    //

#if defined(_X86_) || defined(_AMD64_)

    Process->IopmOffset = KiComputeIopmOffset(IO_ACCESS_MAP_NONE);

#endif // defined(_X86_) || defined(_AMD64_)

    return;
}

VOID
KeAttachProcess (
    IN PRKPROCESS Process
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space
    if, and only if, there is not already a process attached.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the target process is not the current process, then attach the
    // target process.
    //

    Thread = KeGetCurrentThread();
    if (Thread->ApcState.Process != Process) {

        //
        // If the current thread is already attached or executing a DPC, then
        // bugcheck.
        //
    
        if ((Thread->ApcStateIndex != 0) ||
            (KeIsExecutingDpc() != FALSE)) {
    
            KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                         (ULONG_PTR)Process,
                         (ULONG_PTR)Thread->ApcState.Process,
                         (ULONG)Thread->ApcStateIndex,
                         (ULONG)KeIsExecutingDpc());
        }
    
        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //
        // N.B. The dispatcher lock is released ay the attach routine.
        //

        KiLockDispatcherDatabase(&OldIrql);
        KiAttachProcess(Thread, Process, OldIrql, &Thread->SavedApcState);
    }

    return;
}

LOGICAL
KeForceAttachProcess (
    IN PRKPROCESS Process
    )

/*++

Routine Description:

    This function forces an attach of a thread to a target process' address
    space if the process is not current being swapped into or out of memory.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is already attached or executing a DPC, then
    // bugcheck.
    //

    Thread = KeGetCurrentThread();
    if ((Thread->ApcStateIndex != 0) ||
        (KeIsExecutingDpc() != FALSE)) {

        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    //
    // If the target process is not the current process, then attach the
    // target process if the process is not currently being swapped in or
    // out of memory.
    //

    if (Thread->ApcState.Process != Process) {

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //
        // If the target process is currently being swapped into or out of
        // memory, then return a value of FALSE. Otherwise, force the process
        // to be inswapped.
        //

        KiLockDispatcherDatabase(&OldIrql);
        if ((Process->State == ProcessInSwap) ||
            (Process->State == ProcessInTransition) ||
            (Process->State == ProcessOutTransition) ||
            (Process->State == ProcessOutSwap)) {
            KiUnlockDispatcherDatabase(OldIrql);
            return FALSE;

        } else {

            //
            // Force the process state to in memory and attach the target process.
            //
            // N.B. The dispatcher lock is released ay the attach routine.
            //

            Process->State = ProcessInMemory;
            KiAttachProcess(Thread, Process, OldIrql, &Thread->SavedApcState);
        }
    }

    return TRUE;
}

VOID
KeStackAttachProcess (
    IN PRKPROCESS Process,
    OUT PRKAPC_STATE ApcState
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space
    and returns information about a previous attached process.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is executing a DPC, then bug check.
    //

    Thread = KeGetCurrentThread();
    if (KeIsExecutingDpc() != FALSE) {
        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    //
    // If the target process is not the current process, then attach the
    // target process. Otherwise, return a distinguished process value to
    // indicate that an attach was not performed.
    //

    if (Thread->ApcState.Process == Process) {
        ApcState->Process = (PRKPROCESS)1;

    } else {

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //
        // If the current thread is attached to a process, then save the
        // current APC state in the callers APC state structure. Otherwise,
        // save the current APC state in the saved APC state structure, and
        // return a NULL process pointer.
        //
        // N.B. The dispatcher lock is released ay the attach routine.
        //

        KiLockDispatcherDatabase(&OldIrql);
        if (Thread->ApcStateIndex != 0) {
            KiAttachProcess(Thread, Process, OldIrql, ApcState);

        } else {
            KiAttachProcess(Thread, Process, OldIrql, &Thread->SavedApcState);
            ApcState->Process = NULL;
        }
    }

    return;
}

VOID
KeDetachProcess (
    VOID
    )

/*++

Routine Description:

    This function detaches a thread from another process' address space.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is attached to another process, then detach
    // it.
    //

    Thread = KeGetCurrentThread();
    if (Thread->ApcStateIndex != 0) {

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KiLockDispatcherDatabase(&OldIrql);

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

#if !defined(NT_UP)

        while (Thread->ApcState.KernelApcPending && (OldIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(OldIrql);
            KiLockDispatcherDatabase(&OldIrql);
        }

#endif

        //
        // If a kernel APC is in progress, the kernel APC is nbot empty, or
        // the user APC queues is not empty, then bug check.
        //

#if DBG

        if ((Thread->ApcState.KernelApcInProgress) ||
            (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) ||
            (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE)) {

            KeBugCheck(INVALID_PROCESS_DETACH_ATTEMPT);
        }

#endif

        //
        // Unbias current process stack count and check if the process should
        // be swapped out of memory.
        //

        Process = Thread->ApcState.Process;
        Process->StackCount -= 1;
        if ((Process->StackCount == 0) &&
            (IsListEmpty(&Process->ThreadListHead) == FALSE)) {

            Process->State = ProcessOutTransition;
            InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                           &Process->SwapListEntry);

            KiSetSwapEvent();
        }

        //
        // Restore APC state and check whether the kernel APC queue contains
        // an entry. If the kernel APC queue contains an entry then set kernel
        // APC pending and request a software interrupt at APC_LEVEL.
        //

        KiMoveApcState(&Thread->SavedApcState, &Thread->ApcState);
        Thread->SavedApcState.Process = (PKPROCESS)NULL;
        Thread->ApcStatePointer[0] = &Thread->ApcState;
        Thread->ApcStatePointer[1] = &Thread->SavedApcState;
        Thread->ApcStateIndex = 0;
        if (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
            Thread->ApcState.KernelApcPending = TRUE;
            KiRequestSoftwareInterrupt(APC_LEVEL);
        }

        //
        // Swap the address space back to the parent process.
        //

        KiSwapProcess(Thread->ApcState.Process, Process);

        //
        // Lower IRQL to its previous value and return.
        //
    
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}

VOID
KeUnstackDetachProcess (
    IN PRKAPC_STATE ApcState
    )

/*++

Routine Description:

    This function detaches a thread from another process' address space
    and restores previous attach state.

Arguments:

    ApcState - Supplies a pointer to an APC state structure that was returned
        from a previous call to stack attach process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the APC state has a distinguished process pointer value, then no
    // attach was performed on the paired call to stack attach process.
    //

    if (ApcState->Process != (PRKPROCESS)1) {

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        Thread = KeGetCurrentThread();
        KiLockDispatcherDatabase(&OldIrql);

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

#if !defined(NT_UP)

        while (Thread->ApcState.KernelApcPending && (OldIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(OldIrql);
            KiLockDispatcherDatabase(&OldIrql);
        }

#endif

        //
        // If the APC state is the original APC state, a kernel APC is in
        // progress, the kernel APC is nbot empty, or the user APC queues is
        // not empty, then bug check.
        //

        if ((Thread->ApcStateIndex == 0) ||
             (Thread->ApcState.KernelApcInProgress) ||
             (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) ||
             (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE)) {

            KeBugCheck(INVALID_PROCESS_DETACH_ATTEMPT);
        }

        //
        // Unbias current process stack count and check if the process should
        // be swapped out of memory.
        //

        Process = Thread->ApcState.Process;
        Process->StackCount -= 1;
        if ((Process->StackCount == 0) &&
            (IsListEmpty(&Process->ThreadListHead) == FALSE)) {
            Process->State = ProcessOutTransition;
            InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                           &Process->SwapListEntry);

            KiSetSwapEvent();
        }

        //
        // Restore APC state and check whether the kernel APC queue contains
        // an entry. If the kernel APC queue contains an entry then set kernel
        // APC pending and request a software interrupt at APC_LEVEL.
        //

        if (ApcState->Process != NULL) {
            KiMoveApcState(ApcState, &Thread->ApcState);

        } else {
            KiMoveApcState(&Thread->SavedApcState, &Thread->ApcState);
            Thread->SavedApcState.Process = (PKPROCESS)NULL;
            Thread->ApcStatePointer[0] = &Thread->ApcState;
            Thread->ApcStatePointer[1] = &Thread->SavedApcState;
            Thread->ApcStateIndex = 0;
        }

        if (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
            Thread->ApcState.KernelApcPending = TRUE;
            KiRequestSoftwareInterrupt(APC_LEVEL);
        }

        //
        // Swap the address space back to the parent process.
        //

        KiSwapProcess(Thread->ApcState.Process, Process);

        //
        // Lower IRQL to its previous value and return.
        //
    
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}

LONG
KeReadStateProcess (
    IN PRKPROCESS Process
    )

/*++

Routine Description:

    This function reads the current signal state of a process object.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    The current signal state of the process object.

--*/

{

    ASSERT_PROCESS(Process);

    //
    // Return current signal state of process object.
    //

    return Process->Header.SignalState;
}

LONG
KeSetProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of a proces object to Signaled
    and attempts to satisfy as many Waits as possible. The previous
    signal state of the process object is returned as the function value.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Increment - Supplies the priority increment that is to be applied
       if setting the process causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KeSetProcess will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the process object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the previous state of the process object is Not-Signaled and
    // the wait queue is not empty, then satisfy as many Waits as
    // possible.
    //

    OldState = Process->Header.SignalState;
    Process->Header.SignalState = 1;
    if ((OldState == 0) && (!IsListEmpty(&Process->Header.WaitListHead))) {
        KiWaitTest(Process, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of process object.
    //

    return OldState;
}

KAFFINITY
KeSetAffinityProcess (
    IN PKPROCESS Process,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a process to the specified value and
    also sets the affinity of each thread in the process to the specified
    value.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Affinity - Supplies the new of set of processors on which the threads
        in the process can run.

Return Value:

    The previous affinity of the specified process is returned as the function
    value.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    KAFFINITY OldAffinity;
    PKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Capture the current affinity of the specified process and set the
    // affinity of the process and all of its threads to the specified
    // affinity.
    //

    OldAffinity = Process->Affinity;
    Process->Affinity = Affinity;
    NextEntry = Process->ThreadListHead.Flink;
    while (NextEntry != &Process->ThreadListHead) {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        KiSetAffinityThread(Thread, Affinity);
        NextEntry = NextEntry->Flink;
    }

    //
    // Unlock dispatcher database (restoring IRQL to SYNCH_LEVEL), unlock the
    // process lock, lower IRQL to its previous value, and return the previous process
    // affinity.
    //
    // N.B. The unlock of the dispatch database specifying SYNCH_LEVEL is to
    //      make sure a dispatch interrupt is generated if necessary.
    //

    KiUnlockDispatcherDatabase(SYNCH_LEVEL);
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return OldAffinity;
}

KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY NewBase
    )

/*++

Routine Description:

    This function set the base priority of a process to a new value
    and adjusts the priority and base priority of all child threads
    as appropriate.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    NewBase - Supplies the new base priority of the process.

Return Value:

    The previous base priority of the process.

--*/

{

    KPRIORITY Adjustment;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    PKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the new priority is equal to the old priority, then do not change
    // the process priority and return the old priority.
    //
    // N.B. This check can be made without holding the dispatcher lock since
    // nothing needs to be protected, and any race condition that can exist
    // calling this routine exists with or without the lock being held.
    //

    if (Process->BasePriority == NewBase) {
        return NewBase;
    }

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Save the current process base priority, set the new process base
    // priority, compute the adjustment value, and adjust the priority
    // and base priority of all child threads as appropriate.
    //

    OldBase = Process->BasePriority;
    Process->BasePriority = (SCHAR)NewBase;
    Adjustment = NewBase - OldBase;
    NextEntry = Process->ThreadListHead.Flink;
    if (NewBase >= LOW_REALTIME_PRIORITY) {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the realtime class,
            // then limit the change to the realtime class.
            //

            if (NewPriority < LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY;

            } else if (NewPriority > HIGH_PRIORITY) {
                NewPriority = HIGH_PRIORITY;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the appropriate value.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from variable to realtime, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase < LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = HIGH_PRIORITY;

                } else if (Thread->Saturation < 0) {
                    NewPriority = LOW_REALTIME_PRIORITY;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }

    } else {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the variable class,
            // then limit the change to the variable class.
            //

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;

            } else if (NewPriority <= LOW_PRIORITY) {
                NewPriority = 1;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the computed value and reset the thread quantum.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from realtime to variable, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase >= LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = LOW_REALTIME_PRIORITY - 1;

                } else if (Thread->Saturation < 0) {
                    NewPriority = 1;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }
    }

    //
    // Unlock dispatcher database from SYNCH_LEVEL, unlock the process lock
    // and lower IRQL to its previous value, and return the previous process
    // base priority.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return OldBase;
}

LOGICAL
KeSetDisableQuantumProcess (
    IN PKPROCESS Process,
    IN LOGICAL Disable
    )

/*++

Routine Description:

    This function disables quantum runout for realtime threads in the
    specified process.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Disable - Supplies a logical value that determines whether quantum
        runout for realtime threads in the specified process are disabled
        or enabled.

Return Value:

    The previous value of the disable quantum state variable.

--*/

{

    LOGICAL DisableQuantum;

    ASSERT_PROCESS(Process);

    //
    // Capture the current state of the disable boost variable and set its
    // state to TRUE.
    //

    DisableQuantum = Process->DisableQuantum;
    Process->DisableQuantum = (BOOLEAN)Disable;

    //
    // Return the previous disable quantum state.
    //

    return DisableQuantum;
}

VOID
KiAttachProcess (
    IN PRKTHREAD Thread,
    IN PKPROCESS Process,
    IN KIRQL OldIrql,
    OUT PRKAPC_STATE SavedApcState
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space.

    N.B. The dispatcher database lock must be held when this routine is
        called.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Process - Supplies a pointer to a dispatcher object of type process.

    OldIrql - Supplies the previous IRQL.

    SavedApcState - Supplies a pointer to the APC state structure that receives
        the saved APC state.

Return Value:

    None.

--*/

{

    PRKTHREAD OutThread;
    KAFFINITY Processor;
    PLIST_ENTRY NextEntry;
    KIRQL HighIrql;

    ASSERT(Process != Thread->ApcState.Process);

    //
    // Bias the stack count of the target process to signify that a
    // thread exists in that process with a stack that is resident.
    //

    Process->StackCount += 1;

    //
    // Save current APC state and initialize a new APC state.
    //

    KiMoveApcState(&Thread->ApcState, SavedApcState);
    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.Process = Process;
    Thread->ApcState.KernelApcInProgress = FALSE;
    Thread->ApcState.KernelApcPending = FALSE;
    Thread->ApcState.UserApcPending = FALSE;
    if (SavedApcState == &Thread->SavedApcState) {
        Thread->ApcStatePointer[0] = &Thread->SavedApcState;
        Thread->ApcStatePointer[1] = &Thread->ApcState;
        Thread->ApcStateIndex = 1;
    }

    //
    // If the target process is in memory, then immediately enter the
    // new address space by loading a new Directory Table Base. Otherwise,
    // insert the current thread in the target process ready list, inswap
    // the target process if necessary, select a new thread to run on the
    // the current processor and context switch to the new thread.
    //

    if (Process->State == ProcessInMemory) {

        //
        // It is possible that the process is in memory, but there exist
        // threads in the process ready list. This can happen when memory
        // management forces a process attach.
        //

        NextEntry = Process->ReadyListHead.Flink;
        while (NextEntry != &Process->ReadyListHead) {
            OutThread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(NextEntry);
            OutThread->ProcessReadyQueue = FALSE;
            KiReadyThread(OutThread);
            NextEntry = Process->ReadyListHead.Flink;
        }

        KiSwapProcess(Process, SavedApcState->Process);
        KiUnlockDispatcherDatabase(OldIrql);

    } else {
        Thread->State = Ready;
        Thread->ProcessReadyQueue = TRUE;
        InsertTailList(&Process->ReadyListHead, &Thread->WaitListEntry);
        if (Process->State == ProcessOutOfMemory) {
            Process->State = ProcessInTransition;
            InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                           &Process->SwapListEntry);

            KiSetSwapEvent();
        }

        //
        // Clear the active processor bit in the previous process and
        // set active processor bit in the process being attached to.
        //

#if !defined(NT_UP)

        KiLockContextSwap(&HighIrql);
        Processor = KeGetCurrentPrcb()->SetMember;
        SavedApcState->Process->ActiveProcessors &= ~Processor;
        Process->ActiveProcessors |= Processor;
        KiUnlockContextSwap(HighIrql);

#endif

        Thread->WaitIrql = OldIrql;
        KiSwapThread();
    }

    return;
}

VOID
KiMoveApcState (
    IN PKAPC_STATE Source,
    OUT PKAPC_STATE Destination
    )

/*++

Routine Description:

    This function moves the APC state from the source structure to the
    destination structure and reinitializes list headers as appropriate.

Arguments:

    Source - Supplies a pointer to the source APC state structure.

    Destination - Supplies a pointer to the destination APC state structure.


Return Value:

    None.

--*/

{

    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    //
    // Copy the APC state from the source to the destination.
    //

    *Destination = *Source;
    if (IsListEmpty(&Source->ApcListHead[KernelMode]) != FALSE) {
        InitializeListHead(&Destination->ApcListHead[KernelMode]);

    } else {
        First = Source->ApcListHead[KernelMode].Flink;
        Last = Source->ApcListHead[KernelMode].Blink;
        Destination->ApcListHead[KernelMode].Flink = First;
        Destination->ApcListHead[KernelMode].Blink = Last;
        First->Blink = &Destination->ApcListHead[KernelMode];
        Last->Flink = &Destination->ApcListHead[KernelMode];
    }

    if (IsListEmpty(&Source->ApcListHead[UserMode]) != FALSE) {
        InitializeListHead(&Destination->ApcListHead[UserMode]);

    } else {
        First = Source->ApcListHead[UserMode].Flink;
        Last = Source->ApcListHead[UserMode].Blink;
        Destination->ApcListHead[UserMode].Flink = First;
        Destination->ApcListHead[UserMode].Blink = Last;
        First->Blink = &Destination->ApcListHead[UserMode];
        Last->Flink = &Destination->ApcListHead[UserMode];
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=ke

TARGETNAME=ke
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc;..\$(TARGET_DIRECTORY);$(HALKIT_INC_PATH)

SOURCES=..\apcobj.c   \
        ..\apcsup.c   \
        ..\balmgr.c   \
        ..\bugcheck.c \
        ..\config.c   \
        ..\debug.c    \
        ..\devquobj.c \
        ..\dpcobj.c   \
        ..\dpcsup.c   \
        ..\eventobj.c \
        ..\interobj.c \
        ..\kernldat.c \
        ..\kevutil.c  \
        ..\kiinit.c   \
        ..\miscc.c    \
        ..\mutntobj.c \
        ..\procobj.c  \
        ..\profobj.c  \
        ..\queueobj.c \
        ..\raisexcp.c \
        ..\semphobj.c \
        ..\thredobj.c \
        ..\thredsup.c \
        ..\timerobj.c \
        ..\timersup.c \
        ..\wait.c     \
        ..\waitsup.c  \
        ..\xipi.c     \
        ..\yield.c

NTTARGETFILES=

PRECOMPILED_INCLUDE=..\ki.h
PRECOMPILED_PCH=ki.pch
PRECOMPILED_OBJ=ki.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\queueobj.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    queueobj.c

Abstract:

    This module implements the kernel queue object. Functions are
    provided to initialize, read, insert, and remove queue objects.

Author:

    David N. Cutler (davec) 31-Dec-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_QUEUE(Q) ASSERT((Q)->Header.Type == QueueObject);

VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

    Count - Supplies the target maximum number of threads that should
        be concurrently active. If this parameter is not specified,
        then the number of processors is used.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // state of queue object.
    //

    Queue->Header.Type = QueueObject;
    Queue->Header.Size = sizeof(KQUEUE) / sizeof(LONG);
    Queue->Header.SignalState = 0;
    InitializeListHead(&Queue->Header.WaitListHead);

    //
    // Initialize queue listhead, the thread list head, the current number
    // of threads, and the target maximum number of threads.
    //

    InitializeListHead(&Queue->EntryListHead);
    InitializeListHead(&Queue->ThreadListHead);
    Queue->CurrentCount = 0;
    if (ARGUMENT_PRESENT((PVOID)(ULONG_PTR)Count)) {
        Queue->MaximumCount = Count;

    } else {
        Queue->MaximumCount = KeNumberProcessors;
    }

    return;
}

LONG
KeReadStateQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function reads the current signal state of a Queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    The current signal state of the Queue object.

--*/

{

    ASSERT_QUEUE(Queue);

    //
    // Return current signal state of Queue object.
    //

    return Queue->Header.SignalState;
}

LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, FALSE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, TRUE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

//
// The following macro initializes thread local variables for the wait
// for single object kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeRemoveQueue()                                             \
    Thread->WaitBlockList = WaitBlock;                                      \
    WaitBlock->Object = (PVOID)Queue;                                       \
    WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);                          \
    WaitBlock->WaitType = WaitAny;                                          \
    WaitBlock->Thread = Thread;                                             \
    Thread->WaitStatus = 0;                                                 \
    if (ARGUMENT_PRESENT(Timeout)) {                                        \
        WaitBlock->NextWaitBlock = WaitTimer;                               \
        WaitTimer->NextWaitBlock = WaitBlock;                               \
        Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;       \
        Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;       \
    } else {                                                                \
        WaitBlock->NextWaitBlock = WaitBlock;                               \
    }                                                                       \
    Thread->Alertable = FALSE;                                              \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = WrQueue;                                           \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime= KiQueryLowTickCount()

PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes the next entry from the Queue object entry
    list. If no list entry is available, then the calling thread is
    put in a wait state.

    N.B. The wait discipline for Queue object LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The address of the entry removed from the Queue object entry list or
    STATUS_TIMEOUT.

    N.B. These values can easily be distinguished by the fact that all
         addresses in kernel mode have the high order bit set.

--*/

{

    LARGE_INTEGER DueTime;
    PLIST_ENTRY Entry;
    LARGE_INTEGER NewTime;
    PRKQUEUE OldQueue;
    PLARGE_INTEGER OriginalTime;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    LONG_PTR WaitStatus;
    PRKWAIT_BLOCK WaitTimer;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Set constant variables.
    //

    OriginalTime = Timeout;
    Thread = KeGetCurrentThread();
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[0];
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;
        InitializeRemoveQueue();

    } else {

#if defined(NT_UP)

        Thread->WaitIrql = KeRaiseIrqlToDpcLevel();

#else

        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();

#endif

        InitializeRemoveQueue();
        KiLockDispatcherDatabaseAtSynchLevel();
    }

    //
    // Check if the thread is currently processing a queue entry and whether
    // the new queue is the same as the old queue.
    //

    OldQueue = Thread->Queue;
    Thread->Queue = Queue;
    if (Queue != OldQueue) {

        //
        // If the thread was previously associated with a queue, then remove
        // the thread from the old queue object thread list and attempt to
        // activate another thread.
        //

        Entry = &Thread->QueueListEntry;
        if (OldQueue != NULL) {
            RemoveEntryList(Entry);
            KiActivateWaiterQueue(OldQueue);
        }

        //
        // Insert thread in the thread list of the new queue that the thread
        // will be associate with.
        //

        InsertTailList(&Queue->ThreadListHead, Entry);

    } else {

        //
        // The previous and current queue are the same queue - decrement the
        // current number of threads.
        //

        Queue->CurrentCount -= 1;
    }

    //
    //
    // Start of wait loop.
    //
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //
    // If the Queue object entry list is not empty, then remove the next
    // entry from the Queue object entry list. Otherwise, wait for an entry
    // to be inserted in the queue.
    //

    do {

        //
        // Check if there is a queue entry available and the current
        // number of active threads is less than target maximum number
        // of threads.
        //

        Entry = Queue->EntryListHead.Flink;
        if ((Entry != &Queue->EntryListHead) &&
            (Queue->CurrentCount < Queue->MaximumCount)) {

            //
            // Decrement the number of entires in the Queue object entry list,
            // increment the number of active threads, remove the next entry
            // rom the list, and set the forward link to NULL.
            //

            Queue->Header.SignalState -= 1;
            Queue->CurrentCount += 1;
            if ((Entry->Flink == NULL) || (Entry->Blink == NULL)) {
                KeBugCheckEx(INVALID_WORK_QUEUE_ITEM,
                             (ULONG_PTR)Entry,
                             (ULONG_PTR)Queue,
                             (ULONG_PTR)&ExWorkerQueue[0],
                             (ULONG_PTR)((PWORK_QUEUE_ITEM)Entry)->WorkerRoutine);
            }

            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            break;

        } else {

            //
            // Test to determine if a kernel APC is pending.
            //
            // If a kernel APC is pending and the previous IRQL was less than
            // APC_LEVEL, then a kernel APC was queued by another processor
            // just after IRQL was raised to DISPATCH_LEVEL, but before the
            // dispatcher database was locked.
            //
            // N.B. that this can only happen in a multiprocessor system.
            //

            if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

                //
                // Increment the current thread count, unlock the dispatcher
                // database, and lower IRQL to previous value. An APC interrupt
                // will immediately occur which will result in the delivery of
                // the kernel APC if possible.
                //

                Queue->CurrentCount += 1;
                KiUnlockDispatcherDatabase(Thread->WaitIrql);

            } else {

                //
                // Test if a user APC is pending.
                //

                if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) {
                    Entry = (PLIST_ENTRY)ULongToPtr(STATUS_USER_APC);
                    Queue->CurrentCount += 1;
                    break;
                }

                //
                // Check to determine if a timeout value is specified.
                //

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // If the timeout value is zero, then return immediately
                    // without waiting.
                    //

                    if (!(Timeout->LowPart | Timeout->HighPart)) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    //
                    // Insert the timer in the timer tree.
                    //
                    // N.B. The constant fields of the timer wait block are
                    //      initialized when the thread is initialized. The
                    //      constant fields include the wait object, wait key,
                    //      wait type, and the wait list entry link pointers.
                    //

                    if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    DueTime.QuadPart = Timer->DueTime.QuadPart;
                }

                //
                // Insert wait block in object wait list.
                //

                InsertTailList(&Queue->Header.WaitListHead, &WaitBlock->WaitListEntry);

                //
                // Set the thread wait parameters, set the thread dispatcher
                // state to Waiting, and insert the thread in the wait list.
                //

                Thread->State = Waiting;
                if (StackSwappable != FALSE) {
                    InsertTailList(&KiWaitListHead, &Thread->WaitListEntry);
                }

                //
                // Switch context to selected thread.
                //
                // Control is returned at the original IRQL.
                //

                ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                WaitStatus = KiSwapThread();

                //
                // If the thread was not awakened to deliver a kernel mode APC,
                // then return wait status.
                //

                Thread->WaitReason = 0;
                if (WaitStatus != STATUS_KERNEL_APC) {
                    return (PLIST_ENTRY)WaitStatus;
                }

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // Reduce the amount of time remaining before timeout occurs.
                    //

                    Timeout = KiComputeWaitInterval(OriginalTime,
                                                    &DueTime,
                                                    &NewTime);
                }
            }

            //
            // Raise IRQL to DPC level, initialize the thread local variables,
            // lock the dispatcher database, and decrement the count of active
            // threads.
            //

#if defined(NT_UP)

            Thread->WaitIrql = KeRaiseIrqlToDpcLevel();

#else

            Thread->WaitIrql = KeRaiseIrqlToSynchLevel();

#endif

            InitializeRemoveQueue();
            KiLockDispatcherDatabaseAtSynchLevel();
            Queue->CurrentCount -= 1;
        }

    } while (TRUE);

    //
    // Unlock the dispatcher database and return the list entry address or a
    // status of timeout.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return Entry;
}

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function runs down the specified queue by removing the listhead
    from the queue list, removing any associated threads from the thread
    list, and returning the address of the first entry.


Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    If the queue list is not empty, then the address of the first entry in
    the queue is returned as the function value. Otherwise, a value of NULL
    is returned.

--*/

{

    PLIST_ENTRY Entry;
    PLIST_ENTRY FirstEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatch level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Get the address of the first entry in the queue and check if the
    // list is empty or contains entries that should be flushed. If there
    // are no entries in the list, then set the return value to NULL.
    // Otherwise, set the return value to the address of the first list
    // entry and remove the listhead from the list.
    //

    FirstEntry = Queue->EntryListHead.Flink;
    if (FirstEntry == &Queue->EntryListHead) {
        FirstEntry = NULL;

    } else {
        RemoveEntryList(&Queue->EntryListHead);
    }

    //
    // Remove all associated threads from the thread list of the queue.
    //

    while (Queue->ThreadListHead.Flink != &Queue->ThreadListHead) {
        Entry = Queue->ThreadListHead.Flink;
        Thread = CONTAINING_RECORD(Entry, KTHREAD, QueueListEntry);
        Thread->Queue = NULL;
        RemoveEntryList(Entry);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous level,
    // and return the function value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return FirstEntry;
}

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function is called when the current thread is about to enter a
    wait state and is currently processing a queue entry. The current
    number of threads processign entries for the queue is decrement and
    an attempt is made to activate another thread if the current count
    is less than the maximum count, there is a waiting thread, and the
    queue is not empty.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    PRLIST_ENTRY Entry;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PRLIST_ENTRY WaitEntry;

    //
    // Decrement the current count of active threads and check if another
    // thread can be activated. If the current number of active threads is
    // less than the target maximum number of threads, there is a entry in
    // in the queue, and a thread is waiting, then remove the entry from the
    // queue, decrement the number of entries in the queue, and unwait the
    // respectiive thread.
    //

    Queue->CurrentCount -= 1;
    if (Queue->CurrentCount < Queue->MaximumCount) {
        Entry = Queue->EntryListHead.Flink;
        WaitEntry = Queue->Header.WaitListHead.Blink;
        if ((Entry != &Queue->EntryListHead) &&
            (WaitEntry != &Queue->Header.WaitListHead)) {
            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            Queue->Header.SignalState -= 1;
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            Thread = WaitBlock->Thread;
            KiUnwaitThread(Thread, (LONG_PTR)Entry, 0, NULL);
        }
    }

    return;
}

LONG
FASTCALL
KiInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

    Head - Supplies a boolean value that determines whether the queue
        entry is inserted at the head or tail of the queue if it can
        not be immediately dispatched.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    LONG OldState;
    PRKTHREAD Thread;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    ASSERT_QUEUE(Queue);

    //
    // Capture the current signal state of queue object and check if there
    // is a thread waiting on the queue object, the current number of active
    // threads is less than the target number of threads, and the wait reason
    // of the current thread is not queue wait or the wait queue is not the
    // same queue as the insertion queue. If these conditions are satisfied,
    // then satisfy the thread wait and pass the thread the address of the
    // queue entry as the wait status. Otherwise, set the state of the queue
    // object to signaled and insert the specified entry in the queue object
    // entry list.
    //

    OldState = Queue->Header.SignalState;
    Thread = KeGetCurrentThread();
    WaitEntry = Queue->Header.WaitListHead.Blink;
    if ((WaitEntry != &Queue->Header.WaitListHead) &&
        (Queue->CurrentCount < Queue->MaximumCount) &&
        ((Thread->Queue != Queue) ||
        (Thread->WaitReason != WrQueue))) {

        //
        // Remove the last wait block from the wait list and get the address
        // of the waiting thread object.
        //

        RemoveEntryList(WaitEntry);
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // Set the wait completion status, remove the thread from its wait
        // list, increment the number of active threads, and clear the wait
        // reason.
        //

        Thread->WaitStatus = (LONG_PTR)Entry;
        if (Thread->WaitListEntry.Flink != NULL) {
            RemoveEntryList(&Thread->WaitListEntry);
        }

        Queue->CurrentCount += 1;
        Thread->WaitReason = 0;

        //
        // If thread timer is still active, then cancel thread timer.
        //

        Timer = &Thread->Timer;
        if (Timer->Header.Inserted == TRUE) {
            KiRemoveTreeTimer(Timer);
        }

        //
        // Ready the thread for execution.
        //

        KiReadyThread(Thread);

    } else {
        Queue->Header.SignalState += 1;
        if (Head != FALSE) {
            InsertHeadList(&Queue->EntryListHead, Entry);

        } else {
            InsertTailList(&Queue->EntryListHead, Entry);
        }
    }

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\raisexcp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisexcp.c

Abstract:

    This module implements the internal kernel code to continue execution
    and raise a exception.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"

VOID
KiContinuePreviousModeUser(
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This function is called from KiContinue if PreviousMode is
    not KernelMode.   In this case a kernel mode copy of the 
    ContextRecord is made before calling KeContextToKframes.
    This is done in a seperate routine to save stack space for
    the common case which is PreviousMode == Kernel.

    N.B. This routine is called from within a try/except block
    that will be used to handle errors like invalid context.

Arguments:


    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Not KernelMode.

Return Value:

    None.

--*/

{
    CONTEXT ContextRecord2;

    //
    // Copy the context record to kernel mode space.
    //

    ProbeForReadSmallStructure(ContextRecord, sizeof(CONTEXT), CONTEXT_ALIGN);
    RtlCopyMemory(&ContextRecord2, ContextRecord, sizeof(CONTEXT));
    ContextRecord = &ContextRecord2;

    //
    // Move information from the context record to the exception
    // and trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &ContextRecord2,
                       ContextRecord2.ContextFlags,
                       PreviousMode);
}


NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context frame to the
    specified exception and trap frames for the continue system service.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if the context record is not readable
        from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the context record is not
        properly aligned.

    STATUS_SUCCESS is returned if the context frame is copied successfully
        to the specified exception and trap frames.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    KIRQL OldIrql;
    BOOLEAN IrqlChanged = FALSE;

    //
    // Synchronize with other context operations.
    //

    Status = STATUS_SUCCESS;
    if (KeGetCurrentIrql() < APC_LEVEL) {

        //
        // To support try-except and ExRaiseStatus in device driver code we
        // need to check if we are already at raised level.
        //

        IrqlChanged = TRUE;
        KeRaiseIrql(APC_LEVEL, &OldIrql);
    }

    //
    // Establish an exception handler and probe and capture the specified
    // context record if the previous mode is user. If the probe or copy
    // fails, then return the exception code as the function value. Else
    // copy the context record to the specified exception and trap frames,
    // and return success as the function value.
    //

    try {

        //
        // Get the previous processor mode. If the previous processor mode is
        // user, then probe and copy the specified context record.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            KiContinuePreviousModeUser(ContextRecord,
                                       ExceptionFrame,
                                       TrapFrame,
                                       PreviousMode);
        } else {

            //
            // Move information from the context record to the exception
            // and trap frames.
            //

            KeContextToKframes(TrapFrame,
                               ExceptionFrame,
                               ContextRecord,
                               ContextRecord->ContextFlags,
                               PreviousMode);
        }

    //
    // If an exception occurs during the probe or copy of the context
    // record, then always handle the exception and return the exception
    // code as the status value.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (IrqlChanged) {
        KeLowerIrql (OldIrql);
    }

    return Status;
}

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to raise an exception. The exception can be
    raised as a first or second chance exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if either the exception or the context
        record is not readable from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the exception record or the
        context record are not properly aligned.

    STATUS_INVALID_PARAMETER is returned if the number of exception parameters
        is greater than the maximum allowable number of exception parameters.

    STATUS_SUCCESS is returned if the exception is dispatched and handled.

--*/

{

    CONTEXT ContextRecord2;
    EXCEPTION_RECORD ExceptionRecord2;
    ULONG Length;
    ULONG Params;
    KPROCESSOR_MODE PreviousMode;

    //
    // Establish an exception handler and probe the specified exception and
    // context records for read accessibility. If the probe fails, then
    // return the exception code as the service status. Else call the exception
    // dispatcher to dispatch the exception.
    //

    try {

        //
        // Get the previous processor mode. If the previous processor mode
        // is user, then probe and copy the specified exception and context
        // records.
        //

        PreviousMode = KeGetPreviousMode();
        if (PreviousMode != KernelMode) {
            ProbeForReadSmallStructure(ContextRecord, sizeof(CONTEXT), CONTEXT_ALIGN);
            ProbeForReadSmallStructure(ExceptionRecord,
                         FIELD_OFFSET (EXCEPTION_RECORD, NumberParameters) +
                         sizeof (ExceptionRecord->NumberParameters), sizeof(ULONG));
            Params = ExceptionRecord->NumberParameters;
            if (Params > EXCEPTION_MAXIMUM_PARAMETERS) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // The exception record structure is defined unlike others with trailing
            // information as being its maximum size rather than just a single trailing
            // element.
            //
            Length = (sizeof(EXCEPTION_RECORD) -
                     ((EXCEPTION_MAXIMUM_PARAMETERS - Params) *
                     sizeof(ExceptionRecord->ExceptionInformation[0])));

            //
            // The structure is currently less that 64k so we don't really need this probe.
            //
            ProbeForRead(ExceptionRecord, Length, sizeof(ULONG));

            //
            // Copy the exception and context record to local storage so an
            // access violation cannot occur during exception dispatching.
            //

            RtlCopyMemory(&ContextRecord2, ContextRecord, sizeof(CONTEXT));
            RtlCopyMemory(&ExceptionRecord2, ExceptionRecord, Length);
            ContextRecord = &ContextRecord2;
            ExceptionRecord = &ExceptionRecord2;
            //
            // The number of parameters might have changed after we validated but before we
            // copied the structure. Fix this up as lower levels might not like this.
            //
            ExceptionRecord->NumberParameters = Params;            
        }

    //
    // If an exception occurs during the probe of the exception or context
    // record, then always handle the exception and return the exception code
    // as the status value.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Move information from the context record to the exception and
    // trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags,
                       PreviousMode);

    //
    // Make sure the reserved bit is clear in the exception code and
    // perform exception dispatching.
    //
    // N.B. The reserved bit is used to differentiate internally gerarated
    //      codes from codes generated by application programs.
    //

    ExceptionRecord->ExceptionCode &= 0xefffffff;
    KiDispatchException(ExceptionRecord,
                        ExceptionFrame,
                        TrapFrame,
                        PreviousMode,
                        FirstChance);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\thredobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    threadobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel thread object. Functions are provided to initialize, ready,
    alert, test alert, boost priority, enable APC queuing, disable APC
    queuing, confine, set affinity, set priority, suspend, resume, alert
    resume, terminate, read thread state, freeze, unfreeze, query data
    alignment handling mode, force resume, and enter and leave critical
    regions for thread objects.

Author:

    David N. Cutler (davec) 4-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text(INIT, KeInitializeThread)
#pragma alloc_text(PAGE, KeInitThread)
#pragma alloc_text(PAGE, KeUninitThread)

//
// The following assert macro is used to check that an input thread object is
// really a kthread and not something else, like deallocated pool.
//

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

NTSTATUS
KeInitThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack OPTIONAL,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL,
    IN PVOID Teb OPTIONAL,
    IN PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object.

    N.B. This routine is carefully written so that if an access violation
        occurs while reading the specified context frame, then no kernel
        data structures will have been modified. It is the responsibility
        of the caller to handle the exception and provide necessary clean
        up.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

    Teb - Supplies an optional pointer to the user mode thread environment
        block. This parameter is specified if the thread is a user thread and
        will execute in user mode. This parameter is ignored if the ContextFrame
        parameter is not specified.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    None.

--*/

{

    UCHAR IdealProcessor;
    ULONG Index;
    BOOLEAN KernelStackAllocated = FALSE;
    KAFFINITY PreferredSet;
    NTSTATUS Status = STATUS_SUCCESS;
    KAFFINITY TempSet;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;

    //
    // Initialize the standard dispatcher object header and set the initial
    // state of the thread object.
    //

    Thread->Header.Type = ThreadObject;
    Thread->Header.Size = sizeof(KTHREAD) / sizeof(LONG);
    InitializeListHead(&Thread->Header.WaitListHead);

    //
    // Initialize the owned mutant listhead.
    //

    InitializeListHead(&Thread->MutantListHead);

    //
    // Initialize the thread field of all builtin wait blocks.
    //

    for (Index = 0; Index < (THREAD_WAIT_OBJECTS + 1); Index += 1) {
        Thread->WaitBlock[Index].Thread = Thread;
    }

    //
    // Initialize the alerted, preempted, debugactive, autoalignment,
    // kernel stack resident, enable kernel stack swap, and process
    // ready queue boolean values.
    //
    // N.B. Only nonzero values are initialized.
    //

    Thread->AutoAlignment = Process->AutoAlignment;
    Thread->EnableStackSwap = TRUE;
    Thread->KernelStackResident = TRUE;

    //
    // Set the system service table pointer to the address of the static
    // system service descriptor table. If the thread is later converted
    // to a Win32 thread this pointer will be change to a pointer to the
    // shadow system service descriptor table.
    //

    Thread->ServiceTable = (PVOID)&KeServiceDescriptorTable[0];

    //
    // Initialize the APC state pointers, the current APC state, the saved
    // APC state, and enable APC queuing.
    //

    Thread->ApcStatePointer[0] = &Thread->ApcState;
    Thread->ApcStatePointer[1] = &Thread->SavedApcState;
    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.Process = Process;
    Thread->ApcQueueable = TRUE;

    //
    // Initialize the kernel mode suspend APC and the suspend semaphore object.
    // and the builtin wait timeout timer object.
    //

    KeInitializeApc(&Thread->SuspendApc,
                    Thread,
                    OriginalApcEnvironment,
                    (PKKERNEL_ROUTINE)KiSuspendNop,
                    (PKRUNDOWN_ROUTINE)KiSuspendRundown,
                    KiSuspendThread,
                    KernelMode,
                    NULL);

    KeInitializeSemaphore(&Thread->SuspendSemaphore, 0L, 2L);

    //
    // Initialize the builtin timer trimer wait wait block.
    //
    // N.B. This is the only time the wait block is initialized sincs this
    //      information is constant.
    //

    Timer = &Thread->Timer;
    KeInitializeTimer(Timer);
    WaitBlock = &Thread->WaitBlock[TIMER_WAIT_BLOCK];
    WaitBlock->Object = Timer;
    WaitBlock->WaitKey = (CSHORT)STATUS_TIMEOUT;
    WaitBlock->WaitType = WaitAny;
    WaitBlock->WaitListEntry.Flink = &Timer->Header.WaitListHead;
    WaitBlock->WaitListEntry.Blink = &Timer->Header.WaitListHead;

    //
    // Initialize the APC queue spinlock.
    //

    KeInitializeSpinLock(&Thread->ApcQueueLock);

    //
    // Initialize the Thread Environment Block (TEB) pointer (can be NULL).
    //

    Thread->Teb = Teb;

#if defined(NT_UP)

    IdealProcessor = 0;

#else

    //
    // Initialize the ideal processor number for the thread.
    //
    // Set IdealProcessor to next processor this thread is allowed to
    // run on.
    //
    // Get a bit mask of the affinity of all processors with a smaller
    // number than the last processor assigned to this process.
    //

    IdealProcessor = Process->ThreadSeed;
    PreferredSet = Process->Affinity & KeActiveProcessors;

    //
    // If possible bias the ideal processor to a different SMT set than the
    // last thread.
    //

#if defined(NT_SMT)

    TempSet = ~KiProcessorBlock[IdealProcessor]->MultiThreadProcessorSet;
    if ((PreferredSet & TempSet) != 0) {
        PreferredSet &= TempSet;
    }

#endif

    //
    // For NUMA systems bias the ideal processor to the same node as other
    // threads in the process.
    //

#if defined(KE_MULTINODE)

    TempSet = KeNodeBlock[Process->IdealNode]->ProcessorMask;
    if ((PreferredSet & TempSet) != 0) {
        PreferredSet &= TempSet;
    }

#endif

    IdealProcessor = KeFindNextRightSetAffinity(IdealProcessor,
                                                PreferredSet);

#endif

    //
    // Set the initial node which is used for stack allocation and delete.
    // This needs to be determined as it may not have been possible to put
    // the thread on its ideal node.
    //

#if defined(KE_MULTINODE)

    for (Index = Process->IdealNode;
         (KeNodeBlock[Index]->ProcessorMask & AFFINITY_MASK(IdealProcessor)) == 0;
         Index = Index > 0 ? Index - 1 : KeNumberNodes - 1) {
        if (Process->IdealNode == Index) {

            //
            // This can only happen if we wrapped,... which can't happen.
            //

            Index = 0;
            break;
        }
    }

    Thread->InitialNode = (UCHAR)Index;

#else

    Thread->InitialNode = 0;

#endif

    //
    // Set the initial kernel stack and the initial thread context.
    //

    if (KernelStack == NULL) {

        //
        // Get a kernel stack for this thread.
        //

        KernelStack = MmCreateKernelStack(FALSE, Thread->InitialNode);
        if (KernelStack == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KernelStackAllocated = TRUE;
    }

    Thread->InitialStack = KernelStack;
    Thread->StackBase = KernelStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)KernelStack - KERNEL_STACK_SIZE);
    try {
        KiInitializeContextThread(Thread,
                                  SystemRoutine,
                                  StartRoutine,
                                  StartContext,
                                  ContextFrame);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (KernelStackAllocated) {
            MmDeleteKernelStack(Thread->StackBase, FALSE);
            Thread->InitialStack = NULL;
        }

        return GetExceptionCode();
    }

    //
    // Set the base thread priority, the thread priority, the thread affinity,
    // the thread quantum, and the scheduling state.
    //

    Thread->State = Initialized;

#if defined(NT_UP)

    Thread->IdealProcessor = 0;
    Thread->SoftAffinity = 1;

#else

    Thread->IdealProcessor = IdealProcessor;

#endif

    return STATUS_SUCCESS;
}

VOID
KeUninitThread (
    IN PKTHREAD Thread
    )
/*++

Routine Description:

    This function frees the thread kernel stack and must be called before
    the thread is started.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.
--*/

{

    MmDeleteKernelStack(Thread->StackBase, FALSE);
    Thread->InitialStack = NULL;
    return;
}

VOID
KeStartThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function initializes remaining thread fields and inserts the thread
    in the thread's process list. From this point on the thread must run.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;

    //
    // Initialize the thread priority, affinity, and quantum.
    //

    Process = Thread->ApcState.Process;
    Thread->BasePriority = Process->BasePriority;
    Thread->Priority = Thread->BasePriority;
    Thread->Affinity = Process->Affinity;
    Thread->UserAffinity = Process->Affinity;
    Thread->SystemAffinityActive = FALSE;
    Thread->Quantum = Process->ThreadQuantum;
    Thread->DisableBoost = Process->DisableBoost;

#if !defined(NT_UP)

    Thread->SoftAffinity =
        KiProcessorBlock[Thread->IdealProcessor]->ParentNode->ProcessorMask;

#endif

#if defined(_X86_)

    Thread->Iopl = Process->Iopl;

#endif

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Insert the thread in the process  thread list, and increment the kernel
    // stack count.
    //
    // N.B. The distinguished value MAXSHORT is used to signify that no
    //      threads have been created for a process.
    //

    InsertTailList(&Process->ThreadListHead, &Thread->ThreadListEntry);
    if (Process->StackCount == MAXSHORT) {
        Process->StackCount = 1;

    } else {
        Process->StackCount += 1;
    }

#if !defined(NT_UP)

    Process->ThreadSeed = Thread->IdealProcessor;

#endif

    //
    // Unlock dispatcher database from SYNCH_LEVEL, unlock the process lock
    // and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return;
}

NTSTATUS
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack OPTIONAL,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL,
    IN PVOID Teb OPTIONAL,
    IN PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object. The
    thread object is inserted at the end of the thread list for the
    parent process.

    N.B. This routine is carefully written so that if an access violation
        occurs while reading the specified context frame, then no kernel
        data structures will have been modified. It is the responsibility
        of the caller to handle the exception and provide necessary clean
        up.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

    Teb - Supplies an optional pointer to the user mode thread environment
        block. This parameter is specified if the thread is a user thread and
        will execute in user mode. This parameter is ignored if the ContextFrame
        parameter is not specified.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    NTSTATUS - Status of operation

--*/

{

    NTSTATUS Status;

    Status = KeInitThread(Thread,
                          KernelStack,
                          SystemRoutine,
                          StartRoutine,
                          StartContext,
                          ContextFrame,
                          Teb,
                          Process);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeStartThread(Thread);
    return STATUS_SUCCESS;
}

BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function attempts to alert a thread and cause its execution to
    be continued if it is currently in an alertable Wait state. Otherwise
    it just sets the alerted variable for the specified processor mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    AlertMode - Supplies the processor mode for which the thread is
        to be alerted.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Capture the current state of the alerted variable for the specified
    // processor mode.
    //

    Alerted = Thread->Alerted[AlertMode];

    //
    // If the alerted state for the specified processor mode is Not-Alerted,
    // then attempt to alert the thread.
    //

    if (Alerted == FALSE) {

        //
        // If the thread is currently in a Wait state, the Wait is alertable,
        // and the specified processor mode is less than or equal to the Wait
        // mode, then the thread is unwaited with a status of "alerted".
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE) &&
            (AlertMode <= Thread->WaitMode)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT, NULL);

        } else {
            Thread->Alerted[AlertMode] = TRUE;
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return the previous
    // alerted state for the specified mode.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Alerted;
}

ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function attempts to alert a thread in kernel mode and cause its
    execution to be continued if it is currently in an alertable Wait state.
    In addition, a resume operation is performed on the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the kernel mode alerted state is FALSE, then attempt to alert
    // the thread for kernel mode.
    //

    if (Thread->Alerted[KernelMode] == FALSE) {

        //
        // If the thread is currently in a Wait state and the Wait is alertable,
        // then the thread is unwaited with a status of "alerted". Else set the
        // kernel mode alerted variable.
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT, NULL);

        } else {
            Thread->Alerted[KernelMode] = TRUE;
        }
    }

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero and the freeze count is
        // zero, then resume the thread by releasing its suspend semaphore.
        //

        if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return the previous
    // suspend count.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return OldCount;
}

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function boosts the priority of the specified thread using the
    same algorithm used when a thread gets a boost from a wait operation.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the thread does not run at a realtime priority level, then boost
    // the thread priority.
    //

    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        KiBoostPriorityThread(Thread, Increment);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

KAFFINITY
KeConfineThread (
    VOID
    )

/*++

Routine Description:

    This function confines the execution of the current thread to the current
    processor.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous affinity value.

--*/

{

    KAFFINITY Affinity;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current affinity and compute new affinity value by
    // shifting a one bit left by the current processor number.
    //

    Affinity = Thread->Affinity;
    Thread->Affinity = AFFINITY_MASK(Thread->NextProcessor);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous affinity value.
    //

    return Affinity;
}

BOOLEAN
KeDisableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function disables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to FALSE.
    //

    ApcQueueable = Thread->ApcQueueable;
    Thread->ApcQueueable = FALSE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous APC queueable state.
    //

    return ApcQueueable;
}

BOOLEAN
KeEnableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function enables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to TRUE.
    //

    ApcQueueable = Thread->ApcQueueable;
    Thread->ApcQueueable = TRUE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous APC queueable state.
    //

    return ApcQueueable;
}

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function forces resumption of thread execution if the thread is
    suspended. If the specified thread is not suspended, then no operation
    is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The sum of the previous suspend count and the freeze count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount + Thread->FreezeCount;

    //
    // If the thread is currently suspended, then force resumption of
    // thread execution.
    //

    if (OldCount != 0) {
        Thread->FreezeCount = 0;
        Thread->SuspendCount = 0;
        Thread->SuspendSemaphore.Header.SignalState += 1;
        KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

VOID
KeFreezeAllThreads (
    VOID
    )

/*++

Routine Description:

    This function suspends the execution of all thread in the current
    process except the current thread. If the freeze count overflows
    the maximum suspend count, then a condition is raised.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKPROCESS Process;
    KLOCK_QUEUE_HANDLE ProcessHandle;
    PKTHREAD Thread;
    KLOCK_QUEUE_HANDLE ThreadHandle;
    ULONG OldCount;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Set the address of the current thread object and the current process
    // object.
    //

    CurrentThread = KeGetCurrentThread();
    Process = CurrentThread->ApcState.Process;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the process lock.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                               &ProcessHandle);

    //
    // If the freeze count of the current thread is not zero, then there
    // is another thread that is trying to freeze this thread. Unlock the
    // the process lock and lower IRQL to its previous value, allow the
    // suspend APC to occur, then raise IRQL to SYNCH_LEVEL and lock the
    // process lock.
    //

    while (CurrentThread->FreezeCount != 0) {
        KeReleaseInStackQueuedSpinLock(&ProcessHandle);
        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                                   &ProcessHandle);
    }

    KeEnterCriticalRegion();

    //
    // Freeze all threads except the current thread.
    //

    ListHead = &Process->ThreadListHead;
    NextEntry = ListHead->Flink;
    do {

        //
        // Get the address of the next thread.
        //

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

        //
        // Acquire the thread APC queue lock and acquire the dispatcher
        // database lock.
        //

        KeAcquireInStackQueuedSpinLockAtDpcLevel(&Thread->ApcQueueLock,
                                                 &ThreadHandle);

        KiLockDispatcherDatabaseAtSynchLevel();

        //
        // If the thread is not the current thread and APCs are queueable,
        // then attempt to suspend the thread.
        //

        if ((Thread != CurrentThread) && (Thread->ApcQueueable == TRUE)) {

            //
            // Increment the freeze count. If the thread was not previously
            // suspended, then queue the thread's suspend APC.
            //

            OldCount = Thread->FreezeCount;

            ASSERT(OldCount != MAXIMUM_SUSPEND_COUNT);

            Thread->FreezeCount += 1;
            if ((OldCount == 0) && (Thread->SuspendCount == 0)) {
                if (KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT) == FALSE) {
                    Thread->SuspendSemaphore.Header.SignalState -= 1;
                }
            }
        }

        //
        // Release the dispatcher database lock and the thread APC queue lock.
        //

        KiUnlockDispatcherDatabaseFromSynchLevel();
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&ThreadHandle);

        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Unlock the process lock and lower IRQL to its previous value.
    //

    KeReleaseInStackQueuedSpinLock(&ProcessHandle); 
    return;
}

BOOLEAN
KeQueryAutoAlignmentThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the data alignment handling mode for the specified
    thread.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if data alignment exceptions are being
    automatically handled by the kernel. Otherwise, a value of FALSE
    is returned.

--*/

{

    ASSERT_THREAD(Thread);

    //
    // Return the data alignment handling mode for the thread.
    //

    return Thread->AutoAlignment;
}

LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the base priority increment of the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The base priority increment of the specified thread.

--*/

{

    LONG Increment;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If priority saturation occured the last time the thread base priority
    // was set, then return the saturation increment value. Otherwise, compute
    // the increment value as the difference between the thread base priority
    // and the process base priority.
    //

    Process = Thread->ApcStatePointer[0]->Process;
    Increment = Thread->BasePriority - Process->BasePriority;
    if (Thread->Saturation != 0) {
        Increment = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority increment.
    //

    return Increment;
}

KPRIORITY
KeQueryPriorityThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the current priority of the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The current priority of the specified thread.

--*/

{

    return Thread->Priority;
}

ULONG
KeQueryRuntimeThread (
    IN PKTHREAD Thread,
    OUT PULONG UserTime
    )

/*++

Routine Description:

    This function returns the kernel and user runtime for the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    UserTime - Supplies a pointer to a variable that receives the user
        runtime for the specified thread.

Return Value:

    The kernel runtime for the specfied thread is returned.

--*/

{

    ASSERT_THREAD(Thread);

    *UserTime = Thread->UserTime;
    return Thread->KernelTime;
}

BOOLEAN
KeReadStateThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function reads the current signal state of a thread object.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The current signal state of the thread object.

--*/

{

    ASSERT_THREAD(Thread);

    //
    // Return current signal state of thread object.
    //

    return (BOOLEAN)Thread->Header.SignalState;
}

VOID
KeReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution. If the thread's process
    is currently not in the balance set, then the thread is inserted in the
    thread's process' ready queue. Else if the thread is higher priority than
    another thread that is currently running on a processor then the thread
    is selected for execution on that processor. Else the thread is inserted
    in the dispatcher ready queue selected by its priority.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Ready the specified thread for execution.
    //

    KiReadyThread(Thread);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function resumes the execution of a suspended thread. If the
    specified thread is not suspended, then no operation is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero and the freeze count is
        // zero, then resume the thread by releasing its suspend semaphore.
        //

        if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}


VOID
KeRevertToUserAffinityThread (
    VOID
    )

/*++

Routine Description:

    This function setss the affinity of the current thread to its user
    affinity.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PKTHREAD NextThread;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(KeGetCurrentThread()->SystemAffinityActive != FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the current affinity to the user affinity.
    //
    // If the current processor is not in the new affinity set and another
    // thread has not already been selected for execution on the current
    // processor, then select a new thread for the current processor.
    //

    CurrentThread->Affinity = CurrentThread->UserAffinity;
    CurrentThread->SystemAffinityActive = FALSE;
    Prcb = KeGetCurrentPrcb();
    if (((Prcb->SetMember & CurrentThread->Affinity) == 0) &&
        (Prcb->NextThread == NULL)) {
        NextThread = KiSelectNextThread(CurrentThread->NextProcessor);
        NextThread->State = Standby;
        Prcb->NextThread = NextThread;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

VOID
KeRundownThread (
    )

/*++

Routine Description:

    This function is called by the executive to rundown thread structures
    which must be guarded by the dispatcher database lock and which must
    be processed before actually terminating the thread. An example of such
    a structure is the mutant ownership list that is anchored in the kernel
    thread object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKMUTANT Mutant;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    Thread = KeGetCurrentThread();

    if (IsListEmpty (&Thread->MutantListHead)) {
        return;
    }

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Scan the list of owned mutant objects and release the mutant objects
    // with an abandoned status. If the mutant is a kernel mutex, then bug
    // check.
    //

    NextEntry = Thread->MutantListHead.Flink;
    while (NextEntry != &Thread->MutantListHead) {
        Mutant = CONTAINING_RECORD(NextEntry, KMUTANT, MutantListEntry);
        if (Mutant->ApcDisable != 0) {
            KeBugCheckEx(THREAD_TERMINATE_HELD_MUTEX,
                         (ULONG_PTR)Thread,
                         (ULONG_PTR)Mutant, 0, 0);
        }

        RemoveEntryList(&Mutant->MutantListEntry);
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;
        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) != TRUE) {
            KiWaitTest(Mutant, MUTANT_INCREMENT);
        }

        NextEntry = Thread->MutantListHead.Flink;
    }

    //
    // Release dispatcher database lock and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a specified thread to a new value.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    The previous affinity of the specified thread.

--*/

{

    KAFFINITY OldAffinity;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the thread affinity to the specified value.
    //

    OldAffinity = KiSetAffinityThread(Thread, Affinity);

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous user affinity.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldAffinity;
}

VOID
KeSetSystemAffinityThread (
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function set the system affinity of the current thread.

Arguments:

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PKTHREAD NextThread;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT((Affinity & KeActiveProcessors) != 0);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the current affinity to the specified affinity.
    //
    // If the current processor is not in the new affinity set and another
    // thread has not already been selected for execution on the current
    // processor, then select a new thread for the current processor.
    //

    CurrentThread->Affinity = Affinity;
    CurrentThread->SystemAffinityActive = TRUE;
    Prcb = KeGetCurrentPrcb();
    if (((Prcb->SetMember & CurrentThread->Affinity) == 0) &&
        (Prcb->NextThread == NULL)) {
        NextThread = KiSelectNextThread(CurrentThread->NextProcessor);
        NextThread->State = Standby;
        Prcb->NextThread = NextThread;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

LONG
KeSetBasePriorityThread (
    IN PKTHREAD Thread,
    IN LONG Increment
    )

/*++

Routine Description:

    This function sets the base priority of the specified thread to a
    new value.  The new base priority for the thread is the process base
    priority plus the increment.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the base priority increment of the subject thread.

        N.B. If the absolute value of the increment is such that saturation
             of the base priority is forced, then subsequent changes to the
             parent process base priority will not change the base priority
             of the thread.

Return Value:

    The previous base priority increment of the specified thread.

--*/

{

    KPRIORITY NewBase;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    LONG OldIncrement;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the base priority of the specified thread and determine
    // whether saturation if being forced.
    //

    Process = Thread->ApcStatePointer[0]->Process;
    OldBase = Thread->BasePriority;
    OldIncrement = OldBase - Process->BasePriority;
    if (Thread->Saturation != 0) {
        OldIncrement = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    Thread->Saturation = FALSE;
    if (abs(Increment) >= (HIGH_PRIORITY + 1) / 2) {
        Thread->Saturation = (Increment > 0) ? 1 : -1;
    }

    //
    // Set the base priority of the specified thread. If the thread's process
    // is in the realtime class, then limit the change to the realtime class.
    // Otherwise, limit the change to the variable class.
    //

    NewBase = Process->BasePriority + Increment;
    if (Process->BasePriority >= LOW_REALTIME_PRIORITY) {
        if (NewBase < LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY;

        } else if (NewBase > HIGH_PRIORITY) {
            NewBase = HIGH_PRIORITY;
        }

        //
        // Set the new priority of the thread to the new base priority.
        //

        NewPriority = NewBase;

    } else {
        if (NewBase >= LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY - 1;

        } else if (NewBase <= LOW_PRIORITY) {
            NewBase = 1;
        }

        //
        // Compute the new thread priority. If the new priority is outside
        // the variable class, then set the new priority to the highest
        // variable priority.
        //

        if (Thread->Saturation != 0) {
            NewPriority = NewBase;

        } else {
            NewPriority = Thread->Priority +
                            (NewBase - OldBase) - Thread->PriorityDecrement;

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;
            }
        }
    }

    //
    // Set the new base priority and clear the priority decrement. If the
    // new priority is not equal to the old priority, then set the new thread
    // priority.
    //

    Thread->BasePriority = (SCHAR)NewBase;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    if (NewPriority != Thread->Priority) {
        Thread->Quantum = Process->ThreadQuantum;
        KiSetPriorityThread(Thread, NewPriority);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority.
    //

    return OldIncrement;
}

LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    )

/*++

Routine Description:

    This function disables priority boosts for the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Disable - Supplies a logical value that determines whether priority
        boosts for the thread are disabled or enabled.

Return Value:

    The previous value of the disable boost state variable.

--*/

{

    LOGICAL DisableBoost;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the disable boost variable and set its
    // state to TRUE.
    //

    DisableBoost = Thread->DisableBoost;
    Thread->DisableBoost = (BOOLEAN)Disable;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous disable boost state.
    //

    return DisableBoost;
}

CCHAR
KeSetIdealProcessorThread (
    IN PKTHREAD Thread,
    IN CCHAR Processor
    )

/*++

Routine Description:

    This function sets the ideal processor for the specified thread execution.
    If the selected processor is greater than the number of processors in the
    system, a processor is selected from the set of available processors.

Arguments:

    Thread - Supplies a pointer to the thread whose ideal processor number is
        set to the specfied value.

    Processor - Supplies the number of the ideal processor.

Return Value:

    The previous ideal processor number.

--*/

{

    CCHAR OldProcessor;
    KIRQL OldIrql;
    PKPROCESS Process;

    //
    // Capture the previous ideal processor value, set the new ideal processor
    // value, and return the old ideal processor value for the current thread.
    //

    ASSERT(Processor <= MAXIMUM_PROCESSORS);

    KiLockDispatcherDatabase(&OldIrql);
    OldProcessor = Thread->IdealProcessor;
    if (Processor < KeNumberProcessors) {
        Thread->IdealProcessor = Processor;

    } else {
        Process = Thread->ApcState.Process;
        Thread->IdealProcessor =
            KeFindNextRightSetAffinity(Process->ThreadSeed,
                                       KeNodeBlock[Process->IdealNode]->ProcessorMask);

        Process->ThreadSeed = Thread->IdealProcessor;
    }

    Thread->SoftAffinity =
        KiProcessorBlock[Thread->IdealProcessor]->ParentNode->ProcessorMask;

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldProcessor;
}

BOOLEAN
KeSetKernelStackSwapEnable (
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the kernel stack swap enable value for the current
    thread and returns the old swap enable value.

Arguments:

    Enable - Supplies the new kernel stack swap enable value.

Return Value:

    The previous kernel stack swap enable value.

--*/

{

    BOOLEAN OldState;
    PKTHREAD Thread;

    //
    // Capture the previous kernel stack swap enable value, set the new
    // swap enable value, and return the old swap enable value for the
    // current thread;
    //

    Thread = KeGetCurrentThread();
    OldState = Thread->EnableStackSwap;
    Thread->EnableStackSwap = Enable;
    return OldState;
}

KPRIORITY
KeSetPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function sets the priority of the specified thread to a new value.
    If the new thread priority is lower than the old thread priority, then
    resecheduling may take place if the thread is currently running on, or
    about to run on, a processor.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new priority of the subject thread.

Return Value:

    The previous priority of the specified thread.

--*/

{

    KIRQL OldIrql;
    KPRIORITY OldPriority;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(((Priority != 0) || (Thread->BasePriority == 0)) &&
           (Priority <= HIGH_PRIORITY));

    ASSERT(KeIsExecutingDpc() == FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current thread priority, set the thread priority to the
    // the new value, and replenish the thread quantum. It is assumed that
    // the priority would not be set unless the thread had already lost it
    // initial quantum.
    //

    OldPriority = Thread->Priority;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    if (Priority != Thread->Priority) {
        Process = Thread->ApcStatePointer[0]->Process;
        Thread->Quantum = Process->ThreadQuantum;
        KiSetPriorityThread(Thread, Priority);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread priority.
    //

    return OldPriority;
}

ULONG
KeSuspendThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function suspends the execution of a thread. If the suspend count
    overflows the maximum suspend count, then a condition is raised.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG OldCount;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Capture the current suspend count.
    //
    // If the suspend count is at its maximum value, then unlock the
    // dispatcher database, unlock the thread APC queue lock, lower IRQL
    // to its previous value, and raise an error condition.
    //

    OldCount = Thread->SuspendCount;
    if (OldCount == MAXIMUM_SUSPEND_COUNT) {
        KiUnlockDispatcherDatabaseFromSynchLevel();
        KeReleaseInStackQueuedSpinLock(&LockHandle);
        ExRaiseStatus(STATUS_SUSPEND_COUNT_EXCEEDED);
    }

    //
    // Don't suspend the thread if APC queuing is disabled. In this case the
    // thread is being deleted.
    //

    if (Thread->ApcQueueable == TRUE) {

        //
        // Increment the suspend count. If the thread was not previously
        // suspended, then queue the thread's suspend APC.
        //

        Thread->SuspendCount += 1;
        if ((OldCount == 0) && (Thread->FreezeCount == 0)) {
            if (KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT) == FALSE) {
                Thread->SuspendSemaphore.Header.SignalState -= 1;
            }
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return the old
    // count.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return OldCount;
}

VOID
KeTerminateThread (
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function terminates the execution of the current thread, sets the
    signal state of the thread to Signaled, and attempts to satisfy as many
    Waits as possible. The scheduling state of the thread is set to terminated,
    and a new thread is selected to run on the current processor. There is no
    return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;
    PKQUEUE Queue;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    Thread = KeGetCurrentThread();
    Process = Thread->ApcState.Process;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Insert the thread in the reaper list.
    //
    // If a reaper thread is not currently active, then insert a work item in
    // the hyper critical work queue.
    //
    // N.B. This code has knowledge of the reaper data structures and how
    //      worker threads are implemented.
    //
    // N.B. The dispatcher database lock is used to synchronize access to the
    //      reaper list.
    //

    ((PETHREAD)Thread)->ReaperLink = PsReaperList;
    PsReaperList = (PETHREAD)Thread;

    if (PsReaperActive == FALSE) {
        PsReaperActive = TRUE;
        KiInsertQueue(&ExWorkerQueue[HyperCriticalWorkQueue].WorkerQueue,
                      &PsReaperWorkItem.List,
                      FALSE);
    }

    //
    // If the current thread is processing a queue entry, then remove
    // the thread from the queue object thread list and attempt to
    // activate another thread that is blocked on the queue object.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        RemoveEntryList(&Thread->QueueListEntry);
        KiActivateWaiterQueue(Queue);
    }

    //
    // Set the state of the current thread object to Signaled, and attempt
    // to satisfy as many Waits as possible.
    //

    Thread->Header.SignalState = TRUE;
    if (IsListEmpty(&Thread->Header.WaitListHead) != TRUE) {
        KiWaitTest((PVOID)Thread, Increment);
    }

    //
    // Remove thread from its parent process' thread list.
    //

    RemoveEntryList(&Thread->ThreadListEntry);

    //
    // Release the process lock, but don't lower the IRQL.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);

    //
    // Set thread scheduling state to terminated, decrement the process'
    // stack count, select a new thread to run on the current processor,
    // and swap context to the new thread.
    //

    Thread->State = Terminated;
    Process->StackCount -= 1;
    if (Process->StackCount == 0) {
        if (Process->ThreadListHead.Flink != &Process->ThreadListHead) {
            Process->State = ProcessOutTransition;
            InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                           &Process->SwapListEntry);

            KiSetSwapEvent();
        }
    }

    //
    // Rundown any architectural specific structures
    //

    KiRundownThread(Thread);

    //
    // Get off the processor for the last time.
    //

    KiSwapThread();
    return;
}

BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function tests to determine if the alerted variable for the
    specified processor mode has a value of TRUE or whether a user mode
    APC should be delivered to the current thread.

Arguments:

    AlertMode - Supplies the processor mode which is to be tested
        for an alerted condition.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the current thread is alerted for the specified processor mode,
    // then clear the alerted state. Else if the specified processor mode
    // is user and the current thread's user mode APC queue contains an entry,
    // then set user APC pending.
    //

    Alerted = Thread->Alerted[AlertMode];
    if (Alerted == TRUE) {
        Thread->Alerted[AlertMode] = FALSE;

    } else if ((AlertMode == UserMode) &&
              (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) != TRUE)) {
        Thread->ApcState.UserApcPending = TRUE;
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, unlock the thread APC
    // queue lock and lower IRQL to its previous value, and return the previous
    // alerted state for the specified mode.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Alerted;
}

VOID
KeThawAllThreads (
    VOID
    )

/*++

Routine Description:

    This function resumes the execution of all suspended froozen threads
    in the current process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKPROCESS Process;
    PKTHREAD Thread;
    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    Process = KeGetCurrentThread()->ApcState.Process;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Thaw the execution of all threads in the current process that have
    // been frozzen.
    //

    ListHead = &Process->ThreadListHead;
    NextEntry = ListHead->Flink;
    do {

        //
        // Get the address of the next thread and thaw its execution if
        // if was previously froozen.
        //

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        OldCount = Thread->FreezeCount;
        if (OldCount != 0) {
            Thread->FreezeCount -= 1;

            //
            // If the resultant suspend count is zero and the freeze count is
            // zero, then resume the thread by releasing its suspend semaphore.
            //

            if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
                Thread->SuspendSemaphore.Header.SignalState += 1;
                KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
            }
        }

        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Unlock dispatcher database from SYNCH_LEVEL, unlock the process lock
    // and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    KeLeaveCriticalRegion();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\thredsup.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    thredsup.c

Abstract:

    This module contains the support routines for the thread object. It
    contains functions to boost the priority of a thread, find a ready
    thread, select the next thread, ready a thread, set priority of a
    thread, and to suspend a thread.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    All of the functions in this module execute in kernel mode except
    the function that raises a user mode alert condition.

Revision History:

--*/

#include "ki.h"

//
// Define context switch data collection macro.
//

//#define _COLLECT_SWITCH_DATA_ 1

#if defined(_COLLECT_SWITCH_DATA_)

#define KiIncrementSwitchCounter(Member) KeThreadSwitchCounters.Member += 1

#else

#define KiIncrementSwitchCounter(Member)

#endif

VOID
KiSuspendNop (
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC for a
    thread. It is executed in kernel mode as the result of queuing the
    builtin suspend APC and performs no operation. It is called just prior
    to calling the normal routine and simply returns.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    NormalRoutine - not used

    NormalContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{

    //
    // No operation is performed by this routine.
    //

    return;
}

VOID
KiSuspendRundown (
    IN PKAPC Apc
    )

/*++

Routine Description:

    This function is the rundown routine for the threads built in suspend APC.
    No operation is performed.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.


Return Value:

    None.

--*/

{

    return;
}

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN ULONG ProcessorNumber,
    IN KPRIORITY LowPriority
    )

/*++

Routine Description:

    This function searches the dispatcher ready queues from the specified
    high priority to the specified low priority in an attempt to find a thread
    that can execute on the specified processor.

Arguments:

    Processor - Supplies the number of the processor to find a thread for.

    LowPriority - Supplies the lowest priority dispatcher ready queue to
        examine.

Return Value:

    If a thread is located that can execute on the specified processor, then
    the address of the thread object is returned. Otherwise a null pointer is
    returned.

--*/

{

    ULONG HighPriority;
    PRLIST_ENTRY ListHead;
    PRLIST_ENTRY NextEntry;
    ULONG PrioritySet;
    KAFFINITY ProcessorSet;
    PKTHREAD Thread;
    PKTHREAD Thread1;
    PKTHREAD Thread2 = NULL;
    ULONG WaitLimit;
    CCHAR Processor;

    //
    // Compute the set of priority levels that should be scanned in an attempt
    // to find a thread that can run on the specified processor.
    //

    Processor = (CCHAR)ProcessorNumber;
    PrioritySet = (~((1 << LowPriority) - 1)) & KiReadySummary;

#if !defined(NT_UP)

    ProcessorSet = AFFINITY_MASK(Processor);
    WaitLimit = KiQueryLowTickCount() - (READY_SKIP_QUANTUM + 1);

#endif

    KeFindFirstSetLeftMember(PrioritySet, &HighPriority);
    ListHead = &KiDispatcherReadyListHead[HighPriority];
    PrioritySet <<= (31 - HighPriority);
    while (PrioritySet != 0) {

        //
        // If the next bit in the priority set is a one, then examine the
        // corresponding dispatcher ready queue.
        //

        if ((LONG)PrioritySet < 0) {
            NextEntry = ListHead->Flink;

            ASSERT(NextEntry != ListHead);

#if defined(NT_UP)

            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(&Thread->WaitListEntry);
            if (IsListEmpty(ListHead)) {
                ClearMember(HighPriority, KiReadySummary);
            }

            return Thread;

#else

            //
            // Scan the specified dispatcher ready queue for a suitable
            // thread to execute.
            //

            while (NextEntry != ListHead) {
                Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
                NextEntry = NextEntry->Flink;
                if (Thread->Affinity & ProcessorSet) {

                    //
                    // If the found thread ran on the specified processor
                    // last, the processor is the ideal processor for the
                    // thread, the thread has been waiting for longer than
                    // a quantum, or its priority is greater than low realtime
                    // plus 8, then the selected thread is returned. Otherwise,
                    // an attempt is made to find a more appropriate thread.
                    //

                    if ((Thread->IdealProcessor != Processor) &&

#if defined(KE_MULTINODE)

                        (!((Thread->NextProcessor == Processor) &&
                           ((Thread->SoftAffinity & ProcessorSet) != 0))) &&

#else

                        (Thread->NextProcessor != Processor) &&

#endif

                        (WaitLimit < Thread->WaitTime) &&
                        (HighPriority < (LOW_REALTIME_PRIORITY + 9))) {

                        //
                        // Search forward in the ready queue until the end
                        // of the list is reached or a more appropriate
                        // thread is found.
                        //

                        while (NextEntry != ListHead) {
                            Thread1 = CONTAINING_RECORD(NextEntry,
                                                        KTHREAD,
                                                        WaitListEntry);

                            NextEntry = NextEntry->Flink;
                            if ((Thread1->Affinity & ProcessorSet) == 0) {
                                continue;
                            }

                            if ((Thread1->IdealProcessor == Processor) ||
                                (Thread1->NextProcessor == Processor)) {

                                    //
                                    // This thread is a better choice than
                                    // the first one but, if this is a multi
                                    // node configuration, and this thread
                                    // isn't on it's prefered node, see if
                                    // there is a better choice.
                                    //

#if defined(KE_MULTINODE)

                                    if (Thread1->SoftAffinity & ProcessorSet) {
                                        Thread = Thread1;
                                        break;
                                    }

                                    //
                                    // Not on preferred node, only update
                                    // "Thread" if this is the first possible.
                                    //

                                    if (Thread2 == NULL) {
                                        Thread2 = Thread1;
                                        Thread = Thread1;
                                    }

#else

                                    Thread = Thread1;
                                    break;

#endif

                            }

                            if (WaitLimit >= Thread1->WaitTime) {

                                //
                                // This thread has been ready without
                                // running for too long, select it.
                                //

                                Thread = Thread1;
                                break;
                            }
                        }
                    }

#if defined(_COLLECT_SWITCH_DATA_)

                    if (Processor == Thread->IdealProcessor) {
                        KiIncrementSwitchCounter(FindIdeal);

                    } else if (Processor == Thread->NextProcessor) {
                        KiIncrementSwitchCounter(FindLast);

                    } else {
                        KiIncrementSwitchCounter(FindAny);
                    }

#endif

                    Thread->NextProcessor = Processor;
                    RemoveEntryList(&Thread->WaitListEntry);
                    if (IsListEmpty(ListHead)) {
                        ClearMember(HighPriority, KiReadySummary);
                    }

                    return Thread;
                }
            }

#endif

        }

        HighPriority -= 1;
        ListHead -= 1;
        PrioritySet <<= 1;
    };

    //
    // No thread could be found, return a null pointer.
    //

    return NULL;
}

VOID
FASTCALL
KiReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution and attempts to immediately
    dispatch the thread for execution by preempting another lower priority
    thread. If a thread can be preempted, then the specified thread enters
    the standby state and the target processor is requested to dispatch. If
    another thread cannot be preempted, then the specified thread is inserted
    either at the head or tail of the dispatcher ready selected by its priority
 