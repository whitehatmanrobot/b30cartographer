one or more event handles were passed in.
//
//----------------------------------------------------------------------------

DWORD
CScriptHost::MessageEventPump(BOOL    fWait,
                              UINT    cEvents   /* = 0        */,
                              HANDLE *pEvents   /* = NULL     */,
                              BOOL    fAll      /* = FALSE    */,
                              DWORD   dwTimeout /* = INFINITE */,
                              BOOL    fNoEvents /* = FALSE    */)
{
    CStackPtrAry<HANDLE, 5> aryHandles;

    MSG   msg;
    DWORD dwRet;
    DWORD mepReturn = MEP_FALLTHROUGH;

    _int64 i64Freq = 0;
    _int64 i64Time;
    _int64 i64Goal  = 0;
    long   lTimeout = dwTimeout;
    BOOL   fTimeout = dwTimeout != INFINITE;

    if (cEvents)
    {
        aryHandles.CopyIndirect(cEvents, pEvents, FALSE);
    }

    if (_fMustExitThread)
    {
        return MEP_EXIT;
    }

    // WARNING! aryHandles will get rebuilt under certain conditions below.
    // If you add code which adds handles to the array, you must update the
    // code below as well!

    if (!fNoEvents && !_fDontHandleEvents)
    {
        aryHandles.Insert(0, _hCommEvent);
    }
    else if (fNoEvents)
    {
        _fDontHandleEvents = TRUE;
    }

    if (fTimeout)
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&i64Freq);
        QueryPerformanceCounter((LARGE_INTEGER*)&i64Time);

        // Resolution must be at least milliseconds
        Assert(i64Freq >= 1000);

        // Compute the time when the timer will be complete, converted to ms
        i64Goal = ((i64Time * 1000) / i64Freq) + lTimeout;
    }

    do
    {
        //
        // Purge out all window messages (primarily for OLE's benefit).
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                _fMustExitThread = TRUE;
                return MEP_EXIT;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        if (_fMustExitThread)
        {
            AbortScripts();
            return MEP_EXIT;
        }

        dwRet = MsgWaitForMultipleObjects(aryHandles.Size(),
                                          aryHandles,
                                          FALSE,
                                          (fWait) ? (DWORD)lTimeout : 0,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0 && !_fDontHandleEvents)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet < WAIT_OBJECT_0 + aryHandles.Size())
        {
            Assert(cEvents);

            int iEvent = dwRet - WAIT_OBJECT_0;

            //
            // One of the events the script is waiting for has been signaled.
            //
            if (fAll)
            {
                // They want to wait for all the events. Remove the signaled
                // event from the array and if it's the last one then we're
                // there!

                aryHandles.Delete(iEvent);

                if (aryHandles.Size() == ((_fDontHandleEvents) ? 0 : 1))
                {
                    // All the events have come back signaled. Check that none
                    // have become unsignaled.
                    if (WaitForMultipleObjects(cEvents, pEvents, TRUE, 0) == WAIT_TIMEOUT)
                    {
                        // Something became unsignaled. Start over! Rebuild
                        // the array of handles.

                        aryHandles.CopyIndirect(cEvents, pEvents, FALSE);

                        if (!_fDontHandleEvents)
                        {
                            aryHandles.Insert(0, _hCommEvent);
                        }
                    }
                    else
                    {
                        mepReturn = MEP_EVENT_0;

                        break;
                    }
                }
            }
            else
            {
                mepReturn = MEP_EVENT_0 + iEvent;

                if (!_fDontHandleEvents)
                {
                    mepReturn--;
                }

                break;
            }
        }
        else if (dwRet == WAIT_OBJECT_0 + aryHandles.Size())
        {
            //
            // A windows message came through. It will be handled at the
            // top of the loop.
            //
        }
        else if (dwRet == WAIT_FAILED)
        {
            TraceTag((tagError, "WaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "WaitForMultipleObjects failure");

            _fMustExitThread = TRUE;

            mepReturn = MEP_EXIT;

            break;
        }
        else
        {
            Assert(dwRet == WAIT_TIMEOUT);

            mepReturn = MEP_TIMEOUT;

            break;
        }

        // Since any number of things could have brought us out of MWFMO,
        // we need to compute the remaining timeout for the next time around.

        if (fTimeout)
        {
            QueryPerformanceCounter((LARGE_INTEGER*)&i64Time);

            // Convert current time to milliseconds.
            i64Time = ((i64Time * 1000) / i64Freq);

            // Compute the delta between the current time and our goal
            lTimeout = (DWORD)(i64Goal - i64Time);

            // Are we timed out?
            if (lTimeout <= 0)
            {
                mepReturn = MEP_TIMEOUT;

                break;
            }
        }
    }
    while (fWait);  // Only do the loop once if fWait == FALSE

    if (fNoEvents)
    {
        _fDontHandleEvents = FALSE;
    }

    // MEP_FALLTHROUGH is not a valid return if fWait == TRUE
    Assert(!fWait || mepReturn != MEP_FALLTHROUGH);

    return mepReturn;
}

void
CScriptHost::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    if (_fDontHandleEvents)
        return;

    //
    //$ FUTURE: Add a way to filter messages so we can check for MD_PLEASEEXIT
    // without pulling off the event messages
    //
    while (GetNextMsg(&tm, (void **)bData, &cbData))
    {
        switch (tm)
        {
        case MD_PLEASEEXIT:
            //
            // We're being asked to terminate.
            //
            AbortScripts();
            PostQuitMessage(0);
            break;

        case MD_MACHINECONNECT:
            AssertSz(_fIsPrimaryScript, "Non-primary script got machine event!");

            _fDontHandleEvents = TRUE;

            FireEvent(DISPID_MTScript_OnMachineConnect, 0, NULL);

            _fDontHandleEvents = FALSE;
            break;

        case MD_MACHEVENTCALL:
            AssertSz(_fIsPrimaryScript, "Non-primary script got machine event!");
            Assert(cbData == sizeof(MACHPROC_EVENT_DATA*));

            _fDontHandleEvents = TRUE;

            // This call will set the event object in the
            // MACHPROC_EVENT_DATA struct when everything completes.
            FireMachineEvent(*(MACHPROC_EVENT_DATA**)bData, TRUE);

            _fDontHandleEvents = FALSE;
            break;

        case MD_PROCESSDATA:
            Assert(cbData == sizeof(MACHPROC_EVENT_DATA*));

            _fDontHandleEvents = TRUE;

            // This call will set the event object in the
            // MACHPROC_EVENT_DATA struct when everything completes.
            FireMachineEvent(*(MACHPROC_EVENT_DATA**)bData, FALSE);

            _fDontHandleEvents = FALSE;
            break;

        case MD_PROCESSEXITED:
        case MD_PROCESSTERMINATED:
        case MD_PROCESSCONNECTED:
        case MD_PROCESSCRASHED:
            Assert(cbData == sizeof(CProcessThread*));

            _fDontHandleEvents = TRUE;

            FireProcessEvent(tm, *(CProcessThread**)bData);

            _fDontHandleEvents = FALSE;

            break;

        default:
            AssertSz(FALSE, "CScriptHost got a message it couldn't handle!");
            break;
        }
    }
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::PushScript
//
//  Create a new script site/engine and push it on the script stack
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::PushScript(TCHAR *pchName)
{
    VERIFY_THREAD();

    HRESULT hr;
    CScriptSite * pScriptSite;
    TCHAR       * pchFile;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    pScriptSite = new CScriptSite(this);
    if(!pScriptSite)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pchFile = _tcsrchr(pchName, _T('\\'));
    if (!pchFile)
    {
        pchFile = pchName;
    }
    else
        pchFile++;

    hr = pScriptSite->Init(pchFile);
    if (hr)
    {
        delete pScriptSite;
        pScriptSite = NULL;
        goto Cleanup;
    }

    pScriptSite->_pScriptSitePrev = _pScriptSite;
    _pScriptSite = pScriptSite;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::PopScript
//
//  Pop last script site/engine off the script stack
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::PopScript()
{
    VERIFY_THREAD();

    CScriptSite * pScriptSite = _pScriptSite;

    if(!_pScriptSite)
        return S_FALSE;

    _pScriptSite = _pScriptSite->_pScriptSitePrev;

    pScriptSite->Close();
    pScriptSite->Release();

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member: CScriptHost::CloseScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::CloseScripts()
{
    VERIFY_THREAD();

    while(PopScript() == S_OK)
        ;

    AssertSz(_pScriptSite == NULL, "Should have released script site");

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::AbortScripts
//
//  Clear the stack of script engines
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::AbortScripts()
{
    VERIFY_THREAD();

    // Make sure we're not stuck on MsgWaitForMultipleObjects and that we
    //   never will be again.

    _fMustExitThread = TRUE;
    SetEvent(_hCommEvent);

    CScriptSite * pScriptSite;

    pScriptSite = _pScriptSite;

    while (pScriptSite)
    {
        pScriptSite->Abort();

        pScriptSite = pScriptSite->_pScriptSitePrev;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::ExecuteTopLevelScript
//
//  Close previous top level script engine then load and execute script
//  in a new top level script engine
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::ExecuteTopLevelScript(TCHAR * pchPath, VARIANT *pvarParams)
{
    VERIFY_THREAD();

    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    // Getting read to close the scripts fire unload event.
    CloseScripts();

    hr = THR(PushScript(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(VariantCopy(&_pScriptSite->_varParam, pvarParams));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->ExecuteScriptFile(pchPath));
    if(hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

Cleanup:
    Release();
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::ExecuteScriptlet
//
//  Add a scriptlet to the current top level script engine and execute it
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::ExecuteTopLevelScriptlet(TCHAR * pchScript)
{
    VERIFY_THREAD();

    HRESULT hr;

    // Stablize reference count during script execution.
    // Script can hide window which decrements reference count.

    AddRef();

    if(!_pScriptSite)
    {
        hr = THR(PushScript(_T("Scriptlet")));
        if(hr)
            goto Cleanup;
    }
    else
    {
        Assert(_pScriptSite->_pScriptSitePrev == NULL);
    }

    hr = THR(_pScriptSite->ExecuteScriptStr(pchScript));
    if (hr)
        goto Cleanup;

    hr = THR(_pScriptSite->SetScriptState(SCRIPTSTATE_CONNECTED));

Cleanup:
    Release();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptHost::FireProcessEvent, public
//
//  Synopsis:   Fires an OnProcessEvent event into the script
//
//----------------------------------------------------------------------------

void
CScriptHost::FireProcessEvent(THREADMSG tm, CProcessThread *pProc)
{
    VARIANTARG  varg[3];
    TCHAR      *pszMsg;
    DISPID      dispid = DISPID_MTScript_OnProcessEvent;

    VERIFY_THREAD();

    VariantInit(&varg[0]);
    VariantInit(&varg[1]);
    VariantInit(&varg[2]);

    // Parameters are in order from last to first

    V_VT(&varg[2]) = VT_I4;
    V_I4(&varg[2]) = pProc->ProcId();

    switch (tm)
    {
    case MD_PROCESSEXITED:
        pszMsg = _T("exited");

        V_VT(&varg[0]) = VT_I4;
        V_I4(&varg[0]) = pProc->GetExitCode();
        break;

    case MD_PROCESSCRASHED:
        pszMsg = _T("crashed");

        // 3rd parameter is empty
        break;

    case MD_PROCESSTERMINATED:
        pszMsg = _T("terminated");

        // 3rd parameter is empty
        break;

    case MD_PROCESSCONNECTED:
        pszMsg = _T("connected");

        // 3rd parameter is empty
        break;

    default:
        AssertSz(FALSE, "NONFATAL: Invalid THREADMSG value");
        return;
        break;
    }

    V_VT(&varg[1])   = VT_BSTR;
    V_BSTR(&varg[1]) = SysAllocString(pszMsg); // NULL is a valid value for BSTR

    FireEvent(dispid, 3, varg);

    VariantClear(&varg[0]);
    VariantClear(&varg[1]);
    VariantClear(&varg[2]);

    return;
}

long CScriptHost::FireScriptErrorEvent(
                                        TCHAR *bstrFile,
                                        long nLine,
                                        long nChar,
                                        TCHAR *bstrText,
                                        long sCode,
                                        TCHAR *bstrSource,
                                        TCHAR *bstrDescription)
{
    long      cSucceeded = 0;

    VERIFY_THREAD();

    // Parameters are in order from last to first
    AutoVariant varg[7];
    cSucceeded += varg[6].Set(bstrFile);
    cSucceeded += varg[5].Set(nLine);
    cSucceeded += varg[4].Set(nChar);
    cSucceeded += varg[3].Set(bstrText);
    cSucceeded += varg[2].Set(sCode);
    cSucceeded += varg[1].Set(bstrSource);
    cSucceeded += varg[0].Set(bstrDescription);

    if (cSucceeded != ARRAY_SIZE(varg))
        return 0; // Default return value

    AutoVariant varResult;
    FireEvent(DISPID_MTScript_OnScriptError, ARRAY_SIZE(varg), varg, &varResult);
    AutoVariant varResultInt;
    if (VariantChangeType(&varResultInt, &varResult, 0, VT_I4) == S_OK)
        return  V_I4(&varResultInt);

    return 0;
}
//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireMachineEvent
//
//  Notes:  Fires the OnRemoteExec event when a machine connected to us
//          remotely calls the Exec() method.
//
//---------------------------------------------------------------------------

void
CScriptHost::FireMachineEvent(MACHPROC_EVENT_DATA *pmed, BOOL fExec)
{

    VERIFY_THREAD();

    DISPID      dispid = (fExec)
                           ? DISPID_MTScript_OnRemoteExec
                           : DISPID_MTScript_OnProcessEvent;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    VARIANTARG  vararg[3];
    VARIANTARG  varResult;
    HRESULT     hr = S_OK;

    pmed->hrReturn = S_OK;

    if (GetSite() && GetSite()->_pDispSink)
    {
        VariantInit(&vararg[0]);
        VariantInit(&vararg[1]);
        VariantInit(&vararg[2]);
        VariantInit(&varResult);

        // Params are in order from last to first in the array
        V_VT(&vararg[0]) = VT_BSTR;
        V_BSTR(&vararg[0]) = pmed->bstrParams;

        V_VT(&vararg[1]) = VT_BSTR;
        V_BSTR(&vararg[1]) = pmed->bstrCmd;

        if (!fExec)
        {
            V_VT(&vararg[2]) = VT_I4;
            V_I4(&vararg[2]) = pmed->dwProcId;
        }

        dp.rgvarg            = vararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = (fExec) ? 2 : 3;
        dp.cNamedArgs        = 0;

        hr = GetSite()->_pDispSink->Invoke(dispid,
                                           IID_NULL,
                                           0,
                                           DISPATCH_METHOD,
                                           &dp,
                                           &varResult,
                                           &ei,
                                           &uArgErr);
        pmed->hrReturn = hr;

        if (hr)
        {
            // If an error occurred, do nothing except return the error code.
        }
        // Check for data types which we don't support.
        else if (   V_ISBYREF(&varResult)
                 || V_ISARRAY(&varResult)
                 || V_ISVECTOR(&varResult)
                 || V_VT(&varResult) == VT_UNKNOWN)
        {
            // Do nothing. Return an empty result
            AssertSz(FALSE, "NONFATAL: Unsupported data type returned from OnRemoteExec event");
        }
        else if (V_VT(&varResult) == VT_DISPATCH)
        {
            if (fExec)
            {
                // Note that the return value is an IDispatch, but don't set the
                // pointer because it will need to be retrieved out of the GIT
                V_VT(pmed->pvReturn)       = VT_DISPATCH;
                V_DISPATCH(pmed->pvReturn) = NULL;

                hr =_pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&varResult),
                                                           IID_IDispatch,
                                                           &pmed->dwGITCookie);
                if (hr)
                {
                    pmed->hrReturn = hr;
                }
            }

            // Leave the result empty if they returned an IDispatch from an
            //   OnProcessEvent call.
        }
        else
        {
            VariantCopy(pmed->pvReturn, &varResult);
        }

        VariantClear(&varResult);
    }

    // Tell the calling thread we're done with the call and it can continue.
    SetEvent(pmed->hEvent);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, UINT cArg, VARIANTARG *pvararg, VARIANTARG *pvarResult)
{
    VERIFY_THREAD();

    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;

    if (GetSite() && GetSite()->_pDispSink)
    {
        dp.rgvarg            = pvararg;
        dp.rgdispidNamedArgs = NULL;
        dp.cArgs             = cArg;
        dp.cNamedArgs        = 0;

        GetSite()->_pDispSink->Invoke(
                dispid,
                IID_NULL,
                0,
                DISPATCH_METHOD,
                &dp,
                pvarResult,
                &ei,
                &uArgErr);
    }
}

void
CScriptHost::FireEvent(DISPID dispid, UINT carg, VARIANTARG *pvararg)
{
    FireEvent(dispid, carg, pvararg, NULL);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, LPCTSTR pch)
{
    VERIFY_THREAD();

    VARIANT var;

    V_BSTR(&var) = SysAllocString(pch);
    V_VT(&var) = VT_BSTR;
    FireEvent(dispid, 1, &var);
    SysFreeString(V_BSTR(&var));
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, BOOL fArg)
{
    VERIFY_THREAD();

    VARIANT var;

    V_BOOL(&var) = fArg ? VARIANT_TRUE : VARIANT_FALSE;
    V_VT(&var) = VT_BOOL;
    FireEvent(dispid, 1, &var);
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::FireEvent
//
//---------------------------------------------------------------------------

void
CScriptHost::FireEvent(DISPID dispid, IDispatch *pDisp)
{
    VERIFY_THREAD();

    VARIANT var;

    V_DISPATCH(&var) = pDisp;
    V_VT(&var) = VT_DISPATCH;
    FireEvent(dispid, 1, &var);
}

HRESULT
CScriptHost::LoadTypeLibrary()
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    if (!_pTypeLibEXE)
    {
        // BUGBUG -- Is this valid, or does this need to be marshalled?

        _pTypeLibEXE = _pMT->_pTypeLibEXE;
    }

    if (!_pTypeInfoCMTScript)
    {
        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(CLSID_LocalMTScript, &_pTypeInfoCMTScript));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoIGlobalMTScript)
    {
        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(IID_IGlobalMTScript, &_pTypeInfoIGlobalMTScript));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}

void
CScriptHost::GetScriptPath(CStr *pcstrPath)
{
    _pMT->_options.GetScriptPath(pcstrPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\evtsink.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       evtsink.cxx
//
//  Contents:   Implementation of the CScriptEventSink class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

CScriptEventSink::CScriptEventSink(CScriptHost *pSH)
{
    _pSH = pSH;
    _ulRefs = 1;

    Assert(_dwSinkCookie == 0);
}

CScriptEventSink::~CScriptEventSink()
{
    Disconnect();
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptEventSink::Connect, public
//
//  Synopsis:   Connects to event interface on the source object
//
//  Arguments:  [pSource] -- Object to sink events from
//
//  Returns:    HRESULT
//
//              TODO: This method should be more generic and walk through
//              the object's typeinfo looking for the default source
//              interface.
//
//----------------------------------------------------------------------------

HRESULT
CScriptEventSink::Connect(IDispatch *pSource, BSTR bstrProgID)
{
    HRESULT      hr = S_OK;

    IConnectionPointContainer *pCPC;
    IConnectionPoint          *pCP = 0;

    _pDispSource = pSource;

    pSource->AddRef();

    hr = _pDispSource->QueryInterface(IID_IConnectionPointContainer,
                                      (LPVOID*)&pCPC);
    if (!hr)
    {
        if (bstrProgID && SysStringLen(bstrProgID) > 0)
            hr = CLSIDFromProgID(bstrProgID, &_clsidEvents);
        else
            _clsidEvents = DIID_DRemoteMTScriptEvents;

        if (hr == S_OK)
            hr = pCPC->FindConnectionPoint(_clsidEvents, &pCP);

        if (!hr)
        {
            hr = pCP->Advise(this, &_dwSinkCookie);

            ReleaseInterface(pCP);
        }

        ReleaseInterface(pCPC);

#if DBG == 1
        if (hr)
            TraceTag((tagError, "Hookup to event sink returned %x", hr));
#endif
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptEventSink::Disconnect, public
//
//  Synopsis:   Disconnects from a machine we connected to via Connect().
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

void
CScriptEventSink::Disconnect()
{
    HRESULT hr = S_OK;

    if (_dwSinkCookie && _pDispSource)
    {
        IConnectionPointContainer *pCPC;
        IConnectionPoint          *pCP;

        hr = _pDispSource->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC);
        if (!hr)
        {
            hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents,
                                           &pCP);
            if (!hr)
            {
                pCP->Unadvise(_dwSinkCookie);

                ReleaseInterface(pCP);
            }

            ReleaseInterface(pCPC);

#if DBG == 1
            if (hr)
                TraceTag((tagError, "Unadvise from event sink returned %x", hr));
#endif
        }

        _dwSinkCookie = 0;
    }

    ClearInterface(&_pDispSource);

    _pSH = NULL;
}

// *************************************************************************
//
// CScriptEventSink
//
// Class which implements the event sink for the remote object. We only pay
// attention to Invoke calls.
//
// *************************************************************************

HRESULT
CScriptEventSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || 
        iid == IID_IDispatch || 
        iid == _clsidEvents)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 0;

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::GetIDsOfNames(REFIID riid,
                            LPOLESTR * rgszNames,
                            UINT cNames,
                            LCID lcid,
                            DISPID * rgdispid)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptEventSink::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptEventSink::Invoke(DISPID dispidMember,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS * pdispparams,
                         VARIANT * pvarResult,
                         EXCEPINFO * pexcepinfo,
                         UINT * puArgErr)
{
    if (_pSH && _pSH->GetSite() && _pSH->GetSite()->_pDispSink)
    {
        DISPPARAMS dp;
        VARIANTARG varg[20];

        // We need to tack on 2 parameters to the call. First is the object
        // that is firing the event. Second is the dispatch ID.
        // We put them on the end of the list, which means they become
        // the first and second parameters to the event.

        if (pdispparams->cArgs > ARRAY_SIZE(varg) - 2)
        {
            AssertSz(FALSE, "NONFATAL: Too many parameters to event (max==18)!");
            return E_FAIL;
        }

        dp.cArgs = pdispparams->cArgs + 2;
        dp.cNamedArgs = pdispparams->cNamedArgs;
        dp.rgdispidNamedArgs = pdispparams->rgdispidNamedArgs;

        memcpy(varg, pdispparams->rgvarg, pdispparams->cArgs * sizeof(VARIANTARG));

        V_VT(&varg[dp.cArgs-1]) = VT_DISPATCH;
        V_DISPATCH(&varg[dp.cArgs-1]) = _pDispSource;

        V_VT(&varg[dp.cArgs-2]) = VT_I4;
        V_I4(&varg[dp.cArgs-2]) = dispidMember;

        dp.rgvarg = varg;

        return _pSH->GetSite()->_pDispSink->Invoke(
                                  DISPID_MTScript_OnEventSourceEvent,
                                  IID_NULL,
                                  lcid,
                                  DISPATCH_METHOD,
                                  &dp,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\smtp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       smtp.cxx
//
//  Contents:   Contains the command to send SMTP mail
//
//              Stolen from KrisK's mail.exe tool.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include <iostream.h>
#include <winsock2.h>

HRESULT
CScriptHost::SendSMTPMail(BSTR  bstrFrom,
                          BSTR  bstrTo,
                          BSTR  bstrCC,
                          BSTR  bstrSubject,
                          BSTR  bstrMessage,
                          BSTR  bstrSMTPHost,
                          long *plError)
{
    char                  achRecvBuf[2048];
    unsigned short        port = 25;
    struct sockaddr_in    Ser;
    struct hostent *      hp;
    WSADATA               wsaData;
    SOCKET                conn_socket = INVALID_SOCKET;
    int                   iRet;
    int                   iLen;
    char                  achSendBuf[1024];
    char *                pch;
    char *                aszToList[30];
    int                   cToList = 0;
    char *                aszCCList[30];
    int                   cCCList = 0;
    SYSTEMTIME            stUT;
    int                   i;

    ANSIString szFrom(bstrFrom);
    ANSIString szTo(bstrTo);
    ANSIString szCC(bstrCC);
    ANSIString szSubject(bstrSubject);
    ANSIString szMessage(bstrMessage);
    ANSIString szSMTPHost(bstrSMTPHost);

    // ************** Parse the ToList into individual recipients
    pch = szTo;

    while (*pch && cToList < 30)
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pch))
        {
            *pch=0;
            pch++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            aszToList[cToList++] = pch;

            // Move beginning of string to next name in ToList.
            do
            {
                pch++;
            } while (isgraph(*pch));
        }
    }

    // Parse the CCList into individual recipients
    pch = szCC;

    // Parse CCList into rgRecipDescStruct.
    while (*pch && cCCList < 30)
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pch))
        {
            *pch=0;
            pch++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            aszCCList[cCCList++] = pch;

            // Move beginning of string to next name in CCList.
            do
            {
                pch++;
            } while (isgraph(*pch));
        }
    }

    // ************** Initialize Windows Sockets

    // BUGBUG -- Make error return code meaningful

    iRet = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iRet != 0)
    {
        *plError = iRet;
        return S_OK;
    }

    hp = gethostbyname(szSMTPHost);
    if (hp == NULL)
        goto WSAError;

    memset(&Ser,0,sizeof(Ser));
    memcpy(&(Ser.sin_addr),hp->h_addr,hp->h_length);

    Ser.sin_family = hp->h_addrtype;
    Ser.sin_port = htons(port);

    // Open a socket
    conn_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (conn_socket == INVALID_SOCKET)
        goto WSAError;

    // ************** Connect to the SMTP host

    iRet = connect(conn_socket, (struct sockaddr*)&Ser, sizeof(Ser));
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // Get the server's initial response
    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 220: "Service Ready"
    if (strncmp(achRecvBuf, "220", 3) != 0)
        goto ACKError;

    // ************** Send the mail command

    iLen = wsprintfA(achSendBuf, "MAIL FROM: <%s>\r\n", szFrom);
    iRet = send(conn_socket, achSendBuf, iLen, 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 250: "Requested mail action OK, completed"
    if (strncmp(achRecvBuf, "250", 3) != 0)
        goto ACKError;

    // ************** Send the recipient list (combination of TO and CC)

    for (i = 0; i < cToList; i++)
    {
        iLen = wsprintfA(achSendBuf, "RCPT TO: <%s>\r\n", aszToList[i]);

        iRet = send(conn_socket, achSendBuf, iLen, 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        // We expect code 250: "Requested mail action OK, completed"
        if (strncmp(achRecvBuf, "250", 3) != 0)
            goto ACKError;
    }

    for (i = 0; i < cCCList; i++)
    {
        iLen = wsprintfA(achSendBuf, "RCPT TO: <%s>\r\n", aszCCList[i]);

        iRet = send(conn_socket, achSendBuf, iLen, 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
        if (iRet == SOCKET_ERROR)
            goto WSAError;

        // We expect code 250: "Requested mail action OK, completed"
        if (strncmp(achRecvBuf, "250", 3) != 0)
            goto ACKError;
    }

    // ************** Send the mail headers

    iLen = wsprintfA(achSendBuf, "DATA\r\n");
    iRet = send(conn_socket, achSendBuf, iLen, 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 354: "Start mail input; End with ."
    if (strncmp(achRecvBuf, "354", 3) != 0)
        goto ACKError;

    GetSystemTime(&stUT);

    GetDateFormatA(LOCALE_NEUTRAL,
                   0,
                   &stUT,
                   "dd MMM yy",
                   achRecvBuf,
                   sizeof(achRecvBuf));

    wsprintfA(achSendBuf,
             "Date: %s %02d:%02d UT\r\n",
             achRecvBuf,
             stUT.wHour,
             stUT.wMinute);

    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    wsprintfA(achSendBuf, "From: <%s>\r\n", szFrom);

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "Subject: %s\r\n", szSubject);

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "To: ");

    for (i = 0; i < cToList; i++)
    {
        wsprintfA(&achSendBuf[strlen(achSendBuf)],
                 "<%s>%s",
                 aszToList[i],
                 (i == cToList-1) ? "\r\n" : ",\r\n ");
    }

    if (cCCList > 0)
    {
        wsprintfA(&achSendBuf[strlen(achSendBuf)], "cc: ", szFrom);

        for (i = 0; i < cCCList; i++)
        {
            wsprintfA(&achSendBuf[strlen(achSendBuf)],
                     "<%s>%s",
                     aszCCList[i],
                     (i == cCCList-1) ? "\r\n" : ",\r\n ");
        }
    }

    wsprintfA(&achSendBuf[strlen(achSendBuf)], "Reply-To: <%s>\r\n\r\n", szFrom);

/*
    BUGBUG -- Perhaps support HTML formatted mail in the future?
    if ( html )
            str += "MIME-Version: 1.0\r\nContent-Type: text/html;\r\n       charset=\"iso-8859-1\"\r\nSUBJECT: "+ title + "\r\n\r\n"+ message +"\r\n.\r\n";
*/


    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // ************** Send the message body

    iRet = send(conn_socket, szMessage, strlen(szMessage), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // ************** Close the connection

    strcpy(achSendBuf, "\r\n.\r\n");

    iRet = send(conn_socket, achSendBuf, strlen(achSendBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    iRet = recv(conn_socket, achRecvBuf, sizeof(achRecvBuf), 0);
    if (iRet == SOCKET_ERROR)
        goto WSAError;

    // We expect code 250: "Requested mail action OK, completed"
    if (strncmp(achRecvBuf, "250", 3) != 0)
        goto ACKError;


    strcpy(achSendBuf, "QUIT\r\n");

    send(conn_socket, achSendBuf, strlen(achSendBuf), 0);

Cleanup:
    if (conn_socket != INVALID_SOCKET)
    {
        closesocket(conn_socket);
    }

    WSACleanup();

    return S_OK;

ACKError:
    // BUGBUG -- Preserve entire string that was returned
    achRecvBuf[3] = '\0';
    *plError = atoi(achRecvBuf);
    goto Cleanup;

WSAError:
    *plError = WSAGetLastError();

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scripts\makefile.inc ===
types.js: types.xml xmltypes.js
    cscript xmltypes.js //nologo > types.js
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\ssite.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       bsssite.hxx
//
//  Contents:   CBServerScriptSite
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#undef ASSERT

// ************************************************************************
//
// CConnectionPoint
//
// ************************************************************************

CConnectionPoint::CConnectionPoint(CScriptSite *pSite)
{
    _ulRefs = 1;
    _pSite = pSite;
    _pSite->AddRef();
}

CConnectionPoint::~CConnectionPoint()
{
    _pSite->Release();
}

HRESULT
CConnectionPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DLocalMTScriptEvents;
    return S_OK;
}

HRESULT
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pSite;
    (*ppCPC)->AddRef();
    return S_OK;
}

HRESULT
CConnectionPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    *pdwCookie = 0;

    ClearInterface(&_pSite->_pDispSink);
    RRETURN(THR(pUnkSink->QueryInterface(IID_IDispatch, (void **)&_pSite->_pDispSink)));
}

HRESULT
CConnectionPoint::Unadvise(DWORD dwCookie)
{
    ClearInterface(&_pSite->_pDispSink);
    return S_OK;
}

HRESULT
CConnectionPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// CScriptSite
//
// ************************************************************************

STDMETHODIMP
CScriptSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IGlobalMTScript || iid == IID_IDispatch)
    {
        *ppv = (IGlobalMTScript *)this;
    }
    else if (iid == IID_IActiveScriptSiteDebug)
    {
        *ppv = (IActiveScriptSiteDebug *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppv = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo ||
            iid == IID_IProvideClassInfo2 ||
            iid == IID_IProvideMultipleClassInfo)
    {
        *ppv = (IProvideMultipleClassInfo *)this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite constructor
//
//---------------------------------------------------------------------------

CScriptSite::CScriptSite(CScriptHost *pScriptHost)
    : _cstrName(CSTR_NOINIT)
{
    _pSH    = pScriptHost;
    _ulRefs = 1;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite destructor
//
//---------------------------------------------------------------------------

CScriptSite::~CScriptSite()
{
    VariantClear(&_varParam);
    ClearInterface(&_pDispSink);
    AssertSz(_ulRefs <= 1, "Object not properly released on destruction!");

    if (_pDDH)
    {
        _pDDH->Detach();
        ClearInterface(&_pDDH);
    }
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::AddRef, Release
//
//---------------------------------------------------------------------------

ULONG
CScriptSite::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}

ULONG
CScriptSite::Release()
{
    if (--_ulRefs == 0)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Init
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::Init(LPWSTR pszName)
{
    HRESULT hr;
    IActiveScriptParse *pParse = NULL;
    static const CLSID CLSID_JSCRIPT = { 0xf414c260, 0x6ac0, 0x11cf, 0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58};
    WCHAR  *pch;

    _cstrName.Set(pszName);

    hr = THR(ScriptHost()->_pMT->HackCreateInstance(CLSID_JSCRIPT,
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IActiveScript,
                                                    (void **)&_pScript));
    if (hr)
    {
        hr = THR(CoCreateInstance(CLSID_JSCRIPT,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IActiveScript,
                                  (void **)&_pScript));
    }

    if (hr)
        goto Cleanup;

    if (ScriptHost()->_pMT->_pPDM)
    {
        Assert(_pDDH == NULL);

        hr = ScriptHost()->_pMT->_pPDM->CreateDebugDocumentHelper(NULL, &_pDDH);
        if (SUCCEEDED(hr))
        {
            hr = THR(_pDDH->Init(ScriptHost()->_pMT->_pDA,
                                 _cstrName,
                                 _cstrName,
                                 0));
            if (hr)
                goto Cleanup;

            hr = THR(_pDDH->Attach((_pScriptSitePrev)
                                       ? _pScriptSitePrev->_pDDH
                                       : NULL));
            if (hr)
                goto Cleanup;
        }
    }

    for (pch = _cstrName; *pch; pch++)
    {
        if (*pch == L'.')
        {
            *pch = L'_';
        }
    }

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->InitNew());
    if (hr)
        goto Cleanup;

    hr = THR(_pScript->AddNamedItem(_cstrName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Close
//
//---------------------------------------------------------------------------

void
CScriptSite::Close()
{
    if (_pScript)
    {
        _pScript->Close();
        ClearInterface(&_pScript);
    }
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::Abort
//
//---------------------------------------------------------------------------

void
CScriptSite::Abort()
{
    if (_pScript)
    {
        HRESULT hr;

        hr = THR(_pScript->InterruptScriptThread(SCRIPTTHREADID_CURRENT,
                                                 NULL,
                                                 0));
    }
}


//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetClassInfo, IProvideClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetClassInfo(ITypeInfo **ppTypeInfo)
{
    HRESULT hr;

    hr = ScriptHost()->LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *ppTypeInfo = ScriptHost()->_pTypeInfoCMTScript;
    (*ppTypeInfo)->AddRef();

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetGUID, IProvideClassInfo2
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetGUID(DWORD dwGuidKind, GUID * pGUID)
{
    if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID)
    {
        *pGUID = DIID_DLocalMTScriptEvents;
    }
    else
    {
        return E_NOTIMPL;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetMultiTypeInfoCount, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------


HRESULT
CScriptSite::GetMultiTypeInfoCount(ULONG *pc)
{
    *pc = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member:     CScriptSite::GetInfoOfIndex, IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetInfoOfIndex(
    ULONG       itinfo,
    DWORD       dwFlags,
    ITypeInfo** pptinfoCoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    AssertSz(itinfo == 0, "itinfo == 0");

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        *pptinfoCoClass = ScriptHost()->_pTypeInfoCMTScript;
        (*pptinfoCoClass)->AddRef();
        if (pdwTIFlags)
            *pdwTIFlags = 0;
    }

    if (dwFlags & MULTICLASSINFO_GETNUMRESERVEDDISPIDS)
    {
        *pcdispidReserved = 100;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDPRIMARY)
    {
        *piidPrimary = IID_IGlobalMTScript;
    }

    if (dwFlags & MULTICLASSINFO_GETIIDSOURCE)
    {
        *piidSource = DIID_DLocalMTScriptEvents;
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------
HRESULT
CScriptSite::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_DLocalMTScriptEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CConnectionPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetLCID, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetLCID(LCID *plcid)
{
    return E_NOTIMPL;     // Use system settings
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetItemInfo, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetItemInfo(
      LPCOLESTR   pstrName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
            return E_INVALIDARG;
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
            return E_INVALIDARG;
        *ppunkItemOut = NULL;
    }

    if (!_wcsicmp(_cstrName, pstrName))
    {
        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            *pptinfoOut = ScriptHost()->_pTypeInfoCMTScript;
            (*pptinfoOut)->AddRef();
        }
        if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
        {
            *ppunkItemOut = (IGlobalMTScript *)this;
            (*ppunkItemOut)->AddRef();
        }
        return S_OK;
    }


    return TYPE_E_ELEMENTNOTFOUND;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::GetDocVersionString, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::GetDocVersionString(BSTR *pbstrVersion)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::RequestItems()
{
    return _pScript->AddNamedItem(_cstrName, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::RequestTypeLibs, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::RequestTypeLibs()
{
    return _pScript->AddTypeLib(LIBID_MTScriptEngine, 1, 0, 0);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnScriptTerminate, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnScriptTerminate(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo)
{
    // UNDONE: Put up error dlg here
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnStateChange, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
    // Don't care about notification
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnScriptError, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::OnScriptError(IActiveScriptError *pse)
{
    long        nScriptErrorResult = 0;
    BSTR        bstrLine = NULL;
    TCHAR *     pchDescription;
    TCHAR       achDescription[256];
    TCHAR       achMessage[1024];
    EXCEPINFO   ei;
    DWORD       dwSrcContext;
    ULONG       ulLine;
    LONG        ichError;
    HRESULT     hr;
    LONG        iRet = IDYES;

    TraceTag((tagError, "OnScriptError!"));

    if (ScriptHost()->_fMustExitThread)
    {
        return S_OK;
    }

    hr = THR(pse->GetExceptionInfo(&ei));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourcePosition(&dwSrcContext, &ulLine, &ichError));
    if (hr)
        goto Cleanup;

    hr = THR(pse->GetSourceLineText(&bstrLine));
    if (hr)
        hr = S_OK;  // Ignore this error, there may not be source available

    if (ei.bstrDescription)
    {
        pchDescription = ei.bstrDescription;
    }
    else
    {
        achDescription[0] = 0;
        FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                ei.scode,
                LANG_SYSTEM_DEFAULT,
                achDescription,
                ARRAY_SIZE(achDescription),
                NULL);
        pchDescription = achDescription;
    }

// First, lets format a message nice for OUTPUTDEBUGSTRING
    _snwprintf(achMessage, ARRAY_SIZE(achMessage),
        _T("Thread: %s")
        _T("File: %s ")
        _T("Line: %d ")
        _T("Char: %d ")
        _T("Text: %s ")
        _T("Scode: %x ")
        _T("Source: %s ")
        _T("Description: %s"),
        (LPTSTR)_cstrName,
        _achPath,
        (long)(ulLine + 1),
        (long)(ichError),
        bstrLine ? bstrLine : _T(""),
        ei.scode,
        ei.bstrSource ? ei.bstrSource : _T(""),
        pchDescription
        );
    achMessage[ARRAY_SIZE(achMessage) - 1] = 0;
    OUTPUTDEBUGSTRING(achMessage);
    //Assert(!_fInScriptError);
    if (!_fInScriptError)
    {
        _fInScriptError = true;
        nScriptErrorResult = _pSH->FireScriptErrorEvent(
                _achPath,
                ulLine + 1,
                ichError,
                bstrLine ? bstrLine : _T(""),
                ei.scode,
                ei.bstrSource ? ei.bstrSource : _T(""),
                pchDescription);
        _fInScriptError = false;
    }

    if (nScriptErrorResult == 0)
    {
        _snwprintf(achMessage, ARRAY_SIZE(achMessage),
            _T("Thread: %s\r\n")
            _T("File: %s\r\n")
            _T("Line: %d\r\n")
            _T("Char: %d\r\n")
            _T("Text: %s\r\n")
            _T("Scode: %x\r\n")
            _T("Source: %s\r\n")
            _T("Description: %s\r\n")
            _T("%s"),
            (LPTSTR)_cstrName,
            _achPath,
            (long)(ulLine + 1),
            (long)(ichError),
            bstrLine ? bstrLine : _T(""),
            ei.scode,
            ei.bstrSource ? ei.bstrSource : _T(""),
            pchDescription,
            ((_fInDebugError) ? _T("\r\nDo you wish to debug?\r\n") : _T(""))
            );
        achMessage[ARRAY_SIZE(achMessage) - 1] = 0;

        MSGBOXPARAMS mbp;
        memset(&mbp, 0, sizeof(mbp));
        mbp.cbSize = sizeof(mbp);
        //mbp.hwndOwner = ScriptHost()->_pDoc->_hwnd;
        mbp.hwndOwner = NULL;
        mbp.lpszText = achMessage;
        mbp.lpszCaption = _T("Script Error");
        mbp.dwStyle = MB_APPLMODAL | MB_ICONERROR | ((_fInDebugError) ? MB_YESNO : MB_OK);

        iRet = MessageBoxIndirect(&mbp);
    }
    if (nScriptErrorResult == 1)
        hr = S_FALSE;
Cleanup:
    if(ei.bstrSource)
        SysFreeString(ei.bstrSource);
    if(ei.bstrDescription)
        SysFreeString(ei.bstrDescription);
    if(ei.bstrHelpFile)
        SysFreeString(ei.bstrHelpFile);

    if (bstrLine)
        SysFreeString(bstrLine);

    RRETURN1((_fInDebugError && !hr && iRet == IDYES) ? S_FALSE : hr, S_FALSE);
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnEnterScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::OnEnterScript()
{
    // No need to do anything
    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::OnLeaveScript, IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::OnLeaveScript()
{
    // No need to do anything
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::GetWindow(HWND *phwndOut)
{
    //*phwndOut = ScriptHost()->_pDoc->_hwnd;
    *phwndOut = NULL;
    return S_OK;
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::EnableModeless, IActiveScriptSiteWindow
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::EnableModeless(BOOL fEnable)
{
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptSite::ExecuteScriptFile
//
//  Load and execute script file
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::ExecuteScriptFile(TCHAR *pchPath)
{
    HRESULT     hr;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cchFile;
    DWORD       cbRead;
    char *      pchBuf = 0;
    TCHAR *     pchBufWide = 0;
    TCHAR *     pchFile;

    // Attempt to find the file. First, we try to use the path as given. If
    // that doesn't work, then we prefix the script path and try to find it.

    GetFullPathName(pchPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);

    if (GetFileAttributes(_achPath) == 0xFFFFFFFF)
    {
        // The file apparently doesn't exist. Try pre-pending the ScriptPath
        // onto it.

        CStr cstrPath;

        ScriptHost()->GetScriptPath(&cstrPath);

        cstrPath.Append(L"\\");

        cstrPath.Append(pchPath);

        GetFullPathName(cstrPath, ARRAY_SIZE(_achPath), _achPath, &pchFile);
    }

    // Load script file

    hFile = CreateFile(_achPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    cchFile = GetFileSize(hFile, NULL);
    if (cchFile == 0xFFFFFFFF)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pchBuf = new char[cchFile + 1];
    pchBufWide = new TCHAR[cchFile + 1];
    if (!pchBuf || !pchBufWide)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!ReadFile(hFile, pchBuf, cchFile, &cbRead, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    pchBuf[cbRead] = 0;

    MultiByteToWideChar(CP_ACP, 0, pchBuf, -1, pchBufWide, cchFile + 1);

    if (_pDDH)
    {
        pchFile = wcsrchr(pchPath, L'\\');
        if (!pchFile)
        {
            pchFile = pchPath;
        }
        else
            pchFile++;

        hr = THR(_pDDH->SetLongName(_achPath));
        if (hr)
            goto Cleanup;

        hr = THR(_pDDH->AddUnicodeText(pchBufWide));
        if (hr)
            goto Cleanup;

        hr = THR(_pDDH->DefineScriptBlock(0,
                                          cchFile,
                                          _pScript,
                                          TRUE,
                                          &_dwSourceContext));
        //if (hr)
        //    goto Cleanup;
    }

    // Execute script

    hr = ExecuteScriptStr(pchBufWide);
    if(hr)
        goto Cleanup;


Cleanup:
    delete pchBuf;
    delete pchBufWide;
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::ExecuteScriptStr
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::ExecuteScriptStr(TCHAR * pchScript)
{
    HRESULT hr;
    IActiveScriptParse * pParse = NULL;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pParse));
    if (hr)
        goto Cleanup;

    hr = THR(pParse->ParseScriptText(pchScript, _cstrName, NULL, NULL, 0, 0, 0L, NULL, NULL));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pParse);
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
// Method:  CScriptSite::SetScriptState
//
//---------------------------------------------------------------------------

HRESULT
CScriptSite::SetScriptState(SCRIPTSTATE ss)
{
    return _pScript->SetScriptState(ss);
}

HRESULT
CScriptSite::GetDocumentContextFromPosition(DWORD dwSourceContext,
                                            ULONG uCharacterOffset,
                                            ULONG uNumChars,
                                            IDebugDocumentContext **ppsc)
{
    HRESULT hr;

    if (_pDDH)
    {
        ULONG ulStartPos;

        hr = _pDDH->GetScriptBlockInfo(dwSourceContext, NULL, &ulStartPos, NULL);
        if (hr)
            goto Cleanup;

        hr = _pDDH->CreateDebugDocumentContext(ulStartPos+uCharacterOffset,
                                               uNumChars,
                                               ppsc);
    }
    else
        hr = E_UNEXPECTED;

Cleanup:
    RRETURN(hr);
}

HRESULT
CScriptSite::GetApplication(IDebugApplication **ppda)
{
    *ppda = ScriptHost()->_pMT->_pDA;

    return (*ppda) ? S_OK : E_UNEXPECTED;
}

HRESULT
CScriptSite::GetRootApplicationNode(IDebugApplicationNode **ppdanRoot)
{
    if (!ScriptHost()->_pMT->_pDA || !_pDDH)
    {
        return E_UNEXPECTED;
    }

    return _pDDH->GetDebugApplicationNode(ppdanRoot);
}

HRESULT
CScriptSite::OnScriptErrorDebug(IActiveScriptErrorDebug *pErrorDebug,
                                BOOL *pfEnterDebugger,
                                BOOL *pfCallOnScriptErrorWhenContinuing)
{
    HRESULT hr;
    IActiveScriptError * pError;

    TraceTag((tagError, "OnScriptErrorDebug!"));

    *pfEnterDebugger = FALSE;
    *pfCallOnScriptErrorWhenContinuing = TRUE;

    if (ScriptHost()->_fMustExitThread)
    {
        return S_OK;
    }

    hr = pErrorDebug->QueryInterface(IID_IActiveScriptError, (LPVOID*)&pError);
    if (SUCCEEDED(hr))
    {
        _fInDebugError = TRUE;

        hr = OnScriptError(pError);

        _fInDebugError = FALSE;

        if (hr == S_FALSE)
        {
            *pfEnterDebugger = TRUE;
        }

        *pfCallOnScriptErrorWhenContinuing = TRUE;

        pError->Release();
    }

    return S_OK;
}


//---------------------------------------------------------------------------
//
// Method:  CScriptSite::xxx, IBServer
//
//          The implementation of IBServer passed to the script engine
//          cannot be the same as that of the CBServerDoc because this
//          causes a reference count loop with the script engine.
//
//---------------------------------------------------------------------------

HRESULT CScriptSite::GetTypeInfoCount(UINT FAR* pctinfo)
            { return ScriptHost()->GetTypeInfoCount(pctinfo); }
HRESULT CScriptSite::GetTypeInfo(
  UINT itinfo,
  LCID lcid,
  ITypeInfo FAR* FAR* pptinfo)
            { return ScriptHost()->GetTypeInfo(itinfo, lcid, pptinfo); }
HRESULT CScriptSite::GetIDsOfNames(
  REFIID riid,
  OLECHAR FAR* FAR* rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID FAR* rgdispid)
            { return ScriptHost()->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
HRESULT CScriptSite::Invoke(
  DISPID dispidMember,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS FAR* pdispparams,
  VARIANT FAR* pvarResult,
  EXCEPINFO FAR* pexcepinfo,
  UINT FAR* puArgErr)
            { return ScriptHost()->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }


HRESULT CScriptSite::get_PublicData(VARIANT *pvData)
            { return ScriptHost()->get_PublicData(pvData); }
HRESULT CScriptSite::put_PublicData(VARIANT vData)
            { return ScriptHost()->put_PublicData(vData); }
HRESULT CScriptSite::get_PrivateData(VARIANT *pvData)
            { return ScriptHost()->get_PrivateData(pvData); }
HRESULT CScriptSite::put_PrivateData(VARIANT vData)
            { return ScriptHost()->put_PrivateData(vData); }
HRESULT CScriptSite::ExitProcess()
            { return ScriptHost()->ExitProcess(); }
HRESULT CScriptSite::Restart()
            { return ScriptHost()->Restart(); }
HRESULT CScriptSite::get_LocalMachine(BSTR *pbstrName)
            { return ScriptHost()->get_LocalMachine(pbstrName); }
HRESULT CScriptSite::Include(BSTR bstrPath)
            { return ScriptHost()->Include(bstrPath); }
HRESULT CScriptSite::CallScript(BSTR Path, VARIANT *ScriptParam)
            { return ScriptHost()->CallScript(Path, ScriptParam); }
HRESULT CScriptSite::SpawnScript(BSTR Path, VARIANT *ScriptParam)
            { return ScriptHost()->SpawnScript(Path, ScriptParam); }
HRESULT CScriptSite::get_ScriptParam(VARIANT *ScriptParam)
            { return ScriptHost()->get_ScriptParam(ScriptParam); }
HRESULT CScriptSite::get_ScriptPath(BSTR *bstrPath)
            { return ScriptHost()->get_ScriptPath(bstrPath); }
HRESULT CScriptSite::CallExternal(BSTR bstrDLLName, BSTR bstrFunctionName, VARIANT *pParam, long *plRetVal)
            { return ScriptHost()->CallExternal(bstrDLLName, bstrFunctionName, pParam, plRetVal); }
HRESULT CScriptSite::ResetSync(const BSTR bstrName)
            { return ScriptHost()->ResetSync(bstrName); }
HRESULT CScriptSite::WaitForSync(BSTR bstrName, long nTimeout, VARIANT_BOOL *pfTimedout)
            { return ScriptHost()->WaitForSync(bstrName, nTimeout, pfTimedout); }
HRESULT CScriptSite::WaitForMultipleSyncs(const BSTR bstrNameList, VARIANT_BOOL fWaitForAll, long nTimeout, long *plSignal)
            { return ScriptHost()->WaitForMultipleSyncs(bstrNameList, fWaitForAll, nTimeout, plSignal); }
HRESULT CScriptSite::SignalThreadSync(BSTR bstrName)
            { return ScriptHost()->SignalThreadSync(bstrName); }
HRESULT CScriptSite::TakeThreadLock(BSTR bstrName)
            { return ScriptHost()->TakeThreadLock(bstrName); }
HRESULT CScriptSite::ReleaseThreadLock(BSTR bstrName)
            { return ScriptHost()->ReleaseThreadLock(bstrName); }
HRESULT CScriptSite::DoEvents()
            { return ScriptHost()->DoEvents(); }
HRESULT CScriptSite::MessageBoxTimeout(BSTR msg, long cBtn, BSTR btnText, long time, long intrvl, VARIANT_BOOL cancel, VARIANT_BOOL confirm, long *plSel)
            { return ScriptHost()->MessageBoxTimeout(msg, cBtn, btnText, time, intrvl, cancel, confirm, plSel); }
HRESULT CScriptSite::RunLocalCommand(BSTR bstrCmd, BSTR bstrDir, BSTR bstrTitle, VARIANT_BOOL fMin, VARIANT_BOOL fGetOut, VARIANT_BOOL fWait, VARIANT_BOOL fNoPopup, VARIANT_BOOL fNoEnviron, long *plError)
            { return ScriptHost()->RunLocalCommand(bstrCmd, bstrDir, bstrTitle, fMin, fGetOut, fWait, fNoPopup, fNoEnviron, plError); }
HRESULT CScriptSite::CopyOrAppendFile(BSTR bstrSrc, BSTR bstrDst, long nSrcOffset, long nSrcLength, VARIANT_BOOL  fAppend, long *nSrcFilePosition)
            { return ScriptHost()->CopyOrAppendFile(bstrSrc, bstrDst, nSrcOffset, nSrcLength, fAppend, nSrcFilePosition); }
HRESULT CScriptSite::GetLastRunLocalError(long *plErrorCode)
            { return ScriptHost()->GetLastRunLocalError(plErrorCode); }
HRESULT CScriptSite::GetProcessOutput(long lProcessID, BSTR *pbstrData)
            { return ScriptHost()->GetProcessOutput(lProcessID, pbstrData); }
HRESULT CScriptSite::GetProcessExitCode(long lProcessID, long *plExitCode)
            { return ScriptHost()->GetProcessExitCode(lProcessID, plExitCode); }
HRESULT CScriptSite::TerminateProcess(long lProcessID)
            { return ScriptHost()->TerminateProcess(lProcessID); }
HRESULT CScriptSite::SendToProcess(long lProcessID, BSTR bstrType, BSTR bstrData, long *plReturn)
            { return ScriptHost()->SendToProcess(lProcessID, bstrType, bstrData, plReturn); }
HRESULT CScriptSite::SendMail(BSTR to, BSTR cc, BSTR bcc, BSTR subject, BSTR msg, BSTR attach, BSTR user, BSTR pass, long *plError)
            { return ScriptHost()->SendMail(to, cc, bcc, subject, msg, attach, user, pass, plError); }
HRESULT CScriptSite::SendSMTPMail(BSTR from, BSTR to, BSTR cc, BSTR subject, BSTR msg, BSTR host, long *plError)
            { return ScriptHost()->SendSMTPMail(from, to, cc, subject, msg, host, plError); }
HRESULT CScriptSite::OUTPUTDEBUGSTRING(BSTR LogMsg)
            { return ScriptHost()->OUTPUTDEBUGSTRING(LogMsg); }
HRESULT CScriptSite::UnevalString(BSTR in, BSTR *out)
            { return ScriptHost()->UnevalString(in, out); }
HRESULT CScriptSite::ASSERT(VARIANT_BOOL Assertion, BSTR LogMsg)
            { return ScriptHost()->ASSERT(Assertion, LogMsg); }
HRESULT CScriptSite::Sleep (int nTimeout)
            { return ScriptHost()->Sleep (nTimeout); }
HRESULT CScriptSite::Reboot ()
            { return ScriptHost()->Reboot (); }
HRESULT CScriptSite::NotifyScript (BSTR bstrEvent, VARIANT vData)
            { return ScriptHost()->NotifyScript (bstrEvent, vData); }
HRESULT CScriptSite::RegisterEventSource (IDispatch *pDisp, BSTR bstrProgID)
            { return ScriptHost()->RegisterEventSource (pDisp, bstrProgID); }
HRESULT CScriptSite::UnregisterEventSource (IDispatch *pDisp)
            { return ScriptHost()->UnregisterEventSource (pDisp); }
HRESULT CScriptSite::get_HostMajorVer(long *plMajorVer)
            { return ScriptHost()->get_HostMajorVer (plMajorVer); }
HRESULT CScriptSite::get_HostMinorVer(long *plMinorVer)
            { return ScriptHost()->get_HostMinorVer (plMinorVer); }
HRESULT CScriptSite::get_StatusValue(long nIndex, long *pnStatus)
            { return ScriptHost()->get_StatusValue(nIndex, pnStatus); }
HRESULT CScriptSite::put_StatusValue(long nIndex, long nStatus)
            { return ScriptHost()->put_StatusValue(nIndex, nStatus); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\cstr.cxx ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.CXX
//
// Contents     Class implementation for length prefix string class
//
// Classes      CStr
//
// Maintained by Istvanc
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//-----------------------------------------------------------------------------

#include "headers.hxx"

ANSIString::ANSIString(WCHAR *pchWide)
{
    _pch = NULL;

    Set(pchWide);
}

void
ANSIString::Set(WCHAR *pchWide)
{
    int cch = wcslen(pchWide) + 1;

    if (_pch)
        delete _pch;

    if (cch > 0)
    {
        _pch = new char[cch];

        MemSetName(_pch, "ANSIString");

        if (_pch)
        {
            WideCharToMultiByte(CP_ACP,
                                0,
                                pchWide,
                                -1,
                                _pch,
                                cch,
                                NULL,
                                NULL);
        }
    }
    else
        _pch = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates memory for a string and initializes it from a given
//              string.
//
//  Arguments:  [pch] -- String to initialize with. Can be NULL
//              [uc]  -- Number of characters to allocate.
//
//  Returns:    HRESULT
//
//  Notes:      The total number of characters allocated is uc+1, to allow
//              for a NULL terminator. If [pch] is NULL, then the string is
//              uninitialized except for the NULL terminator, which is at
//              character position [uc].
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch, UINT uc)
{
    if (pch == _pch)
    {
        if (uc == Length())
            return S_OK;
        // when the ptrs are the same the length can only be
        // different if the ptrs are NULL.  this is a hack used
        // internally to implement realloc type expansion
        Assert(pch == NULL && _pch == NULL);
    }

    Free();

    BYTE * p = new BYTE [sizeof(TCHAR) + sizeof(TCHAR) * uc + sizeof(UINT)];
    if (p)
    {
        MemSetName(p, "CStr String");

        *(UINT *)(p)  = uc * sizeof(TCHAR);
        _pch = (TCHAR *)(p + sizeof(UINT));
        if (pch)
        {
            _tcsncpy(_pch, pch, uc);
        }

        ((TCHAR *)_pch) [uc] = 0;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [pch] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(LPCTSTR pch)
{
    RRETURN(Set(pch, pch ? _tcsclen(pch) : 0));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Set, public
//
//  Synopsis:   Allocates a string and initializes it
//
//  Arguments:  [cstr] -- String to initialize from
//
//----------------------------------------------------------------------------

HRESULT
CStr::Set(const CStr &cstr)
{
    RRETURN(Set(cstr, cstr.Length()));
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::TakeOwnership, public
//
//  Synopsis:   Takes the ownership of a string from another CStr class.
//
//  Arguments:  [cstr] -- Class to take string from
//
//  Notes:      This method just transfers a string from one CStr class to
//              another. The class which is the source of the transfer has
//              a NULL value at the end of the operation.
//
//----------------------------------------------------------------------------

void
CStr::TakeOwnership(CStr &cstr)
{
    _Free();
    _pch = cstr._pch;
    cstr._pch = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetBSTR, public
//
//  Synopsis:   Allocates a string and initializes it from a BSTR
//
//  Arguments:  [bstr] -- Initialization string
//
//  Notes:      This method is more efficient than Set(LPCWSTR pch) because
//              of the length-prefix on BSTRs.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetBSTR(const BSTR bstr)
{
    RRETURN(Set(bstr, bstr ? SysStringLen(bstr) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetMultiByte, public
//
//  Synopsis:   Sets the string value from an MultiByte string
//
//  Arguments:  [pch] -- MultiByte string to convert to UNICODE
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetMultiByte(LPCSTR pch)
{
    HRESULT hr;
    DWORD   dwLen;

    dwLen = strlen(pch);

    hr = Set(NULL, dwLen);
    if (hr)
        RRETURN(hr);

    dwLen = MultiByteToWideChar(CP_ACP,
                                0,
                                pch,
                                dwLen,
                                _pch,
                                dwLen + 1);

    if (dwLen == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetMultiByte, public
//
//  Synopsis:   Gets the string value in MultiByte format
//
//  Arguments:  [pch] -- Place to put MultiByte string
//              [cch] -- Size of buffer pch points to
//
//----------------------------------------------------------------------------

HRESULT
CStr::GetMultiByte(LPSTR pch, UINT cch)
{
    HRESULT hr = S_OK;

    DWORD dwLen = WideCharToMultiByte(CP_ACP,
                                      0,
                                      _pch,
                                      -1,
                                      pch,
                                      cch,
                                      NULL,
                                      NULL);
    if (dwLen == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Length, public
//
//  Synopsis:   Returns the length of the string associated with this class
//
//----------------------------------------------------------------------------

UINT
CStr::Length() const
{
    if (_pch)
        return (((UINT *)_pch) [-1]) / sizeof(TCHAR);
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ReAlloc, public
//
//  Synopsis:   Reallocate the string to a different size buffer.
//              The length of the string is not affected, but it is allocated
//              within a larger (or maybe smaller) memory allocation.
//
//----------------------------------------------------------------------------

HRESULT
CStr::ReAlloc( UINT uc )
{
    HRESULT hr;
    TCHAR * pchOld;
    UINT    ubOld;

    Assert(uc >= Length());  // Disallowed to allocate a too-short buffer.

    if (uc)
    {
        pchOld = _pch;      // Save pointer to old string.
        _pch = 0;           // Prevent Set from Freeing the string.
        ubOld = pchOld ?    // Save old length
                    *(UINT *) (((BYTE *)pchOld) - sizeof(UINT))
                  : 0;

        hr = Set(pchOld, uc);                   // Alloc new; Copy old string.
        if (hr)
        {
            _pch = pchOld;
            RRETURN(hr);
        }
        *(UINT *)(((BYTE *)_pch) - sizeof(UINT)) = ubOld; // Restore length.

        if (pchOld )
        {
            delete [] (((BYTE *)pchOld) - sizeof(UINT));
        }
    }

    // else if uc == 0, then, since we have already checked that uc >= Length,
    // length must == 0.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStr::Append
//
//  Synopsis:   Append chars to the end of the string, reallocating & updating
//              its length.
//
//----------------------------------------------------------------------------

HRESULT
CStr::Append(LPCTSTR pch, UINT uc)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew;
    BYTE *p;

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;
        _tcsncpy(_pch + ucOld, pch, uc);
        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }
Cleanup:
    RRETURN(hr);
}


HRESULT
CStr::Append(LPCTSTR pch)
{
    RRETURN(Append(pch, pch ? _tcsclen(pch) : 0));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AppendMultiByte, public
//
//  Synopsis:   Append a multibyte string to the end,
//
//----------------------------------------------------------------------------

HRESULT
CStr::AppendMultiByte(LPCSTR pch)
{
    HRESULT hr = S_OK;
    UINT ucOld, ucNew, uc;
    BYTE *p;

    uc = strlen(pch);

    if (uc)
    {
        ucOld = Length();
        ucNew = ucOld + uc;
        hr = ReAlloc(ucNew);
        if (hr)
            goto Cleanup;

        uc = MultiByteToWideChar(CP_ACP,
                                 0,
                                 pch,
                                 uc,
                                 _pch + ucOld,
                                 uc + 1);
        if (uc == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            TraceTag((tagError, "CSTR: Fatal string conversion error %x", hr));

            goto Cleanup;
        }

        ((TCHAR *)_pch) [ucNew] = 0;
        p = ((BYTE*)_pch - sizeof(UINT));
        *(UINT *)p = ucNew * sizeof(TCHAR);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::SetLengthNoAlloc, public
//
//  Synopsis:   Sets the internal length of the string. Note.  There is no
//              verification that the length that is set is within the allocated
//              range of the string. If the caller sets the length too large,
//              this blasts a null byte into memory.
//
//----------------------------------------------------------------------------

HRESULT
CStr::SetLengthNoAlloc( UINT uc )
{
    if (_pch)
    {
        BYTE * p = ( (BYTE *)_pch - sizeof(UINT));
        *(UINT *)p = uc * sizeof(TCHAR);    // Set the length prefix.
        ((TCHAR *)_pch) [uc] = 0;           // Set null terminator
        return S_OK;
    }
    else
        return E_POINTER;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::AllocBSTR, public
//
//  Synopsis:   Allocates a BSTR and initializes it with the string that is
//              associated with this class.
//
//  Arguments:  [pBSTR] -- Place to put new BSTR. This pointer should not
//                         be pointing to an existing BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CStr::AllocBSTR(BSTR *pBSTR) const
{
    if (!_pch)
    {
        *pBSTR = 0;
        return S_OK;
    }

    *pBSTR = SysAllocStringLen(*this, Length());
    RRETURN(*pBSTR ? S_OK: E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::TrimTrailingWhitespace, public
//
//  Synopsis:   Removes any trailing whitespace in the string that is
//              associated with this class.
//
//  Arguments:  None.
//
//----------------------------------------------------------------------------

HRESULT CStr::TrimTrailingWhitespace()
{
    if (!_pch)
        return S_OK;

    UINT ucNewLength = Length();

    for ( ; ucNewLength > 0; ucNewLength-- )
    {
        if ( !_istspace( ((TCHAR *)_pch)[ ucNewLength - 1 ] ) )
            break;
        ((TCHAR *)_pch)[ ucNewLength - 1 ] = (TCHAR) 0;
    }

    BYTE *p = ((BYTE*)_pch - sizeof(UINT));
    *(UINT *)p = ucNewLength * sizeof(TCHAR);
        return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::_Free, private
//
//  Synopsis:   Frees any memory held onto by this class.
//
//----------------------------------------------------------------------------

void
CStr::_Free()
{
    if (_pch )
    {
        delete [] (((BYTE *)_pch) - sizeof(UINT));
    }
    _pch=0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Clone
//
//  Synopsis:   Make copy of current string
//
//----------------------------------------------------------------------------
HRESULT
CStr::Clone(CStr **ppCStr) const
{
    HRESULT hr;
    Assert(ppCStr);
    *ppCStr = new CStr;
    hr = *ppCStr?S_OK:E_OUTOFMEMORY;
    if (hr)
        goto Cleanup;

    hr = THR( (*ppCStr)->Set(*this) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Compare
//
//  Synopsis:   Case insensitive comparison of 2 strings
//
//----------------------------------------------------------------------------
BOOL
CStr::Compare (const CStr *pCStr) const
{
    return (!_tcsicmp(*pCStr, *this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::ComputeCrc
//
//  Synopsis:   Computes a hash of the string.
//
//----------------------------------------------------------------------------
#pragma warning(disable:4305)
WORD
CStr::ComputeCrc() const
{
    WORD wHash=0;
    const TCHAR* pch;
    int i;

    pch=*this;
    for(i = Length();i > 0;i--, pch++)
    {
        wHash = wHash << 7 ^ wHash >> (16-7) ^ (TCHAR)CharUpper((LPTSTR)((DWORD)(*pch)));
    }

    return wHash;
}
#pragma warning(default:4305)

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Load
//
//  Synopsis:   Initializes the CStr from a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Load(IStream * pstm)
{
    DWORD cch;
    HRESULT hr;

    hr = THR(pstm->Read(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch == 0xFFFFFFFF)
    {
        Free();
    }
    else
    {
        hr = THR(Set(NULL, cch));
        if (hr)
            goto Cleanup;

        if (cch)
        {
            hr = THR(pstm->Read(_pch, cch * sizeof(TCHAR), NULL));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::Save
//
//  Synopsis:   Writes the contents of the CStr to a stream
//
//----------------------------------------------------------------------------
HRESULT
CStr::Save(IStream * pstm) const
{
    DWORD   cch = _pch ? Length() : 0xFFFFFFFF;
    HRESULT hr;

    hr = THR(pstm->Write(&cch, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    if (cch && cch != 0xFFFFFFFF)
    {
        hr = THR(pstm->Write(_pch, cch * sizeof(TCHAR), NULL));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStr::GetSaveSize
//
//  Synopsis:   Returns the number of bytes which will be written by
//              CStr::Save
//
//----------------------------------------------------------------------------
ULONG
CStr::GetSaveSize() const
{
    return(sizeof(DWORD) + (_pch ? (Length() * sizeof(TCHAR)) : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\dbgstk.cxx ===
/***
*dbgstk.c - debug check stack routine
*
*       Copyright (c) 1986-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This module contains a debug impelmentation of the standard _chkstk
*   for i386.  It will do the standard stack probe (code copied from
*   VC5 CRT) and then call a debug routine which will have the oportunity
*   top spew the stack before it gets initialized (or not).
*
*******************************************************************************/
#include "headers.hxx"

#if defined(USE_STACK_SPEW) && defined(_X86_)

#pragma check_stack(off)

static BOOL    g_fStackSpewEnabled = FALSE;
static DWORD   g_dwSpew = 0x0;

extern "C" void __declspec(naked) __cdecl _chkstk()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled

        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:
        ret     12                      ; return, popping off 12 padding
    }
}

// NOTE: _alloca_probe is impelemented exactly the same as _chkstk
// I'd like to find some way to merge these two pieces of code but I
// don't know how with inline assembly...
extern "C" void __declspec(naked) __cdecl _alloca_probe()
{
    _asm
    {
        ;  First probe the stack.  We do this because
        ;  we don't want to write past the stack guard page
        ;  Note that this code came from the original
        ;  c run time source.

        push    ecx                     ; save ecx
        push    eax                     ; save eax (size of stack needed)
        cmp     eax,1000h               ; more than one page requested?
        lea     ecx,[esp] + 12          ;   compute new stack pointer in ecx
                                        ;   correct for return address and
                                        ;   saved ecx, eax
        jb      short lastpage          ; no

probepages:
        sub     ecx,1000h               ; yes, move down a page
        sub     eax,1000h               ; adjust request and...

        test    dword ptr [ecx],eax     ; ...probe it

        cmp     eax,1000h               ; more than one page requested?
        jae     short probepages        ; no

lastpage:
        sub     ecx,eax                 ; move stack down by eax
        mov     eax,esp                 ; save current tos and do a...

        test    dword ptr [ecx],eax     ; ...probe in case a page was crossed

        ;  Now set up and write our data into the area of the stack
        ;  that was opened up

        lea     esp,[ecx] - 12          ; set the stack pointer to the bottom
                                        ; leave room 12 in padding so we don't
                                        ; clobber ourselves

        mov     ecx,dword ptr [eax+8]   ; recover return address
        push    ecx

        cmp     g_fStackSpewEnabled,0   ; see if we are enabled

        mov     ecx,dword ptr [eax+4]   ; recover original ecx

        je      done                    ; not enabled

        push    ecx                     ; save original ecx

        pushfd                          ; save flags
        std                             ; set DI: decr edi after stosd

        mov     ecx,dword ptr [eax]     ; recover original eax (stack size)

        push    edi                     ; save edi on stack also
        lea     edi,[eax]+8             ; load up iterator start address

        shr     ecx,2                   ; get count of dwords

        mov     eax,g_dwSpew            ; load up value

        rep stosd                       ; let 'er rip

        pop     edi                     ; pop saved edi
        popfd                           ; pop flags
        pop     ecx                     ; pop saved ecx

done:
        ret     12                      ; return, popping off 12 padding
    }
}

//
// Initialize the debug stack system
//

extern "C" void
InitChkStk(BOOL dwFill)
{
    g_dwSpew = dwFill;
    g_fStackSpewEnabled = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\dynary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   formsary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CImplAry
//
//-------------------------------------------------------------------------

#include <headers.hxx>

//  CImplAry class

//+------------------------------------------------------------------------
//
//  Member: CImplAry::~CImplAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CImplAry::~CImplAry( )
{
    if (!UsingStackArray())
    {
        MemFree(PData());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::GetAlloced, public
//
//  Synopsis:   Returns the number of bytes that have been allocated.
//
//  Arguments:  [cb] -- Size of each element
//
//  Notes:      For the CStackAry classes the value returned is _cStack*cb if
//              we're still using the stack-allocated array.
//
//----------------------------------------------------------------------------

ULONG
CImplAry::GetAlloced(size_t cb)
{
    if (UsingStackArray())
    {
        return GetStackSize() * cb;
    }
    else
    {
        return MemGetSize(PData());
    }
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::EnsureSize ( size_t cb, long c )
{
    HRESULT  hr = S_OK;
    unsigned long cbAlloc;

    if (UsingStackArray() && (long)(c * cb) <= (long)GetAlloced(cb))
        goto Cleanup;

    Assert( c >= 0 );

    cbAlloc = ((c < 8) ? c : ((c + 7) & ~7)) * cb;

    if (UsingStackArray() ||
        (((unsigned long) c > ((_c < 8) ? _c : ((_c + 7) & ~7))) && cbAlloc > MemGetSize(PData())))
    {
        Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

        if (UsingStackArray())
        {
            //
            // We have to switch from the stack-based array to an allocated
            // one, so allocate the memory and copy the data over.
            //

            void * pbDataOld = PData();
            int    cbOld     = GetAlloced( cb );

            PData() = MemAlloc( cbAlloc );

            if (!PData())
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( PData(), pbDataOld, cbOld );
        }
        else
        {
            hr = MemRealloc( (void **) & PData(), cbAlloc );

            if (hr)
                goto Cleanup;
        }

        _fDontFree = FALSE;
    }

Cleanup:

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Grow, public
//
//  Synopsis:   Ensures enough memory is allocated for c elements and then
//              sets the size of the array to that much.
//
//  Arguments:  [cb] -- Element Size
//              [c]  -- Number of elements to grow array to.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Grow(size_t cb, int c)
{
    HRESULT hr = EnsureSize(cb, c);
    if (!hr)
    {
        SetSize(c);
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array,
//              incrementing the array's logical size, and growing the
//              array's allocated size if necessary.  Note that the element
//              is passed with a pointer, rather than directly.
//
//  Arguments:  cb        Element size
//              pv        Pointer to the element to be appended
//              ppvPlaced Pointer to the element that's inside the array
//
//  Returns:    HRESULT
//
//  Notes:      If pv is NULL, the element is appended and initialized to
//              zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::AppendIndirect(size_t cb, void * pv, void ** ppvPlaced)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    if (ppvPlaced)
    {
        *ppvPlaced = Deref(cb, _c);
    }

    if (!pv)
    {
        memset(Deref(cb, _c), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, _c), pv, cb);
    }

    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CImplAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::Delete(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(i < (int)_c);

    Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CImplAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteMultiple(size_t cb, int start, int end)
{
    Assert((start >= 0) && (end >= 0));
    Assert((start < (int)_c) && (end < (int)_c));
    Assert(end >= start);

    if ((unsigned)end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CImplAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CImplAry::DeleteAll(void)
{
    Assert(!_fCheckLock && "CDataAry changing while CImplAryLock is on");

    if (!UsingStackArray())
    {
        MemFree(PData());

        if (_fStack)
        {
            PData() = GetStackPtr();
            _fDontFree = TRUE;
        }
        else
        {
            PData() = NULL;
        }
    }

    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CImplAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//              if pv is NULL then the element is initialized to all zero.
//
//-------------------------------------------------------------------------
HRESULT
CImplAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    if (!pv)
    {
        memset(Deref(cb, i), 0, cb);
    }
    else
    {
        memcpy(Deref(cb, i), pv, cb);
    }
    _c++;
    return NOERROR;

}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CImplAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::Copy
//
//  Synopsis:   Creates a copy from another CImplAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::Copy(size_t cb, const CImplAry& ary, BOOL fAddRef)
{
    RRETURN(CopyIndirect(cb, ary._c, ((CImplAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CImplAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        if (EnsureSize(cb, c))
            RRETURN(E_OUTOFMEMORY);

        memcpy(PData(), pv, c * cb);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}


HRESULT
CImplPtrAry::ClearAndReset()
{
    //  BUGBUG why does this function reallocate memory, rather than
    //    just memset'ing to 0? (chrisz)

    // BUGBUG -- Do not use this method! Use DeleteAll to clear the array.
    Assert(!PData());

    PData() = NULL;
    HRESULT hr = EnsureSize(_c);
    _c = 0;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImplPtrAry::*
//
//  Synopsis:   CImplPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CImplPtrAry::EnsureSize(long c)
{
    return CImplAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Grow(int c)
{
    return CImplAry::Grow(sizeof(void *), c);
}

HRESULT
CImplPtrAry::Append(void * pv)
{
    return CImplAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CImplPtrAry::Insert(int i, void * pv)
{
    return CImplAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CImplPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); (unsigned)i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CImplPtrAry::Delete(int i)
{
    CImplAry::Delete(sizeof(void *), i);
}

BOOL
CImplPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CImplAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CImplPtrAry::DeleteMultiple(int start, int end)
{
    CImplAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CImplPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    Assert(idx < (int)_c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];

    Delete(idx);

    if (pUnk)
        (pUnk)->Release();
}


void
CImplPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); (unsigned)i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

HRESULT
CImplPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CImplAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CImplPtrAry::Copy(const CImplAry& ary, BOOL fAddRef)
{
    return CImplAry::Copy(sizeof(void *), ary, fAddRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\regdcom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       regdcom.cxx
//
//  Contents:   Utility functions used to manipulated the DCOM registry
//              settings.
//
//              This code was stolen from the DCOMPERM sample code written
//              by Michael Nelson.
//
//              The only function that should be called outside this file is
//              ChangeAppIDACL. All others are utility functions used by it.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#include "ntsecapi.h"

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle,
                             TokenUser,
                             tokenUser,
                             0,
                             &tokenSize);

        tokenUser = (TOKEN_USER *) MemAlloc (tokenSize);

        if (GetTokenInformation (tokenHandle,
                                 TokenUser,
                                 tokenUser,
                                 tokenSize,
                                 &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) MemAlloc (sidLength);

            memcpy (*Sid, tokenUser->User.Sid, sidLength);
            CloseHandle (tokenHandle);
        } else
        {
            MemFree (tokenUser);
            return GetLastError();
        }
    } else
    {
        MemFree (tokenUser);
        return GetLastError();
    }

    MemFree (tokenUser);
    return ERROR_SUCCESS;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid
    )
{
    DWORD        sidSize;
    TCHAR        refDomain [256];
    DWORD        refDomainSize;
    DWORD        returnValue;
    SID_NAME_USE snu;

    sidSize = 0;
    refDomainSize = 255;

    LookupAccountName (NULL,
                       Principal,
                       *Sid,
                       &sidSize,
                       refDomain,
                       &refDomainSize,
                       &snu);

    returnValue = GetLastError();
    if (returnValue != ERROR_INSUFFICIENT_BUFFER)
        return returnValue;

    *Sid = (PSID) MemAlloc (sidSize);
    refDomainSize = 255;

    if (!LookupAccountName (NULL,
                            Principal,
                            *Sid,
                            &sidSize,
                            refDomain,
                            &refDomainSize,
                            &snu))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) MemAlloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        MemFree (*SD);
        MemFree (sid);
        return GetLastError();
    }

    MemFree(sid);

    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl;
    PACL                  sacl;
    PSID                  ownerSID;
    PSID                  groupSID;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
                return returnValue;

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS)
            return returnValue;

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) MemAlloc (valueSize);

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            MemFree (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS)
                return returnValue;

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    BOOL *pfNewAcl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue;
    PSID                  principalSID;
    PACL                  oldACL, newACL;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        MemFree (principalSID);
        return GetLastError();
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        MemFree (principalSID);
        return GetLastError();
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (principalSID);
        return returnValue;
    }

    *Acl = newACL;

    if (*pfNewAcl)
        delete [] oldACL;

    *pfNewAcl = TRUE;

    MemFree (principalSID);
    return ERROR_SUCCESS;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    BOOL *pfNewAcl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
        goto Cleanup;

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
        goto Cleanup;

    *Acl = newACL;

    if (*pfNewAcl)
        delete [] oldACL;

    *pfNewAcl = TRUE;

Cleanup:

    MemFree (principalSID);
    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID;
    DWORD                   returnValue;
    ACE_HEADER              *aceHeader;

    returnValue = GetPrincipalSID (Principal, &principalSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            MemFree (principalSID);
            return GetLastError();
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                MemFree (principalSID);
                return ERROR_SUCCESS;
            }
        }
    }

    MemFree (principalSID);
    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue;
    SECURITY_DESCRIPTOR *sd;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newACL = FALSE;
    BOOL                newSD = FALSE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
        return GetLastError();

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
    {
        returnValue = AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, Principal);
    }
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, &newACL, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (sd);
        return returnValue;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
    else
        sdAbsolute = sd;

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
        return GetLastError();

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) MemAlloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
        return GetLastError();

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

    MemFree (sd);
    MemFree (sdSelfRelative);

    if (newACL)
        delete [] dacl;

    if (!newSD)
        MemFree (sdAbsolute);

    return ERROR_SUCCESS;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue;
    SECURITY_DESCRIPTOR *sd;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newACL = FALSE;
    BOOL                newSD = FALSE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL))
        return GetLastError();

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, &newACL, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
    {
        MemFree (sd);
        return returnValue;
    }

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD)
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
    else
        sdAbsolute = sd;

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE))
        return GetLastError();

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) MemAlloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize))
        return GetLastError();

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

    MemFree (sd);
    MemFree (sdSelfRelative);

    if (newACL)
        delete [] dacl;

    if (!newSD)
        MemFree (sdAbsolute);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChangeAppIDACL
//
//  Synopsis:   Given an AppID and a username ("EVERYONE",
//              "REDMOND\johndoe") add or remove them from the DCOM Access
//              or launch permissions for that app.
//
//  Arguments:  [AppID]        -- GUID of application to set permissions for.
//              [Principal]    -- Name of user
//              [fAccess]      -- If TRUE, set the access permissions. If
//                                   FALSE, set the launch permissions.
//              [SetPrincipal] -- If TRUE, add the user, otherwise remove
//              [Permit]       -- If TRUE, give them access, otherwise deny
//                                 them access (ignored if [SetPrincipal] is
//                                 false.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
ChangeAppIDACL (
    REFGUID AppID,
    LPTSTR  Principal,
    BOOL    fAccess,
    BOOL    SetPrincipal,
    BOOL    Permit)
{
    TCHAR   keyName [256];
    DWORD   dwRet;
    LPTSTR  pstrValue;
    OLECHAR strClsid[40];

    StringFromGUID2(AppID, strClsid, 40);

    wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

    if (fAccess)
        pstrValue = TEXT("AccessPermission");
    else
        pstrValue = TEXT("LaunchPermission");

    if (SetPrincipal)
    {
        RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal);
        dwRet = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal, Permit);
    }
    else
    {
        dwRet = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, pstrValue, Principal);
    }

    return HRESULT_FROM_WIN32(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\regsettingsio.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       RegSettingsIO.cxx
//
//  Contents:   Register Settings IO functions
//
//              Written by Lyle Corbin
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "RegSettingsIO.h"

const WCHAR *g_szRegistry = L"Software\\Microsoft\\MTScript";

HRESULT
RegSettingsIO(const WCHAR *szRegistry, BOOL fSave, const REGKEYINFORMATION *aKeyValues, int cKeyValues, BYTE *pBase)
{
    LONG                lRet;
    HKEY                hKeyRoot = NULL;
    HKEY                hKeySub  = NULL;
    int                 i;
    DWORD               dwType;
    DWORD               dwSize;
    DWORD               dwDisposition;

    DWORD               dwDataBuf[MAX_REG_VALUE_LENGTH];
    BYTE              * bDataBuf = (BYTE*) dwDataBuf;

    BYTE              * pbData;
    BOOL                fWriteReg = fSave;
    WCHAR             * pch;

    const REGKEYINFORMATION * prki;
    lRet = RegCreateKeyEx(HKEY_CURRENT_USER,
                          g_szRegistry,
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKeyRoot,
                          &dwDisposition);

    if( lRet != ERROR_SUCCESS )
        return S_FALSE;

    if (dwDisposition == REG_CREATED_NEW_KEY)
    {
        //
        // The key didn't exist. Write out the default values.
        //
        fWriteReg = TRUE;
    }

    for (i = 0; i < cKeyValues; i++)
    {
        prki = &aKeyValues[i];

        switch (prki->rkiType)
        {
        case RKI_KEY:
            if (!prki->pszName)
            {
                hKeySub = hKeyRoot;
            }
            else
            {
                if (hKeySub && (hKeySub != hKeyRoot))
                {
                    RegCloseKey(hKeySub);
                    hKeySub = NULL;

                    fWriteReg = fSave;
                }

                pch = prki->pszName;

                lRet = RegCreateKeyEx(hKeyRoot,
                                      pch,
                                      0,
                                      NULL,
                                      0,
                                      KEY_ALL_ACCESS,
                                      NULL,
                                      &hKeySub,
                                      &dwDisposition);

                if (lRet != ERROR_SUCCESS)
                {
                    // We couldn't get this key, skip it.
                    i++;
                    while (i < cKeyValues &&
                           aKeyValues[i].rkiType != RKI_KEY)
                    {
                        i++;
                    }

                    i--; // Account for the fact that continue will increment i again.
                    hKeySub = NULL;
                    continue;
                }
                else if (dwDisposition == REG_CREATED_NEW_KEY)
                {
                    //
                    // The key didn't exist. Write out the default values.
                    //
                    fWriteReg = TRUE;
                }
            }
            break;

        case RKI_BOOL:
            Assert(hKeySub);

            if (fWriteReg)
            {
                RegSetValueEx(hKeySub,
                              prki->pszName,
                              0,
                              REG_DWORD,
                              (BYTE*)((BYTE *)pBase + prki->cbOffset),
                              sizeof(BOOL));
            }
            else
            {
                dwSize = MAX_REG_VALUE_LENGTH;

                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       bDataBuf,
                                       &dwSize);

                if (lRet == ERROR_SUCCESS)
                {
                    pbData = (BYTE*)((BYTE *)pBase + prki->cbOffset);

                    if (dwType == REG_DWORD)
                    {
                        *pbData = (*(DWORD*)bDataBuf != 0);
                    }
                    else if (dwType == REG_SZ)
                    {
                        TCHAR ch = *(TCHAR *)bDataBuf;

                        if (ch == _T('1') ||
                            ch == _T('y') ||
                            ch == _T('Y'))
                        {
                            *pbData = TRUE;
                        }
                        else
                        {
                            *pbData = FALSE;
                        }
                    } else if (dwType == REG_BINARY)
                    {
                        *pbData = (*(BYTE*)bDataBuf != 0);
                    }

                    // Can't convert other types. Just leave it the default.
                }
            }
            break;

        case RKI_DWORD:
            Assert(hKeySub);

            if (fWriteReg)
            {
                RegSetValueEx(hKeySub,
                              prki->pszName,
                              0,
                              REG_DWORD,
                              (BYTE*)((BYTE *)pBase + prki->cbOffset),
                              sizeof(DWORD));
            }
            else
            {
                dwSize = sizeof(DWORD);

                lRet = RegQueryValueEx(hKeySub,
                                       prki->pszName,
                                       0,
                                       &dwType,
                                       bDataBuf,
                                       &dwSize);

                if (lRet == ERROR_SUCCESS && (dwType == REG_BINARY || dwType == REG_DWORD))
                {
                    *(DWORD*)((BYTE *)pBase + prki->cbOffset) = *(DWORD*)bDataBuf;
                }
            }
            break;

        case RKI_STRING:
        case RKI_EXPANDSZ:
            Assert(hKeySub);

            {
                CStr *pstr = ((CStr *)((BYTE *)pBase + prki->cbOffset));

                if (fWriteReg)
                {
                    //
                    // Only write it out if there is a value there.  That way
                    // we get the default next time we load even if it may
                    // evaluate differently (e.g.  location of this exe
                    // changes).
                    //
                    RegSetValueEx(hKeySub,
                                  prki->pszName,
                                  0,
                                  (prki->rkiType == RKI_STRING) ? REG_SZ : REG_EXPAND_SZ,
                                  (BYTE*)((pstr->Length() > 0) ? (LPTSTR)*pstr : L""),
                                  (pstr->Length()+1) * sizeof(TCHAR));
                }
                else
                {
                    dwSize = 0;

                    // get the size of string
                    lRet = RegQueryValueEx(hKeySub,
                                           prki->pszName,
                                           0,
                                           &dwType,
                                           NULL,
                                           &dwSize);

                    if (lRet == ERROR_SUCCESS && dwSize - sizeof(TCHAR) > 0)
                    {
                        // Set already adds 1 for a terminating NULL, and
                        // dwSize is including it as well.
                        pstr->Set(NULL, (dwSize / sizeof(TCHAR)) - 1);

                        lRet = RegQueryValueEx(hKeySub,
                                               prki->pszName,
                                               0,
                                               &dwType,
                                               (BYTE*)(LPTSTR)*pstr,
                                               &dwSize);

                        if (lRet != ERROR_SUCCESS ||
                            (dwType != REG_SZ && dwType != REG_EXPAND_SZ))
                        {
                            pstr->Free();
                        }

                        if (dwType == REG_EXPAND_SZ)
                        {
                            CStr cstrExpand;

                            dwSize = ExpandEnvironmentStrings(*pstr, NULL, 0);

                            // Set already adds 1 for a terminating NULL, and
                            // dwSize is including it as well.
                            cstrExpand.Set(NULL, dwSize - 1);

                            dwSize = ExpandEnvironmentStrings(*pstr, cstrExpand, dwSize + 1);

                            pstr->TakeOwnership(cstrExpand);
                        }

                        pstr->TrimTrailingWhitespace();
                    }
                }
            }

            break;

        default:
            AssertSz(FALSE, "Unrecognized RKI Type");
            break;
        }
    }

    if (hKeySub && (hKeySub != hKeyRoot))
        RegCloseKey(hKeySub);

    RegCloseKey( hKeyRoot );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\thrdcomm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       thrdcomm.cxx
//
//  Contents:   Implementation of the CThreadComm class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTagOther(tagDontKillThread, "MTScript", "Dont Terminate Threads on Shutdown");

//+---------------------------------------------------------------------------
//
//  CThreadComm class
//
//  Handles communication between threads.
//
//----------------------------------------------------------------------------

CThreadComm::CThreadComm()
{
    Assert(_hCommEvent == NULL);
    Assert(_hThreadReady == NULL);
    Assert(_hThread    == NULL);
    Assert(_pMsgData   == NULL);
}

CThreadComm::~CThreadComm()
{
    MESSAGEDATA *pMsg;

    if (_hThread)
        CloseHandle(_hThread);

    if (_hCommEvent)
        CloseHandle(_hCommEvent);

    if (_hThreadReady)
        CloseHandle(_hThreadReady);

    if (_hResultEvt)
        CloseHandle(_hResultEvt);

    while (_pMsgData)
    {
        pMsg = _pMsgData->pNext;

        delete _pMsgData;

        _pMsgData = pMsg;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Init, public
//
//  Synopsis:   Initializes the class. Must be called on all instances before
//              using.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::Init()
{
    _hCommEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hCommEvent)
        goto Error;

    _hThreadReady = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hThreadReady)
        goto Error;

    _hResultEvt = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!_hResultEvt)
        goto Error;

    return TRUE;

Error:
    ErrorPopup(L"CThreadComm::Init");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SendHelper, public
//
//  Synopsis:   Send or post the given message to the thread which owns
//              this class.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//              [fSend]  -- TRUE if we're doing a send, FALSE if it's a post
//              [hResultEvt] -- Event handle to signal when the result is ready
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::SendHelper(THREADMSG mt,
                        void *    pvData,
                        DWORD     cbData,
                        BOOL      fSend,
                        HANDLE    hResultEvt)
{
    DWORD        dwRet = 0;
    MESSAGEDATA *pMsg = NULL, *pMsgLoop;

    AssertSz(!pvData || cbData != 0, "Invalid params to PostToThread");

    pMsg = new MESSAGEDATA;
    if (!pMsg)
        goto Error;

    pMsg->pNext      = NULL;
    pMsg->tmMessage  = mt;
    pMsg->dwResult   = 0;
    pMsg->hResultEvt = hResultEvt;

    if (pvData)
    {
        AssertSz(cbData <= MSGDATABUFSIZE, "Data is too big!");

        pMsg->cbData = cbData;
        memcpy(pMsg->bData, pvData, cbData);
    }
    else
    {
        pMsg->cbData = 0;
    }

    {
        LOCK_LOCALS(this);

        if (!fSend)
        {
            //
            // Stick the new message at the end so we get messages FIFO
            //

            pMsgLoop = _pMsgData;

            while (pMsgLoop && pMsgLoop->pNext)
            {
                pMsgLoop = pMsgLoop->pNext;
            }

            if (!pMsgLoop)
            {
                _pMsgData = pMsg;
            }
            else
            {
                pMsgLoop->pNext = pMsg;
            }
        }
        else
        {
            // Set dwResult to indicate we're expecting a result
            pMsg->dwResult = 1;

            //
            // Put sent messages at the front to minimize potential deadlocks
            //
            pMsg->pNext = _pMsgData;
            _pMsgData = pMsg;

            Assert(hResultEvt);

            ResetEvent(hResultEvt);
        }
    }

    SetEvent(_hCommEvent);

    if (fSend)
    {
        HANDLE ahEvents[2];
        ahEvents[0] = hResultEvt;
        ahEvents[1] = _hThread ;
        DWORD dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, 50000);
        switch(dwWait)
        {
            case WAIT_OBJECT_0: // OK, this is good
                break;

            default:
            case WAIT_OBJECT_0 + 1:
            case WAIT_TIMEOUT:
                AssertSz(FALSE, "SendToThread never responded!");

                //
                // This causes a memory leak, but it's better than a crash. What
                // we really need to do is remove the message from the queue.
                //
                return 0;
        }

        dwRet = pMsg->dwResult;

        delete pMsg;
    }

    return dwRet;

Error:
    ErrorPopup(L"CThreadComm::PostToThread - out of memory");

    return dwRet;
}
//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::PostToThread, public
//
//  Synopsis:   Post the given message to the thread which owns pTarget.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//
//----------------------------------------------------------------------------

void
CThreadComm::PostToThread(CThreadComm *pTarget,
                          THREADMSG    mt,
                          void *       pvData,
                          DWORD        cbData)
{
    (void)pTarget->SendHelper(mt, pvData, cbData, FALSE, NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SendToThread, public
//
//  Synopsis:   Send the given message to the thread which owns this class.
//
//  Arguments:  [md]     -- Message to send
//              [pvData] -- Associated data with message.
//              [cbData] -- Size of info that [pvData] points to.
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::SendToThread(CThreadComm *pTarget,
                          THREADMSG    mt,
                          void *       pvData,
                          DWORD        cbData)
{
    DWORD  dwRet;

    VERIFY_THREAD();

    Assert(sizeof(_fInSend) == 4);  // We are relying on atomic read/writes
                                    //   because multiple threads are accessing
                                    //   this variable.
    Assert(!_fInSend);

    _fInSend = TRUE;

    if (pTarget->_fInSend)
    {
        //
        // Somebody is trying to send to us while we're sending to someone else.
        // This is potentially a deadlock situation! First, wait and see if it
        // resolves, then if it doesn't, assert and bail out!
        //
        TraceTag((tagError, "Perf Hit! Avoiding deadlock situation!"));

        Sleep(100); // Arbitrary 100 ms

        if (pTarget->_fInSend)
        {
            AssertSz(FALSE, "Deadlock - SendToThread called on object doing a send!");

            _fInSend = FALSE;

            return 0;
        }
    }

    dwRet = pTarget->SendHelper(mt, pvData, cbData, TRUE, _hResultEvt);

    _fInSend = FALSE;

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::GetNextMsg, public
//
//  Synopsis:   Retrieves the next message waiting for this thread.
//
//  Arguments:  [md]      -- Place to put message type.
//              [pData]   -- Associated data for message. Must be allocated
//                            memory of size MSGDATABUFSIZE
//              [pcbData] -- Size of info in *pData is returned here.
//
//  Returns:    TRUE if a valid message was returned. FALSE if there are no
//              more messages.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::GetNextMsg(THREADMSG *mt, void * pData, DWORD *pcbData)
{
    MESSAGEDATA *pMsg;
    BOOL         fRet = TRUE;

    VERIFY_THREAD();

    LOCK_LOCALS(this);

    AssertSz(!_pMsgReply, "Sent message not replied to!");

    pMsg = _pMsgData;

    if (pMsg)
    {
        _pMsgData = pMsg->pNext;

        *mt       = pMsg->tmMessage;
        *pcbData  = pMsg->cbData;
        memcpy(pData, pMsg->bData, pMsg->cbData);

        //
        // If the caller is not expecting a reply, delete the message. If he is,
        // then the caller will free the memory.
        //
        if (pMsg->dwResult == 0)
        {
            delete pMsg;
        }
        else
        {
            _pMsgReply = pMsg;
        }
    }
    else if (!_pMsgData)
    {
        ResetEvent(_hCommEvent);
        fRet = FALSE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Reply, public
//
//  Synopsis:   Call this to send the result of a SendToThread call back to
//              the calling thread.
//
//  Arguments:  [dwReply] -- Result to send back.
//
//----------------------------------------------------------------------------

void
CThreadComm::Reply(DWORD dwReply)
{
    VERIFY_THREAD();

    Assert(_pMsgReply);

    _pMsgReply->dwResult = dwReply;

    SetEvent(_pMsgReply->hResultEvt);

    _pMsgReply = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     MessageEventPump, public
//
//  Synopsis:   Empties our message queues (both windows' and our private
//              threadcomm queue)
//
//  Arguments:
//              [hEvent]    -- event handle to wait for
//
//  Returns:
//              WAIT_ABANDONED: An event occurred which is causing this thread to
//                        terminate. The caller should clean up and finish
//                        what it's doing.
//              WAIT_OBJECT_0: If one (or all if fAll==TRUE) of the passed-in
//                           event handles became signaled. The index of the
//                           signaled handle is added to MEP_EVENT_0. Returned
//                           only if one or more event handles were passed in.
//
//----------------------------------------------------------------------------

DWORD
MessageEventPump(HANDLE hEvent)
{
    MSG   msg;
    DWORD dwRet;
    DWORD mepReturn = 0;

    do
    {
        //
        // Purge out all window messages (primarily for OLE's benefit).
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                return WAIT_ABANDONED;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        dwRet = MsgWaitForMultipleObjects(1,
                                          &hEvent,
                                          FALSE,
                                          INFINITE,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            mepReturn = dwRet;
            break;
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            //
            // A windows message came through. It will be handled at the
            // top of the loop.
            //
        }
        else if (dwRet == WAIT_FAILED || dwRet == WAIT_ABANDONED)
        {
            TraceTag((tagError, "WaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "WaitForMultipleObjects failure");

            mepReturn = dwRet;

            break;
        }
    }
    while (true);
    return mepReturn;
}
//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::StartThread, public
//
//  Synopsis:   Starts a new thread that owns this CThreadComm instance.
//
//----------------------------------------------------------------------------

HRESULT
CThreadComm::StartThread(void * pvParams)
{
    if (!Init())
    {
        AssertSz(FALSE, "Failed to initialize new class.");
        return E_FAIL; // TODO: need to change Init() to return HRESULT
    }
    ResetEvent(_hThreadReady);

    //
    // Create suspended because we need to set member variables before it
    // gets going.
    //
    _hThread = CreateThread(NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)CThreadComm::TempThreadRoutine,
                            (LPVOID)this,
                            CREATE_SUSPENDED,
                            &_dwThreadId);

    if (_hThread == NULL)
    {
        long e = GetLastError();
        return HRESULT_FROM_WIN32(e);
    }

    _pvParams = pvParams;
    _hrThread = S_OK;
    //
    // Everything's set up - get it going!
    //
    ResumeThread(_hThread);
    //
    // Wait for the new thread to say it's ready...
    //
    MessageEventPump(_hThreadReady); // This is neccessary to allow the new thread to retrieve the script parameter with GetInterfaceFromGlobal().
    // On failure, wait for the thread to exit before returning.
    if (FAILED(_hrThread))
    {
        WaitForSingleObject(_hThread, INFINITE);
        return _hrThread;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::TempThreadRoutine, public
//
//  Synopsis:   Static member given to CreateThread. Just a stub that calls
//              the real thread routine.
//
//----------------------------------------------------------------------------

DWORD
CThreadComm::TempThreadRoutine(LPVOID pvParam)
{
    CThreadComm *pThis = (CThreadComm*)pvParam;

    AssertSz(pThis, "Bad arg passed to CThreadComm::TempThreadRoutine");

    return pThis->ThreadMain();
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::SetName, public
//
//  Synopsis:   On a debug build, sets the thread name so the debugger
//              lists the threads in an understandable manner.
//
//  Arguments:  [pszName] -- Name to set thread to.
//
//----------------------------------------------------------------------------

void
CThreadComm::SetName(LPCSTR pszName)
{
#if DBG == 1
    THREADNAME_INFO info =
    {
        0x1000,
        pszName,
        _dwThreadId
    };

    __try
    {
        RaiseException(0x406d1388, 0, sizeof(info) / sizeof(DWORD), (DWORD *)&info);
    }
    __except(EXCEPTION_CONTINUE_EXECUTION)
    {
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CThreadComm::Shutdown, public
//
//  Synopsis:   Forces the thread containing the given instance of the
//              ThreadComm object to shutdown.
//
//  Arguments:  [pTarget] -- Object to shutdown
//
//  Returns:    TRUE if it shutdown normally, FALSE if it had to be killed.
//
//----------------------------------------------------------------------------

BOOL
CThreadComm::Shutdown(CThreadComm *pTarget)
{
    BOOL fReturn    = TRUE;
    DWORD dwTimeout = (IsTagEnabled(tagDontKillThread)) ? INFINITE : 5000;
    DWORD dwCode;

    GetExitCodeThread(pTarget->hThread(), &dwCode);

    // Is client already dead?

    if (dwCode != STILL_ACTIVE)
        return TRUE;

    //
    // Sending the PLEASEEXIT message will flush all other messages out,
    // causing any unsent data to be sent before closing the pipe.
    //
    PostToThread(pTarget, MD_PLEASEEXIT);

    // Wait 5 seconds for our thread to terminate and then kill it.
    if (WaitForSingleObject(pTarget->hThread(), dwTimeout) == WAIT_TIMEOUT)
    {
        TraceTag((tagError, "Terminating thread for object %x...", this));

        AssertSz(FALSE, "I'm being forced to terminate a thread!");

        TerminateThread(pTarget->hThread(), 1);

        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\util\memutils.cxx ===
//+------------------------------------------------------------------------
//
//  File:       memutil.cxx
//
//  Contents:   Memory utilities
//
//  History:    Stolen from Trident
//
//-------------------------------------------------------------------------

#include "headers.hxx"

EXTERN_C HANDLE g_hProcessHeap;

#define SMALLBLOCKHEAP 0

void
ClearInterfaceFn(IUnknown **ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
// Allocation functions not implemented in this file:
//
//      CDUTIL.HXX
//          operator new
//          operator delete
//
//      OLE's OBJBASE.H
//          CoTaskMemAlloc, CoTaskMemFree
//
//-------------------------------------------------------------------------

#if SMALLBLOCKHEAP

DeclareTag(tagSmallBlockHeap, "!Memory", "Check small block heap every time")
DeclareTag(tagSmallBlockHeapDisable, "!Memory", "Disable small block heap");

#define _CRTBLD 1
#include "winheap.h"
EXTERN_C CRITICAL_SECTION g_csHeap;

#if DBG == 1
#define CHECKSBH if (IsTagEnabled(tagSmallBlockHeap)) {Assert(CheckSmallBlockHeap() && "Small block heap corrupt");};
BOOL IsSmallBlockHeapEnabled()
{
    static int g_fSmallBlockHeap = -1;
    if (g_fSmallBlockHeap == -1)
        g_fSmallBlockHeap = IsTagEnabled(tagSmallBlockHeapDisable) ? 0 : 1;
    return(g_fSmallBlockHeap == 1);
}
BOOL CheckSmallBlockHeap()
{
    if (IsSmallBlockHeapEnabled())
    {
        EnterCriticalSection(&g_csHeap);
        BOOL f = __sbh_heap_check() >= 0;
        LeaveCriticalSection(&g_csHeap);
        return f;
    }
    return TRUE;
}
#else
#define CHECKSBH
#endif

#else

#if DBG == 1
BOOL CheckSmallBlockHeap()
{
    return TRUE;
}
#endif

#endif SMALLBLOCKHEAP

//+------------------------------------------------------------------------
//
//  Function:   _MemGetSize
//
//  Synopsis:   Get size of block allocated with MemAlloc/MemRealloc.
//
//              Note that MemAlloc/MemRealloc can allocate more than
//              the requested number of bytes. Therefore the size returned
//              from this function is possibly greater than the size
//              passed to MemAlloc/Realloc.
//
//  Arguments:  [pv] - Return size of this block.
//
//  Returns:    The size of the block, or zero of pv == NULL.
//
//-------------------------------------------------------------------------
ULONG
_MemGetSize(void *pv)
{
    if (pv == NULL)
        return 0;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *    preg;
        __sbh_page_t *      ppage;
        __map_t *           pmap;

        EnterCriticalSection(&g_csHeap);
        if ((pmap = __sbh_find_block(DbgPreGetSize(pv), &preg, &ppage)) != NULL )
        {
            size_t s = DbgPostGetSize(((size_t)(*pmap)) << _PARASHIFT);
            LeaveCriticalSection(&g_csHeap);
            return s;
        }
        LeaveCriticalSection(&g_csHeap);
    }
#endif

    return DbgPostGetSize(HeapSize(g_hProcessHeap, 0, DbgPreGetSize(pv)));
}

//+------------------------------------------------------------------------
//
//  Function:   _MemAlloc
//
//  Synopsis:   Allocate block of memory.
//
//              The contents of the block are undefined.  If the requested size
//              is zero, this function returns a valid pointer.  The returned
//              pointer is guaranteed to be suitably aligned for storage of any
//              object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAlloc(ULONG cb)
{
    AssertSz (cb, "Requesting zero sized block.");

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            void * pv = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));
            LeaveCriticalSection(&g_csHeap);
            if (pv)
                return pv;
        }
    }
#endif

    return DbgPostAlloc(HeapAlloc(g_hProcessHeap, 0, DbgPreAlloc(cb)));
}


//+------------------------------------------------------------------------
//  Function:   _MemAllocClear
//
//  Synopsis:   Allocate a zero filled block of memory.
//
//              If the requested size is zero, this function returns a valid
//              pointer. The returned pointer is guaranteed to be suitably
//              aligned for storage of any object type.
//
//  Arguments:  [cb] - Number of bytes to allocate.
//
//  Returns:    Pointer to the allocated block, or NULL on error.
//
//-------------------------------------------------------------------------
void *
_MemAllocClear(ULONG cb)
{
    AssertSz (cb, "Allocating zero sized block.");

    // The small-block heap will lose its mind if this ever happens, so we
    // protect against the possibility.

    if (cb == 0)
        cb = 1;

    void * pv;

    Assert(g_hProcessHeap);

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        /* round up to the nearest paragraph */
        size_t cbr = (DbgPreAlloc(cb) + _PARASIZE - 1) & ~(_PARASIZE - 1);

        if (cbr < __sbh_threshold)
        {
            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            pv = DbgPostAlloc(__sbh_alloc_block(cbr >> _PARASHIFT));
            LeaveCriticalSection(&g_csHeap);
            if (pv)
            {
                memset(pv, 0, cb);
                return pv;
            }
        }
    }
#endif

    pv = DbgPostAlloc(HeapAlloc(g_hProcessHeap, HEAP_ZERO_MEMORY,
                    DbgPreAlloc(cb)));

    // In debug, DbgPostAlloc set the memory so we need to clear it again.

#if DBG==1
    if (pv)
    {
        memset(pv, 0, cb);
    }
#endif

    return pv;
}

//+------------------------------------------------------------------------
//
//  Function:   _MemFree
//
//  Synopsis:   Free a block of memory allocated with MemAlloc,
//              MemAllocFree or MemRealloc.
//
//  Arguments:  [pv] - Pointer to block to free.  A value of zero is
//              is ignored.
//
//-------------------------------------------------------------------------

void
_MemFree(void *pv)
{
    // The null check is required for HeapFree.
    if (pv == NULL)
        return;

    Assert(g_hProcessHeap);

#if DBG == 1
    pv = DbgPreFree(pv);
#endif

#if SMALLBLOCKHEAP
#if DBG==1
    if (IsSmallBlockHeapEnabled())
#endif
    {
        __sbh_region_t *preg;
        __sbh_page_t *  ppage;
        __map_t *       pmap;

        CHECKSBH;
        EnterCriticalSection(&g_csHeap);
        if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL ) {
            __sbh_free_block(preg, ppage, pmap);
            LeaveCriticalSection(&g_csHeap);
            DbgPostFree();
            return;
        }
        LeaveCriticalSection(&g_csHeap);
    }
#endif

    HeapFree(g_hProcessHeap, 0, pv);
    DbgPostFree();
}

//+------------------------------------------------------------------------
//  Function:   _MemRealloc
//
//  Synopsis:   Change the size of an existing block of memory, allocate a
//              block of memory, or free a block of memory depending on the
//              arguments.
//
//              If cb is zero, this function always frees the block of memory
//              and *ppv is set to zero.
//
//              If cb is not zero and *ppv is zero, then this function allocates
//              cb bytes.
//
//              If cb is not zero and *ppv is non-zero, then this function
//              changes the size of the block, possibly by moving it.
//
//              On error, *ppv is left unchanged.  The block contents remains
//              unchanged up to the smaller of the new and old sizes.  The
//              contents of the block beyond the old size is undefined.
//              The returned pointer is guaranteed to be suitably aligned for
//              storage of any object type.
//
//              The signature of this function is different than thy typical
//              realloc-like function to avoid the following common error:
//                  pv = realloc(pv, cb);
//              If realloc fails, then null is returned and the pointer to the
//              original block of memory is leaked.
//
//  Arguments:  [cb] - Requested size in bytes. A value of zero always frees
//                  the block.
//              [ppv] - On input, pointer to existing block pointer or null.
//                  On output, pointer to new block pointer.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
_MemRealloc(void **ppv, ULONG cb)
{
    void *pv;

    Assert(g_hProcessHeap);

    if (cb == 0)
    {
        _MemFree(*ppv);
        *ppv = 0;
    }
    else if (*ppv == NULL)
    {
        *ppv = _MemAlloc(cb);
        if (*ppv == NULL)
            return E_OUTOFMEMORY;
    }
    else
    {
    #if DBG == 1
        cb = DbgPreRealloc(*ppv, cb, &pv);
    #else
        pv = *ppv;
    #endif

    #if SMALLBLOCKHEAP
    #if DBG==1
        if (IsSmallBlockHeapEnabled())
    #endif
        {
            __sbh_region_t *preg;
            __sbh_page_t *  ppage;
            __map_t *       pmap;
            ULONG           cbr;
            void *          pvNew;

            cbr = (cb + _PARASIZE - 1) & ~(_PARASIZE - 1);

            CHECKSBH;
            EnterCriticalSection(&g_csHeap);
            if ( (pmap = __sbh_find_block(pv, &preg, &ppage)) != NULL )
            {
                pvNew = NULL;
                /*
                 * If the new size falls below __sbh_threshold, try to
                 * carry out the reallocation within the small-block
                 * heap.
                 */
                if ( cbr < __sbh_threshold ) {
                    if ( __sbh_resize_block(preg, ppage, pmap, cbr >> _PARASHIFT))
                    {
                        pvNew = pv;
                    }
                    else if ((pvNew = __sbh_alloc_block(cbr >> _PARASHIFT)) != NULL)
                    {
                        ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                        memcpy(pvNew, pv, min(cbOld, cb));
                        __sbh_free_block(preg, ppage, pmap);
                    }
                }

                /*
                 * If the reallocation has not been (successfully)
                 * performed in the small-block heap, try to allocate a
                 * new block with HeapAlloc.
                 */
                if ((pvNew == NULL) && ((pvNew = HeapAlloc(g_hProcessHeap, 0, cb)) != NULL))
                {
                    ULONG cbOld = ((size_t)(*pmap)) << _PARASHIFT;
                    memcpy(pvNew, pv, min(cbOld, cb));
                    __sbh_free_block(preg, ppage, pmap);
                }
                LeaveCriticalSection(&g_csHeap);
                *ppv = DbgPostRealloc(pvNew);
                if (*ppv)
                {
                    return S_OK;
                }
                else
                {
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                LeaveCriticalSection(&g_csHeap);
            }
        }
    #endif

        pv = DbgPostRealloc(HeapReAlloc(g_hProcessHeap, 0, pv, cb));

        if (pv == NULL)
            return E_OUTOFMEMORY;
        *ppv = pv;
    }

    return S_OK;
}

// MEMGUARD -------------------------------------------------------------------

#if defined(MEMGUARD)

#define MGGUARDDATA 0xF0F0BAAD

struct MGGUARD
{
    MGGUARD *pNext;
    DWORD    dw;
};

MGGUARD * g_pMemList = NULL;

void
_MgMemValidate()
{
    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    while (pg)
    {
        if (pg->dw != MGGUARDDATA)
        {
            DebugBreak();
        }

        pg = pg->pNext;
    }

    LeaveCriticalSection(&g_csHeap);
}

void
_MgRemove(MGGUARD *pmg)
{
    if (!pmg)
        return;

    EnterCriticalSection(&g_csHeap);

    MGGUARD *pg = g_pMemList;

    if (pmg == pg)
    {
        g_pMemList = pg->pNext;
        goto Cleanup;
    }

    while (pg)
    {
        if (pg->pNext == pmg)
        {
            pg->pNext = pg->pNext->pNext;
            break;
        }

        pg = pg->pNext;
    }

Cleanup:
    LeaveCriticalSection(&g_csHeap);

}

void
_MgAdd(MGGUARD *pmg)
{
    EnterCriticalSection(&g_csHeap);

    pmg->pNext = g_pMemList;
    g_pMemList = pmg;

    LeaveCriticalSection(&g_csHeap);
}

void *
_MgMemAlloc(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAlloc(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }

}

void *
_MgMemAllocClear(ULONG cb)
{
    _MgMemValidate();

    MGGUARD * pmg = (MGGUARD *)_MemAllocClear(sizeof(MGGUARD) + cb);

    if (pmg)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        return(pmg + 1);
    }
    else
    {
        return(NULL);
    }
}

HRESULT
_MgMemRealloc(void ** ppv, ULONG cb)
{
    _MgMemValidate();

    if (cb == 0)
    {
        _MgMemFree(*ppv);
        *ppv = 0;
        return(S_OK);
    }

    if (*ppv == NULL)
    {
        *ppv = _MgMemAlloc(cb);
        return(*ppv ? S_OK : E_OUTOFMEMORY);
    }

    MGGUARD *  pmg = (MGGUARD *)*ppv - 1;

    _MgRemove(pmg);

    HRESULT    hr = _MemRealloc((void **)&pmg, sizeof(MGGUARD) + cb);

    if (hr == S_OK)
    {
        pmg->dw = MGGUARDDATA;

        _MgAdd(pmg);

        *ppv = pmg + 1;
    }

    return(hr);
}

ULONG
_MgMemGetSize(void * pv)
{
    _MgMemValidate();

    if (pv == NULL)
        return(0);
    else
        return(_MemGetSize((MGGUARD *)pv - 1) - sizeof(MGGUARD));
}

void
_MgMemFree(void * pv)
{
    _MgMemValidate();

    if (pv)
    {
        MGGUARD * pmg = (MGGUARD *)pv - 1;
        if (pmg->dw != MGGUARDDATA)
        {
            // The memory guard DWORD was overwritten! Bogus!
#ifdef _M_IX86
            _asm int 3  // To get a proper stacktrace.
#else
            DebugBreak();
#endif
        }
        _MgRemove(pmg);

        _MemFree(pmg);
    }
}

HRESULT
_MgMemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst)
{
    TCHAR *pch;
    size_t cb;

    cb = (_tcsclen(pchSrc) + 1) * sizeof(TCHAR);
    *ppchDst = pch = (TCHAR *)_MgMemAlloc(cb);
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        return S_OK;
    }
}

HRESULT
_MgMemAllocString(ULONG cch, const TCHAR *pchSrc, TCHAR **ppchDest)
{
    TCHAR *pch;
    size_t cb = cch * sizeof(TCHAR);

    *ppchDest = pch = (TCHAR *)_MgMemAlloc(cb + sizeof(TCHAR));
    if (!pch)
        return E_OUTOFMEMORY;
    else
    {
        memcpy(pch, pchSrc, cb);
        pch[cch] = 0;
        return S_OK;
    }
}

HRESULT
_MgMemReplaceString(const TCHAR *pchSrc, TCHAR **ppchDest)
{
    HRESULT hr;
    TCHAR *pch;

    if (pchSrc)
    {
        hr = THR(_MgMemAllocString(pchSrc, &pch));
        if (hr)
            RRETURN(hr);
    }
    else
    {
        pch = NULL;
    }

    _MgMemFreeString(*ppchDest);
    *ppchDest = pch;

    return S_OK;
}

#endif // MEMGUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\main\mttf.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define IDD_SIGNON  100
#define IDD_EVENT   200

#define IDB_HELP    666


#define IDS_NORMAL  IDD_SIGNON+1
#define IDS_WARM    IDD_SIGNON+2
#define IDS_COLD    IDD_SIGNON+3

#define IDE_DISABLE IDD_EVENT+1

#define MAX_DIR     128
#define MAX_NAME    16
#define MAX_BUILD_W 4
#define MAX_MEM_W   8
#define MAX_DATETIME 20


typedef struct {
    DWORD Version;
    DWORD Idle;
    DWORD Busy;
    DWORD PercentTotal;
    DWORD Warm;
    DWORD Cold;
    DWORD Other;
    DWORD IdleConsec;
    } StatFileRecord;

typedef struct {
    CHAR MachineName[MAX_NAME];
    CHAR Tab1;
    CHAR MachineType;
    CHAR Tab2;
    CHAR Build[MAX_BUILD_W];
    CHAR Tab3;
    CHAR Mem[MAX_MEM_W];
    CHAR Tab4;
    CHAR UserName[MAX_NAME];
    CHAR Tab5;
    CHAR DateAndTime[MAX_DATETIME];
    CHAR CRLF[2];
    } NameFileRecord;

typedef enum {
    MTTF_TIME,
    MTTF_WARM,
    MTTF_COLD,
    MTTF_OTHER
    } StatType;


#define UNKNOWN_CPU 'U'
#define X86_CPU     'X'
#define MIP_CPU     'M'
#define AXP_CPU     'A'
#define PPC_CPU     'P'


VOID IncrementStats(StatType stattype);
VOID ReadIniFile();
INT_PTR SignonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR EventDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\main\mttf.c ===
/****************************************************************************

    PROGRAM: mttf.c

    AUTHOR:  Lars Opstad (LarsOp) 3/16/93

    PURPOSE: NT Mean-time-to-failure reporting tool.

    FUNCTIONS:

        WinMain() - check for local file, read ini file and display dialogs
        SignonDlgProc() - processes messages for signon dialog
        EventDlgProc() - processes messages for event (other problem) dialog

    COMMENTS:

        This program displays 2 dialog boxes to prompt the user for
        what type of problem occurred.

        Every polling period, the time in the mttf data file is updated
        (as either busy or idle based on percent of cpu usage).  If a machine
        is idle for more than 4 hrs, the "gone" field is increased by the time
        gone.  Whenever the program starts, the user is prompted for why they
        rebooted or logged off.  Other problems should be logged as they happen.

        If any machine can not access the server file for some reason, the
        data is stored in c:\mttf.dat until the next time the server file is
        opened.  At such a time, the server file is updated and the local file
        is deleted.

****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "mttf.h"      /* specific to this program */

//
// For internal use, include header for NetMessageBufferSend and set up
// alert name and unicode buffers for NetMessageBufferSend.
//
#ifndef CUSTOMER

#include <lm.h>
#define AlertName "DavidAn"
WCHAR   UniAlertName[16];
WCHAR   UnicodeBuffer[1024];

#endif

#define IniFileName "Mttf.ini"
#define LocalFileName "c:\\mttf.dat"


#define DEFAULT_IDLE_LIMIT 10
#define DEFAULT_POLLING_PERIOD 30

#define CONSEC_IDLE_LIMIT 4*60
#define POLLING_PRODUCT 60000
#define HUNDREDNS_TO_MS 10000
#define MAX_RETRIES 10

HANDLE  hInst;       // current instance
HWND    hCopying;    // handle to copying dialog box
DWORD   PollingPeriod  = DEFAULT_POLLING_PERIOD;
DWORD   IdlePercentage = DEFAULT_IDLE_LIMIT;
char    ResultsFile[MAX_DIR], NameFile[MAX_DIR];
BOOL    Enabled=TRUE;
BOOL    LocalExists=FALSE;
DWORD   Version;
DWORD   ConsecIdle=0;
SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
SYSTEM_PERFORMANCE_INFORMATION PreviousPerfInfo;

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:  Check for local file, read ini file and display dialogs.

    COMMENTS:

        Check to see if local data file exists and set flag appropriately.
        Initialize the performance information.
        Read the IniFile.
        Display signon dialog.
        Display event dialog (minimized).

****************************************************************************/

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    OFSTRUCT ofstruct;

    hInst = hInstance;

    //
    // Check for local file (if exists, write it to server at next opportunity)
    //
    LocalExists=(HFILE_ERROR!=OpenFile(LocalFileName, &ofstruct, OF_EXIST));

    //
    // Initialize performance information
    //
    Version=GetVersion();
    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    //
    // Read ini file
    //
    ReadIniFile();

//
// For Internal use, convert alert name to unicode for NetMessageBufferSend.
//
#ifndef CUSTOMER

    MultiByteToWideChar(CP_ACP, MB_COMPOSITE, AlertName, sizeof(UniAlertName)/2, UniAlertName, sizeof(UniAlertName)/2);

#endif

    //
    // Display signon dlg
    //
    DialogBox(hInstance, (LPCSTR)IDD_SIGNON, NULL, SignonDlgProc);

    //
    // Display event dialog
    //
    DialogBox(hInstance, (LPCSTR) IDD_EVENT, NULL, EventDlgProc);

    return(0);

} // WinMain()

/*****************************************************************************

    FUNCTION: ReadIniFile ( )

    PURPOSE:  Read values from INI file using GetPrivateProfileString/Int

    COMMENTS:

        This reads entries from the mttf.ini file (in windows nt directory)
        for NameFile, ResultsFile, PollingPeriod and IdlePercent.  Any non-
        existent entry returns a default.

*****************************************************************************/
VOID
ReadIniFile (
   )
{
    GetPrivateProfileString("Mttf",
                            "NameFile",
                            "",
                            NameFile,
                            MAX_DIR,
                            IniFileName);

    GetPrivateProfileString("Mttf",
                            "ResultsFile",
                            "",
                            ResultsFile,
                            MAX_DIR,
                            IniFileName);

    PollingPeriod = GetPrivateProfileInt("Mttf",
                                         "PollingPeriod",
                                         DEFAULT_POLLING_PERIOD,
                                         IniFileName);

    IdlePercentage = GetPrivateProfileInt("Mttf",
                                          "IdlePercent",
                                          DEFAULT_IDLE_LIMIT,
                                          IniFileName);

}

/****************************************************************************

    FUNCTION: DWORD CpuUsage ( )

    PURPOSE:  Returns percentage of cpu usage for last polling period.

    COMMENTS:

        Computes time spent in the idle thread.

        Divides this number by the number of 100nanoseconds in a millisecond.
        (This division is to prevent over-flows in later computations.)

        Returns 100-PercentIdle to get percent busy.

****************************************************************************/
DWORD
CpuUsage(
    )
{
    LARGE_INTEGER EndTime, BeginTime, ElapsedTime;
    DWORD PercentIdle, Remainder;
    PreviousPerfInfo = PerfInfo;

    //
    // Get current perf info
    //
    NtQuerySystemInformation(
        SystemPerformanceInformation,
        &PerfInfo,
        sizeof(PerfInfo),
        NULL
        );

    //
    // Get times from PerfInfo and PreviousPerfInfo
    //
    EndTime = *(PLARGE_INTEGER)&PerfInfo.IdleProcessTime;
    BeginTime = *(PLARGE_INTEGER)&PreviousPerfInfo.IdleProcessTime;

    //
    // Convert from 100 NS to Milliseconds
    //
    EndTime = RtlExtendedLargeIntegerDivide(EndTime, HUNDREDNS_TO_MS, &Remainder);
    BeginTime = RtlExtendedLargeIntegerDivide(BeginTime, HUNDREDNS_TO_MS, &Remainder);

    //
    // Compute elapsed time and percent idle
    //
    ElapsedTime = RtlLargeIntegerSubtract(EndTime,BeginTime);
    PercentIdle = (ElapsedTime.LowPart) / ((POLLING_PRODUCT/100)*PollingPeriod);

    //
    //  Sometimes it takes significantly longer than PollingPeriod
    //  to make a round trip.
    //

    if ( PercentIdle > 100 ) {

        PercentIdle = 100;
    }

    //
    // return cpuusage (100-PercentIdle)
    //
    return 100-PercentIdle;

}

/****************************************************************************

    FUNCTION: IncrementStats (StatType)

    PURPOSE:  Increments the specified stat and writes new data to mttf.dat.

    COMMENTS:

        Increment the specified stat.  For MTTF_TIME, check if it is busy
        or idle by comparing the CpuUsage to IdlePercentage.  If a machine
        is idle for 4 hrs consecutively, first time this is true set the
        IdleConsec stat to the total ConsecIdle value, otherwise set to
        polling period.  (IdleConsec should never exceed Idle.)

        Open mttf.dat.  If opening the server fails (10 times), open the
        local data file.  If server opened and local file also exists,
        open local file also for transfer.

        Search through data file for matching build number, add all values
        and write new record.  (Continue until local file is gone if
        transferring.)

****************************************************************************/
VOID
IncrementStats(
    StatType stattype
    )
{
    HANDLE         fhandle,localHandle;
    StatFileRecord newRec, curRec;
    DWORD          numBytes;
    BOOL           localToServer=FALSE;
    CHAR           buffer[1024];
    int i;

    //
    // Initialize all values to zero
    //
    memset(&newRec, 0, sizeof(newRec));

    newRec.Version=Version;

    //
    // Increment the appropriate stat.
    //
    switch (stattype) {

        //
        // MTTF_TIME stat: Get cpu usage and set idle/busy and percent fields.
        //
        // If idle for more than CONSEC_IDLE_LIMIT, Set IdleConsec.
        // If difference is less than polling period (first time), set to total
        // ConsecIdle; otherwise, just PollingPeriod.
        //
        case MTTF_TIME:
            //
            // Has the CPU been "busy"?
            //
            if ((newRec.PercentTotal=CpuUsage()) > IdlePercentage) {
                //
                // Yes, set busy to polling period and clear ConsecIdle.
                //
                newRec.Busy = PollingPeriod;
                ConsecIdle=0;

            } else {
                //
                // No, not busy, increment consec idle by PollingPeriod.
                // (Set value of idle to polling period.)
                //
                // If ConsecIdle is greater than IDLE_LIMIT, set IdleConsec.
                // If first time, set IdleConsec to ConsecIdle, else PollingPer.
                //
                ConsecIdle+=(newRec.Idle = PollingPeriod);
                if (ConsecIdle>=CONSEC_IDLE_LIMIT) {
                    if (ConsecIdle < CONSEC_IDLE_LIMIT + PollingPeriod) {
                        newRec.IdleConsec=ConsecIdle;
                    } else {
                        newRec.IdleConsec=PollingPeriod;
                    }
                }
            }
            //
            // Weight PercentTotal by number of minutes in polling period.
            //
            newRec.PercentTotal *= PollingPeriod;
            break;

        //
        // MTTF_COLD: Set cold boot count to 1
        //
        case MTTF_COLD:
            newRec.Cold = 1;
            break;
        //
        // MTTF_WARM: Set warm boot count to 1
        //
        case MTTF_WARM:
            newRec.Warm = 1;
            break;
        //
        // MTTF_OTHER: Set other problem count to 1
        //
        case MTTF_OTHER:
            newRec.Other = 1;
            break;
        default:
            ;
    }

    //
    // If there is a ResultsFile name entered in the INI file,
    //
    if (ResultsFile[0]) {

        //
        // Try to open the server file (MAX_RETRIES times).
        //
        for (i=0;i<MAX_RETRIES;i++) {
            if (INVALID_HANDLE_VALUE!=(fhandle = CreateFile(ResultsFile,
                                                 GENERIC_READ|GENERIC_WRITE,
                                                 FILE_SHARE_READ,
                                                 NULL,
                                                 OPEN_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL,
                                                 NULL))) {
                break;
            }
            Sleep(500); // wait a half second if it failed.
        }
    } else {
        //
        // If ResultsFile name is blank, set i to MAX_RETRIES to force open
        // of local data file.
        //
        i=MAX_RETRIES;
    }

    //
    // If i is MAX_RETRIES, server file failed to open, so open local file.
    //
    if (i==MAX_RETRIES) {
        if (INVALID_HANDLE_VALUE==(fhandle = CreateFile(LocalFileName,
                                             GENERIC_READ|GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL))) {
            return;
        }
        LocalExists=TRUE;          // Set flag to indicate local file exists
    } else {
        //
        // If the server file opened and the local file exists, open local for
        // transfer (indicated by localToServer).
        //
        if (LocalExists) {
            localToServer=TRUE;
            if (INVALID_HANDLE_VALUE==(localHandle = CreateFile(LocalFileName,
                                                     GENERIC_READ,
                                                     FILE_SHARE_READ,
                                                     NULL,
                                                     OPEN_ALWAYS,
                                                     FILE_ATTRIBUTE_NORMAL,
                                                     NULL))) {
                localToServer=FALSE;
                return;
            }
        }
    }

    //
    // Outer loop is to continue searching in case of transferring local
    // file to server.
    //
    do {
        //
        // Loop through data file until versions match or end of file found.
        //
        while (1) {

            //
            // If ReadFile fails, close files (and send message if internal).
            //
            if (!ReadFile(fhandle, &curRec, sizeof(curRec), &numBytes, NULL)) {

                CloseHandle(fhandle);

                if (localToServer) {
                    CloseHandle(localHandle);
                    DeleteFile(LocalFileName);
                    LocalExists=FALSE;
                }

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\nPlease rename file.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                return;
            }

            //
            // If numBytes is 0, end of file reached; break out of while to
            // add a new record.
            //
            if (numBytes==0) {
                break;
            }

            //
            // If numBytes is not record size, report an error and close files.
            //
            // Reporting is a local message box for customers and a popup internally.
            //
            if (numBytes != sizeof(curRec)) {

#ifdef CUSTOMER

                sprintf(buffer,
                       "Error reading %s (error code %ld).\n\nPlease have "
                       "your administrator rename the file and contact "
                       "Microsoft regarding the Mttf (mean time to failure) "
                       "reporting tool.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());


                MessageBox(NULL, buffer, "Read File Error", MB_OK|MB_ICONHAND);

#else

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\n(Byte count wrong.) Please rename file.",
                       //
                       // If the local file exists and not transferring,
                       // local file is open; otherwise, server file.
                       //
                       (LocalExists & !localToServer ? LocalFileName : ResultsFile),
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                CloseHandle(fhandle);

                if (localToServer) {
                    CloseHandle(localHandle);
                    DeleteFile(LocalFileName);
                    LocalExists=FALSE;
                }
                return;
            }

            //
            // If Versions match, increment all other stats, rewind file and
            // break out of while to do write.
            //
            if (curRec.Version==newRec.Version) {
                newRec.Idle         += curRec.Idle;
                newRec.IdleConsec   += curRec.IdleConsec;
                newRec.Busy         += curRec.Busy;
                newRec.PercentTotal += curRec.PercentTotal;
                newRec.Warm         += curRec.Warm;
                newRec.Cold         += curRec.Cold;
                newRec.Other        += curRec.Other;
                SetFilePointer(fhandle, -(LONG)sizeof(curRec), NULL, FILE_CURRENT);
                break;
            }
        }

        //
        // Write newRec at current location (end of file for new record)
        //
        WriteFile(fhandle, &newRec, sizeof(newRec), &numBytes, NULL);

        //
        // if transferring from local to server, read the next record from
        // the local file, rewind data file and loop again until end of
        // (local) file.
        //
        if (localToServer) {
            //
            // If ReadFile fails, close files (and send popup internally)
            //
            if (!ReadFile(localHandle, &newRec, sizeof(curRec), &numBytes, NULL)) {

                CloseHandle(fhandle);
                CloseHandle(localHandle);
                LocalExists=FALSE;
                DeleteFile(LocalFileName);

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\nLocal file access failed...data will be lost.",
                       LocalFileName,
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                return;

            }

            if (numBytes==0) {
                //
                // Done transferring, close both files, delete local and set
                // LocalExists and localToServer to FALSE.
                //
                CloseHandle(localHandle);
                DeleteFile(LocalFileName);
                LocalExists=localToServer=FALSE;
                CloseHandle(fhandle);
                return;
            }

            //
            // if numBytes is not record size, close files (and send popup internally)
            //
            if (numBytes != sizeof(curRec)) {

#ifndef CUSTOMER

                sprintf(buffer,
                       "Mttf error reading %s (error code %ld).\n(Byte count wrong.) Data will be lost.",
                       LocalFileName,
                       GetLastError());

                MultiByteToWideChar(CP_ACP, MB_COMPOSITE, buffer, sizeof(buffer), UnicodeBuffer, sizeof(UnicodeBuffer)/2);

                NetMessageBufferSend(NULL, UniAlertName, NULL, (LPBYTE)UnicodeBuffer, 2 * strlen(buffer));

#endif

                CloseHandle(fhandle);
                CloseHandle(localHandle);
                DeleteFile(LocalFileName);
                LocalExists=FALSE;
                return;

            }

            SetFilePointer(fhandle,0, NULL, FILE_BEGIN);
        } else {
            //
            // If not transferring, close file and exit
            //
            CloseHandle(fhandle);
            return;
        }
    } while (localToServer);

}

/****************************************************************************

    FUNCTION: CheckAndAddName ( )

    PURPOSE:  Checks name file for machine name and build number at startup.

    COMMENTS:

        Writes various system info to name file if the machine doesn't have
        an entry for this build.  This was an add-on to collect info on how
        many machines were actually running NT.

****************************************************************************/
VOID
CheckAndAddName(
    )
{
    NameFileRecord newRec, curRec;
    HANDLE         fhandle;
    DWORD          numBytes,i,ulLength=MAX_NAME;
    DWORD          dwVersion;
    SYSTEMTIME     sysTime;
    MEMORYSTATUS   memstat;
    SYSTEM_INFO    sysinfo;

    //
    // If the NameFile name is blank, exit
    //
    if (0==NameFile[0]) {
        return;
    }

    //
    // Set record to zero.
    //
    memset(&newRec, 0, sizeof(newRec));

    GetComputerName(newRec.MachineName, &ulLength);

    GetSystemInfo(&sysinfo);                    // Get system info

    switch(sysinfo.wProcessorArchitecture) {
        case PROCESSOR_ARCHITECTURE_INTEL:
            newRec.MachineType=X86_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_MIPS:
            newRec.MachineType=MIP_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_ALPHA:
            newRec.MachineType=AXP_CPU;
            break;

        case PROCESSOR_ARCHITECTURE_PPC:
            newRec.MachineType=PPC_CPU;
            break;

        default:
            newRec.MachineType=UNKNOWN_CPU;
            break;
    };

    dwVersion=GetVersion();
    sprintf(newRec.Build, "%3ld", dwVersion>>16);

    memstat.dwLength=sizeof(memstat);
    GlobalMemoryStatus(&memstat);               // Get memory info

    sprintf(newRec.Mem, "%5ldMB",memstat.dwTotalPhys/(1024*1024));

    ulLength=MAX_NAME;

    GetUserName(newRec.UserName, &ulLength);

    GetLocalTime(&sysTime);
    sprintf(newRec.DateAndTime, "%2d/%2d/%4d %2d:%02ld",
            sysTime.wMonth, sysTime.wDay, sysTime.wYear,
            sysTime.wHour, sysTime.wMinute);

    newRec.Tab1=newRec.Tab2=newRec.Tab3=newRec.Tab4=newRec.Tab5=9;
    newRec.CRLF[0]=13;
    newRec.CRLF[1]=10;

    //
    // Try to open NameFile, for shared read access.
    //
    if (INVALID_HANDLE_VALUE==(fhandle = CreateFile(NameFile,
                                         GENERIC_READ,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL))) {
        return;
    }

    //
    // Read each record until a match or end-of-file is encountered.
    //
    while (ReadFile(fhandle, &curRec, sizeof(curRec), &numBytes, NULL)) {
        //
        // At end of file, break out and write new record.
        //
        if (numBytes==0) {
            break;
        }

        //
        // If there is a match, close the file and return.
        //
        if (0==strcmp(curRec.Build, newRec.Build) &&
            0==strcmp(curRec.MachineName, newRec.MachineName)) {
            CloseHandle(fhandle);
            return;
        }
    }
    //
    // Close the name file and try to open it for ExclusiveWrite
    //
    CloseHandle(fhandle);
    for (i=0;i<MAX_RETRIES;i++) {
        if (INVALID_HANDLE_VALUE!=(fhandle = CreateFile(NameFile,
                                             GENERIC_READ|GENERIC_WRITE,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_ALWAYS,
                                             FILE_ATTRIBUTE_NORMAL,
                                             NULL))) {
            break;
        }
        Sleep(500);            // wait if open failed.
    }

    //
    // If open succeeded, go to the end of file and write newRec.
    //
    if (i<MAX_RETRIES) {
        SetFilePointer(fhandle, 0, &numBytes, FILE_END);
        WriteFile(fhandle, &newRec, sizeof(newRec), &numBytes, NULL);
        CloseHandle(fhandle);
    }
}


/****************************************************************************

    FUNCTION: SignonDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for signon dialog.

    COMMENTS: The signon dialog

        WM_INITDIALOG: Checks machine name in name file and sets focus.

        WM_COMMAND:    Process the button press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box

****************************************************************************/
INT_PTR
SignonDlgProc(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message)
    {
        case WM_INITDIALOG:   // Checks machinename in namefile and sets focus

            CheckAndAddName();

            CheckRadioButton(hDlg, IDS_NORMAL, IDS_COLD, IDS_NORMAL);
            return (TRUE);

        case WM_COMMAND:        // command: button pressed

            switch (wParam)     // which button
            {
            //
            // OK: Update the appropriate stat if not "Normal Boot"
            //
            case IDOK:
            case IDCANCEL:

                if (IsDlgButtonChecked(hDlg, IDS_WARM)) {
                    IncrementStats(MTTF_WARM);
                } else {
                    if (IsDlgButtonChecked(hDlg, IDS_COLD)) {
                        IncrementStats(MTTF_COLD);
                    }
                }
                EndDialog(hDlg, TRUE);
                return (TRUE);

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "The app should be placed in your start-up group and "
                            "you should respond accurately (if there was a problem) "
                            "on startup.  When you encounter other problems -- where "
                            "the system did not require a reboot, but encountered "
                            "anything you consider a problem -- double-click on the "
                            "Mttf icon and press the Other Problem button.\n\n"
                            "When you are running some test that is outside of the "
                            "realm of normal usage (e.g. Stress), please disable Mttf "
                            "by double-clicking the icon and pressing disable.  When "
                            "you are done with this test, please press the Enable "
                            "button to continue reporting.",
                            "Mean Time to Failure Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // SignonDlgProc()

/****************************************************************************

    FUNCTION: EventDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Processes timer and button events (disable and other problems).

    COMMENTS: Processes the following messages:

        WM_INITDIALOG: Minimize dialog and start timer
        WM_CLOSE...:   End app
        WM_TIMER:      Update Time stat (busy or idle)

        WM_COMMAND:    Process the button press:
            IDOK:        Log Other problem (and minimize).
            IDCANCEL:    Minimize without action.
            IDE_DISABLE: Disable or enable mttf reporting.
            IDB_HELP:    Descriptive message box.


****************************************************************************/
INT_PTR
EventDlgProc(
     HWND hDlg,
     UINT message,
     WPARAM wParam,
     LPARAM lParam
     )
{
    switch (message)
    {
        case WM_INITDIALOG:     // minimize and start timer

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)LoadIcon(hInst,"mttf"));
            SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);
            SetTimer(hDlg, 1, POLLING_PRODUCT*PollingPeriod, NULL);
            break;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:

            EndDialog(hDlg,0);
            break;

        case WM_TIMER:
            IncrementStats(MTTF_TIME);
            break;

        case WM_COMMAND:           // button was pressed
            switch(LOWORD(wParam)) // which one
            {
            //
            // OK: Other problem encountered increment # of others.
            //
            case IDOK:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);

                IncrementStats(MTTF_OTHER);
                break;

            //
            // DISABLE: Disable/Enable Mttf polling.
            //
            case IDE_DISABLE:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);

                //
                // Based on whether enabling or disabling, change button and window title
                //
                if (Enabled) {
                    SetWindowText((HWND) lParam,"&Enable Mttf Reporting");
                    SetWindowText(hDlg, "Mttf (Disabled)");
                    KillTimer(hDlg, 1);
                    Enabled = FALSE;
                } else {
                    SetWindowText((HWND) lParam,"&Disable Mttf Reporting");
                    SetWindowText(hDlg, "Mttf (Enabled)");
                    SetTimer(hDlg, 1, POLLING_PRODUCT*PollingPeriod, NULL);
                    NtQuerySystemInformation(
                        SystemPerformanceInformation,
                        &PerfInfo,
                        sizeof(PerfInfo),
                        NULL
                        );
                    Enabled = TRUE;
                }

                break;

            //
            // CANCEL: Minimize app (no problem)
            //
            case IDCANCEL:

                SendMessage(hDlg, WM_SYSCOMMAND, SC_ICON, 0);
                return (TRUE);


            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "The app should be placed in your start-up group and "
                            "you should respond accurately (if there was a problem) "
                            "on startup.  When you encounter other problems -- where "
                            "the system did not require a reboot, but encountered "
                            "anything you consider a problem -- double-click on the "
                            "Mttf icon and press the Other Problem button.\n\n"
                            "When you are running some test that is outside of the "
                            "realm of normal usage (e.g. Stress), please disable Mttf "
                            "by double-clicking the icon and pressing disable.  When "
                            "you are done with this test, please press the Enable "
                            "button to continue reporting.",
                            "Mean Time to Failure Help",
                            MB_OK
                           );
                return (TRUE);

            default:
               ;
            } // switch (LOWORD(wParam))

            break;

        default:
            ;
    } // switch (message)
    return FALSE;

} // EventDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\cmnds.h ===
/* File: cmnds.h */
/**************************************************************************/
/*	Install: Commands Header File.
/**************************************************************************/

#include <comstf.h>


/*** REVIEW: put the following in common lib? ***/

/* for mkdir, rmdir */
#include <direct.h>
#include <errno.h>

/* for chmod */
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

/* for rename */
#include <stdio.h>

_dt_system(Install)

#define szNull ((SZ)NULL)

/*	Returns the number of lines in the given section
*/
#define CLinesFromInfSection(szSect)	CKeysFromInfSection((szSect), fTrue)

/*	Renames a file
*/
#define FRenameFile(szSrc, szDst) \
	((rename((char *)(szSrc), (char *)(szDst)) == 0) ? fTrue : fFalse)

/*	Write protects a file
*/
#define FWriteProtectFile(szPath) \
	((chmod((char *)(szPath), S_IREAD) == 0) ? fTrue : fFalse)

/*	Creates a directory
*/
#define FMkDir(szDir) \
	(((mkdir((char *)(szDir)) == 0) || (errno == EACCES)) ? fTrue : fFalse)

/*	Removes a directory
*/
#define FRmDir(szDir) \
	(((rmdir((char *)(szDir)) == 0) || (errno == ENOENT)) ? fTrue : fFalse)

/*** END REVIEW ***/


/*	CoMmand Options
*/
_dt_private typedef BYTE CMO;
#define cmoVital     1
#define cmoOverwrite 2
#define cmoAppend    4
#define cmoPrepend   8
#define cmoNone   0x00
#define cmoAll    0xFF

  /* filecm.c */
extern BOOL  APIENTRY FCopyFilesInCopyList(HANDLE);
extern BOOL  APIENTRY FBackupSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FBackupSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FBackupNthSectionFile(SZ, USHORT, SZ);
extern BOOL  APIENTRY FRemoveSectionFiles(SZ, SZ);
extern BOOL  APIENTRY FRemoveSectionKeyFile(SZ, SZ, SZ);
extern BOOL  APIENTRY FRemoveNthSectionFile(SZ, USHORT, SZ);
extern BOOL  APIENTRY FCreateDir(SZ, CMO);
extern BOOL  APIENTRY FRemoveDir(SZ, CMO);

/* inicm.c */
extern BOOL  APIENTRY FCreateIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniSection(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniSection(SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyNoValue(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FReplaceIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAppendIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FRemoveIniKey(SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FCreateSysIniKeyValue(SZ, SZ, SZ, SZ, CMO);
extern BOOL  APIENTRY FAddDos5Help(SZ, SZ, CMO);


/* progcm.c */
extern BOOL  APIENTRY FCreateProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManGroup(SZ, CMO, BOOL);
extern BOOL  APIENTRY FShowProgManGroup(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FCreateProgManItem(SZ, SZ, SZ, SZ, INT, CMO, BOOL);
extern BOOL  APIENTRY FRemoveProgManItem(SZ, SZ, CMO, BOOL);
extern BOOL  APIENTRY FInitProgManDde(HANDLE);
extern BOOL  APIENTRY FEndProgManDde(VOID);

/* misccm.c */

extern BOOL  APIENTRY FSetEnvVariableValue(SZ, SZ, SZ, CMO);
#ifdef UNUSED
extern BOOL  APIENTRY FAddMsgToSystemHelpFile(SZ, SZ, CMO);
#endif /* UNUSED */
extern BOOL  APIENTRY FStampFile(SZ, SZ, SZ, WORD, WORD, SZ, WORD);
extern BOOL  APIENTRY FStampResource(SZ, SZ, SZ, WORD, WORD, SZ, CB);  // 1632

/* extprog.c */

       BOOL FLoadLibrary(SZ DiskName,SZ File,SZ INFVar);
       BOOL FFreeLibrary(SZ INFVar);
       BOOL FLibraryProcedure(SZ INFVar,SZ HandleVar,SZ EntryPoint,RGSZ Args);
       BOOL FRunProgram(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FStartDetachedProcess(SZ,SZ,SZ,SZ,RGSZ);
       BOOL FInvokeApplet(SZ);

/* event.c */
       BOOL FWaitForEvent(IN LPSTR InfVar,IN LPSTR EventName,IN DWORD Timeout);
       BOOL FSignalEvent(IN LPSTR InfVar,IN LPSTR EventName);
       BOOL FSleep(IN DWORD Milliseconds);

/* registry.c */

#define REGLASTERROR    "RegLastError"

       BOOL FCreateRegKey( SZ szHandle, SZ szKeyName, UINT TitleIndex, SZ szClass,
                           SZ Security, UINT Access, UINT Options, SZ szNewHandle,
                           CMO cmo );
       BOOL FOpenRegKey( SZ szHandle, SZ szMachineName, SZ szKeyName, UINT Access, SZ szNewHandle, CMO cmo );
       BOOL FFlushRegKey( SZ szHandle, CMO cmo );
       BOOL FCloseRegKey( SZ szHandle, CMO cmo );
       BOOL FDeleteRegKey( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FDeleteRegTree( SZ szHandle, SZ szKeyName, CMO cmo );
       BOOL FEnumRegKey( SZ szHandle, SZ szInfVar, CMO cmo );
       BOOL FSetRegValue( SZ szHandle, SZ szValueName, UINT TitleIndex, UINT ValueType,
                          SZ szValueData, CMO cmo );
       BOOL FGetRegValue( SZ szHandle, SZ szValueName, SZ szInfVar, CMO cmo );
       BOOL FDeleteRegValue( SZ szHandle, SZ szValueName, CMO cmo );
       BOOL FEnumRegValue( SZ szHandle, SZ szInfVar, CMO cmo );


/* bootini.c */

       BOOL FChangeBootIniTimeout(INT Timeout);


/* restore.c */

       BOOL SaveRegistryHives(PCHAR Drive);
       BOOL GenerateRepairDisk(PCHAR Drive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\comstf.h ===
/************************************************/
/* Common Library Component public include file */
/************************************************/


#if !defined (COMSTF_INCLUDED )

#define COMSTF_INCLUDED

#include <windows.h>

// avoid warnings on every file from including stdlib.h
#if defined(min)
#undef min
#undef max
#endif /* min */

#include <port1632.h>

#define _dt_begin_ignore
#define _dt_end_ignore
_dt_begin_ignore
#define _dt_public
#define _dt_private
#define _dt_hidden
#define _dt_system(s)
#define _dt_subsystem(s)
_dt_end_ignore

#include <ids.h>


_dt_system(Common Library)


/*
**	Global variable macro for DLL portability
*/
_dt_public
#define GLOBAL(x)  (x)


/*	standard datatypes
*/
_dt_public typedef  BYTE *          PB;

_dt_public typedef  unsigned        CB;

_dt_public typedef  LONG *          PLONG_STF;


/*	BOOLean datatype
*/
#define  fFalse  ((BOOL)0)

#define  fTrue   ((BOOL)1)


/*	To avoid compiler warnings for unused parameters
*/
#define  Unused(x)      (x)=(x)


/*  If new GRCs are added, they should as well be handled
	in EercErrorHandler() in ERROR1.C */
/*
**	General Return Code datatype
*/
typedef  USHORT  GRC;

#define  grcFirst                   ((GRC)0)

#define  grcLast                    ((GRC)57)

#define  grcOkay                    ((GRC)0)
#define  grcNotOkay                 ((GRC)1)
#define  grcOutOfMemory             ((GRC)2)
#define  grcInvalidStruct           ((GRC)3)
#define  grcOpenFileErr             ((GRC)4)
#define  grcCreateFileErr           ((GRC)5)
#define  grcReadFileErr             ((GRC)6)
#define  grcWriteFileErr            ((GRC)7)
#define  grcRemoveFileErr           ((GRC)8)
#define  grcRenameFileErr           ((GRC)9)
#define  grcReadDiskErr             ((GRC)10)
#define  grcCreateDirErr            ((GRC)11)
#define  grcRemoveDirErr            ((GRC)12)
#define  grcBadINF                  ((GRC)13)
#define  grcINFStartNonSection      ((GRC)14)
#define  grcINFBadSectionLabel      ((GRC)15)
#define  grcINFBadLine              ((GRC)16)
#define  grcINFBadKey               ((GRC)17)
#define  grcINFContainsZeros        ((GRC)18)
#define  grcTooManyINFSections      ((GRC)19)
#define  grcCloseFileErr            ((GRC)20)
#define  grcChangeDirErr            ((GRC)21)
#define  grcINFSrcDescrSect         ((GRC)22)
#define  grcTooManyINFKeys          ((GRC)23)
#define  grcWriteInf                ((GRC)24)
#define  grcInvalidPoer             ((GRC)25)
#define  grcINFMissingLine          ((GRC)26)
#define  grcINFBadFDLine            ((GRC)27)
#define  grcINFBadRSLine            ((GRC)28)
#define  grcBadInstallLine          ((GRC)29)
#define  grcMissingDidErr           ((GRC)30)
#define  grcInvalidPathErr          ((GRC)31)
#define  grcWriteIniValueErr        ((GRC)32)
#define  grcReplaceIniValueErr      ((GRC)33)
#define  grcIniValueTooLongErr      ((GRC)34)
#define  grcDDEInitErr              ((GRC)35)
#define  grcDDEExecErr              ((GRC)36)
#define  grcBadWinExeFileFormatErr  ((GRC)37)
#define  grcResourceTooLongErr      ((GRC)38)
#define  grcMissingSysIniSectionErr ((GRC)39)
#define  grcDecompGenericErr        ((GRC)40)
#define  grcDecompUnknownAlgErr     ((GRC)41)
#define  grcDecompBadHeaderErr      ((GRC)42)
#define  grcReadFile2Err            ((GRC)43)
#define  grcWriteFile2Err           ((GRC)44)
#define  grcWriteInf2Err            ((GRC)45)
#define  grcMissingResourceErr      ((GRC)46)
#define  grcLibraryLoadErr          ((GRC)47)
#define  grcBadLibEntry             ((GRC)48)
#define  grcApplet                  ((GRC)49)
#define  grcExternal                ((GRC)50)
#define  grcSpawn                   ((GRC)51)
#define  grcDiskFull                ((GRC)52)
#define  grcDDEAddItem              ((GRC)53)
#define  grcDDERemoveItem           ((GRC)54)
#define  grcINFMissingSection       ((GRC)55)
#define  grcRunTimeParseErr         ((GRC)56)
#define  grcOpenSameFileErr         ((GRC)57)

/**************************************/
/* common library function prototypes */
/**************************************/


_dt_subsystem(String Handling)


/*	CHaracter Physical representation datatype
*/
_dt_public typedef  BYTE            CHP;
_dt_public typedef  CHP *           PCHP;
_dt_public typedef  CB              CCHP;

_dt_public
#define  CbFromCchp(cchp)  ((CB)(cchp))


/*	CHaracter Logical representation datatype
*/
_dt_public typedef  CHP             CHL;
_dt_public typedef  CHL *           PCHL;
_dt_public typedef  PCHL *          PPCHL;
_dt_public typedef  CB              CCHL;
_dt_public typedef  CB              ICHL;


_dt_hidden
#define  cbFullPathMax    ((CB)(MAX_PATH-1))
_dt_hidden
#define  cchlFullPathMax  ((CCHL)(MAX_PATH-1))
_dt_hidden
#define  cchlFullDirMax   cchlFullPathMax
_dt_hidden
#define  cchpFullPathMax  ((CCHP)(MAX_PATH-1))


_dt_public
#define  cbFullPathBuf    ((CB)(cbFullPathMax + 1))
_dt_public
#define  cchlFullPathBuf  ((CCHL)(cchlFullPathMax + 1))
_dt_public
#define  cchpFullPathBuf  ((CCHP)(cchpFullPathMax + 1))


/*	String Zero terminated datatype
*/
_dt_public typedef  PCHL   SZ;
_dt_hidden
#define PSZ PPSZ
_dt_public typedef  PPCHL  PSZ;
_dt_public typedef  PPCHL  RGSZ;


/*	Comparison Return Code datatype
*/
_dt_public typedef INT CRC;

_dt_public
#define  crcError         ((CRC)(-2))

_dt_public
#define  crcEqual         ((CRC)0)

_dt_public
#define  crcFirstHigher   ((CRC)1)

_dt_public
#define  crcSecondHigher  ((CRC)(-1))


  /* String manipulation routines */
extern  SZ      APIENTRY SzDupl(SZ);
extern  CRC     APIENTRY CrcStringCompare(SZ, SZ);
extern  CRC     APIENTRY CrcStringCompareI(SZ, SZ);
extern  SZ      APIENTRY SzLastChar(SZ);


/*
**	Purpose:
**		Advances a string pointer to the beginning of the next valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		sz: the string pointer to advance.  It can be NULL or empty, or else
**			it must point at the beginning of a valid character.
**	Returns:
**		NULL if sz was NULL.
**		sz unchanged if it was an empty string (*sz == '\0').
**		sz advanced past the current character and to the beginning of the
**			next valid character.
*/
_dt_public
#define  SzNextChar(sz)            ((SZ)AnsiNext(sz))


/*
**	Purpose:
**		Retreats a string pointer to the beginning of the previous valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		szStart: string pointer to the beginning of a valid character that
**			equals or preceeds the character szCur.
**		szCur:   string pointer to retreat.  It can be NULL or empty, or
**			can point to any byte in a valid character.
**	Returns:
**		NULL if szCur was NULL.
**		sz unchanged if szStart was NULL or if szCur equaled szStart.
**		sz retreated past the current character and to the beginning of the
**			previous valid character.
*/
_dt_public
#define  SzPrevChar(szStart, szCur) ((SZ)AnsiPrev(szStart,szCur))


/*
**	Purpose:
**		Copies a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain enough storage to copy szSrc with its
**			terminating zero character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
_dt_public
#define  SzStrCopy(szDst, szSrc)    ((SZ)lstrcpy((LPSTR)szDst,(LPSTR)szSrc))


/*
**	Purpose:
**		Appends a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain a zero terminated string (can be empty)
**			and enough storage to append szSrc with its terminating zero
**			character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
_dt_public
#define  SzStrCat(szDst, szSrc)     ((SZ)lstrcat((LPSTR)szDst,(LPSTR)szSrc))


/*
**	Purpose:
**		Calculates the number of Physical Characters that a string occupies
**		(not including the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of Physical Characters from the beginning of the string
**			to its terminating zero character.
*/
_dt_public
#define  CchpStrLen(sz)            ((CCHP)CbStrLen(sz))


/*
**	Purpose:
**		Calculates the number of Logical Characters that a string occupies
**		(not including the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of Logical Characters from the beginning of the string
**			to its terminating zero character.
*/
_dt_public
#define  CchlStrLen(sz)            ((CCHL)CbStrLen(sz))


/*
**	Purpose:
**		Calculates the number of bytes that a string occupies (not including
**		the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of bytes from the beginning of the string to its
**			terminating zero character.
*/
_dt_public
#define  CbStrLen(sz)              ((CB)lstrlen((LPSTR)sz))


/*
**	Purpose:
**		Determines whether the current character is a single Physical
**		Character.
**	Arguments:
**		sz: string pointer which can be NULL, empty, or pointing to the
**			beginning of a valid character.
**	Returns:
**		fFalse if sz is NULL or points to the beginning of a multiple
**			Physical Character character.
**		fTrue if sz is empty or points to the beginning of a single
**			Physical Character character.
*/
_dt_public
#define  FSingleByteCharSz(sz)     ((BOOL)((sz)!=(SZ)NULL))


/*
**	Purpose:
**		Determines whether a character is an End-Of-Line character.
**	Arguments:
**		chp: Physical Character (eg a single byte Logical Character).
**	Returns:
**		fFalse if chp is not either a '\n' or a '\r' character.
**		fTrue if chp is either a '\n' or a '\r' character.
*/
_dt_public
#define FEolChp(chp)         ((BOOL)((chp) == '\n' || (chp) == '\r'))


/*
**	Purpose:
**		Determines whether a character is whitespace.
**	Arguments:
**		chp: Physical Character (eg a single byte Logical Character).
**	Returns:
**		fFalse if chp is not either a space or a tab character.
**		fTrue if chp is either a space or a tab character.
*/
_dt_public
#define FWhiteSpaceChp(chp)  ((BOOL)((chp) == ' '  || (chp) == '\t'))


/*
**	Purpose:
**		Converts a zero-terminated string to upper case.
**	Arguments:
**		sz: the string to convert to upper case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
_dt_public
#define SzStrUpper(sz)  (SZ)(AnsiUpper((LPSTR)(sz)))

/*
**	Purpose:
**		Converts a zero-terminated string to lower case.
**	Arguments:
**		sz: the string to convert to lower case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
_dt_public
#define SzStrLower(sz)  (SZ)(AnsiLower((LPSTR)(sz)))


_dt_subsystem(Memory Handling)

#define cbSymbolMax (64*1024)
#define cbAllocMax (65520*5)
#define cbIntStrMax 16


  /* Memory Handling routines */
#if defined(DBG) && defined(MEMORY_CHECK)

        PVOID MyMalloc(unsigned, char *, int) malloc
        PVOID MyRealloc(PVOID,unsigned, char *, int);
        VOID  MyFree(PVOID, char *, int);
        VOID  MemCheck(VOID);
        VOID  MemDump(VOID);

        #define PbAlloc(cb)             ((PB)MyMalloc((unsigned)(cb), __FILE__, __LINE__ ))
        #define PbRealloc(pb,cbn,cbo)   ((PB)MyRealloc(pb,(unsigned)(cbn), __FILE__, __LINE__))
        #define FFree(pb,cb)            (MyFree(pb, __FILE__, __LINE__),TRUE)
        #define MemChk()                MemCheck()

#else  // ! (DBG && MEMORY_CHECK)

        PVOID MyMalloc(unsigned);
        PVOID MyRealloc(PVOID,unsigned);
        VOID  MyFree(PVOID);

        #define PbAlloc(cb)             ((PB)MyMalloc((unsigned)(cb)))
        #define PbRealloc(pb,cbn,cbo)   ((PB)MyRealloc(pb,(unsigned)(cbn)))
        #define FFree(pb,cb)            (MyFree(pb),TRUE)
        #define MemChk()

#endif // DBG && MEMORY_CHECK

/*
**	Purpose:
**		Frees the memory used by an sz.  This assumes the terminating
**		zero occupies the final byte of the allocated buffer.
**	Arguments:
**		sz: the buffer to free.  this must be non-NULL though it can point
**			at an empty string.
**	Returns:
**		fTrue if the Free() operation succeeds.
**		fFalse if the Free() operation fails.
*/
_dt_public
#define FFreeSz(sz)         FFree((PB)(sz),CbStrLen(sz)+1)


/*
**	Purpose:
**		Shrinks a buffer to exactly fit a string.
**	Arguments:
**		sz: the string for which the buffer should shrink to.  sz must be
**			non-NULL though it can be empty.
**		cb: the size in bytes for the buffer that was originally allocated.
**			cb must be greater than or equal to CbStrLen(sz) + 1.
**	Returns:
**		A pointer to the original string if the Realloc() operation succeeds.
**		NULL if the Realloc() operation fails.
*/
_dt_public
#define SzReallocSz(sz,cb)  (SZ)(PbRealloc((PB)(sz),CbStrLen(sz)+1,cb))


#ifdef MEM_STATS
/* Memory Stats Flags */
_dt_private
#define  wModeMemStatNone       0x0000
_dt_private
#define  wModeMemStatAll        0xFFFF

_dt_private
#define  wModeMemStatAlloc      0x0001
_dt_private
#define  wModeMemStatFree       0x0002
_dt_private
#define  wModeMemStatRealloc    0x0004
_dt_private
#define  wModeMemStatSysAlloc   0x0008
_dt_private
#define  wModeMemStatFLAlloc    0x0010
_dt_private
#define  wModeMemStatFLFree     0x0020
_dt_private
#define  wModeMemStatFLRealloc  0x0040
_dt_private
#define  wModeMemStatHistAlloc  0x0080
_dt_private
#define  wModeMemStatHistFree   0x0100
_dt_private
#define  wModeMemStatGarbage    0x0200

extern  BOOL    APIENTRY FOpenMemStats(SZ, WORD);
extern  BOOL    APIENTRY FCloseMemStats(void);
#endif /* MEM_STATS */



_dt_subsystem(File Handling)


/*	Long File Address datatype
*/
_dt_public typedef unsigned long LFA;

_dt_public
#define  lfaSeekError   ((LFA)-1)


/*
**	File Handle structure
**	Fields:
**		iDosfh: DOS file handle.
**		ofstruct: OFSTRUCT used when the file was opened.
*/
_dt_public typedef struct _fh
	{
	INT      iDosfh;
	OFSTRUCT ofstruct;
	} FH;


/*	File Handle datatype
*/
_dt_public typedef  FH *  PFH;


/*	Open File Mode datatype
*/
_dt_public typedef USHORT OFM;

_dt_public
#define  ofmExistRead      ((OFM)OF_EXIST | OF_READ)
_dt_public
#define  ofmExistReadWrite ((OFM)OF_EXIST | OF_READWRITE)

// _dt_public
// #define  ofmRead           ((OFM)OF_READ | OF_SHARE_DENY_WRITE)

_dt_public
#define  ofmRead           ((OFM)OF_READ)
_dt_public
#define  ofmWrite          ((OFM)OF_WRITE | OF_SHARE_EXCLUSIVE)
_dt_public
#define  ofmReadWrite      ((OFM)OF_READWRITE | OF_SHARE_EXCLUSIVE)
_dt_public
#define  ofmCreate         ((OFM)OF_CREATE | OF_SHARE_EXCLUSIVE)


/*	Seek File Mode datatype
*/
_dt_public typedef WORD SFM;

_dt_public
#define  sfmSet   ((SFM)0)

_dt_public
#define  sfmCur   ((SFM)1)

_dt_public
#define  sfmEnd   ((SFM)2)


  /* File handling routines */
extern  PFH     APIENTRY PfhOpenFile(SZ, OFM);
extern  BOOL    APIENTRY FCloseFile(PFH);
extern  CB      APIENTRY CbReadFile(PFH, PB, CB);
extern  CB      APIENTRY CbWriteFile(PFH, PB, CB);
extern  LFA     APIENTRY LfaSeekFile(PFH, LONG, SFM);
extern  BOOL    APIENTRY FEndOfFile(PFH);
extern  BOOL    APIENTRY FRemoveFile(SZ);
extern  BOOL    APIENTRY FWriteSzToFile(PFH, SZ);
extern  BOOL    APIENTRY FFileExists(SZ);
extern  SZ      APIENTRY szGetFileName(SZ szPath);
extern  VOID    APIENTRY FreePfh(PFH pfh);



_dt_subsystem(Path Handling)


  /* Path manipulation routines */

BOOL  FMakeFATPathFromPieces(SZ, SZ, SZ, SZ, CCHP);
BOOL  FMakeFATPathFromDirAndSubPath(SZ, SZ, SZ, CCHP);
LPSTR LocateFilenameInFullPathSpec(LPSTR);

#define FValidFATDir(sz)        fTrue
#define FValidFATPath(sz)       fTrue
#define CchlValidFATSubPath(sz) CbStrLen(sz)        // no checking for WIN32


/*
**	Purpose:
**		Determines if a path is a valid FAT directory.
**	Arguments:
**		szDir: the directory string to check.
**	Returns:
**		fTrue if the szDir is a valid FAT directory.
**		fFalse if the szDir is an invalid FAT directory.
*/
_dt_public
#define  FValidDir(szDir)  FValidFATDir(szDir)


/*
**	Purpose:
**		Determines if a string is a valid FAT SubPath (eg subdirs and filename).
**	Arguments:
**		szSubPath: the SubPath string to check.
**	Returns:
**		zero if the string is an invalid FAT subPath.
**		non-zero count of characters in sz if it is a valid FAT subPath.
*/
_dt_public
#define  CchlValidSubPath(szSubPath)  CchlValidFATSubPath(szSubPath)


/*
**	Purpose:
**		Determines if a path is a valid FAT path.
**	Arguments:
**		szPath: the path to check.
**	Returns:
**		fTrue if the szPath is a valid FAT path.
**		fFalse if the szPath is an invalid FAT path.
*/
_dt_public
#define  FValidPath(szPath)  FValidFATPath(szPath)


/*
**	Purpose:
**		Creates a valid path from volume, path, and filename arguments
**		if possible and stores it in a supplied buffer.
**	Arguments:
**		szVolume:   string containing the volume.
**		szPath:     string containing the path.
**		szFile:     string containing the filename.
**		szBuf:      the buffer in which to store the newly created path.
**		cchpBufMax: the maximum number of physical characters (including the
**			terminating zero) that can be stored in the buffer.
**	Returns:
**		fTrue if a valid FAT path can be created and stored in szBuf.
**		fFalse if szVolume is NULL or invalid (first character must be in the
**			'a' to 'z' or 'A' to 'Z', and the second character must be either
**			a ':' or a terminating zero), if szPath is NULL or invalid (it must
**			start with a '\\' and conform to 8.3 format), if szFile is NULL,
**			empty or invalid (first character cannot be a '\\' and it must
**			conform to 8.3 format), if szBuf is NULL, or if cchpBufMax is not
**			large enough to hold the resultant path.
*/
_dt_public
#define  FMakePathFromPieces(szVolume, szPath, szFile, szBuffer, cchpBufMax) \
			FMakeFATPathFromPieces(szVolume,szPath,szFile,szBuffer,cchpBufMax)


/*
**	Purpose:
**		Creates a valid path from subpath, and filename arguments if possible
**		and stores it in a supplied buffer.
**	Arguments:
**		szDir:      string containing the volume and subdirs.
**		szSubPath:  string containing subdirs and the filename.
**		szBuf:      the buffer in which to store the newly created path.
**		cchpBufMax: the maximum number of physical characters (including the
**			terminating zero) that can be stored in the buffer.
**	Returns:
**		fTrue if a valid FAT path can be created and stored in szBuf.
**		fFalse if szDir is NULL or invalid (first character must be in the
**			'a' to 'z' or 'A' to 'Z', the second character must be either
**			a ':' or a terminating zero, and the third character must be
**			a '\\' and the rest must conform to 8.3 format), if szSubPath is
**			NULL, empty or invalid (first character cannot be a '\\' and it must
**			conform to 8.3 format), if szBuf is NULL, or if cchpBufMax is not
**			large enough to hold the resultant path.
*/
_dt_public
#define  FMakePathFromDirAndSubPath(szDir, szSubPath, szBuffer, cchpBufMax) \
			FMakeFATPathFromDirAndSubPath(szDir,szSubPath,szBuffer,cchpBufMax)




#define AssertDataSeg()

#if DBG

#define  Assert(f)              \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  AssertRet(f, retVal)   \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  EvalAssert(f)          \
         ((f) ? (void)0 : (void)AssertSzUs(__FILE__,__LINE__))

#define  EvalAssertRet(f, retVal) \
         {if (!(f)) {AssertSzUs(__FILE__,__LINE__); return(retVal);}}

#define  PreCondition(f, retVal) \
         {if (!(f)) {PreCondSzUs(__FILE__,__LINE__); return(retVal);}}

#define  ChkArg(f, iArg, retVal) \
         {if (!(f)) {BadParamUs(iArg, __FILE__, __LINE__); return(retVal);}}

#else

#define  Assert(f)                 ((void)0)
#define  AssertRet(f, retVal)      ((void)0)
#define  EvalAssert(f)             ((void)(f))
#define  EvalAssertRet(f, retVal)  ((void)(f))
#define  PreCondition(f, retVal)   ((void)0)
#define  ChkArg(f, iArg, retVal)   ((void)0)

#endif


/*
**	Purpose:
**		Generates a task modal message box.
**	Arguments:
**		szTitle: title for message box.
**		szText:  text for message box.
**	Returns:
**		none
*/
_dt_private
#define  MessBoxSzSz(szTitle, szText) \
		MessageBox((HWND)NULL, (LPSTR)szText, (LPSTR)szTitle, \
				MB_TASKMODAL | MB_ICONHAND | MB_OK)


#define AssertSzUs(x, y)    TRUE
#define PreCondSzUs(x, y)   TRUE
#define BadParamUs(x, y, z) TRUE


_dt_subsystem(INF Handling)


/*
**	Inf Data Block structure
**
**	Fields:
**		pidbNext:      next IDB in linked list.
**		pchpBuffer:    character buffer.
**		cchpBuffer:    number of useful characters in pchpBuffer.
**		cchpAllocated: number of characters actually allocated with
**			pchpBuffer.  May be zero.
*/
_dt_public typedef struct _idb
	{
	struct _idb * pidbNext;
	PCHP          pchpBuffer;
	CCHP          cchpBuffer;
	CCHP          cchpAllocated;
	}  IDB;


/*	Inf Data Block datatypes
*/
_dt_public typedef  IDB *  PIDB;
_dt_public typedef  PIDB * PPIDB;

/*
    The following equate is used because of a situation like
    "abcd"+
    "efgh"
    When parsed, this will be "abcd""efgh"  -- is this two strings or
    one string with a double quote in the middle?  If it's the latter,
    we'll actually store "abcd.efgh" where . is DOUBLE_QUOTE.
*/

#define     DOUBLE_QUOTE                '\001'

#define     INFLINE_SECTION             0x01
#define     INFLINE_KEY                 0x02

  /* INF File Handling routines */
GRC  APIENTRY GrcOpenInf(SZ IniFileName, PVOID pInfTempInfo);

BOOL APIENTRY FFreeInf(void);

UINT APIENTRY CKeysFromInfSection(SZ Section, BOOL IncludeAllLines);
BOOL APIENTRY FKeyInInfLine(INT Line);

RGSZ APIENTRY RgszFromInfLineFields(INT Line,UINT StartField,UINT NumFields);
BOOL APIENTRY FFreeRgsz(RGSZ);

UINT APIENTRY CFieldsInInfLine(INT Line);

INT  APIENTRY FindInfSectionLine(SZ Section);
INT  APIENTRY FindNthLineFromInfSection(SZ Section,UINT n);
INT  APIENTRY FindLineFromInfSectionKey(SZ Section,SZ Key);
INT  APIENTRY FindNextLineFromInf(INT Line);

SZ   APIENTRY SzGetNthFieldFromInfLine(INT Line,UINT n);
SZ   APIENTRY SzGetNthFieldFromInfSectionKey(SZ Section,SZ Key,UINT n);

BOOL APIENTRY FUpdateInfSectionUsingSymTab(SZ);

SZ   APIENTRY InterpretField(SZ);

#define  RgszFromInfScriptLine(Line,NumFields) \
         RgszFromInfLineFields(Line,1,NumFields)

#define  FindFirstLineFromInfSection(Section) FindNthLineFromInfSection(Section,1)

/*
**	Option-Element Flags datatype for SFD
*/
_dt_public typedef WORD OEF;

_dt_public
#define oefVital       ((OEF)0x0001)
_dt_public
#define oefCopy        ((OEF)0x0002)
_dt_public
#define oefUndo        ((OEF)0x0004)
_dt_public
#define oefRoot        ((OEF)0x0008)
_dt_public
#define oefDecompress  ((OEF)0x0010)
_dt_public
#define oefTimeStamp   ((OEF)0x0020)
_dt_public
#define oefReadOnly    ((OEF)0x0040)
_dt_public
#define oefBackup      ((OEF)0x0080)
_dt_public
#define oefUpgradeOnly ((OEF)0x0100)

//
// The following oef means that the source file should not be deleted
// after it is copied, even if the source is the DOS setup local source.
// (Files coming from anywhere below that directory are usually deleted
// after they are copied).
//

#define oefNoDeleteSource    ((OEF)0x0200)


_dt_public
#define oefNone        ((OEF)0x0000)
_dt_public
#define oefAll         ((OEF)0xFFFF)


/*
**	Copy-Time Unit datatype for SFD
*/
_dt_public typedef WORD CTU;


/*
**	OverWrite Mode datatype for SFD
*/
_dt_public typedef WORD OWM;

_dt_public
#define owmNever              ((OWM)0x0001)
_dt_public
#define owmAlways             ((OWM)0x0002)
_dt_public
#define owmUnprotected        ((OWM)0x0004)
_dt_public
#define owmOlder              ((OWM)0x0008)
_dt_public
#define owmVerifySourceOlder  ((OWM)0x0010)

/*
**	Option-Element Record for SFD
*/
_dt_public typedef struct _oer
	{
	OEF   oef;
	CTU   ctuCopyTime;
	OWM   owm;
	LONG  lSize;
	SZ    szRename;
	SZ    szAppend;
	SZ    szBackup;
	SZ    szDescription;
	ULONG ulVerMS;
	ULONG ulVerLS;
	SZ    szDate;
	SZ    szDest;
	}  OER;


/*
**	Option-Element Record datatype for SFD
*/
_dt_public typedef OER *   POER;
_dt_public typedef POER *  PPOER;

_dt_public
#define poerNull ((POER)NULL)


/*
**	Disk ID datatype for SFD
*/
_dt_public typedef WORD DID;

_dt_public
#define didMin    1

_dt_public
#define didMost 999


/*
**	Section-File Description structure
**	Fields:
*/
_dt_public typedef struct _sfd
	{
    DID     did;
    UINT    InfId;
    SZ      szFile;
    OER     oer;
	} SFD;


/*
**	Section-File Description datatype
*/
_dt_public typedef  SFD *  PSFD;
_dt_public typedef  PSFD * PPSFD;
_dt_public
#define psfdNull ((PSFD)NULL)


extern  POER    APIENTRY PoerAlloc(VOID);
extern  BOOL    APIENTRY FFreePoer(POER);
extern  BOOL    APIENTRY FPrintPoer(PFH, POER);
extern  BOOL    APIENTRY FValidPoer(POER);

extern  PSFD    APIENTRY PsfdAlloc(VOID);
extern  BOOL    APIENTRY FFreePsfd(PSFD);
extern  GRC     APIENTRY GrcGetSectionFileLine(INT, PPSFD, POER);
extern  BOOL    APIENTRY FPrintPsfd(PFH, PSFD);
#if DBG
extern  BOOL    APIENTRY FValidPsfd(PSFD);
#endif

extern  BOOL    APIENTRY FValidOerDate(SZ);
extern  BOOL    APIENTRY FParseVersion(SZ, PULONG, PULONG);

extern  BOOL    APIENTRY FListIncludeStatementLine(INT Line);
extern  GRC     APIENTRY GrcGetListIncludeSectionLine(INT, PSZ, PSZ);



_dt_subsystem(INF Media Prompting)


/*
**	Source Description List Element data structure
*/
_dt_public typedef  struct _sdle
	{
	struct _sdle *  psdleNext;
    DID             did;           // disk id as specified in the inf
    DID             didGlobal;     // a universal id across infs
	SZ              szLabel;
	SZ              szTagFile;
	SZ              szNetPath;
	}  SDLE;

_dt_public typedef SDLE *   PSDLE;
_dt_public typedef PSDLE *  PPSDLE;


extern  PSDLE  APIENTRY PsdleAlloc(VOID);
extern  BOOL   APIENTRY FFreePsdle(PSDLE);

extern  GRC    APIENTRY GrcFillSrcDescrListFromInf(VOID);



_dt_subsystem(List Building)


/*
**	Copy List Node data structure
*/
_dt_public typedef struct _cln
	{
	SZ            szSrcDir;
	SZ            szDstDir;
	PSFD          psfd;
	struct _cln * pclnNext;
	} CLN;
_dt_public typedef CLN *   PCLN;
_dt_public typedef PCLN *  PPCLN;
_dt_public typedef PPCLN * PPPCLN;


/*
**	Section Files Operation data structure
**	REVIEW -- not really used
*/
_dt_public typedef WORD SFO;
_dt_public
#define sfoCopy   1
_dt_public
#define sfoBackup 2
_dt_public
#define sfoRemove 3

  /* in LIST.C */
extern PCLN  pclnHead;
extern PPCLN ppclnTail;



extern GRC   APIENTRY GrcFillPoerFromSymTab(POER);
extern BOOL  APIENTRY FSetPoerToEmpty(POER);

extern GRC   APIENTRY GrcAddSectionFilesToCopyList(SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionKeyFileToCopyList(SZ, SZ, SZ, SZ);
extern GRC   APIENTRY GrcAddNthSectionFileToCopyList(SZ, UINT, SZ, SZ);
extern GRC   APIENTRY GrcAddSectionFilesToCList(SFO, SZ, SZ, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddLineToCList(INT, SFO, SZ, SZ, POER);
extern GRC   APIENTRY GrcAddPsfdToCList(SZ, SZ, PSFD);

extern PCLN  APIENTRY PclnAlloc(VOID);
extern BOOL  APIENTRY FFreePcln(PCLN);

extern BOOL  APIENTRY FPrintPcln(PFH, PCLN);
#if DBG
extern BOOL  APIENTRY FValidPcln(PCLN);
#endif



/*	Symbol Table constants */
#define  cchpSymMax   ((CCHP)255)
#define  cchpSymBuf   (cchpSymMax + 1)

  /* Symbol Table routines */
extern  BOOL            APIENTRY FAddSymbolValueToSymTab(SZ, SZ);
extern  GRC             APIENTRY GrcAddSymsFromInfSection(SZ);


	/* Message Box Routine */
extern int APIENTRY ExtMessageBox(HANDLE, HWND, WORD, WORD, WORD);



/*
**	Purpose:
**		Determines whether a symbol is defined in the symbol table.
**	Arguments:
**		szSymbol: symbol to search for.  szSymbol must be non-NULL, non-empty,
**			and start with a non-whitespace character.
**	Returns:
**		fTrue if szSymbol is defined in the symbol table (even if the associated
**			is an empty string).
**		fFalse if szSymbol is not defined in the symbol table.
*/
_dt_public
#define  FSymbolDefinedInSymTab(szSymbol) \
					((BOOL)(SzFindSymbolValueInSymTab(szSymbol)!=(SZ)NULL))


extern  SZ      APIENTRY SzFindSymbolValueInSymTab(SZ);
extern  BOOL    APIENTRY FRemoveSymbolFromSymTab(SZ);
extern  RGSZ    APIENTRY RgszFromSzListValue(SZ);
extern  SZ      APIENTRY SzListValueFromRgsz(RGSZ);
extern  BOOL    APIENTRY FFreeInfTempInfo(PVOID);
extern  BOOL    APIENTRY FCheckSymTabIntegrity(VOID);
extern  BOOL    APIENTRY FDumpSymTabToFile(PFH);
extern  SZ      APIENTRY SzGetSubstitutedValue(SZ);
extern  SZ      APIENTRY SzProcessSzForSyms(HWND, SZ);



_dt_subsystem(Parse Table)


/*	String Parse Code
*/
_dt_public typedef unsigned SPC;

_dt_public typedef SPC *  PSPC;


/*
**	String-Code Pair structure
**	Fields:
**		sz:  string.
**		spc: String Parse Code to associate with string.
*/
_dt_public typedef struct _scp
	{
	SZ  sz;
	SPC spc;
	} SCP;


/*	String-Code Pair datatype
*/
_dt_public typedef  SCP *  PSCP;


/*  String Parse Table datatypes
*/
///////////////////////////////////
// _dt_public typedef  SCP    SPT;
///////////////////////////////////

_dt_public typedef  struct _pspt
    {
    PSCP pscpSorted ;   //  Generated for binary search
    long cItems ;       //  Number of items in table
    PSCP pscpBase ;     //  Original as given to PsptInitParsingTable()
    SPC spcDelim ;      //  Table delimiter entry
    } SPT ;

_dt_public typedef  SPT *  PSPT;


/* Symbol Table routines */
extern  PSPT    APIENTRY PsptInitParsingTable(PSCP);
extern  SPC     APIENTRY SpcParseString(PSPT, SZ);
extern  BOOL    APIENTRY FDestroyParsingTable(PSPT);

/* Flow handling routines */

  /* external program, library */

BOOL APIENTRY FParseLoadLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFreeLibrary(INT Line, UINT *pcFields);
BOOL APIENTRY FParseLibraryProcedure(INT Line,UINT *pcFields);
BOOL APIENTRY FParseRunExternalProgram(INT Line,UINT *pcFields);
BOOL APIENTRY FParseInvokeApplet(INT Line, UINT *pcFields);
BOOL APIENTRY FParseStartDetachedProcess(INT Line, UINT *pcFields);

  /* registry */

BOOL APIENTRY FParseRegistrySection(INT Line, UINT *pcFields, SPC spc);
BOOL APIENTRY FParseCreateRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseOpenRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseFlushRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseCloseRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegTree(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegKey(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseSetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseGetRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseDeleteRegValue(INT Line, UINT *pcFields, SZ szHandle);
BOOL APIENTRY FParseEnumRegValue(INT Line, UINT *pcFields, SZ szHandle);

BOOL APIENTRY FParseAddFileToDeleteList(INT Line, UINT *pcFields);
BOOL APIENTRY FParseWaitOnEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSignalEvent(INT Line,UINT *pcFields);
BOOL APIENTRY FParseSleep(INT Line, UINT *pcFields);
BOOL APIENTRY FParseFlushInf(INT Line, UINT *pcFields);

/*
**	String Parse Codes for Flow Handling
*/
#define spcError                 0
#define spcUnknown               1
#define spcSet                   2
#define spcIfStr                 3
#define spcIfStrI                4
#define spcIfInt                 5
#define spcIfContains            6
#define spcIfContainsI           7
#define spcIfFirst               spcIfStr
#define spcIfLast                spcIfContainsI
#define spcEndIf                 8
#define spcElse                  9
#define spcElseIfStr            10
#define spcElseIfStrI           11
#define spcElseIfInt            12
#define spcElseIfContains       13
#define spcElseIfContainsI      14
#define spcEQ                   15
#define spcNE                   16
#define spcLT                   17
#define spcLE                   18
#define spcGT                   19
#define spcGE                   20
#define spcIn                   21
#define spcNotIn                22
#define spcGoTo                 23
#define spcForListDo            24
#define spcEndForListDo         25
#define spcSetSubst             26
#define spcSetSubsym            27
#define spcDebugMsg             28
#define spcHourglass            29
#define spcArrow                30
#define spcSetInstructionText   31
#define spcSetHelpFile          32
#define spcCreateRegKey         33
#define spcOpenRegKey           34
#define spcFlushRegKey          35
#define spcCloseRegKey          36
#define spcDeleteRegKey         37
#define spcDeleteRegTree        38
#define spcEnumRegKey           39
#define spcSetRegValue          40
#define spcGetRegValue          41
#define spcDeleteRegValue       42
#define spcEnumRegValue         43
#define spcSetAdd               50
#define spcSetSub               51
#define spcSetMul               52
#define spcSetDiv               53
#define spcGetDriveInPath       54
#define spcGetDirInPath         55
#define spcLoadLibrary          56
#define spcFreeLibrary          57
#define spcLibraryProcedure     58
#define spcRunExternalProgram   59
#define spcInvokeApplet         60
#define spcDebugOutput          61
#define spcSplitString          62
#define spcQueryListSize        63
#define spcSetOr                64
#define spcAddFileToDeleteList  65
#define spcInitRestoreDiskLog   66
#define spcStartDetachedProcess 67
#define spcWaitOnEvent          68
#define spcSignalEvent          69
#define spcSleep                70
#define spcSetHexToDec          71
#define spcSetDecToHex          72
#define spcFlushInf             73


extern  PSPT   psptFlow;
extern  SCP    rgscpFlow[];

extern  BOOL    APIENTRY FHandleFlowStatements(INT *, HWND, SZ, UINT *,RGSZ *);
extern  BOOL    APIENTRY FInitFlowPspt(VOID);
extern  BOOL    APIENTRY FDestroyFlowPspt(VOID);


_dt_subsystem(Error Handling)


/*
**	Expanded Error Return Code
*/
_dt_public  typedef  unsigned  EERC;
_dt_public
#define  eercAbort  ((EERC)0)
_dt_public
#define  eercRetry  ((EERC)1)
_dt_public
#define  eercIgnore ((EERC)2)

#define EercErrorHandler(HWND, GRC, BOOL, x, y, z) TRUE
#define FHandleOOM(HWND) TRUE

extern  BOOL    APIENTRY FGetSilent(VOID);
extern  BOOL    APIENTRY FSetSilent(BOOL);


VOID SetSupportLibHandle(HANDLE Handle);

extern HCURSOR CurrentCursor;


//
// Utility functions for dealing with multisz's.
//

RGSZ
MultiSzToRgsz(
    IN PVOID MultiSz
    );

PCHAR
RgszToMultiSz(
    IN RGSZ rgsz
    );


BOOL AddFileToDeleteList(PCHAR Filename);

// floppy operations/repair diskette stuff

BOOL
InitializeFloppySup(
    VOID
    );

VOID
TerminateFloppySup(
    VOID
    );

BOOL
FormatFloppyDisk(
    IN  CHAR  DriveLetter,
    IN  HWND  hwndOwner,
    OUT PBOOL Fatal
    );

BOOL
CopyFloppyDisk(
    IN CHAR  DriveLetter,
    IN HWND  hwndOwner,
    IN DWORD SourceDiskPromptId,
    IN DWORD TargetDiskPromptId
    );

UINT
__cdecl
xMsgBox(
    HWND hwnd,
    UINT CaptionResId,
    UINT MessageResId,
    UINT MsgBoxFlags,
    ...
    );


#endif // COMSTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\ids.h ===
#define  cchpBufTmpLongMax   255
#define  cchpBufTmpLongBuf   (cchpBufTmpLongMax + 1)
#define  cchpBufTmpShortMax   63
#define  cchpBufTmpShortBuf  (cchpBufTmpShortMax + 1)




  /* for Resource String Table */
#define IDS_NULL                     0
#define IDS_USAGE_TITLE              1
#define IDS_USAGE_MSG1               2
#define IDS_USAGE_MSG2               3
#define IDS_USAGE_USAGE              4
#define IDS_USAGE_F                  5
#define IDS_USAGE_I                  6
#define IDS_USAGE_C                  7
#define IDS_USAGE_S                  8
#define IDS_USAGE_D                  9
#define IDS_USAGE_T                 10
#define IDS_USAGE_N                 11
#define IDS_USAGE_V                 12


#define IDS_ERROR                   17
#define IDS_INTERNAL_ERROR          18
#define IDS_BAD_SHL_SCRIPT_SECT     19
#define IDS_BAD_DEST_PATH           20
#define IDS_BAD_INF_SRC             21
#define IDS_BAD_SRC_PATH            22
#define IDS_EXE_PATH_LONG           23
#define IDS_GET_MOD_FAIL            24
#define IDS_UI_EH_ERR               25
#define IDS_INTERP_ERR              26

#define IDS_CANT_FIND_SHL_SECT      27
#define IDS_REGISTER_CLASS          28
#define IDS_CREATE_WINDOW           29
#define IDS_SECOND_INSTANCE         30

#define IDS_UPDATE_INF              31
#define IDS_UI_CMD_ERROR            32

#define IDS_SETUP_INF               33
#define IDS_SHELL_CMDS_SECT         34
#define IDS_ABOUT_MENU              35
#define IDS_ABOUT_TITLE             36
#define IDS_ABOUT_MSG               37

#define IDS_SHL_CMD_ERROR           38
#define IDS_NEED_EXIT               39

#define IDS_INF_SECT_REF            40

#define IDS_CD_BLANKNAME            41
#define IDS_CD_BLANKORG             42
#define IDS_EXE_CORRUPT             43
#define IDS_WARNING                 44
#define IDS_INSTRUCTIONS            45
#define IDS_EXITNOTSETUP            46
#define IDS_EXITCAP                 47
#define IDS_MESSAGE                 48
#define IDS_CANT_END_SESSION        49
#define IDS_CANCEL                  50
#define IDS_PROGRESS                51
#define IDS_NOTDONE                 52

// error messages
#define IDS_ERROR_OOM               53
#define IDS_ERROR_OPENFILE          54
#define IDS_ERROR_CREATEFILE        55
#define IDS_ERROR_READFILE          56
#define IDS_ERROR_WRITEFILE         57
#define IDS_ERROR_REMOVEFILE        58
#define IDS_ERROR_RENAMEFILE        59
#define IDS_ERROR_READDISK          60
#define IDS_ERROR_CREATEDIR         61
#define IDS_ERROR_REMOVEDIR         62
#define IDS_ERROR_CHANGEDIR         63
#define IDS_ERROR_GENERALINF        64
#define IDS_ERROR_INFNOTSECTION     65
#define IDS_ERROR_INFBADSECTION     66
#define IDS_ERROR_INFBADLINE        67
#define IDS_ERROR_INFHASNULLS       68
#define IDS_ERROR_INFXSECTIONS      69
#define IDS_ERROR_INFXKEYS          70
#define IDS_ERROR_INFSMDSECT        71
#define IDS_ERROR_WRITEINF          72
#define IDS_ERROR_LOADLIBRARY       73
#define IDS_ERROR_BADLIBENTRY       74
#define IDS_ERROR_INVOKEAPPLET      75
#define IDS_ERROR_EXTERNALERROR     76
#define IDS_ERROR_DIALOGCAPTION     77
#define IDS_ERROR_INVALIDPOER       78
#define IDS_ERROR_INFMISSINGLINE    79
#define IDS_ERROR_INFBADFDLINE      80
#define IDS_ERROR_INFBADRSLINE      81

#define IDS_GAUGE_TEXT_1            82
#define IDS_GAUGE_TEXT_2            83
#define IDS_INS_DISK                84
#define IDS_INTO                    85
#define IDS_BAD_CMDLINE             86
#define IDS_VER_DLL                 87
#define IDS_SETUP_WARNING           88
#define IDS_BAD_LIB_HANDLE          89

#define IDS_ERROR_BADINSTALLLINE         90
#define IDS_ERROR_MISSINGDID             91
#define IDS_ERROR_INVALIDPATH            92
#define IDS_ERROR_WRITEINIVALUE          93
#define IDS_ERROR_REPLACEINIVALUE        94
#define IDS_ERROR_INIVALUETOOLONG        95
#define IDS_ERROR_DDEINIT                96
#define IDS_ERROR_DDEEXEC                97
#define IDS_ERROR_BADWINEXEFILEFORMAT    98
#define IDS_ERROR_RESOURCETOOLONG        99
#define IDS_ERROR_MISSINGSYSINISECTION  100
#define IDS_ERROR_DECOMPGENERIC         101
#define IDS_ERROR_DECOMPUNKNOWNALG      102
#define IDS_ERROR_DECOMPBADHEADER       103
#define IDS_ERROR_READFILE2             104
#define IDS_ERROR_WRITEFILE2            105
#define IDS_ERROR_WRITEINF2             106
#define IDS_ERROR_MISSINGRESOURCE       107
#define IDS_ERROR_SPAWN                 108
#define IDS_ERROR_DISKFULL              109
#define IDS_ERROR_DDEREMOVEITEM         110
#define IDS_ERROR_DDEADDITEM            111
#define IDS_ERROR_INFMISSINGSECT        112
#define IDS_SURECANCEL                  113
#define IDS_ERROR_RUNTIMEPARSE          114
#define IDS_ERROR_OPENSAMEFILE          115

// messages related to floppy operations (format/diskcopy).

#define IDS_INSERTDISKETTE              200
#define IDS_FIRSTREPAIRDISKPROMPT       201
#define IDS_SECONDREPAIRDISKPROMPT      202
#define IDS_FORMATTINGDISK              205
#define IDS_FORMATGENERALFAILURE        207
#define IDS_CANTDETERMINEFLOPTYPE       209
#define IDS_BADFLOPPYTYPE               210
#define IDS_FLOPPYWRITEPROT             211
#define IDS_FLOPPYIOERR                 212
#define IDS_FLOPPYUNKERR                213
#define IDS_RETRYFORMATREPAIRDISK       215
#define IDS_ALLDATAWILLBELOST           217
#define IDS_CANTINITFLOPPYSUP           218
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\getmttf.c ===
/****************************************************************************

    PROGRAM: getmttf.c

    AUTHOR:  Lars Opstad (LarsOp) 3/18/93

    PURPOSE: Setup for NT Mean-time-to-failure reporting tool.

    FUNCTIONS:

        WinMain() - parse command line and starts each dialog box
        FrameWndProc() - processes messages
        About() - processes messages for "About" dialog box

    COMMENTS:

        This program displays 2 dialog boxes to prompt the user for
        who he/she is and what tests to run.  It then starts tests
        (in INIIO.c) and registers with a server (in CLIENT.c).

****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "setup.h"      /* specific to this program */

#define IniFileName "Mttf.ini"
#define MTTFEXE "Mttf.exe"
#define MTTFVWR "Mttfvwr.exe"

#ifdef MIPS
#define DEFAULT_PATH       "a:\\"
#else
#define DEFAULT_PATH       "a:\\"
#endif

#define DEFAULT_MTTF_FILE  "\\\\server\\share\\mttf.dat"
#define DEFAULT_NAMES_FILE "\\\\server\\share\\names.dat"
#define DEFAULT_IDLE_LIMIT 10
#define DEFAULT_386_IDLE_LIMIT 15
#define DEFAULT_POLLING_PERIOD 15
#define MAX_POLLING_PERIOD 60

HANDLE hInst;       // current instance
DWORD  PollingPeriod;
DWORD  IdlePercentage;
char   SetupDir[MAX_DIR];
char   ResultsFile[MAX_DIR],NameFile[MAX_DIR];
char   Path[MAX_DIR];
char   SysDir[MAX_DIR],
       Buf1[MAX_DIR],
       Buf2[MAX_DIR];


/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:  Checks command args then displays dialogs

    COMMENTS:

        Parse the command arguments.
        If the user hasn't specified name, office and dir,
            display signon dialog.
        Display test selection dialog.

****************************************************************************/

int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    SYSTEM_INFO sysinfo;
    char Buffer[MAX_DIR],
         WinDir[MAX_DIR],
         *EndOfPath;
    INT_PTR dlgRet=FALSE;
    CMO  cmo=cmoVital;

    hInst = hInstance;

    //
    // Get directory EXE was run from.
    //
    GetModuleFileName(NULL, SetupDir, sizeof(SetupDir));

    //
    // Strip off exe name to use as default dir to get files from.
    // Might be a:\, b:\ or \\srv\share\
    //
    _strlwr(SetupDir);
    if (EndOfPath=strstr(SetupDir,"getmttf.exe")) {
        *EndOfPath=0;
    }

    FInitProgManDde(hInst);

    GetSystemInfo(&sysinfo);                    // Get system info

    //
    // if the processortype is 386, set idle percent to 386 limit.
    //
    if (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
        sysinfo.wProcessorLevel < 4
       ) {
        IdlePercentage = DEFAULT_386_IDLE_LIMIT;
    } else {
        IdlePercentage = DEFAULT_IDLE_LIMIT;
    }
    GetSystemDirectory(SysDir, MAX_DIR);

    //
    // Try to copy the EXEs
    //
    MakeFileName(Buf1, SetupDir,MTTFEXE);
    MakeFileName(Buf2, SysDir,  MTTFEXE);

    if (CopyFile(Buf1, Buf2, FALSE)) {

        MakeFileName(Buf1, SetupDir, MTTFVWR);
        MakeFileName(Buf2, SysDir,   MTTFVWR);

        if (CopyFile(Buf1, Buf2, FALSE)) {

            MakeFileName(Buf1, SetupDir, IniFileName);
            ReadIniFile(Buf1);
            dlgRet=TRUE;            // If both EXEs copy, set flag to not show signon
        }
    }


    //
    // Only display the dialog if one of the EXEs didn't copy from default dir.
    //
    if (!dlgRet) {
        //
        // Display signon dlg
        //
        dlgRet = DialogBox(hInstance, (LPCSTR)IDD_SIGNON, NULL, SignonDlgProc);
    }

    if (dlgRet) {
        //
        // Display test selection dialog
        //
        dlgRet = DialogBox(hInstance, (LPCSTR)IDD_VALUES, NULL, ValuesDlgProc);

        if (!dlgRet) {
            goto AbortApp;
        }
        GetWindowsDirectory(WinDir, MAX_DIR);
        MakeFileName(Buffer, WinDir, IniFileName);

        WriteIniFile(Buffer);

        FCreateProgManGroup("Startup", "", cmo, TRUE);
        FCreateProgManItem("Startup", "Mttf", "Mttf.Exe", "", 0, cmo, FALSE);

        if (ResultsFile[0]) {
            sprintf(Buffer, "cmd /k Mttfvwr %s", ResultsFile);
        } else {
            sprintf(Buffer, "cmd /k mttfvwr c:\\mttf.ini");
        }

        FCreateProgManGroup("Main", "", cmo, FALSE);
        FCreateProgManItem("Main", "Mttf Viewer", Buffer, "", 0, cmo, FALSE);

        MessageBox(NULL,
                   "If you are not an Administrator and often log on to this "
                   "machine with a different username, please add mttf.exe to "
                   "the startup group for each user.\n\n"
                   "The following are the keys to valid mttf numbers:\n\n"
                   "1. Answer prompts correctly for warm/cold boot problems\n"
                   "2. Report \"Other\" problems by double-clicking the app\n"
                   "3. Disable while performing unusual tests (such as stress)\n"
                   "4. Install Mttf as soon as possible after upgrading.\n\n"
                   "Setup is now complete. Please go to ProgMan and start Mttf.",
                   "Mttf Setup Complete",
                   MB_OK|MB_ICONINFORMATION);

    } else {
AbortApp:
        MessageBox(NULL,
                   "Mttf setup did NOT install correctly.  Please rerun setup.",
                   "Mttf Setup Failed",
                   MB_OK|MB_ICONHAND);
    }

    return 0;

} // WinMain()

VOID
WriteIniFile (
    char *filename
    )
{
    char Buffer[MAX_DIR];

    WritePrivateProfileString("Mttf", "ResultsFile", ResultsFile, filename);
    WritePrivateProfileString("Mttf", "NameFile", NameFile, filename);
    sprintf(Buffer, "%ld", PollingPeriod);
    WritePrivateProfileString("Mttf", "PollingPeriod", Buffer, filename);
    sprintf(Buffer, "%ld", IdlePercentage);
    WritePrivateProfileString("Mttf", "IdlePercent", Buffer, filename);
}

VOID
ReadIniFile (
    char *filename
    )
{
    GetPrivateProfileString("Mttf",
                            "NameFile",
                            DEFAULT_NAMES_FILE,
                            NameFile,
                            MAX_DIR,
                            filename);

    GetPrivateProfileString("Mttf",
                            "ResultsFile",
                            DEFAULT_MTTF_FILE,
                            ResultsFile,
                            MAX_DIR,
                            filename);

    PollingPeriod = GetPrivateProfileInt("Mttf",
                                         "PollingPeriod",
                                         DEFAULT_POLLING_PERIOD,
                                         filename);

    IdlePercentage = GetPrivateProfileInt("Mttf",
                                          "IdlePercent",
                                          IdlePercentage,
                                          filename);

}

VOID
MakeFileName (
    char *DestBuffer,
    char *Path,
    char *FileName
    )
{
    DWORD len;
    char ch;

    len=strlen(Path);
    ch=(len?Path[len-1]:':');

    switch (ch) {
        case ':':
        case '\\':

            sprintf(DestBuffer, "%s%s", Path, FileName);
            break;

        default:
            sprintf(DestBuffer, "%s\\%s", Path, FileName);
    }
}

/****************************************************************************

    FUNCTION: SignonDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for signon dialog.

    COMMENTS: The signon dialog gets important information for locating
              machine and owner when tracking down problems.

        WM_INITDIALOG: Set default values and focus for input variables

        WM_COMMAND:    Process the button press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box

****************************************************************************/
INT_PTR
SignonDlgProc(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
    switch (message)
    {
        case WM_INITDIALOG:     // initialize values and focus

            SetDlgItemText(hDlg, IDS_PATH, SetupDir);
            return (TRUE);

        case WM_COMMAND:        // command: button pressed

            switch (wParam)     // which button
            {
            //
            // OK: Get and check the input values and try to copy exes
            //
            case IDOK:

                GetDlgItemText(hDlg, IDS_PATH, Path, MAX_DIR);

                MakeFileName(Buf1,Path,MTTFEXE);
                MakeFileName(Buf2,SysDir, MTTFEXE);

                if (!CopyFile(Buf1, Buf2, FALSE)) {
                    sprintf(Buf1, "Error copying %s from %s to %s (%ld).  Please reenter source path.",
                            MTTFEXE, Path, SysDir, GetLastError());
                    MessageBox(NULL,
                               Buf1,
                               "Error Copying",
                               MB_OK|MB_ICONHAND);

                    return (FALSE);
                }

                MakeFileName(Buf1, Path, MTTFVWR);
                MakeFileName(Buf2, SysDir, MTTFVWR);

                if (!CopyFile(Buf1, Buf2, FALSE)) {
                    sprintf(Buf1, "Error copying %s from %s to %s (%ld).  Please reenter source path.",
                            MTTFVWR, Path, SysDir, GetLastError());
                    if (IDRETRY==MessageBox(NULL,
                               Buf1,
                               "Error Copying",
                               MB_RETRYCANCEL|MB_ICONHAND)) {
                        return (FALSE);
                    }
                }

                MakeFileName(Buf1,Path,IniFileName);
                ReadIniFile(Buf1);

                EndDialog(hDlg, TRUE);
                return (TRUE);

            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                return (TRUE);


            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "This part of setup requests the path to the distribution "
                            "files for Mttf.  This may be a:\\, a server (\\\\srv\\shr) or "
                            "any other valid specification.  If Mttf.exe can not be "
                            "copied, setup reprompts for a path.  If MttfVwr.exe can "
                            "not be copied, a warning is displayed that can be ignored "
                            "or retried.",
                            "Mean Time to Failure Setup Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // SignonDlgProc()

/****************************************************************************

    FUNCTION: ValuesDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for test selection dialog.

    COMMENTS: Test selection dialog allows user to add and remove tests
              before and after starting stress.

        WM_INITDIALOG: Set default values and focus for input variables
        WM_CLOSE...:   Send Shutdown message to server for any legal shutdown

        WM_COMMAND:    Process the button/listbox press:
            IDOK:      Get input values and check for validity.
            IDCANCEL:  Kill the app.
            IDB_HELP:  Descriptive message box
            IDT_SAVE:  Prompt for groupname and save selection to ini file
            IDT_ADD:   Add highlighted tests to selected list (remove from poss)
            IDT_REMOVE:Remove highlighted tests from selected list (add to poss)
            IDT_LABEL...: For labels, set selection to corresponding list/combo
            IDT_SEL:   Perform operation depending on action on selected listbox
                LBN_SELCHANGE: Activate Remove button and clear Poss highlights
                LBN_DBLCLK:    Get number of instances for the selected test
            IDT_POSS:  Perform operation depending on action on possible listbox
                LBN_SELCHANGE: Activate Add button and clear selected highlights
                LBN_DBLCLK:    Add highlighted test (simulate press to Add button)
            IDT_GROUP: Change to new group.


****************************************************************************/
INT_PTR
ValuesDlgProc(
     HWND hDlg,
     UINT message,
     WPARAM wParam,
     LPARAM lParam
     )
{
    static DWORD defPP;
    BOOL Translated;
    CHAR Buffer[MAX_DIR];
    HFILE hfile;
    OFSTRUCT ofstruct;

    switch (message)
    {
        case WM_INITDIALOG:     // initialize values and focus

            SetClassLongPtr(hDlg, GCLP_HICON, (LONG_PTR)LoadIcon(hInst,"setup"));
            SetDlgItemText(hDlg, IDV_MTTF, ResultsFile);
            SetDlgItemText(hDlg, IDV_NAMES, NameFile);
            SetDlgItemInt(hDlg, IDV_PERIOD, PollingPeriod, FALSE);
            defPP=PollingPeriod;
            return TRUE;

        case WM_CLOSE:
        case WM_DESTROY:
        case WM_ENDSESSION:
        case WM_QUIT:

            EndDialog(hDlg,FALSE);
            break;

        case WM_COMMAND:           // something happened (button, listbox, combo)
            switch(LOWORD(wParam)) // which one
            {
            //
            // OK: Other problem encountered increment # of others.
            //
            case IDOK:

                GetDlgItemText(hDlg, IDV_MTTF, ResultsFile, MAX_DIR);

                if (HFILE_ERROR==OpenFile(ResultsFile, &ofstruct, OF_EXIST|OF_SHARE_DENY_NONE)) {
                    if (HFILE_ERROR==(hfile=OpenFile(ResultsFile, &ofstruct, OF_CREATE|OF_SHARE_DENY_NONE))) {
                        if (IDRETRY==MessageBox(NULL,
                                     "File does not exist and cannot create file.\n\n"
                                     "Press Retry to reenter filename\n"
                                     "Press Cancel to use filename anyway",
                                     "Invalid file name",
                                     MB_ICONHAND|MB_RETRYCANCEL)) {
                            SetFocus(GetDlgItem(hDlg, IDV_MTTF));
                            return FALSE;
                        }
                    } else {
                        _lclose(hfile);
                    }
                }

                GetDlgItemText(hDlg, IDV_NAMES, NameFile, MAX_DIR);
                if (HFILE_ERROR==OpenFile(NameFile, &ofstruct, OF_EXIST|OF_SHARE_DENY_NONE)) {
                    if (HFILE_ERROR==(hfile=OpenFile(NameFile, &ofstruct, OF_CREATE|OF_SHARE_DENY_NONE))) {
                        if (IDRETRY==MessageBox(NULL,
                                     "File does not exist and cannot create file.\n\n"
                                     "Press Retry to reenter or Cancel to use filename anyway.",
                                     "Invalid file name",
                                     MB_RETRYCANCEL)) {
                            SetFocus(GetDlgItem(hDlg, IDV_NAMES));
                            return FALSE;
                        }
                    } else {
                        _lclose(hfile);
                    }
                }

                PollingPeriod = GetDlgItemInt(hDlg, IDV_PERIOD, &Translated, FALSE);
                if (PollingPeriod<=0 || PollingPeriod > MAX_POLLING_PERIOD) {

                    sprintf(Buffer,
                            "Polling period must be in the range [1, %d] (default %d)",
                            MAX_POLLING_PERIOD,
                            defPP);

                    MessageBox(NULL,
                               Buffer,
                               "Invalid Polling Period",
                               MB_OK|MB_ICONHAND);

                    SetDlgItemInt(hDlg, IDV_PERIOD, defPP, FALSE);
                    SetFocus(GetDlgItem(hDlg, IDV_PERIOD));
                    return (FALSE);
                }
                EndDialog(hDlg, TRUE);
                break;

            //
            // CANCEL: Dismiss dialog (use defaults)
            //
            case IDCANCEL:
                EndDialog(hDlg,FALSE);
                break;

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "Mttf tracks the amount of time your machine stays up, "
                            "the number of cold and warm boots, and "
                            "the number of other problems that occur on your machine. "
                            "All this information is written to a server that is "
                            "specified in mttf.ini (in your Windows NT directory).\n\n"
                            "This part of setup requests the server paths for the data "
                            "files for Mttf.  The Mttf data file contains the time and "
                            "cpu usage data for all machines pointing to this server. "
                            "The Names file is just a list of all machines running mttf. "
                            "These files should both be in UNC (\\\\srv\\shr) format.\n\n"
                            "If your machine is not on the network where your mttf data "
                            "file (or names file) is, just leave these fields blank and "
                            "a small mttf.dat will be kept in the root of your c: drive. "
                            "Send this in when results are requested.\n\n"
                            "The other entry here is for the period (in minutes) that data "
                            "will be sent to the server.  More machines running to one "
                            "server would mean a higher polling period would be helpful. "
                            "Between 10 and 30 minutes seems optimal.",
                            "Mean Time to Failure Setup Help",
                            MB_OK
                           );
                return (TRUE);

            case IDV_LABEL_MTTF:
            case IDV_LABEL_NAMES:
            case IDV_LABEL_PERIOD:
                SetFocus(GetDlgItem(hDlg,1+LOWORD(wParam)));
                break;
            default:
               ;
            } // switch (LOWORD(wParam))

            break;

        default:
            ;
    } // switch (message)
    return FALSE;

} // EventDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\dospif.h ===
/***************************************************************************

INCLUDE FILE: dospif.h - DOSPIF include file

   This file contains definitions (#define, #typedef, external variable and
   function declarations) used in Windows Setup for setting up DOS PIFs.

   *********  IMPORTANT  **********

   This file contains typedefs and bit masks which were copied from the pif 
   editor include files.  Do not change before consulting with pif editor 
   sources.
  
   Copyright (C) Microsoft, 1991

HISTORY:

   Modified by:      Date:       Comment:

   PAK               8/21/91     Created
   SUNILP            2/6/92      Modified, retained just PIF stuff.
                                 Added rgszApp fields ENUM.

***************************************************************************/

/* lengths of certain PIF entries */

#define PIFNAMESIZE        30
#define PIFSTARTLOCSIZE    63
#define PIFDEFPATHSIZE     64
#define PIFPARAMSSIZE      64
#define PIFSHPROGSIZE      64
#define PIFSHDATASIZE      64
#define PIFEXTSIGSIZE      16

/* Miscellaneous defines */

#define LASTHEADERPTR      0xFFFF
#define STDHDRSIG          "MICROSOFT PIFEX"
#define W386HDRSIG         "WINDOWS 386 3.0"
#define W286HDRSIG30       "WINDOWS 286 3.0"
#define DFLT_ICON_FILE     "PROGMAN.EXE"

/* Standard and enhanced modes */

#define MODE_STANDARD   "STANDARD"
#define MODE_ENHANCED   "ENHANCED"


/* String switches used in APPS.INF to set PIF options */

#define GRAF_MULTXT        "gra"
#define COM1               "c1"
#define COM2               "c2"
#define COM3               "c3"
#define COM4               "c4"
#define NO_SCRN_EXCHANGE   "nse"
#define KEYB               "kbd"
#define PREVENT_PROG_SW    "pps"
#define FULL_SCREEN        "fs"
#define WINDOWED_OPT       "win"
#define BACKGROUND         "bgd"
#define EXCLUSIVE          "exc"
#define DETECT_IDLE_TIME   "dit"
#define EMS_LOCKED         "eml"
#define XMS_LOCKED         "xml"
#define USE_HIMEM_AREA     "hma"
#define LOCK_APP_MEM       "lam"
#define LO_RES_GRAPH       "lgr"
#define HI_RES_GRAPH       "hgr"
#define EMULATE_TEXT_MODE  "emt"
#define RETAIN_VIDEO_MEM   "rvm"
#define ALLOW_FAST_PASTE   "afp"
#define ALLOW_CLOSE_ACTIVE "cwa"
#define ALT_SPACE          "asp"
#define ALT_ENTER          "aen"
#define NO_SAVE_SCREEN     "nss"
#define TEXT_OPT           "txt"
#define CLOSE_ON_EXIT      "cwe"
#define ALT_TAB            "ata"
#define ALT_ESC            "aes"
#define CTRL_ESC           "ces"
#define PRSCRN             "psc"
#define ALT_PRSCRN         "aps"

/* Standard and Enhanced section options */

#define UNKNOWN_OPTION     -1
#define PARAMS             1 
#define MINCONVMEM         2
#define VIDEOMODE          3 
#define XMSMEM             4 
#define CHECKBOXES         5 
#define EMSMEM             6 
#define CONVMEM            7 
#define DISPLAY_USAGE      8 
#define EXEC_FLAGS         9
#define MULTASK_OPT        10
#define PROC_MEM_FLAGS     11
#define DISP_OPT_VIDEO     12
#define DISP_OPT_PORTS     13
#define DISP_OPT_FLAGS     14
#define OTHER_OPTIONS      15


/* Bit masks for MSFlags field of PIFNEWSTRUCT */

#define GRAPHMASK       0x02
#define TEXTMASK        0xfd
#define PSMASK          0x04
#define SGMASK          0x08
#define EXITMASK        0x10
#define COM2MASK        0x40
#define COM1MASK        0x80

/* Bit masks for behavior field of PIFNEWSTRUCT */

#define KEYMASK         0x10

/* Bit masks for PfW286Flags field of PIF286EXT30 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

/* Bit masks for PfW386Flags field of PIF386EXT */

#define fEnableClose    0x00000001L
#define fBackground     0x00000002L
#define fExclusive      0x00000004L
#define fFullScreen     0x00000008L
#define fALTTABdis      0x00000020L
#define fALTESCdis      0x00000040L
#define fALTSPACEdis    0x00000080L
#define fALTENTERdis    0x00000100L
#define fALTPRTSCdis    0x00000200L
#define fPRTSCdis       0x00000400L
#define fCTRLESCdis     0x00000800L
#define fPollingDetect  0x00001000L
#define fNoHMA          0x00002000L
#define fHasHotKey      0x00004000L
#define fEMSLocked      0x00008000L
#define fXMSLocked      0x00010000L
#define fINT16Paste     0x00020000L
#define fVMLocked       0x00040000L

/* Bit masks for PfW386Flags2 field of PIF386EXT */

#define fVidTxtEmulate  0x00000001L
#define fVidNoTrpTxt    0x00000002L
#define fVidNoTrpLRGrfx 0x00000004L
#define fVidNoTrpHRGrfx 0x00000008L
#define fVidTextMd      0x00000010L
#define fVidLowRsGrfxMd 0x00000020L
#define fVidHghRsGrfxMd 0x00000040L
#define fVidRetainAllo  0x00000080L


/* PIF Extension Header */
typedef struct {
    char extsig[PIFEXTSIGSIZE];
    WORD extnxthdrfloff;
    WORD extfileoffset;
    WORD extsizebytes;
    } PIFEXTHEADER, *LPPIFEXTHEADER;

/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PIFNEWSTRUCT, *LPPIFNEWSTRUCT;

/* WINDOWS/286 3.0 PIF Extension */
typedef struct {
    WORD          PfMaxXmsK;
    WORD          PfMinXmsK;
    WORD          PfW286Flags;
    } PIF286EXT30, *LPPIF286EXT30;

/* WINDOWS/386 3.0 PIF Extension */
typedef struct {
    WORD      maxmem;
    WORD      minmem;
    WORD      PfFPriority;
    WORD      PfBPriority;
    WORD      PfMaxEMMK;
    WORD      PfMinEMMK;
    WORD      PfMaxXmsK;
    WORD      PfMinXmsK;
    DWORD     PfW386Flags;
    DWORD     PfW386Flags2;
    WORD      PfHotKeyScan;
    WORD      PfHotKeyShVal;
    WORD      PfHotKeyShMsk;
    BYTE      PfHotKeyVal;
    BYTE      PfHotKeyPad[9];
    char      params[PIFPARAMSSIZE];
    } PIF386EXT, *LPPIF386EXT;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    PIFEXTHEADER EnhaExtHdr;
    PIF386EXT    CurrEnha;
    } PIF386Combined, *LPPIF386Combined;

typedef struct {
    PIFNEWSTRUCT DfltPIF;
    PIF286EXT30  DfltStd;
    PIF386EXT    DfltEnha;
    PIFNEWSTRUCT CurrPIF;
    PIFEXTHEADER StdExtHdr;
    PIF286EXT30  CurrStd;
    } PIF286Combined, *LPPIF286Combined;

#pragma pack(1)
/* PIF Structure */
typedef struct {
    char          unknown;
    char          id;
    char          name[PIFNAMESIZE];
    WORD          maxmem;
    WORD          minmem;
    char          startfile[PIFSTARTLOCSIZE];
    char          MSflags;
    char          reserved;
    char          defpath[PIFDEFPATHSIZE];
    char          params[PIFPARAMSSIZE];
    char          screen;
    char          cPages;
    BYTE          lowVector;
    BYTE          highVector;
    char          rows;
    char          cols;
    char          rowoff;
    char          coloff;
    WORD          sysmem;
    char          shprog[PIFSHPROGSIZE];
    char          shdata[PIFSHDATASIZE];
    BYTE          behavior;
    BYTE          sysflags;
    PIFEXTHEADER  stdpifext;
    } PACKED_PIFNEWSTRUCT, *LPPACKED_PIFNEWSTRUCT;
#pragma pack()

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the PIFNEWSTRUCT
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

#define CopyUchar1(Dst,Src) {                                \
    ((PUCHAR1)(Dst))->Uchar[0] = ((PUCHAR1)(Src))->Uchar[0]; \
}

#define CopyUchar2(Dst,Src) {                                \
    ((PUCHAR2)(Dst))->Uchar[0] = ((PUCHAR2)(Src))->Uchar[0]; \
    ((PUCHAR2)(Dst))->Uchar[1] = ((PUCHAR2)(Src))->Uchar[1]; \
}

#define CopyUchar4(Dst,Src) {                                \
    ((PUCHAR4)(Dst))->Uchar[0] = ((PUCHAR4)(Src))->Uchar[0]; \
    ((PUCHAR4)(Dst))->Uchar[1] = ((PUCHAR4)(Src))->Uchar[1]; \
    ((PUCHAR4)(Dst))->Uchar[2] = ((PUCHAR4)(Src))->Uchar[2]; \
    ((PUCHAR4)(Dst))->Uchar[3] = ((PUCHAR4)(Src))->Uchar[3]; \
}

#define CopyUcharn(Dst, Src, n) {                            \
    memmove((PVOID)Dst, (PVOID)Src, n);                      \
}


#define PackPif(Pif,PPif) {                                                        \
    CopyUchar1(&((PPif)->unknown)    ,&((Pif)->unknown)                         ); \
    CopyUchar1(&((PPif)->id)         ,&((Pif)->id)                              ); \
    CopyUcharn(&((PPif)->name)       ,&((Pif)->name)      , PIFNAMESIZE         ); \
    CopyUchar2(&((PPif)->maxmem)     ,&((Pif)->maxmem)                          ); \
    CopyUchar2(&((PPif)->minmem)     ,&((Pif)->minmem)                          ); \
    CopyUcharn(&((PPif)->startfile)  ,&((Pif)->startfile) , PIFSTARTLOCSIZE     ); \
    CopyUchar1(&((PPif)->MSflags)    ,&((Pif)->MSflags)                         ); \
    CopyUchar1(&((PPif)->reserved)   ,&((Pif)->reserved)                        ); \
    CopyUcharn(&((PPif)->defpath)    ,&((Pif)->defpath)   , PIFDEFPATHSIZE      ); \
    CopyUcharn(&((PPif)->params)     ,&((Pif)->params)    , PIFPARAMSSIZE       ); \
    CopyUchar1(&((PPif)->screen)     ,&((Pif)->screen)                          ); \
    CopyUchar1(&((PPif)->cPages)     ,&((Pif)->cPages)                          ); \
    CopyUchar1(&((PPif)->lowVector)  ,&((Pif)->lowVector)                       ); \
    CopyUchar1(&((PPif)->highVector) ,&((Pif)->highVector)                      ); \
    CopyUchar1(&((PPif)->rows)       ,&((Pif)->rows)                            ); \
    CopyUchar1(&((PPif)->cols)       ,&((Pif)->cols)                            ); \
    CopyUchar1(&((PPif)->rowoff)     ,&((Pif)->rowoff)                          ); \
    CopyUchar1(&((PPif)->coloff)     ,&((Pif)->coloff)                          ); \
    CopyUchar2(&((PPif)->sysmem)     ,&((Pif)->sysmem)                          ); \
    CopyUcharn(&((PPif)->shprog)     ,&((Pif)->shprog)    , PIFSHPROGSIZE       ); \
    CopyUcharn(&((PPif)->shdata)     ,&((Pif)->shdata)    , PIFSHDATASIZE       ); \
    CopyUchar1(&((PPif)->behavior)   ,&((Pif)->behavior)                        ); \
    CopyUchar1(&((PPif)->sysflags)   ,&((Pif)->sysflags)                        ); \
    CopyUcharn(&((PPif)->stdpifext)  ,&((Pif)->stdpifext) , sizeof(PIFEXTHEADER));  \
}


enum tagAppRgszFields {
    nEXETYPE,
    nNAME,
    nEXE,
    nDIR,
    nPIF,
    nDEFDIR,
    nCWE,
    nSTDOPT,
    nENHOPT,
    nICOFIL,
    nICONUM
    };

typedef enum {
    ADDAPP_SUCCESS,
    ADDAPP_GENFAIL,
    ADDAPP_GRPFAIL
    } ADDAPP_STATUS;

/* Make New Long Pointer MACRO */
#define MKNLP(lp,w) (LONG)((DWORD)lp + (DWORD)w)

/* DOS PIF INTERNAL ROUTINE DECLARATIONS */

ADDAPP_STATUS
AddDosAppItem(
    IN RGSZ rgszApp,
    IN SZ   szPifDir,
    IN SZ   szGroup
    );

ADDAPP_STATUS
AddWinItem(
    IN RGSZ rgszApp,
    IN SZ   szGroup
    );


BOOL
FDeterminePIFName(
    IN     RGSZ rgszApp,
    IN     SZ   szPifDir,
    IN OUT SZ   szPIFPath
    );

BOOL
FCreatePIF(
    RGSZ  rgszApp,
    SZ    szPIFPath
    );

VOID
ProcessCommonInfo(
    RGSZ rgszApp,
    LPPIFNEWSTRUCT fpPNS
    );

BOOL
FProcessStdModeInfo(
    SZ szStdOptions,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

VOID
ProcessCheckBoxSwitches(
    RGSZ rgsz,
    LPPIFNEWSTRUCT fpPNS,
    LPPIF286EXT30 fpPStd
    );

BOOL
FProcessEnhaModeInfo(
    SZ szEnhOptions,
    LPPIF386EXT fpPEnha
    );

INT
GetExtOption(
    LPSTR lpsz
    );

BOOL
FInitializePIFStructs(
    BOOL bIsEnhanced,
    SZ   szDfltStdOpt,
    SZ   szDfltEnhOpt
    );

VOID
FreePIFStructs(
    VOID
    );

VOID
ExtractStrFromPIF(
    LPSTR lpsz,
    int n
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\setupdef.h ===
#include <windows.h>
#define IDD_SIGNON  100
#define IDD_VALUES  200

#define IDB_HELP    666


#define IDS_PATH    IDD_SIGNON+1

#define IDV_LABEL_MTTF   IDD_VALUES+1
#define IDV_MTTF         IDD_VALUES+2
#define IDV_LABEL_NAMES  IDD_VALUES+3
#define IDV_NAMES        IDD_VALUES+4
#define IDV_LABEL_PERIOD IDD_VALUES+5
#define IDV_PERIOD       IDD_VALUES+6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\install.h ===
/* File: install.h */
/**************************************************************************/
/*	Install: Install Component Public Include File
/**************************************************************************/

#ifndef __install_
#define __install_

_dt_system(Install)

typedef BOOL (APIENTRY *PFNSF)(SZ, SZ);
// Function pointer for {Backup|Remove}SectionFiles
typedef BOOL (APIENTRY *PFNSKF)(SZ, SZ, SZ);
// Function pointer for {Backup|Remove}SectionKeyFile
typedef BOOL (APIENTRY *PFNSNF)(SZ, UINT, SZ);
// Function pointer for {Backup|Remove}SectionNthFile
typedef BOOL (APIENTRY *PFND)(SZ, BYTE);


extern BOOL APIENTRY FInstallEntryPoint(HANDLE, HWND, RGSZ, UINT);
extern BOOL APIENTRY FInstRemoveableDrive(CHP);
extern BOOL APIENTRY FPromptForDisk(HANDLE, SZ, SZ);
extern BOOL APIENTRY FFileFound(SZ);
extern BOOL APIENTRY FCopy(SZ, SZ, OEF, OWM, BOOL, int, USHORT, PSDLE);
extern BOOL APIENTRY FDiskReady(SZ, DID);

/* REVIEW these should be in a private H file */
extern BOOL APIENTRY FGetArgSz(INT Line,UINT *NumFields,SZ *ArgReturn);
extern BOOL APIENTRY FGetArgUINT(INT, UINT *, UINT *);
extern BOOL APIENTRY FParseSectionFiles(INT, UINT *, PFNSF);
extern BOOL APIENTRY FParseSectionKeyFile(INT, UINT *, PFNSKF);
extern BOOL APIENTRY FParseSectionNFile(INT, UINT *, PFNSNF);
extern BOOL APIENTRY FParseCopySection(INT, UINT *);
extern BOOL APIENTRY FParseCopySectionKey(INT, UINT *);
extern BOOL APIENTRY FParseCopyNthSection(INT, UINT *);
extern BOOL APIENTRY FParseDirectory(INT, UINT *, PFND);
extern BOOL APIENTRY FParseCreateIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniSection(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseCreateIniKeyNoValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseReplaceIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseAppendIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseRemoveIniKey(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseIniSection(INT, UINT *, SPC);
extern BOOL APIENTRY FParseSetEnv(INT, UINT *);
#ifdef UNUSED
extern BOOL APIENTRY FParseAddMsgToSystemHelpFile(INT, UINT *);
extern BOOL APIENTRY FParseStampFile(INT, UINT *);
extern BOOL APIENTRY FUndoActions(void);
#endif /* UNUSED */
extern BOOL APIENTRY FParseStampResource(INT, UINT *);
extern BOOL APIENTRY FInitParsingTables(void);
extern BOOL APIENTRY FParseInstallSection(HANDLE hInstance, SZ szSection);
extern SZ   APIENTRY SzGetSrcDollar(SZ);
extern BOOL APIENTRY FDdeTerminate(void);
extern LONG_PTR APIENTRY WndProcDde(HWND, UINT, WPARAM, LPARAM);
extern BOOL APIENTRY FDdeInit(HANDLE);
extern VOID APIENTRY DdeSendConnect(ATOM, ATOM);
extern BOOL APIENTRY FDdeConnect(SZ, SZ);
extern BOOL APIENTRY FDdeWait(void);
extern BOOL APIENTRY FDdeExec(SZ);
extern BOOL APIENTRY FActivateProgMan(void);
extern INT  APIENTRY EncryptCDData(UCHAR *, UCHAR *, UCHAR *, INT, INT, INT, UCHAR *);
extern BOOL APIENTRY FParseCloseSystem(INT, UINT *);
extern BOOL APIENTRY FParseCreateSysIniKeyValue(INT, UINT *, SZ, SZ);
extern BOOL APIENTRY FParseSearchDirList(INT, UINT *);
extern BOOL APIENTRY FParseSetupDOSAppsList(INT, UINT *);
extern BOOL APIENTRY FParseRunExternalProgram(INT, UINT *);
extern BOOL APIENTRY FStrToDate(SZ, PUSHORT, PUSHORT, PUSHORT);

extern BOOL APIENTRY FParseAddDos5Help(INT, USHORT *);
extern USHORT APIENTRY DateFromSz(SZ);
extern BOOL APIENTRY FConvertAndStoreRglInSymTab(PLONG_STF, SZ, INT);


extern BOOL APIENTRY FSearchDirList( SZ, SZ, BOOL, BOOL, SZ, SZ, SZ, SZ );
extern BOOL APIENTRY FInstallDOSPifs( SZ, SZ, SZ, SZ, SZ, SZ );






_dt_public
#define INSTALL_OUTCOME   "STF_INSTALL_OUTCOME"
_dt_public
#define SUCCESS           "STF_SUCCESS"
_dt_public
#define FAILURE           "STF_FAILURE"
_dt_public
#define USERQUIT          "STF_USERQUIT"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\uilstf.h ===
/***************************************************************************/
/***********************  include file for UI Library  *********************/
/***************************************************************************/

#ifndef __uilstf_
#define __uilstf_

_dt_system(User Interface Library)
_dt_subsystem(General Dialog Handling)

_dt_public
#define STF_MESSAGE               (WM_USER + 0x8000)

/*
**	Window Messages
*/
_dt_public
#define STF_UI_EVENT              (STF_MESSAGE)
_dt_public
#define STF_DESTROY_DLG           (STF_MESSAGE + 1)
_dt_public
#define STF_HELP_DLG_DESTROYED    (STF_MESSAGE + 2)
_dt_public
#define STF_INFO_DLG_DESTROYED    (STF_MESSAGE + 3)
_dt_public
#define STF_EDIT_DLG_DESTROYED    (STF_MESSAGE + 4)
_dt_public
#define STF_RADIO_DLG_DESTROYED   (STF_MESSAGE + 5)
_dt_public
#define STF_CHECK_DLG_DESTROYED   (STF_MESSAGE + 6)
_dt_public
#define STF_LIST_DLG_DESTROYED    (STF_MESSAGE + 7)
_dt_public
#define STF_MULTI_DLG_DESTROYED   (STF_MESSAGE + 8)
_dt_public
#define STF_QUIT_DLG_DESTROYED    (STF_MESSAGE + 9)
_dt_public
#define STF_DLG_ACTIVATE          (STF_MESSAGE + 10)
_dt_public
#define STF_UILIB_ACTIVATE        (STF_MESSAGE + 11)
_dt_public
#define STF_REINITDIALOG          (STF_MESSAGE + 12)
_dt_public
#define STF_SHL_INTERP            (STF_MESSAGE + 13)
_dt_hidden
#define STF_COMBO_DLG_DESTROYED   (STF_MESSAGE + 14)
_dt_hidden
#define STF_MULTICOMBO_DLG_DESTROYED (STF_MESSAGE + 15)
_dt_hidden
#define STF_DUAL_DLG_DESTROYED    (STF_MESSAGE + 16)
_dt_hidden
#define STF_MULTICOMBO_RADIO_DLG_DESTROYED (STF_MESSAGE + 17)
_dt_hidden
#define STF_MAINT_DLG_DESTROYED   (STF_MESSAGE + 18)


_dt_hidden
#define STF_SET_INSTRUCTION_TEXT  (STF_MESSAGE + 0x100)

_dt_hidden
#define STF_SET_HELP_CONTEXT      (STF_MESSAGE + 0x101)

_dt_hidden
#define STF_ENABLE_EXIT_BUTTON    (STF_MESSAGE + 0x102)

_dt_hidden
#define STF_ERROR_ABORT           (STF_MESSAGE + 0x103)

#include <setupxrc.h>

#if !defined(STF_SET_INSTRUCTION_TEXT_RC) || (STF_SET_INSTRUCTION_TEXT_RC != STF_MESSAGE + 0x104)
#error STF_SET_INSTRUCTION_TEXT_RC has changed!
#endif


//
// Button IDS to communicate help and exit button messages to shell
//
#define ID_EXITBUTTON       7
#define ID_HELPBUTTON       8


/*
**	Symbols used by Basic Dialog Class procedures
*/

#define CLS_MYDLGS          "mydlg"
#define DLGTEXT             "DlgText"
#define DLGCAPTION          "Caption"
#define DLGTYPE             "DlgType"
#define DLGTEMPLATE         "DlgTemplate"



#define INSTRUCTIONTEXT     "InstructionText"
#define HELPCONTEXT         "HelpContext"
#define EXITSTATE			"ExitState"

#define EXIT_ENABLE			 "Active"
#define EXIT_DISABLE		 "Inactive"


/*
**	PushButton Control IDs
*/
_dt_public
#define IDC_A        401
_dt_public
#define IDC_B        402
_dt_public
#define IDC_C        403
_dt_public
#define IDC_D        404
_dt_public
#define IDC_E        405
_dt_public
#define IDC_F        406
_dt_public
#define IDC_G        407
_dt_public
#define IDC_H        408
_dt_public
#define IDC_I        409
_dt_public
#define IDC_J        410
_dt_public
#define IDC_K        411
_dt_public
#define IDC_L        412
_dt_public
#define IDC_M        413
_dt_public
#define IDC_N        414
_dt_public
#define IDC_O        415
_dt_public
#define IDC_P        416
_dt_public
#define IDC_Q        417
_dt_public
#define IDC_R        418
_dt_public
#define IDC_S        419
_dt_public
#define IDC_T        420
_dt_public
#define IDC_U        421
_dt_public
#define IDC_V        422
_dt_public
#define IDC_W        423
_dt_public
#define IDC_X        424
_dt_public
#define IDC_Y        425
_dt_public
#define IDC_Z        426


/*
**	Text Control IDs
*/
_dt_public
#define IDC_TEXT1    431
_dt_public
#define IDC_TEXT2    432
_dt_public
#define IDC_TEXT3    433
_dt_public
#define IDC_TEXT4    434
_dt_public
#define IDC_TEXT5    435
_dt_public
#define IDC_TEXT6    436
_dt_public
#define IDC_TEXT7    437
_dt_public
#define IDC_TEXT8    438
_dt_public
#define IDC_TEXT9    439
_dt_public
#define IDC_TEXT10   440
_dt_public
#define IDC_TEXT11   441


/*
**	Radio and Checkbox Button Control IDs
*/
_dt_public
#define IDC_B0       450
_dt_public
#define IDC_B1       451
_dt_public
#define IDC_B2       452
_dt_public
#define IDC_B3       453
_dt_public
#define IDC_B4       454
_dt_public
#define IDC_B5       455
_dt_public
#define IDC_B6       456
_dt_public
#define IDC_B7       457
_dt_public
#define IDC_B8       458
_dt_public
#define IDC_B9       459
_dt_public
#define IDC_B10      460

_dt_public
#define IDC_RB0       610
_dt_public
#define IDC_RB1       611
_dt_public
#define IDC_RB2       612
_dt_public
#define IDC_RB3       613
_dt_public
#define IDC_RB4       614
_dt_public
#define IDC_RB5       615
_dt_public
#define IDC_RB6       616
_dt_public
#define IDC_RB7       617
_dt_public
#define IDC_RB8       618
_dt_public
#define IDC_RB9       619
_dt_public
#define IDC_RB10      620

/*
**  Generic Dialog Button IDs
*/

_dt_public
#define IDC_BTN0		630
_dt_public
#define IDC_BTN1		631
_dt_public
#define IDC_BTN2		632
_dt_public
#define IDC_BTN3		633
_dt_public
#define IDC_BTN4		634
_dt_public
#define IDC_BTN5		635
_dt_public
#define IDC_BTN6		636
_dt_public
#define IDC_BTN7		637
_dt_public
#define IDC_BTN8		638
_dt_public
#define IDC_BTN9		639


/*
**	Combo box IDs
*/
_dt_public
#define IDC_COMBO0   480
_dt_public
#define IDC_COMBO1   481
_dt_public
#define IDC_COMBO2   482
_dt_public
#define IDC_COMBO3   483
_dt_public
#define IDC_COMBO4   484
_dt_public
#define IDC_COMBO5   485
_dt_public
#define IDC_COMBO6   486
_dt_public
#define IDC_COMBO7   487
_dt_public
#define IDC_COMBO8   488
_dt_public
#define IDC_COMBO9   489

/*
**	ICON IDs
*/
_dt_public
#define IDC_ICON0    500
_dt_public
#define IDC_ICON1    501
_dt_public
#define IDC_ICON2    502
_dt_public
#define IDC_ICON3    503
_dt_public
#define IDC_ICON4    504
_dt_public
#define IDC_ICON5    505
_dt_public
#define IDC_ICON6    506
_dt_public
#define IDC_ICON7    507
_dt_public
#define IDC_ICON8    508
_dt_public
#define IDC_ICON9    509

/*
** SPECIAL PUSHBUTTONS
*/

_dt_public
#define IDC_SP1    521
_dt_public
#define IDC_SP2    522
_dt_public
#define IDC_SP3    523
_dt_public
#define IDC_SP4    524
_dt_public
#define IDC_SP5    525
_dt_public
#define IDC_SP6    526
_dt_public
#define IDC_SP7    527
_dt_public
#define IDC_SP8    528
_dt_public
#define IDC_SP9    529
_dt_public
#define IDC_SP10   530

/*
** STATUS TEXT FIELDS
*/

_dt_public
#define IDC_STATUS1    541
_dt_public
#define IDC_STATUS2    542
_dt_public
#define IDC_STATUS3    543
_dt_public
#define IDC_STATUS4    544
_dt_public
#define IDC_STATUS5    545
_dt_public
#define IDC_STATUS6    546
_dt_public
#define IDC_STATUS7    547
_dt_public
#define IDC_STATUS8    548
_dt_public
#define IDC_STATUS9    549
_dt_public
#define IDC_STATUS10   550



/*
** SIZE FIELDS ASSOCIATED WITH CHECK OPTIONAL COMPONENTS
*/

_dt_public
#define IDC_SIZE1    551
_dt_public
#define IDC_SIZE2    552
_dt_public
#define IDC_SIZE3    553
_dt_public
#define IDC_SIZE4    554
_dt_public
#define IDC_SIZE5    555
_dt_public
#define IDC_SIZE6    556
_dt_public
#define IDC_SIZE7    557
_dt_public
#define IDC_SIZE8    558
_dt_public
#define IDC_SIZE9    559
_dt_public
#define IDC_SIZE10   560



/*
** TOTALS OF SIZES
*/

_dt_public
#define IDC_TOTAL1    561
_dt_public
#define IDC_TOTAL2    562
_dt_public
#define IDC_TOTAL3    563
_dt_public
#define IDC_TOTAL4    564
_dt_public
#define IDC_TOTAL5    565
_dt_public
#define IDC_TOTAL6    566
_dt_public
#define IDC_TOTAL7    567
_dt_public
#define IDC_TOTAL8    568
_dt_public
#define IDC_TOTAL9    569
_dt_public
#define IDC_TOTAL10   570

/*
** MAXIMUM SIZES
*/

_dt_public
#define IDC_MAX1    571
_dt_public
#define IDC_MAX2    572
_dt_public
#define IDC_MAX3    573
_dt_public
#define IDC_MAX4    574
_dt_public
#define IDC_MAX5    575
_dt_public
#define IDC_MAX6    576
_dt_public
#define IDC_MAX7    577
_dt_public
#define IDC_MAX8    578
_dt_public
#define IDC_MAX9    579
_dt_public
#define IDC_MAX10   580

/*
**	Edit Control IDs
*/

#define IDC_EDIT1   581
#define IDC_EDIT2   582
#define IDC_EDIT3   583
#define IDC_EDIT4   584
#define IDC_EDIT5   585
#define IDC_EDIT6   586
#define IDC_EDIT7   587
#define IDC_EDIT8   588
#define IDC_EDIT9   589
#define IDC_EDIT10  590

/*
**	ListBox Control IDs
*/

#define IDC_LIST1   591
#define IDC_LIST2   592
#define IDC_LIST3   593
#define IDC_LIST4   594
#define IDC_LIST5   595
#define IDC_LIST6   596
#define IDC_LIST7   597
#define IDC_LIST8   598
#define IDC_LIST9   599
#define IDC_LIST10  600


/*
** MENU IDS
*/

#define ID_MAINTAIN  651


/*
** ID_MAINTAIN MENU IDS
*/

#define MENU_CHANGE           701
#define MENU_INSTALL          702
#define MENU_ADD_REMOVE       703
#define MENU_EXIT             704
#define MENU_HELPINDEX        705
#define MENU_HELPSEARCH       706
#define MENU_HELPONHELP       708
#define MENU_HELPONLINE       709
#define MENU_ABOUT            710
#define MENU_PROFILE          711
#define MENU_ADD_REMOVE_SCSI  712
#define MENU_ADD_REMOVE_TAPE  713


/*
**  Handle-Dialog type
*/
_dt_public typedef HWND     HDLG;

/*
**  Event Handler Return Code type
*/
_dt_public typedef USHORT   EHRC;

_dt_public
#define ehrcError       (EHRC) 0
_dt_public
#define ehrcNoPost      (EHRC) 1
_dt_public
#define ehrcPostInterp  (EHRC) 2
_dt_public
#define ehrcNotHandled  (EHRC) 3

/*
**  Prototype for Specific Dialog Event Handlers -- 1632
*/
_dt_public typedef EHRC ( APIENTRY *PFNEVENT)(HANDLE, HWND, UINT, WPARAM, DWORD);

    /* Standard Dialog handler routines */

extern LONG    APIENTRY LDefSetupDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstInfoDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstEditDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiEditDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstGetPathDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstRadioDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCheckDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCheck1DlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstListDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstModelessDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMultiComboDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstComboRadDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstCombinationDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstDualDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstDual1DlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstMaintDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FGstBillboardDlgProc(HWND, UINT, WPARAM, LONG);
extern BOOL    APIENTRY FAppAbout(HWND, UINT, WPARAM, LONG);

	/* stack manipulation routines */
extern HDLG    APIENTRY HdlgPushDbcb(HANDLE, SZ, SZ, HWND, WNDPROC, DWORD,
                                     PFNEVENT, SZ, WNDPROC);
extern BOOL	   APIENTRY FPopDbcb(VOID);
extern BOOL    APIENTRY FPopNDbcb(INT);

extern BOOL    APIENTRY FUiLibFilter(MSG *);
extern BOOL    APIENTRY FResumeStackTop(VOID);
extern SZ      APIENTRY SzStackTopName(VOID);
extern BOOL    APIENTRY FGenericEventHandler(HANDLE, HWND, UINT, WPARAM, DWORD);  // 1632
extern BOOL    APIENTRY FStackEmpty(VOID);
extern HDLG	   APIENTRY HdlgStackTop(VOID);


//
// Display of integer items in text fields
//
extern VOID MySetDlgItemInt(HDLG, INT, LONG);
extern VOID NumericFormat(SZ szSrcBuf, SZ szDispBuf);

//
// Winhelp related externals
//

extern BOOL FInitWinHelpFile(HWND, SZ, SZ, SZ, SZ);
extern BOOL FCloseWinHelp(HWND);
extern BOOL FProcessWinHelp(HWND);
extern BOOL FProcessWinHelpMenu(HWND, WORD);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\vwr\mttfvwr.c ===
#include "..\main\mttf.h"

VOID
__cdecl
main(
    int argc,
    char * argv[]
    )
{
HANDLE statFile;
StatFileRecord statRec;
DWORD numBytes;

    if (argc==1) {
        printf("Usage: mttfvwr <datafile> [/t]\n\n/t for terse (Excel text format)\n");
        return;
    }
    if (INVALID_HANDLE_VALUE==(statFile= CreateFile(argv[1],
                                         GENERIC_READ,
                                         FILE_SHARE_READ,
                                         NULL,
                                         OPEN_ALWAYS,
                                         FILE_ATTRIBUTE_NORMAL,
                                         NULL))) {
        printf("Unable to open %s: %ld\n", argv[1], GetLastError());
        return;
    }
    if (argc<3 || tolower(argv[2][1])!='t') {
        printf("Mean Time To Failure data for %s\n\n", argv[1]);
        printf("Build:    minor version number for each set of stats.\n");
        printf("Busy:     number of minutes with cpu usage greater than idle threshhold.\n");
        printf("Idle:     number of minutes with cpu usage less than idle threshhold.\n");
        printf("Gone:     minutes with cpu less than threshhold for 4 consecutive hrs.\n");
        printf("CpuUsage: average percentage of cpu usage for all machines on that build.\n");
        printf("Cold:     number of cold boots due to a problem.\n");
        printf("Warm:     number of warm boots due to a problem.\n");
        printf("Other:    number of other problems.\n\n");
        printf(" Build    Busy    Idle    Gone  CpuUsg    Cold    Warm   Other\n");
        printf(" -----    ----    ----    ----  ------    ----    ----   -----\n");
    } else {
        printf("Build\011Busy\011Idle\011Gone\011CpuUsg\011Cold\011Warm\011Other\n");
    }

    while (ReadFile(statFile, &statRec, sizeof(statRec), &numBytes, NULL)) {
        if (numBytes==0) {
            return;
        }
        if (argc==3 && tolower(argv[2][1])=='t') {
            printf("%ld\011%ld\011%ld\011%ld\011%ld\011%ld\011%ld\011%ld\n",
                statRec.Version>>16,
                statRec.Busy,
                statRec.Idle,
                statRec.IdleConsec,
                (statRec.Busy+statRec.Idle?statRec.PercentTotal/(statRec.Busy+statRec.Idle):0),
                statRec.Cold,
                statRec.Warm,
                statRec.Other);
        } else {
            printf("%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\t%6ld\n",
                statRec.Version>>16,
                statRec.Busy,
                statRec.Idle,
                statRec.IdleConsec,
                (statRec.Busy+statRec.Idle?statRec.PercentTotal/(statRec.Busy+statRec.Idle):0),
                statRec.Cold,
                statRec.Warm,
                statRec.Other);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munge\datefix.c ===
/*
 * Utility program to munge a set of files, translating names from
 * one form to another.  Usage:
 *
 *      munge scriptFile files...
 *
 * where the first parameter is the name of a file that consists of
 * one or more lines of the following format:
 *
 *      oldName newName
 *
 * and the remaining parameters are the names of the files to munge.
 * Each file is _read into memory, scanned once, where each occurence
 * of an oldName string is replaced by its corresponding newName.
 * If any changes are made to a file, the old version is RMed and
 * the new version written out under the same name.
 *
 */

#include "munge.h"

int fQuery = FALSE;
int fRecurse = FALSE;
int fVerbose = FALSE;

void
DoFiles(
    char *p,
    struct findType *b,
    void *Args
    );

void
DoFile( p )
char *p;
{
    HANDLE FileHandle;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;
    FILETIME CreationTime;
    FILETIME LastAccessTime;
    FILETIME LastWriteTime;
    BOOL DatesBogus = FALSE;

    if (fVerbose)
        fprintf( stderr, "Checking %s\n", p );

    FileHandle = CreateFile( p,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if (FileHandle == NULL) {
        fprintf( stderr, "%s - unable to open (%d)\n", p, GetLastError() );
        return;
        }

    if (!GetFileTime( FileHandle,
                      &CreationTime,
                      &LastAccessTime,
                      &LastWriteTime
                    )
       ) {
        fprintf( stderr, "%s - unable to read file dates (%d)\n", p, GetLastError() );
        CloseHandle( FileHandle );
        return;
        }
    CloseHandle( FileHandle );

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &CurrentTime );

    if (CompareFileTime( &CreationTime, &CurrentTime ) > 0) {
        CreationTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (CompareFileTime( &LastAccessTime, &CurrentTime ) > 0) {
        LastAccessTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (CompareFileTime( &LastWriteTime, &CurrentTime ) > 0) {
        LastWriteTime = CurrentTime;
        DatesBogus = TRUE;
        }

    if (DatesBogus) {
        printf( "%s dates invalid", p );
        if (fQuery) {
            printf( "\n" );
            return;
            }

        FileHandle = CreateFile( p,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                               );
        if (FileHandle == NULL) {
            printf( " - unable to open for write (%d)\n", GetLastError() );
            }
        else {
            if (!SetFileTime( FileHandle,
                              &CreationTime,
                              &LastAccessTime,
                              &LastWriteTime
                            )
               ) {
                printf( " - unable to modify file dates (%d)\n", GetLastError() );
                }
            else {
                printf( " - reset to current date/time\n" );
                }

            CloseHandle( FileHandle );
            }
        }

    return;
}


void
DoFiles(
    char *p,
    struct findType *b,
    void *Args
    )
{
    if (strcmp (b->fbuf.cFileName, ".") &&
        strcmp (b->fbuf.cFileName, "..") &&
        _stricmp (b->fbuf.cFileName, "slm.dif")
       ) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
                case '/':
                case '\\':  strcat (p, "*.*");  break;
                default:    strcat (p, "\\*.*");
                }

            if (fRecurse) {
                fprintf( stderr, "Scanning %s\n", p );
                forfile( p,
                         FILE_ATTRIBUTE_DIRECTORY,
                         DoFiles,
                         NULL
                       );
                }
            }
        else {
            DoFile( p );
            }
        }

    Args;
}

void
Usage( void )
{
    fprintf( stderr, "usage: datefix [-q] [-r] [-v] [DirectorySpec(s)]\n" );
    fprintf( stderr, "Where...\n");
    fprintf( stderr, "\t-q\tQuery only - don't actually make changes.\n");
    fprintf( stderr, "\t-r\tRecurse.\n");
    fprintf( stderr, "\t-v\tVerbose - show files being checked.\n");
    fprintf( stderr, "\tDirectorySpec - one or more directories to examime.\n" );
    exit( 1 );
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s, pathBuf[ 64 ];
    int FileArgsSeen = 0;

    if (argc < 2) {
        Usage();
        }

    fQuery = FALSE;
    fRecurse = FALSE;
    fVerbose = FALSE;

    for (i=1; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'q':   fQuery = TRUE;  break;
                    case 'r':   fRecurse = TRUE;  break;
                    case 'v':   fVerbose = TRUE;  break;
                    default:    Usage();
                    }
                }
            }
        else {
            FileArgsSeen++;
            if (GetFileAttributes( s ) & FILE_ATTRIBUTE_DIRECTORY) {
                s = strcpy( pathBuf, s );
                switch (s[strlen(s)-1]) {
                    case '/':
                    case '\\':  strcat (s, "*.*");  break;
                    default:    strcat (s, "\\*.*");
                    }
                fprintf( stderr, "Scanning %s\n", s );
                forfile( s,
                         FILE_ATTRIBUTE_DIRECTORY,
                         DoFiles,
                         NULL
                       );
                }
            else {
                DoFile( s );
                }
            }
        }

    if (FileArgsSeen == 0) {
        s = "*.*";
        fprintf( stderr, "Scanning .\\%s\n", s );
        forfile( s,
                 FILE_ATTRIBUTE_DIRECTORY,
                 DoFiles,
                 NULL
               );
        }

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\setup.h ===
#include "setupdef.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "comstf.h"
#include "install.h"
#include "uilstf.h"
#include "cmnds.h"
#include "dospif.h"

//_dt_system(Install)
//_dt_subsystem(ProgMan Operations)

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );


#define MAX_DIR     128
#define MAX_NAME    16
#define MAX_BUILD_W 4
#define MAX_MEM_W   8
#define MAX_DATETIME 20



_dt_private BOOL APIENTRY FDdeInit(HANDLE hInst);
_dt_private BOOL APIENTRY FCreateProgManItem(SZ szGroup, SZ szItem, SZ szCmd, SZ szIconFile, INT nIconNum, CMO cmo, BOOL CommonGroup);
VOID MakeFileName(char *Buffer, char *Path, char *FileName);
VOID ReadIniFile(char * filename);
VOID WriteIniFile(char * filename);
INT_PTR SignonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR ValuesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mttf\setup\progcm.c ===
/* File: progcm.c */
/**************************************************************************/
/*	Install: Program Manager commands.
/*	Uses DDE to communicate with ProgMan
/*	Can create groups, delete groups, add items to groups
/*	Originally written 3/9/89 by toddla (the stuff that looks terrible)
/*	Munged greatly for STUFF 4/15/91 by chrispi (the stuff that doesn't work)
/**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <cmnds.h>
#include <dde.h>
#include "install.h"
#include "uilstf.h"

#define BIG_ENUF 1024
_dt_system(Install)
_dt_subsystem(ProgMan Operations)

HANDLE
ExecuteApplication(
    LPSTR lpApp,
    WORD  nCmdShow
    );

HWND hwndFrame;
HWND hwndProgressGizmo;

CHAR	szProgMan[] = "PROGMAN";
HWND	hwndDde     = NULL;        // dummy window to handle DDE messages
HWND	hwndProgMan = NULL;        // global handle of progman window
BOOL	fInitiate   = fFalse;      // are we initializing?
BOOL    fAck        = fFalse;
BOOL    fProgManExeced     = fFalse;
HANDLE  hInstCur    = NULL;


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeTerminate(VOID)
{
	PreCondition(hwndProgMan != NULL, fFalse);
    PreCondition(hwndDde     != NULL, fFalse);

    SetForegroundWindow(hwndFrame);
    UpdateWindow(hwndFrame);
    MPostWM_DDE_TERMINATE( hwndProgMan, hwndDde );
	hwndProgMan = NULL;

	return(fTrue);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
LONG_PTR
APIENTRY
WndProcDde(
           HWND hwnd,
           UINT uiMessage,
           WPARAM wParam,
		   LPARAM lParam
           )
{
	AssertDataSeg();

    switch (uiMessage) {

    case WM_DDE_TERMINATE:

        if(hwndProgMan == NULL) {
            DestroyWindow(hwnd);
            hwndDde = NULL;
        }
        else {
            EvalAssert(FDdeTerminate());
        }

        DDEFREE( uiMessage, lParam );
        return(0L);

    case WM_DDE_ACK:

        if (fInitiate) {

            ATOM aApp   = LOWORD(lParam);
            ATOM aTopic = HIWORD(lParam);

            hwndProgMan = (HWND)wParam;     //conversation established 1632
            GlobalDeleteAtom (aApp);
            GlobalDeleteAtom (aTopic);
        }

        else {

            WORD   wStatus   = GET_WM_DDE_EXECACK_STATUS(wParam, lParam);
            HANDLE hCommands = GET_WM_DDE_EXECACK_HDATA(wParam, lParam);
            if (hCommands) {
                fAck = ((DDEACK *)(&wStatus))->fAck;
                GlobalFree(hCommands);
            }

            DDEFREE( uiMessage, lParam );
        }

        return(0L);

    default:

        break;

    }

	return(DefWindowProc(hwnd, uiMessage, wParam, lParam));
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeInit(
         HANDLE hInst
         )
{

    if (hInst == NULL) {

        /* try to re-init with hInst from last FDdeInit call */

        if (hInstCur == NULL) {
            return(fFalse);
        }

		hInst = hInstCur;
    }
    else {

        hInstCur = hInst;

    }

    if (hwndDde == NULL) {

		static CHP szClassName[] = "ddeClass";
		WNDCLASS rClass;

		Assert(hwndProgMan == NULL);

        if (!GetClassInfo(hInst, szClassName, &rClass)) {
			rClass.hCursor       = NULL;
			rClass.hIcon         = NULL;
			rClass.lpszMenuName  = NULL;
			rClass.lpszClassName = szClassName;
			rClass.hbrBackground = NULL;
			rClass.hInstance     = hInst;
			rClass.style         = 0;
			rClass.lpfnWndProc   = WndProcDde;
			rClass.cbClsExtra    = 0;
			rClass.cbWndExtra    = 0;

            if (!RegisterClass(&rClass)) {
                return(fFalse);
            }

        }

        hwndDde = CreateWindow(
                       szClassName,
                       NULL,
                       0L,
                       0, 0, 0, 0,
                       (HWND)NULL,
                       (HMENU)NULL,
                       (HANDLE)hInst,
                       (LPSTR)NULL
                       );
    }

	return(hwndDde != NULL);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
VOID
APIENTRY
DdeSendConnect(
               ATOM aApp,
               ATOM aTopic
               )
{
    fInitiate = fTrue;
    SendMessage(
        (HWND)-1,
        WM_DDE_INITIATE,
        (WPARAM)hwndDde,
        MAKELONG(aApp, aTopic)
        );
    fInitiate = fFalse;
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeConnect(
            SZ szApp,
            SZ szTopic
            )
{
    BOOL   fStatus = fTrue;
    MSG    rMsg;
    HANDLE hProcess = NULL;

    //
    // Form the Global Atoms used to indicate the app and topic
    //

	ATOM aApp   = GlobalAddAtom(szApp);
	ATOM aTopic = GlobalAddAtom(szTopic);

    //
    // Connect to the progman dde server
    //

    DdeSendConnect(aApp, aTopic);

    if (hwndProgMan == NULL) {

        //
        // If the connect failed then try to run progman.
        //

        if ((hProcess = ExecuteApplication("PROGMAN /NTSETUP", SW_SHOWNORMAL)) == NULL ) {
            fStatus = fFalse;
        }
        else {
            INT i;
            DWORD dw;
            #define TIMEOUT_INTERVAL  120000

            //
            // Indicate that Progman has been execed
            //

            fProgManExeced = fTrue;

            //
            // exec was successful, first wait for input idle
            //

            if( (dw = WaitForInputIdle( hProcess, TIMEOUT_INTERVAL )) != 0 ) {
                CloseHandle( hProcess );
                fStatus = fFalse;
            }
            else {
                CloseHandle( hProcess );

                //
                // Empty the message queue till no messages
                // are left in the queue or till WM_ACTIVATEAPP is processed. Then
                // try connecting to progman.  I am using PeekMessage followed
                // by GetMessage because PeekMessage doesn't remove some messages
                // ( WM_PAINT for one ).
                //

                while ( PeekMessage( &rMsg, hwndFrame, 0, 0, PM_NOREMOVE ) &&
                        GetMessage(&rMsg, NULL, 0, 0) ) {

                    if (TRUE
                            && (hwndProgressGizmo == NULL
                                || !IsDialogMessage(hwndProgressGizmo, &rMsg))) {
                        TranslateMessage(&rMsg);
                        DispatchMessage(&rMsg);
                    }

                    if ( rMsg.message == WM_ACTIVATEAPP ) {
                        break;
                    }

                }
                DdeSendConnect(aApp, aTopic);
            }
        }
    }

    //
    // Delete the atom resources
    //

	GlobalDeleteAtom(aApp);
    GlobalDeleteAtom(aTopic);

    return ( fStatus );
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeWait(VOID)
{
    MSG   rMsg;
    BOOL  fResult   = fTrue;
    DWORD dwTimeOut, dwTickDelta, dwLastTick, dwCurrentTick;

	Assert(hwndProgMan != NULL);
	Assert(hwndDde != NULL);

    //
    // Set timeout for 30 seconds from now.  This assumes that it will
    // take less than 30 seconds for Progman to respond.
    //

    dwTimeOut  = 30000L;
    dwLastTick = GetTickCount();

    while (TRUE) {

        //
        // While there is a connection established to progman and there
        // are DDE messages we can fetch, fetch the messages dispatch them
        // and try to find out if they are terminators (data, ack or terminate)
        //

        while (
            hwndProgMan != NULL &&
            PeekMessage(&rMsg, NULL, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE)
            ) {

            TranslateMessage(&rMsg);
            DispatchMessage(&rMsg);

            if (rMsg.wParam == (WPARAM)hwndProgMan) {
                switch (rMsg.message) {

                case WM_DDE_ACK:
                    return ( fAck );

                case WM_DDE_DATA:
                    return (fTrue);

                default:
                    break;
                }
            }
        }


        //
        // If connection to progman has been broken, this may be resulting
        // from a terminate, so return true
        //

        if (hwndProgMan == NULL) {
            return (fTrue);
        }

        //
        // Check to see if timeout hasn't been reached.  If the timeout is
        // reached we will assume that our command succeeded (for want of
        // a better verification scheme
        //
        dwTickDelta = ((dwCurrentTick = GetTickCount()) < dwLastTick) ?
                             dwCurrentTick : (dwCurrentTick - dwLastTick);

        if (dwTimeOut < dwTickDelta) {
            return (fTrue);
        }

        dwTimeOut  = dwTimeOut - dwTickDelta;
        dwLastTick = dwCurrentTick;

        //
        // Lastly, since user doesn't have idle detection, we will be
        // sitting in a tight loop here.  To prevent this just do a
        // sleep for 250 milliseconds.
        //

        Sleep( 250 );

    }

    return(fTrue);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FDdeExec(
         SZ szCmd
         )
{
	BOOL   bResult = fFalse;
	HANDLE hCmd;

	Assert(hwndProgMan != NULL);
	Assert(hwndDde != NULL);

    hCmd = GlobalAlloc(GMEM_DDESHARE, (LONG)CchpStrLen(szCmd) + 1);
    if (hCmd != NULL) {

		LPSTR lpCmd = GlobalLock(hCmd);

        if (lpCmd != NULL) {
			lstrcpy(lpCmd, szCmd);
            GlobalUnlock(hCmd);
            MPostWM_DDE_EXECUTE(hwndProgMan, hwndDde, hCmd);
            bResult = FDdeWait();
        }

        else {
            GlobalFree(hCmd);
        }
    }

	return(bResult);
}


/*
**	Purpose:
**	Arguments:
**	Returns:
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FActivateProgMan(VOID)
{
    //
    // Find out if the dde client window has been started, if not start it
    //

    if (hwndDde == NULL) {
        if (!FDdeInit(NULL)) {
            return(fFalse);
        }
		Assert(hwndDde != NULL);
    }

    //
    // Find out if the connection has been established with the progman
    // server, if not try to connect
    //

    if (hwndProgMan == NULL) {
        //
        // Try to conncect and then see if we were successful
        //
        if ( (!FDdeConnect(szProgMan, szProgMan)) ||
             (hwndProgMan == NULL)
           ) {
            return(fFalse);
        }
    }

    //
    // Bring progman to the foreground
    //

    SetForegroundWindow(hwndProgMan);

    //
    // If progman is iconic restore it
    //

    if (GetWindowLong(hwndProgMan, GWL_STYLE) & WS_ICONIC) {
        ShowWindow(hwndProgMan, SW_RESTORE);
    }

	return(fTrue);
}


/*
**	Purpose:
**		Creates a new Program Manager group.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		fTrue if group was created, or already existed
**		fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FCreateProgManGroup(
                    SZ szGroup,
                    SZ szPath,
                    CMO cmo,
                    BOOL CommonGroup
                    )
{
    static CHP szCmdBase[] = "[CreateGroup(%s%s%s,%s)]";
	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

    if (szPath == NULL) {
        szPath = "";
    }

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, (*szPath ? "," : szPath), szPath, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Removes a Program Manager group.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		fTrue if successful if removed, or didn't exist
**		fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FRemoveProgManGroup(
                    SZ szGroup,
                    CMO cmo,
                    BOOL CommonGroup
                    )
{
    static CHP szCmdBase[] = "[DeleteGroup(%s,%s)]";
	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Shows a program manager group in one of several different ways
**		based upon the parameter szCommand.
**	Arguments:
**		szGroup:   non-NULL, non-empty group to show.
**		szCommand: non-NULL, non-empty command to exec.
**		cmo:       Valid command options - cmoVital and cmoNone.
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FShowProgManGroup(
                  SZ szGroup,
                  SZ szCommand,
                  CMO cmo,
                  BOOL CommonGroup
                  )
{
    static CHP szCmdBase[] = "[ShowGroup(%s, %s,%s)]";
	CCHP cchp;
    CHP  szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
	EERC eerc;

	ChkArg((szGroup   != (SZ)NULL) && (*szGroup != '\0'), 1, fFalse);
	ChkArg((szCommand != (SZ)NULL) && (*szCommand != '\0'), 2, fFalse);

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szGroup, szCommand, CommonGroup ? "1" : "0");

    FDdeExec(szBuf);

	return(fTrue);
}


/*
**	Purpose:
**		Creates a new Program Manager item.
**		Always attempts to create the group if it doesn't exist.
**	Arguments:
**		Valid command options:
**			cmoVital
**			cmoOverwrite
**	Notes:
**		Initializes and activates the DDE communication if it is not
**		currently open.
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private BOOL APIENTRY
FCreateProgManItem(
    SZ  szGroup,
    SZ  szItem,
    SZ  szCmd,
    SZ  szIconFile,
    INT nIconNum,
    CMO cmo,
    BOOL CommonGroup
    )
{
    static CHP szCmdBase[] = "[AddItem(%s, %s, %s, %d)]";

	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
    EERC eerc;
    BOOL bStatus;

    FActivateProgMan();

    wsprintf(szBuf, szCmdBase, szCmd, szItem, szIconFile, nIconNum+666);

    bStatus = FDdeExec(szBuf);

    return(bStatus);
}


/*
**	Purpose:
**		Removes a program manager item.
**	Arguments:
**		Valid command options:
**			cmoVital
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FRemoveProgManItem(
                   SZ szGroup,
                   SZ szItem,
                   CMO cmo,
                   BOOL CommonGroup
                   )
{
    static CHP szCmdBase[] = "[DeleteItem(%s)]";

	CCHP cchp;
    char szBuf[BIG_ENUF];
	BOOL fVital = cmo & cmoVital;
    EERC eerc;
    BOOL bStatus;

    FActivateProgMan();

    FCreateProgManGroup(szGroup, NULL, cmoVital, CommonGroup);

    wsprintf(szBuf, szCmdBase, szItem);

    bStatus = FDdeExec(szBuf);

    return(bStatus);

}


/*
**	Purpose:
**		Initializes the DDE window for communication with ProgMan
**		Does not actually initiate a conversation with ProgMan
**	Arguments:
**		hInst	instance handle for the setup application
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FInitProgManDde(
                HANDLE hInst
                )
{
    if (hwndDde == NULL) {
        return(FDdeInit(hInst));
    }

	return(fTrue);
}


/*
**	Purpose:
**		Closes conversation with ProgMan (if any) and destroys
**		the DDE communication window (if any)
**	Arguments:
**		(none)
**	Returns:
**		Returns fTrue if successful, fFalse otherwise.
**
**************************************************************************/
_dt_private
BOOL
APIENTRY
FEndProgManDde(VOID)
{

    //
    // if we execed progman then we should try to close it down.  When we
    // send a close message it will post us a WM_DDE_TERMINATE message
    // eventaully.  else we haven't started progman so we just need to
    // terminate the connection.
    //

    if (fProgManExeced) {

        fProgManExeced = fFalse;

        //
        // Clean up connection to progman
        //

        if (hwndProgMan) {
            SetForegroundWindow(hwndFrame);
            UpdateWindow(hwndFrame);
            FDdeExec("[exitprogman(1)]");  // close save state
            hwndProgMan = NULL;
        }

        //
        // Destroy the DDE Window if need be
        //

        if (hwndDde) {
            DestroyWindow(hwndDde);
            hwndDde = NULL;
        }

    }

    else if (hwndProgMan != NULL) {
        EvalAssert( FDdeTerminate() );
    }

    else if (hwndDde != NULL) {
        DestroyWindow (hwndDde);
        hwndDde = NULL;
    }

    return (fTrue);

}


/*
**	Purpose:
**  Arguments:
**  Returns:
**
**************************************************************************/
HANDLE
ExecuteApplication(
    LPSTR lpApp,
    WORD  nCmdShow
    )
{
    BOOL                fStatus;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

#if DBG
    DWORD               dwLastError;
#endif

    //
    // Initialise Startup info
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpDesktop = NULL;
    si.lpTitle = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = nCmdShow;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    //
    // Execute using Create Process
    //

    fStatus = CreateProcess(
                  (LPSTR)NULL,                  // lpApplicationName
                  lpApp,                        // lpCommandLine
                  (LPSECURITY_ATTRIBUTES)NULL,  // lpProcessAttributes
                  (LPSECURITY_ATTRIBUTES)NULL,  // lpThreadAttributes
                  DETACHED_PROCESS,             // dwCreationFlags
                  FALSE,                        // bInheritHandles
                  (LPVOID)NULL,                 // lpEnvironment
                  (LPSTR)NULL,                  // lpCurrentDirectory
                  (LPSTARTUPINFO)&si,           // lpStartupInfo
                  (LPPROCESS_INFORMATION)&pi    // lpProcessInformation
                  );

    //
    // Since we are execing a detached process we don't care about when it
    // exits.  To do proper book keeping, we should close the handles to
    // the process handle and thread handle
    //

    if (fStatus) {
        CloseHandle( pi.hThread );
        return( pi.hProcess );
    }
#if DBG
    else {
        dwLastError = GetLastError();
    }
#endif

    //
    // Return the status of this operation

    return ( (HANDLE)NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munge\munge.c ===
/*
 * Utility program to munge a set of files, translating names from
 * one form to another.  Usage:
 *
 *      munge scriptFile files...
 *
 * where the first parameter is the name of a file that consists of
 * one or more lines of the following format:
 *
 *      oldName newName
 *
 * and the remaining parameters are the names of the files to munge.
 * Each file is _read into memory, scanned once, where each occurence
 * of an oldName string is replaced by its corresponding newName.
 * If any changes are made to a file, the old version is RMed and
 * the new version written out under the same name.
 *
 */

#include "munge.h"

BOOL SymbolsInserted;
BOOL InitTokenMappingTable( void );
BOOL SaveTokenMapping( char *, char * );
char *FindTokenMapping( char * );

#define MAXFILESIZE 0x1000000L
char *InputFileBuf;
char *OutputFileBuf;
int fClean;
int fQuery;
int fFileOnly;
int fRecurse;
int fUseAttrib;
int fUseSLM;
int fForceSLM;
int fTrustMe;
int fVerbose;
int fSummary;
int fRemoveDuplicateCR;
int fRemoveImbeddedNulls;
int fTruncateWithCtrlZ;
int fInsideQuotes;
int fInsideComments;
int fNeuter;
int fCaseSensitive;
int fEntireLine;

#define MAX_LITERAL_STRINGS 64

void
DoFiles(
       char *p,
       struct findType *b,
       void *Args
       );

unsigned long NumberOfLiteralStrings;
char *LiteralStrings[ MAX_LITERAL_STRINGS ];
unsigned long LiteralStringsLength[ MAX_LITERAL_STRINGS ];
char *NewLiteralStrings[ MAX_LITERAL_STRINGS ];
char LeadingLiteralChars[ MAX_LITERAL_STRINGS+1 ];

unsigned long NumberOfFileExtensions = 0;
char *FileExtensions[ 64 ];

unsigned long NumberOfFileNames = 0;
char *FileNames[ 64  ];

unsigned long NumberOfFileNameAndExts = 0;
char *FileNameAndExts[ 64 ];


char *UndoScriptFileName;
FILE *UndoScriptFile;
int UndoCurDirCount;

void
DisplayFilePatterns( void );

char *
PushCurrentDirectory(
                    char *NewCurrentDirectory
                    );

void
PopCurrentDirectory(
                   char *OldCurrentDirectory
                   );


NTSTATUS
CreateSymbolTable(
                 IN ULONG NumberOfBuckets,
                 IN ULONG MaxSymbolTableSize,
                 OUT PVOID *SymbolTableHandle
                 );

NTSTATUS
AddSymbolToSymbolTable(
                      IN PVOID SymbolTableHandle,
                      IN PUNICODE_STRING SymbolName,
                      IN ULONG_PTR *SymbolValue OPTIONAL
                      );

NTSTATUS
LookupSymbolInSymbolTable(
                         IN PVOID SymbolTableHandle,
                         IN PUNICODE_STRING SymbolName,
                         OUT ULONG_PTR *SymbolValue OPTIONAL
                         );

BOOL
myread( int fh, unsigned long cb )
{
    HANDLE InputFileMapping;

    InputFileMapping = CreateFileMapping( (HANDLE)_get_osfhandle( fh ),
                                          NULL,
                                          PAGE_READONLY,
                                          0,
                                          cb,
                                          NULL
                                        );

    if (InputFileMapping == NULL) {
        if (cb != 0) {
            fprintf( stderr, "Unable to map file (%d) - ", GetLastError() );
        }

        return FALSE;
    }

    InputFileBuf = MapViewOfFile( InputFileMapping,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  cb
                                );

    CloseHandle( InputFileMapping );
    if (InputFileBuf == NULL) {
        if (cb != 0) {
            fprintf( stderr, "Unable to map view (%d) - ", GetLastError() );
        }

        CloseHandle( InputFileMapping );
        return FALSE;
    } else {
        return TRUE;
    }
}

unsigned long mywrite( int fh, char *s, unsigned long cb )
{
    unsigned long cbWritten;

    if (!WriteFile( (HANDLE)_get_osfhandle( fh ), s, cb, &cbWritten, NULL )) {
        printf( "(%d)", GetLastError() );
        return 0L;
    } else {
        return cbWritten;
    }
}


static char lineBuf[ 1024 ];

ReadScriptFile( s )
char *s;
{
    FILE *fh;
    int lineNum, result;
    char *pOldName, *pNewName, *pEnd;
    unsigned n;
    char LeadingChar, QuoteChar, SaveChar;

    NumberOfLiteralStrings = 0;

    n = 0;
    fprintf( stderr, "Reading script file - %s", s );
    if ( !( fh = fopen( s, "r" ) ) ) {
        fprintf( stderr, " *** unable to open\n" );
        return FALSE;
    }

    result = TRUE;
    lineNum = -1;
    while ( pOldName = fgets( lineBuf, sizeof( lineBuf ), fh ) ) {
        lineNum++;
        while ( *pOldName == ' ' )
            pOldName++;

        if (*pOldName == '-' && (pOldName[1] == 'f' || pOldName[1] == 'F')) {
            pOldName += 2;
            while (*pOldName) {
                while (*pOldName == ' ') {
                    pOldName++;
                }

                pEnd = pOldName;
                while (*pEnd > ' ') {
                    pEnd++;
                }
                SaveChar = *pEnd;
                *pEnd = '\0';

                if (*pOldName == '.') {
                    FileExtensions[ NumberOfFileExtensions++ ] = _strlwr( MakeStr( ++pOldName ) );
                } else
                    if (pEnd > pOldName && pEnd[ -1 ] == '.') {
                    pEnd[ - 1 ] = '\0';
                    FileNames[ NumberOfFileNames++ ] = _strlwr( MakeStr( pOldName ) );
                } else {
                    FileNameAndExts[ NumberOfFileNameAndExts++ ] = _strlwr( MakeStr( pOldName ) );
                }

                *pEnd = SaveChar;
                pOldName = pEnd;
            }
        } else
            if (*pOldName == '"' || *pOldName == '\'') {
            if (NumberOfLiteralStrings >= MAX_LITERAL_STRINGS) {
                fprintf( stderr, " *** too many literal strings\n" );
                fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                result = FALSE;
                break;
            }

            QuoteChar = *pOldName;
            LeadingChar = *++pOldName;
            pNewName = pOldName;
            while (*pNewName >= ' ' && *pNewName != QuoteChar) {
                pNewName++;
            }

            if (*pNewName != QuoteChar) {
                fprintf( stderr, " *** invalid literal string\n" );
                fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                result = FALSE;
                continue;
            }

            *pNewName++ = '\0';
            while ( *pNewName == ' ' )
                pNewName++;

            if (*pNewName != QuoteChar) {
                if (!fQuery) {
                    fprintf( stderr, " *** invalid literal string\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }
            } else {
                PUCHAR pDest, pSrc;
                BOOL fEscaped = FALSE;

                pEnd = ++pNewName;
                pDest = pSrc = pEnd;

                while ((*pSrc >= ' ') && ((*pSrc != QuoteChar) || fEscaped)) {
                    if (fEscaped) {
                        switch(pSrc[0]) {
                            case 'n':
                                *pDest++ = '\r';
                                *pDest++ = '\n';
                                break;
                            default:
                                *pDest++ = *pSrc;
                                break;
                        }
                        fEscaped = FALSE;
                    } else {
                        if (pSrc[0] == '\\') {
                            fEscaped = TRUE;
                        } else {
                            *pDest++ = *pSrc;
                        }
                    }
                    pSrc++;
                }

                pEnd = pSrc;

                if (*pEnd != QuoteChar) {
                    fprintf( stderr, " *** invalid literal string\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }
                *pDest = '\0';
            }

            LiteralStrings[ NumberOfLiteralStrings ] = MakeStr( ++pOldName );
            LiteralStringsLength[ NumberOfLiteralStrings ] = strlen( pOldName );
            NewLiteralStrings[ NumberOfLiteralStrings ] = MakeStr( pNewName );
            LeadingLiteralChars[ NumberOfLiteralStrings ] = LeadingChar;
            NumberOfLiteralStrings += 1;
        } else {
            pNewName = pOldName;
            while ( *pNewName != '\0' && *pNewName != ' ' ) {
                pNewName += 1;
            }

            if (*pNewName == '\0') {
                if (!fQuery) {
                    if (result)
                        fprintf( stderr, " *** invalid script file\n" );
                    fprintf( stderr, "%s(%d) - %s\n", s, lineNum, &lineBuf[ 0 ] );
                    result = FALSE;
                    continue;
                }

                while (pNewName > pOldName && pNewName[ -1 ] < ' ') {
                    *--pNewName = '\0';
                }

                pNewName = MakeStr( pOldName );
            } else {
                *pNewName++ = 0;
                while ( *pNewName == ' ' )
                    pNewName++;

                pEnd = pNewName;
                while ( *pEnd > ' ' )
                    pEnd++;
                *pEnd = 0;
                pNewName = MakeStr( pNewName );
            }

            if (!pNewName || !SaveTokenMapping(  pOldName, pNewName )) {
                if (result)
                    fprintf( stderr, " *** out of memory\n" );
                if (pNewName) {
                    free(pNewName);
                }
                fprintf( stderr, "%s(%d) - can't add symbol '%s'\n", s, lineNum, pOldName );
                result = FALSE;
            } else {
                SymbolsInserted = TRUE;
                n++;
            }
        }
    }

    fclose( fh );
    if (result) {
        fprintf( stderr, " %d tokens", n );
        if (NumberOfLiteralStrings) {
            fprintf( stderr, " and %d literal strings\n", NumberOfLiteralStrings );
        } else {
            fprintf( stderr, "\n" );
        }

        if (!NumberOfFileExtensions && !NumberOfFileNames && !NumberOfFileNameAndExts) {
            FileExtensions[ NumberOfFileExtensions++ ] = "asm";
            FileExtensions[ NumberOfFileExtensions++ ] = "bat";
            FileExtensions[ NumberOfFileExtensions++ ] = "c";
            FileExtensions[ NumberOfFileExtensions++ ] = "cli";
            FileExtensions[ NumberOfFileExtensions++ ] = "cpp";
            FileExtensions[ NumberOfFileExtensions++ ] = "cxx";
            FileExtensions[ NumberOfFileExtensions++ ] = "def";
            FileExtensions[ NumberOfFileExtensions++ ] = "dlg";
            FileExtensions[ NumberOfFileExtensions++ ] = "h";
            FileExtensions[ NumberOfFileExtensions++ ] = "htm";
            FileExtensions[ NumberOfFileExtensions++ ] = "hpj";
            FileExtensions[ NumberOfFileExtensions++ ] = "hxx";
            FileExtensions[ NumberOfFileExtensions++ ] = "idl";
            FileExtensions[ NumberOfFileExtensions++ ] = "inc";
            FileExtensions[ NumberOfFileExtensions++ ] = "inf";
            FileExtensions[ NumberOfFileExtensions++ ] = "lic";
            FileExtensions[ NumberOfFileExtensions++ ] = "mak";
            FileExtensions[ NumberOfFileExtensions++ ] = "mc";
            FileExtensions[ NumberOfFileExtensions++ ] = "odl";
            FileExtensions[ NumberOfFileExtensions++ ] = "rc";
            FileExtensions[ NumberOfFileExtensions++ ] = "rcv";
            FileExtensions[ NumberOfFileExtensions++ ] = "reg";
            FileExtensions[ NumberOfFileExtensions++ ] = "s";
            FileExtensions[ NumberOfFileExtensions++ ] = "src";
            FileExtensions[ NumberOfFileExtensions++ ] = "srv";
            FileExtensions[ NumberOfFileExtensions++ ] = "tk";
            FileExtensions[ NumberOfFileExtensions++ ] = "w";
            FileExtensions[ NumberOfFileExtensions++ ] = "x";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "makefil0";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "makefile";
            FileNameAndExts[ NumberOfFileNameAndExts++ ] = "sources";
        }
    }

    return result;
}


int
MungeFile(
         int fRepeatMunge,
         char *FileName,
         char *OldBuf,
         unsigned long OldSize,
         char *NewBuf,
         unsigned long MaxNewSize,
         unsigned long *FinalNewSize
         )
{
    unsigned long NewSize = MaxNewSize;
    unsigned Changes = 0;
    unsigned LineNumber;
    char c, *Identifier, *BegLine, *EndLine, *OrigOldBuf;
    char IdentifierBuffer[ 256 ];
    char *p, *p1;
    int i, j, k;
    BOOL TruncatedByCtrlZ;
    BOOL ImbeddedNullsStripped;
    BOOL DuplicateCRStripped;
    BOOL InSingleQuotes;
    BOOL InDoubleQuotes;
    BOOL Escape = FALSE;
    BOOL Star = FALSE;
    BOOL Backslash = FALSE;
    BOOL Pound = FALSE;
    BOOL Semi = FALSE;
    BOOL LastEscape;
    BOOL LastStar;
    BOOL LastBackslash;
    BOOL LastPound;
    BOOL LastSemi;
    BOOL SkipChar;
    BOOL InLineComment;
    BOOL InComment;

    *FinalNewSize = 0;
    LineNumber = 1;
    TruncatedByCtrlZ = FALSE;
    ImbeddedNullsStripped = FALSE;
    DuplicateCRStripped = FALSE;
    InSingleQuotes = FALSE;
    InDoubleQuotes = FALSE;
    InLineComment = FALSE;
    InComment = FALSE;
    LastEscape = FALSE;
    LastStar = FALSE;
    LastBackslash = FALSE;
    OrigOldBuf = OldBuf;

    while (OldSize) {
        OldSize--;
        c = *OldBuf++;
        if (c == '\r') {
            while (OldSize && *OldBuf == '\r') {
                DuplicateCRStripped = TRUE;
                OldSize--;
                c = *OldBuf++;
            }
        }

        if (c == 0x1A) {
            TruncatedByCtrlZ = TRUE;
            break;
        }

        SkipChar = FALSE;

        if ( !fInsideQuotes || !fInsideComments ) {
            LastEscape    = Escape;
            LastStar      = Star;
            LastBackslash = Backslash;
            LastPound     = Pound;
            LastSemi      = Semi;

            Escape    = (c == '\\');
            Star      = (c == '*' );
            Backslash = (c == '/' );
            Pound     = (c == '#' );
            Semi      = (c == ';' );

            if ( Escape && LastEscape ) {   // two in a row don't mean escape
                Escape = FALSE;
            }

            if ( c == '\r' || c == '\n' ) {
                InLineComment = FALSE;
            }


            // Don't process Include or Pragma directives
            if ( LastPound && OldSize > 6 ) {
                if ( !strncmp(OldBuf-1,"include",7)
                     || !strncmp(OldBuf-1,"pragma",6) ) {
                    InLineComment = TRUE;
                }
            }

            if (c == '"' && !InSingleQuotes && !LastEscape
                && !InLineComment && !InComment ) {
                InDoubleQuotes = !InDoubleQuotes;
                if ( fNeuter ) {
                    if ( InDoubleQuotes ) {
                        if ( NewSize < 5 ) {
                            return( -1 );
                        }
                        strcpy(NewBuf,"TEXT(");
                        NewBuf+=5;
                        NewSize -= 5;
                    } else {
                        if ( NewSize < 1 ) {
                            return( -1 );
                        }
                        *NewBuf++ = '"';
                        NewSize--;
                        c = ')';
                    }
                }
            }

            if (c == '\'' && !InDoubleQuotes && !LastEscape
                && !InLineComment && !InComment ) {
                InSingleQuotes = !InSingleQuotes;
                if ( fNeuter ) {
                    if ( InSingleQuotes ) {
                        if ( NewSize < 5 ) {
                            return( -1 );
                        }
                        strcpy(NewBuf,"TEXT(");
                        NewBuf+=5;
                        NewSize -= 5;
                    } else {
                        if ( NewSize < 1 ) {
                            return( -1 );
                        }
                        *NewBuf++ = '\'';
                        NewSize--;
                        c = ')';
                    }
                }
            }
            if ( !InDoubleQuotes && !InSingleQuotes
                 && !InLineComment && !InComment ) {
                if ( LastBackslash ) {
                    switch (c) {
                        case '*':   InComment = TRUE;       break;
                        case '/':   InLineComment = TRUE;   break;
                    }
                }
            }

            if ( InComment && LastStar && Backslash ) {
                InComment = FALSE;
            }

            if ( !fInsideQuotes && ( InSingleQuotes || InDoubleQuotes ) ) {
                SkipChar = TRUE;
            } else
                if ( !fInsideComments && ( InLineComment || InComment ) ) {
                SkipChar = TRUE;
            }
        }

        if (c != 0 && NumberOfLiteralStrings != 0 && !SkipChar ) {
            p = LeadingLiteralChars;
            while (p = strchr( p, c )) {
                i = (int)(p - LeadingLiteralChars);
                p++;
                if (OldSize >= LiteralStringsLength[ i ]) {
                    p1 = IdentifierBuffer;
                    Identifier = OldBuf;
                    j = LiteralStringsLength[ i ];
                    while (j--) {
                        *p1++ = *Identifier++;
                    }
                    *p1 = '\0';

                    if (!strcmp( LiteralStrings[ i ], IdentifierBuffer )) {
                        BegLine = OldBuf - 1;
                        OldSize -= LiteralStringsLength[ i ];
                        OldBuf = Identifier;
                        p1 = NewLiteralStrings[ i ];

                        if (!fRepeatMunge && !fSummary) {
                            if (fFileOnly) {
                                if (Changes == 0) { // Display just file name on first match
                                    printf( "%s\n", FileName );
                                }
                            } else {
                                printf( "%s(%d) : ",
                                        FileName,
                                        LineNumber
                                      );
                                if (fQuery) {
                                    EndLine = BegLine;
                                    while (*EndLine != '\0' && *EndLine != '\n') {
                                        EndLine += 1;
                                    }
                                    if (fEntireLine) {
                                        while (BegLine > OrigOldBuf && *BegLine != '\n') {
                                            BegLine -= 1;
                                        }
                                        if (*BegLine == '\n') {
                                            BegLine += 1;
                                        }
                                    }

                                    printf( "%.*s\n", EndLine - BegLine, BegLine );
                                } else {
                                    printf( "Matched \"%c%s\", replace with \"%s\"\n",
                                            c,
                                            LiteralStrings[ i ],
                                            p1
                                          );
                                }
                            }
                            fflush( stdout );
                        }

                        Changes++;
                        while (*p1) {
                            if (NewSize--) {
                                *NewBuf++ = *p1++;
                            } else {
                                return( -1 );
                            }
                        }

                        c = '\0';
                        break;
                    }
                }
            }
        } else {
            p = NULL;
        }

        if (SymbolsInserted && (p == NULL) && iscsymf( c )) {
            BegLine = OldBuf - 1;
            Identifier = IdentifierBuffer;
            k = sizeof( IdentifierBuffer ) - 1;
            while (iscsym( c )) {
                if (k) {
                    *Identifier++ = c;
                    k--;
                } else {
                    break;
                }

                if (OldSize--) {
                    c = *OldBuf++;
                } else {
                    // OldSize will get updated below...
                    c = '\0';
                }
            }

            c = '\0';       // No character to add to output stream

            --OldBuf;       // Went a little too far
            OldSize++;

            *Identifier++ = 0;

            if (k == 0 || (Identifier = FindTokenMapping( IdentifierBuffer )) == NULL || SkipChar ) {
                Identifier = IdentifierBuffer;
            } else {
                if (!fRepeatMunge && !fSummary) {
                    if (fFileOnly) {
                        if (Changes == 0) { // Display just file name on first match
                            printf( "%s\n", FileName );
                        }
                    } else {
                        printf( "%s(%d) : ", FileName, LineNumber );
                        if (fQuery) {
                            EndLine = BegLine;
                            while (*EndLine != '\0' && *EndLine != '\r' && *EndLine != '\n') {
                                EndLine += 1;
                            }
                            if (*EndLine == '\0') {
                                EndLine -= 1;
                            }
                            if (*EndLine == '\n') {
                                EndLine -= 1;
                            }
                            if (*EndLine == '\r') {
                                EndLine -= 1;
                            }

                            if (fEntireLine) {
                                while (BegLine > OrigOldBuf && *BegLine != '\n') {
                                    BegLine -= 1;
                                }
                                if (*BegLine == '\n') {
                                    BegLine += 1;
                                }
                            }

                            printf( "%.*s", EndLine - BegLine + 1, BegLine );
                        } else {
                            printf( "Matched %s replace with %s", IdentifierBuffer, Identifier );
                        }

                        printf( "\n" );
                    }

                    fflush( stdout );
                }

                Changes++;
            }

            while (*Identifier) {
                if (NewSize--) {
                    *NewBuf++ = *Identifier++;
                } else {
                    return( -1 );
                }
            }
        }

        if (c == '\n') {
            LineNumber++;
        }

        if (c != '\0') {
            if (NewSize--) {
                *NewBuf++ = c;
            } else {
                return( -1 );
            }
        } else {
            ImbeddedNullsStripped = TRUE;
        }
    }

    if (!Changes && fClean) {
        if (fTruncateWithCtrlZ && TruncatedByCtrlZ) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : File truncated by Ctrl-Z\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }

        if (fRemoveImbeddedNulls && ImbeddedNullsStripped) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : Imbedded null characters removed.\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }

        if (fRemoveDuplicateCR && DuplicateCRStripped) {
            if (!fRepeatMunge && !fSummary) {
                printf( "%s(%d) : Duplicate Carriage returns removed.\n",
                        FileName,
                        LineNumber
                      );
                fflush( stdout );
            }

            Changes++;
        }
    }

    *FinalNewSize = MaxNewSize - NewSize;
    return( Changes );
}


typedef struct _MUNGED_LIST_ELEMENT {
    struct _MUNGED_LIST_ELEMENT *Next;
    char *FileName;
    int NumberOfChanges;
} MUNGED_LIST_ELEMENT, *PMUNGED_LIST_ELEMENT;

PMUNGED_LIST_ELEMENT MungedListHead;

BOOL
RememberMunge(
             char *FileName,
             int NumberOfChanges
             );

BOOL
CheckIfMungedAlready(
                    char *FileName
                    );

void
DumpMungedList( void );

BOOL
RememberMunge(
             char *FileName,
             int NumberOfChanges
             )
{
    PMUNGED_LIST_ELEMENT p;

    p = (PMUNGED_LIST_ELEMENT)malloc( sizeof( *p ) + strlen( FileName ) + 4 );
    if (p == NULL) {
        return FALSE;
    }

    p->FileName = (char *)(p + 1);
    strcpy( p->FileName, FileName );
    p->NumberOfChanges = NumberOfChanges;
    p->Next = MungedListHead;
    MungedListHead = p;
    return TRUE;
}


BOOL
CheckIfMungedAlready(
                    char *FileName
                    )
{
    PMUNGED_LIST_ELEMENT p;

    p = MungedListHead;
    while (p) {
        if (!strcmp( FileName, p->FileName )) {
            return TRUE;
        }

        p = p->Next;
    }

    return FALSE;
}

void
DumpMungedList( void )
{
    PMUNGED_LIST_ELEMENT p, p1;

    if (!fSummary) {
        return;
    }

    p = MungedListHead;
    while (p) {
        p1 = p;
        printf( "%s(1) : %u changes made to this file.\n", p->FileName, p->NumberOfChanges );
        p = p->Next;
        free( (char *)p1 );
    }
}


void
DoFile( p )
char *p;
{
    int fh, n;
    unsigned long oldSize;
    unsigned long newSize;
    int  count, rc;
    char newName[ 128 ];
    char bakName[ 128 ];
    char CommandLine[ 192 ];
    char *s, *CurrentDirectory;
    DWORD dwFileAttributes;
    int fRepeatMunge;

    if (CheckIfMungedAlready( p )) {
        return;
    }

    if (fVerbose)
        fprintf( stderr, "Scanning %s\n", p );

    strcpy( &newName[ 0 ], p );
    strcpy( &bakName[ 0 ], p );
    for (n = strlen( &newName[ 0 ] )-1; n > 0; n--) {
        if (newName[ n ] == '.') {
            break;
        } else
            if (newName[ n ] == '\\') {
            n = 0;
            break;
        }
    }

    if (n == 0) {
        n = strlen( &newName[ 0 ] );
    }
    strcpy( &newName[ n ], ".mge" );
    strcpy( &bakName[ n ], ".bak" );
    fRepeatMunge = FALSE;

    RepeatMunge:
    if ( (fh = _open( p, O_BINARY )) == -1) {
        fprintf( stderr, "%s - unable to open\n", p );
        return;
    }

    oldSize = _lseek( fh, 0L, 2 );
    _lseek( fh, 0L, 0 );
    count = 0;
    if (oldSize > MAXFILESIZE)
        fprintf( stderr, "%s - file too large (%ld)\n", p, oldSize );
    else
        if (!myread( fh, oldSize )) {
        if (oldSize != 0) {
            fprintf( stderr, "%s - error while reading\n", p );
        }
    } else {
        count = MungeFile( fRepeatMunge,
                           p,
                           InputFileBuf,
                           oldSize,
                           OutputFileBuf,
                           MAXFILESIZE,
                           (unsigned long *)&newSize
                         );
        if (count == -1)
            fprintf( stderr, "%s - output buffer overflow", p );

        UnmapViewOfFile( InputFileBuf );
    }
    _close( fh );

    if (count > 0) {
        if (fRepeatMunge) {
            fprintf( stderr, " - munge again" );
        } else {
            dwFileAttributes = GetFileAttributes( p );
            fprintf( stderr, "%s", p );
        }

        if (!fQuery && _access( p, 2 ) == -1) {
            if (!(fUseSLM || fUseAttrib)) {
                fprintf( stderr, " - write protected, unable to apply changes\n", p );
                return;
            }

            if (fRepeatMunge) {
                fprintf( stderr, " - %s failed, %s still write-protected\n",
                         fUseSLM ? "OUT" : "ATTRIB", p );
                printf( "%s(1) : UNABLE TO RUN %s command.\n", p, fUseSLM ? "OUT" : "ATTRIB" );
                fflush( stdout );
                return;
            }

            s = p + strlen( p );
            while (s > p) {
                if (*--s == '\\') {
                    *s++ = '\0';
                    break;
                }
            }

            if (s != p) {
                CurrentDirectory = PushCurrentDirectory( p );
            } else {
                CurrentDirectory = NULL;
            }

            if (fUseAttrib) {
                fprintf( stderr, " - ATTRIB -r" );
                if (SetFileAttributes( s,
                                       dwFileAttributes & ~(FILE_ATTRIBUTE_READONLY |
                                                            FILE_ATTRIBUTE_HIDDEN |
                                                            FILE_ATTRIBUTE_SYSTEM
                                                           )
                                     )
                   ) {
                } else {
                    if (CurrentDirectory) {
                        s[-1] = '\\';
                    }

                    fprintf( stderr, " - failed (rc == %d), %s still write-protected\n",
                             GetLastError(), p );
                    printf( "%s(1) : UNABLE TO MAKE WRITABLE\n", p );
                    fflush( stdout );
                    return;
                }
            } else {
                sprintf( CommandLine, "out %s%s", fForceSLM ? "-z " : "", s );
                fprintf( stderr, " - check out" );
                fflush( stdout );
                fflush( stderr );
                rc = system( CommandLine );

                if (rc == -1) {
                    if (CurrentDirectory) {
                        s[-1] = '\\';
                    }

                    fprintf( stderr, " - OUT failed (rc == %d), %s still write-protected\n", errno, p );
                    printf( "%s(1) : UNABLE TO CHECK OUT\n", p );
                    fflush( stdout );
                    return;
                }

            }

            GetCurrentDirectory( sizeof( CommandLine ), CommandLine );
            if (CurrentDirectory) {
                PopCurrentDirectory( CurrentDirectory );
                s[-1] = '\\';
            }

            if (fUseSLM && UndoScriptFile != NULL) {
                if (!(UndoCurDirCount++ % 8)) {
                    if (UndoCurDirCount == 1) {
                        fprintf( UndoScriptFile, "\ncd %s", CommandLine );
                    }

                    fprintf( UndoScriptFile, "\nin -vi" );
                }

                fprintf( UndoScriptFile, " %s", s );
                fflush( UndoScriptFile );
            }

            fRepeatMunge = TRUE;
            goto RepeatMunge;
        } else
            if (!fQuery && _access( p, 2 ) != -1 && fUseSLM && !fRepeatMunge) {
            if (!fSummary) {
                printf( "%s(1) : FILE ALREADY CHECKED OUT\n", p );
                fflush( stdout );
            }
        }

        RememberMunge( p, count );
        if (fQuery) {
            fprintf( stderr, " [%d potential changes]\n", count );
        } else {
            if ( (fh = _creat( newName, S_IWRITE | S_IREAD )) == -1 )
                fprintf( stderr, " - unable to create new version (%s)\n",
                         newName );
            else
                if (mywrite( fh, OutputFileBuf, newSize ) != newSize) {
                fprintf( stderr, " - error while writing\n" );
                _close( fh );
                _unlink( newName );
            } else {
                _close( fh );
                if (fTrustMe) {
                    _unlink( p );
                } else {
                    if (_access( bakName, 0 ) == 0) {
                        _unlink( bakName );
                    }

                    if (rename( p, bakName )) {
                        fprintf( stderr, "MUNGE: rename %s to %s failed\n",
                                 p, bakName );
                        return;
                    }
                }

                if (rename( newName, p )) {
                    fprintf( stderr, "MUNGE: rename %s to %s failed\n",
                             newName, p );
                } else {
                    if (fRepeatMunge && fUseAttrib) {
                        SetFileAttributes( p, dwFileAttributes );
                    } else {
                        fprintf( stderr, "\n" );
                    }
                    RememberMunge( p, count );
                }
            }
        }
    }
}


void
DoFiles(
       char *p,
       struct findType *b,
       void *Args
       )
{
    int SaveCurDirCount;
    char *s;
    unsigned long i;
    int FileProcessed;

    if (strcmp ((const char *)b->fbuf.cFileName, ".") &&
        strcmp ((const char *)b->fbuf.cFileName, "..") &&
        strcmp ((const char *)b->fbuf.cFileName, "slm.dif")
       ) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            switch (p[strlen(p)-1]) {
                case '/':
                case '\\':  strcat (p, "*.*");  break;
                default:    strcat (p, "\\*.*");
            }

            if (fRecurse) {
                fprintf( stderr, "Scanning %s\n", p );
                SaveCurDirCount = UndoCurDirCount;
                UndoCurDirCount = 0;
                forfile( p,
                         FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                         DoFiles,
                         NULL
                       );
                if (UndoScriptFile != NULL) {
                    if (UndoCurDirCount != 0) {
                        fprintf( UndoScriptFile, "\n" );
                        fflush( UndoScriptFile );
                        UndoCurDirCount = 0;
                    } else {
                        UndoCurDirCount = SaveCurDirCount;
                    }
                }
            }
        } else {
            s = _strlwr( (char *)b->fbuf.cFileName );
            while (*s != '.') {
                if (*s == '\0') {
                    break;
                } else {
                    s++;
                }
            }

            FileProcessed = FALSE;
            if (*s) {
                if (!strcmp( s, "mge" ) || !strcmp( s, "bak" )) {
                    FileProcessed = TRUE;
                } else {
                    for (i=0; i<NumberOfFileExtensions; i++) {
                        if (!strcmp( FileExtensions[ i ], s+1 )) {
                            FileProcessed = TRUE;
                            DoFile( p );
                            break;
                        }
                    }
                }

                if (!FileProcessed) {
                    *s = '\0';
                    for (i=0; i<NumberOfFileNames; i++) {
                        if (!strcmp( FileNames[ i ], (const char *)b->fbuf.cFileName )) {
                            FileProcessed = TRUE;
                            DoFile( p );
                            break;
                        }
                    }
                    *s = '.';
                }
            } else {
                for (i=0; i<NumberOfFileNames; i++) {
                    if (!strcmp( FileNames[ i ], (const char *)b->fbuf.cFileName )) {
                        FileProcessed = TRUE;
                        DoFile( p );
                        break;
                    }
                }
            }

            if (!FileProcessed) {
                for (i=0; i<NumberOfFileNameAndExts; i++) {
                    if (!strcmp( FileNameAndExts[ i ], (const char *)b->fbuf.cFileName )) {
                        FileProcessed = TRUE;
                        DoFile( p );
                        break;
                    }
                }
            }
        }
    }

    Args;
}

void
Usage( char *MsgFmt, int MsgArg )
{
    fputs("usage: munge scriptFile [-q [-e] [-o]] [-v] [-i] [-k] [-r] [-c [-m] [-z] [-@]]\n"
          "                        [-n] [-l | -L] [-a | -s [-f]] [-u undoFileName]\n"
          "                        filesToMunge...\n"
          "Where...\n"
          "    -q\tQuery only - don't actually make changes.\n"
          "    -e\tQuery only - display entire line for each match\n"
          "    -o\tQuery only - just display filename once on first match\n"
          "    -v\tVerbose - show files being scanned\n"
          "    -i\tJust output summary of files changed at end\n"
          "    -k\tCase - Case sensitive scriptFile\n"
          "    -r\tRecurse.\n"
          "    -c\tIf no munge of file, then check for cleanlyness\n"
          "    -m\tCollapse multiple carriage returns into one\n"
          "    -z\tCtrl-Z will truncate file\n"
          "    -@\tRemove null characters\n"
          "    -n\tNeuter - Surround all strings with TEXT()\n"
          "    -l\tLiterals - process any quoted text (includes comments too)\n"
          "    -L\tLiterals - process any quoted text (excludes comments)\n"
          "    -s\tUse OUT command command for files that are readonly\n"
          "    -a\tUse ATTRIB -r command for files that are readonly\n"
          "    -f\tUse -z flag for SLM OUT command\n"
          "    -t\tTrust me and dont create .bak files\n"
          "    -u\tGenerate an undo script file for any SLM OUT commands invoked.\n"
          "    -?\tGets you this message\n\n"
          "and scriptFile lines take any of the following forms:\n\n"
          "    oldName newName\n"
          "    \"oldString\" \"newString\"\n"
          "    -F .Ext  Name.  Name.Ext\n\n"
          "Where...\n"
          "    oldName and newName following C Identifier rules\n"
          "    oldString and newString are arbitrary text strings\n"
          "    -F limits the munge to files that match:\n"
          "        a particular extension (.Ext)\n"
          "        a particular name (Name.)\n"
          "        a particular name and extension (Name.Ext)\n"
          "    If no -F line is seen in the scriptFile, then\n"
          "    the following is the default:\n"
          "    -F .asm .bat .c .cli .cpp .cxx .def .dlg .h .htm .hpj .hxx .idl .inc\n"
          "    -F .inf .lic .mak .mc .odl .rc .rcv .reg .s .src .srv .tk .w .x\n"
          "    -F makefil0 makefile sources\n",
          stderr);

    if (MsgFmt != NULL) {
        fprintf( stderr, "\n" );
        fprintf( stderr, MsgFmt, MsgArg );
        fprintf( stderr, "\n" );
    }
    exit( 1 );
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    int i;
    char *s, pathBuf[ 64 ];
    int FileArgsSeen = 0;

    ConvertAppToOem( argc, argv );
    if (argc < 3) {
        Usage( NULL, 0 );
    }

    if ( !InitTokenMappingTable()) {
        fprintf( stderr, "MUNGE: Unable to create symbol table\n" );
        exit( 1 );
    }

    OutputFileBuf = (char *)VirtualAlloc( NULL,
                                          MAXFILESIZE,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    if ( OutputFileBuf == NULL) {
        fprintf( stderr, "not enough memory\n" );
        exit( 1 );
    }

    fClean = FALSE;
    fRemoveDuplicateCR = FALSE;
    fRemoveImbeddedNulls = FALSE;
    fTruncateWithCtrlZ = FALSE;
    fQuery = FALSE;
    fFileOnly = FALSE;
    fRecurse = FALSE;
    fUseAttrib = FALSE;
    fUseSLM = FALSE;
    fForceSLM = FALSE;
    fTrustMe = FALSE;
    fVerbose = FALSE;
    UndoScriptFileName = NULL;
    UndoScriptFile = NULL;
    fSummary = FALSE;
    fInsideQuotes = FALSE;
    fInsideComments = FALSE;
    fNeuter = FALSE;
    fEntireLine = FALSE;

    for (i=2; i<argc; i++) {
        s = argv[ i ];
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch ( tolower( *s ) ) {
                    case 'm':   fRemoveDuplicateCR = TRUE; break;
                    case '@':   fRemoveImbeddedNulls = TRUE; break;
                    case 'z':   fTruncateWithCtrlZ = TRUE; break;
                    case 'c':   fClean = TRUE;  break;
                    case 'q':   fQuery = TRUE;  break;
                    case 'o':   fFileOnly = TRUE;  break;
                    case 'r':   fRecurse = TRUE;  break;
                    case 'a':   fUseAttrib = TRUE;  break;
                    case 's':   fUseSLM = TRUE;  break;
                    case 'f':   fForceSLM = TRUE;  break;
                    case 't':   fTrustMe = TRUE;  break;
                    case 'v':   fVerbose = TRUE;  break;
                    case 'i':   fSummary = TRUE;  break;
                    case 'l':   if (*s != 'L') fInsideComments = TRUE;
                        fInsideQuotes = TRUE; break;
                    case 'n':   fNeuter = TRUE; fInsideQuotes = FALSE; break;
                    case 'k':   fCaseSensitive = TRUE; break;
                    case 'e':   fEntireLine = TRUE;  break;
                    case 'u':   UndoScriptFileName = argv[ ++i ];
                        break;

                    default:    Usage( "invalid switch - '%c'", *s );
                }
            }
        } else {
            if ((fFileOnly | fEntireLine) && !fQuery) {
                Usage( "-e or -o invalid without -q", 0 );
            }

            if (fQuery && (fClean ||
                           fRemoveDuplicateCR ||
                           fRemoveImbeddedNulls ||
                           fTruncateWithCtrlZ ||
                           fUseSLM ||
                           fForceSLM ||
                           fTrustMe ||
                           UndoScriptFile ||
                           fNeuter
                          )
               ) {
                Usage( "-q valid only with -e or -o", 0 );
            }

            if (fClean &&
                !fRemoveDuplicateCR &&
                !fRemoveImbeddedNulls &&
                !fTruncateWithCtrlZ
               ) {
                Usage( "-c requires at least one of -m, -z or -@", 0 );
            }

            if (UndoScriptFileName != NULL) {
                if (!fUseSLM) {
                    Usage ("-u invalid with -s", 0 );
                } else {
                    UndoScriptFile = fopen( UndoScriptFileName, "w" );
                    if (UndoScriptFile == NULL) {
                        fprintf( stderr, "Unable to open %s\n", UndoScriptFileName );
                        exit( 1 );
                    }
                }
            }

            if (!FileArgsSeen++) {
                if (!ReadScriptFile( argv[ 1 ] )) {
                    fprintf( stderr, "Invalid script file - %s\n", argv[ 1 ] );
                    exit( 1 );
                }

                if (fVerbose) {
                    DisplayFilePatterns();
                }
            }

            if (GetFileAttributes( s ) & FILE_ATTRIBUTE_DIRECTORY) {
                s = strcpy( pathBuf, s );
                switch (s[strlen(s)-1]) {
                    case '/':
                    case '\\':  strcat (s, "*.*");  break;
                    default:    strcat (s, "\\*.*");
                }
                fprintf( stderr, "Scanning %s\n", s );
                UndoCurDirCount = 0;
                forfile( s,
                         FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                         DoFiles,
                         NULL
                       );
            } else {
                UndoCurDirCount = 0;
                DoFile( s );
            }
        }
    }

    if (FileArgsSeen == 0) {
        if (!ReadScriptFile( argv[ 1 ] )) {
            fprintf( stderr, "Invalid script file - %s\n", argv[ 1 ] );
            exit( 1 );
        }

        if (fVerbose) {
            DisplayFilePatterns();
        }

        s = "*.*";
        fprintf( stderr, "Scanning %s\n", s );
        UndoCurDirCount = 0;
        forfile( s,
                 FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN ,
                 DoFiles,
                 NULL
               );
    }

    if (UndoScriptFile != NULL) {
        if (UndoCurDirCount != 0) {
            fprintf( UndoScriptFile, "\n" );
        }

        fclose( UndoScriptFile );
    }

    DumpMungedList();
    return( 0 );
}




void
DisplayFilePatterns( void )
{
    unsigned long i;

    if (NumberOfFileExtensions) {
        fprintf( stderr, "Munge will look at files with the following extensions:\n   " );
        for (i=0; i<NumberOfFileExtensions; i++) {
            fprintf( stderr, " %s", FileExtensions[ i ] );
        }
        fprintf( stderr, "\n" );
    }

    if (NumberOfFileNames) {
        fprintf( stderr, "Munge will look at files with the following names:\n   " );
        for (i=0; i<NumberOfFileNames; i++) {
            fprintf( stderr, " %s", FileNames[ i ] );
        }
        fprintf( stderr, "\n" );
    }

    if (NumberOfFileNameAndExts) {
        fprintf( stderr, "Munge will look at files with the following name and extensions:\n   " );
        for (i=0; i<NumberOfFileNameAndExts; i++) {
            fprintf( stderr, " %s", FileNameAndExts[ i ] );
        }
        fprintf( stderr, "\n" );
    }
}


char *
PushCurrentDirectory(
                    char *NewCurrentDirectory
                    )
{
    char *OldCurrentDirectory;

    if (OldCurrentDirectory = malloc( MAX_PATH )) {
        GetCurrentDirectory( MAX_PATH, OldCurrentDirectory );
        SetCurrentDirectory( NewCurrentDirectory );
    } else {
        fprintf( stderr,
                 "MUNGE: (Fatal Error) PushCurrentDirectory out of memory\n"
               );
        exit( 16 );
    }

    return( OldCurrentDirectory );
}


void
PopCurrentDirectory(
                   char *OldCurrentDirectory
                   )
{
    if (OldCurrentDirectory) {
        SetCurrentDirectory( OldCurrentDirectory );
        free( OldCurrentDirectory );
    }
}


PVOID SymbolTableHandle;


BOOL
InitTokenMappingTable( void )
{
    NTSTATUS Status;

    Status = CreateSymbolTable( 257, 0x20000, &SymbolTableHandle );
    if (NT_SUCCESS( Status )) {
        return TRUE;
    } else {
        return FALSE;
    }
}


BOOL
SaveTokenMapping(
                char *String,
                char *Value
                )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING SymbolName;
    ULONG_PTR SymbolValue;

    RtlInitString( &AnsiString, String );
    Status = RtlAnsiStringToUnicodeString( &SymbolName, &AnsiString, TRUE );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    SymbolValue = (ULONG_PTR)Value;
    Status = AddSymbolToSymbolTable( SymbolTableHandle,
                                     &SymbolName,
                                     &SymbolValue
                                   );
    RtlFreeUnicodeString( &SymbolName );
    if (NT_SUCCESS( Status )) {
        return TRUE;
    } else {
        return FALSE;
    }
}


char *
FindTokenMapping(
                char *String
                )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING SymbolName;
    ULONG_PTR SymbolValue;

    RtlInitString( &AnsiString, String );
    Status = RtlAnsiStringToUnicodeString( &SymbolName, &AnsiString, TRUE );
    if (!NT_SUCCESS( Status )) {
        return NULL;
    }

    Status = LookupSymbolInSymbolTable( SymbolTableHandle,
                                        &SymbolName,
                                        &SymbolValue
                                      );
    RtlFreeUnicodeString( &SymbolName );
    if (NT_SUCCESS( Status )) {
        return (char *)SymbolValue;
    } else {
        return NULL;
    }
}


typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY *HashLink;
    ULONG_PTR Value;
    UNICODE_STRING Name;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;

typedef struct _SYMBOL_TABLE {
    ULONG NumberOfBuckets;
    PSYMBOL_TABLE_ENTRY Buckets[1];
} SYMBOL_TABLE, *PSYMBOL_TABLE;

NTSTATUS
CreateSymbolTable(
                 IN ULONG NumberOfBuckets,
                 IN ULONG MaxSymbolTableSize,
                 OUT PVOID *SymbolTableHandle
                 )
{
    NTSTATUS Status;
    PSYMBOL_TABLE p;
    ULONG Size;

    RtlLockHeap( GetProcessHeap() );

    if (*SymbolTableHandle == NULL) {
        Size = sizeof( SYMBOL_TABLE ) +
               (sizeof( SYMBOL_TABLE_ENTRY ) * (NumberOfBuckets-1));

        p = (PSYMBOL_TABLE)RtlAllocateHeap( GetProcessHeap(), 0, Size );
        if (p == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            RtlZeroMemory( p, Size );
            p->NumberOfBuckets = NumberOfBuckets;
            *SymbolTableHandle = p;
        }
    } else {
        Status = STATUS_SUCCESS;
    }

    RtlUnlockHeap( GetProcessHeap() );

    return( Status );
}


PSYMBOL_TABLE_ENTRY
BasepHashStringToSymbol(
                       IN PSYMBOL_TABLE p,
                       IN PUNICODE_STRING Name,
                       OUT PSYMBOL_TABLE_ENTRY **PreviousSymbol
                       )
{
    ULONG n, Hash;
    WCHAR c;
    PWCH s;
    PSYMBOL_TABLE_ENTRY *pps, ps;

    n = Name->Length / sizeof( c );
    s = Name->Buffer;
    if ( fCaseSensitive ) {
        Hash = 0;
        while (n--) {
            c = *s++;
            Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    } else {
        Hash = 0;
        while (n--) {
            c = RtlUpcaseUnicodeChar( *s++ );
            Hash = Hash + (c << 1) + (c >> 1) + c;
        }
    }

    pps = &p->Buckets[ Hash % p->NumberOfBuckets ];
    while (ps = *pps) {
        if (RtlEqualUnicodeString( &ps->Name, Name, (BOOLEAN)!fCaseSensitive )) {
            break;
        } else {
            pps = &ps->HashLink;
        }
    }

    *PreviousSymbol = pps;
    return( ps );
}


NTSTATUS
AddSymbolToSymbolTable(
                      IN PVOID SymbolTableHandle,
                      IN PUNICODE_STRING SymbolName,
                      IN ULONG_PTR * SymbolValue OPTIONAL
                      )
{
    NTSTATUS Status;
    PSYMBOL_TABLE p = (PSYMBOL_TABLE)SymbolTableHandle;
    PSYMBOL_TABLE_ENTRY ps, *pps;
    ULONG_PTR Value;

    if (ARGUMENT_PRESENT( SymbolValue )) {
        Value = *SymbolValue;
    } else {
        Value = 0;
    }

    Status = STATUS_SUCCESS;

    RtlLockHeap( GetProcessHeap() );
    try {
        ps = BasepHashStringToSymbol( p, SymbolName, &pps );
        if (ps == NULL) {
            ps = RtlAllocateHeap( GetProcessHeap(), 0, (sizeof( *ps ) + SymbolName->Length) );
            if (ps != NULL) {
                ps->HashLink = NULL;
                ps->Value = Value;
                ps->Name.Buffer = (PWSTR)(ps + 1);
                ps->Name.Length = SymbolName->Length;
                ps->Name.MaximumLength = (USHORT)(SymbolName->Length + sizeof( UNICODE_NULL ));
                RtlMoveMemory( ps->Name.Buffer, SymbolName->Buffer, SymbolName->Length );
                *pps = ps;
            } else {
                Status = STATUS_NO_MEMORY;
            }
        }

        else {
            Status = STATUS_OBJECT_NAME_EXISTS;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    RtlUnlockHeap( GetProcessHeap() );

    return( Status );
}

NTSTATUS
LookupSymbolInSymbolTable(
                         IN PVOID SymbolTableHandle,
                         IN PUNICODE_STRING SymbolName,
                         OUT ULONG_PTR *SymbolValue OPTIONAL
                         )
{
    NTSTATUS Status;
    PSYMBOL_TABLE p = (PSYMBOL_TABLE)SymbolTableHandle;
    PSYMBOL_TABLE_ENTRY ps, *pps;
    ULONG_PTR Value;

    RtlLockHeap( GetProcessHeap() );
    try {
        ps = BasepHashStringToSymbol( p, SymbolName, &pps );
        if (ps == NULL) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            Value = 0;
        } else {
            Status = STATUS_SUCCESS;
            Value = ps->Value;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
    RtlUnlockHeap( GetProcessHeap() );

    if (NT_SUCCESS( Status )) {
        if (ARGUMENT_PRESENT( SymbolValue )) {
            *SymbolValue = Value;
        }
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\inc\regclient.h ===
// Purpose: This is a DLL which is the INFO client End of RegSrv
// Author : RajNath
// Exported Funcs:
//
//
// Will connect to the corresponding RegSrv. Returns a "HANDLE"
// to be used only with Func. exported by this DLL.
//
// HANDLE    AddRegSrv(IN char *Server,IN char *PipeName,OUT DWORD &Count);
//
//
// Will Wait for Data until available. Will return FALSE incase of
// failure - this means its been disconnected from the corresponding RegSrv.
// Must not call ReadRegSrv with this - attempt reconnect again by calling
// AddRegSrv().
//
//
// BOOL    ReadRegSrv(IN OUT PVOID Buff,IN DWORD Len,OUT HANDLE *From);

#define MAX_REGSRV 63

HANDLE
AddRegSrv(char *Server, char *Name,DWORD *Count);

BOOL
ReadRegSrv(IN OUT PVOID Buff,IN DWORD Len,OUT HANDLE *From);


typedef struct
{
    SYSTEMTIME StartTime;
    TCHAR      MachineName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD      Status;
    DWORD      Ram;
    DWORD      BuildNo;
    TCHAR      EmailName[MAX_EMAILNAME_LENGTH+1]     ;
    TCHAR      Location[MAX_LOCATION_LENGTH+1]       ;
    TCHAR      DebugMachine[MAX_COMPUTERNAME_LENGTH+1]   ;
    DWORD      Cpu;
    TCHAR      Run_Type[128];
    TCHAR      CairoBld[16];   // CAIRO SPECIFIC
    WORD       TestIds[64];

}REGINFO, *PREGINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munge\munge.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    munge.h

Abstract:

    This is the main include file for the source file munger.

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\inc\locale.h ===
#define ORIGLC  "OriginalLCID"
#define LANGKEY "System\\CurrentControlSet\\Control\\Nls\\Language"

#define IMMKEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\IMM"
#define IMMLOAD "LoadIMM"
#define IMMCHANGE "IMMChanged"

typedef struct _LC_INFO {
    TCHAR szID[5];
    TCHAR szAbbr[4];
    TCHAR szName[50];
} LC_INFO;

//
// It would be better not to include variables here.
// Anywa add "static" to avoid conflict in multiple instance includes.
// Yuhong Li, Feb 26, 1998.
//
//
static LC_INFO Locale[] = {
    TEXT("0411"), TEXT("jpn"), TEXT("Japanese"),
    TEXT("0412"), TEXT("kor"), TEXT("Korean"),
    TEXT("0404"), TEXT("cht"), TEXT("Chinese (Traditional)"),
    TEXT("0804"), TEXT("chs"), TEXT("Chinese (Simplified)"),
    TEXT("0C04"), TEXT("chp"), TEXT("Chinese (HongKong)"),
    TEXT("1004"), TEXT("chg"), TEXT("Chinese (Singapore)"), // not offical
    TEXT("0409"), TEXT("enu"), TEXT("English (US)"),
    TEXT("0407"), TEXT("deu"), TEXT("German (Standard)"),
    TEXT("040C"), TEXT("fra"), TEXT("French (Standard)"),
    TEXT("040A"), TEXT("esp"), TEXT("Spanish (Traditional Sort)"),
    TEXT("0410"), TEXT("ita"), TEXT("Italian"),
    TEXT("0401"), TEXT("are"), TEXT("Arabic (Egypt)"),
    TEXT("3401"), TEXT("ark"), TEXT("Arabic (Kuwait)"),
    TEXT("0801"), TEXT("ari"), TEXT("Arabic (Iraq)"),
    TEXT("3001"), TEXT("arb"), TEXT("Arabic (Lebanon)"),
    TEXT("0C01"), TEXT("ara"), TEXT("Arabic (Saudi Arabia)"),
    TEXT("041E"), TEXT("tha"), TEXT("Thai"),
    TEXT("040D"), TEXT("heb"), TEXT("Hebrew"),
    TEXT("0439"), TEXT("hin"), TEXT("Indic (Hindi)"),
    TEXT("0449"), TEXT("tam"), TEXT("Indic (Tamil)"),
};
#define NUM_LOCALE              (sizeof(Locale)/sizeof(Locale[0]))
#define DEFAULT_ENGLISH_INDEX   6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\inc\debug.h ===
/*++

    Module Name:

    debug.h


    Abstract:



    Author:

    Sanjeev Katariya


    Environment:

    User mode


    Revision History:


    Serial #    Author      Date    Changes
    --------    ------      ----    -------
    1.          SanjeevK    10/28   Original



--*/


//
//  Debug defines
//
//  DEBUG MASK SUCCESS: 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
//                       1  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X
//  DEBUG MASK FAILURE: 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
//                       1  X  X  X  X  X  X  X  X  X  X  X  X  X  X  X

#define   DEBUG_F_INIT      0x8000UL
#define   DEBUG_F_CONNECT   0x8001UL
#define   DEBUG_F_ALL       0xFFFFUL
#define   DEBUG_S_INIT      0x80000000UL
#define   DEBUG_S_CONNECT   0x80010000UL
#define   DEBUG_S_ALL       0xFFFF0000UL
#define   DEBUG_ALL         0xFFFFFFFFUL


//
// Debug constants
//
#define  DEBUG_NEWPAGE    "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"

//
//  Debug Variables
//
#if DBG

extern const ULONG cul_DebugMask;


//
//  Debug Macros
//
#define DEBUG_MACRO_F_INIT      if ( cul_DebugMask & DEBUG_F_INIT )
#define DEBUG_MACRO_F_CONNECT   if ( cul_DebugMask & DEBUG_F_CONNECT )
#define DEBUG_MACRO_F_ALL       if ( cul_DebugMask & DEBUG_F_ALL )
#define DEBUG_MACRO_S_INIT      if ( cul_DebugMask & DEBUG_S_INIT )
#define DEBUG_MACRO_S_CONNECT   if ( cul_DebugMask & DEBUG_S_CONNECT )
#define DEBUG_MACRO_S_ALL       if ( cul_DebugMask & DEBUG_S_ALL )
#define DEBUG_MACRO_ALL         if ( cul_DebugMask & DEBUG_ALL )
#define DbgOut(a,b,c)           DbgPrint( a, b, c )

#else

#define DEBUG_MACRO_F_INIT      if ( FALSE )
#define DEBUG_MACRO_F_CONNECT   if ( FALSE )
#define DEBUG_MACRO_F_ALL       if ( FALSE )
#define DEBUG_MACRO_S_INIT      if ( FALSE )
#define DEBUG_MACRO_S_CONNECT   if ( FALSE )
#define DEBUG_MACRO_S_ALL       if ( FALSE )
#define DEBUG_MACRO_ALL         if ( FALSE )
#define DbgOut(a,b)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\comrun.c ===
/****************************************************************************

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    <None>
    common functions to be shared by modules.

File Name:

    comsun.c

Abstract:

    This file contains some common functions used in instlpk.lib and
    instlang.exe. 

Public Functions:

    LaunchRegionalSettings -- launch our LangPack installation dll.

Revision History:

    20-Jan-98       -- Yuhong Li [YuhongLi]
        make initial version.

****************************************************************************/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>

#define PRIVATE
#define PUBLIC

#define MAX_BUFFER_SIZE     256
#define INTL_CPL_NAME       TEXT("intl.cpl")
#define PROGRAM_TITLE       TEXT("Install LangPack")


////////////////////////////////////////////////////////////////////////////
//
//  GetSysErrorMsg
//
//  get the error message of GetLastError().
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE void
GetSysErrorMsg(LPTSTR lpMsg)
{
    LPVOID  lpMsgBuf;

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  GetLastError(),
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default lang.
                  (LPTSTR)&lpMsgBuf,
                  0,
                  NULL);
    sprintf(lpMsg, TEXT("WARNING:  %s"), (LPTSTR)lpMsgBuf);
    LocalFree(lpMsgBuf);
}

////////////////////////////////////////////////////////////////////////////
//
//  RunProgram
//
//  launches a program.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE BOOL
RunProgram(LPTSTR lpCommandLine)
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL                fSuccess;
    DWORD               dwRetValue;

#if 0
This was old stuff when we changed intl.cpl and made it to return something
for us to know if it was successed or stopped by user.
Now we don't change any in intl.cpl, just launch it.  So we don't and couldn't
use it any more.

It would be safe to have someway of communication between these two
processes, because GetExitCodeProcess doesn't give much information.

    //
    // initiate the program return value with non-zeror, because
    // zero means the program will be run successfully without any error.
    //
    if (SetProgramReturnValue(1) == FALSE) {
        return FALSE;
    }
#endif

    GetStartupInfo(&StartupInfo);

    fSuccess = CreateProcess(NULL,
                     lpCommandLine,
                     NULL,
                     NULL,
                     FALSE,
                     0,
                     NULL,
                     NULL,
                     &StartupInfo,
                     &ProcessInfo);

    //
    // Don't use (fSuccess == TRUE), because VC++ 5.0 reference confuses me:
    //
    //      Return Values
    //
    //      If the function succeeds, the return value is nonzero. 
    //      If the function fails, the return value is zero. 
    //
    // but the function is declared as *BOOL*.
    //

    if (fSuccess) {
        HANDLE hProcess = ProcessInfo.hProcess;
        DWORD  dwExitCode;

        // close the thread handle as soon as it is no longer needed.
        CloseHandle(ProcessInfo.hThread);

        if (WaitForSingleObject(hProcess, INFINITE) != WAIT_FAILED) {
            // The process terminated.
            GetExitCodeProcess(hProcess, &dwExitCode);
        }

        // close the process handle as soon as it is no longer needed.
        CloseHandle(hProcess);
    } else {
        MessageBox(NULL,
                TEXT("The Regional Settings failed to be launched.\n")
                TEXT("The LangPack is not installed!"),
                PROGRAM_TITLE,
                MB_ICONINFORMATION|MB_OK);
        return FALSE;
    }
 
#if 0
    //
    // Until here we can just return TRUE for successful running program.
    //      return TRUE;
    //
    // However to be strict, we are trying to get the return value of the
    // program we have run. 
    //
    // GetProgramReturnValue giving 0 means TRUE (OK), otherwise means
    // the error code.
    //
    if (GetProgramReturnValue(&dwRetValue) == FALSE) {
        return FALSE;
    }
    return (dwRetValue == 0)? TRUE: FALSE; 
#endif
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  LaunchRegionalSettings
//
//  launches our Regional Settings intldll.cpl.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
BOOL
LaunchRegionalSettings(LPTSTR pCmdOption)
{
    TCHAR       szCmdLine[MAX_BUFFER_SIZE * 2];
    TCHAR       szName[MAX_BUFFER_SIZE];
    TCHAR       szBuf[MAX_BUFFER_SIZE];

    strcpy(szName, INTL_CPL_NAME);

    //
    // start Regional Options.
    //
    if (*pCmdOption != TEXT('\0')) {
        sprintf(szCmdLine,
            TEXT("rundll32 shell32.dll,Control_RunDLL %s,@0,%s"),
            szName,
            pCmdOption);
    } else {
        sprintf(szCmdLine,
            TEXT("rundll32 shell32.dll,Control_RunDLL %s"),
            szName);
    }

    return RunProgram(szCmdLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\inc\struct.h ===
/*++

    Module Name:

    struct.h


    Abstract:

    Contains all the valid definition constants, structures used
    by client.c and testdrvr.c


    Author:

    Sanjeev Katariya


    Environment:

    User mode


    Revision History:


    Serial #    Author      Date        Changes
    --------    ------      ----        -------
    1.          SanjeevK    10/28/92    Original
    2.          RickTu      1/25/93     Changed for new system watchdog mess.
    3.          RajNath     2/??/93


--*/

//
// DEFINES: General
//
//#define     SRVTOCLIENT_MSLOT      "\\\\.\\mailslot\\SRVTOCLNT"
#define       CONNECT_MSLOT          "\\\\*\\mailslot\\CONNECT"
#define       SRVEND_PIPE_BASE       "PIPE\\NODAL"
#define       SRVEND_PIPE_NAME       "STRESS7"

#define     MAX_RETRY_COUNT        3
#define     MAX_EMAILNAME_LENGTH   8
#define     MAX_LOCATION_LENGTH    10
#define     MAX_COMMENT_LENGTH     15
#define     MAX_GENERAL_LENGTH     80
#define     MAX_TESTS              256
#define     MAX_TEST_IDS           64

#define     SEND_PERIOD            10UL*60UL*1000UL //Interval 10 minutes at which Alive Message Sent

//#define     NUM_MACHINE_TYPES      2
//#define     MACHINE_TYPE_X86       (TCHAR)0x1
//#define     MACHINE_TYPE_MIPS      (TCHAR)0x2

#define     STRESS_ENV_VAR         "STRESSROOT"

//#define	NUM_DEFAULT_SRVADMINS  4
//#define	NUM_POPUP_SERVERS      4

//#define   NUM_DEFAULT_SRVADMINS (sizeof(ppc_SrvAdmins)/sizeof(ppc_SrvAdmins[0]))
//#define   NUM_POPUP_SERVERS	(sizeof(ppc_PopUpSrvrs)/sizeof(ppc_PopUpSrvrs[0]))


//
// DEFINES: Message Identifiers
//
#define     MSG_REGISTER_INFORMATION        (DWORD)0x1
#define     MSG_REGISTER_ADD_INFORMATION    (DWORD)0x2
#define     MSG_CLIENT_ALIVE                (DWORD)0x3
#define     MSG_CLIENT_SHUTDOWN             (DWORD)0x4
#define     MSG_CLIENT_WATCHDOG             (DWORD)0x5
#define     MSG_ERROR_POPUP                 (DWORD)0x6

//
// DEFINES: Popups (upper WORD bit fields)
//

#define VDM_WINDOWS_POPUP   0x10000000
#define VDM_MSDOS_POPUP     0x20000000
#define APP_POPUP           0x40000000


//
// DEFINES: Special error codes
//

#define     ERROR_SHARENAME_RETRIEVAL       (DWORD)2000


//
// DEFINES: Connection States
//
//  This is the state transition diagram for the client
//
//       Reg/Fail                    KeepAlive/Success
//      -----------                    ----
//     | Count:3   |                  |    |
//     v           |                  |    v
//   ------      ------  Reg/Success  ------
//  | DISC |--->| CONN |------------>| REG  |
//   ------      ------               ------
//     ^                                |
//     |                                |
//      --------------------------------
//          KeepAlive/Fail Count:3
//

#define   STATE_DISCONNECTED                (DWORD)0x0
#define   STATE_CONNECTED                   (DWORD)0x1
#define   STATE_REGISTERED                  (DWORD)0x2

//
// TYPEDEFS: SERVER, CONNECTION_INFORMATION, REG_INFORMATION
//           REG_ADD_INFORMATION, CLIENT_ALIVE, CLIENT_SHUTDOWN,
//           DATA, INFORMATION, THREAD_KEEPALIVE_PARMS
//


//typedef TCHAR   SERVER, *PSERVER;


//typedef struct  _STRESS_SHARE {
//
//    TCHAR       c_MachineType;
//    TCHAR       pc_SrvShareName[NNLEN+MAX_COMPUTERNAME_LENGTH+6];
//
//} STRESS_SHARE, *PSTRESS_SHARE;


//typedef struct _CONNECTION_INFORMATION {
//
//  TCHAR         pc_ComputerName[MAX_COMPUTERNAME_LENGTH+1]  ;
//  TCHAR         pc_ServerName[MAX_COMPUTERNAME_LENGTH+1]    ;
//  STRESS_SHARE  pstruct_SrvShareName[NUM_MACHINE_TYPES]     ;
//
//} CONNECTION_INFORMATION, *PCONNECTION_INFORMATION;

typedef struct _TEST_FLAGS {
    DWORD ul_TestFl[2];
} TEST_FLAGS;

typedef struct _INFO_FLAGS {
    TCHAR   FreeChk;
    TCHAR   UniMultiProc;
    WORD    CsdVersion;
    WORD    RCMajor;
    WORD    RCMinor;
} INFO_FLAGS;


typedef union _STRESS_FLAGS {
    TEST_FLAGS TF;
    INFO_FLAGS IF;
} STRESS_FLAGS;

typedef struct _OLDCAIROBUILD {
    TCHAR   CairoBld[16];
} OLDCAIROBUILD;

typedef struct _FILESYSTEMINFO {
    TCHAR   FileSystemName[12];
    DWORD   FileSystemFlags;
} FILESYSTEMINFO;

typedef union _FILESYSTEMUNION {
    OLDCAIROBUILD  oldcairo;
    FILESYSTEMINFO fsi;
} FILESYSTEMUNION;

typedef struct _REG_INFORMATION {

    DWORD   ul_PhysMem;
    DWORD   ul_Version;
    DWORD   ul_FreeDisk;
    STRESS_FLAGS Fl;
    //DWORD   ul_TestFl[2]; // out of date
    DWORD   ul_BuildVersionNumber;
    TCHAR   pc_EmailName[MAX_EMAILNAME_LENGTH+1]     ;
    TCHAR   pc_MachineName[MAX_COMPUTERNAME_LENGTH+1];
    TCHAR   pc_Location[MAX_LOCATION_LENGTH+1]       ;
    TCHAR   pc_Debugger[MAX_COMPUTERNAME_LENGTH+1]   ;
    TCHAR   Filler;
    SYSTEMTIME st_StartTime;
    union {
        DWORD   Cpu;
        struct {
            WORD CpuLevel;
            WORD CpuType;
        };
    };
    TCHAR   Run_Type[128];
    int     OtherBuild;
    FILESYSTEMUNION fsu;
    WORD    TestIds[MAX_TEST_IDS];

} REG_INFORMATION, *PREG_INFORMATION;

//
// Defines current registration packet "version" number.  Need
// to incremenent the low word by "1" every time a change is made
// to the REG_INFORMATION structure
//

#define CURRENT_REG_VERSION 0xFFFF0003



typedef struct _REG_ADD_INFORMATION {

    WORD   TestIds[MAX_TEST_IDS];

}   REG_ADD_INFORMATION, *PREG_ADD_INFORMATION;


typedef struct _CLIENT_ALIVE {

    DWORD   ul_ClientSendCount;
    DWORD   CpuUtil;
    DWORD   DiskUtil;
    DWORD   Interrupts;

} CLIENT_ALIVE, *PCLIENT_ALIVE;


typedef struct _CLIENT_SHUTDOWN {

    TCHAR   pc_SmartMessage;

} CLIENT_SHUTDOWN, *PCLIENT_SHUTDOWN;

typedef struct
{
    TCHAR Popup[1];
}ERROR_POPUP;


typedef union _DATA {

    REG_INFORMATION       RI ;
    REG_ADD_INFORMATION   RAI;
    CLIENT_ALIVE          CA ;
    CLIENT_SHUTDOWN       CS ;

} DATA, *PDATA;


typedef struct _INFORMATION {
    DWORD   Type;
    char    Data[1];

} INFORMATION, *PINFORMATION;

typedef struct _WATCHDOG {

    DWORD   CsrssCommitedPages;
    DWORD   PercentCpuUsage;
    DWORD   InterruptsPerSec;
    DWORD   ReadWritePerSec;

} WATCHDOG, *PWATCHDOG;

typedef struct _ERRORS {

    DWORD   ErrCode;
    CHAR    Server[100];

} ERRORS, *PERRORS;

#define MAX_ERROR_ENTRIES 20




//
// Structure for parameters passed to the client alive thread
//
typedef struct _THREAD_KEEPALIVE_PARMS {

    PHANDLE           ppv_Handle   ;
    DWORD             ul_DelayTimer;
    DWORD             ul_ConnectionState;
    REG_INFORMATION   struct_RegInf;
    TCHAR             pc_ServerName[MAX_COMPUTERNAME_LENGTH+1];

}  THREAD_KEEPALIVE_PARMS, *PTHREAD_KEEPALIVE_PARMS;






//
//  Exported functions: EstablishConnection(), SendInformation(),
//                      ReceiveInformation(), CloseConnection()
//

//DWORD
//EstablishConnection(
//    IN     PSERVER                  lpsz_ServerName OPTIONAL,
//    OUT    PHANDLE                  ppv_Handle,
//    OUT    PCONNECTION_INFORMATION  pstruct_ConnectionInformation
//    );


BOOL
SendInformation(
    DWORD MsgType,
    PVOID Msg,
    DWORD MsgSize
    );


//DWORD
//ReceiveInformation(
//    IN  HANDLE            pv_PipeHandle,
//    IN  OUT PINFORMATION  pstruct_Information
//    );


//
// MACROS
//
//#define CloseConnection( Handle )   CloseHandle( Handle ) ? ERROR_SUCCESS : GetLastError()

//
// SOME ADDITIONAL STUFF FOR NEWCLIENT.C
//


#define MAX_SERVERS  10
#define MAXPIPENAME  MAX_COMPUTERNAME_LENGTH+1+128


typedef struct {

    TCHAR	      RegSrvs[MAX_SERVERS][MAX_COMPUTERNAME_LENGTH+1];
    DWORD	      NumRegSrvs;

}  SERVERLIST;


//
//Incase the .INI File has missing section on this....
//
//static CHAR ppc_SrvAdmins[][MAX_COMPUTERNAME_LENGTH+1] = { "NTSTRESS", "LAPILE","DRAINO","RICKTUMIPS","RAJNATH" };
//static CHAR ppc_PopUpSrvrs[][MAX_COMPUTERNAME_LENGTH+1] = { "STRESS", "RICKTU", "A-LARSO", "RAJNATH" };
//static STRESS_SHARE pstruct_DefaultStressSrvrs[]    = { { MACHINE_TYPE_X86,  "\\\\PEANUT\\X86STRS" },
//                                                        { MACHINE_TYPE_MIPS, "\\\\PEANUT\\MIPSSTRS" } };


extern	BOOL  			     SendAdditionalInfo;
extern	REG_ADD_INFORMATION	 RAI;
extern	REG_INFORMATION		 RI;
extern  SERVERLIST           ServerList;
extern  int                  ActiveServer;

#define SAFECLOSEHANDLE(hX) {if (hX!=INVALID_HANDLE_VALUE) {CloseHandle(hX);hX=INVALID_HANDLE_VALUE;}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\comsub.c ===
/****************************************************************************

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    <None>
    common functions to be shared by other modules.

File Name:

    comsub.c

Abstract:

    This file contains some common functions used in instlpk.lib and
    intldll.dll.  Since instlpk.lib is compiled in ANSI and intldll.dll is
    compiled in Unicode, don't put any string-senstive stuff here!

Public Functions:

    SetProgramReturnValue  -- set program return value in Registry.
    GetProgramReturnValue  -- get program return value and delete it in
                              Registry.

Revision History:

    10-Feb-98       -- Yuhong Li [YuhongLi]
        make initial version.

****************************************************************************/

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>

static const TCHAR c_szRegionalSettings[] =
    TEXT("System\\CurrentControlSet\\Control\\Nls\\RegionalSettings");
static const TCHAR c_szProgramReturnValue[] =
    TEXT("ProgramReturnValue");

////////////////////////////////////////////////////////////////////////////
//
//  SetProgramReturnValue
//
//  borrows Registry values to set the program return value.
//
//  10-Feb-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
BOOL
SetProgramReturnValue(DWORD dwValue)
{
    HKEY    hKey;
    DWORD   dwDisp;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                     c_szRegionalSettings,
                     0L,
                     NULL,
                     REG_OPTION_VOLATILE,  // don't need system save it.
                     KEY_WRITE,
                     (LPSECURITY_ATTRIBUTES)NULL,
                     &hKey,
                     &dwDisp)
        != ERROR_SUCCESS) {
        return FALSE;
    }
    if (RegSetValueEx(hKey,
                      c_szProgramReturnValue,
                      0L,
                      REG_DWORD,
                      (LPBYTE)&dwValue,
                      sizeof(DWORD))
        != ERROR_SUCCESS) {
        return FALSE;
    }
    RegCloseKey(hKey);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetProgramReturnValue
//
//  gets the program return value from Registry values.
//
//  10-Feb-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
BOOL
GetProgramReturnValue(LPDWORD lpdwValReturn)
{
    HKEY    hKey;
    DWORD   dwVal;
    DWORD   dwValSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     c_szRegionalSettings,
                     0L,
                     KEY_READ,
                     &hKey)
        != ERROR_SUCCESS) {
        return FALSE;
    }
    dwValSize = sizeof(DWORD);
    if (RegQueryValueEx(hKey,
                      c_szProgramReturnValue,
                      (LPDWORD)NULL,
                      (LPDWORD)NULL,
                      (LPBYTE)&dwVal,
                      &dwValSize)
        != ERROR_SUCCESS) {
        return FALSE;
    }
    RegCloseKey(hKey);

    //
    //
    // clean it.
    //
    RegDeleteKey(HKEY_LOCAL_MACHINE, c_szRegionalSettings);

    *lpdwValReturn = dwVal;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\instlpk.h ===
BOOL WINAPI InstallLPK(int, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\instlpk.c ===
/****************************************************************************

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    instlpk.lib

File Name:

    instlpk.c

Abstract:

    This is an interface to start installing/uninstalling language package
    as we specify any language (locale) in the command option.

    This module will start a program ported from Regional Settings.
    However, keep in mind that the Regional Settings is compiled in UNICODE.


    See the following note from Regional Settings (regdlg.c) about installing
    LangPack:

    //
    //  Register the regional change every time so that all other property
    //  pages will be updated due to the locale settings change.
    //
    
Public Functions:

    InstallLPK      -- install/uninstall LangPack.


Revision History:

    20-Jan-98       -- Yuhong Li [YuhongLi]
        make InstallLPK() for NT 5.0.


****************************************************************************/

#ifdef ENABLE_UILANGUAGE
//
// nt.h is for NtQueryDefaultUILanguage in ntexapi.h and STATUS_SUCCESS in 
// ntstatus.h 
//
#include <nt.h>
#include <ntrtl.h>      // for nt.h
#include <nturtl.h>     // for nt.h
#endif // ENABLE_UILANGUAGE

#include <windows.h>
#include <setupapi.h>   // for HINF.
#include <stdlib.h>
#include <stdio.h>

#include "locale.h"

//
// nothing, but for readability.
//
#define PRIVATE
#define PUBLIC

//
// Build team uses the name "nec_98", but I refer to use "nec98", which is
// also used in NT 5.0 CD-ROM for platform soruce.
// (last confirmation about this concern on Feb 2, 1998).
//
#define CPU_NEC98_NAME          TEXT("nec98")
#define MAX_BUFFER_SIZE         256
#define PROGRAM_TITLE           TEXT("Install LangPack")
#define SUPPORTED_BUILD         1843 // 1754 -> 1783 -> 1843
#define STRESSLPK_ANSFILE_NAME  TEXT("stresslpk_ans.txt")


static const TCHAR c_szLastLocale[] =
    TEXT("System\\CurrentControlSet\\Control\\Nls\\LastLocale");
static const TCHAR c_szSystemLocale[] =
    TEXT("SystemLocale");
static const TCHAR c_szUserLocale[] =
    TEXT("UserLocale");
static const TCHAR c_szSortLocale[] =
    TEXT("SortLocale");
static const TCHAR c_szUILanguage[] =
    TEXT("UILanguage");
static const TCHAR c_szUnattendSection[] =
    TEXT("[RegionalSettings]\r\n");

TCHAR   g_szUnattendFileName[MAX_BUFFER_SIZE];
HANDLE  g_pUnattendFile;


PRIVATE BOOL
InstallLangPack(LCID lcNewLocaleID);

PRIVATE BOOL
RecoverLangPack(void);

PRIVATE BOOL
RemoveLangPack(LCID lcLCID);

extern BOOL
LaunchRegionalSettings(LPTSTR pCmdOption);

////////////////////////////////////////////////////////////////////////////
//
//  InstallLPK
//
//  install/uninstall LangPack.
//
//  ??-???-97   Jeff Jun Yin [JeffJunY]
//      creat the interface
//
//  20-Jan-98   Yuhong Li [YuhongLi]
//      keep the function interface and create the body.
//
////////////////////////////////////////////////////////////////////////////
PUBLIC
BOOL WINAPI InstallLPK(
    int nLCIndex,
    BOOL bInst)
{
    OSVERSIONINFOEX szVersionInfo; // OSVERSIONINFOEX requires NT5.0 or later.
    LCID            lcLocaleID;
    HCURSOR         hcurSave;
    BOOL            hRet;
    int             retScan = 0;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // Get build#.
    //
    szVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO)&szVersionInfo) == FALSE) {
        return FALSE;
    }
    if (szVersionInfo.dwBuildNumber < SUPPORTED_BUILD) {
        //
        // We don't support the builds older than SUPPORTED_BUILD.
        //
        return FALSE;
    }

    //
    // set locale
    //
    retScan = sscanf(Locale[nLCIndex].szID, TEXT("%x"), &lcLocaleID);
    if ( 0 == retScan || EOF == retScan ) {
        return FALSE;
    }

    hRet = (bInst == TRUE)? InstallLangPack(lcLocaleID) : RecoverLangPack();
    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    return hRet;

}

//===========================================================================



////////////////////////////////////////////////////////////////////////////
//
//  TransNum
//
//  Converts a number string to a dword value (in hex).
//
////////////////////////////////////////////////////////////////////////////
//
// The TransNum function is just copied from Regional Settings.
//
PRIVATE
DWORD TransNum(
    LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}

////////////////////////////////////////////////////////////////////////////
//
//  IsNECPC98Platform
//
//  detects if the machine is NEC PC-98, then returns TURE.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL IsNECPC98Platform(void)
{
    HKEY            hKey;
    TCHAR           szData[MAX_BUFFER_SIZE];
    DWORD           cbData;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("HARDWARE\\DESCRIPTION\\System"),
                     0L,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    cbData = sizeof(szData) - 1;    // in bytes, leave 1 for null.
    if (RegQueryValueEx(hKey,
                      TEXT("Identifier"),
                      (LPDWORD)NULL,
                      (LPDWORD)NULL,
                      (LPBYTE)szData,
                      &cbData) != ERROR_SUCCESS) {
        return FALSE;
    }
    szData[cbData] = TEXT('\0');
    RegCloseKey(hKey);

    return (strncmp(szData, TEXT("NEC PC-98"), 9) == 0)? TRUE: FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetBuildInfo
//
//  gets the build#, free or chk and cpu name of the machine.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL GetBuildInfo(
    LPDWORD lpBuild,
    LPTSTR  lpFreeBld,
    LPTSTR  lpCPU)
{
    OSVERSIONINFO   szVersionInfo;
    HKEY            hKey;
    TCHAR           szData[MAX_BUFFER_SIZE];
    DWORD           cbData;
    TCHAR           szUniMultiProc[MAX_BUFFER_SIZE];
    TCHAR           szFreeChk[MAX_BUFFER_SIZE];
    TCHAR           szCPU[MAX_BUFFER_SIZE];
    int             retScan = 0;


    //
    // Get CPU name.
    //
    if (GetEnvironmentVariable(TEXT("PROCESSOR_ARCHITECTURE"),
                               szCPU,
                               sizeof(szCPU)) == 0) {
        return FALSE;
    }

    if (IsNECPC98Platform() == TRUE) {
        strcpy(szCPU, CPU_NEC98_NAME);
    }

    //
    // Get build#.
    //
    szVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&szVersionInfo) == FALSE) {
        return FALSE;
    }

    //
    // Identify free or chk build.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                     0L,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    cbData = sizeof(szData) - 1;    // in bytes, leave 1 for null.
    if (RegQueryValueEx(hKey,
                      TEXT("CurrentType"),
                      (LPDWORD)NULL,
                      (LPDWORD)NULL,
                      (LPBYTE)szData,
                      &cbData) != ERROR_SUCCESS) {
        return FALSE;
    }
    szData[cbData] = 0;
    RegCloseKey(hKey);

    //
    // szUniMultiProce is not used, just for sscanf.
    //
    retScan = sscanf(szData, "%s %s", szUniMultiProc, szFreeChk);
    if ( 0 == retScan || EOF == retScan ) {
        return FALSE;
    }

    *lpBuild = szVersionInfo.dwBuildNumber;
    strcpy(lpCPU, szCPU);
    if ((szFreeChk[0] != TEXT('F')) && (szFreeChk[0] != TEXT('f'))) {
        strcpy(lpFreeBld, TEXT(".chk"));
    } else {
        lpFreeBld[0] = TEXT('\0');
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLangPackPath
//
//  gets the directory path where LangPack are stored.  If we can not get the
//  path, we just put the empty and mean to use system default source path.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
void GetLangPackPath(LPTSTR lpPathOption)
{
    TCHAR   szBuff[MAX_BUFFER_SIZE * 2];
    TCHAR   szHostName[MAX_BUFFER_SIZE];
    TCHAR   szFreeChk[MAX_BUFFER_SIZE];
    TCHAR   szCPU[MAX_BUFFER_SIZE];
    LPTSTR  lpCur, lpStrName, lpStrEnd;
    BOOL    fFound;
    INT     inLen;
    DWORD   dwBuildNum;
    DWORD   dwSectionSize;
    HANDLE  hDir;

    //
    // First, try the environment %LANGPACK_PATH%.
    //
    if (GetEnvironmentVariable(TEXT("LANGPACK_PATH"),
                szBuff, sizeof(szBuff)) > 0) {
        strcpy(lpPathOption, szBuff);
        return;
    }

    //
    // Well, let's figure out the source path.
    // The stress.ini is always copied into the local machine when we run
    // stress commands. So we pick the stress server name from stress.ini
    // like following:
    //
    // [binary-servers]
    //      server=\\ntstress\stress\*\stress
    //      server=\\ntstress2\stress\*\stress
    //
    // If ntstress is on-line and LangPack stuff is ready, put LangPack path
    // in lpPathOption, e.g., "\\ntstress\langpack\x86\1935"
    // If not, then try the next key "ntstress2" until we find one.
    //
    dwSectionSize = GetPrivateProfileSection(
                        TEXT("binary-servers"),
                        szBuff,
                        sizeof(szBuff),
                        TEXT("stress.ini"));
    if (dwSectionSize == 0) {
        return;
    }
    if (dwSectionSize == sizeof(szBuff) - 2) {
        //
        // Over the buffer size it should never happen, because the buffer
        // is supposed to handle at least 10 lines (10 stress servers) of
        // this section --  the stress.ini is messed up.
        // 
        return;
    }

    szHostName[0] = TEXT('\0');
    fFound = FALSE;
    lpCur = szBuff;
    while (*lpCur && (fFound == FALSE)) {
        //
        // pick the machine name from the key such that:
        //      server=\\ntstress\stress\*\stress
        //
        lpStrName = strchr(lpCur, TEXT('\\'));
        if ((lpStrName == NULL) ||
            (*(lpStrName + 1) != TEXT('\\'))) { 
            // It should never happen -- the stress.ini is messed up.
            return;
        }
        lpStrEnd = strchr(lpStrName + 2, TEXT('\\'));
        if (lpStrEnd == NULL) {
            // It should never happen -- the stress.ini is messed up.
            return;
        }
        inLen = (INT)(lpStrEnd - lpStrName);
        strncpy(szHostName, lpStrName, inLen);
        szHostName[inLen] = TEXT('\0');
        strcat(szHostName, TEXT("\\langpack"));

        //
        // check \\ntstress\langpack to see if the machine is on-line.
        //
        hDir = CreateFile(szHostName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
                    NULL);
        if (hDir == INVALID_HANDLE_VALUE) {
            // advance to the next key.
            lpCur += strlen(lpCur) + 1;
        } else {
            CloseHandle(hDir);
            fFound = TRUE;
        }
    }

    if (fFound == FALSE) {
        // not found.
        return;
    }

    //
    //
    // Get build information to make a path like:
    //      \\ntfestress\langpack\x86\1735[.chk]
    //
    if (GetBuildInfo(&dwBuildNum, szFreeChk, szCPU) == FALSE) {
        return;
    }

    // Since some build (around NT 2036) Regional Options always cuts off the
    // last word (whack off) in the source path.  It hurts our correct LangPack
    // path we passed.
    // To avoid it, add an extran back-slash at the end of LangPack path to
    // feed its cut.
    sprintf(lpPathOption,
                TEXT("%s\\%s\\%d%s\\"),
                szHostName,
                szCPU,
                dwBuildNum,
                szFreeChk);
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateUnattendFile
//
//  creates an unattend file which will be provided to Regional Options to
//  install LangPack.
//
//  21-Jul-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL CreateUnattendFile(void)
{
    DWORD           dwWrittenSize;
    TCHAR           szBuff[MAX_BUFFER_SIZE];

    //
    // get a temprorary unattend file name for Regional Options.
    //
    if (GetEnvironmentVariable(TEXT("TEMP"),
                               szBuff,
                               sizeof(szBuff)) == 0) {
        return FALSE;
    }
    sprintf(g_szUnattendFileName,
            TEXT("%s\\%s"),
            szBuff,
            STRESSLPK_ANSFILE_NAME);

    g_pUnattendFile = CreateFile(g_szUnattendFileName,
                        GENERIC_READ|GENERIC_WRITE,
                        0,
                        (LPSECURITY_ATTRIBUTES)NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE)NULL);
    if (g_pUnattendFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WriteFile(g_pUnattendFile,
                c_szUnattendSection,
                strlen(c_szUnattendSection),
                &dwWrittenSize,
                (LPOVERLAPPED)NULL);

    return TRUE;
}

#define WriteUnattendFile(pLine)                                    \
{                                                                   \
    DWORD dwWrittenSize;                                            \
                                                                    \
    WriteFile(g_pUnattendFile,                                      \
                (pLine),                                            \
                strlen(pLine),                                      \
                &dwWrittenSize,                                     \
                (LPOVERLAPPED)NULL);                                \
}

#define CloseUnattendFile()         CloseHandle(g_pUnattendFile)


////////////////////////////////////////////////////////////////////////////
//
//  SetRegistryLastLocale
//
//  saves the current locales into Registry for recovery later.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////

#define SET_LOCALE_ID(lcID, szName)                                     \
{                                                                       \
    sprintf(szData, TEXT("%04x"), (lcID));                              \
    if (RegSetValueEx(hKey,                                             \
                      (szName),                                         \
                      0L,                                               \
                      REG_SZ,                                           \
                      (LPBYTE)szData,                                   \
                      (lstrlen(szData) + 1) * sizeof(TCHAR))            \
        != ERROR_SUCCESS)                                               \
    {                                                                   \
        return FALSE;                                                   \
    }                                                                   \
}

PRIVATE
BOOL SetRegistryLastLocale(
    LCID    lcSysLocaleID,
    LCID    lcUserLocaleID,
    LANGID  lnUILanguageID)
{
    HKEY    hKey;
    DWORD   dwDisp;
    TCHAR   szData[MAX_BUFFER_SIZE];

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                     c_szLastLocale,
                     0L,
                     NULL,
                     REG_OPTION_NON_VOLATILE,
                     KEY_WRITE,
                     (LPSECURITY_ATTRIBUTES)NULL,
                     &hKey,
                     &dwDisp) != ERROR_SUCCESS) {
        return FALSE;
    }

    SET_LOCALE_ID(lcSysLocaleID, c_szSystemLocale);
    SET_LOCALE_ID(lcUserLocaleID, c_szUserLocale);
    SET_LOCALE_ID(lnUILanguageID, c_szUILanguage);

    RegCloseKey(hKey);

    return TRUE;

}

////////////////////////////////////////////////////////////////////////////
//
//  GetRegistryLastLocale
//
//  gets the last locales we saved in Registry.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
#define GET_LOCALE_ID(pLCID, szName)                                    \
{                                                                       \
    cbData = sizeof(szData) - 1;                                        \
    szData[0] = 0;                                                      \
    if (RegQueryValueEx(hKey,                                           \
                      (szName),                                         \
                      (LPDWORD)NULL,                                    \
                      (LPDWORD)NULL,                                    \
                      (LPBYTE)szData,                                   \
                      &cbData) != ERROR_SUCCESS)                        \
    {                                                                   \
        return FALSE;                                                   \
    }                                                                   \
    szData[cbData] = TEXT('\0');                                        \
    *(pLCID) = TransNum(szData);                                        \
}

PRIVATE
BOOL GetRegistryLastLocale(
    LCID    *plcSysLocaleID,
    LCID    *plcUserLocaleID,
    LANGID  *plnUILanguageID)
{
    HKEY    hKey;
    TCHAR   szData[MAX_BUFFER_SIZE];
    DWORD   cbData;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     c_szLastLocale,
                     0L,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    GET_LOCALE_ID(plcSysLocaleID, c_szSystemLocale);
    GET_LOCALE_ID(plcUserLocaleID, c_szUserLocale);
    GET_LOCALE_ID((LCID *)plnUILanguageID, c_szUILanguage);

    RegCloseKey(hKey);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  SetSysUserLocale
//
//  makes a command line and start the program of installing LangPack.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL SetSysUserLocale(
    LCID    lcSysLocaleID,
    LCID    lcUserLocaleID,
    LANGID  lnUILanguageID)
{
    TCHAR   szPathOption[MAX_BUFFER_SIZE];
    TCHAR   szCmdOption[MAX_BUFFER_SIZE * 2];
    TCHAR   szBuff[MAX_BUFFER_SIZE];
    DWORD   dwWrittenSize;

    szBuff[0] = TEXT('\0');
    GetLangPackPath(szBuff);
    if (szBuff[0] == TEXT('\0')) {
        // no LangPack in stress sever, no running of LangPack.
        return FALSE;
    }
    sprintf(szPathOption,
                TEXT("/s:\"%s\""),
                szBuff);

    //
    // must begin with digit 0 to tell Setup the number is in hex.
    // or begin explicitly with "0x".
    //
// For stress, we no longer set SysLocale. That way one reboot can recover all.
//    sprintf(szBuff, TEXT("%s = %08x\r\n"), c_szSystemLocale, lcSysLocaleID);
//    WriteUnattendFile(szBuff);

    sprintf(szBuff, TEXT("%s = %08x\r\n"), c_szUserLocale, lcUserLocaleID);
    WriteUnattendFile(szBuff);
    CloseUnattendFile();

    sprintf(szCmdOption,
// Since NT 2035, it requires the option /g to show up setup dialog.
            TEXT("/g /f:\"%s\" %s"),
            g_szUnattendFileName,
            szPathOption);

    return LaunchRegionalSettings(szCmdOption);
}


//////////////////////////////////////////////////////////////////////////////
//
// stole from Regional Settings regdlg.c for the function GetLanguageGroupID
//
// For easy comparision and maintanance, I just copied the piece of source from
// regdlg.c except wsprintf in Regional Settings and sprintf in our source.
// Many stuff is not needed in our sources.
//
//////////////////////////////////////////////////////////////////////////////

//=== BEGIN OF REGIONAL SETTING SOURCE ===
#define ML_ORIG_INSTALLED    0x0001
#define ML_PERMANENT         0x0002
#define ML_INSTALL           0x0004
#define ML_REMOVE            0x0008

static TCHAR szIntlInf[]          = TEXT("intl.inf");
static TCHAR szLocaleListPrefix[] = TEXT("LOCALE_LIST_");
static TCHAR szLGRemovePrefix[]   = TEXT("LG_REMOVE_");


typedef struct languagegroup_s
{
    WORD wStatus;                   // status flags
    UINT LanguageGroup;             // language group value
    HANDLE hLanguageGroup;          // handle to free for this structure
    TCHAR pszName[MAX_PATH];        // name of language group
    UINT NumLocales;                // number of locales in pLocaleList
    LCID pLocaleList[MAX_PATH];     // ptr to locale list for this group
    UINT NumAltSorts;               // number of alternate sorts in pAltSortList
    LCID pAltSortList[MAX_PATH];    // ptr to alternate sorts for this group
    struct languagegroup_s *pNext;  // ptr to next language group node

} LANGUAGEGROUP, *LPLANGUAGEGROUP;

static LPLANGUAGEGROUP pLanguageGroups = NULL;
static HINF g_hIntlInf = NULL;

////////////////////////////////////////////////////////////////////////////
//
//  Region_GetLocaleList
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_GetLocaleList(
    LPLANGUAGEGROUP pLG)
{
    TCHAR szSection[MAX_PATH];
    INFCONTEXT Context;
    int LineCount, LineNum;
    LCID Locale;

    //
    //  Get the inf section name.
    //
    sprintf(szSection, TEXT("%s%d"), szLocaleListPrefix, pLG->LanguageGroup);

    //
    //  Get the number of locales for the language group.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, szSection);
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Add each locale in the list to the language group node.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, szSection, LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &Locale))
        {
            if (SORTIDFROMLCID(Locale))
            {
                //
                //  Add the locale to the alternate sort list for this
                //  language group.
                //
                if (pLG->NumAltSorts >= MAX_PATH)
                {
                    return (FALSE);
                }
                pLG->pAltSortList[pLG->NumAltSorts] = Locale;
                (pLG->NumAltSorts)++;
            }
            else
            {
                //
                //  Add the locale to the locale list for this
                //  language group.
                //
                if (pLG->NumLocales >= MAX_PATH)
                {
                    return (FALSE);
                }
                pLG->pLocaleList[pLG->NumLocales] = Locale;
                (pLG->NumLocales)++;
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_GetSupportedLanguageGroups
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_GetSupportedLanguageGroups()
{
    UINT LanguageGroup;
    HANDLE hLanguageGroup;
    LPLANGUAGEGROUP pLG;
    INFCONTEXT Context;
    TCHAR szSection[MAX_PATH];
    int LineCount, LineNum;

    //
    //  Get the number of supported language groups from the inf file.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, TEXT("LanguageGroups"));
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Go through all supported language groups in the inf file.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, TEXT("LanguageGroups"), LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &LanguageGroup))
        {
            //
            //  Create the new node.
            //
            if (!(hLanguageGroup = GlobalAlloc(GHND, sizeof(LANGUAGEGROUP))))
            {
                return (FALSE);
            }
            pLG = GlobalLock(hLanguageGroup);

            //
            //  Fill in the new node with the appropriate info.
            //
            pLG->wStatus = 0;
            pLG->LanguageGroup = LanguageGroup;
            pLG->hLanguageGroup = hLanguageGroup;
            (pLG->pszName)[0] = 0;
            pLG->NumLocales = 0;
            pLG->NumAltSorts = 0;

            //
            //  Get the appropriate display string.
            //
            if (!SetupGetStringField(&Context, 1, pLG->pszName, MAX_PATH, NULL))
            {
                GlobalUnlock(hLanguageGroup);
                GlobalFree(hLanguageGroup);
                continue;
            }

            //
            //  See if this language group can be removed.
            //
            sprintf(szSection, TEXT("%s%d"), szLGRemovePrefix, LanguageGroup);
            if ((!SetupFindFirstLine( g_hIntlInf,
                                      szSection,
                                      TEXT("AddReg"),
                                      &Context )))
            {
                //
                //  Mark it as permanent.
                //  Also mark it as originally installed to avoid problems.
                //
                pLG->wStatus |= (ML_ORIG_INSTALLED | ML_PERMANENT);
            }

            //
            //  Get the list of locales for this language group.
            //
            if (Region_GetLocaleList(pLG) == FALSE)
            {
                return (FALSE);
            }

            //
            //  Add the language group to the front of the linked list.
            //
            pLG->pNext = pLanguageGroups;
            pLanguageGroups = pLG;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_InitInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_InitInf(
    HWND hDlg,
    HINF *phIntlInf,
    LPTSTR pszInf,
    HSPFILEQ *pFileQueue,
    PVOID *pQueueContext)
{
    //
    //  Open the Inf file.
    //
    *phIntlInf = SetupOpenInfFile(pszInf, NULL, INF_STYLE_WIN4, NULL);
    if (*phIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, *phIntlInf, NULL))
    {
        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    //
    //  Create a setup file queue and initialize default setup
    //  copy queue callback context.
    //
    *pFileQueue = SetupOpenFileQueue();
    if ((!*pFileQueue) || (*pFileQueue == INVALID_HANDLE_VALUE))
    {
        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    *pQueueContext = SetupInitDefaultQueueCallback(hDlg);
    if (!*pQueueContext)
    {
        SetupCloseFileQueue(*pFileQueue);
        SetupCloseInfFile(*phIntlInf);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_CloseInf
//
////////////////////////////////////////////////////////////////////////////

void Region_CloseInf(
    HINF hIntlInf,
    HSPFILEQ FileQueue,
    PVOID QueueContext)
{
    //
    //  Terminate the Queue.
    //
    SetupTermDefaultQueueCallback(QueueContext);

    //
    //  Close the file queue.
    //
    SetupCloseFileQueue(FileQueue);

    //
    //  Close the Inf file.
    //
    SetupCloseInfFile(hIntlInf);
}

//=== END OF REGIONAL SETTING SOURCE ===

////////////////////////////////////////////////////////////////////////////
//
//  CreateLanguageGroups
//
//  creates a global list pLanguageGroups used for GetLanguageGroupID.
//
//  21-Jul-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL CreateLanguageGroups(void)
{
    //
    //  Open the Inf file.
    //
    g_hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (g_hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, g_hIntlInf, NULL))
    {
        SetupCloseInfFile(g_hIntlInf);
        g_hIntlInf = NULL;
        return (FALSE);
    }

    //
    //  Get all supported language groups from the inf file.
    //
    if (Region_GetSupportedLanguageGroups() == FALSE)
    {
        return (FALSE);
    }

    //
    //  Close the inf file.
    //
    SetupCloseInfFile(g_hIntlInf);
    g_hIntlInf = NULL;
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageGroupID
//
//  gets the language group id# which contains the specifiied lcoale lcLocaleID
//  e.g., For JPN locale, its locale id is 0x411, the function will return its
//  its language group id 7.
//  This information is defined in %windir%\INF\intl.inf.
//
//  21-Jul-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
INT GetLanguageGroupID(LCID lcLocaleID)
{
    LPLANGUAGEGROUP pLG;
    UINT            ctr;
    LCID            idLocale;

    //
    //  Go through the list of language groups.
    //
    pLG = pLanguageGroups;
    while (pLG) {
        for (ctr = 0; ctr < pLG->NumLocales; ctr++) {
            idLocale = (pLG->pLocaleList)[ctr];
            if (idLocale == lcLocaleID) {
                return pLG->LanguageGroup;
            }
        }
        pLG = pLG->pNext;
    }
    return 0;
}


////////////////////////////////////////////////////////////////////////////
//
//  InstallLangPack
//
//  sets the system and user locales to the specified one and install its
//  LangPack if it has not installed.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE BOOL
InstallLangPack(LCID lcNewLocaleID)
{
    LCID    lcCurSysLocaleID;
    LCID    lcCurUserLocaleID;
    LANGID  lnCurUILanguageID = (LANGID)0;
    INT     inLangNo;
    TCHAR   szLangGroup[MAX_BUFFER_SIZE];

    lcCurSysLocaleID =  GetSystemDefaultLCID();
    lcCurUserLocaleID = GetUserDefaultLCID();

#ifdef ENABLE_UILANGUAGE
/*
I don't touch UILanguage for the reasons:

1).  The function NtQueryDefaultUILanguage is in NT 5.0 only.  This will
     cuase that munger linked with this library instlpk.lib doesn't work
     in NT 4.0 due to the error:

         Can not find NtQueryDefultUILanguage in ntdll.dll.

2).  It is OK for us who don't care it here, because our purpose is to install
     the language packages.  In addition the UI has not shown up (not enabled)
     in default in the recent builds (date: Feb 26, 1998, NT 1757).
*/

//
//  see ntos\ex\sysinfo.c for NtQueryDefaultUILanguage.
//
    if (NtQueryDefaultUILanguage(&lnCurUILanguageID) != STATUS_SUCCESS)
    {
        lnCurUILanguageID = (LANGID)0;
    }
#endif // ENABLE_UILANGUAGE


    //
    // save the current locales into Registry for recovery later.
    //
    if (SetRegistryLastLocale(lcCurSysLocaleID,
                          lcCurUserLocaleID,
                          lnCurUILanguageID) == FALSE) {
        return FALSE;
    }

    if (CreateLanguageGroups() == FALSE) {
        return FALSE;
    }

    if ((inLangNo = GetLanguageGroupID(lcNewLocaleID)) == 0) {
        //
        // not find, return
        // !!! need to tell user.
        return FALSE;
    }

    if (CreateUnattendFile() == FALSE) {
        return FALSE;
    }
    
    sprintf(szLangGroup, TEXT("LanguageGroup = %d\r\n"), inLangNo);
    WriteUnattendFile(szLangGroup);

    return SetSysUserLocale(lcNewLocaleID,     // system locale.
                            lcNewLocaleID,     // user locale same as system.
                            0);                // not touch UI language.
}


////////////////////////////////////////////////////////////////////////////
//
//  RecoverLangPack
//
//  recovers the last locale both system and user locales we saved during
//  InstallLangPack.
//
//  20-Jan-98   Yuhong Li [YuhongLi]    created.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE BOOL
RecoverLangPack(void)
{
    LCID    lcOrgSysLocaleID;
    LCID    lcOrgUserLocaleID;
    LANGID  lnOrgUILanguageID;
    LCID    lcCurUserLocaleID;

    lcCurUserLocaleID = GetUserDefaultLCID();

    if (GetRegistryLastLocale(&lcOrgSysLocaleID,
                              &lcOrgUserLocaleID,
                              &lnOrgUILanguageID) == FALSE) {
        return FALSE;
    }

    if (CreateUnattendFile() == FALSE) {
        return FALSE;
    }

    if (SetSysUserLocale(lcOrgSysLocaleID,
                            lcOrgUserLocaleID,
                            lnOrgUILanguageID) == FALSE) {
        return FALSE;
    }

    RegDeleteKey(HKEY_LOCAL_MACHINE, c_szLastLocale);

    //
    // remove LangPack.
    //
    if (RemoveLangPack(lcCurUserLocaleID) == FALSE) {
        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveLangPack
//
//  remove the langpack that contains the lcLCID.
//  This piece of program is modified from Regional Settings, that is from
//  the function Region_SetupLanguageGroups() in regdlg.c.   
//
//  26-Oct-98   Yuhong Li [YuhongLi]    ported.
//
////////////////////////////////////////////////////////////////////////////
PRIVATE
BOOL RemoveLangPack(LCID lcLCID)
{
    HWND        hDlg = NULL;
    BOOL        g_bSetupCase = FALSE;
    HINF        hIntlInf;
    HSPFILEQ    FileQueue;
    PVOID       QueueContext;
    TCHAR       szSection[MAX_PATH];
    INT         inLangNo;
    DWORD       d;
    TCHAR       szSetupSourcePath[MAX_PATH];
    LPTSTR      pSetupSourcePath =  szSetupSourcePath;

    szSetupSourcePath[0] = TEXT('\0');
    GetLangPackPath(szSetupSourcePath);
    if (szSetupSourcePath[0] == TEXT('\0')) {
        // no LangPack in stress sever, no running of LangPack.
        return FALSE;
    }

    if (CreateLanguageGroups() == FALSE) {
        return FALSE;
    }

    if ((inLangNo = GetLanguageGroupID(lcLCID)) == 0) {
        //
        // not find, shouldn't happen here.
        return FALSE;
    }

    //
    //  Get the inf section name.
    //
    sprintf(szSection, TEXT("%s%d"), szLGRemovePrefix, inLangNo);

    if (Region_InitInf(hDlg, &hIntlInf, szIntlInf, &FileQueue, &QueueContext)
        == FALSE) {
        return FALSE;
    }

    //
    //  Enqueue the code page files so that they may be
    //  copied.  This only handles the CopyFiles entries in the
    //  inf file.
    //
    //  Although we do remove, we still put here in case if intl.inf
    //  is changed to copy some files even during remove.
    //
    if (!SetupInstallFilesFromInfSection( hIntlInf,
                                          NULL,
                                          FileQueue,
                                          szSection,
                                          pSetupSourcePath,
                                          (g_bSetupCase)
                                            ? SP_COPY_FORCE_NOOVERWRITE
                                            : SP_COPY_NEWER ))
    {
        //
        //  Setup failed to find the language group.
        //  This shouldn't happen - the inf file is messed up.
        //
        return FALSE;
    }

    //
    //  See if we need to install any files.
    //
    //  d = 0: User wants new files or some files were missing;
    //         Must commit queue.
    //
    //  d = 1: User wants to use existing files and queue is empty;
    //         Can skip committing queue.
    //
    //  d = 2: User wants to use existing files, but del/ren queues
    //         not empty.  Must commit queue.  The copy queue will
    //         have been emptied, so only del/ren functions will be
    //         performed.
    //
    if ((SetupScanFileQueue( FileQueue,
                             (g_bSetupCase)
                               ? SPQ_SCAN_FILE_VALIDITY
                               : SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_INFORM_USER,
                             hDlg,
                             NULL,
                             NULL,
                             &d )) && (d != 1))
    {
        //
        //  Copy the files in the queue.
        //
        if (!SetupCommitFileQueue( hDlg,
                                   FileQueue,
                                   SetupDefaultQueueCallback,
                                   QueueContext ))
        {
            //
            //  This can happen if the user hits Cancel from within
            //  the setup dialog.
            //
            Region_CloseInf(hIntlInf, FileQueue, QueueContext);
            return FALSE;
        }
    }

    //
    //  Call setup to install other inf info for this
    //  language group.
    //
    if (!SetupInstallFromInfSection( hDlg,
                                     hIntlInf,
                                     szSection,
                                     SPINST_ALL & ~SPINST_FILES,
                                     NULL,
                                     pSetupSourcePath,
                                     0,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL ))
    {
        //
        //  Setup failed.
        //
        //  This shouldn't happen - the inf file is messed up.
        //
        return FALSE;
    }

    //
    //  Close Inf stuff.
    //
    Region_CloseInf(hIntlInf, FileQueue, QueueContext);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\munger.c ===
/****************************************************************************

    PROGRAM: munger.c

    AUTHOR:  Lars Opstad (LarsOp) 4/26/94

    PURPOSE: Registry munger for stress system.

    FUNCTIONS:

        WinMain()       - main entry point
        GetRGSZEnvVar() - Alpha NVRAM function stolen from system applet
        UpdateNVRAM()   - Alpha NVRAM function stolen from system applet
        Changed()       - tells if the values have changed (is reboot required?)
        GetBootOptions()- gets the boot names, paths and debug
        SetBootOptions()- sets the boot names, paths and debug
        GetValues()     - read current registry/boot values
        SetValues()     - write current registry/boot values
        GetDlgItems()   - read dialog into variables
        SetDlgItems()   - set dialog items based on variables
        CheckPreferred()- see if the registry is already set the preferred way
        SetPreferred()  - set the stress preferences
        *DlgProc()      - processes messages for options dialog

    COMMENTS:

        This program provides a quick UI for changing the registry and
        boot selections before running stress.  It is a stand-alone utility
        so changes can be made more easily and so it can be used when not
        running stress.

****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "munger.h"      /* specific to this program */
#include "resource.h"

#if defined(_X86_)
#define PAGE_SIZE (ULONG)0x1000
#else
#define PAGE_SIZE (ULONG)0x2000
#endif
#define NOT_SET -1

#define MINUTE  60
#define HOUR    60 * MINUTE
#define DAY     24 * HOUR
#define WEEK    7 * DAY

#define DEFAULT(val, def) (-1==val?def:val)
#define POOL_UNDERRUNS 	0
#define POOL_OVERRUNS	1

typedef struct _BOOT_OPTION {
    TCHAR   Identifier[MAX_PATH];
    TCHAR   Path[MAX_PATH];
    TCHAR   OtherOptions[256];
    DWORD   DebugPort;
    DWORD   BaudRate;
    DWORD   DebugType;
    BOOL    Modified;
    } BOOT_OPTION;
//
// MUNGE_INFO contains all the informations that this program sets.
//
typedef struct _MUNGE_INFO {
    DWORD GlobalFlag;
    DWORD BootIndex;
    DWORD BootOption;
    BOOL  CrashDumpEnabled;
    BOOL  AutoReboot;
    BOOL  DebugWinlogon;
    BOOL  Alignment;
//
// LoadIMM is no longer touched.  We leave it to LangPack system.
// If you want to activate it, just put "-DLOADIMM" in compile options.
// If you want to clean the source, just delete the block between
// #ifdef and #endif.   -- YuhongLi, 12/02/98
//
#ifdef LOADIMM
    BOOL  LoadIMM;
#endif // LOADIMM
    DWORD CritSectTimeout;
    DWORD ResourceTimeout;
    int   nLCIndex;
    DWORD PoolTag;
    DWORD PoolTagOverruns;
    } MUNGE_INFO;


HWND    HSavePages[NUM_PROP]={NULL,NULL,NULL,NULL};
DWORD   BuildNumber;
BOOL    UseNewFlags;
BOOL    Quiet=FALSE;            /* Quiet means exit if preferred set */
BOOL    Preferred=FALSE;        /* Takes preferred settings */
BOOL    YesReboot=FALSE;        /* Reboots with whatever set chosen */
BOOL    ChooseDebug=FALSE;      /* Set Debug boot option */
BOOL    ChooseCSR=FALSE;        /* Set CSR debugging option */
BOOL    ChooseHeap=FALSE;       /* Set heap checking option */
BOOL    ChooseTagging=FALSE;    /* Set pool tagging option */
BOOL    ChooseObject=FALSE;     /* Set object typelist option */
BOOL    ChooseHandle=FALSE;     /* Set invalid handle option */
BOOL    ChooseSpecial=FALSE;    /* Set pool corrupter catching code */
BOOL    ChooseBaudRate=FALSE;   /* Set baudrate from command line */
BOOL    ChooseCommPort=FALSE;   /* Set commport from command line */
BOOL    ChooseAeDebug=FALSE;    /* Set AeDebug from command line */
BOOL	NoIndication= FALSE;	/* Give No indication Munger is setting the preferred stress setting*/
BOOL    bLCSet=FALSE;           /* Set LangPack option */
BOOL    bLCSetQuiet=FALSE;      /* Set quite mode of installing LangPack */
BOOL    IsAlpha=FALSE;

MUNGE_INFO Orig_Munge, Curr_Munge;        /* Original and current state */

TCHAR   Buffer[MAX_PATH];                 /* General buffer */
TCHAR   itoabuf[16];

BOOL        ChangedBootOptions=FALSE;
DWORD       NumBootOptions=0;
BOOT_OPTION BootOptions[MAX_BOOT_OPTIONS];
DWORD       dwCommPort = 2;
DWORD       BaudRate = 0;
DWORD       PoolTag = 0;
#ifdef FESTRESS
int         nLCIndex = 0;           // hold the locale set from command line.
BOOL        fDisableLocale = FALSE; // disable locale function for unknown loc.
#endif // FESTRESS
OSVERSIONINFOEX OsVersion;

//
// Names used in boot.ini parsing
//
TCHAR szBootIni[]     = TEXT("c:\\boot.ini");
TCHAR szFlexBoot[]    = TEXT("flexboot");
TCHAR szMultiBoot[]   = TEXT("multiboot");
TCHAR szBootLdr[]     = TEXT("boot loader");
TCHAR szTimeout[]     = TEXT("timeout");
TCHAR szDefault[]     = TEXT("default");
TCHAR szOS[]          = TEXT("operating systems");
TCHAR *pszBoot = NULL;

/*
 * These functions in SETUPDLL.DLL are ANSI only!!!!
 *
 * Therefore any functions working with this DLL MUST remain ANSI only.
 * The functions are GetRGSZEnvVar and UpdateNVRAM.
 * The structure CPEnvBuf MUST also remain ANSI only.
 */
typedef int (WINAPI *GETNVRAMPROC)(CHAR **, USHORT, CHAR *, USHORT);
typedef int (WINAPI *WRITENVRAMPROC)(DWORD, PSZ *, PSZ *);

#define BUFZ        4096
BOOL CheckExceptLocale();
/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE:  Initializes program and shows dialog.

    COMMENTS:

        Check for quiet and crash command options.
        Get current values (exit if failed).
        If quiet and preferred already chosen, exit.
        Show options dialog.

****************************************************************************/

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    int retval;
    retval=WinMainInner(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
    StatusToDebugger();
    return retval;
}

int WINAPI
WinMainInner(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    OFSTRUCT ofstruct;
    char *tmpptr = lpCmdLine;
    int i;
    DWORD dwLen = 0;
    TCHAR szBuff[5];
    SYSTEM_INFO SystemInfo;
    int retScan = 0;

    if (NULL!=strstr(lpCmdLine, "?")) {
        MessageBox(NULL,
                   "Munger [options]\n"
                   "/a: enable aedebug\n"
                   "/b baudrate: set baudrate\n"
                   "/c: enable CSR debugging\n"
                   "/d: boot in /Debug mode\n"
                   "/h: enable Heap checking\n"
                   "/i: break on invalid handles\n"
                   "/w: select a system default locale\n"
                   "/n: No Indication preferred has been set(really quiet)\n"
                   "/o: maintain object typelist\n"
                   "/p: choose preferred stress settings\n"
                   "/q: do not display UI\n"
                   "/s comport: set comport com1, com2, ...\n"
                   "/t: enable pool Tagging\n"
                   "/u [Tag]: enable pool corrupter catching code\n"
                   "/y: Yes (ok to reboot)\n"
                   "/?: this message",
                   "Usage for Munger.Exe", MB_OK|MB_ICONINFORMATION);
        return (1);
    }

    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((LPOSVERSIONINFO)&OsVersion);
    BuildNumber = OsVersion.dwBuildNumber;
    UseNewFlags=(BuildNumber>=829);

    GetSystemInfo(&SystemInfo);
    IsAlpha = (SystemInfo.wProcessorArchitecture & PROCESSOR_ARCHITECTURE_ALPHA)
                ? 1 : 0;

    while (*tmpptr) {
        tmpptr+=strcspn(tmpptr, "/-");  // Advance pointer to next argument

        if (*tmpptr==0)                 // if end of string
            break;                      //R return from function

        //
        // switch on the character following the - or /
        //
        switch (*(++tmpptr)){
        case 'a':
	case 'A':
            ChooseAeDebug = TRUE;
            break;
        case 'q':
	case 'Q':
            Quiet = TRUE;
            break;
        case 'n':
	case 'N':
            NoIndication = TRUE;
            break;
        case 'p':
	case 'P':
            Preferred= TRUE;
            //
            // IMM development broke command line for /py
            //
            if ( toupper(*(tmpptr+1)) == 'Y' ) {
                YesReboot = TRUE;
            }
            break;
        case 'y':
	case 'Y':
            YesReboot = TRUE;
            break;
        case 'd':
	case 'D':
            ChooseDebug= TRUE;
            break;
        case 'c':
	case 'C':
            ChooseCSR= TRUE;
            break;
        case 'h':
	case 'H':
            ChooseHeap= TRUE;
            break;
        case 't':
	case 'T':
            ChooseTagging= TRUE;
            break;
        case 'o':
	case 'O':
            ChooseObject = TRUE;
            break;
        case 'i':
	case 'I':
            ChooseHandle = TRUE;
            break;
        case 'u':
	case 'U':
            ChooseSpecial=TRUE;
            tmpptr++;
            if ( *tmpptr++ ) {
                if ( *tmpptr != '/' && *tmpptr != '-' ) { // Specified a tag
                    dwLen = strlen(tmpptr);
                    for ( ;dwLen > 0; dwLen--) {
                        (BYTE)PoolTag |= tmpptr[dwLen-1];
                        if ( dwLen-1 > 0) {
                            PoolTag = PoolTag << 8;
                        }
                    }
                }
            }
            break;
            case 's':
            case 'S':
                // Default value
                dwCommPort = 2;

                ChooseCommPort=TRUE;
                tmpptr += 2;
                {
                    DWORD dw = 0;
                    if (!_strnicmp(tmpptr, "com", 3)) {
                        tmpptr += 3;
                        dw = atol(tmpptr);
                    }

                    if (dw) {
                        // Success
                        dwCommPort = dw;
                    } else {
                        // No such thing as port 0
                        MessageBox(NULL,
                                   "You must specify a comm port with the /s option. "
                                   "For example, munger /s com1\n",
                                   "munger /s comport",
                                   MB_OK|MB_ICONHAND);
                        return 1;
                    }
                }
                break;

        case 'b':
	case 'B':
            ChooseBaudRate=TRUE;
            tmpptr += 2;
            if ( isdigit(*tmpptr) ) {
                BaudRate = atoi(tmpptr);
            } else {
                MessageBox(NULL,
                           "You must specify a baudrate with the /b option. "
                           "For example, munger /b 115200\n",
                           "munger /b baudrate",
                           MB_OK|MB_ICONHAND);
                return(1);
            }
            break;
#ifdef FESTRESS
        case 'w':
	case 'W':
            bLCSet = TRUE;
            ++tmpptr;
            if (*tmpptr == 'q' || *tmpptr == 'Q') {
                bLCSetQuiet = TRUE;
                ++tmpptr;
            }
            retScan = sscanf(tmpptr, "%s", szBuff);
            if ( 0 == retScan || EOF == retScan ) {
                break;
            }
            _strlwr(szBuff);
            for (i=0; i<NUM_LOCALE; i++)
                if (strcmp(szBuff, Locale[i].szAbbr) == 0) {
                    nLCIndex = i;
                    break;
                }
            if (i == NUM_LOCALE && nLCIndex != i) {
                MessageBox(NULL,
                   "Please use the following locale abbr.:\n"
                   "enu - English (U.S.)\n"
                   "jpn - Japanese\n"
                   "kor - Korean\n"
                   "cht - Chinese (Traditional)\n"
                   "chs - Chinese (Simplified)\n"
                   "chp - Chinese (HongKong)\n"
                   "chg - Chinese (Singapore) (not offical)\n"
                   "deu - German (Standard)\n"
                   "fra - French (Standard)\n"
                   "esp - Spanish (Traditional Sort)\n"
                   "ita - Italian\n"
                   "are - Arabic (Saudi Arabia)\n"
                   "heb - Hebrew\n"
                   "tha - Thai",
                   "Wrong locale abbreviation",
                   MB_OK|MB_ICONHAND);
                return(1);
            }
#endif
        default:
            break;
        }
    }

    if (!GetValues()) {
        MessageBox(NULL,
                   "Unable to get current registry/boot values. "
                   "Logon with admin privileges to make changes.",
                   "Error Loading Values",
                   MB_OK|MB_ICONHAND);
        return(1);
    }

    if (bLCSet && bLCSetQuiet &&
            CheckExceptLocale() && (!CheckPreferred())) {
        //
        // This condition indicates that munger is quietly installing
        // LangPack without showing dialog sheet.  If munger is launched
        // to set debug options at the first time, the quite mode is disabled
        // and it still will be shown with the other options together.
        //
        //
        YesReboot = TRUE;
        SetPreferred();
        SetValuesAndReboot();
        return 0;
    }

    if (NoIndication)
    {
        SetPreferred();
	SetValues();
	return 0;
    }

    if ((Quiet||YesReboot) && CheckPreferred()) {
        return (0);
    }
//	else if (Quiet) {
//        SetValuesAndReboot();
//        return 0;
//    }

    MakeProperty(hInstance);
    //
    // Display options dlg
    //
    //DialogBox(hInstance, (LPCSTR)(MAKEINTRESOURCE(IDD_OPTIONS)), NULL, OptionsDlgProc);

    return(0);

} // WinMain()

BOOL Is_ARCx86(void)
{
    TCHAR identifier[256];
    ULONG identifierSize = sizeof(identifier);
    HKEY hSystemKey = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("HARDWARE\\DESCRIPTION\\System"),
                     0,
                     KEY_QUERY_VALUE,
                     &hSystemKey) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx(hSystemKey,
                             TEXT("Identifier"),
                             NULL,
                             NULL,
                             (LPBYTE) identifier,
                             &identifierSize) == ERROR_SUCCESS)
            && (strstr(identifier, TEXT("ARCx86")) != NULL))
            return TRUE;
    }

    return FALSE;
}


void StatusToDebugger()
{
    DbgPrint("MUNGER: Global flags=%08x, Deadlock timeout=%d, Resource timeout=%d\n",
    Curr_Munge.GlobalFlag, Curr_Munge.CritSectTimeout, Curr_Munge.ResourceTimeout);
}

int
MakeProperty(
		HINSTANCE hInstance
		)
{
    PROPSHEETPAGE psp[NUM_PROP];
    PROPSHEETHEADER psh;
    int Result = IDCANCEL;
    WCHAR awchBuffer[MAX_PATH];

    //
    // Initialize the property sheet structures
    //

    RtlZeroMemory(psp, sizeof(psp));

    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags     = 0;
    psp[0].hInstance   = hInstance;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_OPTIONS);
    psp[0].pfnDlgProc  = (WNDPROC)BootDlgProc;
    psp[0].lParam      = PROP_BOOT;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags     = 0;
    psp[1].hInstance   = hInstance;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_FLAGS);
    psp[1].pfnDlgProc  = (WNDPROC)FlagsDlgProc;
    psp[1].lParam      = PROP_FLAG;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags     = 0;
    psp[2].hInstance   = hInstance;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_MISC);
    psp[2].pfnDlgProc  = (WNDPROC)MiscDlgProc;
    psp[2].lParam      = PROP_MISC;

    psp[3].dwSize      = sizeof(PROPSHEETPAGE);
    psp[3].dwFlags     = 0;
    psp[3].hInstance   = hInstance;
    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_LOCALE);
    psp[3].pfnDlgProc  = (WNDPROC)LocaleDlgProc;
    psp[3].lParam      = PROP_LOCALE;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPTITLE | PSH_USEICONID | PSH_PROPSHEETPAGE |
                  PSH_NOAPPLYNOW;
    psh.hwndParent = NULL;
    psh.hInstance = hInstance;
    psh.pszIcon = NULL;
    psh.pszCaption = "Stress Registry Munger";
    psh.nPages = NUM_PROP;
//    psh.nStartPage = 0;
//
//  If munger is popped for selecting LangPack ONLY, show the initial page
//  on Locale Settings. Otherwise sit on the first page as well as munger does
//  for any other options.
//
    psh.nStartPage = ((bLCSet == TRUE) && CheckExceptLocale())? 3: 0;
    psh.ppsp = psp;
    psh.pfnCallback = NULL;

    //
    // Create the property sheet
    //

    if (PropertySheet(&psh)) {
        GetDlgItems(NULL);
        if (Curr_Munge.AutoReboot) {
            int buttonRet;
            buttonRet = MessageBox(NULL,
                        "WARNING! You have your machine set to autoreboot "
                        "for bugchecks. This is BAD for stress.  You will "
                        "not be counted.  Is this OK?",
                        "Warning: Autoreboot Set",
                        MB_ICONHAND|MB_OKCANCEL);
            if (buttonRet==IDCANCEL) {
                return TRUE;
            }
        }
        if (Changed()) {
            SetValuesAndReboot();
        }
    }
    return 0;
}

static HMODULE hmodSetupDll;   // hmod for setup - has api we need
static GETNVRAMPROC fpGetNVRAMvar;  // address of function for getting nvram vars
BOOL fCanUpdateNVRAM;
typedef struct tagEnvBuf{
  int     cEntries;
  CHAR *  pszVars[10];
} CPEnvBuf;

////////////////////////////////////////////////////////////////////////////
//  CP_MAX_ENV assumes entire env. var. value < maxpath +
//  add 20 for various quotes
//  and 10 more for commas (see list description below)
//
//  NOTE: Changed to BUFZ (4096) to fix AV on alpha
////////////////////////////////////////////////////////////////////////////
#define CP_MAX_ENV   BUFZ

CPEnvBuf CPEBOSLoadIdentifier,CPEBOSLoadOptions, CPEBOSLoadPaths;
BOOL fAutoLoad;

////////////////////////////////////////////////////////////////////////////
//
//  This routine will query the Alpha NVRAM for an option passed
//  in szName and fill in the argv style pointer passed in.
//
////////////////////////////////////////////////////////////////////////////

BOOL
GetRGSZEnvVar(
		CPEnvBuf * pEnvBuf,
		PCHAR pszName
		)
{
    CHAR   *pszCur, *p;
    int     cb, i;
    CHAR   *rgtmp[1];
    CHAR    rgchOut[CP_MAX_ENV];

    // GetNVRAMVar takes an argv[] style paramater as input, so crock
    // one up.
    rgtmp[0] = pszName;

    // GetNVRAMVar returns a 'list' of the form
    //   open-curly"string1","string2","string3"close-curly
    //
    // an empty environment string will be 5 bytes:
    // open-curly""close-curly[null-terminator]

    cb = fpGetNVRAMvar (rgtmp, (USHORT)1,
                rgchOut, (USHORT) CP_MAX_ENV);

    pEnvBuf->cEntries = 0;

    // if cb was equal to 5, the string was empty (see above comment)
    if (cb > 5){
        // break the string up into array of separate strings that
        // can be put into a listbox.
        pszCur = rgchOut;

        // skip first open-curly brace
        pszCur++;

        // counter for array of strings
        i = 0;
        while (*pszCur != '}'){
            p = pEnvBuf->pszVars[i] = LocalAlloc (LPTR, MAX_PATH);
            if ( NULL == p ) {
                break;
            }
            // skip first quote
            pszCur++;
            while (*pszCur != '"')
               *p++ = *pszCur++;

            // skip the close quote
            pszCur++;

            // null terminate destination
            *p = '\0';

            // skip the comma if not at end of string
            if (*pszCur == ','){
               pszCur++;
               // and go to next string
            }
            i++;
        }
        pEnvBuf->cEntries = i;
    }

    return pEnvBuf->cEntries;
}


////////////////////////////////////////////////////////////////////////////
// The user has made a choice among the entries.
// Now we have to arrange all the strings stored in NVRAM so
// that they  have the same ordering.  The selection is passed in,
// so what this  function does is if selection is M, it makes the Mth item
// appear first in each of the 5 environment strings and the other items
// follow it in the list.
//
// Then if the timeout button is checked, it updates the AUTOLOAD variable
// to "yes" and set the COUNTDOWN variable to the number of seconds in the
// edit control.
////////////////////////////////////////////////////////////////////////////

BOOL
UpdateNVRAM(
    DWORD currDef,
    DWORD orgDebug,
    DWORD currDebug
)
{
    CHAR *rgszVRAM[5] = { "SYSTEMPARTITION",
                          "OSLOADER",
                          "OSLOADPARTITION",
                          "OSLOADFILENAME",
                          "OSLOADOPTIONS"
                        };
    CPEnvBuf rgcpeb[5];
    CPEnvBuf cpebAutoload;
    CPEnvBuf cpebCountdown;
    WRITENVRAMPROC fpWriteNVRAMVar;
    int j;
    CHAR *pszSwap;
    CHAR szTemp[10];
    HMODULE hmodSetupDLL;
    BOOL bChecked;
    BOOL bOK;

    // args and charray are needed for call to SetNVRamVar() in SETUP
    PSZ args[2];
    CHAR chArray[CP_MAX_ENV];
    PSZ pszReturn;


    if (!ChangedBootOptions) {
	return TRUE;
	}
    if ((hmodSetupDll = LoadLibrary (TEXT("setupdll"))) == NULL)
        return(FALSE);

    fpWriteNVRAMVar = (WRITENVRAMPROC) GetProcAddress(hmodSetupDll, "SetNVRAMVar");
    if (fpWriteNVRAMVar == NULL)
        return(FALSE);

    fpGetNVRAMvar = (GETNVRAMPROC) GetProcAddress(hmodSetupDll, "GetNVRAMVar");
    if (fpGetNVRAMvar == NULL)
        return(FALSE);

    // read in the strings from NVRAM.  the number of strings (other than
    // LOADIDENTIFIER is 5) and swap the default with the zeroth element
    {
    	int i;
    	for (i = 0; i < 5; i++){
            GetRGSZEnvVar (&rgcpeb[i], rgszVRAM[i]);
            // now re-order the strings to swap the 'currDef-th' item
            // string with the first string.
            pszSwap = rgcpeb[i].pszVars[0];
            rgcpeb[i].pszVars[0] = rgcpeb[i].pszVars[currDef];
            rgcpeb[i].pszVars[currDef] = pszSwap;
    	}
    }
    //
    // Swap the Zeroth and Default BOOT_OPTION structures
    //
    {
        BOOT_OPTION tmpBoot;
        tmpBoot=BootOptions[0];
        BootOptions[0]=BootOptions[Curr_Munge.BootIndex];
        BootOptions[Curr_Munge.BootIndex]=tmpBoot;
        Curr_Munge.BootIndex=0;
    }

            {
        UINT u;
        for (u=0;u<NumBootOptions;u++) {
            if (BootOptions[u].Modified) {
                rgcpeb[3].pszVars[u]=BootOptions[u].Path;
                rgcpeb[4].pszVars[u]=BootOptions[u].OtherOptions;
                switch (BootOptions[u].DebugType) {
                case IDO_RBNO:
                        strcat(BootOptions[u].OtherOptions, " /NODEBUG");
                    break;

                case IDO_RBDEBUG:
                        strcat(BootOptions[u].OtherOptions, " /DEBUG");
                    break;

                case IDO_RBCRASH:
                        strcat(BootOptions[u].OtherOptions, " /CRASHDEBUG");
                    break;

                default:
                    break;
            }
                if (-1!=BootOptions[u].DebugPort) {
                    strcat(BootOptions[u].OtherOptions, " /DEBUGPORT=COM");
                    strcat(BootOptions[u].OtherOptions, _itoa(BootOptions[u].DebugPort, itoabuf, 10));
                }
                if (-1!=BootOptions[u].BaudRate) {
                    strcat(BootOptions[u].OtherOptions, " /BAUDRATE=");
                    strcat(BootOptions[u].OtherOptions, _itoa(BootOptions[u].BaudRate, itoabuf, 10));
            }
            }
        }
    }

    if (rgcpeb[4].cEntries==0) {
        rgcpeb[4].cEntries=1;
    }

    // now do the same for the LOADIDENTIFIER, (this was set up earlier
    // in the processing the INITDIALOG message).
    pszSwap = CPEBOSLoadIdentifier.pszVars[0];
    CPEBOSLoadIdentifier.pszVars[0] = CPEBOSLoadIdentifier.pszVars[currDef];
    CPEBOSLoadIdentifier.pszVars[currDef] = pszSwap;

    // now write to NVRAM:  first write LOADIDENTIFIER, then the other 5
    // variables.
    args[0] = (PSZ)"LOADIDENTIFIER";
    args[1] = chArray;

    chArray[0] = '\0';
    {
	int i;
    	for (i = 0; i < CPEBOSLoadIdentifier.cEntries; i++){
            lstrcatA (chArray, CPEBOSLoadIdentifier.pszVars[i]);
            lstrcatA (chArray, ";");
    	}
    }
    // remove the last semi-colon:
    chArray[lstrlenA(chArray)-1] = '\0';

    fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);

    {
	int i;
    	for (i = 0; i < 5; i++){
            args[0] = rgszVRAM[i];
            args[1] = chArray;
            chArray[0] = '\0';
            for (j = 0; j < rgcpeb[i].cEntries; j++){
            	lstrcatA (chArray, rgcpeb[i].pszVars[j]);
            	lstrcatA (chArray, ";");
        	}
        	chArray[lstrlenA(chArray)-1] = '\0';

        	fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);
    	}
    }

    FreeLibrary (hmodSetupDll);
    return TRUE;
}

TCHAR x86DetermineSystemPartition (IN HWND hdlg);

/////////////////////////////////////////////////////////////////////
//
// Changed() simply returns whether any of the values have changed.
//
/////////////////////////////////////////////////////////////////////
BOOL Changed()
{
return  Orig_Munge.GlobalFlag       != Curr_Munge.GlobalFlag
     || Orig_Munge.BootIndex != Curr_Munge.BootIndex
     || ChangedBootOptions
     || Orig_Munge.CrashDumpEnabled != Curr_Munge.CrashDumpEnabled
     || Orig_Munge.AutoReboot       != Curr_Munge.AutoReboot
     || Orig_Munge.DebugWinlogon    != Curr_Munge.DebugWinlogon
#ifdef LOADIMM
     || Orig_Munge.LoadIMM          != Curr_Munge.LoadIMM
#endif // LOADIMM
     || Orig_Munge.Alignment        != Curr_Munge.Alignment
     || Orig_Munge.CritSectTimeout  != Curr_Munge.CritSectTimeout
     || Orig_Munge.ResourceTimeout  != Curr_Munge.ResourceTimeout
     || Orig_Munge.nLCIndex         != Curr_Munge.nLCIndex
     || Orig_Munge.PoolTag          != Curr_Munge.PoolTag;
}
#define AllocMem(cb)  LocalAlloc (LPTR, (cb))

//////////////////////////////////////////////////////////
// ParseBootOption() takes debug options and sets the
// various values for debugging.
//////////////////////////////////////////////////////////
void
ParseBootOption(
                IN OUT BOOT_OPTION *pBootOption
                )
{
    TCHAR *pCh=pBootOption->OtherOptions, *pTok=NULL;
    TCHAR tmpBuf[256];
    int i;
    int     retScan = 0;

    while (*pCh) {
        switch (*pCh) {
            case '-':
            case '/':
                switch (*(pCh+1)) {
                    case 'd':
                        if (0==_strnicmp(pCh+1, "debugport", strlen("debugport"))) {
                            retScan = sscanf(pCh, "/debugport=com%d", &(pBootOption->DebugPort));
                            if ( 0 == retScan || EOF == retScan ) {
                                pBootOption->DebugPort = dwCommPort;
                            }
                            while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                            }
                        } else if (0==_strnicmp(pCh+1, "debug", strlen("debug"))) {
                            pBootOption->DebugType=IDO_RBDEBUG;
                            while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                            }
                        }
                        break;

                    case 'c':
                        if (0==_strnicmp(pCh+1, "crashdebug", strlen("crashdebug"))) {
                            pBootOption->DebugType=IDO_RBCRASH;
                            while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                            }
                        }
                        break;

                    case 'b':
                        if (0==_strnicmp(pCh+1, "baudrate", strlen("baudrate"))) {
                            char separator;
                            retScan = sscanf(pCh, "/baudrate%c%d", &separator, &(pBootOption->BaudRate));
                            if ( 0 == retScan || EOF == retScan ) {
                                pBootOption->BaudRate = BaudRate;
                            }
                            while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                            }
                        }
                        break;

                    case 'n':
                        if (0==_strnicmp(pCh+1, "nodebug", strlen("nodebug"))) {
                            pBootOption->DebugType=IDO_RBNO;
                            while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                            }
                        }
                        break;

                    default:
                        ;
                    }
                break;
            case 'd':
                if (0==_strnicmp(pCh, "debugport", strlen("debugport"))) {
                    retScan = sscanf(pCh, "debugport=com%d", &(pBootOption->DebugPort));
                    if ( 0 == retScan || EOF == retScan ) {
                        pBootOption->DebugPort = dwCommPort;
                    }
                    while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                    }
                } else if (0==_strnicmp(pCh, "debug", strlen("debug"))) {
                    pBootOption->DebugType=IDO_RBDEBUG;
                    while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                    }
                }
                break;

            case 'c':
                if (0==_strnicmp(pCh, "crashdebug", strlen("crashdebug"))) {
                    pBootOption->DebugType=IDO_RBCRASH;
                    while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                    }
                }
                break;

            case 'b':
                if (0==_strnicmp(pCh, "baudrate", strlen("baudrate"))) {
                    char separator;
                    retScan = sscanf(pCh, "baudrate%c%d", &separator, &(pBootOption->BaudRate));
                    if ( 0 == retScan || EOF == retScan ) {
                        pBootOption->BaudRate = BaudRate;
                    }
                    while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                    }
                }
                break;

            case 'n':
                if (0==_strnicmp(pCh, "nodebug", strlen("nodebug"))) {
                    pBootOption->DebugType=IDO_RBNO;
                    while (*pCh && *pCh!=' ') {
                                *pCh=' ';
                                pCh++;
                    }
                }
                break;

            default:
                ;
        }
        pCh++;
    }
    if (pBootOption->DebugType==-1) {
        pBootOption->DebugType=IDO_RBNO;
    }
    strcpy(tmpBuf, pBootOption->OtherOptions);
    pTok=strtok(tmpBuf, " ");
    pBootOption->OtherOptions[0]='\0';
    if (pTok) {
        do {
            strcat(pBootOption->OtherOptions, pTok);
            strcat(pBootOption->OtherOptions, " ");
            pTok=strtok(NULL, " ");
        } while (pTok!=NULL);
    }
}

//////////////////////////////////////////////////////////
//
// GetBootOptions() reads the boot options from boot.ini
// or NVRAM.
//
// Based on system applet.
//
//////////////////////////////////////////////////////////
BOOL
GetBootOptions()
{
    TCHAR   szTemp[MAX_PATH];
    TCHAR  *pszKeyName;
    TCHAR  *bBuffer;
    int     i, n;

    //  Get some memory for strings

    pszKeyName = (TCHAR *) AllocMem (BUFZ);

    bBuffer = (TCHAR *) AllocMem (BUFZ);

    if ( NULL == pszKeyName || NULL == bBuffer ) {
        return FALSE;
    }

    if ( IsAlpha || Is_ARCx86() ) {
        ////////////////////////////////////////////////////////////////////
        //  Read info from NVRAM environment variables
        ////////////////////////////////////////////////////////////////////

        fCanUpdateNVRAM = FALSE;
        if ( hmodSetupDll = LoadLibrary(TEXT("setupdll")) ) {
            if ( fpGetNVRAMvar = (GETNVRAMPROC)GetProcAddress(hmodSetupDll, "GetNVRAMVar") ) {
                if ( fCanUpdateNVRAM = GetRGSZEnvVar (&CPEBOSLoadIdentifier, "LOADIDENTIFIER") ) {
                    GetRGSZEnvVar (&CPEBOSLoadOptions,"OSLOADOPTIONS");
                    GetRGSZEnvVar (&CPEBOSLoadPaths, "OSLOADFILENAME");
                    NumBootOptions = CPEBOSLoadIdentifier.cEntries;
                    for ( i = 0; i < CPEBOSLoadIdentifier.cEntries; i++ ) {
                        strcpy(BootOptions[i].Identifier, CPEBOSLoadIdentifier.pszVars[i]);
                        if ( i<CPEBOSLoadPaths.cEntries ) {
                            strcpy(BootOptions[i].Path, CPEBOSLoadPaths.pszVars[i]);
                        } else {
                            BootOptions[i].Path[0]='\0';
                        }
                        if ( i<CPEBOSLoadOptions.cEntries ) {
                            strcpy(BootOptions[i].OtherOptions, CPEBOSLoadOptions.pszVars[i]);
                        } else {
                            BootOptions[i].OtherOptions[0]='\0';
                        }
                        BootOptions[i].DebugPort=-1;
                        BootOptions[i].BaudRate=-1;
                        BootOptions[i].DebugType=-1;
                        BootOptions[i].Modified=FALSE;
                        _strlwr(BootOptions[i].OtherOptions);
                        ParseBootOption(&(BootOptions[i]));
                        if ( -1==BootOptions[i].DebugType ) {
                            BootOptions[i].DebugType=IDO_RBNO;
                        }
                    }
                    Curr_Munge.BootIndex=0;
                } else {
                    return FALSE;
                }
            }
            FreeLibrary (hmodSetupDll);
        }
    } else {
        //
        // Find System Partition for boot.ini
        //
        szBootIni[0]=x86DetermineSystemPartition( NULL );

        //
        // Change attributes on boot.ini
        //
        if ( !SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL) ) {
            if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
                CHAR DriveString[105];
                CHAR *DrivePointer = DriveString;

                GetLogicalDriveStrings(104, DriveString);
                while ( DrivePointer[0] ) {
                    if ( (DrivePointer[0] == 'a')||(DrivePointer[0] == 'b')||
                         (DrivePointer[0] == 'A')||(DrivePointer[0] == 'B') ) {

                        DrivePointer += (strlen(DrivePointer) + 1);
                        continue;
                    }

                    szBootIni[0] = DrivePointer[0];

                    if ( SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL) )
                        break;

                    DrivePointer += (strlen(DrivePointer) + 1);
                }
            }
        }

        ////////////////////////////////////////////////////////////////////
        //  Read info from boot.ini file and initialize OS Group box items
        ////////////////////////////////////////////////////////////////////

        //
        //  Get correct Boot Drive - this was added because after someone
        //  boots the system, they can ghost or change the drive letter
        //  of their boot drive from "c:" to something else.
        //
        // (not worth it for this util)
        //
        //szBootIni[0] = GetBootDrive();
        //
        //
        //  Determine which section [boot loader]
        //                          [flexboot]
        //                       or [multiboot] is in file
        //

        n = GetPrivateProfileString (szBootLdr, NULL, NULL, szTemp,
                                     sizeof(szTemp), szBootIni);
        if ( n != 0 )
            pszBoot = szBootLdr;
        else {
            n = GetPrivateProfileString (szFlexBoot, NULL, NULL, szTemp,
                                         sizeof(szTemp), szBootIni);
            if ( n != 0 )
                pszBoot = szFlexBoot;
            else
                pszBoot = szMultiBoot;
        }

        //  Get info under [*pszBoot] section - timeout & default OS path

        GetPrivateProfileString (pszBoot, szDefault, NULL, szTemp,
                                 sizeof(szTemp), szBootIni);

        //  Display all choices under [operating system] in boot.ini file
        //  in combobox for selection

        GetPrivateProfileString (szOS, NULL, NULL, pszKeyName, BUFZ, szBootIni);

        Curr_Munge.BootIndex = -1;

        while ( *pszKeyName ) {
            // fix to make sure we don't overshoot our array
            if ( NumBootOptions >= MAX_BOOT_OPTIONS ) {
                MessageBox(NULL, "You Have Surpassed The Maximum Number of Boot Options"
                           "Supported by this Utility.\nPlease Cleanup your Boot.ini!\n"
                           "The utility will continue but may not configure your machine correctly.",
                           "Excessive Boot Options", MB_OK|MB_ICONWARNING);
                break;
            }

            // Get display string for each key name

            GetPrivateProfileString (szOS, pszKeyName, NULL, bBuffer, BUFZ, szBootIni);

#ifndef UNICODE
            // Convert Oem to Ansi, since the boot.ini file is an OEM file.
            OemToChar(bBuffer, bBuffer);
#endif

            lstrcpy(BootOptions[NumBootOptions].Identifier, (bBuffer[0] == TEXT('\0') ? pszKeyName : bBuffer));
            {
                char *endOfName;
                if ( endOfName=strchr(BootOptions[NumBootOptions].Identifier+1, '"') ) {
                    endOfName++;
                    strcpy(BootOptions[NumBootOptions].OtherOptions, endOfName);
                    _strlwr(BootOptions[NumBootOptions].OtherOptions);
                    *endOfName='\0';
                }
            }

            //
            // Put quotes around identifier if it doesn't have 'em
            //
            if ( '"'!=BootOptions[NumBootOptions].Identifier[0] ) {
                sprintf(bBuffer, "\"%s\"",BootOptions[NumBootOptions].Identifier);
                strcpy(BootOptions[NumBootOptions].Identifier, bBuffer);
            }

            // Find the "default" selection

            if ( !lstrcmp (pszKeyName, szTemp) )
                Curr_Munge.BootIndex = NumBootOptions;

            // Also attach pointer to KeyName (i.e. boot path) to each item

            lstrcpy(BootOptions[NumBootOptions].Path, pszKeyName);

            // Get next unique KeyName

            do {
                DWORD j;
                pszKeyName += lstrlen (pszKeyName) + 1;
                if ( *pszKeyName==TEXT('\0') ) break;
                for ( j=0;j<=NumBootOptions;j++ ) {
                    if ( !strcmp(pszKeyName, BootOptions[j].Path) ) {
                        break;
                    }
                }
                if ( j>NumBootOptions ) break;
            } while ( 1 );
            BootOptions[NumBootOptions].DebugPort=-1;
            BootOptions[NumBootOptions].BaudRate=-1;
            BootOptions[NumBootOptions].DebugType=-1;
            BootOptions[NumBootOptions].Modified=FALSE;
            ParseBootOption(&(BootOptions[NumBootOptions]));
            NumBootOptions++;
        }

    }
    // If no selection was found up to this point, choose 0, because
    // that is the default value that loader would choose.
    if ( Curr_Munge.BootIndex == -1 ) {
        Curr_Munge.BootIndex = 0;
    }
    Curr_Munge.BootOption=BootOptions[Curr_Munge.BootIndex].DebugType;
#if 0
    if ( BootOptions[Curr_Munge.BootIndex].OtherOptions != NULL ) {
        _strlwr(BootOptions[Curr_Munge.BootIndex].OtherOptions);
    }
    if ( BootOptions[Curr_Munge.BootIndex].OtherOptions != NULL &&
         strstr(BootOptions[Curr_Munge.BootIndex].OtherOptions, "debug") ) {
        BootOptions[Curr_Munge.BootIndex].DebugType=IDO_RBDEBUG;
        Curr_Munge.BootOption=IDO_RBDEBUG;
    }
    if ( BootOptions[Curr_Munge.BootIndex].OtherOptions != NULL &&
         strstr(BootOptions[Curr_Munge.BootIndex].OtherOptions, "crash") ) {
        BootOptions[Curr_Munge.BootIndex].DebugType=IDO_RBCRASH;
        Curr_Munge.BootOption=IDO_RBCRASH;
    }
    if ( BootOptions[Curr_Munge.BootIndex].OtherOptions != NULL &&
         strstr(BootOptions[Curr_Munge.BootIndex].OtherOptions, "nodebug") ) {
        BootOptions[Curr_Munge.BootIndex].DebugType=IDO_RBNO;
        Curr_Munge.BootOption=IDO_RBNO;
    }
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////
//
// SetBootOptions() writes the boot options to boot.ini
// or NVRAM.
//
//////////////////////////////////////////////////////////
BOOL
SetBootOptions()
{
    int d=Curr_Munge.BootIndex;
    if ( -1!=BootOptions[d].DebugPort ) {
        WriteProfileString("munger", "port", _itoa(BootOptions[d].DebugPort, itoabuf, 10));
    }
    if ( -1!=BootOptions[d].BaudRate ) {
        WriteProfileString("munger", "baud", _itoa(BootOptions[d].BaudRate, itoabuf, 10));
    }
    if ( IsAlpha || Is_ARCx86() ) {
        return UpdateNVRAM(Curr_Munge.BootIndex,
                           Orig_Munge.BootOption,
                           Curr_Munge.BootOption);
    } else {
        if ( Orig_Munge.BootIndex!=Curr_Munge.BootIndex ) {
            WritePrivateProfileString (pszBoot, szDefault, BootOptions[d].Path, szBootIni);
        }
        if ( ChangedBootOptions ) {
            char BigBuf[4096]="";
            char *bptr=BigBuf;
            DWORD i;
            for ( i=0;i<NumBootOptions;i++ ) {
                if ( BootOptions[i].Modified ) {
                    bptr=BigBuf;
                    *bptr='\0';
                    strcat(bptr, BootOptions[i].Identifier);
                    strcat(bptr, " ");
                    if ( BootOptions[i].OtherOptions[0] ) {
                        strcat(bptr, BootOptions[i].OtherOptions);
                    }
                    switch ( BootOptions[i].DebugType ) {
                    case IDO_RBNO:
                        strcat(bptr, " /NODEBUG");
                        break;

                    case IDO_RBDEBUG:
                        strcat(bptr, " /DEBUG");
                        break;

                    case IDO_RBCRASH:
                        strcat(bptr, " /CRASHDEBUG");
                        break;

                    default:
                        break;
                    }
                    if ( -1!=BootOptions[i].DebugPort ) {
                        strcat(bptr, " /DEBUGPORT=COM");
                        strcat(bptr, _itoa(BootOptions[i].DebugPort, itoabuf, 10));
                    }
                    if ( -1!=BootOptions[i].BaudRate ) {
                        strcat(bptr, " /BAUDRATE=");
                        strcat(bptr, _itoa(BootOptions[i].BaudRate, itoabuf, 10));
                    }
                    WritePrivateProfileString(szOS, BootOptions[d].Path, BigBuf, szBootIni);
                }
            }
        }

        return TRUE;
    }
}

#define WINLOGON_EXECUTION_OPTIONS TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\winlogon.exe")
#define WINLOGON_DEBUG_STRING   TEXT("ntsd -d -g")
#define WINLOGON_GLOBAL_FLAG(x)     (x?TEXT("0x000400f0"):TEXT("0x08A00008"))

///////////////////////////////////////////////////////////////
//
// GetDebugWinlogon() checks if the registry key to debug
// winlogon.exe exists.
//
///////////////////////////////////////////////////////////////

BOOL
GetDebugWinLogon()
{
    HKEY hkResult;
    if (Curr_Munge.DebugWinlogon =
       (ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
                         WINLOGON_EXECUTION_OPTIONS,
                         &hkResult))) {
        RegCloseKey(hkResult);
    }
    return TRUE;

}

///////////////////////////////////////////////////////////////
//
// SetDebugWinlogon() sets the registry to debug winlogon.exe
// (only if ntsd and friends are in path)
//
///////////////////////////////////////////////////////////////
BOOL
SetDebugWinLogon()
{

  SECURITY_ATTRIBUTES SecurityAttributes;
  HKEY hkResult;
  DWORD Disp;
  LONG Result;
  SECURITY_DESCRIPTOR sd;

  if (Orig_Munge.DebugWinlogon==Curr_Munge.DebugWinlogon) {
      return TRUE;
  }

  if (Curr_Munge.DebugWinlogon)
  {
	if (OsVersion.dwMajorVersion <= 4)
	{
    	    while ((0==SearchPath(NULL, "ntsd.exe", NULL, 0, NULL, NULL)) ||
           	(0==SearchPath(NULL, "imagehlp.dll", NULL, 0, NULL, NULL)) ||
           	(0==SearchPath(NULL, "ntsdexts.dll", NULL, 0, NULL, NULL)) /* ||
           	(0==SearchPath(NULL, "userexts.dll", NULL, 0, NULL, NULL))*/ )
	    {
            	if (IDCANCEL==MessageBox(NULL, "Unable to find ntsd.exe, imagehlp.dll, "
                                 "ntsdexts.dll or userexts.dll.  Please copy "
                                 "them into your path and press Retry, or press "
                                 "Cancel to not debug winlogon.",
                                 "Can't Find Debugger",
                                 MB_RETRYCANCEL))
            	{
            	    return FALSE;
            	}
            }
	}
	else
	{
    	    while ((0==SearchPath(NULL, "ntsd.exe", NULL, 0, NULL, NULL)) ||
           	(0==SearchPath(NULL, "dbghelp.dll", NULL, 0, NULL, NULL)) ||
               (0==SearchPath(NULL, "ntsdexts.dll", NULL, 0, NULL, NULL)) ||
               (0==SearchPath(NULL, "userexts.dll", NULL, 0, NULL, NULL))) {

            	if (IDCANCEL==MessageBox(NULL, "Unable to find ntsd.exe, dbghelp.dll, "
                                 "ntsdexts.dll or userexts.dll.  Please copy "
                                 "them into your path and press Retry, or press "
                                 "Cancel to not debug winlogon.",
                                 "Can't Find Debugger",
                                     MB_RETRYCANCEL)) {
            	    return FALSE;
		}
            }
        }
    InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );

    SecurityAttributes.nLength = sizeof( SECURITY_ATTRIBUTES );
    SecurityAttributes.lpSecurityDescriptor = &sd;
    SecurityAttributes.bInheritHandle = FALSE;

    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                             WINLOGON_EXECUTION_OPTIONS,
                             0,
                             TEXT("REG_SZ"),
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             &SecurityAttributes,
                             &hkResult,
                             &Disp
                             );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to create registry key for winlogon debugging.", "Registry Failure", MB_OK);
        return FALSE;
    }

    //
    // Add values for Debugger and WINLOGON_GLOBAL_FLAG
    //

    Result = RegSetValueEx( hkResult,
                            TEXT("Debugger"),
                            0,
                            REG_SZ,
                            WINLOGON_DEBUG_STRING,
                            lstrlen(WINLOGON_DEBUG_STRING)
                            );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to set registry key for winlogon debugging.", "Registry Failure", MB_OK);
            RegCloseKey(hkResult);
        return FALSE;
    }

    Result = RegSetValueEx( hkResult,
                            TEXT("GLOBAL_FLAG"),
                            0,
                            REG_SZ,
                            WINLOGON_GLOBAL_FLAG(UseNewFlags),
                            lstrlen(WINLOGON_GLOBAL_FLAG(UseNewFlags))
                            );

        if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to set registry key for winlogon debugging.", "Registry Failure", MB_OK);
            RegCloseKey(hkResult);
        return FALSE;
    }
        RegCloseKey(hkResult);
    return TRUE;
  } else {
    return (ERROR_SUCCESS != RegDeleteKey (HKEY_LOCAL_MACHINE, WINLOGON_EXECUTION_OPTIONS));

  }
}

#define AEDEBUG_OPTIONS         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define AEDEBUG_AUTO_STRING     TEXT("1")
#define AEDEBUG_DEBUGGER_STRING TEXT("ntsd -d -p %ld -e %ld -g -x -xd ip")
#define AEDEBUG_WINDOWS_CONTROL TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows")
#define AEDEBUG_ERROR_MODE      TEXT("0x00000002")
///////////////////////////////////////////////////////////////
//
// SetAeDebug() sets the registry for auto-enabled debugging
// (only if ntsd and friends are in path)
//
///////////////////////////////////////////////////////////////
BOOL SetAeDebug()
{

  SECURITY_ATTRIBUTES SecurityAttributes;
  HKEY hkResult;
  DWORD Disp;
  LONG Result;
  SECURITY_DESCRIPTOR sd;

    while ((0==SearchPath(NULL, "ntsd.exe", NULL, 0, NULL, NULL)) ||
       (0==SearchPath(NULL, "imagehlp.dll", NULL, 0, NULL, NULL)) ||
       (0==SearchPath(NULL, "ntsdexts.dll", NULL, 0, NULL, NULL)) /* ||
       (0==SearchPath(NULL, "userexts.dll", NULL, 0, NULL, NULL)) */ ) {

        //
        // If not quiet, then pop this up. NT4 does not get this stuff by default so quiet
        // the noise.
        //
        if ( Quiet ||
             IDCANCEL==MessageBox(NULL,
                                 "Unable to find ntsd.exe, imagehlp.dll, "
                                 "or ntsdexts.dll.  Please copy them into "
                                 "your path and press Retry, or press "
                                 "Cancel to not set AeDebug.",
                                 "Can't Find Debugger",
                                 MB_RETRYCANCEL)) {
            return FALSE;
        }
    }
    InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );

    SecurityAttributes.nLength = sizeof( SECURITY_ATTRIBUTES );
    SecurityAttributes.lpSecurityDescriptor = &sd;
    SecurityAttributes.bInheritHandle = FALSE;

    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                             AEDEBUG_OPTIONS,
                             0,
                             TEXT("REG_SZ"),
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             &SecurityAttributes,
                             &hkResult,
                             &Disp
                             );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to create registry key for AeDebugging.", "Registry Failure", MB_OK);
        return FALSE;
    }

    //
    // Add values for Debugger and Auto
    //

    Result = RegSetValueEx( hkResult,
                            TEXT("Auto"),
                            0,
                            REG_SZ,
                            AEDEBUG_AUTO_STRING,
                            lstrlen(AEDEBUG_AUTO_STRING)
                            );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to set registry key 'auto' for AeDebugging.", "Registry Failure", MB_OK);
        CloseHandle(hkResult);
        return FALSE;
    }

    Result = RegSetValueEx( hkResult,
                            TEXT("Debugger"),
                            0,
                            REG_SZ,
                            AEDEBUG_DEBUGGER_STRING,
                            lstrlen(AEDEBUG_DEBUGGER_STRING)
                            );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to set registry key 'debugger' for AeDebugging.", "Registry Failure", MB_OK);
        CloseHandle(hkResult);
        return FALSE;
    }
    CloseHandle(hkResult);

    Result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                             AEDEBUG_WINDOWS_CONTROL,
                             0,
                             TEXT("REG_DWORD"),
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             &SecurityAttributes,
                             &hkResult,
                             &Disp
                             );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to create registry key for Windows Control.", "Registry Failure", MB_OK);
        return FALSE;
    }

    //
    // Add values for ErrorMode
    //

    Result = RegSetValueEx( hkResult,
                            TEXT("ErrorMode"),
                            0,
                            REG_DWORD,
                            AEDEBUG_ERROR_MODE,
                            lstrlen(AEDEBUG_ERROR_MODE)
                            );

    if ( Result != ERROR_SUCCESS ) {
        MessageBox(NULL, "Unable to set registry key 'auto' for AeDebugging.", "Registry Failure", MB_OK);
        CloseHandle(hkResult);
        return FALSE;
    }

    return TRUE;
}

//
//
//
void SetSpecialTag(
                    DWORD dwPoolTag,
                    PDWORD pPoolTag,
                    PDWORD pPoolTagOverruns
                    )
{
    DWORD    rgwTable[10] = {-2, -2, -2, -2, -2, -2, -2, -1, 0, 0 };
    time_t  timeval = 0;

    //
    // Set randomization seed and get possible timeout value
    //
    time(&timeval);
    srand((DWORD)timeval);

    //
    // Someone already specified a PoolTag (i.e., LSwn), so leave it.
    //
    if ( *pPoolTag > PAGE_SIZE ) {
        return;
    }

    //
    // Someone already specified an allocation size to watch, so leave it.
    //
    if ( (*pPoolTag / 0x20) > 0 ) {
        return;
    }

    //
    // Specified pooltag from command line
    //
    if ( dwPoolTag != 0 ) {
        *pPoolTag = dwPoolTag;
        return;
    }

    //
    // Pick a value
    //
    *pPoolTag = rgwTable[(WORD)rand() % 10];

    //
    // Set PoolTagOverruns tag
    //
    *pPoolTagOverruns = (WORD)rand() % 10 < 2 ? POOL_UNDERRUNS : POOL_OVERRUNS;

}

void SetPreferredBoot()
{
    BOOT_OPTION tmpBoot=BootOptions[Curr_Munge.BootIndex];
    tmpBoot.DebugType=PREF_BOOT;
    tmpBoot.DebugPort=DEFAULT(tmpBoot.DebugPort, GetProfileInt("munger", "port", -1));
    tmpBoot.BaudRate =DEFAULT(tmpBoot.BaudRate,  GetProfileInt("munger", "baud", -1));
    if (tmpBoot.DebugType!=BootOptions[Curr_Munge.BootIndex].DebugType ||
        tmpBoot.DebugPort!=BootOptions[Curr_Munge.BootIndex].DebugPort ||
        tmpBoot.BaudRate !=BootOptions[Curr_Munge.BootIndex].BaudRate) {
        ChangedBootOptions=tmpBoot.Modified=TRUE;
        BootOptions[Curr_Munge.BootIndex]=tmpBoot;
    }
}

/////////////////////////////////////////////////////////////////////
//
// SetPreferred() sets the preferred stress settings.
//
/////////////////////////////////////////////////////////////////////
void SetPreferred()
{
    Curr_Munge.CrashDumpEnabled=TRUE;
#ifdef LOADIMM
    Curr_Munge.LoadIMM=TRUE;
#endif // LOADIMM
    Curr_Munge.BootOption=PREF_BOOT;
    Curr_Munge.AutoReboot=FALSE;
    Curr_Munge.GlobalFlag=(UseNewFlags?Curr_Munge.GlobalFlag|CSR_FLAG(UseNewFlags):Curr_Munge.GlobalFlag&~CSR_FLAG(UseNewFlags));
    Curr_Munge.GlobalFlag|=POOL_FLAG(UseNewFlags);
    Curr_Munge.GlobalFlag|=OBJECT_FLAG(UseNewFlags);
    //Curr_Munge.GlobalFlag|=HANDLE_FLAG(BuildNumber>1057);
    Curr_Munge.CritSectTimeout=PREF_CSR_TIMEOUT;
    Curr_Munge.ResourceTimeout=PREF_TIMEOUT;
#ifdef FESTRESS
    //
    // If the locale is set with the command line, this is "Preferred Locale".
    //
    if (bLCSet == TRUE) Curr_Munge.nLCIndex = nLCIndex;
#endif // FESTRESS
    SetPreferredBoot();
}

/////////////////////////////////////////////////////////////////////
//
// GetValues() reads current state from registry/boot.ini into vars
//
/////////////////////////////////////////////////////////////////////
BOOL
GetValues()
{
    HKEY    hKeySessMan;
    HKEY    hKeyCrash;
    HKEY    hKeyIMM;
    HKEY    hKeyLC;
    DWORD   SzData;
    TCHAR   *szBuff;
    DWORD   TypeOfData;
    DWORD   dwTemp;
    BOOL    retval;
    int     i;
    TCHAR   szBuff_Buff[64];
    LCID    lcUserLCID;

    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   "System\\CurrentControlSet\\Control\\Session Manager",
                   &hKeySessMan)) {
        return FALSE;
    }
    TypeOfData=REG_DWORD;
    SzData=sizeof(DWORD);
    if ((ERROR_SUCCESS!=RegQueryValueEx(hKeySessMan, (LPTSTR) "GlobalFlag", NULL, &TypeOfData, (LPBYTE)&Curr_Munge.GlobalFlag, &SzData)) ||
        (ERROR_SUCCESS!=RegQueryValueEx(hKeySessMan, (LPTSTR) "CriticalSectionTimeout", NULL, &TypeOfData, (LPBYTE)&Curr_Munge.CritSectTimeout, &SzData)) ||
        (ERROR_SUCCESS!=RegQueryValueEx(hKeySessMan, (LPTSTR) "ResourceTimeoutCount", NULL, &TypeOfData, (LPBYTE)&Curr_Munge.ResourceTimeout, &SzData)) ||
        ((IsAlpha && (retval=RegQueryValueEx(hKeySessMan, (LPTSTR) "EnableAlignmentFaultExceptions", NULL, &TypeOfData, (LPBYTE)&Curr_Munge.Alignment, &SzData))) &&
         (ERROR_SUCCESS!=retval) &&
         (ERROR_FILE_NOT_FOUND!=retval))
            ) {
        RegCloseKey(hKeySessMan);
        return FALSE;
    }
    RegCloseKey (hKeySessMan);

    //
    // Now get the Memory Manager PoolTag
    //
    if (ERROR_SUCCESS==
        RegOpenKey(HKEY_LOCAL_MACHINE,
                    "System\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
                    &hKeySessMan
                   )) {
        TypeOfData=REG_DWORD;
        SzData=sizeof(DWORD);
        RegQueryValueEx(
                    hKeySessMan,
                    "PoolTag",
                    NULL,
                    &TypeOfData,
                    (LPBYTE)&Curr_Munge.PoolTag,
                    &SzData
                    );
    }
    RegCloseKey (hKeySessMan);

    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   "System\\CurrentControlSet\\Control\\CrashControl",
                   &hKeyCrash)) {
        return FALSE;
    }
    TypeOfData=REG_DWORD;
    SzData=sizeof(DWORD);
    if (ERROR_SUCCESS!=RegQueryValueEx(hKeyCrash, "CrashDumpEnabled", NULL, &TypeOfData, (LPBYTE)&dwTemp, &SzData)) {
        RegCloseKey(hKeyCrash);
        return FALSE;
    }
    Curr_Munge.CrashDumpEnabled=(dwTemp!=0);
    if (ERROR_SUCCESS!=RegQueryValueEx(hKeyCrash, "AutoReboot", NULL, &TypeOfData, (LPBYTE)&dwTemp, &SzData)) {
        RegCloseKey(hKeyCrash);
        return FALSE;
    }
    RegCloseKey(hKeyCrash);

    Curr_Munge.AutoReboot=(dwTemp!=0);
    GetDebugWinLogon();
    retval = GetBootOptions();

#ifdef LOADIMM
    // Get IMM loading info
    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   IMMKEY,
                   &hKeyIMM)) {
        Curr_Munge.LoadIMM = FALSE;
       // return FALSE;
    }
    TypeOfData=REG_DWORD;
    SzData=sizeof(DWORD);
    dwTemp = 0;
    if (ERROR_SUCCESS!=RegQueryValueEx(hKeyIMM, IMMLOAD, NULL, &TypeOfData, (LPBYTE)&dwTemp, &SzData)) {
       RegCloseKey(hKeyIMM);
        Curr_Munge.LoadIMM = FALSE;
    //    return FALSE;
    }
    Curr_Munge.LoadIMM=(dwTemp!=0);
    RegCloseKey(hKeyIMM);
#endif // LOADIMM

    // Get CodePage Info
    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   LANGKEY,
                   &hKeyLC)) {
        return FALSE;
    }
    TypeOfData = REG_SZ;
    if (ERROR_SUCCESS!=RegQueryValueEx(hKeyLC, "Default", NULL, &TypeOfData, (LPBYTE)NULL, &SzData)) {
        RegCloseKey(hKeyLC);
        return FALSE;
    }
    szBuff = (LPBYTE)malloc(SzData);
    if (szBuff == NULL) {
        RegCloseKey(hKeyLC);
         return FALSE;
    }
    memset( szBuff, 0, SzData);

    if (ERROR_SUCCESS!=RegQueryValueEx(hKeyLC, "Default", NULL, &TypeOfData, szBuff, &SzData)) {
        RegCloseKey(hKeyLC);
        return FALSE;
    }
    RegCloseKey(hKeyLC);

    //
    // Old: szBuff holds System LocalID
    // New: szBuff holds User LocalID.
    //
    // The old source ource code about RegQueryValueEx can be cleaned up,
    // but I don't do it, just make the minimun changes for easy diff.
    // -- YuhongLi.
    //
    if (szBuff != NULL) {
        free(szBuff);
    }
    szBuff = szBuff_Buff;
    if ((lcUserLCID = GetUserDefaultLCID()) == 0) {
        // never here.
        return (FALSE);
    }
    sprintf(szBuff, "0%x", lcUserLCID);

#ifdef FESTRESS
    for (i=0; i < NUM_LOCALE; i++) {
        //
        // The table Locale holds the upcase letter, but registry holds lower.
        // so use _stricmp here.
        //
        if (_stricmp(Locale[i].szID, szBuff) == 0) break;
    }

    if (i >= NUM_LOCALE) {
        //
        // the unkown locale in the list.
        //
        // If users launch munger with option "-l" to install LangPack,
        // tell them.  If it is just running munger without langapck option,
        // we won't let user feel any change, so we keep it compatible with
        // English munger verion.
        //
        if (bLCSet == TRUE) {
            MessageBox(NULL,
                TEXT("Your system locale has not been included in the list.\n")
                TEXT("We disable the function of setting locales.\n")
                TEXT("Please contact Stress Team if you want to add it."),
                TEXT("Munger Message"),
                MB_OK|MB_ICONINFORMATION);
        }
        //
        // As the message reads, we still continue, but disable it.
        //
        fDisableLocale = TRUE;
        i = DEFAULT_ENGLISH_INDEX;
    }

    //
    // set the original default LCID to the initial value.
    // It may be changed if user clicks Preferred or selects in locale list.
    //
    Curr_Munge.nLCIndex = i;

    Orig_Munge=Curr_Munge;

    //
    // select LangPack passed from the command option such /w jpn.
    //
    if (bLCSet == TRUE) {
        Curr_Munge.nLCIndex = nLCIndex;
    }
#else
    for (i=0;i<NUM_LOCALE;i++)
        if (strcmp(Locale[i].szID, szBuff) == 0) break;
    // if no cmdline locale setting or the original locale is one of the FE ones
    if (!bLCSet) Curr_Munge.nLCIndex = i;

    Orig_Munge=Curr_Munge;
    Orig_Munge.nLCIndex = i;    //set origianl LCID to current system default locale
#endif // FESTRESS

    if (Preferred) {
        SetPreferred();
    }

    if ( ChooseAeDebug )
    {
        SetAeDebug();
    }
    if (ChooseDebug)
    {
        Curr_Munge.BootOption = IDO_RBDEBUG;
        // Need to set this in order for cmd line options to be stored
        BootOptions[Curr_Munge.BootIndex].DebugType = IDO_RBDEBUG;
        ChangedBootOptions = BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
    }
    if (ChooseCSR) {
        Curr_Munge.GlobalFlag=(UseNewFlags?Curr_Munge.GlobalFlag|CSR_FLAG(UseNewFlags):Curr_Munge.GlobalFlag&~CSR_FLAG(UseNewFlags));
    }
    if (ChooseHeap) {
        Curr_Munge.GlobalFlag=(UseNewFlags?Curr_Munge.GlobalFlag|HEAP_FLAGS(UseNewFlags):Curr_Munge.GlobalFlag&~HEAP_FLAGS(UseNewFlags));
    }
    if (ChooseTagging) {
        Curr_Munge.GlobalFlag|=POOL_FLAG(UseNewFlags);
    }
    if (ChooseObject) {
        Curr_Munge.GlobalFlag|=OBJECT_FLAG(UseNewFlags);
    }
    if (ChooseHandle) {
        Curr_Munge.GlobalFlag|=HANDLE_FLAG(BuildNumber>1057);
    }
    if ( ChooseSpecial ) {
#ifdef POOL_TRACK
        FILE *PoolFile;
        char rgTrackPool[256];
        char CompName[32];
        DWORD dwLength;
#endif
        SetSpecialTag(
                  PoolTag,
                  &Curr_Munge.PoolTag,
                  &Curr_Munge.PoolTagOverruns
                  );

#ifdef POOL_TRACK
        GetComputerName(
                    CompName,
                    &dwLength
                    );
        sprintf(rgTrackPool,
                "\\\\NTStress\\TrackDbg\\Pool\\%s",
                CompName
                );
        PoolFile = fopen(rgTrackPool, "w" );
        if ( PoolFile ) {
            fprintf(PoolFile,
                    "%s, %li, %li\n",
                    CompName,
                    Orig_Munge.PoolTag,
                    Curr_Munge.PoolTag
                    );
            fclose(PoolFile);
        }
#endif
    }
    if ( ChooseCommPort ) {
        BootOptions[Curr_Munge.BootIndex].DebugPort = dwCommPort;
        ChangedBootOptions = BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
    }
    if ( ChooseBaudRate ) {
        BootOptions[Curr_Munge.BootIndex].BaudRate = BaudRate;
        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
    }

    return retval;
}

/////////////////////////////////////////////////////////////////////
//
// SetValues() writes current state to registry/boot.ini from vars
//
/////////////////////////////////////////////////////////////////////
BOOL
SetValues()
{
    HKEY    hKeySessMan;
    HKEY    hKeyi8042prt;
    HKEY    hKeyLCID;
    HKEY    hKeyIMM;
    DWORD   SzData;
    DWORD   TypeOfData;
    DWORD   dwDisp;
    int     nData;

    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   "System\\CurrentControlSet\\Control\\Session Manager",
                   &hKeySessMan)) {
        return FALSE;
    }
    TypeOfData=REG_DWORD;
    SzData=sizeof(DWORD);
    if ((ERROR_SUCCESS!=RegSetValueEx(hKeySessMan, (LPCTSTR)"GlobalFlag", 0, TypeOfData, (LPCTSTR)&Curr_Munge.GlobalFlag, SzData)) ||
        (ERROR_SUCCESS!=RegSetValueEx(hKeySessMan, (LPCTSTR)"CriticalSectionTimeout", 0, TypeOfData, (LPCTSTR)&Curr_Munge.CritSectTimeout, SzData)) ||
        (ERROR_SUCCESS!=RegSetValueEx(hKeySessMan, (LPCTSTR)"ResourceTimeoutCount", 0, TypeOfData, (LPCTSTR)&Curr_Munge.ResourceTimeout, SzData)) ||
        (IsAlpha && (ERROR_SUCCESS!=RegSetValueEx(hKeySessMan, (LPCTSTR)"EnableAlignmentFaultExceptions", 0, TypeOfData, (LPCTSTR)&Curr_Munge.Alignment, SzData)))
            ) {
        RegCloseKey(hKeySessMan);
        return FALSE;
    }
    RegCloseKey (hKeySessMan);

    //
    // Set Memory Manager PoolTag
    //
    if ( ChooseSpecial ) {
        if (ERROR_SUCCESS!=
            RegOpenKey(HKEY_LOCAL_MACHINE,
                       "System\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
                       &hKeySessMan)) {
            return FALSE;
        }
        TypeOfData=REG_DWORD;
        SzData=sizeof(DWORD);
        if ((ERROR_SUCCESS!=RegSetValueEx(
                                        hKeySessMan,
                                        (LPCTSTR)"PoolTag",
                                        0,
                                        TypeOfData,
                                        (LPCTSTR)&Curr_Munge.PoolTag,
                                        SzData))
                ) {
            RegCloseKey(hKeySessMan);
            return FALSE;
        }
        TypeOfData=REG_DWORD;
        SzData=sizeof(DWORD);
        if ((ERROR_SUCCESS!=RegSetValueEx(
                                        hKeySessMan,
                                        (LPCTSTR)"PoolTagOverruns",
                                        0,
                                        TypeOfData,
                                        (LPCTSTR)&Curr_Munge.PoolTagOverruns,
                                        SzData))
                ) {
            RegCloseKey(hKeySessMan);
            return FALSE;
        }
        RegCloseKey (hKeySessMan);
    }

    //
    // Set SCROLL-LOCK Crash Dumping.
    //
    if ( ERROR_SUCCESS!= RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      "System\\CurrentControlSet\\Services\\i8042prt\\Parameters",
                                      0,
                                      KEY_WRITE,
                                      &hKeyi8042prt) ) {
        return FALSE;
    }
    TypeOfData=REG_DWORD;
    SzData=sizeof(DWORD);
    nData = 1;
    if ( (ERROR_SUCCESS!=RegSetValueEx(
                                      hKeyi8042prt,
                                      (LPCTSTR)"CrashOnCtrlScroll",
                                      0,
                                      TypeOfData,
                                      (LPCTSTR)&nData,
                                      SzData)) ) {
        RegCloseKey(hKeyi8042prt);
        return FALSE;
    }
    RegCloseKey (hKeyi8042prt);


    if ((Orig_Munge.CrashDumpEnabled != Curr_Munge.CrashDumpEnabled) ||
        (Orig_Munge.AutoReboot != Curr_Munge.AutoReboot)) {
        HKEY hKeyCrash;
        DWORD dwZero=0, dwOne=1;
        if (ERROR_SUCCESS!=
            RegOpenKey(HKEY_LOCAL_MACHINE,
                       "System\\CurrentControlSet\\Control\\CrashControl",
                       &hKeyCrash)) {
            return FALSE;
        }
        if (Curr_Munge.CrashDumpEnabled) {
            TypeOfData=REG_DWORD;
            SzData=sizeof(DWORD);
            if ((ERROR_SUCCESS!=RegSetValueEx(hKeyCrash, (LPCTSTR)"CrashDumpEnabled", 0, TypeOfData, (LPCTSTR)&dwOne, SzData)) ||
                (ERROR_SUCCESS!=RegSetValueEx(hKeyCrash, (LPCTSTR)"Overwrite", 0, TypeOfData, (LPCTSTR)&dwOne, SzData))
                ) {
                RegCloseKey(hKeyCrash);
                return FALSE;
            }
            TypeOfData=REG_EXPAND_SZ;
            if (ERROR_SUCCESS!=RegSetValueEx(hKeyCrash, (LPCTSTR)"DumpFile", 0, TypeOfData, (LPCTSTR)CRASH_DUMP_FILE, strlen(CRASH_DUMP_FILE)+1)) {
               RegCloseKey(hKeyCrash);
                return FALSE;
            }
        } else {
            if (ERROR_SUCCESS!=RegSetValueEx(hKeyCrash, (LPCTSTR)"CrashDumpEnabled", 0, TypeOfData, (LPCTSTR)&dwZero, SzData)) {
                RegCloseKey(hKeyCrash);
                return FALSE;
            }

        }
        TypeOfData=REG_DWORD;
        SzData=sizeof(DWORD);
        RegSetValueEx(hKeyCrash, (LPCTSTR)"AutoReboot", 0, TypeOfData, (LPCTSTR)(Curr_Munge.AutoReboot?&dwOne:&dwZero), SzData);
        RegCloseKey(hKeyCrash);
    }

#ifdef LOADIMM
    if (Curr_Munge.LoadIMM) {   // create a LoadIMM registry value
        if (ERROR_SUCCESS!=
            RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           IMMKEY,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKeyIMM,
                           &dwDisp)) {
             return FALSE;
        }
        TypeOfData=REG_DWORD;
        SzData=sizeof(DWORD);
        nData = Curr_Munge.LoadIMM?1:0;
        if (ERROR_SUCCESS !=
            RegSetValueEx(hKeyIMM, (LPCTSTR)IMMLOAD, 0, TypeOfData, (LPCTSTR)&nData, SzData))  {
            RegCloseKey(hKeyIMM);
            return FALSE;
        }

        // create a value to record if the LoadIMM value is changed
        nData = 1;
        if (ERROR_SUCCESS !=
            RegSetValueEx(hKeyIMM, (LPCTSTR)IMMCHANGE, 0, TypeOfData, (LPCTSTR)&nData, SzData)) {
            RegCloseKey(hKeyIMM);
            return FALSE;
        }
        RegCloseKey(hKeyIMM);
    }
#endif // LOADIMM

    // Create a registry key to record the original locale
    if (ERROR_SUCCESS!=
        RegOpenKey(HKEY_LOCAL_MACHINE,
                   LANGKEY,
                   &hKeyLCID)) {
        return FALSE;
    }

#ifdef FESTRESS

    // Install langpack
    // After we success to install LangPack, then set recovery Registry.
    if ((Curr_Munge.nLCIndex != Orig_Munge.nLCIndex) &&
        (fDisableLocale == FALSE)) {
        if (!InstallLPK(Curr_Munge.nLCIndex, TRUE)) {
            // LangPack is failed to install, e.g., stopped by user,
            // LangPack stuff is not ready and etc.
            // If we return FALSE, SetValue will be treated as failed and
            // will print out the error message like "Unable to write changes.
            // Logon with admin privileges to make changes.".  This confuses
            // users. So we just return TRUE.
            // return FALSE;
            return TRUE;
        }

        TypeOfData=REG_SZ;
        SzData=(DWORD)(1+lstrlen(Locale[Curr_Munge.nLCIndex].szID));
        if (ERROR_SUCCESS !=
                RegSetValueEx(hKeyLCID, (LPCTSTR)ORIGLC, 0, TypeOfData, (LPCTSTR)Locale[Orig_Munge.nLCIndex].szID, SzData)) {
            RegCloseKey(hKeyLCID);
            return FALSE;
        }
    }
    RegCloseKey(hKeyLCID);

#else

    TypeOfData = REG_SZ;
    SzData = (DWORD)(1+lstrlen(Locale[Curr_Munge.nLCIndex].szID));
    if (ERROR_SUCCESS !=
        RegSetValueEx(hKeyLCID, (LPCTSTR)ORIGLC, 0, TypeOfData, (LPCTSTR)Locale[Orig_Munge.nLCIndex].szID, SzData))
    {
        RegCloseKey(hKeyLCID);
        return FALSE;
    }
    RegCloseKey(hKeyLCID);

#endif // FESTRESS

    SetDebugWinLogon();
    return SetBootOptions();

}


/////////////////////////////////////////////////////////////////////
//
// GetDlgItems() sets vars based on dialog items.
//
/////////////////////////////////////////////////////////////////////
void
GetDlgItems (
             HWND hDlg
             )
{
    /*
    if (HSavePages[PROP_MISC]) {
        Curr_Munge.CritSectTimeout =
            GetDlgItemInt(HSavePages[PROP_MISC], IDO_CRITSECT, NULL,
            (Curr_Munge.CritSectTimeout?Curr_Munge.CritSectTimeout:PREF_CSR_TIMEOUT));
        Curr_Munge.ResourceTimeout =
            GetDlgItemInt(HSavePages[PROP_MISC], IDO_RESOURCE, NULL,
            (Curr_Munge.ResourceTimeout?Curr_Munge.ResourceTimeout:PREF_TIMEOUT));
    }
    */
}

/////////////////////////////////////////////////////////////////////
//
// SetDlgItems() sets dialog items based on vars.
//
/////////////////////////////////////////////////////////////////////
void
SetDlgItems (
             HWND hDlg
             )
{
    DWORD i;
    HWND hLocale;
    HWND hBoot=(HSavePages[PROP_BOOT]?GetDlgItem(HSavePages[PROP_BOOT], IDO_BOOT):NULL);

    if (HSavePages[PROP_FLAG]) {
        CheckDlgButton(HSavePages[PROP_FLAG], IDO_CSR,  (Curr_Munge.GlobalFlag &  CSR_FLAG(UseNewFlags) ? UseNewFlags: !UseNewFlags));
        CheckDlgButton(HSavePages[PROP_FLAG], IDO_HEAP, (Curr_Munge.GlobalFlag & HEAP_FLAGS(UseNewFlags)? UseNewFlags: !UseNewFlags));
        CheckDlgButton(HSavePages[PROP_FLAG], IDO_POOL, (Curr_Munge.GlobalFlag & POOL_FLAG(UseNewFlags) ? 1: 0));
        CheckDlgButton(HSavePages[PROP_FLAG], IDO_OBJECT, (Curr_Munge.GlobalFlag & OBJECT_FLAG(UseNewFlags) ? 1: 0));
        CheckDlgButton(HSavePages[PROP_FLAG], IDO_HANDLE, (Curr_Munge.GlobalFlag & HANDLE_FLAG(BuildNumber>1057) ? 1: 0));
    }
    if (HSavePages[PROP_MISC]) {
        CheckDlgButton(HSavePages[PROP_MISC], IDO_CRASHDUMP, (Curr_Munge.CrashDumpEnabled? 1: 0));
        CheckDlgButton(HSavePages[PROP_MISC], IDO_REBOOT, (Curr_Munge.AutoReboot? 1: 0));
        CheckDlgButton(HSavePages[PROP_MISC], IDO_WINLOGON, (Curr_Munge.DebugWinlogon? 1: 0));
        CheckDlgButton(HSavePages[PROP_MISC], IDO_ALIGN, (Curr_Munge.Alignment? 1:0));
#ifdef LOADIMM
        CheckDlgButton(HSavePages[PROP_MISC], IDC_LOADIMM, (Curr_Munge.LoadIMM? 1: 0));
#endif // LOADIMM
        SetDlgItemInt(HSavePages[PROP_MISC], IDO_CRITSECT, Curr_Munge.CritSectTimeout, 0);
        SetDlgItemInt(HSavePages[PROP_MISC], IDO_RESOURCE, Curr_Munge.ResourceTimeout, 0);
    }
    if (HSavePages[PROP_BOOT]) {
        if (0==SendMessage(hBoot, CB_GETCOUNT, 0, 0)) {
            for (i=0; i<NumBootOptions; i++) {
                SendMessage(hBoot, CB_ADDSTRING, 0, (LPARAM) BootOptions[i].Identifier);
            }
        }
        SendMessage(hBoot, CB_SETCURSEL, i=Curr_Munge.BootIndex, 0);
        if (-1!=BootOptions[i].BaudRate) {
            SetDlgItemInt(HSavePages[PROP_BOOT], IDO_BAUD, BootOptions[i].BaudRate, TRUE);
        } else {
            SetDlgItemText(HSavePages[PROP_BOOT], IDO_BAUD, "");
        }
        if (-1!=BootOptions[i].DebugPort) {
            SetDlgItemInt(HSavePages[PROP_BOOT], IDO_PORT, BootOptions[i].DebugPort, TRUE);
        } else {
            SetDlgItemText(HSavePages[PROP_BOOT], IDO_PORT, "");
        }
        SetDlgItemText(HSavePages[PROP_BOOT], IDO_PATH, BootOptions[i].Path);
        SetDlgItemText(HSavePages[PROP_BOOT], IDO_MISC, BootOptions[i].OtherOptions);
        CheckRadioButton(HSavePages[PROP_BOOT], IDO_RBDEBUG, IDO_RBNO, Curr_Munge.BootOption);
    }

    // set locale dialog items
    if (HSavePages[PROP_LOCALE]) {
        DWORD_PTR j;
        hLocale = GetDlgItem(HSavePages[PROP_LOCALE], IDC_LOCALE);
        if (0==SendMessage(hLocale, CB_GETCOUNT, 0, 0)) {
            for (i=0; i<NUM_LOCALE; i++)
                SendMessage(hLocale, CB_ADDSTRING, 0, (LPARAM) Locale[i].szName);
        }
        j = SendMessage(hLocale, CB_FINDSTRING, 0, (LPARAM) Locale[Curr_Munge.nLCIndex].szName);
        SendMessage(hLocale, CB_SETCURSEL, j, 0);
    }
}

/////////////////////////////////////////////////////////////////////
//
// CheckPreferred() checks to see if preferred options already set.
//
/////////////////////////////////////////////////////////////////////
BOOL
CheckPreferred()
{
    if (Orig_Munge.AutoReboot)
        return FALSE;
    if (UseNewFlags) {
        if ((Orig_Munge.GlobalFlag & CSR_FLAG(UseNewFlags))==0)
            return FALSE;
    } else {
        if (Orig_Munge.GlobalFlag & CSR_FLAG(UseNewFlags))
            return FALSE;
    }
    if (Orig_Munge.CritSectTimeout != PREF_CSR_TIMEOUT || Orig_Munge.ResourceTimeout != PREF_TIMEOUT)
       return FALSE;
#ifdef FESTRESS
    //
    // If Locale is passed from command line and different from the default,
    // we need Preferred settings, let user to select.
    //
    if ((bLCSet == TRUE) &&
            Orig_Munge.nLCIndex != nLCIndex) return FALSE;
#endif // FESTRESS
    if ( !Quiet )
    {
#ifdef LOADIMM
       	if (Orig_Munge.LoadIMM == FALSE)
    	    return FALSE;
#endif // LOADIMM
	if (Orig_Munge.nLCIndex != Curr_Munge.nLCIndex)
    	    return FALSE;
    }

    if ( ChooseSpecial ) {
	if ( Orig_Munge.PoolTag != Curr_Munge.PoolTag )	{
	    return FALSE;
        }
    }
    return Orig_Munge.BootOption==PREF_BOOT;
}

/////////////////////////////////////////////////////////////////////
//
// same as CheckPreferred, but no Locale check.
//
BOOL CheckExceptLocale()
{
    if (Orig_Munge.AutoReboot) return FALSE;
    if (UseNewFlags) {
        if ((Orig_Munge.GlobalFlag & CSR_FLAG(UseNewFlags))==0) return FALSE;
    } else {
        if (Orig_Munge.GlobalFlag & CSR_FLAG(UseNewFlags)) return FALSE;
    }
    if (Orig_Munge.CritSectTimeout != PREF_CSR_TIMEOUT || Orig_Munge.ResourceTimeout != PREF_TIMEOUT) return FALSE;
    if ( !Quiet ) {
        if ( ChooseSpecial ) {
            if ( Orig_Munge.PoolTag != Curr_Munge.PoolTag ) {
                return FALSE;
            }
        }
    }
    return Orig_Munge.BootOption==PREF_BOOT;
}

BOOL
SetValuesAndReboot()
{
    int buttonRet;
    if (!YesReboot) {
        buttonRet = MessageBox(NULL,
                "The changes you have requested require "
                "a reboot. Is it OK to reboot?",
                "Reboot Now?",
                MB_ICONQUESTION|MB_YESNOCANCEL);
        if (buttonRet==IDCANCEL) {
            return TRUE;
        }
    } else {
        buttonRet=IDYES;
    }

    if (!SetValues()) {
        MessageBox(NULL,
                   "Unable to write changes. "
                   "Logon with admin privileges to make changes.",
                   "Unable to Change",
                   MB_OK|MB_ICONHAND);

    } else {

      if (buttonRet==IDYES) {

        HANDLE hToken = NULL;
        TOKEN_PRIVILEGES newTokPriv;

        //
        // Open process token to allow privileges to be set.
        //
        if (OpenProcessToken(GetCurrentProcess(),
                             TOKEN_ADJUST_PRIVILEGES,
                             &hToken)) {

            newTokPriv.PrivilegeCount = 1;
            newTokPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            //
            // Get current Shutdown privilege and enable it.
            //
            if (LookupPrivilegeValue("", SE_SHUTDOWN_NAME,
                                     &(newTokPriv.Privileges[0].Luid)) &&
                AdjustTokenPrivileges(hToken, FALSE, &newTokPriv, 0,NULL,NULL) ) {

                //
                // Use ExitWindowsEx with EW_REBOOT set.
                //
                if (!ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0)) {
                    TCHAR ErrBuff[128];
                    sprintf(ErrBuff, "Error %ld attempting to reboot. "
                            "Reboot should be done manually.",
                            GetLastError());
                    MessageBox(NULL, ErrBuff, "Reboot Failed!",
                               MB_OK|MB_ICONEXCLAMATION);
                }

            } // if (LookupPrivilegeValue...

        } // if (OpenProcessToken...

      } // if (buttonRet...
    } // else !SetValues
    return TRUE;
}

/****************************************************************************

    FUNCTION: BootDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for options dialog.

    COMMENTS: The options dialog

        WM_INITDIALOG: Sets items (and enables/disables crashdump)

        WM_COMMAND:    something happened:
            IDO_BOOT:  Get debug option for new boot selection.
            IDO_RB*:   Set new debug option.
            IDO_PREFERRED: Select preferred settings.

****************************************************************************/
LRESULT
CALLBACK
BootDlgProc(
            HWND hDlg,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    BOOT_OPTION tmpBoot;
    switch (message) {
        case WM_INITDIALOG:
            {
                HSavePages[PROP_BOOT]=hDlg;
                if (YesReboot && Changed()) {
                    SetValuesAndReboot();
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
                }
                SetDlgItems(hDlg);
            }
            return (FALSE);

        case WM_COMMAND:        // command: button pressed

            switch (LOWORD(wParam)) {     // which button
            case IDO_BOOT:
                    switch (HIWORD(wParam)) {

                case CBN_SELCHANGE:
                    Curr_Munge.BootIndex=(long)SendMessage((HWND) lParam, CB_GETCURSEL, 0, 0);
                    if ( ChooseBaudRate ) {
                        BootOptions[Curr_Munge.BootIndex].BaudRate = BaudRate;
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                    }
                    Curr_Munge.BootOption=BootOptions[Curr_Munge.BootIndex].DebugType;
                    if (-1!=BootOptions[Curr_Munge.BootIndex].BaudRate) {
                        SetDlgItemInt(hDlg, IDO_BAUD, BootOptions[Curr_Munge.BootIndex].BaudRate, TRUE);
                    } else {
                        SetDlgItemText(hDlg, IDO_BAUD, "");
                    }
                    if (-1!=BootOptions[Curr_Munge.BootIndex].DebugPort) {
                        SetDlgItemInt(hDlg, IDO_PORT, BootOptions[Curr_Munge.BootIndex].DebugPort, TRUE);
                    } else {
                        SetDlgItemText(hDlg, IDO_PORT, "");
                    }
                    SetDlgItemText(hDlg, IDO_PATH, BootOptions[Curr_Munge.BootIndex].Path);
                    SetDlgItemText(hDlg, IDO_MISC, BootOptions[Curr_Munge.BootIndex].OtherOptions);
                    CheckRadioButton(hDlg, IDO_RBDEBUG, IDO_RBNO, Curr_Munge.BootOption);
                    return (FALSE);

                default:
                    break;
                }
                break;
            case IDO_RBDEBUG:
            case IDO_RBCRASH:
            case IDO_RBNO:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.BootOption=LOWORD(wParam);
                    if (Curr_Munge.BootOption!=BootOptions[Curr_Munge.BootIndex].DebugType) {
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                        BootOptions[Curr_Munge.BootIndex].DebugType=Curr_Munge.BootOption;
                    }
                }
                break;

            case IDO_PATH:
                if (HIWORD(wParam)==EN_CHANGE) {
                    GetWindowText((HWND)lParam, tmpBoot.Path, MAX_PATH);
                    if (_stricmp(tmpBoot.Path, BootOptions[Curr_Munge.BootIndex].Path)) {
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                        lstrcpy(BootOptions[Curr_Munge.BootIndex].Path, tmpBoot.Path);
                    }
                }
                break;

            case IDO_MISC:
                if (HIWORD(wParam)==EN_CHANGE) {
                    GetWindowText((HWND)lParam, tmpBoot.OtherOptions, 256);
                    if (_stricmp(tmpBoot.OtherOptions, BootOptions[Curr_Munge.BootIndex].OtherOptions)) {
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                        lstrcpy(BootOptions[Curr_Munge.BootIndex].OtherOptions, tmpBoot.OtherOptions);
                    }
                }
                break;

            case IDO_PORT:
                if (HIWORD(wParam)==EN_CHANGE) {
                    tmpBoot.DebugPort=GetDlgItemInt(hDlg, LOWORD(wParam), NULL, TRUE);
                    if (0==tmpBoot.DebugPort) {
                        tmpBoot.DebugPort=-1;
                    }
                    if (tmpBoot.DebugPort!=BootOptions[Curr_Munge.BootIndex].DebugPort) {
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                        BootOptions[Curr_Munge.BootIndex].DebugPort=tmpBoot.DebugPort;
                    }
                }
                break;

            case IDO_BAUD:
                if (HIWORD(wParam)==EN_CHANGE) {
                    tmpBoot.BaudRate=GetDlgItemInt(hDlg, LOWORD(wParam), NULL, TRUE);
                    if (0==tmpBoot.BaudRate) {
                        tmpBoot.BaudRate=-1;
                    }
                    if (tmpBoot.BaudRate!=BootOptions[Curr_Munge.BootIndex].BaudRate) {
                        ChangedBootOptions=BootOptions[Curr_Munge.BootIndex].Modified=TRUE;
                        BootOptions[Curr_Munge.BootIndex].BaudRate=tmpBoot.BaudRate;
                    }
                }
                break;

            case IDO_PREFERRED:
                SetPreferred();
                SetDlgItems(hDlg);
                break;
            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // BootDlgProc()

/****************************************************************************

    FUNCTION: FlagsDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for flags dialog.

    COMMENTS: The options dialog

        WM_INITDIALOG: Sets items (and enables/disables crashdump)

        WM_COMMAND:    something happened:
            IDO_HEAP:  Toggle flag.
            IDO_CSR:   ditto.
            IDO_POOL:  ditto.
            IDO_CRASH: ditto.
            IDO_PREFERRED: Select preferred settings.

****************************************************************************/
LRESULT
CALLBACK
FlagsDlgProc(
             HWND hDlg,
             UINT message,
             WPARAM wParam,
              LPARAM lParam
             )
{
    switch (message) {
        case WM_INITDIALOG:
            {
                HSavePages[PROP_FLAG]=hDlg;
                if (YesReboot && Changed()) {
                    SetValuesAndReboot();
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
                }
                SetDlgItems(hDlg);
            }
            return (FALSE);

        case WM_COMMAND:        // command: button pressed

            switch (LOWORD(wParam)) {     // which button
            case IDO_HEAP:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.GlobalFlag^=HEAP_FLAGS(UseNewFlags);
                }
                break;
            case IDO_OBJECT:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.GlobalFlag^=OBJECT_FLAG(UseNewFlags);
                }
                break;
            case IDO_HANDLE:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.GlobalFlag^=HANDLE_FLAG(BuildNumber>1057);
                }
                break;
            case IDO_POOL:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.GlobalFlag^=POOL_FLAG(UseNewFlags);
                }
                break;
            case IDO_CSR:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.GlobalFlag^=CSR_FLAG(UseNewFlags);
                }
                break;

            case IDO_PREFERRED:
                SetPreferred();
                SetDlgItems(hDlg);
                break;
            //
            // OK: Update the appropriate stat if not "Normal Boot"
            //
            case IDOK:
                GetDlgItems(hDlg);
                if (Curr_Munge.AutoReboot) {
                    int buttonRet;
                    buttonRet = MessageBox(NULL,
                                "WARNING! You have your machine set to autoreboot "
                                "for bugchecks. This is BAD for stress.  You will "
                                "not be counted.  Is this OK?",
                                "Warning: Autoreboot Set",
                                MB_ICONHAND|MB_OKCANCEL);
                    if (buttonRet==IDCANCEL) {
                        return TRUE;
                    }
                }
                if (Changed()) {
                    SetValuesAndReboot();
                }

            case IDCANCEL:

                EndDialog(hDlg, TRUE);
                return (TRUE);

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "The Stress Registry Munger allows you to set "
                            "values in the registry and boot loader and "
                            "reboot before stress.\r\r"
                            "The Preferred Stress Settings button will set "
                            "the registry the way the stress team prefers it "
                            "for best debugging.\r\r"
                            "The GlobalFlags section allows you to set flags "
                            "for better debugging.  CSR debugging must be checked "
                            "to debug AV's and critical section timeouts.  Pool & "
                            "heap flags allow better debugging at some performance "
                            "cost.\r\r"
                            "The Timeouts are the time for each type of dealock to "
                            "timeout (in seconds).\r\r"
                            "CrashDump helps test the crashdump feature in the event "
                            "of a bugcheck.\r\r"
                            "NOTE: Using this utility requires admin privileges.",
                            "Stress Registry Munger Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // FlagsDlgProc()

/****************************************************************************

    FUNCTION: MiscDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for misc dialog.

    COMMENTS: The options dialog

        WM_INITDIALOG: Sets items (and enables/disables crashdump)

        WM_COMMAND:    something happened:
            IDO_CRASH: toggle flag
            IDO_PREFERRED: Select preferred settings.
            IDC_LOADIMM: Load imm32.dll or not
            IDOK:      Get dialog items and set values in registry/boot.
            IDCANCEL:  Kill the app without changes.
            IDB_HELP:  Descriptive message box.

****************************************************************************/

LRESULT
 CALLBACK
MiscDlgProc(
            HWND hDlg,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    switch (message) {
        case WM_INITDIALOG:
            {
                HSavePages[PROP_MISC]=hDlg;
                if (YesReboot && Changed()) {
                    SetValuesAndReboot();
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
                }
                SetDlgItems(hDlg);
            }
            return (FALSE);

        case WM_COMMAND:        // command: button pressed

            switch (LOWORD(wParam)) {     // which button
            case IDO_CRASHDUMP:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.CrashDumpEnabled=!Curr_Munge.CrashDumpEnabled;
                }
                break;

            case IDO_REBOOT:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.AutoReboot=!Curr_Munge.AutoReboot;
                }
                break;

            case IDO_ALIGN:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.Alignment=!Curr_Munge.Alignment;
                }
                break;

            case IDO_WINLOGON:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.DebugWinlogon=!Curr_Munge.DebugWinlogon;
                }
                break;

#ifdef LOADIMM
            case IDC_LOADIMM:
                if (HIWORD(wParam)==BN_CLICKED) {
                    Curr_Munge.LoadIMM=!Curr_Munge.LoadIMM;
                }
                break;
#endif // LOADIMM

            case IDO_PREFERRED:
                SetPreferred();
                SetDlgItems(hDlg);
                break;

            case IDO_CRITSECT:
                if (HIWORD(wParam)==EN_CHANGE) {
                    Curr_Munge.CritSectTimeout = GetDlgItemInt(hDlg,
                       IDO_CRITSECT, NULL,Curr_Munge.CritSectTimeout);
                }
                break;

            case IDO_RESOURCE:
                if (HIWORD(wParam)==EN_CHANGE) {
                    Curr_Munge.ResourceTimeout = GetDlgItemInt(hDlg,
                       IDO_RESOURCE, NULL,Curr_Munge.ResourceTimeout);
                }
                break;


            //
            // OK: Update the appropriate stat if not "Normal Boot"
            //
            case IDOK:
                GetDlgItems(hDlg);
                if (Curr_Munge.AutoReboot) {
                    int buttonRet;
                    buttonRet = MessageBox(NULL,
                                "WARNING! You have your machine set to autoreboot "
                                "for bugchecks. This is BAD for stress.  You will "
                                "not be counted.  Is this OK?",
                                "Warning: Autoreboot Set",
                                MB_ICONHAND|MB_OKCANCEL);
                    if (buttonRet==IDCANCEL) {
                        return TRUE;
                    }
                }
                if (Changed()) {
                    SetValuesAndReboot();
                }

            case IDCANCEL:

                EndDialog(hDlg, TRUE);
                return (TRUE);

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "The Stress Registry Munger allows you to set "
                            "values in the registry and boot loader and "
                            "reboot before stress.\r\r"
                            "The Preferred Stress Settings button will set "
                            "the registry the way the stress team prefers it "
                            "for best debugging.\r\r"
                            "The GlobalFlags section allows you to set flags "
                            "for better debugging.  CSR debugging must be checked "
                            "to debug AV's and critical section timeouts.  Pool & "
                            "heap flags allow better debugging at some performance "
                            "cost.\r\r"
                            "The Timeouts are the time for each type of dealock to "
                            "timeout (in seconds).\r\r"
                            "CrashDump helps test the crashdump feature in the event "
                            "of a bugcheck.\r\r"
                            "NOTE: Using this utility requires admin privileges.",
                            "Stress Registry Munger Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // MiscDlgProc()

/****************************************************************************

    FUNCTION: LocaleDlgProc(HWND, UINT, UINT, UINT)

    PURPOSE:  Dialog procedure for locale dialog.

    COMMENTS: Use this dialog to set the system default locale to stress

        WM_INITDIALOG: Set the locale to current locale or command line locale

        WM_COMMAND:    something happened:
            IDC_LOCALE: User select a locale

****************************************************************************/

LRESULT
CALLBACK
LocaleDlgProc(
              HWND hDlg,
              UINT message,
              WPARAM wParam,
              LPARAM lParam
              )
{
int LocaleIndex;

    switch (message) {
        case WM_INITDIALOG:
            {
                HSavePages[PROP_LOCALE]=hDlg;
                if (YesReboot && Changed()) {
                    SetValuesAndReboot();
                    EndDialog(hDlg, TRUE);
                    return (TRUE);
                }
                SetDlgItems(hDlg);
            }
            return (FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDC_LOCALE:
                    switch (HIWORD(wParam)) {
                TCHAR szBuff[50];
                int i;
                case CBN_SELCHANGE:
                            LocaleIndex=(int)SendMessage((HWND) lParam, CB_GETCURSEL, 0, 0);
                    SendMessage((HWND) lParam, CB_GETLBTEXT, LocaleIndex, (LPARAM) &szBuff);
                    for(i=0;i<NUM_LOCALE;i++)
                        if (strcmp(szBuff, Locale[i].szName)==0) {
                            Curr_Munge.nLCIndex = i;
                            break;
                        }
#ifdef LOADIMM
                            if (i>=0&&i<6) {
                        Curr_Munge.LoadIMM = TRUE;
                        SetDlgItems(HSavePages[PROP_MISC]);
                    }
#endif // LOADIMM
                    }

                break;
            case IDO_PREFERRED:
                SetPreferred();
                SetDlgItems(hDlg);
                break;
            case IDOK:
                GetDlgItems(hDlg);
                if (Curr_Munge.AutoReboot) {
                    int buttonRet;
                    buttonRet = MessageBox(NULL,
                                "WARNING! You have your machine set to autoreboot "
                                "for bugchecks. This is BAD for stress.  You will "
                                "not be counted.  Is this OK?",
                                "Warning: Autoreboot Set",
                                MB_ICONHAND|MB_OKCANCEL);
                    if (buttonRet==IDCANCEL) {
                        return TRUE;
                    }
                }
                if (Changed()) {
                    SetValuesAndReboot();
                }

            case IDCANCEL:

                EndDialog(hDlg, TRUE);
                return (TRUE);

            //
            // HELP: Descriptive message box (.HLP file would be overkill)
            //
            case IDB_HELP:
                MessageBox( NULL,
                            "The Stress Registry Munger allows you to set "
                            "values in the registry and boot loader and "
                            "reboot before stress.\r\r"
                            "The Preferred Stress Settings button will set "
                            "the registry the way the stress team prefers it "
                            "for best debugging.\r\r"
                            "The GlobalFlags section allows you to set flags "
                            "for better debugging.  CSR debugging must be checked "
                            "to debug AV's and critical section timeouts.  Pool & "
                            "heap flags allow better debugging at some performance "
                            "cost.\r\r"
                            "The Timeouts are the time for each type of dealock to "
                            "timeout (in seconds).\r\r"
                            "CrashDump helps test the crashdump feature in the event "
                            "of a bugcheck.\r\r"
                            "NOTE: Using this utility requires admin privileges.",
                            "Stress Registry Munger Help",
                            MB_OK
                           );
                return (TRUE);

            default:
                break;
            } // switch (wParam)
            break;
       default:
             break;
    } // switch (message)
    return (FALSE);     // Didn't process a message
} // LocaleDlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\munger.h ===
#include <windows.h>
#include <commctrl.h>
#include "locale.h"
#include "instlpk.h"


// Varibles and function prototypes
#define CSR_FLAG(x)     (x?0x00020000:0x00080000)
#define POOL_FLAG(x)    (x?0x00000400:0x01000000)
#define HEAP_FLAGS(x)   (x?0x00000370:0x20100000)
#define CRASH_FLAG(x)   (x?0x00000000:0x10000000)
#define OBJECT_FLAG(x)  (x?0x00004000:0x00000000)
#define HANDLE_FLAG(x)  (x?0x00400000:0x00000000)
#define PREF_BOOT IDO_RBDEBUG
// note: pref_timeout=1500*4 seconds=1 hr 40 minutes (too much, but too late to change)
#define PREF_TIMEOUT 1500
// pref_csr_timeout in seconds=27 minutes*3=1 hour 21 minutes
#define PREF_CSR_TIMEOUT 27*60
#define CRASH_DUMP_FILE "%systemroot%\\memory.dmp"
#define MAX_BOOT_OPTIONS 20
#define NUM_PROP 4
#define PROP_BOOT 0
#define PROP_FLAG 1
#define PROP_MISC 2
#define PROP_LOCALE 3

#define DEF_BAUD 19200
#if defined(_ALPHA_)
#define DEF_PORT 1
#else
#define DEF_PORT 2
#endif

#if !defined(MAX_PATH)
#define MAX_PATH 256
#endif

LRESULT CALLBACK BootDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK FlagsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MiscDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK LocaleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
int WINAPI WinMainInner(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow);
void StatusToDebugger();
int MakeProperty(HINSTANCE hInstance);
void GetDlgItems (HWND hDlg);
ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );
BOOL GetValues();
BOOL CheckPreferred();
void SetPreferred();
BOOL Changed();
BOOL SetValuesAndReboot();
BOOL SetValues();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\resource.h ===
#include <windows.h>

// resource ids
#define IDD_LOCALE    301
#define IDC_LOCALE    1001
#define IDC_STATIC    -1
#define IDD_OPTIONS   100
#define IDO_PREFERRED 110
#define      IDO_BOOT 120
#define   IDO_RBDEBUG 121
#define   IDO_RBCRASH 122
#define      IDO_RBNO 123
#define      IDO_PORT 124
#define      IDO_BAUD 125
#define      IDO_MISC 126
#define      IDO_PATH 127
#define       IDO_CSR 130
#define      IDO_HEAP 131
#define      IDO_POOL 132
#define    IDO_OBJECT 133
#define    IDO_HANDLE 134
#define  IDO_CRITSECT 140
#define  IDO_RESOURCE 141
#define IDO_CRASHDUMP 150
#define IDO_CRASHDUMPLABEL 151
#define    IDO_REBOOT 152
#define  IDO_WINLOGON 160
#define  IDO_ALIGN   161
#define IDC_LOADIMM   162
#define IDD_FLAGS     200
#define IDD_MISC      300
#define      IDB_HELP 666
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\munger\munger\syspart.c ===
/** FILE: syspart.c ******** Module Header ********************************
 *
 *  Control panel applet for System configuration.  This file holds
 *  everything to do with finding the system partition where the
 *  boot.ini file for x86 systems resides.
 *
 * History:
 *  08 Sept 1994  -by- Steve Cathcart [stevecat]
 *        Took base routines from TedM's SETUP code
 *
 *  Copyright (C) 1994 Microsoft Corporation
 *
 *************************************************************************/
//==========================================================================
//                              Include files
//==========================================================================
// C Runtime
#include "stdio.h"
#include "stdlib.h"

// For NT apis
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntdddisk.h"

// For Windows apis
#include "windows.h"


//==========================================================================
//                            Local Definitions
//==========================================================================

#define MALLOC(size)            Malloc(size)
#define REALLOC(block,size)     Realloc((block),(size))
#define FREE(block)             Free(&(block))


//==========================================================================
//                            Typedefs and Structs
//==========================================================================


//==========================================================================
//                            External Declarations
//==========================================================================
/* Functions */


//==========================================================================
//                     Local Data Declarations
//==========================================================================


//==========================================================================
//                      Local Function Prototypes
//==========================================================================
void  ErrMemDlg (HWND hParent)
{
MessageBox(NULL, "Insufficient memory to continue.", "Out of Memory",
           MB_ICONEXCLAMATION | MB_OK);
}

PVOID Malloc (IN DWORD Size)

/*++

Routine Description:

    Allocates memory and fatal errors if none is available.

Arguments:

    Size - number of bytes to allocate

Return Value:

    Pointer to memory.

--*/

{
    PVOID p;

    if ((p = (PVOID)LocalAlloc(LPTR,Size)) == NULL)
    {
        ErrMemDlg (NULL);
    }

    return(p);
}



VOID Free (IN OUT PVOID *Block)

/*++

Routine Description:

    Free a block of memory previously allocated with Malloc().

Arguments:

    Block - supplies pointer to block to free.

Return Value:

    None.

--*/

{
    LocalFree((HLOCAL)*Block);
    *Block = NULL;
}


PVOID Realloc (IN PVOID Block, IN DWORD Size)

/*++

Routine Description:

    Reallocates a block of memory previously allocated with Malloc();
    fatal errors if none is available.

Arguments:

    Block - supplies pointer to block to resize

    Size - number of bytes to allocate

Return Value:

    Pointer to memory.

--*/

{
    PVOID p;

    if ((p = LocalReAlloc((HLOCAL)Block,Size,LMEM_MOVEABLE)) == NULL)
    {
        ErrMemDlg (NULL);
    }

    return (p);
}


BOOL GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile (
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (hDisk == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    b = DeviceIoControl (
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle (hDisk);

    return (b);
}


UINT MyGetDriveType (IN TCHAR Drive)
{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk.  Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;

    if ((rc = GetDriveType (DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile (
                    DriveNameNt,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if (hDisk != INVALID_HANDLE_VALUE)
        {
            b = DeviceIoControl (
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if (b && (MediaInfo.MediaType == RemovableMedia))
            {
                rc = DRIVE_FIXED;
            }

            CloseHandle (hDisk);
        }
    }

    return(rc);
}


PWSTR ArcPathToNtPath (IN PWSTR ArcPath)
{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath;
    PWSTR ntPath;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MALLOC(((wcslen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    if ( NULL != arcPath ) {
        wcscpy (arcPath, L"\\ArcName\\");
        wcscat (arcPath, ArcPath);
    } else {
        return NULL;
    }

    RtlInitUnicodeString (&UnicodeString, arcPath);

    InitializeObjectAttributes (
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject (
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if (NT_SUCCESS(Status))
    {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject (
                    ObjectHandle,
                    &UnicodeString,
                    NULL
                    );

        if (NT_SUCCESS(Status))
        {
            ntPath = MALLOC(UnicodeString.Length+sizeof(WCHAR));

            if ( NULL != ntPath ) {
                CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);
        
                ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
            }
        }

        NtClose (ObjectHandle);
    }

    FREE (arcPath);

    return (ntPath);
}


BOOL AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PTSTR BootFiles[] = { TEXT("BOOT.INI"),
                          TEXT("NTLDR"),
                          TEXT("NTDETECT.COM"),
                          NULL
                        };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if (!GetPartitionInfo((TCHAR)Drive,&PartitionInfo))
    {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;

    for (i=0; i<min(DriveLayout->PartitionCount,4); i++)
    {
        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
          && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
          && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart))
        {
            IsPrimary = TRUE;
            break;
        }
    }

    if (!IsPrimary)
    {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be
    // accurate (like user is using os/2 boot manager, for example).
    //

    //
    // See whether an nt boot files are present on this drive.
    //
    for (i=0; BootFiles[i]; i++)
    {
        wsprintf (FileName, TEXT("%wc:\\%s"), Drive, BootFiles[i]);

        FindHandle = FindFirstFile (FileName, &FindData);

        if (FindHandle == INVALID_HANDLE_VALUE)
        {
            return (FALSE);
        }
        else
        {
            FindClose (FindHandle);
        }
    }

    return (TRUE);
}


TCHAR x86DetermineSystemPartition (IN HWND hdlg)

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    hdlg - Handle of topmost window currently being displayed. (unused)

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL  b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    NtDevicePath = ArcPathToNtPath (L"multi(0)disk(0)rdisk(0)");
    if ( NULL != NtDevicePath ) {
        //
        // The arc path for a disk device is usually linked
        // to partition0.  Get rid of the partition part of the name.
        //
        CharLowerW (NtDevicePath);

        if (p = wcsstr (NtDevicePath, L"\\partition"))
        {
            *p = 0;
        }

        NtDevicePathLen = lstrlenW (NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if (!wcsncmp (NtDevicePath, L"\\device\\harddisk", 16))
        {
            PhysicalDriveNumber = wcstoul (NtDevicePath+16, NULL, 10);

            wsprintfW (Buffer, L"\\\\.\\PhysicalDrive%u", PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFileW (
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if (hDisk != INVALID_HANDLE_VALUE)
            {
                //
                // Get partition information.
                //
                DriveLayout = MALLOC(2048);
                DriveLayoutSize = 2048;

                retry:

                b = DeviceIoControl (
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if (!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                {
                    DriveLayoutSize += 1024;
                    DriveLayout = REALLOC(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle (hDisk);

                if (b)
                {
                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for (Drive=L'C'; Drive<=L'Z'; Drive++)
                    {
                        if (MyGetDriveType ((TCHAR)Drive) == DRIVE_FIXED)
                        {
                            DriveName[0] = Drive;

                            if (QueryDosDeviceW (DriveName, Buffer, sizeof(Buffer)/sizeof(WCHAR)))
                            {
                                if (!_wcsnicmp (NtDevicePath, Buffer, NtDevicePathLen))
                                {
                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if (AppearsToBeSysPart(DriveLayout,Drive))
                                    {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                FREE(DriveLayout);
            }
        }

        FREE(NtDevicePath);
    }


    return (GotIt ? (TCHAR)Drive : TEXT('C'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\netperm\netperm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    netperm.c

Abstract:

    This is the main source file for the NETPERM tool, which insures that you
    have persistent connections to a set of servers.

Author:

    Steve Wood (stevewo) 23-Jan-1996

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

__cdecl
main (
    int argc,
    char *argv[]
    )
{
    DWORD           Status;
    DWORD           i, j;
    char            *Local;
    char            *Remote;
    HANDLE          enumHandle;
    DWORD           numEntries;
    BOOL            endOfList;
    NETRESOURCE     netResource[8192/sizeof(NETRESOURCE)];
    DWORD           bufferSize = sizeof(netResource);
    DWORD           NumberOfRemoteNamesToCheck;
    char            *RemoteNamesToCheck[ 16 ];
    BOOLEAN         RemoteNamesFound[ 16 ];


    NumberOfRemoteNamesToCheck = 0;
    while (--argc) {
        RemoteNamesFound[ NumberOfRemoteNamesToCheck ] = FALSE;
        RemoteNamesToCheck[ NumberOfRemoteNamesToCheck ] = *++argv;
        NumberOfRemoteNamesToCheck += 1;
        }
    if (NumberOfRemoteNamesToCheck == 0) {
        fprintf( stderr, "List of persistent drive letters currently defined:\n" );
        }

    Status = WNetOpenEnum(
                 RESOURCE_REMEMBERED,
                 RESOURCETYPE_DISK,
                 RESOURCEUSAGE_CONNECTABLE,
                 NULL,
                 &enumHandle );

    if (Status != NO_ERROR) {
        fprintf( stderr, "Cannot enumerate network connections (%d)\n", Status );
        exit( 1 );
        }

    endOfList = FALSE;

    do {
        numEntries = 0xFFFFFFFF;
        Status = WNetEnumResource( enumHandle, &numEntries, netResource, &bufferSize );

        switch( Status ) {

            case NO_ERROR:
                break;

            case ERROR_NO_NETWORK:
                //
                //  If the network has not started we'll continue
                //  (so users can work in local projects).
                //
            case ERROR_NO_MORE_ITEMS:
                endOfList = TRUE;
                numEntries = 0;
                break;

            case ERROR_EXTENDED_ERROR: {
                CHAR ErrorString [256];
                CHAR Network[256];
                DWORD dwError;

                WNetGetLastError(&dwError, ErrorString, 256, Network, 256);
                fprintf( stderr,
                         "Cannot enumerate network connections (%d)\n"
                         "Net: %s\n"
                         "Error: (%d) %s\n",
                         Status,
                         Network,
                         dwError,
                         ErrorString
                       );
                }
                break;

            default:
                fprintf( stderr, "Cannot enumerate network connections (%d)\n", Status );
                exit( 1 );
            }

        for (i = 0; i<numEntries; i++) {
            if (netResource[i].lpLocalName != NULL) {
                if (NumberOfRemoteNamesToCheck == 0) {
                    fprintf( stderr,
                             "%s => %s\n",
                             netResource[i].lpLocalName,
                             netResource[i].lpRemoteName
                           );
                    }
                else {
                    for (j=0; j<NumberOfRemoteNamesToCheck; j++) {
                        if (!RemoteNamesFound[ j ] &&
                            !_stricmp( netResource[i].lpRemoteName, RemoteNamesToCheck[ j ] )
                           ) {
                            RemoteNamesFound[ j ] = TRUE;
                            break;
                            }
                        }
                    }
                }
            }
        }
    while (!endOfList);

    WNetCloseEnum( enumHandle );

    Status = 0;
    for (j=0; j<NumberOfRemoteNamesToCheck; j++) {
        if (!RemoteNamesFound[ j ]) {
            fprintf( stderr, "No persistent drive letter found for %s\n", RemoteNamesToCheck[ j ] );
            Status = 1;
            }
        }

    exit( Status );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mv\mv.c ===
/* move from one file to another */


#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf;
    char src[MAX_PATH], dst[MAX_PATH], name[MAX_PATH];
    char *s;
    int i, erc;
    char *y;
    BOOL fExpunge, fDelayUntilReboot;
    DWORD dwMoveFileFlags;

    ConvertAppToOem( c, v );
    SHIFT (c,v);
    if (c < 2) {
ShowUsage:
        printf ("Usage: mv [/x [/d]] file1 [ file2 ...] target\n");
        printf ("   /x     dont save deleted files in deleted subdirectory\n");
        printf ("   /d     specifies to delay the rename until the next reboot.\n");
        exit (1);
        }

    dwMoveFileFlags = MOVEFILE_REPLACE_EXISTING |
                      MOVEFILE_COPY_ALLOWED;

    fExpunge = FALSE;
    fDelayUntilReboot = FALSE;
    for (i=0; i<c; i++) {
nextArg:
        s = v[i];
        if (*s == '/' || *s == '-') {
            SHIFT (c,v);
            while (*++s) {
                switch (tolower(*s)) {
                case 'x':   fExpunge = TRUE;    break;
                case 'd':   if (fExpunge) {
                                dwMoveFileFlags |= MOVEFILE_DELAY_UNTIL_REBOOT;
                                dwMoveFileFlags &= ~MOVEFILE_COPY_ALLOWED;
                                break;
                            }

                default:    goto ShowUsage;
                }

            goto nextArg;
            }
        } else {
            findpath (v[i], src, FALSE);
            pname (src);
            v[i] = _strdup (src);
        }
    }

    if (rootpath (v[c-1], dst) == -1) {
        printf ("Cannot move to %s - %s\n", v[c-1], error ());
        exit (1);
    } else {
        if ( dst[0] == '\\' && dst[1] == '\\' ) {
            y = strbscan (&dst[3], "/\\");
            if ( *y != '\0' ) {
                y = strbscan( y+1, "/\\");
                if ( *y == '\0' ) {
                    strcat(dst, "\\" );
                }
            }
        }
    }

    if (fPathChr (dst[strlen(dst)-1])) {
        SETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (ffirst (dst, FILE_ATTRIBUTE_DIRECTORY, &fbuf)) {
        findclose( &fbuf );  /* Let next ffirst work */
        RSETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        strcat (dst, "\\");
    }

    /* if more than 1 source and dest is a file */
    if (c != 2 && !TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        printf ("Cannot move > 1 file to another file\n");
        exit (1);
    }

    erc = 0;
    for (i=0; i < c-1; i++) {

        if (rootpath (v[i], src) == -1) {
            printf ("Cannot move %s - %s\n", v[i], error ());
            erc++;
            continue;
            }
        strcpy (name, dst);
        if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            if (!fPathChr (name[strlen(name)-1])) {
                strcat (name, "\\");
            }
            upd (src, name, name);
        }
        if (strcmp (src, name)) {
            printf ("%s => %s ", src, name);
            fflush (stdout);
            if (fExpunge) {
                if (MoveFileEx( src, dst, dwMoveFileFlags )) {
                    if (dwMoveFileFlags & MOVEFILE_DELAY_UNTIL_REBOOT)
                        printf ("[ok, will happen next reboot]\n");
                    else
                        printf ("[ok]\n");
                    }
                else {
                    printf( "failed - Error Code == %u\n", GetLastError() );
                    }
                }
            else {
                s = fmove( src, name );
                if (s) {
                    erc++;
                    printf ("[%s]\n", s);
                    }
                else
                    printf ("[ok]\n");
                }
            }
        else
            printf ("Source and destination the same, %s\n", src);
        }
    return(erc != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\charmap.h ===
//
// Access to charmap functions
//
#define OPERATORMSK 0x80        // Is this character the startof an operator
#define LX_OPERATOR 0x80
#define IS_OPERATORCHAR(c) ((Charmap[(UCHAR)(c)] & OPERATORMSK) != 0)

#define MACROMSK 0x01           // Is this character a valid macro character
#define LX_MACRO 0x01
#define IS_MACROCHAR(c) ((Charmap[(UCHAR)(c)] & MACROMSK) != 0)

#define LX_EOS      0x00
#define LX_ILL      0x00
#define LX_WHITE    0x00
#define LX_NL       0x00
#define LX_CR       0x00
#define LX_DQUOTE   0x00
#define LX_POUND    0x00
#define LX_ASCII    0x00
#define LX_SQUOTE   0x00
#define LX_COMMA    0x00
#define LX_MINUS    0x00
#define LX_DOT      0x00
#define LX_NUMBER   0x00
#define LX_COLON    0x00
#define LX_SEMI     0x00
#define LX_EACH     0x00
#define LX_ID       0x00
#define LX_OBRACK   0x00
#define LX_CBRACK   0x00
#define LX_OBRACE   0x00
#define LX_CBRACE   0x00

#define CHARMAP_SIZE 256

extern UCHAR Charmap[CHARMAP_SIZE];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\build.cpp ===
//  BUILD.C -- build routines
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to build targets
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  18-Jul-1996 GP  Support "batch" inference rules
//  15-Nov-1993 JR  Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  04-Aug-1993 HV  Fixed Ikura bug #178.  This is a separate bug but ArunJ
//                  just reopen 178 anyway.
//  07-Jul-1993 HV  Fixed Ikura bug #178: Option K does not give non zero
//                  return code when it should.
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Truncated History ... rest is now on SLM
//  16-May-1991 SB  Separated parts that should be in other modules

#include "precomp.h"
#pragma hdrstop

//  In order to make comparing dates easier, we cast the FILEINFO buffer to
//  be of type BOGUS, which has one long where the two unsigneds (for date
//  and time) are in the original buffer.  That way only need a single compare.

#ifdef CHECK_RECURSION_LEVEL
#define MAXRECLEVEL 10000                // Maximum recursion level
#endif

// function prototypes for the module
// I make as many things static as possible, just to be extra cautious


int          build(MAKEOBJECT*, UCHAR, time_t *, BOOL, char *, BATCHLIST**);

MAKEOBJECT * makeTempObject(char*, UCHAR);
void         insertSort(DEPLIST **pDepList, DEPLIST *pElement);
BOOL         nextToken(char**, char**);
DEPLIST    * createDepList(BUILDBLOCK *pBlock, char *objectName);
void         addBatch(BATCHLIST **pBatchList, RULELIST *pRule,
                            MAKEOBJECT *pObject, char *dollarLt);
int          doBatchCommand (BATCHLIST *pBatch);
int RecLevel = 0;           // Static recursion level.  Changed from function
                            // parameter because of treatment of recursive makes.
int   execBatchList(BATCHLIST *);
void  freeBatchList(BATCHLIST **);
int   invokeBuildEx(char *, UCHAR, time_t *, char *, BATCHLIST **);

// we have to check for expansion on targets -- firstTarget had to be
// expanded earlier to tell whether or not we were dealing w/ a rule, etc.,
// but targets from commandline might have macros, wildcards in them

int
processTree()
{
    STRINGLIST *p;
    char *v;
    NMHANDLE searchHandle;
    int status;
    time_t dateTime;

    for (p = makeTargets; p; p = makeTargets) {
        if (_tcspbrk(makeTargets->text, "*?")) {   // expand wildcards
            struct _finddata_t finddata;
            char *szFilename;

            if (szFilename = findFirst(makeTargets->text, &finddata, &searchHandle)) {
                do {
                    v = prependPath(makeTargets->text, szFilename);
                    dateTime = getDateTime(&finddata);
                    status = invokeBuild(v, flags, &dateTime, NULL);
                    FREE(v);
                    if ((status < 0) && (ON(gFlags, F1_QUESTION_STATUS))) {
                        freeStringList(p);  // Was not being freed
                        return(-1);
                    }
                } while (szFilename = findNext(&finddata, searchHandle));
            } else {
                makeError(0, NO_WILDCARD_MATCH, makeTargets->text);
            }
        } else {
            dateTime = 0L;
            status = invokeBuild(makeTargets->text, flags, &dateTime, NULL);
            if ((status < 0) && (ON(gFlags, F1_QUESTION_STATUS))) {
                freeStringList(p);          // Was not being freed
                return(255);    // Haituanv: change -1 to 255 to follow the manual
            }
        }
        makeTargets = p->next;
        FREE_STRINGLIST(p);
    }
    return(0);
}

int
invokeBuild(
    char *target,
    UCHAR pFlags,
    time_t *timeVal,
    char *pFirstDep)
{
    int status = 0;
    BATCHLIST *pLocalBatchList = NULL;
    status += invokeBuildEx(target,
                    pFlags,
                    timeVal,
                    pFirstDep,
                    &pLocalBatchList);

    if (pLocalBatchList) {
        status += execBatchList (pLocalBatchList);
        freeBatchList (&pLocalBatchList);
    }

    return status;
}


int
invokeBuildEx(
    char *target,
    UCHAR pFlags,
    time_t *timeVal,
    char *pFirstDep,
    BATCHLIST **ppBatchList)
{
    MAKEOBJECT *object;
    BOOL fInmakefile = TRUE;
    int  rc;

    ++RecLevel;
#ifdef CHECK_RECURSION_LEVEL
    if (RecLevel > MAXRECLEVEL)
        makeError(0, TOO_MANY_BUILDS_INTERNAL);
#endif
    if (!(object = findTarget(target))) {
        object = makeTempObject(target, pFlags);
        fInmakefile = FALSE;
    }
    rc = build(object, pFlags, timeVal, fInmakefile, pFirstDep, ppBatchList);
    --RecLevel;
    return(rc);
}


int
build(
    MAKEOBJECT *object,
    UCHAR parentFlags,
    time_t *targetTime,
    BOOL fInmakefile,
    char *pFirstDep,
    BATCHLIST **ppBatchList)
{
    STRINGLIST *questionList,
               *starList,
               *temp,
               *implComList;
    struct _finddata_t finddata;    // buffer for getting file times
    NMHANDLE tHandle;
    BUILDLIST  *b;
    RULELIST *rule;                 // pointer to rule found to build target
    BUILDBLOCK *block,
               *explComBlock;
    DEPLIST *deps, *deplist;
    char name[MAXNAME];
    int rc, status = 0;
    time_t        targTime,         // target's time in file system
                  newTargTime,      // target's time after being rebuilt
                  tempTime,
                  depTime,          // time of dependency just built
                  maxDepTime;       // time of most recent dependency built
    BOOL built;                     // flag: target built with doublecolon commands
    time_t        *blockTime;       // points to dateTime of cmd. block
    extern char *makeStr;
    extern UCHAR okToDelete;
    UCHAR okDel;
    BATCHLIST *pLocalBatchList;


#ifdef DEBUG_ALL
    printf("Build '%s'\n", object->name);
#endif

    // The first dependent or inbuilt rule dependent is reqd for extmake syntax
    // handling. If it has a value then it is the dependent corr to the inf rule
    // otherwise it should be the first dependent specified

    if (!object) {
        *targetTime = 0L;
        return(0);
    }

    if (ON(object->flags3, F3_BUILDING_THIS_ONE))       // detect cycles
        makeError(0, CYCLE_IN_TREE, object->name);

    if (object->ppBatch) {
        // we need to build an object that is already placed in a batch list
        // Go ahead and build the whole batch list
        BATCHLIST **ppBatch = object->ppBatch;
        status += execBatchList (*ppBatch);
        freeBatchList(ppBatch);
        *targetTime = object->dateTime;
        return status;
    }

    if (ON(object->flags3, F3_ALREADY_BUILT)) {
        if (ON(parentFlags, F2_DISPLAY_FILE_DATES))
            printDate(RecLevel*2, object->name, object->dateTime);
        *targetTime = object->dateTime;
        if ( OFF(gFlags, F1_QUESTION_STATUS) &&
             RecLevel == 1 &&
             OFF(object->flags3, F3_OUT_OF_DATE) &&
             findFirst(object->name, &finddata, &tHandle)) {
            // Display 'up-to-date' msg for built level-1 targets
            // that exist as files. [VS98 1930]
            makeMessage(TARGET_UP_TO_DATE, object->name);
        }
        return(ON(object->flags3, F3_OUT_OF_DATE)? 1 : 0);
    }

    questionList = NULL;
    starList = NULL;
    implComList = NULL;
    explComBlock = NULL;
    block = NULL;
    targTime = 0L;
    newTargTime = 0L;
    tempTime = 0L;
    depTime = 0L;
    maxDepTime = 0L;
    blockTime = NULL;
    pLocalBatchList = NULL;


    SET(object->flags3, F3_BUILDING_THIS_ONE);
    dollarStar = dollarAt = object->name;

    // For Double Colon case we need the date of target before it's target's are
    //  built. For all other cases the date matters only if dependents are up
    //  to date. NOT TRUE: WE ALSO NEED THE TARGET'S TIME for @?

    b = object->buildList;
    if (b && ON(b->buildBlock->flags, F2_DOUBLECOLON)
            && findFirst(object->name, &finddata, &tHandle)) {
        targTime = getDateTime(&finddata);

    }

    for (; b; b = b->next) {
        depTime = 0L;
        block = b->buildBlock;
        if (block->dateTime != 0) {         // cmd. block already executed
            targTime = __max(targTime, block->dateTime);
            built = TRUE;
            continue;                       // so set targTime and skip this block
        }
        blockTime = &block->dateTime;

        deplist = deps = createDepList(block, object->name);
        for (;deps; deps = deps->next) {
            tempTime = deps->depTime;
            rc = invokeBuildEx(deps->name,    // build the dependent
                             block->flags,
                             &tempTime, NULL, &pLocalBatchList);
            status += rc;
            if (fOptionK && rc) {
                MAKEOBJECT *obj = findTarget(deps->name);
                assert(obj != NULL);
                if (OFF(obj->flags3, F3_ERROR_IN_CHILD)) {
                    fSlashKStatus = FALSE;
                    makeError(0, BUILD_FAILED_SLASH_K, deps->name);
                }
                SET(object->flags3, F3_ERROR_IN_CHILD);
            }
            depTime = __max(depTime, tempTime);/*if rebuilt, change time*/

            // If target exists then we need it's timestamp to correctly construct $?

            if (!targTime && OFF(block->flags, F2_DOUBLECOLON) &&
                    findFirst(object->name, &finddata, &tHandle)) {
                object->dateTime = targTime = getDateTime(&finddata);
            }

            // If dependent was rebuilt, add to $?.  [RB]

            if (ON(object->flags2, F2_FORCE_BUILD) ||
                targTime < tempTime ||
                (fRebuildOnTie && targTime == tempTime)
               ) {
                temp = makeNewStrListElement();
                temp->text = makeString(deps->name);
                appendItem(&questionList, temp);
            }

            // Always add dependent to $**. Must allocate new item because two
            // separate lists.  [RB]

            temp = makeNewStrListElement();
            temp->text = makeString(deps->name);
            appendItem(&starList, temp);
        }

        if (pLocalBatchList) {
            // Perform deferred batch builds and free batch list
            status += execBatchList (pLocalBatchList);
            freeBatchList(&pLocalBatchList);
        }

        // Free dependent list

        for (deps = deplist; deps ; deps = deplist) {
            FREE(deps->name);
            deplist = deps->next;
            FREE(deps);
        }

        // Now, all dependents are built.

        if (ON(block->flags, F2_DOUBLECOLON)) {

            // do doublecolon commands

            if (block->buildCommands) {
                dollarQuestion = questionList;
                dollarStar = dollarAt = object->name;
                dollarLessThan = dollarDollarAt = NULL;
                dollarStarStar = starList;
                if (((fOptionK && OFF(object->flags3, F3_ERROR_IN_CHILD)) ||
                      status == 0) &&
                    (targTime < depTime) ||
                    (fRebuildOnTie && (targTime == depTime)) ||
                    (targTime == 0 && depTime == 0) ||
                    (!block->dependents)
                   ) {

                    // do commands if necessary

                    okDel = okToDelete;
                    okToDelete = TRUE;

                    // if the first dependent is not set use the first one
                    // from the list of dependents

                    pFirstDep = pFirstDep ? pFirstDep : (dollarStarStar ?
                        dollarStarStar->text : NULL);
                    status += doCommands(object->name,
                                         block->buildCommands,
                                         block->buildMacros,
                                         block->flags,
                                         pFirstDep);

                    if (OFF(object->flags2, F2_NO_EXECUTE) &&
                            findFirst(object->name, &finddata, &tHandle))
                        newTargTime = getDateTime(&finddata);
                    else if (maxDepTime)
                        newTargTime = maxDepTime;
                    else
                        curTime(&newTargTime);      // currentTime

                    // set time for this block
                    block->dateTime = newTargTime;
                    built = TRUE;

                    // 5/3/92  BryanT   If these both point to the same list,
                    //                  don't free twice.

                    if (starList != questionList) {
                        freeStringList(starList);
                        freeStringList(questionList);
                    } else {
                        freeStringList(starList);
                    }

                    starList = questionList = NULL;
                    okToDelete = okDel;
                }

                if (fOptionK && ON(object->flags3, F3_ERROR_IN_CHILD))
                    makeError(0, TARGET_ERROR_IN_CHILD, object->name);
            }
        } else {

            // singlecolon; set explComBlock

            if (block->buildCommands)
                if (explComBlock)
                    makeError(0, TOO_MANY_RULES, object->name);
                else
                    explComBlock = block;
            maxDepTime = __max(maxDepTime, depTime);
        }

        if (ON(block->flags, F2_DOUBLECOLON) && !b->next) {
            CLEAR(object->flags3, F3_BUILDING_THIS_ONE);
            SET(object->flags3, F3_ALREADY_BUILT);
            if (status > 0)
                SET(object->flags3, F3_OUT_OF_DATE);
            else
                CLEAR(object->flags3, F3_OUT_OF_DATE);
            targTime = __max(newTargTime, targTime);
            object->dateTime = targTime;
            *targetTime = targTime;
            return(status);
        }
    }

    dollarLessThan = dollarDollarAt = NULL;

    if (!(targTime = *targetTime)) {                            //???????
        if (object->dateTime) {
            targTime = object->dateTime;
        } else if (findFirst(object->name, &finddata, &tHandle)) {
            targTime = getDateTime(&finddata);
        }
    }

    if (ON(object->flags2, F2_DISPLAY_FILE_DATES)) {
        printDate(RecLevel*2, object->name, targTime);
    }

    built = FALSE;

    // look for implicit dependents and use rules to build the target

    // The order of the if's decides whether the dependent is inferred
    // from the inference rule or not, even when the explicit command block is
    // present, currently it is infered (XENIX MAKE compatibility)

    if (rule = useRule(object,
                        name,
                        targTime,
                        &questionList,
                        &starList,
                        &status,
                        &maxDepTime,
                        &pFirstDep)
       ) {
        if (!explComBlock) {
            dollarLessThan = name;
            implComList = rule->buildCommands;
        }
   }

    dollarStar = dollarAt = object->name;
    dollarQuestion = questionList;
    dollarStarStar = starList;

    if (((fOptionK && OFF(object->flags3, F3_ERROR_IN_CHILD)) || status == 0) &&
        (targTime < maxDepTime ||
         (fRebuildOnTie && (targTime == maxDepTime)) ||
         (targTime == 0 && maxDepTime == 0) ||
         ON(object->flags2, F2_FORCE_BUILD)
        )
       ) {
        okDel = okToDelete;         // Yes, can delete while executing commands
        okToDelete = TRUE;

        if (explComBlock) {
            // if the first dependent is not set use the first one from the
            // list of dependents
            pFirstDep = pFirstDep ? pFirstDep :
                (dollarStarStar ? dollarStarStar->text : NULL);
            status += doCommands(object->name,      // do singlecolon commands
                                 explComBlock->buildCommands,
                                 explComBlock->buildMacros,
                                 explComBlock->flags,
                                 pFirstDep);
        }
        else if (implComList) {
            if (rule->fBatch && OFF(gFlags, F1_NO_BATCH)) {
                addBatch(ppBatchList,
                        rule,
                        object,
                        dollarLessThan);
            }
            else {
                status += doCommands(object->name,      // do rule's commands
                                 implComList,
                                 rule->buildMacros,
                                 object->flags2,
                                 pFirstDep);
            }
        }
        else if (ON(gFlags, F1_TOUCH_TARGETS)) {      // for /t with no commands...
            if (block)
                status += doCommands(object->name,
                                 block->buildCommands,
                                 block->buildMacros,
                                 block->flags,
                                 pFirstDep);
        }
        // if Option K specified don't exit ... pass on return code
        else if (!fInmakefile && targTime == 0) {    // lose
            // Haituanv: If option K, then set the return code 'status'
            // to 1 to indicate a failure.  This fixes Ikura bug #178.
            if (fOptionK) {
                status = 1;
#ifdef DEBUG_OPTION_K
                printf("DEBUG: %s(%d): status = %d\n", __FILE__, __LINE__, status);
#endif
            } else
                makeError(0, CANT_MAKE_TARGET, object->name);
        }
        okToDelete = okDel;
        // if cmd exec'ed or has 0 deps then currentTime else max of dep times
        if (explComBlock || implComList || !dollarStarStar) {
            curTime(&newTargTime);

            // Add 2 to ensure the time for this node is >= the time the file
            // system might have used (mainly useful when running a very fast
            // machine where the file system doesn't have the resolution of the
            // system timer... We don't have to to this in the curTime
            // above since it's only hit when nothing is built anywhere...

            newTargTime +=2;
        } else
            newTargTime = maxDepTime;

        if (blockTime && explComBlock)
            // set block's time, if a real cmd. block was executed
            *blockTime = newTargTime;
    }
    else if (OFF(gFlags, F1_QUESTION_STATUS) &&
             RecLevel == 1 &&
             !built &&
             OFF(object->flags3, F3_ERROR_IN_CHILD))
        makeMessage(TARGET_UP_TO_DATE, object->name);

    if (fOptionK && status) {
        // 4-Aug-1993 Haituanv: Ikura bug #178 again:  We should set fSlashKStatus=FALSE
        // so that main() knows the build failed under /K option.
        fSlashKStatus = FALSE;

        if (ON(object->flags3, F3_ERROR_IN_CHILD))
            makeError(0, TARGET_ERROR_IN_CHILD, object->name);
        else if (RecLevel == 1)
            makeError(0, BUILD_FAILED_SLASH_K, object->name);
    }

    if (ON(gFlags, F1_QUESTION_STATUS) && RecLevel == 1 ) {
        // 5/3/92  BryanT   If these both point to the same list, don't
        //                  free twice.

        if (starList!= questionList) {
            freeStringList(starList);
            freeStringList(questionList);
        } else {
            freeStringList(starList);
        }

        return(numCommands ? -1 : 0);
    }

    CLEAR(object->flags3, F3_BUILDING_THIS_ONE);
    if (!object->ppBatch) {
        SET(object->flags3, F3_ALREADY_BUILT);
        if (status > 0)
            SET(object->flags3, F3_OUT_OF_DATE);
        else
            CLEAR(object->flags3, F3_OUT_OF_DATE);
    }

    targTime = __max(newTargTime, targTime);
    object->dateTime = targTime;

    *targetTime = targTime;

    // 5/3/92  BryanT   If these both point to the same list, don't
    //                  free twice.

    if (starList!= questionList) {
        freeStringList(starList);
        freeStringList(questionList);
    } else {
        freeStringList(starList);
    }

    return(status);
}

DEPLIST *
createDepList(
    BUILDBLOCK *bBlock,
    char *objectName
    )
{
    BOOL again;  // flag: wildcards found in dependent name
    char *s, *t;
    char *source, *save, *token;
    char *depName, *depPath;
    char *tempStr;
    STRINGLIST *sList, *pMacros;
    DEPLIST *depList = NULL, *pNew;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;

    pMacros = bBlock->dependentMacros;

    // expand Macros in Dependent list
    for (sList = bBlock->dependents; sList; sList = sList->next) {
        for (s = sList->text; *s && *s != '$'; s = _tcsinc(s)) {
            if (*s == ESCH)
                s++;
        }
        if (*s) {
            // set $$@ properly, The dependency macros will then expand right
            dollarDollarAt = objectName;
            source = expandMacros(sList->text, &pMacros);
        } else
            source = sList->text;

        save = makeString(source);
        // build list for all dependents
        for (t = save; nextToken(&t, &token);) {
            if (*token == '{') {
                // path list found
                for (depName = token; *depName && *depName != '}'; depName = _tcsinc(depName)) {
                    if (*depName == ESCH) {
                        depName++;
                    }
                }

                if (*depName) {
                    *depName++ = '\0';
                    ++token;
                }
            } else {
                depName = token;    // If no path list, set
                token = NULL;       // token to null.
            }

            // depName is now name of dependency file ...

            again = FALSE;
            putDateTime(&finddata, 0L);
            depPath = makeString(depName);
            if (_tcspbrk(depName, "*?") || token) { // do wildcards in filename
                if (tempStr = searchPath(token, depName, &finddata, &searchHandle)){
                    again = TRUE;
                    FREE(depPath);
                    depName = tempStr;              // depName gets actual name
                    depPath = prependPath(depName, getFileName(&finddata));
                }                                   // depPath gets full path
            }

            // Add to the dependent list

            do {
                pNew = MakeNewDepListElement();
                // if name contains spaces and has no quotes,
                // add enclosing quotes around it [DS 14575]
                if (_tcschr(depPath, ' ') && !_tcschr(depPath, '\"')) {
                    pNew->name = (char *)rallocate (_tcslen(depPath)+3);
                    *(pNew->name) = '\"';
                    *(pNew->name+1) = '\0';
                    _tcscat (pNew->name, depPath);
                    _tcscat (pNew->name, "\"");
                }
                else {
                    pNew->name = makeString(depPath);
                }

                if (!fDescRebuildOrder || findFirst(depPath, &finddata, &searchHandle)) {
                    pNew->depTime = getDateTime(&finddata);
                } else {
                    pNew->depTime = 0L;
                }

                if (fDescRebuildOrder) {
                    insertSort(&depList, pNew);
                } else {
                    appendItem((STRINGLIST**)&depList, (STRINGLIST*)pNew);
                }
                FREE(depPath);
            } while (again &&
                     _tcspbrk(depName, "*?") &&    // do all wildcards
                     findNext(&finddata, searchHandle) &&
                     (depPath = prependPath(depName, getFileName(&finddata)))
                    );
        }
        // One dependent (w/wildcards?) was expanded

        if (source != sList->text) {
            FREE(source);
        }

        FREE(save);
    }

    // Now, all dependents are done ...

    return(depList);
}

void
insertSort(
    DEPLIST **pDepList,
    DEPLIST *pElement
    )
{
    time_t item;
    DEPLIST *pList, *current;

    item = pElement->depTime;
    pList = current = *pDepList;

    for (;pList && item <= pList->depTime; pList = pList->next) {
        current = pList;
    }

    if (current == pList) {
        *pDepList = pElement;
    } else {
        current->next = pElement;
        pElement->next = pList;
    }
}


BOOL
nextToken(
    char **pNext,
    char **pToken
    )
{
    char *s = *pNext;

    while (*s && WHITESPACE(*s)) {
        ++s;
    }

    if (!*(*pToken = s)) {
        return(FALSE);
    }

    // Token begins here
    *pToken = s;

    if (*s == '"') {
        while (*s && *++s != '"')
            ;

        if (!*s) {
            // lexer possible internal error: missed a quote
            makeError(0, LEXER_INTERNAL);
        }

        if (*++s) {
            *s++ = '\0';
        }

        *pNext = s;
        return(TRUE);
    } else if (*s == '{') {
        // skip to '}' outside quotes
        for (;*s;) {
            s++;
            if (*s == '"') {
                s++;        // Skip the first quote
                while (*s && *s++ != '"'); // Skip all including the last quote
            }
            if (*s == '}') {
                break;
            }
        }

        if (!*s) {
            // lexer possible internal error: missed a brace
            makeError(0, MISSING_CLOSING_BRACE);
         }

        if (*++s == '"') {
            while (*s && *++s != '"')
                ;

            if (!*s) {
                // lexer possible internal error: missed a quote
                makeError(0, LEXER_INTERNAL);
            }

            if (*++s) {
                *s++ = '\0';
            }

            *pNext = s;
            return(TRUE);
        }
    }

    while (*s && !WHITESPACE(*s)) {
        ++s;
    }

    if (*s) {
        *s++ = '\0';
    }

    *pNext = s;

    return(TRUE);
}


void
freeStringList(
    STRINGLIST *list
    )
{
    STRINGLIST *temp;

    while (temp = list) {
        list = list->next;
        FREE(temp->text);
        FREE_STRINGLIST(temp);
    }
}


// makeTempObject -- make an object to represent implied dependents
//
//   We add implied dependents to the target table, but use a special struct
//   that has  no pointer to a build list -- they never get removed.
//   time-space trade-off -- can remove them, but will take more proc time.

MAKEOBJECT *
makeTempObject(
    char *target,
    UCHAR flags
    )
{
    MAKEOBJECT *object;
    unsigned i;

    object = makeNewObject();
    object->name = makeString(target);
    object->flags2 = flags;
    object->flags3 = 0;
    object->dateTime = 0L;
    object->buildList = NULL;
    i = hash(target, MAXTARGET, (BOOL) TRUE);
    prependItem((STRINGLIST**)targetTable+i, (STRINGLIST*)object);
    return(object);
}


void
addBatch(
    BATCHLIST **ppBatchList,
    RULELIST *pRule,
    MAKEOBJECT *pObject,
    char *dollarLt
    )
{
    STRINGLIST *temp;
    BATCHLIST *pBatch;
    BATCHLIST *pBatchPrev = 0;

    for(pBatch = *ppBatchList; pBatch; pBatch = pBatch->next) {
        if (pBatch->pRule == pRule &&
            pBatch->flags == pObject->flags2)
            break;
        pBatchPrev = pBatch;
    }
    if (!pBatch) {
        pBatch = makeNewBatchListElement();
        pBatch->pRule = pRule;
        pBatch->flags = pObject->flags2;
        if (pBatchPrev) {
            pBatchPrev->next = pBatch;
        }
        else if(*ppBatchList) {
            (*ppBatchList)->next = pBatch;
        }
        else
            *ppBatchList = pBatch;
    }

    temp = makeNewStrListElement();
    temp->text = makeString(pObject->name);
    appendItem(&pBatch->nameList, temp);

    temp = makeNewStrListElement();
    temp->text = makeString(dollarLessThan);
    appendItem(&pBatch->dollarLt, temp);

    assert(!pObject->ppBatch);
    pObject->ppBatch = ppBatchList;
}


int doBatchCommand (
    BATCHLIST *pBatch
    )
{
    size_t      cbStr = 0;
    int         rc;
    char        *pchBuf;
    STRINGLIST  *pStrList;
    RULELIST    *pRule = pBatch->pRule;
    assert (pBatch->dollarLt);
    assert (pBatch->nameList);

    // form $<
    for (pStrList = pBatch->dollarLt; pStrList; pStrList = pStrList->next) {
        cbStr += _tcslen(pStrList->text) + 1;
        // allow space for quotes if text contains spaces
        if (_tcschr(pStrList->text, ' '))
            cbStr += 2;
    }
    pchBuf = (char *)allocate(cbStr + 1);
    *pchBuf = 0;
    for (pStrList = pBatch->dollarLt; pStrList; pStrList = pStrList->next) {
        BOOL fQuote;
        // Quote only if not quoted and contains spaces [vs98:8677]
        fQuote = pStrList->text[0] != '"' && _tcschr(pStrList->text, ' ');
        if (fQuote)
            _tcscat(pchBuf, "\"");
        _tcscat(pchBuf, pStrList->text);
        _tcscat(pchBuf, fQuote ? "\" " : " ");
    }
    dollarLessThan = pchBuf;

    rc = doCommandsEx(pBatch->nameList,
                    pRule->buildCommands,
                    pRule->buildMacros,
                    pBatch->flags,
                    NULL);

    if (rc == 0) {
        STRINGLIST *pName;
        MAKEOBJECT *pObject;
        for (pName = pBatch->nameList; pName; pName = pName->next) {
            pObject = findTarget(pName->text);
            assert (pObject);

            SET(pObject->flags3, F3_ALREADY_BUILT);
            CLEAR(pObject->flags3, F3_OUT_OF_DATE);

            pObject->ppBatch = 0;
        }
    }

    FREE (pchBuf);
    return rc;
}




int
execBatchList(
    BATCHLIST *pBList
    )
{
    int status = 0;
    if (pBList) {
        BATCHLIST *pBatch;
        for (pBatch = pBList; pBatch; pBatch=pBatch->next) {
            status += doBatchCommand (pBatch);
        }
    }
    return status;
}


void
freeBatchList(
    BATCHLIST **ppBList
    )
{
    BATCHLIST *pBatch = *ppBList;

    while (pBatch) {
        BATCHLIST *pTmp;
        free_stringlist(pBatch->nameList);
        free_stringlist(pBatch->dollarLt);
        pTmp = pBatch;
        pBatch = pBatch->next;
        FREE(pTmp);
    }
    *ppBList = NULL;
}


#ifdef DEBUG_ALL
void
DumpList(
    STRINGLIST *pList
    )
{
    // STRINGLIST *p;
    printf("* ");
    while (pList) {
        printf(pList->text);
        printf(",");
        pList = pList->next;
    }
    printf("\n");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\action.cpp ===
//  ACTION.C -- routines called by the parser
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the routines called during parsing of a makefile.
//
// Revision History:
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  13-Feb-1990 SB  nextComponent() missed out mixed case of quoted/non-quote list
//  02-Feb-1990 SB  Add nextComponent() for Longfilename handling
//  08-Dec-1989 SB  removed local used without initialization warnings for -Oes
//  07-Dec-1989 SB  removed register to compile using C6 -Oes (warning gone)
//  06-Dec-1989 SB  changed expandFileNames() type to void instead of void *
//  22-Nov-1989 SB  Changed free() to FREE()
//  13-Nov-1989 SB  Removed an unreferenced local in endNameList()
//  02-Oct-1989 SB  add dynamic inline file handling support
//  04-Sep-1989 SB  Add A_DEPENDENT and fix macro inheritance
//  24-Aug-1989 SB  Allow $* on dependency lines
//  14-Jul-1989 SB  Environment macro was getting updated even when CMDLINE
//                  macro was present
//  29-Jun-1989 SB  addItemToList() now maintains Global inline file List
//  26-Jun-1989 SB  Fixed -e for recursive NMAKE
//  22-May-1989 SB  NZ options work independently. -NZ does both stuff now
//  13-May-1989 SB  Changed delList to contain just names of files and no "del "
//  14-Apr-1989 SB  made targetList NEAR, no 'del inlinefile' cmd for -n now
//  05-Apr-1989 SB  Added parameters to makeRule() & makeTarget(); this get rid
//                  of globals
//  03-Apr-1989 SB  changed all functions to NEAR to get them into one module
//  21-Mar-1989 SB  changed assignDependents() and assignCommands() to handle
//                  multiple target case correctly.
//  20-Mar-1989 SB  startNamelist() doesn't flag error if target macro is null
//                  and >1 target given; commented startNameList()
//  16-Feb-1989 SB  addItemToList() now appends to delList instead of List so
//                  that all 'del scriptFile' cmds can be at the end of the make
//  29-Jan-1989 SB  added targList but not used as yet
//  19-Jan-1989 SB  changed startNameList() to avoid GP fault, bug# 162
//  18-Jan-1989 SB  modified endNameList(), added makeList() and makeBuildList()
//                  and added a parameter to makeTarget() for bug# 161
//  21-Dec-1988 SB  use scriptFileList to handle multiple scriptFiles
//                  Improve KEEP/NOKEEP;each file can have its own action
//  16-Dec-1988 SB  addItemToList() is now equipped for KEEP/NOKEEP
//  14-Dec-1988 SB  addItemToList() modified for 'Z' option -- adds a delete
//                  command for deleting temporary script files
//   5-Nov-1988 RB  Fixed macro inheritance for recursive definitions.
//  27-Oct-1988 SB  put malloc for allocate in putEnvStr() -- error checking
//  23-Oct-1988 SB  Using putEnvStr() for putenv() to simplify code
//  21-Oct-1988 SB  Added fInheritUserEnv flag modifications to makeMacro()
//                  and putMacro() for macro inheritance
//  19-Sep-1988 RB  Remove warning for MAKE redefinition.
//  22-Aug-1988 RB  Clean up for !UNDEF'ed macros.
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Added initialization of dateTime field of BUILDBLOCKs.
//   7-Jul-1988 rj  Added targetFlag parameter to hash() calls.
//                  Fixed bug: redefined macros didn't get flags reset.
//  09-May-1988 rb  Don't swallow no-match wildcards.

#include "precomp.h"
#pragma hdrstop

void       startNameList(void);
void       makeRule(STRINGLIST *, BOOL fBatch);
void       makeTarget(char*, BOOL, BUILDBLOCK**);
void       appendPseudoTargetList(STRINGLIST**, STRINGLIST*);
void       clearSuffixes(void);
BOOL       doSpecial(char*);
BUILDLIST  * makeBuildList(BUILDBLOCK *);
char     * nextComponent(char **);

// created by endNameList() & freed by assignBuildCommands(). In use because
// although global 'list' has this list is used by too many routines and the
// complete sequence of actions on 'list' is unknown

STRINGLIST    * targetList;         // corr to a dependency block


//  makeName -- create copy of a name seen by lexer
//
// Purpose:
//  Create a copy of a macro or 1st name in a target/dependency list. It also
//  does the groundwork for expansion of macros in name and saves values.
//
// Assumes: That the lexical routines save the token in buf
//
// Modifies Globals:
//  name   -- the pointer to the copy created, gets allocated memory
//  macros -- the list of macro values in name. Used later by startNameList()
//           to expand macros in name and get expanded target name.
//
// Uses Globals:
//  buf    -- the lexical routines return a token in this
//
// Notes:
//  The token in buf could be part of a macrodefinition or a target list. The
//  next token determines if it is a macrodefn or a targetlist we are parsing.
//  The next token would overwrite the current token and so it is saved in name.

void
makeName()
{
    findMacroValues(buf, &macros, NULL, NULL, 0, 0, 0);
    name = makeString(buf);
}


// don't expand build lines for rules now -- expand after everything read in
// that way CC and CFLAGS used in rules from tools.ini but not defined until
// the makefile will have appropriate values.    Redefining macros for use
// in targets w/o explicit build commands doesn't work.  Macros in rules have
// the value of their last definition in the makefile.

void
addItemToList()
{
    STRINGLIST *p;                  // from lexer
    STRINGLIST *NewList;

    if (name) {
        SET(actionFlags, A_TARGET);
        startNameList();
        name = NULL;
    }
    if (ON(actionFlags, A_TARGET)) {
        if (isRule(buf)) {
            if (ON(actionFlags, A_RULE))
                makeError(currentLine, TOO_MANY_RULE_NAMES);
            makeError(currentLine, MIXED_RULES);
        }
    }
    p = makeNewStrListElement();
    if (ON(actionFlags, A_STRING)) {    // we collect macros
        p->text = string;               // for dependents &
        string = NULL;                  // build lines for
    } else                              // non-implicit rules
        p->text = makeString(buf);

    NewList = p;                        // build lines for
    if (OFF(actionFlags, A_RULE)        // rules get expanded
        || ON(actionFlags, A_TARGET))   // after entire make-
    {
        findMacroValues(p->text, &macros, NULL, NULL, 0, 0, 0); //  file parsed
    }

    if (ON(actionFlags, A_TARGET)) {
        p = macros;
        expandFileNames("$", &NewList, &macros);
        expandFileNames("*?", &NewList, NULL);
        while (macros = p) {
            p = p->next;
            FREE_STRINGLIST(macros);
        }
    }

    appendItem(&list, NewList);
}


//  startNameList -- puts in the first element into list
//
// Scope:           Local.
//
// Purpose:         Puts in the first name seen into a list
//
// Errors/Warnings: TARGET_MACRO_IS_NULL -- if the macro used as a target expands to null
//
// Assumes:
//  The global 'list' is originally a null list, & the global 'macro' points to
//  a list of values used for expanding the macros in global 'name'.
//
// Modifies Globals:
//  list    -- the list of names; set to contain the first name here or to a
//             list of values if 'name' contains a macro invocation.
//  macros  -- the list of values reqd for macro expansion; the list is
//             freed and macros is made NULL
//  currentFlags -- the flags for current target; set to global flags
//  actionFlags  -- determine actions to be done; if the name is a rule then set
//                  the rule bit
//
// Uses Globals:
//  name        -- the first name seen in a list of names.
//  flags       -- the global flags setup by the options specified
//  actionFlags -- if handling targets then no error as we have > 1 target
//
// Notes:
//  If there is more than one target then actionFlags has A_TARGET flag set and
//  startNameList() is called from addItemToList. In this case don't flag error.

void
startNameList()
{
    STRINGLIST *p;

    currentFlags = flags;               // set flags for cur target
    p = makeNewStrListElement();
    p->text = name;
    list = p;                           // list contains name
    p = macros;
    expandFileNames("$", &list, &macros);   // expand macros in name
    expandFileNames("*?", &list, NULL);     // expand wildcards
    while (macros = p) {                    // free macro list
        p = p->next;
        FREE_STRINGLIST(macros);
    }
    if (!list && OFF(actionFlags, A_TARGET))
        makeError(line, TARGET_MACRO_IS_NULL, name);    // target null & 1 target

    if (list && isRule(list->text))
        SET(actionFlags, A_RULE);
}


//  endNameList -- semantic actions when a list is fully seen
//
// Purpose:
//  When the parser has seen an entire list then it needs to do some semantic
//  actions. It calls endNameList() to do these actions. The action depends on
//  the values in certain globals.
//
// Modifies Globals:    actionFlags --
//
// Uses Globals:
//  name         -- The first element seen (if non null)
//  actionFlags  -- The flag determining semantic & data structure actions
//  buf          -- The delimiter seen after list
//  list         -- The list of elements seen

void
endNameList()
{
    if (name) {                     // if only one name to left of :
        startNameList();            // it hasn't been put in list yet
        name = NULL;
    } else
        CLEAR(actionFlags, A_TARGET);       // clear target flag

    if (buf[1])
        SET(currentFlags, F2_DOUBLECOLON);  //  so addItemToList()

    if (!list)                                          //  won't expand names
        makeError(currentLine, SYNTAX_NO_TARGET_NAME);  //  of dependents

    if (ON(actionFlags, A_RULE)) {
		BOOL fBatch;
		// A rule with a doublecolon on the dependency line
		// is a "batch rule", i.e., a rule that applies the 
		// command block in batch mode for all affected 
		// dependents.  
        fBatch = !!(ON(currentFlags, F2_DOUBLECOLON));
        makeRule(list, fBatch);
        FREE_STRINGLIST(list);
    }
    else if (!(list->next) && doSpecial(list->text)) { // special pseudotarget ...
        FREE(list->text);           // don't need ".SUFFIXES" etc
        FREE_STRINGLIST(list);
    }
    else                            // regular target
        targetList = list;

    list = NULL;
    // We are now looking for a dependent
    SET(actionFlags, A_DEPENDENT);
}


BOOL
doSpecial(
    char *s)
{
    BOOL status = FALSE;

    if (!_tcsicmp(s, silent)) {
        SET(actionFlags, A_SILENT);
        setFlags('s', TRUE);
        status = TRUE;
    }

    if (!_tcsicmp(s, ignore)) {
        SET(actionFlags, A_IGNORE);
        setFlags('i', TRUE);
        status = TRUE;
    }
    else if (!_tcscmp(s, suffixes)) {
        SET(actionFlags, A_SUFFIX);
        status = TRUE;
    }
    else if (!_tcscmp(s, precious)) {
        SET(actionFlags, A_PRECIOUS);
        status = TRUE;
    }
    return(status);
}


void
expandFileNames(
    char *string,
    STRINGLIST **sourceList,
    STRINGLIST **macroList
    )
{
    char *s,
     *t = NULL;
    STRINGLIST *p;                  // Main list pointer
    STRINGLIST *pNew,               // Pointer to new list
               *pBack;              // Pointer to one element back
    char *saveText = NULL;

    for (pBack = NULL, p = *sourceList; p;) {

        // If no expand-character is found, continue to next list element.
        if (!_tcspbrk(p->text, string)) {
            pBack = p;
            p = pBack->next;
            continue;
        }

        // Either expand macros or wildcards.
        if (*string == '$') {
            t = expandMacros(p->text, macroList);
            FREE(p->text);
        } else {

            // If the wildcard string does not expand to anything, go to
            // next list elment.  Do not remove p from the original list
            // else we must check for null elsewhere.

            // CAVIAR 3912 -- do not attempt to expand wildcards that
            // occur in inference rules [rm]

            if (isRule(p->text) || (pNew = expandWildCards(p->text)) == NULL) {
                pBack = p;
                p = pBack->next;
                continue;
            }
            saveText = p->text;
        }

        // At this point we have a list of expanded names to replace p with.
        if (pBack) {
            pBack->next = p->next;
            FREE_STRINGLIST(p);
            p = pBack->next;
        } else {
            *sourceList = p->next;
            FREE_STRINGLIST(p);
            p = *sourceList;
        }

        if (*string == '$') {       // if expanding macros
            char *str = t;
            if (s = nextComponent(&str)) {
                do {                // put expanded names
                    pNew = makeNewStrListElement();     //  at front of list
                    pNew->text = makeString(s);         //  so we won't try to
                    prependItem(sourceList, pNew);      //  re-expand them
                    if (!pBack)
                        pBack = pNew;
                } while (s = nextComponent(&str));
            }
            FREE(t);
            continue;
        }
        else if (pNew) {            // if matches for * ?
            // Wild cards within Quoted strings will fail
            if (!pBack)
                for (pBack = pNew; pBack->next; pBack = pBack->next)
                    ;
            appendItem(&pNew, *sourceList);     // put at front of old list
            *sourceList = pNew;
        }
        FREE(saveText);
    }
}


//  nextComponent - returns next component from expanded name
//
// Scope:   Local (used by expandFilenames)
//
// Purpose:
//  Given a target string (target with macros expanded) this function returns a
//  name component. Previously _tcstok(s, " \t") was used but with the advent of
//  quoted filenames this is no good.
//
// Input:   szExpStr - the target name with macros expanded
//
// Output:  Returns pointer to next Component; NULL means no more components left.
//
// Assumes: That that two quoted strings are seperated by whitespace.

char *
nextComponent(
    char **szExpStr
    )
{
    char *t, *next;

    t = *szExpStr;

    while (WHITESPACE(*t))
        t++;

    next = t;
    if (!*t)
        return(NULL);

    if (*t == '"') {
        for (; *++t && *t != '"';)
            ;
    } else {
        for (; *t && *t != ' ' && *t != '\t'; t++)
            ;
    }

    if (WHITESPACE(*t)) {
        *t = '\0';
    } else if (*t == '"') {
        t++;
        if(*t=='\0') t--;   // If this is the end of the string, backup a byte, so we don't go past next time
            else *t = '\0';	    // else stop here for this time.
    } else if (!*t) {
        // If at end of string then backup a byte so that next time we don't go past
        t--;
    }

    *szExpStr = t+1;
    return(next);
}


// append dependents to existing ones (if any)
void
assignDependents()
{
    const char *which = NULL;

    if (ON(actionFlags, A_DEPENDENT))
        CLEAR(actionFlags, A_DEPENDENT);

    if (ON(actionFlags, A_RULE)) {
        if (list)
            makeError(currentLine, DEPENDENTS_ON_RULE);
    }
    else if (ON(actionFlags, A_SILENT) || ON(actionFlags, A_IGNORE)) {
        if (list) {
            if (ON(actionFlags, A_SILENT))
                which = silent;
            else if (ON(actionFlags, A_IGNORE))
                which = ignore;
            makeError(currentLine, DEPS_ON_PSEUDO, which);
        }
    }
    else if (ON(actionFlags, A_SUFFIX)) {
        if (!list)
            clearSuffixes();
        else
            appendPseudoTargetList(&dotSuffixList, list);
    }
    else if (ON(actionFlags, A_PRECIOUS)) {
        if (list)
            appendPseudoTargetList(&dotPreciousList, list);
    }
    else {
        block = makeNewBuildBlock();
        block->dependents = list;
        block->dependentMacros = macros;
    }
    list = NULL;
    macros = NULL;
    SET(actionFlags, A_STRING);             // expecting build cmd
}

void
assignBuildCommands()
{
    BOOL okToFreeList = TRUE;
    BOOL fFirstTarg = (BOOL)TRUE;
    STRINGLIST *p;
    const char *which = NULL;

    if (ON(actionFlags, A_RULE))        // no macros found yet for inference rules
        rules->buildCommands = list;
    else if (ON(actionFlags, A_SILENT) ||
             ON(actionFlags, A_IGNORE) ||
             ON(actionFlags, A_PRECIOUS) ||
             ON(actionFlags, A_SUFFIX)
            ) {
        if (list) {
            if (ON(actionFlags, A_SILENT))
                which = silent;
            else if (ON(actionFlags, A_IGNORE))
                which = ignore;
            else if (ON(actionFlags, A_PRECIOUS))
                which = precious;
            else if (ON(actionFlags, A_SUFFIX))
                which = suffixes;
            makeError(currentLine, CMDS_ON_PSEUDO, which);
        }
    } else {
        block->buildCommands = list;
        block->buildMacros = macros;
        block->flags = currentFlags;
        while (p = targetList) {                        // make a struct for each targ
            if (doSpecial(p->text))                     // in list, freeing list when
                makeError(currentLine, MIXED_TARGETS);
            makeTarget(p->text, fFirstTarg, &block);    // done, don't free name
            if (!makeTargets) {                         // field -- it's still in use
                makeTargets = p;                        // if no targs given on cmdlin
                okToFreeList = FALSE;                   // put first target(s) from
            }                                           // mkfile in makeTargets list
            targetList =  p->next;                      // (makeTargets defined in
            if (okToFreeList)                           // nmake.c)
                FREE_STRINGLIST(p);
            if (fFirstTarg)
                fFirstTarg = (BOOL)FALSE;
        }
    }
    targetList = NULL;
    list = NULL;
    macros = NULL;
    block = NULL;
    actionFlags = 0;
}

//  makeMacro -- define macro with name and string taken from global variables
//
// Modifies:
//  fInheritUserEnv    set to TRUE
//
// Notes:
//  Calls putMacro() to place expanded Macros in the NMAKE table. By setting
//  fInheritUserEnv those definitions that change Environment variables are
//  inherited by the environment.

void
makeMacro()
{
    STRINGLIST *q;
    char *t;

    if (_tcschr(name, '$')) {              // expand name
        q = macros;
        t = expandMacros(name, &macros);    // name holds result
        if (!*t)                            // error if macro to left of = is undefined
            makeError(currentLine, SYNTAX_NO_MACRO_NAME);
        while (macros = q) {
            q = q->next;
            FREE_STRINGLIST(macros);
        }
        FREE(name);
        name = t;
    }

    for (t = name; *t && MACRO_CHAR(*t); t = _tcsinc (t))   // Check for illegal chars
        ;

    if (*t)
        makeError(currentLine, SYNTAX_BAD_CHAR, *t);

    fInheritUserEnv = (BOOL)TRUE;

    // Put Env Var in Env & macros in table.

    if (!putMacro(name, string, 0)) {
        FREE(name);
        FREE(string);
    }
    name = string = NULL;
}


//  defineMacro -- check macro's syntax for illegal chars., then define it
//
//  actions:    check all of macro's characters
//        if one's bad and it's an environment macro, bag it
//            else flag error
//        call putMacro to do the real work
//
// can't use macro invocation to left of = in macro def from commandline
//  it doesn't make sense to do that, because we're not in a makefile
//  the only way to get a comment char into the makefile w/o having it really
//  mark a comment is to define a macro A=# on the command line

BOOL
defineMacro(
    char *s,                        // commandline or env definitions
    char *t,
    UCHAR flags
    )
{
    char *u;

    for (u = s; *u && MACRO_CHAR(*u); u = _tcsinc(u))  // check for illegal
        ;
    if (*u) {
        if (ON(flags, M_ENVIRONMENT_DEF)) { // ignore bad macros
            return(FALSE);
        }
        makeError(currentLine, SYNTAX_BAD_CHAR, *u);    // chars,  bad syntax
    }
    return(putMacro(s, t, flags));          // put macro in table
}


//  putMacro - Put the macro definition into the Macro Table / Environmnet
//
// Scope:
//  Global.
//
// Purpose:
//  putMacro() inserts a macro definition into NMAKE's macro table and also into
//  the environment. If a macro name is also an environment variable than its
//  value is inherited into the environment. While replacing older values by new
//  values NMAKE needs to follow the precedence of macro definitions which is
//  as per the notes below.
//
// Input:
//  name  - Name of the macro
//  value - Value of the macro
//  flags - Flags determining Precedence of Macro definitions (see Notes)
//
// Output:
//
// Errors/Warnings:
//  OUT_OF_ENV_SPACE - If putenv() returns failure in adding to the environment.
//
// Assumes:
//  Whatever it assumes
//
// Modifies Globals:
//  fInheritUserEnv - Set to False.
//
// Uses Globals:
//  fInheritUserEnv  - If True then Inherit definition to the Environment.
//  gFlags           - Global Options Flag. If -e specified then Environment Vars
//                       take precedence.
//  macroTable       - NMAKE's internal table of Macro Definitions.
//
// Notes:
//  1> If the same macro is defined in more than one place then NMAKE uses the
//     following order of Precedence (highest to lowest) --
//
//     -1- Command line definitions
//     -2- Description file/Include file definitions
//     -3- Environment definitions
//     -4- TOOLS.INI definitions
//     -5- Predefined Values (e.g. for CC, AS, BC, RC)
//     If -e option is specified then -3- precedes -2-.
//
//  2> Check if the macro already exists in the Macro Table. If the macro is not
//     redefinable (use order of precedence) then return. Make a new string
//     element to hold macro's new value. If the macro does not exist then create
//     new entry in the Macro table. Set Macro's flag to be union of Old and new
//     values. Add the new value to macro's value entry. If a new macro then add
//     it to the macro table. Test for Cyclic definitions.
//
// Undone/Incomplete:
//  1> Investigate into possibility of removing fInheritUserEnv variable.
//      Can be done. Use CANT_REDEFINE(p) || OFF((A)->flags,M_ENVIRONMENT_DEF)
//  2> Probably should warn when $(MAKE) is being changed.

BOOL
putMacro(
    char *name,
    char *value,
    UCHAR flags
    )
{
    MACRODEF *p;
    STRINGLIST *q;
    BOOL defined = FALSE;
    BOOL fSyntax = TRUE;

    // Inherit macro definitions.  Call removeMacros() to expand sub-macro
    // definitions.  Must be done before macro is put in table, else
    // recursive definitions won't work.

    if (ON(flags, M_NON_RESETTABLE)) {
        if (*value)
            if ((putEnvStr(name,removeMacros(value)) == -1))
                makeError(currentLine, OUT_OF_ENV_SPACE);
    } else
    if (fInheritUserEnv &&
        OFF(gFlags, F1_USE_ENVIRON_VARS) &&
        getenv(name)
       ) {
        if (p = findMacro(name)) {  // don't let user
            if (CANT_REDEFINE(p))   // redefine cmdline
                return(FALSE);      // macros, MAKE, etc.
        }
        if ((putEnvStr(name,removeMacros(value)) == -1))
            makeError(currentLine, OUT_OF_ENV_SPACE);
    }

    fInheritUserEnv = (BOOL)FALSE;
    if (p = findMacro(name)) {      // don't let user
        if (CANT_REDEFINE(p))       // redefine cmdline
            return(FALSE);          // macros, MAKE, etc.
    }

    q = makeNewStrListElement();
    q->text = value;

    if (!p) {
        p = makeNewMacro();
        p->name = name;
        assert(p->flags == 0);
        assert(p->values == NULL);
    } else
        defined = TRUE;

    p->flags &= ~M_UNDEFINED;       // Is no longer undefined
    p->flags |= flags;              // Set flags to union of old and new
    prependItem((STRINGLIST**)&(p->values), (STRINGLIST*)q);
    if (!defined)
        insertMacro((STRINGLIST*)p);

    if (OFF(flags, M_LITERAL) && _tcschr(value, '$')) {     // Check for cyclic Macro Definitions
        SET(p->flags, M_EXPANDING_THIS_ONE);
        // NULL -> don't build list
        fSyntax = findMacroValues(value, NULL, NULL, name, 1, 0, flags);
        CLEAR(p->flags, M_EXPANDING_THIS_ONE);
    }

    if (!fSyntax) {
        p->values = NULL;
        p->flags |= M_UNDEFINED;
        //return(FALSE);
		// return TRUE since p has been added to the macro table
		// Otherwise the caller may free name and value leaving
		// dangling pointers in the macro table. [DS 18040]
		return(TRUE);
    }
    return(TRUE);
}


//  makeRule -- makes an inference rule
//
// Scope:
//  Local
//
// Purpose:
//  Allocates space for an inference rule and adds rule to the beginning of the
//  doubly linked inference rule list. The name of the rule is also added.
//
// Input:
//  rule -- The name of the inference rule
//	fBatch -- True if command block should be executed in batch mode
//
// Output:
//
// Errors/Warnings:
//
// Assumes:
//
// Modifies Globals:
//  rules -- The doubly linked inference rule list to which the rule is added
//
// Uses Globals:
//
// Notes:
//  The syntax of an inference rule is --
//
//  {frompath}.fromext{topath}.toext:    # Name of the inference rule
//      command ...                      # command block of the inference rule

void
makeRule(
    STRINGLIST *rule,
	BOOL fBatch
    )
{
    RULELIST *rList;

    rList = makeNewRule();
    rList->name = rule->text;
	rList->fBatch = fBatch;
    prependItem((STRINGLIST**)&rules, (STRINGLIST*)rList);
    if (rList->next)
        rList->next->back = rList;
}


//  makeTarget -- add target to targetTable
//
//  actions:    if no block defined, create one and initialize it
//        make new build list entry for this target
//        if the target's already in the table,
//            flag error if : and :: mixed
//            else add new buildlist object to target's current buildlist
//        else allocate new object, initialize it, and stick it in table

void
makeTarget(
    char *s,
    BOOL firstTarg,
    BUILDBLOCK **block
    )
{
    BUILDLIST  *build;
    MAKEOBJECT *object;

    if (!*block)
        *block = makeNewBuildBlock();

    if (firstTarg) {
        build = makeNewBldListElement();
        build->buildBlock = *block;
    } else
        build = makeBuildList(*block);

    if (object = findTarget(s)) {
        if (ON(object->flags2, F2_DOUBLECOLON) != ON(currentFlags, F2_DOUBLECOLON))
            makeError(currentLine, MIXED_SEPARATORS);
        appendItem((STRINGLIST**)&(object->buildList), (STRINGLIST*)build);
        FREE(s);
    } else {
        build->next = NULL;
        object = makeNewObject();
        object->name = s;
        object->buildList = build;
        object->flags2 = currentFlags;
        prependItem((STRINGLIST**)targetTable+hash(s, MAXTARGET, (BOOL)TRUE),
                    (STRINGLIST*)object);
    }
}


void
clearSuffixes()
{
    STRINGLIST *p;

    while (p = dotSuffixList) {
    dotSuffixList = dotSuffixList->next;
    FREE(p->text);
    FREE_STRINGLIST(p);
    }
}


void
appendPseudoTargetList(
    STRINGLIST **pseudo,
    STRINGLIST *list
    )
{
    STRINGLIST  *p, *q, *r;
    char *t, *u;

    while (p = list) {
        if (!_tcschr(p->text, '$')) {
            list = list->next;
            p->next = NULL;
            appendItem(pseudo, p);
        } else {
            r = macros;
            t = expandMacros(p->text, &macros);
            while (r != macros) {
                q = r->next;
                FREE_STRINGLIST(r);
                r = q;
            }
            for (u = _tcstok(t, " \t"); u; u = _tcstok(NULL, " \t")) {
                q = makeNewStrListElement();
                q->text = makeString(u);
                appendItem(pseudo, q);
            }
            FREE(t);
            FREE(p->text);
            list = list->next;
            FREE_STRINGLIST(p);
        }
    }
}

//  putEnvStr -- Extends putenv() standard function
//
// Purpose:
//  Library function putenv() expects one string argument of the form
//    "NAME=value"
//  Most of the times when putenv() is to be used we have two strings
//    name   -- of the variable to add to the environment, and
//    value  -- to be set
//  putEnvStr takes these 2 parameters and calls putenv with the reqd
//  format
//
// Input:
//  name  -- of var to add to the env
//  value -- reqd to be set
//
// Output:
//  Same as putenv()

int
putEnvStr(
    char *name,
    char *value
    )
{
   char *envPtr;
   envPtr = (char *)rallocate(_tcslen(name)+1+_tcslen(value)+1);
//                                         ^                 ^
//                                    for '='             for '\0'

   return(PutEnv(_tcscat(_tcscat(_tcscpy(envPtr, name), "="), value)));
}


//  makeBuildList -- takes a build block and copies into a buildlist
//
// Purpose:
//  Routine creates a copy of a buildlist and returns a pointer to a copy.
//  When multiple targets have the same description block then there is a
//  need for each of them to get seperate build blocks. makeBuildList()
//  helps achieve this by creating a copy for each target.
//
// Input:
//  bBlock  --  the build block whose copy is to be added to a build block
//
// Output:
//  Returns a pointer to the copy of buildlist it creates

BUILDLIST *
makeBuildList(
    BUILDBLOCK *bBlock
    )
{
    BUILDLIST *tList = makeNewBldListElement();
    BUILDBLOCK *tBlock = makeNewBuildBlock();

    tBlock->dependents = bBlock->dependents;
    tBlock->dependentMacros = bBlock->dependentMacros;
    tBlock->buildCommands = bBlock->buildCommands;
    tBlock->buildMacros = bBlock->buildMacros;
    tBlock->flags = bBlock->flags;
    tBlock->dateTime = bBlock->dateTime;

    tList->buildBlock = tBlock;
    return(tList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\netjoin\netjoin.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <lmcons.h>
#include <stdlib.h>
#include <stdio.h>

#include <crypt.h>      // logonmsv.h needs this
#include <logonmsv.h>   // SSI_SECRET_NAME defined here.

#define TRUST_ENUM_PERF_BUF_SIZE    sizeof(LSA_TRUST_INFORMATION) * 1000
                    // process max. 1000 trusted account records at atime !!

#define NETLOGON_SECRET_NAME  L"NETLOGON$"


NTSTATUS
OpenAndVerifyLSA(
    IN OUT PLSA_HANDLE LsaHandle,
    IN ACCESS_MASK DesiredMask,
    IN LPWSTR DomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO * ReturnPrimaryDomainInfo OPTIONAL
    );

NTSTATUS
AddATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo,
    IN LPWSTR TrustedAccountSecret
    );

NTSTATUS
DeleteATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo
    );

NTSTATUS
MakeNetlogonSecretName(
    IN OUT PUNICODE_STRING SecretName
    );

VOID
FailureMessage(
    IN char *ProcName,
    IN NTSTATUS NtStatus
    );


VOID
FailureMessage(
    IN char *ProcName,
    IN NTSTATUS NtStatus
    )
{
    fprintf( stderr, "NETJOIN: %s failed - Status == %x\n", ProcName, NtStatus );
}

int
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    NTSTATUS NtStatus;

    HKEY hKey;

    WCHAR UnicodeDomainName[ 32 ];
    WCHAR UnicodePassword[ 32 ];
    DWORD cbUnicodePassword = sizeof( UnicodePassword );
    DWORD cbUnicodeDomainName = sizeof( UnicodeDomainName );

    DWORD dwType;
    DWORD rc;

    ACCESS_MASK         DesiredAccess;
    LSA_HANDLE          PolicyHandle = NULL;

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    LSA_ENUMERATION_HANDLE      TrustEnumContext = 0;
    PLSA_TRUST_INFORMATION      TrustEnumBuffer = NULL;
    DWORD                       TrustEnumCount = 0;

    //
    // Get computer name as the password to use.
    //

    if (!GetComputerNameW( UnicodePassword, &cbUnicodePassword )) {
        fprintf( stderr, "NETJOIN: Unable to read computer name from registry - %u\n", GetLastError() );
        exit( 1 );
        }

    if ((rc = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                           L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
                           &hKey
                         )
        ) ||
        (rc = RegQueryValueExW( hKey,
                                L"Domain",
                                NULL,
                                &dwType,
                                (LPBYTE)UnicodeDomainName,
                                &cbUnicodeDomainName
                              )
        )
       ) {
        fprintf( stderr, "NETJOIN: Unable to read domain name from registry - %u\n", rc );
        exit( 1 );
        }

    DesiredAccess = POLICY_VIEW_LOCAL_INFORMATION |
                        // needed to read domain info and trusted account info
                    POLICY_TRUST_ADMIN |
                        // needed to add and delete trust accounts
                    POLICY_CREATE_SECRET ;
                        // needed to add and delete secret

    NtStatus = OpenAndVerifyLSA( &PolicyHandle,
                                 DesiredAccess,
                                 UnicodeDomainName,
                                 &PrimaryDomainInfo
                               );

    if (!NT_SUCCESS( NtStatus )) {
        fprintf( stderr, "NETJOIN: Unable to read domain name from registry - %u\n", GetLastError() );
        exit( 1 );
        }

    //
    // now the domain names match and the PrimaryDomainInfo has the SID of the
    // domain, we can add trust entry and secret in LSA for this domain.
    // Before adding this, clean up old entries.
    //

    for(;;) {

        DWORD i;
        PLSA_TRUST_INFORMATION  TrustedDomainAccount;

        NtStatus = LsaEnumerateTrustedDomains( PolicyHandle,
                                               &TrustEnumContext,
                                               (PVOID *)&TrustEnumBuffer,
                                               TRUST_ENUM_PERF_BUF_SIZE,
                                               &TrustEnumCount
                                             );

        if (NtStatus == STATUS_NO_MORE_ENTRIES) {

            //
            // we are done
            //

            break;
            }

        if (NtStatus != STATUS_MORE_ENTRIES) {
            if (!NT_SUCCESS( NtStatus )) {
                FailureMessage( "LsaEnumerateTrustedDomains", NtStatus );
                goto Cleanup;
                }
            }

        //
        // delete trusted accounts and the corresponding secrets
        //

        for( i = 0, TrustedDomainAccount = TrustEnumBuffer;
                    i < TrustEnumCount;
                        TrustedDomainAccount++, i++ ) {

            NtStatus = DeleteATrustedDomain( PolicyHandle,
                                             TrustedDomainAccount
                                           );

            if (!NT_SUCCESS( NtStatus )) {
                FailureMessage( "DeleteATrustedDomain", NtStatus );
                goto Cleanup;
                }
            }

        if (NtStatus != STATUS_MORE_ENTRIES) {

            //
            // we have cleaned up all old entries.
            //

            break;
            }

        //
        // free up used enum buffer
        //

        if (TrustEnumBuffer != NULL) {
            LsaFreeMemory( TrustEnumBuffer );
            TrustEnumBuffer = NULL;
            }
        }

    //
    // add a new trust for the specified domain
    //

    NtStatus = AddATrustedDomain( PolicyHandle,
                                  (PLSA_TRUST_INFORMATION) PrimaryDomainInfo,
                                  UnicodePassword
                                );
    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain", NtStatus );
        }
    else {
        //
        // Give LSA a chance to do its thing.
        //

        Sleep( 10000 );
        }

Cleanup:

    if (PrimaryDomainInfo != NULL) {
        LsaFreeMemory( PrimaryDomainInfo );
        }

    if (TrustEnumBuffer != NULL) {
        LsaFreeMemory( TrustEnumBuffer );
        }

    if (PolicyHandle != NULL) {
        LsaClose( PolicyHandle );
        }

    if (NT_SUCCESS( NtStatus )) {
        fprintf( stderr,
                 "NETJOIN: Computer == '%ws' joined the '%ws' domain.\n",
                 UnicodePassword,
                 UnicodeDomainName
               );
        return 0;
        }
    else {
        fprintf( stderr,
                 "NETJOIN: Computer == '%ws' unable to join the '%ws' domain - Status == %08x\n",
                 UnicodePassword,
                 UnicodeDomainName,
                 NtStatus
               );
        return 1;
        }
}


NTSTATUS
OpenAndVerifyLSA(
    IN OUT PLSA_HANDLE PolicyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN LPWSTR DomainName,
    OUT PPOLICY_PRIMARY_DOMAIN_INFO * ReturnPrimaryDomainInfo OPTIONAL
    )
/*++

Routine Description:

    This function opens the local LSA policy and verifies that the LSA is
    configured for the workstation. Optionally it returns the primary
    domain information that is read form the LSA.

Arguments:

    LsaHandle - Pointer to location where the LSA handle will be retured.

    DesiredMask - Access mask used to open the LSA.

    DomainName - Name of the trusted domain.

    ReturnPrimaryDomainInfo - Primary domain info is returned here.

Return Value:

    Error code of the operation.

--*/
{
    NTSTATUS        NtStatus;

    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    OBJECT_ATTRIBUTES   ObjectAttributes;

    DWORD       PrimaryDomainNameLength;
    LPWSTR      PrimaryDomainName = NULL;

    //
    // open LSA

    *PolicyHandle = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0,
                                NULL,
                                NULL
                              );

    NtStatus = LsaOpenPolicy( NULL,
                              &ObjectAttributes,
                              DesiredAccess,
                              PolicyHandle
                            );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "OpenAndVerifyLSA: LsaOpenPolicy", NtStatus );
        return NtStatus;
        }

    //
    // now read primary domain info from LSA.
    //

    NtStatus = LsaQueryInformationPolicy( *PolicyHandle,
                                          PolicyPrimaryDomainInformation,
                                          (PVOID *) &PrimaryDomainInfo
                                        );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "OpenAndVerifyLSA: LsaQueryInformationPolicy", NtStatus );
        return NtStatus;
        }


    //
    // compare domain names
    //

    PrimaryDomainNameLength = PrimaryDomainInfo->Name.Length + sizeof( WCHAR );
    PrimaryDomainName = malloc( PrimaryDomainNameLength );
    if (PrimaryDomainName == NULL) {
        NtStatus = STATUS_NO_MEMORY;
        FailureMessage( "OpenAndVerifyLSA: malloc", NtStatus );
        goto Cleanup;
        }

    RtlMoveMemory( PrimaryDomainName,
                   PrimaryDomainInfo->Name.Buffer,
                   PrimaryDomainInfo->Name.Length
                 );
    PrimaryDomainName[ PrimaryDomainInfo->Name.Length / sizeof(WCHAR) ] = UNICODE_NULL;
    if (_wcsicmp( DomainName, PrimaryDomainName )) {

        //
        // domain names don't match
        //

        NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        FailureMessage( "OpenAndVerifyLSA: wcsicmp", NtStatus );
        goto Cleanup;
        }


    NtStatus = STATUS_SUCCESS;

Cleanup:

    if (PrimaryDomainName != NULL) {
        free( PrimaryDomainName );
        }

    if (PrimaryDomainInfo != NULL) {
        if (ARGUMENT_PRESENT( ReturnPrimaryDomainInfo ) ) {
            if (NT_SUCCESS( NtStatus )) {

                *ReturnPrimaryDomainInfo = PrimaryDomainInfo;
            }
            else {

                LsaFreeMemory( PrimaryDomainInfo );
                *ReturnPrimaryDomainInfo = NULL;
            }
        }
        else {
            LsaFreeMemory( PrimaryDomainInfo );
            }
        }

    if (!NT_SUCCESS( NtStatus ) && *PolicyHandle != NULL) {
        //
        // close LSA if an error occurred.
        //

        LsaClose( *PolicyHandle );
        *PolicyHandle = NULL;
        }

    return NtStatus;
}


#if 0
NET_API_STATUS NET_API_FUNCTION
I_NetGetDCList(
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    );
#endif


NTSTATUS
AddATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo,
    IN LPWSTR TrustedAccountSecret
    )
/*++

Routine Description:

    This function adds trusted domain account and a secret for the
    corresponding account in LSA. This function does not do any check
    before adding this account in LSA.

Arguments:

    PolicyHandle - LSA policy handle

    TrustedDomainAccountInfo - Pointer to the LSA_TRUST_INFORMATION structure.

    TrustedAccountSecret - Pointer to the secret for the trusted domain
                            account.

Return Value:

    Error code of the operation.

--*/
{

    NTSTATUS        NtStatus;

    LSA_HANDLE      TrustedDomainHandle = NULL;

    DWORD           DCCount;
    PUNICODE_STRING DCNames = NULL;

    TRUSTED_CONTROLLERS_INFO    TrustedControllersInfo;

    UNICODE_STRING  SecretName = {0, 0, NULL};
    LSA_HANDLE      SecretHandle = NULL;

    UNICODE_STRING  CurrentSecretValue;

    DWORD           UnicodeDomainNameLength;
    LPWSTR          UnicodeDomainName = NULL;

    NtStatus = LsaCreateTrustedDomain( PolicyHandle,
                                       TrustedDomainAccountInfo,
                                       TRUSTED_SET_CONTROLLERS | DELETE,
                                       &TrustedDomainHandle
                                     );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaCreateTrustedDomain", NtStatus );
        return NtStatus;
        }

    //
    // Determine the DC List. This list will be stored in trusted domain
    // account.
    //
    // Specify the server name NULL, the domain name is the primary domain
    // of this workstation and so it must be listening DC announcements.
    //

    UnicodeDomainNameLength = TrustedDomainAccountInfo->Name.Length +
                                sizeof(WCHAR);
    UnicodeDomainName = malloc( UnicodeDomainNameLength );
    if (UnicodeDomainName == NULL) {
        NtStatus = STATUS_NO_MEMORY;
        FailureMessage( "AddATrustedDomain: malloc", NtStatus );
        goto Cleanup;
        }

    RtlMoveMemory( UnicodeDomainName,
                   TrustedDomainAccountInfo->Name.Buffer,
                   TrustedDomainAccountInfo->Name.Length
                 );

    UnicodeDomainName[ (UnicodeDomainNameLength / sizeof(WCHAR)) - 1 ] = '\0';

#if 0
    if (I_NetGetDCList( NULL,
                        UnicodeDomainName,
                        &DCCount,
                        &DCNames
                      )
       ) {
        //
        // if unable to find the DC list for the specified domain, set
        // the Dc list to null and proceed.
        //
        DCCount = 0;
        DCNames = NULL;
        }
#else
        DCCount = 0;
        DCNames = NULL;
#endif

    TrustedControllersInfo.Entries = DCCount;
    TrustedControllersInfo.Names = DCNames;

    //
    // set controller info in trusted domain object.
    //

    NtStatus = LsaSetInformationTrustedDomain( TrustedDomainHandle,
                                               TrustedControllersInformation,
                                               &TrustedControllersInfo
                                             );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaSetInformationTrustedDomain", NtStatus );
        goto Cleanup;
        }

    //
    // Add a secret for this trusted account
    //

    MakeNetlogonSecretName( &SecretName );
    NtStatus = LsaCreateSecret( PolicyHandle,
                                &SecretName,
                                SECRET_SET_VALUE,
                                &SecretHandle
                              );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "AddATrustedDomain: LsaCreateSecret", NtStatus );
        goto Cleanup;
        }


    RtlInitUnicodeString( &CurrentSecretValue, TrustedAccountSecret );
    NtStatus = LsaSetSecret( SecretHandle,
                             &CurrentSecretValue,
                             &CurrentSecretValue
                           );

Cleanup:

    if (DCNames != NULL) {
        free( DCNames );
        }

    if (UnicodeDomainName != NULL) {
        free( UnicodeDomainName );
        }

    if (SecretHandle != NULL) {
        if (!NT_SUCCESS( NtStatus)) {

            //
            // since we are not successful completely to create the trusted
            // account, delete it.
            //

            LsaDelete( SecretHandle );
            }
        else {
            LsaClose( SecretHandle );
            }
        }


    if (TrustedDomainHandle != NULL) {
        if (!NT_SUCCESS( NtStatus)) {
            //
            // since we are not successful completely to create the trusted
            // account, delete it.
            //

            LsaDelete( TrustedDomainHandle );
            }
        else {
            LsaClose( TrustedDomainHandle );
            }
        }

    return NtStatus;
}


NTSTATUS
DeleteATrustedDomain(
    IN LSA_HANDLE PolicyHandle,
    IN PLSA_TRUST_INFORMATION TrustedDomainAccountInfo
    )
/*++

Routine Description:

    This function deletes a trusted domain account and the corresponding
    secret from LSA. This function however does not check any conditions
    before deleting this account.

Arguments:

    PolicyHandle - LSA policy handle

    TurstedDoaminAccountInfo - Pointer to the LSA_TRUST_INFORMATION structure.

Return Value:

    Error code of the operation.

--*/
{

    NTSTATUS        NtStatus;

    LSA_HANDLE      TrustedDomainHandle = NULL;
    LSA_HANDLE      SecretHandle = NULL;

    UNICODE_STRING  SecretName = { 0, 0, NULL };

    MakeNetlogonSecretName( &SecretName );

    //
    // open trusted domain account secret
    //

    NtStatus = LsaOpenSecret(
                    PolicyHandle,
                    &SecretName,
                    DELETE,
                    &SecretHandle );

    if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
        if (!NT_SUCCESS( NtStatus )) {
            FailureMessage( "DeleteATrustedDomain: LsaOpenSecret", NtStatus );
            goto Cleanup;
            }

        LsaDelete( SecretHandle );
        }

    //
    // open trusted domain account
    //

    NtStatus = LsaOpenTrustedDomain(
                    PolicyHandle,
                    TrustedDomainAccountInfo->Sid,
                    DELETE,
                    &TrustedDomainHandle );

    if (!NT_SUCCESS( NtStatus )) {
        FailureMessage( "DeleteATrustedDomain: LsaOpenTrustedDomain", NtStatus );
        goto Cleanup;
        }

    LsaDelete( TrustedDomainHandle );

Cleanup:

    return NtStatus;

}

NTSTATUS
MakeNetlogonSecretName(
    IN OUT PUNICODE_STRING SecretName
    )
/*++

Routine Description:

    This function makes a secret name that is used for the netlogon.

Arguments:

    SecretName - Pointer to a unicode structure in which the netlogon
                    secret name will be returned.

Return Value:

    NERR_Success;

--*/
{

    SecretName->Length = wcslen(SSI_SECRET_NAME) * sizeof(WCHAR);
    SecretName->MaximumLength = SecretName->Length + 2;
    SecretName->Buffer = SSI_SECRET_NAME;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\charmap.cpp ===
#include "precomp.h"
#pragma hdrstop

//
// Map to determine characteristics of text
//
UCHAR   Charmap[CHARMAP_SIZE] = {
LX_EOS,         // 0x0, <end of string marker>
LX_ILL,         // 0x1
LX_ILL,         // 0x2
LX_ILL,         // 0x3
LX_ILL,         // 0x4
LX_ILL,         // 0x5
LX_ILL,         // 0x6
LX_ILL,         // 0x7
LX_ILL,         // 0x8
LX_WHITE,       // <horizontal tab>
LX_NL,          // <newline>
LX_WHITE,       // <vertical tab>
LX_WHITE,       // <form feed>
LX_CR,          // <really a carriage return>
LX_ILL,         // 0xe
LX_ILL,         // 0xf
LX_ILL,         // 0x10
LX_ILL,         // 0x11
LX_ILL,         // 0x12
LX_ILL,         // 0x13
LX_ILL,         // 0x14
LX_ILL,         // 0x15
LX_ILL,         // 0x16
LX_ILL,         // 0x17
LX_ILL,         // 0x18
LX_ILL,         // 0x19
LX_EOS,         // 0x1a, ^Z
LX_ILL,         // 0x1b
LX_ILL,         // 0x1c
LX_ILL,         // 0x1d
LX_ILL,         // 0x1e
LX_ILL,         // 0x1f
LX_WHITE,       // 0x20
LX_OPERATOR,    // !
LX_DQUOTE,      // "
LX_POUND,       // #
LX_ASCII,       // $
LX_OPERATOR,    // %
LX_OPERATOR,    // &
LX_SQUOTE,      // '
LX_OPERATOR,    // (
LX_OPERATOR,    // )
LX_OPERATOR,    // *
LX_OPERATOR,    // +
LX_COMMA,       // ,
LX_MINUS,       // -
LX_DOT,         // .
LX_OPERATOR,    // /
LX_NUMBER,      // 0
LX_NUMBER,      // 1
LX_NUMBER,      // 2
LX_NUMBER,      // 3
LX_NUMBER,      // 4
LX_NUMBER,      // 5
LX_NUMBER,      // 6
LX_NUMBER,      // 7
LX_NUMBER,      // 8
LX_NUMBER,      // 9
LX_COLON,       // :
LX_SEMI,        // ;
LX_OPERATOR,    // <
LX_OPERATOR,    // =
LX_OPERATOR,    // >
LX_EOS,         // ?
LX_EACH,        // @
LX_ID,          // A
LX_ID,          // B
LX_ID,          // C
LX_ID,          // D
LX_ID,          // E
LX_ID,          // F
LX_ID,          // G
LX_ID,          // H
LX_ID,          // I
LX_ID,          // J
LX_ID,          // K
LX_ID,          // L
LX_ID,          // M
LX_ID,          // N
LX_ID,          // O
LX_ID,          // P
LX_ID,          // Q
LX_ID,          // R
LX_ID,          // S
LX_ID,          // T
LX_ID,          // U
LX_ID,          // V
LX_ID,          // W
LX_ID,          // X
LX_ID,          // Y
LX_ID,          // Z
LX_OBRACK,      // [
LX_EOS,         // \ (backslash)
LX_CBRACK,      // ]
LX_OPERATOR,    // ^
LX_MACRO,       // _
LX_ASCII,       // `
LX_ID,          // a
LX_ID,          // b
LX_ID,          // c
LX_ID,          // d
LX_ID,          // e
LX_ID,          // f
LX_ID,          // g
LX_ID,          // h
LX_ID,          // i
LX_ID,          // j
LX_ID,          // k
LX_ID,          // l
LX_ID,          // m
LX_ID,          // n
LX_ID,          // o
LX_ID,          // p
LX_ID,          // q
LX_ID,          // r
LX_ID,          // s
LX_ID,          // t
LX_ID,          // u
LX_ID,          // v
LX_ID,          // w
LX_ID,          // x
LX_ID,          // y
LX_ID,          // z
LX_OBRACE,      // {
LX_OPERATOR,    // |
LX_CBRACE,      // }
LX_OPERATOR,    // ~
LX_ILL,         // 0x7f
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO, LX_MACRO,
};

void initCharmap(void)
{
    int i;
    for (i = 0; i <= 127; i++) {

        // Initialize valid macro chars (besides '_' and >= 128)
        if (_istalnum(i)) {
            Charmap[i] |= LX_MACRO;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\command.cpp ===
//  COMMAND.C - NMAKE 'command line' handling routines
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to handle NMAKE 'command line' syntax. NMAKE can be
//  optionally called by using the syntax 'NMAKE @commandfile'. This allows more
//  flexibility and preents a way of getting around DOS's 128-byte limit on the
//  length of a command line. Additionally, it saves keystrokes for frequently
//  run commands for NMAKE.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JR  Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  14-Aug-1992 SS  CAVIAR 2735: handle quoted macro values in command files
//  02-Feb-1990 SB  Replace fopen() by FILEOPEN
//  01-Dec-1989 SB  Changed realloc() to REALLOC()
//  22-Nov-1989 SB  Changed free() to FREE()
//  17-Aug-1989 SB  Add error check to closing file
//  05-Apr-1989 SB  made func calls NEAR to put all funcs into 1 module
//  20-Oct-1988 SB  Notes added to readCommandFile()
//  17-Aug-1988 RB  Clean up.

#include "precomp.h"
#pragma hdrstop

void addArgument(char*,unsigned,char***);
void processLine(char*,unsigned*,char***);
void tokenizeLine(char*,unsigned*,char***);

// readCommandFile()
//
// arguments:  name    pointer to name of command file to read
//
// actions:    opens command file
//             reads in lines and calls processLine() to
//               break them into tokens and to build
//               an argument vector (a la argv[])
//             calls parseCommandLine() recursively to process
//               the accumulated "command line" arguments
//             frees space used by the arg vector
//
// modifies:   makeFiles   in main() by modifying contents of parameter list
//             makeTargets in main() by modifying contents of targets parameter
//             buf         global buffer
//
// notes:      function is not ANSI portable because it uses fopen()
//             with "rt" type and text mode is a Microsoft extension
//

void
readCommandFile(
    char *name
    )
{
    char *s,                        // buffer
         **vector;                  // local versions of arg vector
    unsigned count = 0;             // count
    size_t n;

    if (!(file = FILEOPEN(name,"rt")))
        makeError(0,CANT_OPEN_FILE,name);
    vector = NULL;                      // no args yet
    while (fgets(buf,MAXBUF,file)) {
        n = _tcslen(buf);

        // if we didn't get the whole line, OR the line ended with a backSlash

        if ((n == MAXBUF-1 && buf[n-1] != '\n') ||
            (buf[n-1] == '\n' && buf[n-2] == '\\')
           ) {
            if (buf[n-2] == '\\' && buf[n-1] == '\n') {
                // Replace \n by \0 and \\ by a space; Also reset length
                buf[n-1] = '\0';
                buf[n-2] = ' ';
                n--;
            }
            s = makeString(buf);
            getRestOfLine(&s,&n);
        } else
            s = buf;

        processLine(s,&count,&vector);  // separate into args
        if (s != buf)
            FREE(s);
    }

    if (fclose(file) == EOF)
        makeError(0, ERROR_CLOSING_FILE, name);

    parseCommandLine(count,vector);     // evaluate the args
    while (count--)                     // free the arg vector
        if(vector[count])
            FREE(vector[count]);        // NULL entries mean that the space the
}                                       //  entry used to pt to is still in use


// getRestOfLine()
//
// arguments:   s    pointer to readCommandFile()'s buffer
//                    holding line so far
//              n    pointer to readCommandFile()'s count of
//                    the chars in *s
//
// actions:     keeps reading in text until it sees a newline
//              or the end of file
//              reallocs space for the old buffer plus the
//               contents of the new buffer each time
//              appends new buffer's text to existing text
//
// modifies:    s    readCommandFile()'s text buffer by realloc'ing
//                    more space for incoming text
//              n    readCommandFile()'s count of bytes in s
//              buf  global buffer

void
getRestOfLine(
    char *s[],
    size_t *n
    )
{
    size_t temp;
    char *t;

    t = buf;
    while ((*s)[*n-1] != '\n') {    // get rest of line
        if (!fgets(t,MAXBUF,file))
            break;                  // we hit EOF
        temp = _tcslen(t);
        if (t[temp-2] == '\\' && t[temp-1] == '\n') {
            //Replace \n by \0 and \\ by a space; Also reset length
            t[temp-1] = '\0';
            t[temp-2] = ' ';
        }
        temp = *n;
        *n += _tcslen(t);
        *s = (char *) REALLOC(*s,*n+1);     // + 1 for NULL byte
        if (!*s)
            makeError(line, MACRO_TOO_LONG);
        _tcscpy(*s+temp,t);
    }
}


// processLine()
//
// arguments:  s       pointer to readCommandFile()'s buffer
//                       holding "command line" to be processed
//             count   pointer to readCommandFile()'s count of
//                       "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                       pointers to character strings
//
// actions:    if the line to be broken into "command line arguments" contains '"'
//             breaks all the text before '"' into tokens
//             delimited by whitespace (which get put in vector[] by
//              tokenizeLine())
//             finds the closing '"' and treats the quoted string
//              as a single token, adding it to the vector
//             recurses on the tail of the line (to check for
//              other quoted strings)
//             else breaks all text in line into tokens delimited
//              by whitespace
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             count   readCommandFile()'s count of the arguments in
//                      the vector (by modifying the contents of the
//                      parameter pointer, count)

void
processLine(
    char *s,
    unsigned *count,
    char **vector[]
    )
{
    char *t;
    char *u;
    size_t m;
    size_t n;
    BOOL allocFlag = FALSE;

    if (!(t = _tcschr(s,'"'))) {            // no quoted strings,
        tokenizeLine(s,count,vector);       // just standard fare
    } else {
        // There are two kinds of situations in which quotes can occur:
        //   1. "FOO = bar baz"
        //   2. FOO="bar baz"

        if ((t == s) || (*(t-1) != '='))  {
            // Case 1 above
            *t++ = '\0';                    // quoted macrodef
            tokenizeLine(s,count,vector);   // get tokens before "
        } else {
            // Case 2 above
            *t-- = ' ';
            for (u = t; u > s; --u) //    find the beginning of the macro name
                if (*u == ' ' || *u == '\t' || *u == '\n')
                    break;

            if (u != s) {
                *u++ = '\0';
                tokenizeLine(s, count, vector);
            }

            t = u;
        }

        n = _tcslen(t);
        for (u = t; *u; ++u) {              // look for closing "
            if (*u == '"') {                // need " and not ""
                if (*(u+1) == '"') {
                    _tcscpy(u,u+1);
                    continue;
                }
                *u++ = '\0';                // terminate macrodef
                addArgument(t,*count,vector);   // treat as one arg
                ++*count;
                processLine(u+1,count,vector);  // recurse on rest of line
                break;
            }                       // TAIL RECURSION -- eliminate later?

            if ((*u == '\\')
                && WHITESPACE(*(u-1))
                && (*(u+1) == '\n')) {      // \n always last char
                *u = '\0';                  // 2 chars go to 1
                m = (n = n-2);              // adjust length count
                if (!allocFlag) {
                    allocFlag = TRUE;
                    t = makeString(t);
                }
                getRestOfLine(&t,&n);       // get some more text
                u = t + m ;                 // reset u & continue looping
            }
        }

        if (u == t + n) {                   // if at end of line
            makeError(0,SYNTAX_NO_QUOTE);   // and no ", error
        }

        if (allocFlag) {
            FREE(t);
        }
    }
}


// tokenizeLine()
//
// arguments:  s       pointer to readCommandFile()'s buffer
//                      holding "command line" to be tokenized
//             count   pointer to readCommandFile()'s count of
//                      "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                      pointers to character strings
//
// actions:    breaks the line in s into tokens (command line
//              arguments) delimited by whitespace
//             adds each token to the argument vector
//             adjusts the argument counter
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             count   readCommandFile()'s count of the arguments in
//                      the vector (by modifying the contents of the
//                      parameter pointer, count)
//
// If the user ever wants '@' to be part of an argument in a command file,
// he has to enclose that argument in quotation marks.

void
tokenizeLine(                       // gets args delimited
    char *s,                        // by whitespace and
    unsigned *count,                // constructs an arg
    char **vector[]                 // vector
    )
{
    char *t;

    if (t = _tcschr(s,'\\')) {
        if (WHITESPACE(*(t-1)) && (*(t+1) == '\n')) {
            *t = '\0';
        }
    }

    for (t = _tcstok(s," \t\n"); t; t = _tcstok(NULL," \t\n")) {
        if (*t == '@') {
            makeError(0,SYNTAX_CMDFILE,t+1);
            break;                  // should we keep on parsing here?
        }
        addArgument(t,*count,vector);
        ++*count;
    }
}


// addArgument()
//
// arguments:  s       pointer to text of argument to be added
//                      to the "command line argument" vector
//             count   pointer to readCommandFile()'s count of
//                      "command line" arguments seen so far
//             vector  pointer to readCommandFile()'s vector of
//                      pointers to character strings
//
// actions:    allocates space in the vector for the new argument
//             allocates space for argument string
//             makes vector entry point to argument string
//
// modifies:   vector  readCommandFile()'s vector of pointers to
//                      "command line argument" strings (by modifying
//                      the contents of the parameter pointer, vector)
//             (count gets incremented by caller)
//
// To keep from fragmenting memory by doing many realloc() calls for very
// small amounts of space, we get memory in small chunks and use that until
// it is depleted, then we get another chunk . . . .

void
addArgument(                        // puts s in vector
    char *s,
    unsigned count,
    char **vector[]
    )
{
    if (!(*vector)) {
        *vector = (char**) allocate(CHUNKSIZE*sizeof(char*));
    } else if (!(count % CHUNKSIZE)) {
        *vector = (char**) REALLOC(*vector,(count+CHUNKSIZE)*sizeof(char*));
        if (!*vector) {
            makeError(0,OUT_OF_MEMORY);
        }
    }
    (*vector)[count] = makeString(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\getmsg.h ===
// getmsg.h

#ifndef __GETMSG_H__
#define __GETMSG_H__

char *  get_err(int);
int SetErrorFile(char *szFilename, char *szExeName, int fSearchExePath);
long SetHInstace(long hInstModule);

#endif __GETMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\getrcmsg.c ===
// getrcmsg.c

#include "windows.h"

static HINSTANCE    hInstModule = NULL;

HINSTANCE
SetHInstance(HINSTANCE h)
{
    HINSTANCE   hRet = hInstModule;
    hInstModule = h;
    return hRet;
}

char  *
get_err(int msg_num)
{

    static char rgchErr[1024];

#if !defined(HARD_LINK)
    static HMODULE hmodUser32;
    static int (WINAPI *pfnLoadStringA)(HINSTANCE, UINT, LPSTR, int);

    if (hmodUser32 == NULL) {
        hmodUser32  = LoadLibrary("USER32.DLL");

        if (hmodUser32 == NULL) {
            return NULL;
        }
    }

    if (pfnLoadStringA == NULL) {
        pfnLoadStringA = (int (WINAPI *)(HINSTANCE, UINT, LPSTR, int))
                             GetProcAddress(hmodUser32, "LoadStringA");

        if (pfnLoadStringA == NULL) {
            return NULL;
        }
    }

    if ((*pfnLoadStringA)(hInstModule, msg_num, rgchErr, sizeof(rgchErr)) == 0) {
        rgchErr[0] = '\0';
    }
#else
#pragma comment(lib, "user32")

    if (LoadString(hInstModule, msg_num, rgchErr, sizeof(rgchErr)) == 0) {
        rgchErr[0] = '\0';
    }
#endif
    return rgchErr;
}

int
SetErrorFile(char *pFilename, char *pExeName, int fSearchExePath)
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\globals.cpp ===
//  globals.c - global variables/needed across modules
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This is the routine in which global variables reside.
//
// HackAlert:
//  The functionality explained in the Notes below work only because of the way
//  Microsoft Compiler's upto C6.0A allocate initialized data ... in the order
//  in which it is specified. All variables between startOfSave and endOfSave
//  have to be initialized. According to ChuckG this functionality is not
//  guaranteed in C7.0 and so these should be moved to a struct.
//
// Notes:
//  This module was created for an interesting reason. NMAKE handles recursive
//  calls by saving its global variables somewhere in memory. It handles this by
//  allocating all global variables which have value changes in each recursive
//  in adjacent memory. The routine called recursively is doMake() and before it
//  is called the address of this chunk of memory is stored. When the recursive
//  call returns the memory is restored using the stored address. startOfSave and
//  endOfSave give the location of this chunk. The reason this method was opted
//  for is that spawning of NMAKE would consume a lot of memory under DOS. This
//  might not be very efficient under OS/2 because the code gets shared.
//
// Revision History:
//  15-Nov-1993 JR Major speed improvements
//  04-Apr-1990 SB Add fHeapChk
//  01-Dec-1989 SB Made some variables near and pushed some into saveArea
//  19-Oct-1989 SB variable fOptionK added (ifdef SLASHK)
//  02-Oct-1989 SB add dynamic inline file handling support
//  18-May-1989 SB Support of H and NOLOGO in MAKEFLAGS
//  24-Apr-1989 SB Added ext_size, filename_size, filenameext_size &
//                  resultbuf_size for OS/2 1.2 support
//  05-Apr-1989 SB made revList, delList, scriptFileList NEAR
//  22-Mar-1989 SB removed tmpFileStack and related variables
//  16-Feb-1989 SB added delList to have scriptfile deletes at end of make
//  21-Dec-1988 SB Added scriptFileList to handle multiple script files
//                  removed tmpScriptFile and fKeep (not reqd anymore)
//  19-Dec-1988 SB Added fKeep to handle KEEP/NOKEEP
//  14-Dec-1988 SB Added tmpScriptFile to handle 'z' option
//  30-Nov-1988 SB Added revList to handle 'z' option
//  23-Nov-1988 SB Added CmdLine[] to handle extmake syntax
//                  made pCmdLineCopy Global in build.c
//  21-Oct-1988 SB Added fInheritUserEnv to inherit macros
//  15-Sep-1988 RB Move some def's here for completeness.
//  17-Aug-1988 RB Declare everything near.
//  06-Jul-1988 rj Ditched shell and argVector globals.

#include "precomp.h"
#pragma hdrstop

#if defined(STATISTICS)
unsigned long CntfindMacro;
unsigned long CntmacroChains;
unsigned long CntinsertMacro;
unsigned long CntfindTarget;
unsigned long CnttargetChains;
unsigned long CntStriCmp;
unsigned long CntunQuotes;
unsigned long CntFreeStrList;
unsigned long CntAllocStrList;
#endif

BOOL          fOptionK;             // TRUE if user specifies /K
BOOL          fDescRebuildOrder;    // TRUE if user specifies /O
BOOL          fSlashKStatus = TRUE; // no error when slash K specified


// Used by action.c & nmake.c
//
// Required to make NMAKE inherit user modified changes to the environment. To
// be set to true before defineMacro() is called so that user defined changes
// in environment variables are reflected in the environment. If set to false
// then these changes are made only in NMAKE tables and the environment remains
// unchanged

BOOL          fInheritUserEnv;

BOOL fRebuildOnTie;                 //  TRUE if /b specified, Rebuild on tie

// Used by action.c and nmake.c
//
// delList is the list of delete commands for deleting inline files which are
// not required anymore (have a NOKEEP action specified.

STRINGLIST  * delList;

// Complete list of generated inline files. Required to avoid duplicate names
// NOTNEEDED

STRINGLIST  * inlineFileList;

// from NMAKE.C
      // No of blanks is same as no of Allowed options in NMAKE; currently 14
      // L = nologo, H = help
      //      corr to                  ABCDEHIKLNPQRSTUY?
char          makeflags[] = "MAKEFLAGS=                  ";
BOOL          firstToken;           // to initialize parser
BOOL          bannerDisplayed;
UCHAR         flags;                // holds -d -s -n -i -u
UCHAR         gFlags;               // "global" -- all targets
FILE        * file;
STRINGLIST  * makeTargets;          // list of targets to make
STRINGLIST  * makeFiles;            // user can specify > 1
BOOL          fDebug;
MACRODEF    * pMacros;
STRINGLIST  * pValues;

// from LEXER.C
BOOL          colZero       = TRUE; // global flag set if at column zero of a makefile/tools.ini
unsigned      line;
char        * fName;
char        * string;
INCLUDEINFO   incStack[MAXINCLUDE]; //Assume this is initialized to null
int           incTop;

// Inline file list -- Gets created in lexer.c and is used by action.c to
// produce a delete command when 'NOKEEP' or Z option is set
//
SCRIPTLIST  * scriptFileList;

// from PARSER.C
BOOL          init;                 // global boolean value to indicate if tools.ini is being parsed
UCHAR         stack[STACKSIZE];
int           top       = -1;       // gets pre-incremented before use
unsigned      currentLine;          // used for all error messages

// from ACTION.C


MACRODEF    * macroTable[MAXMACRO];
MAKEOBJECT  * targetTable[MAXTARGET];
STRINGLIST  * macros;
STRINGLIST  * dotSuffixList;
STRINGLIST  * dotPreciousList;
RULELIST    * rules;
STRINGLIST  * list;
char        * name;
BUILDBLOCK  * block;
UCHAR         currentFlags;
UCHAR         actionFlags;

// from BUILD.C


unsigned      errorLevel;
unsigned      numCommands;
char        * shellName;
char        * pCmdLineCopy;
char          CmdLine[MAXCMDLINELENGTH];

// from IFEXPR.C

UCHAR         ifStack[IFSTACKSIZE];
int           ifTop     = -1;       // pre-incremented
char        * lbufPtr;              // ptr to alloced buf
char        * prevDirPtr;           // ptr to directive
unsigned      lbufSize;             // initial size
int           chBuf     = -1;


// from UTIL.C

char        * dollarDollarAt;
char        * dollarLessThan;
char        * dollarStar;
char        * dollarAt;
STRINGLIST  * dollarQuestion;
STRINGLIST  * dollarStarStar;

// from parser.c

char          buf[MAXBUF];

// from action.c

const char    suffixes[]  = ".SUFFIXES";
const char    ignore[]    = ".IGNORE";
const char    silent[]    = ".SILENT";
const char    precious[]  = ".PRECIOUS";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\file.cpp ===
//  FILE.C -- Utilities for File handling
//
//    Copyright (c) 1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains routines that help in file handling. These routines
//  have a behaviour which depends upon the Operating System Version.
//
// Revision History:
//   08-Jun-1992 SS Port to DOSX32
//   20-Apr-1989 SB Created
//
// Notes:   Created to give OS/2 Version 1.2 filename support.

#include "precomp.h"
#pragma hdrstop

#define bitsin(type)   sizeof(type) * 8

//  getFileName -- get file name from struct
//
// Purpose: returns filename from file search structure passed to it.
//
// Input:   findBuf -- address of pointer to structure
//
// Output:  Returns a pointer to filename in the file search structure.
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t         :    DOS         Real Mode
//      _finddata_t    :    FLAT        Protect Mode
//
// Notes:   The functionality depends upon the OS version and mode

char *
getFileName(
    void *findBuf
    )
{
    char *fileName;

    fileName = ((struct _finddata_t *) findBuf)->name;

    return(fileName);
}

//  getDateTime -- get file timestamp from struct
//
// Purpose: returns timestamp from the file search structure passed to it.
//
// Input:   findBuf -- address of pointer to structure
//
// Output:  Returns timestamp of the file in the structure
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t         :    DOS     Real Mode
//      _finddata_t    :    FLAT    Protect Mode
//
// Notes:
//  The timestamp is an unsigned long value that gives the date and time of last
//  change to the file. If the date is high byte then two times of creation of
//  two files can be compared by comparing their timestamps. This is easy in the
//  DOS struct but becomes complex for the OS/2 structs because the order of date
//  and time has been reversed (for some unexplicable reason).
//
//  The functionality depends upon the OS version and mode.

time_t
getDateTime(
    const _finddata_t *pfd
    )
{
    time_t  dateTime;

    if( pfd->attrib & _A_SUBDIR ) {
        // subdir return create date
        if (pfd->time_create == -1) {
            // except on FAT
            dateTime = pfd->time_write;
        }
        else {
            dateTime = pfd->time_create;
        }
    }
    else {
        dateTime = pfd->time_write ;
    }

    return dateTime;
}

//  putDateTime -- change the timestamp in the struct
//
// Purpose: changes timestamp in the file search structure passed to it.
//
// Input:   findBuf   -- address of pointer to structure
//          lDateTime -- new value of timestamp
//
// Assumes:
//  That the structure of appropriate size is given to it. This means that the
//  size is as per --
//      find_t          :    DOS                  Real Mode
//      FileFindBuf    :    OS/2 (upto Ver 1.10)       Protect Mode
//      _FILEFINDBUF   :    OS/2 (Ver 1.20 & later)    Protect Mode
//
// Notes:
//  The timestamp is a time_t value that gives the date and time of last
//  change to the file. If the date is high byte then two times of creation of
//  two files can be compared by comparing their timestamps. This is easy in the
//  DOS struct but becomes complex for the OS/2 structs because the order of date
//  and time has been reversed (for some unexplicable reason).
//
//  The functionality depends upon the OS version and mode.
//
//  Efficient method to get a long with high and low bytes reversed is
//      (long)high << 16 | (long)low           //high, low being short

void
putDateTime(
    _finddata_t *pfd,
    time_t lDateTime
    )
{
    if (pfd->attrib & _A_SUBDIR) {
        // return the creation date on directories
        pfd->time_create = lDateTime;
    }
    else {
        pfd->time_write = lDateTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\error.cpp ===
//  ERROR.C -- error handling functions
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Revision History:
//  23-Feb-1994 HV  Change Copyright years to 1988-94
//  01-Feb-1994 HV  Move messages to external file.
//  29-Oct-1993 HV  Change the version scheme.
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  18-May-1993 HV  Change reference to messageTable[] to __MSGTAB.  The new
//                  (and more standard) mkmsg.exe output __MSGTAB instead
//                  of messageTable.  See message.h
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  23-Feb-1990 SB  Version No correctly displayed
//  31-Jan-1990 SB  Debug version changes
//  05-Jan-1990 SB  Rev no in std format; #ifdef LEADING_ZERO for old code
//  07-Dec-1989 SB  Changed CopyRight Years to 1988-90; Add #ifdef DEBUG_HEAP
//  06-Nov-1989 SB  Error messages now show NMAKE and not argv0
//  04-Sep-1989 SB  heapdump() has two extra parameters
//  18-Aug-1989 SB  For -z nothing done by makeMessage; Fix later
//  05-Jul-1989 SB  localize rest of the messages in makeError()
//  14-Jun-1989 SB  modified to localize all messages and auto update version no
//  05-Jun-1989 SB  modified heapdump(), has a previous member in the list too
//  14-Apr-1989 SB  modified heapdump() for better error messages when DEBUG
//  05-Apr-1989 SB  made functions NEAR; all funcs to one code segment
//                  modified heapdump() to give better heap violations
//  22-Mar-1989 SB  del call to unlinkTmpFiles() ;add call to delScriptFiles().
//  17-Mar-1989 SB  heapdump() has an additional check built-in
//  10-Mar-1989 SB  Changed makeMessage() for -z to get echo CMD's into PWB.SHL
//  16-Feb-1989 SB  changed makeError() and makeMessage() to handle -help
//  09-Jan-1989 SB  changes in makeError() to handle -help correctly
//  05-Dec-1988 SB  Added CDECL for makeError(), makeMessage(); Pascal calling
//                  #ifdef'd heapdump prototype
//  20-Oct-1988 SB  Changed some eoln comments to be in the same column
//  12-Oct-1988 SB  Made GetFarMsg() to be Model independent & efficient
//  17-Aug-1988 RB  Clean up.
//  24-Jun-1988 rj  Added doError flag to unlinkTmpFiles call.

#include "precomp.h"
#pragma hdrstop

#include "verstamp.h"

#define FATAL       1               // error levels for
#define ERROR       2               // systems lanuguages
#define RESERVED    3               // products
#define WARNING     4

#define CopyRightYrs "1988-2000"
#define NmakeStr "NMAKE"


void __cdecl
makeError (
    unsigned lineNumber,
    unsigned msg,
    ...)
{
    unsigned exitCode = 2;          // general program err
    unsigned level;
    va_list args;                   // More arguments

    va_start(args, msg);            // Point 'args' at first extra arg

    if (ON(gFlags,F1_CRYPTIC_OUTPUT) && (msg / 1000) == WARNING) {
        return;
    }

    displayBanner();

    if (lineNumber) {
        fprintf(stderr, "%s(%u) : ", fName, lineNumber);
    } else {
        fprintf(stderr, "%s : ", NmakeStr);
    }

    switch (level = msg / 1000) {
        case FATAL:
            makeMessage(FATAL_ERROR_MESSAGE);
            if (msg == OUT_OF_MEMORY) {
                exitCode = 4;
            }
            break;

        case ERROR:
            makeMessage(ERROR_MESSAGE);
            break;

        case WARNING:
            makeMessage(WARNING_MESSAGE);
            break;
    }

    fprintf(stderr, " U%04d: ",msg);     // U for utilities
    vfprintf(stderr, get_err(msg), args);
    putc('\n', stderr);
    fflush(stderr);

    if (level == FATAL) {
        fprintf(stderr, "Stop.\n");
        delScriptFiles();

#if !defined(NDEBUG)
        printStats();
#endif
        exit(exitCode);
    }
}


void __cdecl
makeMessage(
    unsigned msg,
    ...)
{
    va_list args;
    FILE *stream = stdout;

    va_start(args, msg);

    if (msg != USER_MESSAGE && ON(gFlags, F1_CRYPTIC_OUTPUT)) {
        return;
    }

    displayBanner();

    if (msg >= FATAL_ERROR_MESSAGE && msg <= COPYRIGHT_MESSAGE_2) {
        stream = stderr;
    }

    if (msg == COPYRIGHT_MESSAGE_1) {
        putc('\n', stream);
    }

    vfprintf(stream, get_err(msg), args);

    if ((msg < COMMANDS_MESSAGE || msg > STOP_MESSAGE) && msg != MESG_LAST) {
        putc('\n', stream);
    }

    fflush(stream);
}


//  displayBanner - display SignOn Banner
//
// Scope:       Global
//
// Purpose:     Displays SignOn Banner (Version & Copyright Message)
//
// Assumes:     If rup is 0 then build version is to be suppressed
//
// Modifies Globals:
//  bannerDisplayed -- Set to TRUE
//
// Notes:
//  1> Display Banner to stderr for compatibility with Microsoft C Compiler.
//  2> rmj, rmm, rup are set by SLM as #define's in VERSION.H
//  3> szCopyrightYrs is a macro set in this file

void
displayBanner()
{
    if (bannerDisplayed) {
        return;
    }

    bannerDisplayed = TRUE;

    makeMessage(COPYRIGHT_MESSAGE_1, VER_PRODUCTVERSION_STR);
    makeMessage(COPYRIGHT_MESSAGE_2, CopyRightYrs);

    fflush(stderr);
}

//  usage - prints the usage message
//
// Scope:   Extern
//
// Purpose: Prints a usage message
//
// Output:  to screen
//
// Assumes: The usage messages are in order between MESG_FIRST and MESG_LAST in the
// messages file.


void
usage(void)
{
    unsigned mesg;

    for (mesg = MESG_FIRST; mesg < MESG_A; ++mesg) {
        makeMessage(mesg, "NMAKE");
    }

    for (mesg = MESG_A; mesg <= MESG_LAST; mesg++) {
        if (mesg == MESG_M) {
            mesg++;
        }

        if (mesg == MESG_V) {
            mesg++;
        }
        makeMessage(mesg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\exec.cpp ===
//  Exec.C - Contains routines that have do to with execing programs
//
// Copyright (c) 1988-1991, Microsoft Corporation. All Rights Reserved.
//
// Purpose:
//  Contains routines that spawn programs ...
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  06-Oct-1992 GBS Removed extern for _pgmptr
//  10-Aug-1992 GBS Change file parsing in execLine to use splitpath
//  19-Aug-1992 SS  Remove Quotes from cd argument.
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Created from routines that existed elsewhere

#include "precomp.h"
#pragma hdrstop

#define SLASH '\\'
#define PUBLIC
#define QUOTE '\"'

extern BOOL processInline(char *, char **, STRINGLIST **, BOOL);

#ifdef _M_IX86
extern UCHAR fRunningUnderChicago;
#else
#define fRunningUnderChicago FALSE
#endif

char * getComSpec(void);
BOOL   iterateCommand(char*, STRINGLIST*, UCHAR, UCHAR, char *, unsigned*);
void   removeQuotes(int, char **);
void   touch(char*, BOOL);


//buffer for path of .cmd/.bat
extern char * makeStr;
extern char * shellName;


char szCmdLineBuf[MAXCMDLINELENGTH];
char *szNmakeProgName;

//  buildArgumentVector -- builds an argument vector from a command line
//
// Scope:
//  Local.
//
// Purpose:
//  It builds an argument vector for a command line. This argument vector can
//  be used by spawnvX routines. The algorithm is explained in the notes below.
//
// Input:
//  argc    -- The number of arguments created in the argument vector
//  argv    -- The actual argument vector created
//              (Ignored if NULL)
//  cmdline -- The command line whose vector is required
//
// Output:
//  Returns the number of arguments and the argument vector as parameters
//
// Errors/Warnings:
// Assumes:
//  That the behaviour of cmd.exe i.e. parses quotes but does not disturb them.
//  Assumes that the SpawnVX routines will handle quotes as well as escaped
//  chars.
//
// Modifies Globals:
// Uses Globals:
// Notes:
//  Scan the cmdline from left to the end building the argument vector along
//  the way. Whitespace delimits arguments except for the first argument for
//  which the switch char '/' is also allowed. Backslash can be used to escape
//  a char and so ignore the character following it. Parse the quotes along
//  the way. If an argument begins with a double-quote then all characters till
//  an unescaped double-quote are part of that argument. Likewise, if an
//  unescaped Doublequote occurs within an argument then the above follows. If
//  the end of the command line comes before the closing quote then the
//  argument goes as far as that.

void
buildArgumentVector(
    unsigned *argc,
    char **argv,
    char *cmdline
    )
{
    char *p;                        // current loc in cmdline
    char *end;                      // end of command line
    BOOL    fFirstTime = TRUE;      // true if 1st argument

    // 11-May-1993 HV _mbschr() bug: return NULL
    // end = _tcschr(p = cmdline, '\0');
    // Work around:
    end = p = cmdline;
    while (*end)
        end++;

    for (*argc = 0; p < end; ++*argc) {
        p += _tcsspn(p, " \t");    // skip whitespace
        if (p >= end)
            break;
        if (argv)
            *argv++ = p;
        if (*p == '\"') {

            // If the word begins with double-quote, find the next
            // occurrence of double-quote which is not preceded by backslash
            // (same escape as C runtime), or end of string, whichever is
            // first.  From there, find the next whitespace character.

            for (++p; p < end; p = _tcsinc(p)) {
                if (*p == '\\')
                    ++p;            // skip escaped character
                else if (*p == '\"')
                    break;
            }
            if (p >= end)
                continue;
            ++p;
            p = _tcspbrk(p, " \t");
        } else {

            // For the first word on the command line, accept the switch
            // character and whitespace as terminators.  Otherwise, just
            // whitespace.

            p = _tcspbrk(p, " \t\"/");
            for (;p && p < end;p = _tcspbrk(p+1, " \t\"/")) {
                if (*p == '/' && !fFirstTime)
                    continue;       // after 1st word '/' is !terminator
                else break;
            }
            if (p && *p == '\"') {
                for (p++;p < end;p++) {     // inside quote so skip to next one
                    if (*p == '\"')
                        break;
                }
                p = _tcspbrk(p, " \t");    // after quote go to first whitespace
            }
            if (fFirstTime) {
                fFirstTime = FALSE;

                // If switch char terminates the word, replace it with 0,
                // re-allocate the word on the heap, restore the switch and set
                // p just before the switch.  It would be easier to shift
                // everything right but then we have to worry about overflow.

                if (p && *p == '/' && argv) {
                    *p = '\0';
                    argv[-1] = makeString(argv[-1]);
                    *p-- = '/';
                }
            }
        }
        if (!p)
            p = end;
        // Now, p points to end of command line argument
        if (argv)
            *p++ = '\0';
    }
    if (argv)
        *argv = NULL;
}

PUBLIC int
doCommands(
    char *name,
    STRINGLIST *s,
    STRINGLIST *t,
    UCHAR buildFlags,
    char *pFirstDep
    )
{
    STRINGLIST *temp;
    int rc;
    temp = makeNewStrListElement();
    temp->text = makeString(name);
    rc = doCommandsEx (temp, s, t, buildFlags, pFirstDep);
    free_stringlist(temp);
    return rc;
}

PUBLIC int
doCommandsEx(
    STRINGLIST *nameList,
    STRINGLIST *s,
    STRINGLIST *t,
    UCHAR buildFlags,
    char *pFirstDep
    )
{
    char *u, *v;
    UCHAR cFlags;
    unsigned status = 0;
    int retryCount = 0;
    char c;
    char *Cmd;
    char *pLine;
    BOOL fExpanded;
    char *pCmd;
    size_t cbLine;

#ifdef DEBUG_ALL
    if (fDebug) {
        printf("* doCommands:");
        DumpList(nameList);
        DumpList(s);
        DumpList(t);
    }
#endif

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 1\n");
#endif
    ++numCommands;
    if (ON(gFlags, F1_QUESTION_STATUS))
        return(0);

    if (ON(gFlags, F1_TOUCH_TARGETS)) {
        STRINGLIST *pName;
        for (pName = nameList; pName; pName = pName->next) {
            touch(pName->text, (USHORT) ON(buildFlags, F2_NO_EXECUTE));
        }
        return(0);
    }

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 2\n");
#endif

    for (; s; s = s->next) {
        fExpanded = processInline(s->text, &Cmd, &t,
            ON(buildFlags, F2_DUMP_INLINE));
        cFlags = 0;
        errorLevel = 0;
        u = Cmd;
        for (v = u; *v; v = _tcsinc(v)) {
            if (*v == ESCH) ++v;
            else if (*v == '$') {
                if (*++v == '$')
                    continue;
// commented out 15-Apr-93 by JonM.  This code forces recursive nmake to be
// executed even if -n, but it's hosed (the -n is not passed to the recursive
// nmake), and the whole thing sounds like a bad idea anyway, so I'm going to
// turn it off.
//              if (!_tcsncmp(v, "(MAKE)", 6)) {
//                  SET(cFlags, C_EXECUTE);
//                  break;
//              }
            }
        }
#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 2.1\n");
#endif
        for (c = *u; c == '!'  ||
                     c == '-'  ||
                     c == '@'  ||
                     c == ESCH ||
                     WHITESPACE(c); u = _tcsinc(u), c = *u) {
            switch (c) {
                case ESCH:
                    if (c = *++u, WHITESPACE(c))
                        c = ' ';    // keep going
                    else
                        c = ESCH;
                    break;

                case '!':
                    SET(cFlags, C_ITERATE);
                    break;

                case '-':
                    SET(cFlags, C_IGNORE);
                    ++u;
                    if (_istdigit(*u)) {
                        char *pNumber = u;

                        errorLevel = _tcstoul(u, &u, 10);
                        if (errno == ERANGE) {
                            *u = '\0';
                            makeError(line, CONST_TOO_BIG, pNumber);
                        }
                        while(_istspace(*u))
                            u++;
                    } else
                        errorLevel = UINT_MAX;
                    --u;
                    break;
                case '@':
                    if (
                        OFF(flags, F2_NO_EXECUTE)) {
                            SET(cFlags, C_SILENT);
                        }
                    break;
            }
            if (c == ESCH)
                break;              // stop parsing for cmd-line options
        }
#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.2\n");
#endif
        if (ON(cFlags, C_ITERATE) &&
            iterateCommand(u, t, buildFlags, cFlags, pFirstDep, &status)
           ) {
            // The macros used by the command have to be freed & so we do so

            v = u;

#ifdef DEBUG_ALL
            printf("DEBUG: doCommands 2.21\n");
#endif
            if (_tcschr(u, '$'))
                u = expandMacros(u, &t);

#ifdef DEBUG_ALL
            printf("DEBUG: doCommands 2.22\n");
#endif
            if (v != u)
                FREE(u);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
                fOptionK &&
                status &&
                status > errorLevel)
            {
                break;
            }
            continue;
        }
        v = u;

#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.23\n");
#endif
        if (!fExpanded && _tcschr(u, '$'))
            u = expandMacros(u, &t);

#ifdef DEBUG_ALL
        printf("DEBUG: doCommands 2.24\n");
#endif

        cbLine = _tcslen(u) + 1;
        pLine = (char *) rallocate (__max(cbLine, MAXCMDLINELENGTH));
        _tcscpy(pLine, u);

        // by this time $< has already been expanded.
        // in order to allow processing of long commands that are due to
        // batch-mode rules, use a buffer that may be larger than MAXCMDLINELENGTH
        // Later we'll attempt to execute the long command directly, instead of
        // passing it to the shell.
        // Note: the macros expanded by ZFormat are not normally found in the
        // command block of a batch-mode rule, so it should be safe to use
        // max(cbLine, MAXCMDLINELENGTH) as a limit for ZFormat
        if (ZFormat (pLine, __max(cbLine, MAXCMDLINELENGTH), u, pFirstDep))
            makeError(0, COMMAND_TOO_LONG, u);

retry:
            status = execLine(pLine,
                              (BOOL)(ON(buildFlags, F2_NO_EXECUTE)
                                  || (OFF(buildFlags,F2_NO_ECHO)
                                  && OFF(cFlags,C_SILENT))),
                              (BOOL)((OFF(buildFlags, F2_NO_EXECUTE)
                                     )
                                     || ON(cFlags, C_EXECUTE)),
                              (BOOL)ON(cFlags, C_IGNORE), &pCmd);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES)) {
                if (status == STATUS_PENDING) {
                    // Hack for ntvdm problem returning correct error code.
                    if (retryCount < 10) {
                        retryCount++;
                        goto retry;
                    }
                }
                if (status && status > errorLevel) {
                    if (!fOptionK)
                        makeError(0, BAD_RETURN_CODE, pCmd, status);
                }
            }
        if (v != u)
            FREE(u);
        FREE(Cmd);
        FREE(pLine);
        if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
            fOptionK &&
            status &&
            status > errorLevel)
        {
            break;
        }
    }

#ifdef DEBUG_ALL
    printf("DEBUG: doCommands 3\n");
#endif

    if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) && fOptionK &&
            (status > errorLevel))
        return(status);
    else
        return(0);
}


//  expandCommandLine -- expands %name% strings in the Command Line
//
// Purpose:
//  The function expands '%name%' type strings in the Command Line. Its main
//  job is to assist FEmulateCommand() in emulating set for OS/2.
//
// Modifies:    buf -- The Command Line available globally
//
// Output:
//  Returns -- the position of 'name=value' part in the Command Line.
//          -- Null when no '=' is found so that FEmulateCommand() can pass the
//              line to the shell to signal syntax error.
// Note:
//  The shell does not give a syntax error for unmatched '%' and assumes it
//  as just another character in this case. This behaviour is duplicated
//  by expandCommandLine()

char *
expandCommandLine(
    void
    )
{
    char Buf[MAXCMDLINELENGTH];         // Buffer for expanded string
    char *pBuf;
    char EnvBuf[MAXCMDLINELENGTH];      // getenv returned string copy
    char *posName,                      // position of 'name=string' in Buf or buf
         *p,                            // points into buf
         *pEnv;                         // points into Env
    char ExpandName[MAXNAME];           // %name% string
    char *pExpandName;

    pBuf = Buf;
    _tcscpy(pBuf, "set");
    p = szCmdLineBuf + 3;               // go beyond 'set'
    pBuf +=3;
    /* Skip whitespace */
    for (;;p++) {
        if (!(WHITESPACE(*p)))
            break;                      // argc>1  this will happen
        else *pBuf++ = *p;
    }

    if (!_tcschr(p, '='))
        return("");                     // Syntax error so pass to the shell
    else
        posName = pBuf;                 // fixes position of Name in Buf

    // Now we look for environment variables and expand if required
    for (;*p != '=';p++)
        *pBuf++ = *p;

    for (;*p;) {
        if (*p == '%') {
            pExpandName = &ExpandName[0];
            while (*++p != '%' && *p)
                *pExpandName++ = *p;
            *pExpandName = '\0';
            if (!*p++) {                // unmatched %;so don't expand
                *pBuf='\0';             // from the environment; like set
                _tcscat(Buf, ExpandName);
                pBuf += _tcslen(ExpandName);
                break;                  // Done precessing quit #43290
            } else {                    // matched %;so expand from the environment
                EnvBuf[0] = '\0';
                if ((pEnv = getenv(ExpandName)) != (char *)NULL) {
                    *pBuf='\0';

                    // If the expanded command line is too long
                    // just say that we can't expand it!!! #43290
                    size_t len = _tcslen(pEnv) + _tcslen(Buf);
                    if (len > MAXCMDLINELENGTH)
                        return NULL;

                    _tcscat(EnvBuf, pEnv);
                    _tcscat(Buf,EnvBuf);
                    pBuf += _tcslen(EnvBuf);
                }
            }
        } else
            *pBuf++ = *p++;
    }
    *pBuf = '\0';
    _tcscpy(szCmdLineBuf, Buf);
    *posName = '\0';
    posName = szCmdLineBuf + _tcslen(Buf);          // Offset into buf
    return(posName);
}

// expandEnvVars -- expands %name% strings in szArg
//
// Returns -- szNew: the resulting expanded string
//          (szNew should be FREEd by the caller)
//
char *
expandEnvVars(
    char *szArg
    )
{
    char *pchLeft = NULL;
    char *pchRight = NULL;
    char *pchStart = szArg;

    char *szNew = makeString("");

    while (*pchStart) {
        pchLeft = _tcschr(pchStart, '%');
        if (pchLeft) {
            pchRight = _tcschr(pchLeft + 1, '%');
        }

        if (pchLeft && pchRight) {
            char *szEnv;
            *pchLeft = '\0';
            *pchRight = '\0';
            szNew = reallocString(szNew, pchStart);
            if (szEnv = getenv(pchLeft + 1)) {
                szNew = reallocString(szNew, szEnv);
            }
            else {
                // no matching env var was found
                // append the %..% string literary
                *pchLeft = '%';
                szNew = reallocString(szNew, pchLeft);
                szNew = reallocString(szNew, "%");
            }
            *pchLeft = '%';
            *pchRight = '%';
            pchStart = pchRight + 1;
            pchLeft = NULL;
            pchRight = NULL;
        }
        else {
            szNew = reallocString(szNew, pchStart);
            pchStart += _tcslen(pchStart);
        }
    }
    return szNew;
}


//  FEmulateCommand - look for certain commands and emulate them
//
// Emulate $(MAKE), cd, chdir, and <drive letter>:.
// Also emulates 'set'.
//
// RETURNS:    TRUE if command emulated, FALSE if not.
//
// Note:
//  In set emulation if a syntax error is discovered then it lets the
//  shell handle it. It does this by returning FALSE.

BOOL
FEmulateCommand(
    int argc,
    char **argv,
    int *pStatus
    )
{
    char *pArg0 = argv[0];
    char *pArg1 = argv[1];

    if (_istalpha(*pArg0) && pArg0[1] == ':' && !pArg0[2]) {
        // If "<drive letter>:" then change drives.  Ignore everything after
        // the drive letter, just like the shell does.

        _chdrive(_totupper(*pArg0) - 'A' + 1);
        *pStatus = 0;
        return(TRUE);
    }

    if (!_tcsicmp(pArg0, "set")) {
        char *pNameVal;         // the "name=value" string

        // If "set" then pass it to the shell and if "set string" then put it
        // into the environment. Let the shell handle the syntax errors.

        if (argc == 1) {
            return(FALSE);          // pass it to the shell
        }

        // expandCommandLine cannot handle lines > MAXCMDLINELENGTH
        // In that case szCmdLineBuf will be empty
        if (!szCmdLineBuf[0])
            return (FALSE);

        pNameVal = expandCommandLine();

        if (pNameVal == NULL)
        {
            // Expanded commad line too long
            return FALSE;
        }

        if (!*pNameVal) {
            // If there is a syntax error let the shell handle it

            return(FALSE);
        }

        if ((*pStatus = PutEnv(makeString(pNameVal))) == -1) {
            makeError(currentLine, OUT_OF_ENV_SPACE);
        }
    } else {
        // If "cd foo" or "chdir foo", do a chdir() else in protect mode this
        // would be a no-op.  Ignore everything after 1st arg, just like the
        // shell does.

        char *szArg;

        if (!_tcsnicmp(pArg0, "cd", 2)) {
            pArg0 += 2;
        } else if (!_tcsnicmp(pArg0, "chdir", 5)) {
            pArg0 += 5;
        } else {
            return(FALSE);
        }

        // At this point, a prefix of argv[0] matches cd or chdir and pArg0
        // points to the next char.  Check for a path separator in argv[0]
        // (e.g., cd..\foo) or else use the next arg if present.

        // if there are more than two arguments then let the shell handle it
        if (argc > 2) {
            return(FALSE);
        }

        // Remove quotes, if any from the argument
        removeQuotes(argc, argv);

        if (!*pArg0 && pArg1) {
            // Under certain circumstances the C RunTime does not help us
            // e.g. 'd:', in this case let the shell do it ...
            if (isalpha(*pArg1) && pArg1[1] == ':' && !pArg1[2]) {
                return(FALSE);
            }

            szArg = expandEnvVars(pArg1); // [VS98 2251]
            *pStatus = _chdir(szArg);
            FREE (szArg);
        } else if (*pArg0 == '.' || PATH_SEPARATOR(*pArg0)) {
            szArg = expandEnvVars(pArg0); // [VS98 2251]
            *pStatus = _chdir(szArg);
            FREE (szArg);
        } else {
            // Unrecognized syntax--we can't emulate.

            return(FALSE);
        }
    }

    // If error, simulate a return code of 1.

    if (*pStatus != 0) {
        *pStatus = 1;
    }

    return(TRUE);
}

#ifdef WIN95

int __cdecl
cmpSzPsz(
    const void *sz,
    const void *psz
    )
{
   const char *sz1 = (char *) sz;
   const char *sz2 = *(char **) psz;

   return(_tcsicmp(sz1, sz2));
}


BOOL
FInternalCommand(
    const char *szName
    )
{
    const char * const *pszInternal;

    static const char * const rgszInternal[] =
    {
        "BREAK",
        "CALL",
        "CD",
        "CHDIR",
        "CLS",
        "COPY",
        "CTTY",
        "DATE",
        "DEL",
        "DIR",
        "DIR.",
        "ECHO",
        "ECHO.",
        "ERASE",
        "EXIT",
        "FOR",
        "GOTO",
        "IF",
        "MD",
        "MKDIR",
        "PATH",
        "PAUSE",
        "PROMPT",
        "RD",
        "REM",
        "REN",
        "RENAME",
        "RMDIR",
        "SET",
        "SHIFT",
        "TIME",
        "TYPE",
        "VER",
        "VERIFY",
        "VOL"
    };


    pszInternal = (const char * const *) bsearch(szName,
                                                 rgszInternal,
                                                 sizeof(rgszInternal) / sizeof(rgszInternal[0]),
                                                 sizeof(rgszInternal[0]),
                                                 &cmpSzPsz);

    return(pszInternal != NULL);
}

#endif  // WIN95

// redirect -- handles redirection of input or output.
//
// arguments:   dir - READ => input,
//                    WRITE => output,
//                    APPEND => append to end of the file.
//
//              p - pointer to buffer that has the filename as
//                  well as the rest of the command string.
//
// return value     FALSE => error (freopen fails)
//                  TRUE => normal return.
//
// the freopen() call sets up the redirection. the rest of the
// command string is then copied forward.

BOOL
redirect(
    char *name,
    unsigned which
    )
{
    char *p;
    char c = '\0';
    BOOL fStatus;
    char *mode;
    FILE *stream;
    FILE *newFile;

    while (WHITESPACE(*name)) {
        name++;
    }

    if (p = _tcspbrk(name, " \t<>\r")) {
        c = *p;

        *p = '\0';
    }

    if (which == READ) {
        mode = "r";
        stream = stdin;
    } else {
        stream = stdout;

        if (which == WRITE) {
            mode = "w";
        } else {
            mode = "a";
        }
    }

    newFile = freopen(name, mode, stream);

    fStatus = (newFile != NULL);

    if (fStatus && (which == APPEND)) {
        _lseek(_fileno(newFile), 0L, SEEK_END);
    }

    while (*name) {
        *name++ = ' ';
    }

    if (p) {
        *p = c;
    }

    return(fStatus);
}


BOOL
FDoRedirection(
    char *p,
    int *oldIn,
    int *oldOut
    )
{
    BOOL in = FALSE;
    BOOL out = FALSE;
    BOOL fReturn = FALSE;
    char *q;
    unsigned which;
    char *save = NULL;


    while (q = _tcspbrk(p, "<>|")) {
        switch (*q) {
            case '<':
                if (in) {
                    fReturn = TRUE;
                    break;
                }

                if (!save) {
                    save = makeString(p);
                }

                *q++ = ' ';
                p = q;
                in = TRUE;
                *oldIn = _dup(_fileno(stdin));

                if ((*oldIn == -1) || !redirect(q, READ)) {
                    fReturn = TRUE;
                    break;
                }
                break;

            case '>':
                if (out) {
                    fReturn = TRUE;
                    break;
                }

                if (!save) {
                    save = makeString(p);
                }

                *q++ = ' ';
                p = q;
                out = TRUE;

                if (*q == '>') {
                    *q++ = ' ';
                    which = APPEND;
                } else {
                    which = WRITE;
                }

                *oldOut = _dup(_fileno(stdout));

                if ((*oldOut == -1) || !redirect(q, which)) {
                    fReturn = TRUE;
                    break;
                }
                break;

            case '|':
                fReturn = TRUE;
                break;

            default :
                makeError(0, BUILD_INTERNAL);
        }

        if (fReturn) {
            break;
        }
    }

    if (fReturn) {
        if (save != NULL) {
            _tcscpy(p, save);
            FREE(save);
        }

        if (in && (*oldIn != -1)) {
            if (_dup2(*oldIn, _fileno(stdin)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(*oldIn);

            *oldIn = -1;
        }

        if (out && (*oldOut != -1)) {
            if (_dup2(*oldOut, _fileno(stdout)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(*oldOut);

            *oldOut = -1;
        }

    }

    return(fReturn);
}


BOOL
FSearchForExecutableExt(
    const char *szFilename,
    const char *szExt,
    BOOL fHasPath,
    char *szPath
    )
{
    char szFullName[_MAX_PATH];

    _tcscpy(szFullName, szFilename);
    _tcscat(szFullName, szExt);
    if (fHasPath) {
       if (_access(szFullName, 0) == 0) {
          _tcscpy(szPath, szFullName);

          return(TRUE);
       }

       return(FALSE);
    }

    _searchenv(szFullName, "PATH", szPath);

    return(szPath[0] != '\0');
}


BOOL
FSearchForExecutable(char *szFullName, char *szPath, BOOL *fBat)
{
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char szFileName[_MAX_FNAME];
    char szNoExt[_MAX_PATH];
    BOOL fHasPath;
    char *szEndQuote;
    BOOL fHasQuotes = FALSE;

    // Ignore any given extension.  This is what COMMAND.COM does,

    char *szToPass = szFullName;

    if (*szFullName == QUOTE) {
        // get rid of any number of quotes at the beginning and at the end of the
        // string. This allows handling names enclosed in multiple quotes that are
        // accepted by the shell (DS 14300)
        szEndQuote = _tcsdec(szFullName, szFullName + _tcslen(szFullName));

        if (QUOTE == *szEndQuote) {
            fHasQuotes = TRUE;

            while (QUOTE == *szToPass)
                szToPass ++;

            while (szEndQuote > szToPass) {
                char *szPrev = _tcsdec (szToPass, szEndQuote);
                if (QUOTE != *szPrev)
                    break;
                szEndQuote = szPrev;
            }

            *szEndQuote = '\0';
        }
    }

    _splitpath(szToPass, szDrive, szDir, szFileName, NULL);
    _makepath(szNoExt, szDrive, szDir, szFileName, NULL);
    fHasPath = (szDrive[0] != '\0') || (szDir[0] != '\0');

    *fBat = FALSE;

    // Search for .COM file

    if (FSearchForExecutableExt(szNoExt, ".com", fHasPath, szPath)) {
        goto success;
    }

    // Search for .EXE file

    if (FSearchForExecutableExt(szNoExt, ".exe", fHasPath, szPath)) {
        goto success;
    }

    // Search for .BAT file

    if (FSearchForExecutableExt(szNoExt, ".bat", fHasPath, szPath)) {
        *fBat = TRUE;

        goto success;
    }

    return(FALSE);

success:
    if (fHasQuotes) {
        size_t size = _tcslen(szPath);
        memmove(szPath+1, szPath, size);
        *szPath = '"';
        *(szPath + size + 1) = '"';
        *(szPath + size + 2) = '\0';
        *szEndQuote = '"';
    }
    return TRUE;

}


//  execLine -- execute a command line
//
// Scope:   Global (build.c, rpn.c)
//
// Purpose:
//  Parses the command line for redirection characters and redirects stdin and
//  stdout if "<", ">", or ">>" are seen.  If any of the following occur,
//  restore the original stdin and stdout, pass the command to the shell, and
//  invoke the shell:
//     - the command line contains "|" (pipe)
//     - a syntax error occurs in parsing the command line
//     - an error occurs in redirection
//  Otherwise, attempt to invoke the command directly, then restore the
//  original stdin and stdout.  If this invocation failed because of
//  file-not-found then pass the command to the shell and invoke the shell.
//
// Input:   line         -- The command line to be executed
//          echoCmd      -- determines if the command line is to be echoed
//          doCmd        -- determines if the command is to be actually executed
//          ignoreReturn -- determines if NMAKE is to ignore the return code on
//                          execution
//          ppCmd        -- if non-null then on error returns command executed
//
// Output:  Returns ... return code from child process
//                  ... -1 if error occurs
//
// Notes:
//  1/ Quoted strings can have redir chars "<>" which will be skipped over.
//  2/ Unmatched quotes cause error; redir chars are replaced by space char.
//  3/ Dup stdin file handle then redirect it. If we have to use the shell,
//     restore the original command line.
//  4/ Emulate certain commands such as "cd" to help prevent some makefiles
//     from breaking when ported from DOS to OS/2.
//
// Algorithm for spawning commands:
//  If we can't handle the syntax, let the shell do everything.  Otherwise,
//  first check to see if the command (without extension) is a DOS built-in &
//  if it is, call the shell to execute it (this is how cmd.exe behaves)
//  If it's not a built-in, we check to see if it has a .cmd or a .bat
//  extension (depending on whether we're in DOS or OS/2). If it does, we
//  call system() to execute it.
//  If it has some other extension, we ignore the extension and go looking for
//  a .cmd or .bat file.  If we find it, we execute it with system().
//  Otherwise, we try to spawn it (without extension). If the spawn fails,
//  we issue an unknown program error.

int
execLine(
    char *line,
    BOOL echoCmd,
    BOOL doCmd,
    BOOL ignoreReturn,
    char **ppCmd
    )
{
    char **argv;
    BOOL fUseShell;
    BOOL fLongCommand;
    int status;
    unsigned argc;

    if (!shellName) {
        shellName = getComSpec();
    }

    switch (*line) {
        case '@':
            // Turn off echo if it was on.  This handles the case where the "@"
            // was in a macro.
            //
            line++;
            if (doCmd)
                echoCmd = 0;
            break;

        case '-':
            ignoreReturn = TRUE;
            ++line;
            if (_istdigit(*line)) {
                char * pNumber = line;
                errorLevel = _tcstoul(line, &line, 10);
                if (errno == ERANGE) {
                    *line = '\0';
                    makeError(0, CONST_TOO_BIG, pNumber);       // Todo: replace 0 with line number
                }
                while(_istspace(*line))
                      line++;
            } else
                errorLevel = UINT_MAX;
            break;
    }

    // handle null command ...
    if (!line[0])
        return(0);

#if 0
    // 10/10/96: disabled to allow execution of long
    // commands that are produced by batch-mode rules

    // copy command line into buffer
    if (_tcslen(line) < MAXCMDLINELENGTH)
        _tcscpy(szCmdLineBuf, line);
    else
        makeError(0, COMMAND_TOO_LONG, line);
#endif

    fLongCommand = _tcslen(line) >= MAXCMDLINELENGTH;
    if (!fLongCommand)
        _tcscpy(szCmdLineBuf, line);
    else
        *szCmdLineBuf = '\0';

    // Allocate a copy of the command line on the heap because in a
    // recursive call to doMake(), argv pointers will be allocated from
    // the static buffer which will then be trashed.  For buildArg...().

    pCmdLineCopy = makeString(line);

    // If -n then echo command if not '$(MAKE)'
    if (echoCmd) {
        printf("\t%s\n", pCmdLineCopy);
        fflush(stdout);
    }

    // Build arg vector.  This is a waste on Windows NT since we're probably
    // going to use the shell, except we have to check for cd, $(MAKE),
    // etc. so we take advantage of the parsing code.

    buildArgumentVector(&argc, NULL, pCmdLineCopy);

    if (argc == 0) {
        return(0);                     // for case when macro command is null
    }

    // allocate argv. Leave space for extra arguments
    // (like "cmd", "/k", quotes) that may be added later
    argv = (char **) rallocate((argc + 5) * sizeof (char *));
    buildArgumentVector(&argc, argv, pCmdLineCopy);


    // 11-May-1993 HV The _mbsicmp() does not like NULL pointer
    //                so I have to check before calling it.
    if (argv[0] && makeStr && !_tcsicmp(argv[0], makeStr)) {
        if(!szNmakeProgName) {
            szNmakeProgName = _pgmptr;
            if( _tcspbrk( szNmakeProgName," " )) {      // If the program name has an embedded space in it
                // Let's put quotes around it
                szNmakeProgName = (char *)rallocate(_tcslen(szNmakeProgName)+3);
                *szNmakeProgName = QUOTE;               // First quote
                *(szNmakeProgName+1) = '\0';
                _tcscat( szNmakeProgName, _pgmptr );    // copy the full program name (self)
                _tcscat( szNmakeProgName, "\"");        // Final quote and \0
            }
        }
        argv[0]=szNmakeProgName;
    }

    if (!doCmd) {                   // don't execute command if doCmd false
        // For -n, emulate if possible.

        if (FEmulateCommand(argc, argv, &status)) {
            if (status && ppCmd) {
                *ppCmd = makeString(*argv);
            }

            return(status);         // return status
        }

        return(0);
    }

    // Try emulating the command if appropriate.  If not, and we should not
    // use the shell, try spawning command directly.

    // Check status when emulating

    if (FEmulateCommand(argc, argv, &status)) {
        // Command has been emulated.  Don't execute it again.

        fUseShell = FALSE;

    } else if (!fRunningUnderChicago && !fLongCommand) {
        // Use the shell for Windows NT unless the command is too long

        fUseShell = TRUE;

#ifdef WIN95
    } else if (fRunningUnderChicago && FInternalCommand(argv[0])) {
        // Under Windows 95 or MS-DOS, use the shell for internal commands

        fUseShell = TRUE;
#endif  // WIN95

    } else {
        int oldIn = -1;                // Old stdin file handle
        int oldOut = -1;               // Old stdout file handle

        // Under Windows 95 or MS-DOS, COMMAND.COM doesn't return child return
        // codes.  Try spawning the child application directly.

        // This code is also now used if the line is too long to be handled by
        // the NT command interpreter.

        fUseShell = FDoRedirection(line, &oldIn, &oldOut);

        if (!fUseShell) {
            char szPath[_MAX_PATH];
            char szQuotedPath[_MAX_PATH];
            BOOL fBat;

            if (oldIn != -1 || oldOut != -1) { // If there was a redirection
                // Need to re-build the argument vector without the
                // redirection characters
                FREE(pCmdLineCopy);
                pCmdLineCopy = makeString(line);
                buildArgumentVector(&argc, argv, pCmdLineCopy);
            }

            if (!FSearchForExecutable(argv[0], szPath, &fBat)) {
                /* If not found, set up an error since COMMAND will
                 * return 0.  This risks future incompatibility if new
                 * COMMAND.COM internal commands are added.
                 */
                if (fRunningUnderChicago) {
                    errno = ENOENT;
                    status = -1;
                } else {
                    fUseShell = TRUE;
                }
            } else if (fBat) {
                // If .bat extension, use COMMAND.COM.

                // UNDONE: CreateProcess is supposed to handle this.  Try it.

                fUseShell = TRUE;
            } else {
                // Spawn command directly.
                // DevStudio#8911, cannot use quotes in szPath
                if (*szPath == QUOTE && *(szPath + _tcslen(szPath) - 1) == QUOTE) {
                    // unquote the path.
                    size_t  cb = _tcslen(szPath);
                    memmove(szPath, szPath + 1, cb);
                    *(szPath + cb - 2) = '\0';
                }
#if 0
                {
                    int i;
                    printf("Spawning \"%s\" directly\n", szPath);
                    for (i = 0; i < argc; i++) {
                        printf ( "Arg[%d] = \"%s\"\n", i, argv[i] );
                    }
                }
#endif
                // DS 14300: Use full path for argv[0]
                // otherwise a shell command may be invoked
                // instead of an intended executable with the
                // same name. Enclosing quotes are needed if
                // string has embedded spaces

                argv[0] = szPath;
                if (_tcschr (argv[0], ' ')) {
                    *szQuotedPath = QUOTE;
                    _tcscpy (szQuotedPath+1, szPath);
                    _tcscat (szQuotedPath, "\"");
                    argv[0] = szQuotedPath;
                }
                status = (int)_spawnvp(P_WAIT, szPath, argv);   // REVIEW:WIN64 cast
            }
        }

        if (oldIn != -1) {
            if (_dup2(oldIn, _fileno(stdin)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(oldIn);
        }

        if (oldOut != -1) {
            if (_dup2(oldOut, _fileno(stdout)) == -1) {
                makeError(0, BUILD_INTERNAL);
            }

            _close(oldOut);
        }
    }

    if (fUseShell) {
        int i;
        BOOL fExtraQuote = FALSE;

        // copy command line into buffer
        if (_tcslen(line) < MAXCMDLINELENGTH)
            _tcscpy(szCmdLineBuf, line);
        else
            makeError(0, COMMAND_TOO_LONG, line);

        // Workaround for cmd bug (DevStudio #11253):
        // IF argv[0] (before we rearrange with cmd.exe /c) is quoted AND
        // any of the other argv[1...n] args have quotes   AND
        // running on NT
        // THEN we add an extra quote before argv[0] and one after argv[n].

        if ((*argv[0] == QUOTE) &&
            (*(argv[0] + _tcslen(argv[0]) - 1) == QUOTE) &&
            !fRunningUnderChicago) {
            for (i = argc - 1; i >= 1; i--) {
                if( _tcspbrk( argv[i],"\"" )) {
                    fExtraQuote = TRUE;
                    break;
                }
            }
        }

        if (fExtraQuote) {
            argv[argc++] = "\"";
            argv[argc] = NULL;
        }

        for (i = argc; i >= 0; i--) {
            argv[i+2] = argv[i];
        }

        argv[0] = shellName;
        argv[1] = fExtraQuote ? "/c \"" : "/c";

#if 0
        printf("Shelling \"%s\"\n", szCmdLineBuf);
        for (i = 0; i < argc + 2; i++) {
            printf ( "Arg[%d] = \"%s\"\n", i, argv[i] );
        }
#endif

        status = (int)_spawnvp(P_WAIT, argv[0], (const char * const *) argv);   // REVIEW:WIN64 cast
    }

    // Check for errors spawning command (distinct from errors *returned*
    // from a successfully spawned command).

    if (status == -1) {
        if (ignoreReturn) {
            status = 0;
        } else {
            switch (errno) {
                case 0:
                    // We (ie: nmake) didn't fail, but the spawned program did.
                    break;

                case ENOENT:
                    makeError(0, CANT_FIND_PROGRAM, argv[0]);
                    break;

                case ENOMEM:
                    makeError(0, EXEC_NO_MEM, fUseShell ? argv[2] : argv[0]);
                    break;

                default:
                    // Done to flag possibly erroneous decision made here [SB]
                    makeError(0, SPAWN_FAILED_ERROR, _strerror(NULL));
            }
        }
    }

    if (status && ppCmd) {
        *ppCmd = makeString(fUseShell ? argv[2] : argv[0]);
    }

    FREE(argv);
    FREE(pCmdLineCopy);
    return(status);
}


// getComSpec()
//
// actions:        Attempts to find system shell.
//
// First look for COMSPEC.  If not found, look for COMMAND.COM or CMD.EXE
// in the current directory then the path.  If not found, fatal error.
// It would make sense to give an error if COMSPEC is not defined but
// test suites are easier if no user-defined environment variables are
// required.

char *
getComSpec()
{
    char *szShell;
    char szPath[_MAX_PATH];

    if ((szShell = getenv("COMSPEC")) != NULL) {
        return(szShell);
    }

    if (fRunningUnderChicago) {
        szShell = "COMMAND.COM";
    } else {
        szShell = "CMD.EXE";
    }

    _searchenv(szShell, "PATH", szPath);

    if (szPath[0] == '\0') {
        makeError(0, NO_COMMAND_COM);
    }

    return(makeString(szPath));
}


BOOL
iterateCommand(
    char *u,
    STRINGLIST *t,
    UCHAR buildFlags,
    UCHAR cFlags,
    char *pFirstDep,
    unsigned *status
    )
{
    BOOL parens;
    char c = '\0';
    char *v;
    STRINGLIST *p = NULL,
               *q;
    char *pLine;
    char *pCmd;

    for (v = u; *v ; ++v) {
        parens = FALSE;
        if (*v == '$') {
            if (*(v+1) == '(') {
                ++v;
                parens = TRUE;
            }
            if (*(v+1) == '?') {
                if (parens
                    && !(_tcschr("DFBR", *(v+2)) && *(v+3) == ')')
                    && *(v+2) != ')')
                    continue;
                p = dollarQuestion;
                c = '?';
                break;
            }
            if (*++v == '*' && *(v+1) == '*') {
                if (parens
                    && !(_tcschr("DFBR", *(v+2)) && *(v+3) == ')')
                    && *(v+2) != ')')
                    continue;
                p = dollarStarStar;
                c = '*';
                break;
            }
        }
    }

    if (!*v) {
        return(FALSE);
    }

    v = u;
    q = p;
    while (p) {
        macros = t;
        if (c == '*') {
            p = dollarStarStar->next;
            dollarStarStar->next = NULL;
        } else {
            p = dollarQuestion->next;
            dollarQuestion->next = NULL;
        }
        u = expandMacros(v, &macros);

        expandExtmake(CmdLine, u, pFirstDep);
            pLine = CmdLine;
            *status = execLine(pLine,
                              (BOOL)(ON(buildFlags, F2_NO_EXECUTE)
                                  || (OFF(buildFlags,F2_NO_ECHO)
                                     && OFF(cFlags,C_SILENT))),
                              (BOOL)((OFF(buildFlags, F2_NO_EXECUTE)
                                     )
                                     || ON(cFlags, C_EXECUTE)),
                              (BOOL)ON(cFlags, C_IGNORE), &pCmd);
            if (OFF(buildFlags, F2_IGNORE_EXIT_CODES)) {
                if (*status && *status > errorLevel)
                    if (!fOptionK)
                        makeError(0, BAD_RETURN_CODE, pCmd, *status);
            }

        if (c == '*')
            dollarStarStar = dollarStarStar->next = p;
        else
            dollarQuestion = dollarQuestion->next = p;
        FREE(u);
        if (OFF(buildFlags, F2_IGNORE_EXIT_CODES) &&
            fOptionK &&
            *status &&
            *status > errorLevel)
        {
            break;
        }
    }
    if (c == '*')
        dollarStarStar = q;
    else
        dollarQuestion = q;
    return(TRUE);
}


void
removeQuotes(
    int argc,
    char **argv
    )
{
    char *t,
         *string;

    for (; argc--; argv++) {
        string = *argv;
        for (t = string; *t;) {
            if (*t == SLASH || *t == ESCH) {
                if (t[1] == QUOTE)
                   *(string)++ = *(t++);
                *(string++) = *(t++);
                continue;
            }
            if (*t == QUOTE)
                ++t;
            else {
                if (_istlead(* (unsigned char *)t))
                    *(string++) = *(t++);
                *(string++) = *(t++);
            }
        }
        *string = '\0';
    }
}

void
touch(
    char *s,
    BOOL minusN
    )
{
    int fd;
    char c;
    FILE * file;

    makeMessage(TOUCHING_TARGET, s);
    if (!minusN &&
            ((file = FILEOPEN(s, "r+b")) != NULL)) {
        fd = _fileno(file);
        if (_read(fd, &c, 1) > 0) {
            _lseek(fd, 0L, SEEK_SET);
            _write(fd, &c, 1);
        }
        _close(fd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\globals.h ===
//  globals.h - global variables/needed across modules
//
//   Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Globals.c is the routine in which global variables reside. Globals.h mirrors
//  the declarations in globals.c as externs and is included in all routines that
//  use globals.
//
// Notes:
//  This module was created for an interesting reason. NMAKE handles recursive
//  calls by saving its global variables somewhere in memory. It handles this by
//  allocating all global variables which have value changes in each recursive
//  in adjacent memory. The routine called recursively is doMake() and before it
//  is called the address of this chunk of memory is stored. When the recursive
//  call returns the memory is restored using the stored address. startOfSave and
//  endOfSave give the location of this chunk. The reason this method was opted
//  for is that spawning of NMAKE would consume a lot of memory under DOS. This
//  might not be very efficient under OS/2 because the code gets shared.
//
// Revision History:
//  15-Nov-1993 JdR Major speed improvements
//  04-Apr-1990 SB  Add fHeapChk
//  01-Dec-1989 SB  Made some variables near and pushed some into saveArea
//  19-Oct-1989 SB  variable fOptionK added (ifdef SLASHK)
//  02-Oct-1989 SB  add dynamic inline file handling support
//  24-Apr-1989 SB  Added ext_size, filename_size, filenameext_size &
//                  resultbuf_size for OS/2 1.2 support
//  05-Apr-1989 SB  made revList, delList, scriptFileList NEAR
//  22-Mar-1989 SB  removed tmpFileStack and related variables
//  16-Feb-1989 SB  added delList to have scriptfile deletes at end of make
//  21-Dec-1988 SB  Added scriptFileList to handle multiple script files
//                  removed tmpScriptFile and fKeep (not reqd anymore)
//  19-Dec-1988 SB  Added fKeep to handle KEEP/NOKEEP
//  14-Dec-1988 SB  Added tmpScriptFile for 'z' option
//  30-Nov-1988 SB  Added revList to handle 'z' option
//  23-Nov-1988 SB  Added CmdLine[] to handle extmake syntax
//                  made pCmdLineCopy Global in build.c
//  21-Oct-1988 SB  Added fInheritUserEnv to inherit macros
//  20-Sep-1988 RB  Clean up.
//  17-Aug-1988 RB  Declare everything NEAR.
//  06-Jul-1988 rj  Ditched shell and argVector globals.
//                  Put all ECS declarations as macros in here.

#if defined(STATISTICS)
extern unsigned long CntfindMacro;
extern unsigned long CntmacroChains;
extern unsigned long CntinsertMacro;
extern unsigned long CntfindTarget;
extern unsigned long CnttargetChains;
extern unsigned long CntStriCmp;
extern unsigned long CntunQuotes;
extern unsigned long CntFreeStrList;
extern unsigned long CntAllocStrList;
#endif

extern BOOL  fOptionK;              // user specified /K ?
extern BOOL  fDescRebuildOrder;     // user specified /O ?
extern BOOL  fSlashKStatus;

// boolean used by action.c & nmake.c

// Required for NMAKE enhancement -- to make NMAKE inherit user modified
// changes in the environment. To be set to true before defineMacro() is
// called so that user defined changes in environment variables are
// reflected in the environment. If set to false then these changes are
// made only in NMAKE tables and the environment remains unchanged

extern BOOL fInheritUserEnv;

extern BOOL fRebuildOnTie;          // TRUE if /b specified, Rebuild on tie

// Used by action.c and nmake.c

// delList is the list of delete commands for deleting inline files which are
// to be deleted before NMAKE exits & have a NOKEEP action specified.

extern STRINGLIST * delList;

// Complete list of generated inline files. Required to avoid duplicate names

extern STRINGLIST * inlineFileList;

// from NMAKE.C

extern BOOL     firstToken;         // to initialize parser
extern BOOL     bannerDisplayed;
extern UCHAR    flags;              // holds -d -s -n -i
extern UCHAR    gFlags;             // "global" -- all targets
extern char     makeflags[];
extern FILE   * file;
extern STRINGLIST * makeTargets;    // list of targets to make
extern STRINGLIST * makeFiles;      // user can specify > 1
extern BOOL     fDebug;


// from LEXER.C

extern unsigned     line;
extern BOOL     colZero;            // global flag set if at column zero
                                    //  of a makefile/tools.ini
extern char   * fName;
extern char   * string;
extern INCLUDEINFO  incStack[MAXINCLUDE];
extern int      incTop;

// Inline file list -- Gets created in lexer.c and is used by action.c to
// produce a delete command when 'NOKEEP' or Z option is set

extern SCRIPTLIST * scriptFileList;

// from PARSER.C

#define STACKSIZE 16

extern UCHAR    stack[STACKSIZE];
extern int      top;                // gets pre-incremented before use
extern unsigned currentLine;        // used for all error messages
extern BOOL     init;               // global boolean value to indicate
                                    // if tools.ini is being parsed
// from ACTION.C

extern MACRODEF   * macroTable[MAXMACRO];
extern MAKEOBJECT * targetTable[MAXTARGET];
extern STRINGLIST * macros;
extern STRINGLIST * dotSuffixList;
extern STRINGLIST * dotPreciousList;
extern RULELIST   * rules;
extern STRINGLIST * list;
extern char       * name;
extern BUILDBLOCK * block;
extern UCHAR        currentFlags;
extern UCHAR        actionFlags;


// from BUILD.C

extern unsigned errorLevel;
extern unsigned numCommands;
extern char   * pCmdLineCopy;

// Used to store expanded Command Line returned by SPRINTF, the result on
// expanding extmake syntax part in the command line
extern char      CmdLine[MAXCMDLINELENGTH];

// from IFEXPR.C

#define IFSTACKSIZE     16

extern UCHAR    ifStack[IFSTACKSIZE];
extern int      ifTop;              // gets pre-incremented before use
extern char   * lbufPtr;            // pointer to alloc'd buffer
                                    // we don't use a static buffer so
                                    // that buffer may be realloced
extern char   * prevDirPtr;         // ptr to directive to be processed
extern unsigned lbufSize;           // initial size of the buffer


// from UTIL.C

extern char   * dollarDollarAt;
extern char   * dollarLessThan;
extern char   * dollarStar;
extern char   * dollarAt;
extern STRINGLIST * dollarQuestion;
extern STRINGLIST * dollarStarStar;

extern char     buf[MAXBUF];        // from parser.c

extern const char suffixes[];       // from action.c
extern const char ignore[];
extern const char silent[];
extern const char precious[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\ifexpr.cpp ===
//  IFEXPR.C -- routines to handle directives
//
//    Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to handle !directives. This module is transparent to
//  rest of NMAKE. It also contains lgetc() used by lexer.c
//
// Revision History:
//   15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//   01-Jun-1993 HV Created UngetTxtChr()
//   01-Jun-1993 HV Change #ifdef KANJI to _MBCS.
//                  Eliminate #include <jctype.h>
//   10-May-1993 HV Add include file mbstring.h
//                  Change the str* functions to STR*
//   30-Jul-1990 SB Freeing ptr in the middle of a string for 'undef foo' case
//   01-Dec-1989 SB Changed realloc() to REALLOC()
//   22-Nov-1989 SB Changed free() to FREE()
//   05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//   19-Sep-1988 RB Remove ESCH processing from readInOneLine().
//   15-Sep-1988 RB Move chBuf to GLOBALS.
//   17-Aug-1988 RB Clean up.
//   29-Jun-1988 rj Added support for cmdswitches e,q,p,t,b,c in tools.ini.
//   23-Jun-1988 rj Fixed GP fault when doing directives in tools.ini.
//   23-Jun-1988 rj Add support for ESCH to readInOneLine().
//   25-May-1988 rb Add missing argument to makeError() call.

#include "precomp.h"
#pragma hdrstop

//  function prototypes

void    skipToNextDirective(void);
void    processIfs(char*, UCHAR);
UCHAR   ifsPresent(char*, unsigned, char**);
void    processCmdSwitches(char*);
char  * readInOneLine(void);
char  * getDirType(char*, UCHAR*);

//  macros that deal w/ the if/else directives' stack

#define ifStkTop()      (ifStack[ifTop])
#define popIfStk()      (ifStack[ifTop--])
#define pushIfStk(A)    (ifStack[++ifTop] = A)

#define INCLUDE         0x09
#define CMDSWITCHES     0x0A
#define ERROR           0x0B
#define MESSAGE         0x0C
#define UNDEF           0x0D


#ifdef _MBCS

//  GetTxtChr : get the next character from a text file stream
//
//    This routine handles mixed DBCS and ASCII characters as
//    follows:
//
//    1.  The second byte of a DBCS character is returned in a
//    word with the high byte set to the lead byte of the character.
//    Thus the return value can be used in comparisions with
//    ASCII constants without being mistakenly matched.
//
//    2.  A DBCS space character (0x8140) is returned as two
//    ASCII spaces (0x20).  I.e. return a space the 1st and 2nd
//    times we're called.
//
//    3.  ASCII characters and lead bytes of DBCS characters
//    are returned in the low byte of a word with the high byte
//    set to 0.

int GetTxtChr(FILE *bs)
{
    extern int  chBuf;      // Character buffer
    int         next;       // The next byte
    int         next2;      // The one after that

    // -1 in chBuf means it doesn't contain a valid character

    // If we're not in the middle of a double-byte character,
    // get the next byte and process it.

    if(chBuf == -1) {
        next = getc(bs);
        // If this byte is a lead byte, get the following byte
        // and store both as a word in chBuf.

        if (_ismbblead(next)) {
            next2 = getc(bs);
            chBuf = (next << 8) | next2;
            // If the pair matches a DBCS space, set the return value
            // to ASCII space.

            if(chBuf == 0x8140)
                next = 0x20;
        }
    } else {
        // Else we're in the middle of a double-byte character.

        if(chBuf == 0x8140) {
            // If this is the 2nd byte of a DBCS space, set the return
            // value to ASCII space.

            next = 0x20;
        } else {
            // Else set the return value to the whole DBCS character

            next = chBuf;
        }
        // Reset the character buffer
        chBuf = -1;
    }

    // Return the next character
    return(next);
}

#endif // _MBCS


#ifdef _MBCS

//  UngetTxtChr -- Unget character fetched by GetTxtChr
//
// Scope:
//  Global.
//
// Purpose:
//  Since GetTxtChr() sometimes reads ahead one character and saves it in chBuf,
//  ungetc() will sometimes put back characters in incorrect sequence.
//  UngetTxtChr, on the other hand, understands how GetTxtChr works and will
//  correctly put those characers back.
//
// Input:
//  c    -- The character read by GetTxtChr()
//  bs    -- The file buffer which c was read from.
//
// Output:
//  Returns c if c is put back OK, otherwise returns EOF
//
// Errors/Warnings:
//
// Assumes:
//  Assumes that characters are read only by GetTxtChr(), not by getc, etc.
//
// Modifies Globals:
//  chBuf -- The composite character, read ahead by GetTxtChr()
//
// Uses Globals:
//  chBuf -- The composite character, read ahead by GetTxtChr()
//
// Notes:
//  There are three cases to consider:
//  1. Normal character (chBuf == -1 && c == 0x00XX)
//     In this case, just put back c is sufficient.
//  2. Trail byte character (chBuf == -1 && c = LB|TB)
//     chBuf = c;
//  3. Lead byte character (chBuf == LB|TB && c == LB)
//     put back TB
//     put back LB
//     chBuf = -1
//
// History:
//   01-Jun-1993 HV Created.

int
UngetTxtChr(int c, FILE *bs)
{
    extern int  chBuf;                  // Character buffer
    int         nTrailByte;             // The trail byte to put back

    if (-1 == chBuf) {                  // We're not in the middle of a DB character
        if (0 == (c >> 8)) {            // CASE 1: normal character
            c = ungetc(c, bs);          // putback normal char
        } else {                        // CASE 2: at trail byte (c=LBTB)
            chBuf = c;                  // change chBuf is sufficient
        }
    } else {                            // CASE 3: at lead byte (c=LB, chBuf=LBTB)
        nTrailByte = chBuf & (int)0xff; // Figure out the trail byte to putback
        ungetc(nTrailByte, bs);         // putback trail byte
        c = ungetc(c, bs);              // putback lead byte
        chBuf = -1;
    }
    return (c);
}

#endif // _MBCS

//  lgetc()        local getc - handles directives and returns char
//
//  arguments:        init    global boolean value -- TRUE if tools.ini
//                is the file being parsed
//              colZero     global boolean value -- TRUE if at first column
//
//  actions:
//          gets a character from the currently open file.
//          loop
//            if it is column zero and the char is '!' or
//               there is a previous directive to be processed do
//               read in one line into buffer.
//               find directive type and get a pointer to rest of
//              text.
//              case directive of:
//
//              CMDSWITCHES  : set/reset global flags
//              ERROR        : set up global error message
//                         printed by error routine on
//                     termination. (not implemented yet )
//              INCLUDE      : calls processInclude
//                     continues with new file...
//              UNDEF        : undef the macro in the table
//                  IF
//              IFDEF
//              IFNDEF
//              ELSE
//              ENDIF        : change the state information
//                              on the ifStack
//                     evaluate expression if required
//                     skip text if required (and look
//                          for the next directive)
//                     ( look at processIfs() )
//            free extra buffers used (only one buffer need be
//                 maintained )
//            increment lexer's line count
//            we 're now back at column zero
//            get next char from current file
//           end if
//         end loop
//         return a char
//
//  returns :    a character (that is not part of any directive...)
//
//  modifies:        ifStack    if directives' stack, static to this module
//            ifTop     index of current element at top of stack
//            line        lexer's line count...
//
//            file        current file, if !include is found...
//                  fName       if !include is processed...

int
lgetc()
{
    UCHAR dirType;
    int c;
    char *s, *t;
    MACRODEF *m;

    for (c = GetTxtChr(file); prevDirPtr || (colZero && (c == '!'));
                    ++line, c = GetTxtChr(file)) {
        colZero = FALSE;                // we saw a '!' incolZero
        if (!prevDirPtr) {
            s = readInOneLine();        // might modify lbufPtr -
                                        // if input text causes realloc */
        } else {
            UngetTxtChr(c, file);
            s = prevDirPtr;
            prevDirPtr = NULL;
        }

        t = getDirType(s, &dirType);

        if (dirType == INCLUDE) {
            if (init) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
            }

            // processInclude eats up first char in new file
            // if it is space char. we check for that and break out.

            if (processIncludeFile(t) == (UCHAR) NEWLINESPACE) {
                c = ' ';                // space character is returned
                break;                  // colZero is now FALSE
            }
        }
        else if (dirType == CMDSWITCHES) {
            processCmdSwitches(t);
        }
        else if (dirType == ERROR) {
            makeError(line, USER_CONTROLLED, t);
        }
        else if (dirType == MESSAGE) {
            if (!_tcsnicmp(t, "\\t", 2)) {
                printf("\t");
                t+=2;
            }
            makeMessage(USER_MESSAGE, t);
        }
        else if (dirType == UNDEF) {
            char *tmp;
            tmp = _tcstok(t, " \t");
            if (_tcstok(NULL, " \t")) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, tmp);
            }
            if (NULL != (m = findMacro(tmp))) {
                SET(m->flags, M_UNDEFINED);
            }
            // CONSIDER:  why not remove symbol from table? [RB]
        }
        else processIfs(t, dirType);
            colZero = TRUE;             // finished with this directive
        if (s != lbufPtr)               // free buffer if it had expanded macros
            FREE(s);
    }
    return(c);                          // return a character to the lexer
}


//  readInOneLine()
//
//  arguments:  lbufPtr   pointer(static/global to this module) to buffer that
//                    will hold text of line being read in
//              lbufSize  size of buffer(static/global to this module), updated
//                if buffer is realloc'd
//  actions  :  skip spaces/tabs and look for the directive.
//              line continuations allowed in usual way
//              if space-backslash-nl keep looking...
//              if colZero of next line has comment char
//                    (#, or ; in tools.ini), look at next line...
//              if first non-space char is '\n' or EOF report
//                fatal-error and stop.
//
//          keep reading in chars and storing in the buffer until
//               a newline, EOF or a '#' which is NOT in column
//               zero is seen
//          if comment char in column zero ('#' or ';' in tools.ini)
//             skip the line, continue with text on next line.
//          if buffer needs to be realloc'd increase size by
//             MAXBUF, a global constant.
//          if newline was found, eat up newline.
//          null terminate string for return.
//          if '#' was found discard chars till the a newline or EOF.
//          if EOF was found, push it back on stream for return
//             to the lexer the next time.
//
//          now expand macros. get a different buffer with clean
//          text after expansion of macros.
//
//   modifies :   colZero    global boolean value ( thru' call to
//                            skipBackSlash())
//                lbufPtr    buffer pointer, in case of reallocs.
//                lbufSize   size of buffer, increased if buffer is realloc'd
//   Note:  the buffer size will grow to be just greater than the size
//        of the longest directive in any of the files processed,
//        if it calls for any realloc's
//        Do NOT process ESCH here.  It is processed at a higher level.
//
//   returns  :   pointer to buffer.
//

char *
readInOneLine()
{
    extern STRINGLIST *eMacros;
    int c;
    unsigned index = 0;
    register char *s;

    if (((c = skipWhiteSpace(FROMSTREAM)) == '\n') || (c == EOF))
        makeError(line, SYNTAX_MISSING_DIRECTIVE);

    UngetTxtChr(c, file);

    for (;;) {
        c = GetTxtChr(file);
        c = skipBackSlash(c, FROMSTREAM);
        if (c == '#' || c == '\n' || c == EOF) {
            break;
        }
        if ((index+2) > lbufSize) {
            lbufSize += MAXBUF;
            if (!lbufPtr) {
                lbufPtr = (char *) allocate(lbufSize+1);    // +1 for NULL byte
            } else {
                lbufPtr = (char *) REALLOC(lbufPtr, lbufSize+1);
                if (!lbufPtr)
                    makeError(line, MACRO_TOO_LONG);
            }
        }
        *(lbufPtr + (index++)) = (char) c;
    }
    *(lbufPtr + index) = '\0';          // null terminate the string
    if (c == '#') {
        for(c = GetTxtChr(file); (c != '\n') && (c != EOF); c = GetTxtChr(file))
            ;
                                        // newline at end is eaten up
    }

    if (c == EOF) {
        UngetTxtChr(c, file);           // this directive is to be processed
    }

    s = lbufPtr;                        // start expanding macros here
    s = removeMacros(s);                // remove and expand macros in string s
    return(s);
}


//  getDirType()
//
//  arguments:  s         -   pointer to buffer that has directive text.
//            dirType   -   pointer to unsigned char that gets set
//                   with directive type.
//
//  actions  :  goes past directive keyword, sets the type code and
//        returns a pointer to rest of test.

char *
getDirType(
    char *s,
    UCHAR *dirType
    )
{
    char *t;
    int len;

    *dirType = 0;
    for (t = s; *t && !WHITESPACE(*t); ++t);
    len = (int) (t - s);                // store len of directive
    while (*t && WHITESPACE(*t)) {
        ++t;                            // go past directive keyword
    } if (!_tcsnicmp(s, "INCLUDE", 7) && (len == 7)) {
        *dirType = INCLUDE;
    } else if (!_tcsnicmp(s, "CMDSWITCHES", 11) && (len == 11)) {
        *dirType = CMDSWITCHES;
    } else if (!_tcsnicmp(s, "ERROR", 5) && (len == 5)) {
        *dirType = ERROR;
    } else if (!_tcsnicmp(s, "MESSAGE", 7) && (len == 7)) {
        *dirType = MESSAGE;
    } else if (!_tcsnicmp(s, "UNDEF", 5) && (len == 5)) {
        *dirType = UNDEF;
    } else {
        *dirType = ifsPresent(s, len, &t) ;     // directive one of "if"s?
    }

    if (!*dirType) {
        makeError(line, SYNTAX_BAD_DIRECTIVE, lbufPtr);
    }
    return(t);
}


//  processCmdSwitches() -- processes command line switches in makefiles
//
//  arguments:      t         pointer to flag settings specified.
//
//  actions  :    sets or resets global flags as specified in the directive.
//          The allowed flags are:
//          s - silent mode,     d - debug output (dates printed)
//          n - no execute mode, i - ignore error returns from commands
//          u - dump inline files
//          If parsing tools.ini, can also handle epqtbc
//                reports a bad directive error for any other flags
//          specified
//
//  modifies :    nothing
//
//  returns  :    nothing

void
processCmdSwitches(
    char *t                         // pointer to switch values
    )
{
    for (; *t; ++t) {               // ignore errors in flags specified
        switch (*t) {
            case '+':
                while (*++t && *t != '-') {
                    if (_tcschr("DINSU", (unsigned short)_totupper(*t))) {
                        setFlags(*t, TRUE);
                    } else if (init && _tcschr("ABCEKLPQRTY", (unsigned short)_totupper(*t))) {
                        setFlags(*t, TRUE);
                    } else {
                        makeError(line, SYNTAX_BAD_CMDSWITCHES);
                    }
                }

                if (!*t) {
                    break;
                }

            case '-':
                while (*++t && *t != '+') {
                    if (_tcschr("DINSU", (unsigned short)_totupper(*t))) {
                        setFlags(*t, FALSE);
                    } else if (init && _tcschr("ABCEKLMPQRTV", (unsigned short)_totupper(*t))) {
                        setFlags(*t, FALSE);
                    } else {
                        makeError(line, SYNTAX_BAD_CMDSWITCHES);
                    }
                }
                break;

            default:
                if (!WHITESPACE(*t)) {
                    makeError(line, SYNTAX_BAD_CMDSWITCHES);
                }
                break;
        }
        if (!*t) {
            break;
        }
    }
}

//  ifsPresent() -- checks if current directive is one of the "if"s
//
//  arguments:  s       pointer to buffer with directive name in it
//              len     length of the directive that was seen
//              t       pointer to address upto which processed
//
//  actions  :  does a string compare in the buffer for one of the
//              directive keywords. If string matches true, it returns
//              a non-zero value, the code for the specific directive
//
//  modifies :  nothing
//
//  returns  :  a zero if no match, or the code for directive found.

UCHAR
ifsPresent(
    char *s,
    unsigned len,
    char **t
    )
{
    UCHAR ifFlags = 0;              // takes non-zero value when one of
                                    // if/else etc is to be processed

    if (!_tcsnicmp(s, "IF", 2) && (len == 2)) {
        ifFlags = IF_TYPE;
    } else if (!_tcsnicmp(s, "IFDEF", 5) && (len == 5)) {
        ifFlags = IFDEF_TYPE;
    } else if (!_tcsnicmp(s, "IFNDEF", 6) && (len == 6)) {
        ifFlags = IFNDEF_TYPE;
    } else if (!_tcsnicmp(s, "ELSE", 4) && (len == 4)) {
        // 'else' or 'else if' or 'else ifdef' or 'else ifndef'
        char *p = *t;

        if (!*p) {
            ifFlags = ELSE_TYPE;
        } else {
            for (s = p; *p && !WHITESPACE(*p); p++)
                ;
            len = (unsigned) (p - s);
            while (*p && WHITESPACE(*p)) {
                p++;
            }
            *t = p;
            if (!_tcsnicmp(s, "IF", 2) && (len == 2)) {
                ifFlags = ELSE_IF_TYPE;
            } else if (!_tcsnicmp(s, "IFDEF", 5) && (len == 5)) {
                ifFlags = ELSE_IFDEF_TYPE;
            } else if (!_tcsnicmp(s, "IFNDEF", 6) && (len == 6)) {
                ifFlags = ELSE_IFNDEF_TYPE;
            }
        }
    }
    else if (!_tcsnicmp(s, "ELSEIF", 6) && (len == 6)) {
        ifFlags = ELSE_IF_TYPE;
    }
    else if (!_tcsnicmp(s, "ELSEIFDEF", 9) && (len == 9)) {
        ifFlags = ELSE_IFDEF_TYPE;
    }
    else if (!_tcsnicmp(s, "ELSEIFNDEF", 10) && (len == 10)) {
        ifFlags = ELSE_IFNDEF_TYPE;
    }
    else if (!_tcsnicmp(s, "ENDIF", 5) && (len == 5)) {
        ifFlags = ENDIF_TYPE;
    }

    return(ifFlags);
}


//  processIfs() -- sets up / changes state information on "if"s
//
//  arguments:  s       pointer to "if" expression ( don't care
//                       for "endif" )
//
//              kind    code indicating if processing if/else/ifdef etc.
//
//  actions  :  modifies a stack (ifStack) by pushing/popping or
//              sets/resets bits in the top element on the
//              stack(examining the previous element pushed if
//              required).
//              case (kind) of
//                  IF
//                  IFDEF
//                  IFNDEF
//                  IF defined() : if no more space on ifStack
//                                  (too many nesting levels) abort...
//                      set IFELSE bit in elt.
//                      push elt on ifStack.
//                      if more than one elt on stack
//                          and outer level "ifelse" false
//                          set IGNORE bit, skipToNextDirective
//                      else
//                          evaluate expression of
//                           current "if"
//                          if expr true set CONDITION bit in elt
//                          else skipToNextDirective.
//                  ELSE         : if no elt on stack or previous
//                                  directive was "else", flag error, abort
//                       clear IFELSE bit in elt on stack.
//                       if current ifelse block is to
//                        be skipped (IGNORE bit is on
//                        in outer level if/else),skip...
//                       else FLIP condition bit.
//                          if "else" part is false
//                             skipToNextDirective.
//                  ENDIF        : if no elt on stack, flag error,abort
//                       pop an elt from ifStack.
//                       if there are elts on stack
//                        and we are in a "false" block
//                        skipToNextDirective.
//                  end case
//
//  modifies:   ifStack     if directives' stack, static to this module
//              ifTop       index of current element at top of stack
//              line        lexer's line count  (thru calls to
//                            skipToNextDirective())
//
//  returns  :      nothing

void
processIfs(
    char *s,
    UCHAR kind
    )
{
    UCHAR element;          // has its bits set and is pushed on the ifStack

    switch (kind) {
        case IF_TYPE:
        case IFDEF_TYPE:
        case IFNDEF_TYPE:
            if (ifTop == IFSTACKSIZE-1) {
                makeError(line, SYNTAX_TOO_MANY_IFS);
            }
            element = (UCHAR) 0;
            SET(element, NMIFELSE);
            pushIfStk(element);
            if (ifTop && OFF(ifStack[ifTop-1], NMCONDITION)) {
                SET(ifStkTop(), NMIGNORE);
                skipToNextDirective();
            } else if (evalExpr(s, kind)) {
                SET(ifStkTop(), NMCONDITION);
            } else {
                skipToNextDirective();
            }
            break;

        case ELSE_TYPE:
            if ((ifTop < 0) || (OFF(ifStkTop(), NMIFELSE) && OFF(ifStkTop(), NMELSEIF))) {
                makeError(line, SYNTAX_UNEXPECTED_ELSE);
            }
            CLEAR(ifStkTop(), NMIFELSE);
            CLEAR(ifStkTop(), NMELSEIF);
            if (ON(ifStkTop(), NMIGNORE)) {
                skipToNextDirective();
            } else {
                FLIP(ifStkTop(), NMCONDITION);
                if (OFF(ifStkTop(), NMCONDITION)) {
                    skipToNextDirective();
                }
            }
            break;

        case ELSE_IF_TYPE:
        case ELSE_IFDEF_TYPE:
        case ELSE_IFNDEF_TYPE:
            if ((ifTop < 0) || (OFF(ifStkTop(), NMIFELSE) && OFF(ifStkTop(), NMELSEIF))) {
                makeError(line, SYNTAX_UNEXPECTED_ELSE);
            }
            CLEAR(ifStkTop(), NMIFELSE);
            SET(ifStkTop(), NMELSEIF);
            if (ON(ifStkTop(), NMIGNORE)) {
                skipToNextDirective();
            } else {
                if (ON(ifStkTop(), NMCONDITION)) {
                    SET(ifStkTop(), NMIGNORE);
                    CLEAR(ifStkTop(), NMCONDITION);
                    skipToNextDirective();
                } else if (evalExpr(s, kind)) {
                    SET(ifStkTop(), NMCONDITION);
                } else {
                    skipToNextDirective();
                }
            }
            break;

        case ENDIF_TYPE:
            if (ifTop < 0) {
                makeError(line, SYNTAX_UNEXPECTED_ENDIF);
            }
            popIfStk();
            if (ifTop >= 0) {
                if (OFF(ifStkTop(), NMCONDITION)) {
                    skipToNextDirective();
                }
            }

        default:
            break;  // default should never happen
    }
}


//  skipToNextDirective() -- skips to next line that has '!' in column zero
//
//  actions  :  gets first char of the line to be skipped if it is
//               not a directive ( has no '!' on column zero ).
//              a "line" that is skipped may in fact span many
//               lines ( by using sp-backslash-nl to continue...)
//              comments in colZero are skipped as part of the previous
//               line ('#' or ';' in tools.ini)
//              comment char '#' elsewhere in line implies the end of
//               that line (with the next newline / EOF)
//              if a '!' is found in colZero, read in the next directive
//              if the directive is NOT one of if/ifdef/ifndef/else/
//               endif, keep skipping more lines and look for the
//               next directive ( go to top of the routine here ).
//              if EOF found before next directive, report error.
//
//  modifies :  line    global lexer line count
//
//  returns  :  nothing

void
skipToNextDirective()
{
    register int c;
    UCHAR type;

repeat:

    for (c = GetTxtChr(file); (c != '!') && (c != EOF) ;c = GetTxtChr(file)) {
        ++line;                         // lexer's line count

        do {
            if (c == '\\') {
                c = skipBackSlash(c, FROMSTREAM);
                if (c == '!' && colZero) {
                    break;
                } else {
                    colZero = FALSE;
                }
            }
            if ((c == '#') || (c == '\n') || (c == EOF)) {
                break;
            }
            c = GetTxtChr(file);
        } while (TRUE);

        if (c == '#') {
            for (c = GetTxtChr(file); (c != '\n') && (c != EOF); c = GetTxtChr(file))
                ;
        }
        if ((c == EOF) || (c == '!')) {
            break;
        }
    }

    if (c == '!') {
        if (prevDirPtr && (prevDirPtr != lbufPtr)) {
            FREE(prevDirPtr);
        }
        prevDirPtr = readInOneLine();
        getDirType(prevDirPtr, &type);
        if (type > ENDIF_TYPE) {        // type is NOT one of the "if"s
            ++line;
            goto repeat;
        }
    } else if (c == EOF) {
        makeError(line, SYNTAX_EOF_NO_DIRECTIVE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\grammar.h ===
// GRAMMAR.H -- Contains grammar of NMAKE ************************************
//
//  Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains grammar of NMAKE and definitions used by lexer & parser
//
// Revision History:
//  08-Oct-1989 SB Added QUOTE_ and NOQ and QUO to handle OS/2 1.2 quoted names
//  31-Jul-1989 SB Added BKS, DEF and BEG to add lookahead to the lexer
//  18-May-1989 SB Added BKSLH_ definition for use by lexer's nameStates[]

//  This file contains the grammar for nmake.
//
//
//
//  e is the symbol epsilon
//
//
//  nonterminals begin w/ capitals
//
//
//  terminals begin w/ lower-case letters
//
//
//  terminals: name newline newlineWhitespace semicolon colon equals string e
//      doublecolon value
//
//
//  Makefile ->     e |
//              BlankLines Makefile |
//              newline name Body Makefile
//
//  Body ->         NameList Separator BuildInfo |
//              equals value
//
//  NameList ->     e |
//              name NameList
//
//  Commands ->     e |
//              MoreBuildLines |
//              semicolon string MoreBuildLines
//
//  MoreBuildLines ->   e |
//              newlineWhitespace string MoreBuildLines |
//              newline MoreBuildLines
//
//  BlankLines ->       e |
//              newline BlankLines |
//              newlineWhitespace BlankLines
//
//  BuildInfo ->        e |
//              NameList Commands
//
//  Separator ->        colon | doublecolon
//
//
//
//
//
//  note:   a "string" is everything from the current input character up
//      to the first newline which is not preceded by a backslash, or
//      end of file (whichever comes first).  a macro "value" is the
//      same as a "string" with the exception that comments are stripped
//      from it (a comment ending in a backslash does not cause the
//      value to be continued on the next line).


//  Compute FIRST() and FOLLOW() for each nonterminal in order to construct
//  parse table (it'd be nice to have a simple utility to build the
//  table, but it's still a pretty easy thing to do by hand).
//
//
//  FIRST(Makefile)         =   e newline FIRST(BlankLines)
//                  = e newline newlineWhitespace
//
//  FIRST(Body)         =   equals FIRST(NameList) FIRST(Separator)
//                  = equals name colon doublecolon
//
//  FIRST(NameList)         =   e name
//
//  FIRST(Commands)         =   e semicolon FIRST(BuildLine)
//                  = e semicolon newlineWhitespace
//
//  FIRST(MoreBuildLines)       =   e FIRST(BuildLine) FIRST(BlankLines)
//                  = e newlineWhitespace newline
//
//  FIRST(BlankLines)       =   e newline newlineWhitespace
//
//  FIRST(BuildInfo)        =   FIRST(NameList) FIRST(Commands)
//                  = e name semicolon newlineWhitespace
//
//  FIRST(Separator)        =   colon doublecolon


//  ---------------------------------------------------------------
//
//
//  FOLLOW(Makefile)        =   $
//
//  FOLLOW(Body)            =   FIRST(Makefile) FOLLOW(Makefile)
//                  = newline newlineWhitespace $
//
//  FOLLOW(NameList)        =   FIRST(Commands) FIRST(MoreBuildLines)
//                  colon FOLLOW(Body)
//                  = colon semicolon newlineWhitespace
//                    newline $
//
//  FOLLOW(Commands)        =   FOLLOW(Body)
//                  = newline newlineWhitespace $
//
//  FOLLOW(MoreBuildLines)      =   FOLLOW(Commands)
//                  = newline newlineWhitespace $
//
//  FOLLOW(BlankLines)      =   FIRST(Body) FOLLOW(Makefile)
//                  = newlineWhitespace newline $
//
//  FOLLOW(BuildInfo)       =   FOLLOW(Body)
//                  = newline newlineWhitespace $
//
//  FOLLOW(Separator)       =   FIRST(BuildInfo) FOLLOW(Body)
//                  = name semicolon newlineWhitespace
//                    newline $
//

//------------------------------------------------------------------------------
//
//  for building the table, I number the productions:
//
//
//
//  0.  Makefile ->     e
//
//  1.  Makefile ->     BlankLines Makefile
//
//  2.  MakeFile ->     newline name Body Makefile
//
//  3.  Body ->         NameList Separator BuildInfo
//
//  4.  Body ->         equals value
//
//  5.  NameList ->     e
//
//  6.  NameList ->     name NameList
//
//  7.  Commands ->     e
//
//  8.  Commands ->     MoreBuildLines
//
//  9.  Commands ->     semicolon string MoreBuildLines
//
//  10. MoreBuildLines ->   newlineWhiteSpace string MoreBuildLines
//
//  11. MoreBuildLines ->   e
//
//  12. MoreBuildLines ->   newline MoreBuildLines
//
//  13. BlankLines ->       e
//
//  14. BlankLines ->       newline BlankLines
//
//  15. BlankLines ->       newlineWhitespace BlankLines
//
//  16. BuildInfo ->        e
//
//  17. BuildInfo ->        NameList Commands
//
//  18. Separator ->        colon
//
//  19. Separator ->        doublecolon
//



//------------------------------------------------------------------------------
//
//  NOTE THAT THIS GRAMMAR IS NOT LL(1) (it's really LL(2) because we need
//  an extra symbol of lookahead to decide which production to use in
//  a few cases)
//
//
//  the resulting parse table (empty entries are error conditions):
//
//
//                      newline-
//                              White-  semi-           double-
//             |name   |newline| space | colon | colon | colon |equals |$      |
//             -----------------------------------------------------------------
//  A          |       |       |       |       |       |       |       |       |
//    Makefile |       |  1,2  |   1   |       |       |       |       |   0   |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  B          |       |       |       |       |       |       |       |       |
//    Blank-   |       | 13,14 | 13[15]|       |       |       |       |   13  |
//     Lines   |       |       | --    |       |       |       |       |       |
//             -----------------------------------------------------------------
//  C          |       |       |       |       |       |       |       |       |
//    More-    |       | 11,12 |   10  |       |       |       |       |   11  |
//     Build-  |       |       |       |       |       |       |       |       |
//  Lines      -----------------------------------------------------------------
//  D          |       |       |       |       |       |       |       |       |
//    Commands |       |   7   | [7]8  |   9   |       |       |       |   7   |
//             |       |       |    -  |       |       |       |       |       |
//             -----------------------------------------------------------------
//  E          |       |       |       |       |       |       |       |       |
//    Body     |   3   |       |       |       |   3   |       |   4   |       |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  F          |       |       |       |       |       |       |       |       |
//    NameList |   6   |   5   |   5   |   5   |   5   |   5   |       |   5   |
//             |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//  G          |       |       |       |       |       |       |       |       |
//    Build-   |   17  |   16  |[16]17 |   17  |       |       |       |   16  |
//     Info    |       |       |    -- |       |       |       |       |       |
//             -----------------------------------------------------------------
//  H          |       |       |       |       |       |       |       |       |
//    Separ-   |       |       |       |       |   18  |   19  |       |       |
//     ator    |       |       |       |       |       |       |       |       |
//             -----------------------------------------------------------------
//
//  G2 -- always uses 17 -- anytime the user puts a line beginning w/
//      whitespace immediately after a target-dependency line, it's
//      a build line.  Same for D2.



//  IMPORTANT:  IF YOU CHANGE THE VALUES OF ANY OF THE FOLLOWING
//  CONSTANTS FOR TERMINAL OR NONTERMINAL SYMBOLS, YOU MUST ADJUST
//  THE APPROPRIATE TABLES (AND STRING LITERALS) ACCORDINGLY.
//
//  Nonterminal symbols first (these are used to index the parse table
//  along the first dimension):
//
// define nonterminals . . .

#define MAKEFILE    0x00            // productions w/ 2
#define BLANKLINES  0x01            //  alternatives in a
#define MOREBUILDLINES  0x02        //  table entry must
#define COMMANDS    0x03            //  come first (so
#define BODY        0x04            //  that I can use
#define NAMELIST    0x05            //  them as array
#define BUILDINFO   0x06            //  subscripts when
#define SEPARATOR   0x07            //  resolving the
                                    //  conflict)

#define START       MAKEFILE
#define LAST_PRODUCTION SEPARATOR

// Now the terminal symbols (the 4 low bits of which are used to index
// the parse table alone 2nd dimension -- bit 5 simply distinguishes
// tokens from nonterminals in productions):

#define NAME        0x10            // TOKEN_MASK | 0
#define NEWLINE     0x11            // TOKEN_MASK | 1
#define NEWLINESPACE    0x12        // TOKEN_MASK | 2
#define SEMICOLON   0x13            // TOKEN_MASK | 3
#define COLON       0x14            // TOKEN_MASK | 4
#define DOUBLECOLON 0x15            // etc.
#define EQUALS      0x16
#define ACCEPT      0x17            // this is $
#define STRING      0x18            // no columns in table
#define VALUE       0x19            //  for these two

// Error values    -- these are equal to the error exit code minus 1000
// if you change them, you must change the corresponding values in
// nmmsg.txt

#define MACRO       0x20            // ERROR_MASK | 0
#define SYNTAX      0x21            // ERROR_MASK | 1
#define SEPRTR      0x22            // ERROR_MASK | 2
#define SEPEQU      0x23            // ERROR_MASK | 3
#define NAMES       0x24            // ERROR_MASK | 4
#define NOTARG      0x25            // ERROR_MASK | 5
#define LEXER       0x26            // ERROR_MASK | 6
#define PARSER      0x27            // ERROR_MASK | 7

// Parser actions  -- these are indexes into the "action" function table,
// telling the parser which function to call at a certain point in
// a production

#define DONAME      0x40            // ACTION_MASK | 0
#define DONAMELIST  0x41
#define DOMACRO     0x42
#define DODEPENDS   0x43
#define DOLASTNAME  0x44
#define DOBUILDCMDS 0x45

//  a few macros to simplify dealing w/ tokens:

#define TOKEN_MASK  0x10
#define ERROR_MASK  0x20
#define ACTION_MASK 0x40
#define AMBIG_MASK  0x80            // conflict in table
#define LOW_NIBBLE  0x0F

//  values for alternate productions table
//  (a YES in the slot for a given input token and a given nonterminal
//  on top of the stack means use the next production (+1) from the
//  one given in the production table)

#define YES 1
#define NO  0


//  values for lexer's state machine that recognizes names
//  append an underscore to distinguish these from parser's tokens

#define DEFAULT_    0x00            // char not defined
#define COMMENT_    0x01            //  below
#define EQUALS_     0x02
#define SEMICOLON_  0x03
#define COLON_      0x04
#define WHITESPACE_ 0x05            // \t and ' '
#define NEWLINE_    0x06            // \n and EOF
#define DOLLAR_     0x07
#define OPENPAREN_  0x08
#define CLOSEPAREN_ 0x09
#define MACROCHAR_  0x0A            // A-Z,a-z,0-9,_
#define OPENCURLY_  0x0B
#define CLOSECURLY_ 0x0C
#define BKSLSH_     0x0D
#define QUOTE_      0x0E

#define STAR_       0x0B            // only for strings:
#define SPECIAL1_   0x0C            // @ * < ?
#define SPECIAL2_   0x0D            // B F D R
#define BACKSLASH_  0x03            // don't need semi if
                                    //  we have backslash
                                    //  (names need ; but
                                    //  strings need \)

//  values for state tables -- for error values, mask off the error bit (0x20)
//  to get the message number.

#define OK      0x40                // means accept token
#define BEG     0x00                // means beginning
#define DEF     0x01                // means normal name
#define BKS     0x0f                // processing bkslash
#define PAR     0x20                // close paren missing
#define CHR     0x21                // bad char in macro
#define BAD     0x22                // single $ w/o macro
#define EQU     0x23                // substitution w/o =
#define NAM     0x24                // illegal macro name
#define SEQ     0x25                // subst w/o strings
#define NOQ     0x26                // no matching quote
#define QUO     0x27                // illegal " in name
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\init.cpp ===
//  INIT.C -- routines to handle TOOLS.INI
//
//    Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Module contains routines to deal with TOOLS.INI file. Functions in TOOLS.LIB
//  have not been used because NMAKE needs to be small and the overhead is too
//  much.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  10-May-1993 HV Revise SearchFileInEnv to take care of cases when path
//                 characters (\,/,:) are used.  This fixed the recursive
//                 problem.
//  22-Apr-1993 HV Rewrite SearchRunPath() to use _makepath(), _searchenv()
//                 Add SearchFileInEnv() helper for SearchRunPath()
//  08-Jun-1992 SS Port to DOSX32
//  02-Feb-1990 SB Replace fopen() by FILEOPEN
//  22-Nov-1989 SB Changed free() to FREE()
//  19-Oct-1989 SB searchHandle passed around as extra param
//  16-Aug-1989 SB error check for fclose() added
//  24-Apr-1989 SB made FILEINFO as void * for OS/2 1.2 support
//  05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//  20-Sep-1988 RB Add SearchRunPath().
//          Remove TOOLS.INI warning.
//  17-Aug-1988 RB Clean up.
//  10-May-1988 rb Find tools.ini in current directory first.
//  27-May-1988 rb Remove NO_INIT_ENTRY warning because of built-ins.

#include "precomp.h"
#pragma hdrstop

//  findTag()
//
//  arguments:  tag     pointer to tag name to be searched for
//
//  actions:    reads tokens from file
//              whenever it sees a newline, checks the next token
//               to see if 1st char is opening paren
//              if no, reads and discards rest of line and
//               checks next token to see if it's newline or EOF
//               and if newline loops to check next token . . .
//              if yes ('[' found), looks on line for tag
//              if tag found, looks for closing paren
//              if ']' found, discards rest of line and returns
//              else keeps looking until end of file or error
//
//  returns:    if successful, returns TRUE
//              if tag never found, returns FALSE

BOOL
findTag(
    char *tag
    )
{
    BOOL endTag;                       // TRUE when find [...]
    size_t n;
    char *s;

    for (line = 0; fgets(buf, MAXBUF, file); ++line) {
        if (*buf == '[') {
            endTag = FALSE;
            for (s = _tcstok(buf+1," \t\n");
                 s && !endTag;
                 s = _tcstok(NULL," \t\n")
                ) {
                n = _tcslen(s) - 1;

                if (s[n] == ']') {
                    endTag = TRUE;
                    s[n] = '\0';
                }

                if (!_tcsicmp(s,tag)) {
                    return(TRUE);
                }
            }
        }
    }

    if (!feof(file)) {
        currentLine = line;
        makeError(0, CANT_READ_FILE);
    }

    return(FALSE);
}


//  tagOpen()
//
//  arguments:  where   pointer to name of environment variable
//                       containing path to search
//              name    pointer to name of initialization file
//              tag     pointer to name of tag to find in file
//
//  actions:    looks for file in current directory
//              if not found, looks in each dir in path (semicolons
//                separate each path from the next in the string)
//              if file is found and opened, looks for the given tag
//
//              (if ported to xenix, tagOpen() and searchPath()
//               should probably use access() and not findFirst().)
//
//  returns:    if file and tag are found, returns pointer to file,
//                opened for reading and positioned at the line
//                following the tag line
//              else returns NULL

BOOL
tagOpen(
    char *where,
    char *name,
    char *tag
    )
{
    char szPath[_MAX_PATH];

    // Look for 'name' in current directory then path.

    _searchenv(name, where, szPath);

    if (szPath[0] == '\0') {
        return(FALSE);
    }

    if (!(file = FILEOPEN(szPath, "rt"))) {
        makeError(0, CANT_READ_FILE, szPath);
    }

    if (findTag(tag)) {
        return(TRUE);                   // look for tag in file
    }

    if (fclose(file) == EOF) {          // if tag not found, close
        makeError(0, ERROR_CLOSING_FILE, szPath);
    }

    return(FALSE);                      // file and pretend file not found
}



//  searchPath()
//
//  arguments:  p       pointer to string of paths to be searched
//              name    name of file being searched for
//
//  actions:    looks for name in current directory, then each
//                directory listed in string.
//
//  returns:    pointer to path spec of file found, else NULL
//
//  I don't use _tcstok() here because that modifies the string that it "token-
//  izes" and we cannot modify the environment-variable string.  I'd have to
//  make a local copy of the whole string, and then make another copy of each
//  directory to which I concatenate the filename to in order to test for the
//  file's existence.

char *
searchPath(
    char *p,
    char *name,
    void *findBuf,
    NMHANDLE *searchHandle
    )
{
    char *s;                           // since it's not in use

    // CONSIDER: Why aren't we using access() here?  FindFirst has problems
    // CONSIDER: with networks and DOS 2.x.  Also maybe cheaper.  [RLB]. */

    // We use FindFirst() because the dateTime of file matters to us
    // We don't need it always but then access() probably uses findFirst()
    // -Sundeep-

    if (findFirst(name, findBuf, searchHandle)) {   // check current dir first
        return(makeString(name));
    }

    // Check if environment string is NULL.  Unnecessary if check is done
    // elsewhere, but it's more convenient and safer to do it here.

    if (p == NULL) {
        return(NULL);
    }

    for (s = buf; ;) {
		while (*p && '\"' == *p) {
			// Quotes should not be used in search paths. If we find any,
			// we ignore them. This way we can form the full path and the
			// filename without quotes and add an enclosing pair of quotes
			// later, if necessary. [DS 14575]
			p++;
		}
        if (!*p || (*s = *p++) == ';') {    // found a dir separator
            if (s == buf) {                 // ignore ; w/out name
                if (*p) {
                    continue;
                }

                return(NULL);               // list exhausted ...
            }

            if (*(s-1) != '\\' && *(s-1) != '/') {  // append path separator
                *s++ = '\\';
            }

            *s = '\0';

            if (_tcspbrk(buf,"*?")) {      // wildcards not allowed
                s = buf;
                continue;
            }

            _tcscpy(s, name);              // append file name, zap

            if (findFirst(buf, findBuf, searchHandle)) {
                return(makeString(buf));
            }

            s = buf;                        // reset ptr to begin of
        }                                   // buf and check next dir
        else {
            ++s;                            // we keep copying chars
        }                                   //  until find ';' or '\0'
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\makefile.inc ===
$(O)\errstr.rc : nmmsg.us
   mkmsg -rc $@ $?

$(O)\nmmsg.h : nmmsg.us
   mkmsg -h $@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\macro.cpp ===
//  Macro.C - contains routines that have to do with macros
//
//  Copyright (c) 1988-1991, Microsoft Corporation. All Rights Reserved.
//
// Purpose:
//  Contains routines that have to do with macros
//
// Revision History:
//  16-May-1991 SB  Created from routines that existed elsewhere

#include "precomp.h"
#pragma hdrstop

static STRINGLIST **lastMacroChain = NULL;

// findMacro - look up a string in a hash table
//
//  Look up a macro name in a hash table and return the entry
//  or NULL.
//  If a macro and undefined, return NULL.

MACRODEF * findMacro(char *str)
{
    unsigned n;
    char *string = str;
    STRINGLIST *found;

    if (*string) {
        for (n = 0; *string; n += *string++);   	//Hash
        n %= MAXMACRO;
#if defined(STATISTICS)
        CntfindMacro++;
#endif
        lastMacroChain = (STRINGLIST **)&macroTable[n];
        for (found = *lastMacroChain; found; found = found->next) {
#if defined(STATISTICS)
            CntmacroChains++;
#endif
            if (!_tcscmp(found->text, str)) {
                return((((MACRODEF *)found)->flags & M_UNDEFINED) ? NULL : (MACRODEF *)found);
            }
        }
    } else {
        // set lastMacroChain, even for an empty name
        lastMacroChain = (STRINGLIST **)&macroTable[0];
    }
    return(NULL);
}

// insertMacro
//
// Macro insertion requires that we JUST did a findMacro, which action set lastMacroChain.

void insertMacro(STRINGLIST * p)
{
#ifdef STATISTICS
    CntinsertMacro++;
#endif
    assert(lastMacroChain != NULL);
    prependItem(lastMacroChain, p);
    lastMacroChain = NULL;
}

// 16/May/92  Bryant    Init the macro table to a known state before
//                      continuing.

void initMacroTable(MACRODEF *table[])
{
    unsigned num;
    for (num = 0; num < MAXMACRO; num++) {
        table[num] = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\lexer.cpp ===
//  LEXER.C -- gets tokens from input, returns them to parse() in parser.c
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the lexical routines of nmake
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  01-Jun-1993 HV  Use UngetTxtChr() instead of ungetc()
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  06-Apr-1993 HV  Change createDosTmp() to use _makepath()
//  22-Mar-1993 HV  Rewrite getPath() to make use of the new _splitpath() and
//                  _makepath() functions.
//  04-Aug-1992 SS  CAVIAR 2266: expand INCLUDE macro in processIncludeFile()
//  08-Jun-1992 SS  Port to DOSX32
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  01-Dec-1989 SB  Changed realloc() to REALLOC()
//  22-Nov-1989 SB  Changed free() to FREE()
//  19-Oct-1989 SB  searchHandle passed around as extra param
//  08-Oct-1989 SB  handle OS/2 1.2 quoted filenames
//  04-Sep-1989 SB  temporary filename generated has a trailing '.' for LINK.EXE
//  24-Aug-1989 SB  Allow $* and $@ in dependency lines
//  18-Aug-1989 SB  Added fclose() return code check
//  31-Jul-1989 SB  Added lookahead to the lexer for \ on dependency lines
//  06-Jul-1989 SB  Remove escaping abilities of '^' in command lines totally
//  29-Jun-1989 SB  Add duplicateInline() to detect duplicate inline filenames
//                  and issue error if duplicates are found
//  26-Jun-1989 SB  Modify ParseScriptFileList() and add nextInlineFile() to
//                  handle complex syntax of Inline file command line.
//  15-Jun-1989 SB  issue error for usage of inline file in an inference rule
//  18-May-1989 SB  Added getPath(), changed processIncludeFile() to have C like
//                  processing of include files
//  16-May-1989 SB  expand macros in include file names; handle '\' processing
//                  in same way for macros and dependency lines
//  15-May-1989 SB  Changed nameStates to 16x14
//  13-May-1989 SB  don't remove ESCH on reading cmd block
//  24-Apr-1989 SB  made FILEINFO as void * and corrected regression in parsing
//                  inline file names
//  14-Apr-1989 SB  inline file names are correctly expanded now
//  06-Apr-1989 SB  ren removeFirstLtLt() as delInlineSymbol().
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  22-Mar-1989 SB  removed unlinkTmpFiles() function; not needed
//  19-Jan-1989 SB  added function removeFirstLtLt() to remove '<<' appearing
//                  in -n output
//  30-Dec-1988 SB  Fixed GP fault for KEEP/NOKEEP in parseScriptFileList()
//                  and makeScriptFileList()
//  21-Dec-1988 SB  Added parseScriptFileList() and appendScript() to allow
//                  handling of multiple script files inside a makefile
//                  Improved KEEP/NOKEEP so that each file can have its own
//                  action
//  16-Dec-1988 SB  Added to makeScriptFile() for KEEP/NOKEEP
//  14-Dec-1988 SB  Added tmpScriptFile so that a delete command can be
//                  added for unnamed script files for Z option
//  13-Dec-1988 SB  Added processEschIn() to improve response files
//   5-Oct-1988 RB  Strip trailing whitespace from macro defs, build lines.
//  22-Sep-1988 RB  Fix skipComments() to not parse \\nl.
//  20-Sep-1988 RB  Error if named script file creation fails.
//                  Count line numbers in script files.
//  18-Sep-1988 RB  Handle mktemp() small limit.
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Fixed handling of ^ before !, @, or -.
//   8-Jul-1988 rj  Added handler to ignore ^ inside quotes.
//                  Made \ carry comments over lines.
//                  Made ^ carry comments over lines.
//  27-Jun-1988 rj  Fixed bug with handling of response files.
//  16-Jun-1988 rj  Finished up ESCH.
//  15-Jun-1988 rj  Added support for ESCH escape:  modified skipWhiteSpace
//                  (adding some redundancy in setting colZero), getString,
//                  getName; removed \\nl escape.
//  13-Jun-1988 rj  Fixed backslashes to work as in nmake, with addition of
//                  double-backslash escape.  (v1.5)

#include "precomp.h"
#pragma hdrstop

#define COMMENT(A,B,C)      (((A) == ';' && B && C) || ((A) == '#'))
#ifdef _MBCS
#define GET(A)              A ? GetTxtChr(file) : lgetc()
#else
#define GET(A)              A ? getc(file) : lgetc()
#endif

extern char       * makeInlineFiles(char*, char**, char**);
extern void         removeTrailChars(char *);

void          skipComments(UCHAR);
void          getString(UCHAR,char*,char*);
void          getName(char*,char*);
UCHAR         determineTokenFor(int,char*,char*);
void          popFileStack(void);
UCHAR         include(int);
char        * getPath(const char *);

extern const UCHAR nameStates[18][15];
extern const UCHAR stringStates[13][14];
extern STRINGLIST *targetList;


//  getToken()
//
//  arguments:  init        global boolean value -- TRUE if tools.ini is the
//                           file being lexed
//              n           size of s[]
//              expected    kind of token expected by parser -- only
//                           needed when parser wants a whole string
//                           (meaning everything left on the current line)
//                           -- this way getToken() doesn't break strings
//                           into their separate tokens
//
//  actions:    if no tokens have been read from current file,
//              returns some kind of newline to initialize the parser
//               (if 1st char in file is whitespace, returns NEWLINESPACE
//              else returns NEWLINE -- w/o actually getting a token
//               from the input)
//              if the parser wants a whole string, reads rest of line
//               into s and returns STRING
//              if at end of file, return ACCEPT (which is the last
//               symbol on the parser's stack)
//              if input char is newline
//              if followed by whitespace, return NEWLINESPACE
//              if the next char is [ and we're reading tools.ini
//               pretend that we've reached end of file and
//               return ACCEPT
//              otherwise return NEWLINE
//              if input char is colon
//              if following char is also colon,
//                (put both chars in s) return DOUBLECOLON
//              otherwise return SINGLECOLON
//              if input char is semicolon return SEMICOLON
//              if input char is equals return EQUALS
//              if input char is exclamation handle directives
//               (not yet implemented)
//              otherwise char must be part of a name, so gather
//              the rest of the identifier and return NAME
//
//  returns:    token type: NEWLINE NEWLINESPACE NAME EQUALS COLON
//              SEMICOLON STRING ACCEPT
//
//  modifies:   buf     by modifying *s, which points somewhere into buf
//              line    global line count
//              fname   will change when !include is handled
//              colZero global flag set if at column zero of a file
//
//  The lexer has to keep track of whether or not it is at the beginning
//  of a line in the makefile (i.e. in column zero) so that it will know
//  whether to ignore comments.  If init is TRUE, meaning that we are
//  lexing tools.ini, then we have to treat lines beginning with ';' as
//  comment lines.  If the parser expects a string, only comments beginning
//  in column zero are ignored; all others are returned as part of the
//  string.  Comments are stripped from macro values (strings that are
//  part of macro definitions).
//
//  The user can specify a macro definition or a build line that
//  spans several lines (using the \<newline> to "continue" the lines) while
//  interspersing comment lines with the text.

UCHAR
getToken(
    unsigned n,                         // size of s[]
    UCHAR expected                      // STRING means get line
    )                                   //  w/o checking for #;:=
{
    char *s;
    char *end;
    int c;

    s = buf;
    end = buf + n;
    if (firstToken) {                   // global var
        ++line;
        firstToken = FALSE;             // parser needs to see some kind of
        c = lgetc();                    // newline to initialize it
        if (colZero = (BOOL) !WHITESPACE(c)) {
            if (c == EOF)
                return(determineTokenFor(c,s,end));
            else
                UngetTxtChr(c,file);
            return(NEWLINE);
        }
        return(NEWLINESPACE);
    }

    if (expected == STRING || expected == VALUE) {  // get everything up to \n
        getString(expected,s,end);
        return(expected);
    }                                   // were/are we
    c = skipWhiteSpace(FROMLOCAL);      //  past col 0?
    *s++ = (char) c;                    // save the letter
    *s = '\0';                          // terminate s
    return(determineTokenFor(c,s,end));
}


//  determineTokenFor()
//
//  arguments:  c       current input character
//              s       buffer to place token in for return to parser
//              end     end of the token return buffer
//
//  returns:    token type: NEWLINE NEWLINESPACE NAME EQUALS COLON
//                          SEMICOLON ACCEPT
//
//  modifies:   buf     by modifying *s, which points somewhere into buf
//              line    global line count
//              fname   will change when include is handled
//              init    global flag - set if parsing tools.ini
//              colZero global flag set if at column zero of a file

UCHAR
determineTokenFor(
    int c,
    char *s,
    char *end
    )
{
    switch (c) {
        case EOF:
            if (!feof(file))
                makeError(line,LEXER+FATAL_ERR);
            if (incTop)
                popFileStack();
            else if (ifTop >= 0)        // all directives not processed
                makeError(line,SYNTAX_EOF_NO_DIRECTIVE);
            else
                return(ACCEPT);

        case '\n':
            ++line;
            colZero = TRUE;
            c = lgetc();
            if (COMMENT(c,TRUE,init)) {
                skipComments(FROMLOCAL);
                ++line;
                colZero = TRUE;         // manis - 11/13/87
                c = lgetc();
            }
            if (colZero = (BOOL) !WHITESPACE(c)) {
                if (c == EOF)
                    return(determineTokenFor(c,s,end));
                else
                    UngetTxtChr(c,file);    //save for next token
                return(NEWLINE);
            }
            return(NEWLINESPACE);

        case ':':
            colZero = FALSE;
            if ((c = lgetc()) == ':') {
                *s++ = (char) c;
                *s = '\0';
                return(DOUBLECOLON);
            }
            UngetTxtChr(c,file);
            return(COLON);

        case ';':
            colZero = FALSE;
            return(SEMICOLON);

        case '=':
            colZero = FALSE;
            return(EQUALS);

        case '[':
            if (init && colZero)
                return(ACCEPT);

        case ESCH:
            UngetTxtChr(c, file);       // getName has to get esch
            s--;                        // so we don't double the caret

        default:
            getName(s,end);
            if (colZero && !_tcsicmp(buf, "include")) {
                colZero = FALSE;
                if ((c = skipWhiteSpace(FROMLOCAL)) != ':'
                        && c != '=')  {
                    if (init)
                        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
                    return(include(c));
                }
                UngetTxtChr(c,file);
            } else
                colZero = FALSE;
            return(NAME);
    }
}


//  skipWhiteSpace()
//
//  arguments:  c       current input character
//              init    global boolean value -- TRUE if we're lexing tools.ini
//              colZero global boolean value -- TRUE if the current
//                       input char is at the beginning of the line
//
//  actions:    reads and discards characters until it gets a
//              non-whitespace char that isn't part of a comment
//              or hits the end of the line (NEWLINE and NEWLINESPACE
//              are valid tokens and shouldn't be skipped w/ whitespace)
//              backslash-newline ('\\''\n') is treated as whitespace
//              comments are treated as whitespace
//              escaped whitespace is treated as whitespace (v1.5)
//
//  modifies:   colZero global boolean value to :
//              TRUE if by skipping whitespace and comments we're
//              at the beginning of a line
//              else if we skipped characters and are not at the
//              beginning of a line, FALSE
//              else if we did not skip any characters, leave
//              colZero unchanged
//
//  returns:    c       the current non-whitespace input char

int
skipWhiteSpace(
    UCHAR stream
    )
{
    int c;

    do {
        c = GET(stream);
        if (WHITESPACE(c) || c == ESCH) {
            if (c == ESCH) {
                c = GET(stream);
                if (!WHITESPACE(c)) {   // push char back out, return esch
                    UngetTxtChr(c, file);
                    c = ESCH;
                    break;
                }
            }
            colZero = FALSE;            // we've moved past col 0
        }

        if (c == '\\')
            c = skipBackSlash(c, stream);
    } while(WHITESPACE(c));

    if (COMMENT(c,colZero,init)) {
        skipComments(stream);           // current char is always
        c = '\n';                       // \n after comments
        colZero = TRUE;                 // always in col 0 after a comment
    }
    return(c);                          // true if we're in col 0
}


//  ----------------------------------------------------------------------------
//  skipComments()
//
//  arguments:  c       pointer to current input character
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//
//  actions:    reads and discards characters until it hits the end of
//              the line
//              checks to see if 1st char on next line is comment,
//              and if so, discards that line, too
//              DO NOT parse backslash-newline.  That would break our
//              precedence of comments over escaped newlines, the reverse
//              of Xenix.
//
//  modifies:   line    global line count
//              colZero

void
skipComments(
    UCHAR stream
    )
{
    int c;

    for (;;) {
        colZero = FALSE;                // manis 11/13/87
        do {
            c = GET(stream);
        } while (c != EOF && c != '\n');

        if (c == EOF)
            return;
        colZero = TRUE;
        c = GET(stream);
        if (!COMMENT(c,TRUE,init)) {    // if next line comment,
            UngetTxtChr(c,file);        //  go around again
            return;
        }
        ++line;
    }
}


//  skipBackSlash()  - skips backslash-newline sequences
//
//
//  arguments:  c       current input char
//              stream  flag to determine if chars are to be got
//                       from the raw stream or thru' lgetc()

int
skipBackSlash(
    int c,
    UCHAR stream
    )
{
    while (c == '\\') {                     // treat \newline as space
        if ((c = GET(stream)) == '\n') {    //    and consume it too
            colZero = TRUE;                 // manis - 11/13-87
            ++line;                         // adjust line count
            c = GET(stream);                // skip over newline
            if (COMMENT(c,TRUE,init)) {     // skip comment line after
                skipComments(stream);       //    continuation char
                ++line;                     // manis - 11/13/87
                c = GET(stream);
            }
        } else {
            UngetTxtChr(c,file);
            c = '\\';
            return(c);
        }
    }
    return(c);
}


//  getString()
//
//  arguments:  type    says which kind of token we're getting,
//                       a build STRING, or macro VALUE
//                       (we strip comments from VALUEs, but not
//                       from STRINGs)
//              s       pointer to buffer that will hold string
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//              colZero global boolean value -- true if we 're in
//                       1st position of line when invoked
//              end     pointer to end of s[]
//
//  actions:    gets all chars up to the end of line or end of file
//              and stores them in s[]
//              backslash followed by newline is replaced by a single
//              space, and getString() continues getting characters
//              comments beginning in column 0 are ignored, as are
//              comments anywhere on a VALUE line
//
//  modifies:   buf     by modifying *s
//              line    global line count
//              colZero thru' calls to lgetc()
//
//  When build strings or macro values are continued on the next line w/
//  a backslash before the newline, leading whitespace after the newline
//  is omitted.  This is for xmake compatibility.
//
//  The continuation character is backslash immediately before newline.
//
//  The only difference between build strings and macro values is that
//  comments are stripped from macro values and not from build strings.
//
//  Modifications:
//
//    06-Jul-1989 SB remove escaping in command lines
//    15-Jun-1988 rj Added escape functionality.  Escape char., before
//               certain characters, causes those characters to bypass
//               the normal mechanism determining their type; they are
//               placed directly into the string.  Some characters cause
//               the escape character itself to be placed into the
//               string.

void
getString(
    UCHAR type,                         // build string or macro value?
    char *s,
    char *end
    )
{
    int c;                              // buffer
    UCHAR state, input;
    int tempC;
    unsigned size;                      // whenever state
    char *begin;                        //    is 0, we're in
                                        //    column zero
    BOOL parsechar;                     // flag to examine char. type
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks

    begin = s;
    c = lgetc();
    if (type == STRING)
        state = (UCHAR) 2;
    else if (WHITESPACE(c)) {
        state = (UCHAR) 2;
        c = skipWhiteSpace(FROMLOCAL);
    } else if (c == ESCH) {
        c = lgetc();
        if (WHITESPACE(c)) {
            state = (UCHAR) 2;
            c = skipWhiteSpace(FROMLOCAL);
        } else {
            UngetTxtChr(c, file);
            state = (UCHAR) 1;          // default state
            c = ESCH;
        }
    } else
        state = (UCHAR) 1;              // default state

    for (;;c = lgetc()) {
        if (c == '\"')
            inQuotes = (BOOL) !inQuotes;
        parsechar = 1;                  // Default is examine character.
        if (c == ESCH && !inQuotes && type == VALUE) {
            c = lgetc();
            switch (c) {
                case '$': case ESCH:    // Special characters; must
                case '{': case '}':     // not elide esch from string
                case '(': case ')':
                case '!': case '-': case '@':
                    *s++ = ESCH;
                    if (s == end) {
                        if (string == NULL) {       // Increase size of s
                            string = (char *) allocate(MAXBUF<<1);
                            _tcsncpy(string,begin,MAXBUF);
                            s = string + MAXBUF;
                            size = MAXBUF << 1;
                            end = string + size;
                        } else {
                            if ((size + MAXBUF < size)  // overflow error
                                || !(string = (char *) REALLOC(string,size+MAXBUF)))
                                makeError(line, MACRO_TOO_LONG);
                            s = string + size;
                            size += MAXBUF;
                            end = string + size;
                        }
                        begin = string;
                    }
                case '#': case '\n':        // elide esch right now!
                case '\\': case '\"':
                    input = DEFAULT_;
                    parsechar = 0;          // DON'T examine character
                    break;
                default:
                    break;                  // DO examine character.
            }
        } else if (c == ESCH) {
            c = lgetc();
            UngetTxtChr(c, file);
            c = ESCH;
        }

        if (parsechar) {
            switch (c) {
                case '#':   input = COMMENT_;       break;
                case '=':   input = EQUALS_;        break;
                case ':':   input = COLON_;         break;
                case '$':   input = DOLLAR_;        break;
                case '(':   input = OPENPAREN_;     break;
                case ')':   input = CLOSEPAREN_;    break;
                case '\\':  input = BACKSLASH_;     break;
                case '\n':
                case EOF:   input = NEWLINE_;       break;
                case ' ':
                case '\t':  input = WHITESPACE_;    break;
                case '*':   input = STAR_;          break;
                case '@':
                case '<':
                case '?':   input = SPECIAL1_;      break;
                case 'F':
                case 'D':
                case 'B':
                case 'R':   input = SPECIAL2_;      break;
                case ';':   input = (UCHAR) (!state && init ? COMMENT_ : DEFAULT_);
                    break;          /* Handle comments in tools.ini */

                default:    input = (UCHAR) (MACRO_CHAR(c) ? MACROCHAR_:DEFAULT_);
                    break;
            }
        }
        if (input == SPECIAL1_ && type == STRING && c == '<') {
            if ((tempC = lgetc()) == '<') {             // << means start
                s = makeInlineFiles(s, &begin, &end);   // an inline file
                input = NEWLINE_;
                c = '\n'; line--;       // adding a '\n', we need to remove a line to compensate
            } else {
                UngetTxtChr(tempC,file);
            }
            state = stringStates[state][input];
        } else if (input == COMMENT_) {                 // Handle comments
            if (!state) {
                inQuotes = (BOOL) FALSE;
                skipComments(FROMLOCAL);
                ++line;
                continue;
            }
            else if (type == VALUE)
                state = OK;             // don't elide from command
            else
                state = stringStates[state][input];
        } else
            state = stringStates[state][input];

        if (state == OK) {              // Accept end of string
            inQuotes = (BOOL) FALSE;
            UngetTxtChr(c,file);

            // Strip trailing whitespace from string.  Easier to do it here,
            // else we have to treat a multi-string value (OBJS=a b c) as
            // separate tokens.  [RB]

            while (s > begin && _istspace(s[-1]))
                --s;
            *s = '\0';
            if (string) {
                if (s = (char *) REALLOC(string, (size_t) (s - string + 1)))
                    string = s;
            } else
                string = makeString(begin);
            return;
        } else if (ON(state,ERROR_MASK))        // Error code from table
            makeError(line,(state&~ERROR_MASK)+FATAL_ERR,c);

        if (!state) {                   // Col 0; we just hit \nl
            *--s = ' ';                 // so treat it like white-
            ++s;  ++line;               // space; overwrite the
            colZero = TRUE;             // backslash with a space.
            c = lgetc();
            colZero = FALSE;
            if (WHITESPACE(c)) {
                state = 2;
                do {
                    c = lgetc();
                } while (WHITESPACE(c));
            }
            UngetTxtChr(c,file);
        } else {                        // Keep storing string
            *s++ = (char) c;
            if (s == end) {
                if (!string) {          // Increase size of s
                    string = (char *) allocate(MAXBUF<<1);
                    _tcsncpy(string,begin,MAXBUF);
                    s = string + MAXBUF;
                    size = MAXBUF << 1;
                    end = string + size;
                } else {
                    if ((size + MAXBUF < size)      // overflow error
                        || !(string = (char *) REALLOC(string,size+MAXBUF)))
                        makeError(line, MACRO_TOO_LONG);
                    s = string + size;
                    size += MAXBUF;
                    end = string + size;
                }
            }
        }
    }
}


//  getName()
//
//  arguments:  s       pointer into buffer that will hold string
//                       (s is pointing to buf+1 when passed, because
//                       the caller, getToken(), has already seen and
//                       saved one char)
//              init    global boolean value -- TRUE if tools.ini is the
//                       file being lexed
//                       used by routine called - lgetc()
//              end     pointer to end of s[]
//
//  actions:    gets all chars up to first token delimiter and stores
//              them in s[] (delimiters are ' ', '\t', '\n' and (when
//              not inside a macro invocation) ':' and '='
//              note that backslash-newline is treated as a space,
//              which is a delimiter
//              if the current input char is '$' this must be a macro
//              invocation
//              if the macro name is in parentheses
//                get all chars up to and including close paren
//                (if ')' not found, error)
//
//  We check the syntax within the name here -- thus errors in macro
//  invocation syntax will be caught.  Special macros cannot be used
//  as part of names, with the exception of the dynamic dependency macros.
//
//  We can probably never overrun our buffer, because it would be extremely
//  difficult for the user to get a name with 1024 characters or more into
//  his makefile.
//
//  we never end up in column zero, because we push the delimiter back
//  out on the input
//
//  uses state table defined in table.h, defs from grammar.h
//
//    modifies: line    (possibly) thru' call to lgetc()
//              file    (possibly) if lgetc() finds a !include
//              fName   (possibly) if lgetc() finds a !include

void
getName(
    char *s,
    char *end                           // pts to end of s
    )
{
    int c;
    UCHAR state, input;
    BOOL seenBackSlash = FALSE;
    BOOL fQuoted = FALSE;
    char *beg = s - 1;
    BOOL parsechar;                     // flag to examine char. type

    switch (*(s-1)) {
        case '$':   state = (UCHAR) 2;    break;
        case '{':   state = (UCHAR) 8;    break;
        case '"':   fQuoted = TRUE; state = (UCHAR)16; break;
        default:    state = (UCHAR) 0;    break;
    }

    for (;;) {
        c = lgetc();
        parsechar = 1;                  // Default is examine char.
        if (c == ESCH) {
            c = lgetc();
            switch (c) {
                case '{':               // Special characters; must
                case '}':               // not elide esch from string
                case '(':
                case ')':
                case '$':
                case ESCH:
                    *s++ = ESCH;

                case '#':               // elide esch right now!
                case '\n':
                case '\\':
                    input = DEFAULT_;
                    parsechar = 0;      // DON'T examine character
                    break;
                default:
                    break;              // DO examine character.
        }
    }
    if (parsechar) {
        switch (c) {
            case '#' :  input = COMMENT_;        break;
            case '=' :  input = EQUALS_;        break;
            case ';' :  input = SEMICOLON_;     break;
            case ':' :  input = COLON_;        break;
            case '$' :  input = DOLLAR_;        break;
            case '(' :  input = OPENPAREN_;     break;
            case ')' :  input = CLOSEPAREN_;    break;
            case '{' :  input = OPENCURLY_;     break;
            case '}' :  input = CLOSECURLY_;    break;
            case ' ' :
            case '\t':  input = (UCHAR)((fQuoted)
                       ? DEFAULT_ : WHITESPACE_);
                break;
            case '\n':
            case EOF :  input = NEWLINE_;        break;
            case '\\':  input = BKSLSH_;        break;
            case '"' :  input = QUOTE_; 
				if (state == 18) {
					// found a quote after a path list {...}
					// handle as quoted name
					fQuoted = 1;
				}
				break;

            // Add support for $* and $@ on the dependency line
            default  :
                if (ON(actionFlags, A_DEPENDENT))
                    input = (UCHAR)((MACRO_CHAR(c) || c == '*' || c == '@')
                         ?MACROCHAR_:DEFAULT_);
                else
                    input = (UCHAR)(MACRO_CHAR(c)?MACROCHAR_:DEFAULT_);
                break;
        }
    }
    state = nameStates[state][input];

    // Cheat lex table to think that you are handling quoted string case

    if (fQuoted && state == 1)
        state = 16;
	
    // seenBackSlash is used to provide lookahead when \ is seen on a
    // dependency line
    if (seenBackSlash)
        // if \ followed by \n then use it as a continuation
        if (input == NEWLINE_) {
            ++line;
            colZero = TRUE;
            c = lgetc();
            colZero = FALSE;
            if (WHITESPACE(c)) {
                state = OK;
                do {
                    c = lgetc();
                } while (WHITESPACE(c));
            } else
                state = (UCHAR)((s == buf + 1) ? BEG : DEF);
        } else
            *s++ = '\\';
        seenBackSlash = FALSE;
        if (s >= end)
            makeError(line,NAME_TOO_LONG);
        if (state == OK) {
            UngetTxtChr(c,file);
            *s = '\0';
            removeTrailChars(beg);
            return;
        } else if (ON(state,ERROR_MASK))
            makeError(line,(state&~ERROR_MASK)+FATAL_ERR,c);

        if (state == BKS) {
            seenBackSlash = TRUE;       //set lookahead flag
        } else
            *s++ = (char) c;
    }
}


//  createDosTmp -- Creates a unique temporary file.
//
// Scope:
//  Global.
//
// Purpose:
//  To create a unique temporary file by calling _mktemp() but it gets
//  over _mktemp() limitation to be able to create more files.
//
// Input:
//  path -- The buffer initially contain the directory to store the temp
//          file.  On exit, if success, the temp file is appended to it.
//          In case of failure, the its contents is undetermined.
//
// Output:
//  If successful, temporary file name is appended to path and
//  the function returns the file pointer, else NULL.
//
// History:
//  06-Apr-1993 HV Change createDosTmp() to use _makepath()

FILE *
createDosTmp(
    char *path
    )
{
    FILE       *fd = NULL;

    // CONSIDER: is the size of szDir too big for the stack?  We can
    //           make it a little smaller if we take the risk.

    char        szDir[_MAX_PATH];

    // CONSIDER: The path supplied by the caller might contain both
    //           the drive and probably some level of directories
    //           (e.g. c:\win\tmp)  Right now, _makepath happily takes
    //           the whole thing as the directory component, but that
    //           might change in the future.  In such case, we should
    //           first break up path to drive/dir compents before we
    //           construct the full pathname of the template.  There
    //           is something to watch out: for "c:\win\tmp", _splitpath
    //           will split as: "c:", "\win\", and "tmp", which is not
    //           what we want.  To fix it, append a backslash to the
    //           end before calling _splitpath.  "c:\win\tmp\" will
    //           be broken up correctly to "c:" and "\win\tmp\"

    if (!path || !*path) {             // If path is empty, use "."
        _tcscpy(szDir, ".");
    } else {
        _tcscpy(szDir, path);
    }

#if 0
    static char filetemplate[] = "nmXXXXXX";
    static char szExtension[] = ".";    // just a dot to make Mr. linker happy.
    // Construct the full pathname.  _mktemp() doesn't seem to like
    // template with trailing dot (".") so instead of specifying "."
    // for the extension, we defer it later and _tcscat the dot to
    // its tail.
    _makepath(path, NULL, szDir, filetemplate, NULL);

    if (_mktemp(path) == NULL) {
        // Mktemp() has a limit of 27 files per template.  If it fails, assume
        // the limit has overflowed and increment the second letter of the template.

        if (filetemplate[1] == 'z') {
            filetemplate[1] = 'a';
        } else {
            ++filetemplate[1];          // ASSUMPTION: that this will work with DBCS
        }

        _makepath(path, NULL, szDir, filetemplate, NULL);

        if (_mktemp(path) == NULL) {
            return(NULL);
        }
    }

    // add a trailing "." for the linker's sake
    _tcscat(path, szExtension);

#endif


    // Use GetTempFileName to overcome limitations of _mktemp 
    // regarding the max number of generated files [vs7:5255]
    char szTempFile[_MAX_PATH];
    if (GetTempFileName (path, "nm", 0, szTempFile)) {
        _tcscpy(path, szTempFile);
        // Open the file and return the file's descriptor.
        fd = FILEOPEN(path, "w");
    }

    return fd;
}


void
popFileStack()
{
    if (fclose(file) == EOF)
       makeError(0, ERROR_CLOSING_FILE, fName);
    FREE(fName);
    file = incStack[--incTop].file;
    fName = incStack[incTop].name;
    line = incStack[incTop].line;
}


//  include()  -- handle include files
//
//  arguments:  c       first non-whitespace char after the string
//                       INCLUDE on the line...
//              colZero global boolean value, set if currently at
//                       column zero of a file.
//
//  modifies:   line     global line count - if include file opened
//              file     global pointer to current file
//              fName    global pointer to name of current file
//              colZero  global boolean value, changed if include
//                        file opened and char from colZero is returned

UCHAR
include(
    int c
    )
{
    size_t n;
    char *s;

    if (c == '\n' || c == EOF)
        makeError(line,SYNTAX_NO_NAME);

    *buf = (char) c;
    if (!fgets(buf+1,MAXBUF - 1,file)) {
        if (feof(file))
            makeError(line,SYNTAX_UNEXPECTED_TOKEN,"EOF");
        makeError(line,CANT_READ_FILE);
    }
    n = _tcslen(buf) - 1;
    if (buf[n] == '\n') {
        buf[n] = '\0';
    }
    s = buf;
    while (WHITESPACE(*s))
        ++s;
    return(processIncludeFile(s));
}


//  processIncludeFile()  -- checks for include file and switches state
//
//  arguments:  s       buffer that has include file name
//              colZero global boolean value, set if currently at
//                       column zero of a file.
//              init    global boolean - set if tools.ini is being lexed
//                       used by lgetc() which is called from here...
//
//  modifies:   line    global line count - if include file opened
//              file    global pointer to current file
//              fName   global pointer to name of current file
//              colZero global boolean value, changed if include
//                       file opened and char from colZero is returned

UCHAR
processIncludeFile(
    char *s
    )
{
    MACRODEF *m;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;
    char *t, *p, *u;
    int c = 0;
    int i;

    if (!*s || *s == '#') {
        makeError(line, SYNTAX_NO_NAME);
    }

    if (t = _tcspbrk(s,"\t#")) {
        if (*t == '#') {
            c = *t;
        }

        *t = '\0';

        if (!c) {
            for (u = t; *++u;) {        // check for extra
                if (*u == '#') {
                    break;              // text on line
                }

                if (!WHITESPACE(*u)) {
                    makeError(line, SYNTAX_UNEXPECTED_TOKEN, u);
                }
            }
        }
    } else {
        t = s + _tcslen(s);
    }

	// remove trailing white space
	while (t > s) {
		char *prev;
		prev = _tcsdec(s, t);
		if (!WHITESPACE(*prev))
			break;
		t = prev;
	}
	*t = '\0';

    if (*s == '<' && *(t-1) == '>') {
        char *pt;

        *--t = '\0';
        p = removeMacros(++s);
        p = p == s ? makeString(s) : p;
        t = (m = findMacro("INCLUDE")) ? m->values->text : (char*) NULL;
        if (t != NULL) {        // expand INCLUDE macro before passing it on
            char * pt1;

            pt1= makeString(t);
            pt = removeMacros(pt1);
            if (pt != pt1) {
                FREE(pt1);             // we've got a new string, free old one
            }
        } else {
            pt = NULL;
        }

        if (!(u = searchPath(pt, p, &finddata, &searchHandle))) {
            makeError(line, CANT_OPEN_FILE, p);
        }

        if (pt) {
            FREE(pt);
        }

        FREE(p);
        s = u;
    } else {
        if (*s == '"' && *(t-1) == '"') {
            *--t = '\0';
            ++s;
        }
        p = removeMacros(s);
        p = p == s ? makeString(s) : p;
        if (!findFirst(p, &finddata, &searchHandle)) {
            if (!_tcspbrk(p, "\\/:")) {
                //use C sematics for include
                for (i = incTop;i >= 0;i--) {
                    t = (i == incTop) ? fName : incStack[i].name;
                    if (!(t = getPath(t)))
                        continue;
                    u = (char *)allocate(_tcslen(t) + 1 + _tcslen(p) + 1);
                    _tcscat(_tcscat(_tcscpy(u, t), "\\"), p);
                    if (findFirst(u, &finddata, &searchHandle)) {
                        s = u;
                        FREE(t);
                        break;
                    }
                    FREE(t);
                    FREE(u);
                }
                FREE(p);
                if (i < 0) {
                    makeError(line, CANT_OPEN_FILE, s);
                }
            } else {
                makeError(line, CANT_OPEN_FILE, p);
            }
        }
    }

    for (i = 0; i < incTop; ++i) {      // test for cycles
        if (!_tcsicmp(s,incStack[i].name)) {
            makeError(line, CYCLE_IN_INCLUDES, s);
        }
    }

    incStack[incTop].file = file;       // push info on stack
    incStack[incTop].line = line;
    incStack[incTop++].name = fName;
    currentLine = 0;

    if (!(file = OpenValidateMakefile(s,"rt"))) {   // read, text mode
        makeError(line,CANT_OPEN_FILE,s);
    }

    fName = makeString(s);
    line = 1;
    colZero = TRUE;                     // parser needs to see some kind of
    c = lgetc();                        //  newline to initialize it for this

    if (colZero = (BOOL) !WHITESPACE(c)) {  // file
        UngetTxtChr(c,file);
        line=0;                         // We did not start reading the file
        return(NEWLINE);
    }

    return(NEWLINESPACE);
}


//  getPath -- return the drive/directory parts of a full path
//
// Scope:
//  Local
//
// Purpose:
//  This function returns the drive/directory parts of a full path.  Space is
//  allocated for the resulting string, so the caller is responsible for freeing
//  it after use.
//
// Input:   pszFullPath -- The full pathname.
//
// Assumes: Pathnames use MS-DOS file naming convension.
//
// Notes:
//  To allocate temporary memory for the drive and path components, I have used
//  _MAX_DRIVE and _MAX_DIR.  Under Windows NT there are two possibilities:
//  1. These two parameters can be so large that the stack will be overflow
//  2. They are not large enough (?)
//
// History:
//  22-Mar-1993 HV Rewrite getPath() to make use of the new _splitpath() and
//          _makepath() functions.

char *
getPath(
    const char *pszFullPath
    )
{
    // HV: Are _MAX_DRIVE and _MAX_DIR good size under NT?  Does it
    // work under Windows NT?
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char *szPath;
    char *pszSlash;

    // Separate the components of the fullpath
    _splitpath(pszFullPath, szDrive, szDir, NULL, NULL);

    // Allocate just enough memory to hold the drive/path combo then
    // Glue just the drive and dir component back together.
    szPath = (char *) rallocate(_tcslen(szDrive) + _tcslen(szDir) + 1);
    _makepath(szPath, szDrive, szDir, NULL, NULL);

    // Eliminate the trailing slash/blackslash to retain compatibility with
    // the older version of getPath()
    pszSlash = szPath + _tcslen(szPath) - 1;
    if ('\\' == *pszSlash || '/' == *pszSlash) {
        *pszSlash = '\0';
    }

    return szPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\nmake.cpp ===
//  NMAKE.C - main module
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This is the main module of nmake
//
// Revision History:
//  01-Feb-1994 HV  Move messages to external file.
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  26-Mar-1992 HV  Rewrite filename() to use _splitpath()
//  06-Oct-1992 GBS Removed extern for _pgmptr
//  08-Jun-1992 SS  add IDE feedback support
//  08-Jun-1992 SS  Port to DOSX32
//  29-May-1990 SB  Fix precedence of predefined inference rules ...
//  25-May-1990 SB  Various fixes: 1> New inference rules for fortran and pascal;
//                  2> Resolving ties in timestamps in favour of building;
//                  3> error U1058 does not echo the filename anymore (ctrl-c
//                  caused filename and lineno to be dispalyed and this was
//                  trouble for PWB
//  01-May-1990 SB  Add predefined rules and inference rules for FORTRAN
//  23-Apr-1990 SB  Add predefined rules and inference rules for COBOL
//  20-Apr-1990 SB  Don't show lineno for CTRL+C handler error
//  17-Apr-1990 SB  Pass copy of makeflags to putenv() else freeing screws the
//                  DGROUP.
//  23-Feb-1990 SB  chdir(MAKEDIR) to avoid returning to bad directory in DOS
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  31-Jan-1990 SB  Postpone defineMAcro("MAKE") to doMAke(); Put freshly
//                  allocated strings in the macro table as freeStructures()
//                  free's the macroTable[]
//  24-Jan-1990 SB  Add byte to call for sprintf() for "@del ..." case for /z
//  29-Dec-1989 SB  ignore /Z when /T also specified
//  29-Dec-1989 SB  nmake -? was giving error with TMP directory nonexistent
//  19-Dec-1989 SB  nmake /z requests
//  14-Dec-1989 SB  Trunc MAKEFLAGS averts GPF;Silently ignore /z in protect mode
//  12-Dec-1989 SB  =c, =d for NMAKE /Z
//  08-Dec-1989 SB  /NZ causes /N to override /Z; add #define TEST_RUNTIME stuff
//  01-Dec-1989 SB  Contains an hack #ifdef'ed for Overlayed version
//  22-Nov-1989 SB  Changed free() to FREE()
//  17-Nov-1989 SB  defined INCL_NOPM; generate del commands to del temps
//  19-Oct-1989 SB  ifdef SLASHK'ed stuff for -k
//  04-Sep-1989 SB  echoing and redirection problem for -z fixed
//  17-Aug-1989 SB  added #ifdef DEBUG's and error -nz incompatible
//  31-Jul-1989 SB  Added check of return value -1 (error in spawning) for -help
//                  remove -z option help message
//  12-Jul-1989 SB  readEnvironmentVars() was not using environ variable but an
//                  old pointer (envPtr) to it. In the meantime environ was
//                  getting updated. Safer to use environ directly.
//  29-Jun-1989 SB  freeStructures() now deletes inlineFileList also
//  28-Jun-1989 SB  changed deletion of inline files to end of mainmain() instead of
//                  doMake() to avoid deletion when a child make quits.
//  19-Jun-1989 SB  modified .bas.obj to have ';' at end of cmd line
//  21-May-1989 SB  freeRules() gets another parameter to avoid bogus messages
//  18-May-1989 SB  change delScriptFiles() to do unlink instead of calling
//                  execLine. Thus, ^C handling is better now. No more hangs
//  15-May-1989 SB  Added /make support; inherit /nologo
//  13-May-1989 SB  Changed delScriptFiles(); added MAKEDIR; Added BASIC rules
//                  Changed chkPrecious()
//  01-May-1989 SB  Changed FILEINFO to void *; OS/2 Version 1.2 support
//  17-Apr-1989 SB  on -help spawn 'qh /u nmake' instead. rc = 3 signals error
//  14-Apr-1989 SB  no 'del inlinefile' cmd for -n. -z now gives 'goto NmakeExit'
//                  CC and AS allocated of the heap and not from Data Segment
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  27-Mar-1989 SB  Changed unlinkTmpFiles() to delScriptFiles()
//  10-Mar-1989 SB  Removed blank link from PWB.SHL output
//  09-Mar-1989 SB  changed param in call to findRule. fBuf is allocated on the
//                  heap in useDefaultMakefile()
//  24-Feb-1989 SB  Inherit MAKEFLAGS to Env for XMake Compatibility
//  22-Feb-1989 SB  Ignore '-' or '/' in parseCommandLine()
//  16-Feb-1989 SB  add delScriptFiles() to delete temp script files at the
//                  end of the make. Also called on ^c and ^break
//  15-Feb-1989 SB  Rewrote useDefaultMakefile(); MAKEFLAGS can contain all flags
//                  now
//  13-Feb-1989 SB  Rewrote filename() for OS/2 1.2 support, now returns BOOL.
//   3-Feb-1989 SB  Renamed freeUnusedRules() to freeRules(); moved prototype to
//                  proto.h
//   9-Jan-1989 SB  Improved /help;added -?
//   3-Jan-1989 SB  Changes for /help and /nologo
//   5-Dec-1988 SB  Made chkPrecious() CDECL as signal() expects it
//                  main has CDECL too; cleaned prototypes (added void)
//  30-Nov-1988 SB  Added for 'z' option in setFlags() and chkPrecious()
//  10-Nov-1988 SB  Removed '#ifndef IBM' as IBM ver has a separate tree
//  21-Oct-1988 SB  Added fInheritUserEnv to inherit macro definitions
//  22-Sep-1988 RB  Changed a lingering reference of /B to /A.
//  15-Sep-1988 RB  Move some def's out to GLOBALS.
//  17-Aug-1988 RB  Clean up.
//  15-Aug-1988 RB  /B ==> /A for XMAKE compatibility.
//  11-Jul-1988 rj  Removed OSMODE definition.
//                  Removed NMAKE & NMAKEFLAGS (sob!).
//   8-Jul-1988 rj  Added OSMODE definition.
//   7-Jul-1988 rj  #ifndef IBM'ed NMAKE & NMAKEFLAGS
//   6-Jul-1988 rj  Ditched shell, argVector, moved getComSpec to build.c.
//   5-Jul-1988 rj  Fixed (*pfSPAWN) declarations.
//  28-Jun-1988 rj  Added NMAKEFLAGS predefined macro.
//  24-Jun-1988 rj  Added NMAKE predefined macro.
//                  Added doError flag to unlinkTmpFiles call.
//  23-Jun-1988 rj  Fixed okToDelete to delete less often.
//  22-Jun-1988 rj  Make chkPrecious use error messages
//  25-May-1988 rb  Make InitLeadByte() smarter.
//  20-May-1988 rb  Change built-in macro names.
//  18-May-1988 rb  Remove comment about built-in rules and macros.
//  17-May-1988 rb  Load built-in rules in right place.
//  16-May-1988 rb  Conditionalize recursive make feature.
//   8-May-1988 rb  Better initialization of system shell.

#include "precomp.h"
#pragma hdrstop

#include "verstamp.h"

void      readEnvironmentVars(void);
void      readMakeFiles(void);
void      useDefaultMakefile(void);
BOOL      filename(const char*, char**);
void  __cdecl  chkPrecious(int sig);
UCHAR     isPrecious(char*);
      void      removeTrailChars(char *);

void usage (void);

char *makeStr;                         // this make invocation name

UCHAR  okToDelete;                     // do not del unless exec'ing cmd

#ifdef _M_IX86
UCHAR  fRunningUnderChicago;

extern UCHAR FIsChicago(void);
#endif

const char * const builtInTarg[] = {
    ".SUFFIXES",
    ".c.obj",
    ".c.exe",
    ".cpp.obj",
    ".cpp.exe",
    ".cxx.obj",
    ".cxx.exe",
#if defined(_M_IX86) || defined(_M_MRX000)
    ".asm.obj",
    ".asm.exe",
#endif
#if !defined(_M_IX86)
    ".s.obj",
#endif
    ".bas.obj",
    ".cbl.obj",
    ".cbl.exe",
    ".f.obj",
    ".f.exe",
    ".f90.obj",
    ".f90.exe",
    ".for.obj",
    ".for.exe",
    ".pas.obj",
    ".pas.exe",
    ".rc.res",
    NULL
};

const char * const bltInCmd0[] = {
    ":",
    ".exe",
    ".obj",
#if defined(_M_IX86) || defined(_M_MRX000)
    ".asm",
#endif
#if !defined(_M_IX86)
    ".s",
#endif
    ".c",
    ".cpp",
    ".cxx",
    ".bas",
    ".cbl",
    ".f",
    ".f90",
    ".for",
    ".pas",
    ".res",
    ".rc",
    NULL
};

// Single colon (":") specifies ordinary rules
// Double colon ("::") specifies batch rules
const char * const bltInCmd1[]  = {":", "$(CC) $(CFLAGS) /c $<", NULL};
const char * const bltInCmd2[]  = {":", "$(CC) $(CFLAGS) $<", NULL};
const char * const bltInCmd3[]  = {":", "$(CPP) $(CPPFLAGS) /c $<", NULL};
const char * const bltInCmd4[]  = {":", "$(CPP) $(CPPFLAGS) $<", NULL};
const char * const bltInCmd5[]  = {":", "$(CXX) $(CXXFLAGS) /c $<", NULL};
const char * const bltInCmd6[]  = {":", "$(CXX) $(CXXFLAGS) $<", NULL};
#if defined(_M_IX86) || defined(_M_MRX000)
const char * const bltInCmd7[]  = {":", "$(AS) $(AFLAGS) /c $*.asm", NULL};
const char * const bltInCmd8[]  = {":", "$(AS) $(AFLAGS) $*.asm", NULL};
#endif
#if !defined(_M_IX86)
#if defined(_M_MRX000)
const char * const bltInCmd9[]  = {":", "$(AS) $(AFLAGS) /c $*.s", NULL};
#else
const char * const bltInCmd9[]  = {":", "$(AS) $(AFLAGS) $*.s", NULL};
#endif
#endif
const char * const bltInCmd10[] = {":", "$(BC) $(BFLAGS) $*.bas;", NULL};
const char * const bltInCmd11[] = {":", "$(COBOL) $(COBFLAGS) $*.cbl;", NULL};
const char * const bltInCmd12[] = {":", "$(COBOL) $(COBFLAGS) $*.cbl, $*.exe;", NULL};
const char * const bltInCmd13[] = {":", "$(FOR) /c $(FFLAGS) $*.f", NULL};
const char * const bltInCmd14[] = {":", "$(FOR) $(FFLAGS) $*.f", NULL};
const char * const bltInCmd15[] = {":", "$(FOR) /c $(FFLAGS) $*.f90", NULL};
const char * const bltInCmd16[] = {":", "$(FOR) $(FFLAGS) $*.f90", NULL};
const char * const bltInCmd17[] = {":", "$(FOR) /c $(FFLAGS) $*.for", NULL};
const char * const bltInCmd18[] = {":", "$(FOR) $(FFLAGS) $*.for", NULL};
const char * const bltInCmd19[] = {":", "$(PASCAL) /c $(PFLAGS) $*.pas", NULL};
const char * const bltInCmd20[] = {":", "$(PASCAL) $(PFLAGS) $*.pas", NULL};
const char * const bltInCmd21[] = {":", "$(RC) $(RFLAGS) /r $*", NULL};

const char * const * const builtInCom[] = {
    bltInCmd0,
    bltInCmd1,
    bltInCmd2,
    bltInCmd3,
    bltInCmd4,
    bltInCmd5,
    bltInCmd6,
#if defined(_M_IX86) || defined(_M_MRX000)
    bltInCmd7,
    bltInCmd8,
#endif
#if !defined(_M_IX86)
    bltInCmd9,
#endif
    bltInCmd10,
    bltInCmd11,
    bltInCmd12,
    bltInCmd13,
    bltInCmd14,
    bltInCmd15,
    bltInCmd16,
    bltInCmd17,
    bltInCmd18,
    bltInCmd19,
    bltInCmd20,
    bltInCmd21,
    NULL
};

//  main
//
// actions:  saves the initial global variables in a
//           block. calls doMake() and then delTempScriptFiles()

void __cdecl
main(
    unsigned argc,
    char *argv[],
    char *envp[]
    )
{
    int status;                         // returned by doMake

#ifdef _M_IX86
    fRunningUnderChicago = FIsChicago();
#endif

    initCharmap();

    initMacroTable(macroTable);

#ifdef DEBUG_COMMANDLINE
    {
        int iArg = argc;
        char **chchArg = argv;
        for (; iArg--; chchArg++) {
            printf("'%s' ", *chchArg);
        }
        printf("\n");
    }
#endif

    if (!makeStr) {
        // extract file name
        if (!filename(_pgmptr, &makeStr)) {
            makeStr = "NMAKE";
        }
    }

    // set up handler for .PRECIOUS  the handler tries to remove the
    // current target when control-C'd, unless it is "precious"

    signal(SIGINT, chkPrecious);
    signal(SIGTERM, chkPrecious);

    status = doMake(argc, argv, NULL);

    delScriptFiles();

    if (!fSlashKStatus) {
        status = 1;                     // error when slashK specified
    }

#if !defined(NDEBUG)
    printStats();
#endif

    exit(status);
}

extern void endNameList(void);
extern void addItemToList(void);
extern void assignDependents(void);
extern void assignBuildCommands(void);

//  loadBuiltInRules() -- Loads built in Rules to the NMAKE Tables
//
// Modifies:
//  fInheritUserEnv  --    is set to TRUE to inherit CC, AS
//
// Notes:
//  Does this by calls to defineMacro(), which calls putMacro(). Since,
//  fInheritUserEnv is set to TRUE, putMacro() will add to the Environment.

void
loadBuiltInRules(
    void
    )
{
    const char *tempTarg;
    const char * const *tempCom;
    unsigned index;
    char *macroName, *macroValue;
    extern char *makestr;

    // We dynamically allocate CC and AS because they need to be freed in a
    // recursive MAKE

    macroName = makeString("CC");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("CXX");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("CPP");
    macroValue = makeString("cl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("AS");
#if   defined(_M_ALPHA)
    macroValue = makeString("asaxp");
#else
    // UNDONE: What is appropriate for IA64?

    macroValue = makeString("ml");
#endif
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("BC");
    macroValue = makeString("bc");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("COBOL");
    macroValue = makeString("cobol");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("FOR");
    macroValue = makeString("fl32");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("PASCAL");
    macroValue = makeString("pl");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("RC");
    macroValue = makeString("rc");
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("_NMAKE_VER");
    macroValue = makeString(VER_PRODUCTVERSION_STR);
    defineMacro(macroName, macroValue, 0);
    macroName = makeString("MAKE");
    macroValue = makeString(makeStr);
    // From environment so it won't get exported ; user can reset MAKE

    defineMacro(macroName, macroValue, M_ENVIRONMENT_DEF|M_WARN_IF_RESET);

    for (index = 0; tempTarg = builtInTarg[index]; index++) {
        name = makeString(tempTarg);
        tempCom = builtInCom[index];
        // tempCom should now contain a single or double colon
        assert (tempCom && *tempCom && **tempCom == ':');
        _tcscpy(buf, *tempCom);
        endNameList();
        for (tempCom++; *tempCom; tempCom++) {
            _tcscpy(buf, *tempCom);
            addItemToList();
        }
        if (index == 0) {
            assignDependents();
        }
        assignBuildCommands();
    }
}


//  doMake()
//
// actions:  prints a version message
//           reads the environment variable MAKEFLAGS
//           if MAKEFLAGS defined
//           defines MAKEFLAGS to have that value w/in nmake
//           sets a flag for each option if MAKEFLAGS defined
//           else defines the macro MAKEFLAGS to be NULL
//           parses commandline (adding option letters to MAKEFLAGS)
//           reads all environment variables
//           reads tools.ini
//           reads makefile(s) (if -e flag set, new definitions in
//           makefile won't override environment variable defs)
//           prints information if -p flag
//           processes makefile(s)
//           prints information if -d flag and not -p flag (using both
//           is overkill)
//
// In effect, the order for making assignments is (1 = least binding,
//   4 = most binding):
//
//   1)  TOOLS.INI
//   2)  environment (if -e flag, makefile)
//   3)  makefile    (if -e flag, environment)
//   4)  command line
//
// The user can put anything he wants in the MAKEFLAGS environment variable.
// I don't check it for illegal flag values, because there are many xmake
// flags that we don't support.  He shouldn't have to change his MAKEFLAGS
// to use nmake. Xmake always puts 'b' in MAKEFLAGS for "backward com-
// patibility" (or "botch") for the original Murray Hill version of make.
// It doesn't make sense to use -f in MAKEFLAGS, thus it is disallowed.
// It also makes little sense to let the default flags be -r, -p, or -d,
// so they aren't allowed in MAKEFLAGS, either.
//
// Even though DOS only uses uppercase in environment variables, this
// program may be ported to xenix in the future, thus we allow for the
// possibility that MAKEFLAGS and commandline options will be in upper
// and/or lower case.
//
// modifies:   init    global flag set if tools.ini is being parsed...

int
doMake(
    unsigned argc,
    char *argv[],
    char *parentBlkPtr          // state of parent, restored prior to return
    )
{
    int status = 0;
    char *p;
    extern char *makeStr;               // the initial make invok name
    char *makeDir, *curDir;

#ifdef DEBUG_ALL
    printf ("DEBUG: In doMake\n");
#endif

    assert(parentBlkPtr == NULL);

    // Load built-ins here rather than in main().  Otherwise in a recursive
    // make, doMake() will initialize rules to some value which has been
    // freed by sortRules(). [RB]
    // UNDONE:    why is sortRules() not setting rules to NULL?  [RB]

    inlineFileList = (STRINGLIST *)NULL;
    makeDir = makeString("MAKEDIR");
    curDir  = getCurDir();
    // Use M_LITERAL flag to prevent nmake from trying to
    // interpret $ in path as an embedded macro. [DS 14983]
    defineMacro(makeDir, curDir, M_LITERAL);

    // TEMPFIX: We are truncating MAKEFLAGS environment variable to its limit
    // to avoid GP Faults
    if (p = getenv("MAKEFLAGS")) {      // but not MAKEFLAGS
        _tcsncpy(makeflags+10, p, _tcslen(makeflags + 10));
    }

    // fInheritUserEnv is set to TRUE so that the changes made get inherited

    fInheritUserEnv = TRUE;

    // 07-05-92  BryanT    Simply adding global strings to the macro array
    //                     causes problems later when you go to free them
    //                     from a recursive $(MAKE).  Both the macro name
    //                     and the macro's value must be created with
    //                     makeString.

    defineMacro(makeString("MAKEFLAGS"), makeString(makeflags+10), M_NON_RESETTABLE|M_ENVIRONMENT_DEF);

    for (;p && *p; p++) {               // set flags in MAKEFLAGS
        setFlags(*p, TRUE);             // TRUE says turn bits ON
    }

    parseCommandLine(--argc, ++argv);   // skip over program name

#ifdef DEBUG_ALL
    printf ("DEBUG: Command Line parsed\n");
#endif

    if (!bannerDisplayed) {
        displayBanner();                // version number, etc.
    }

    if (OFF(gFlags, F1_IGNORE_EXTERN_RULES)) {  // read tools.ini
#ifdef DEBUG_ALL
        printf ("DEBUG: Read Tools.ini\n");
#endif
        loadBuiltInRules();
#ifdef DEBUG_ALL
        printf ("DEBUG: loadBuiltInRules\n");
#endif
        fName = "tools.ini";

        if (tagOpen("INIT", fName, makeStr)) {
            ++line;
            init = TRUE;                // tools.ini being parsed

#ifdef DEBUG_ALL
            printf ("DEBUG: Start Parse\n");
#endif
            parse();

#ifdef DEBUG_ALL
            printf ("DEBUG: Parsed\n");
#endif
            if (fclose(file) == EOF)
                makeError(0, ERROR_CLOSING_FILE, fName);
        }
    }

#ifdef DEBUG_ALL
    printf ("after tagopen\n");
#endif

    // For XMake Compatibility MAKEFLAGS should always be inherited to the Env
    // Put copy of makeflags so that the environment can be freed on return
    // from a recursive make

    if (PutEnv(makeString(makeflags)) == -1) {
        makeError(0, OUT_OF_ENV_SPACE);
    }

#ifdef DEBUG_ALL
    printf ("after putenv\n");
#endif

    if (!makeFiles) {
        useDefaultMakefile();           // if no -f makefile given
    }

    readEnvironmentVars();
    readMakeFiles();                    // read description files

#ifdef DEBUG_ALL
    printf ("DEBUG: Read makefile\n");
#endif

    currentLine = 0;                    // reset line after done
    sortRules();                        // reading files (for error messages)

    if (ON(gFlags, F1_PRINT_INFORMATION)) {
        showMacros();
        showRules();
        showTargets();
    }

    // free buffer used for conditional processing - not required now
    if (lbufPtr) {
        FREE(lbufPtr);
    }

    status = processTree();

    // We ignore retval from chdir because we cannot do anything if it fails
    // This accomplishes a 'cd $(MAKEDIR)'.
    _chdir(curDir);
    return(status);
}


//  filename -- filename part of a name
//
// Scope:   Local
//
// Purpose:
//  A complete file name is of the form  <drive:><path><filename><.ext>. This
//  function returns the filename part of the name.
//
// Input:   src -- The complete file name
//          dst -- filename part of the complete file name
//
// Output:  Returns TRUE if src has a filename part & FALSE otherwise
//
// Assumes: That the file name could have either '/' or '\' as path separator.
//
// Notes:
//  Allocates memory for filename part. Function was rewritten to support OS/2
//  Ver 1.2 filenames.
//
//  HV: One concern when I rewrite filename() to use _splitpath(): I declared
//  szFilename with size _MAX_FNAME, which could blow up the stack if _MAX_FNAME
//  is too large.

BOOL
filename(
    const char *src,
    char **dst
    )
{
    char szFilename[_MAX_FNAME];        // The filename part

    // Split the full pathname to components
    _splitpath(src, NULL, NULL, szFilename, NULL);

    // Allocate & copy the filename part to the return string
    *dst = makeString(szFilename);

    // Finished
    return (BOOL) _tcslen(*dst);
}


// readMakeFiles()
//
// actions:  walks through the list calling parse on each makefile
//           resets the line number before parsing each file
//           removes name of parsed file from list
//           frees removed element's storage space
//
// modifies: file      global file pointer (FILE*)
//           fName     global pointer to file name (char*)
//           line      global line number used and updated by the lexer
//           init      global flag reset for parsing makefiles
//                      ( files other than tools.ini )
//           makeFiles in main() by modifying contents of local pointer (list)
//
// We keep from fragmenting memory by not allocating and then freeing space
// for the (probably few) names in the files and targets lists.  Instead
// we use the space already allocated for the argv[] vars, and use the space
// we alloc for the commandfile vars.  The commandfile vars that could be
// freed here, but they aren't because we can't tell them from the argv[]
// vars.  They will be freed at the end of the program.

void
readMakeFiles(
    void
    )
{
    STRINGLIST *q;

    for (q = makeFiles; q ; q = q->next) {          // for each name in list
        if ((q->text)[0] == '-' && !(q->text)[1]) {
            fName = makeString("STDIN");
            file = stdin;
        } else {
            fName = makeString(q->text);
            if (!(file = FILEOPEN(fName, "rt")))    // open to read, text mode
                makeError(0, CANT_OPEN_FILE, fName);
            if (!IsValidMakefile(file))
                makeError(0, CANT_SUPPORT_UNICODE, fName);
        }
        line = 0;
        init = FALSE;                   // not parsing tools.ini
        parse();
        if (file != stdin && fclose(file) == EOF)
            makeError(0, ERROR_CLOSING_FILE, fName);
    }

    // free the list of makefiles
    freeStringList(makeFiles);
}


//  readEnvironmentVars - Read in environment variables into Macro table
//
// Scope:   Local.
//
// Purpose:
//  Reads environment variables into the NMAKE macro Table. It walks through envp
//  using environ making entries in NMAKE's hash table of macros for each string
//  in the table.
//
// Assumes: That the env contains strings of the form "VAR=value" i.e. '=' present.
//
// Modifies Globals:    fInheritUserEnv - set to false.
//
// Uses Globals:
//  environ - Null terminated table of pointers to environment variable
//         definitions of the form "name=value" (Std C Runtime variable)
//
// Notes:
//  If the user specifies "set name=value" as a build command for a target being
//  built, the change in the environment will not be reflected in nmake's set of
//  defined variables in the macro table.
//
// Undone/Incomplete:
//  1> Probably do not need envPtr global in NMAKE. (to be removed)
//  2> Probably don't need fInheritUserEnv (see PutMacro)

void
readEnvironmentVars(
    void
    )
{
    char *macro, *value;
    char *t;
    char **envPtr;

    envPtr = environ;
    for (;*envPtr; ++envPtr) {
        if (t = _tcschr(*envPtr, '=')) {   // should always be TRUE
            if (!_tcsnicmp(*envPtr, "MAKEFLAGS", 8))
                continue;
            *t = '\0';
            // Don't add empty names.
            if (**envPtr == '\0')
                continue;
            // ALLOC: here we make copies of the macro name and value to define
            macro = _tcsupr(makeString(*envPtr));

            value = makeString(t+1);
            *t = '=';
            fInheritUserEnv = (BOOL)FALSE;
            if (!defineMacro(macro, value, M_ENVIRONMENT_DEF)) {
                // ALLOC: here we free the copies if they were not added.
                FREE(macro);
                FREE(value);
            }
        }
    }
}


//  parseCommandLine()
//
// arguments:  argc    count of arguments in argv vector
//             argv    table of pointers to commandline arguments
//
// actions:    reads a command file if necessary
//             sets switches
//             defines macros
//             makes a list of makefiles to read
//             makes a list of targets to build
//
// modifies:   makeFiles   in main() by modifying contents of parameter
//                          pointer (list) to STRINGLIST pointer
//                          (makeFiles)
//             makeTargets     in main() by modifying contents of param
//                              pointer (targets) to STRINGLIST pointer
//             fInheritUserEnv set to TRUE so that user defined changes in the
//                              environment variables get inherited by the Env
//
// nmake doesn't make new copies of command line macro values or environment
// variables, but instead uses pointers to the space already allocated.
// This can cause problems if the envp, the environment pointer, is accessed
// elsewhere in the program (because the vector's strings will contain '\0'
// where they used to contain '=').  I don't foresee any need for envp[] to
// be used elsewhere.  Even if we did need to use the environment, we could
// access the environ variable or use getenv().
//
// I don't care what the current DOS "switch" character is -- I always
// let the user give either.

void
parseCommandLine(
    unsigned argc,
    char *argv[]
    )
{
    STRINGLIST *p;
    char *s;
    char *t;
    FILE *out;
    BOOL fUsage = FALSE;

    for (; argc; --argc, ++argv) {
        if (**argv == '@') {           // cmdfile
            readCommandFile((char *) *argv+1);
        } else if (**argv == '-'|| **argv == '/') {   // switch
            s = *argv + 1;
            if (!_tcsicmp(s, "help")) {
                fUsage = TRUE;
                break;
            }

            // if '-' and '/' specified then ignores it
            for (; *s; ++s) {
                if (!_tcsicmp(s, "nologo")) {
                    setFlags(s[2], TRUE);
                    break;
                } else if (*s == '?') {
                    fUsage = TRUE;
                    break;
                } else if (*s == 'f' || *s == 'F') {
                    char *mkfl = s+1;

                    //if '/ffoo' then use 'foo'; else use next argument
                    if (!*mkfl && (!--argc || !*++argv || !*(mkfl = *argv))) {
                        makeError(0, CMDLINE_F_NO_FILENAME);
                    }
                    p = makeNewStrListElement();
                    p->text = makeString(mkfl);
                    appendItem(&makeFiles, p);
                    break;
                } else if (*s == 'x' || *s == 'X') {
                    char *errfl = s+1;

                    //if '/xfoo' then use 'foo'; else use next argument
                    if (!*errfl && (!--argc || !*++argv || !*(errfl = *argv))) {
                        makeError(0, CMDLINE_X_NO_FILENAME);
                    }

                    if (*errfl == '-' && !errfl[1]) {
                        _dup2(_fileno(stdout), _fileno(stderr));
                    } else {
                        if ((out = fopen(errfl, "wt")) == NULL) {
                            makeError(0, CANT_WRITE_FILE, errfl);
                        }
                        _dup2(_fileno(out), _fileno(stderr));
                        fclose(out);
                    }
                    break;
                } else {
                    setFlags(*s, TRUE);
                }
            }
        } else {
            if (s = _tcschr(*argv, '=')) {         // macro
                if (s == *argv) {
                    makeError(0, CMDLINE_NO_MACRONAME);    // User has specified "=value"
                }
                *s = '\0';
                for (t = s++ - 1; WHITESPACE(*t); --t)
                    ;
                *(t+1) = '\0';
                fInheritUserEnv = (BOOL)TRUE;
                defineMacro(makeString(*argv+_tcsspn(*argv, " \t")),
                makeString( s+_tcsspn(s," \t")),
                M_NON_RESETTABLE);
            } else {
                removeTrailChars(*argv);
                if (**argv) {
                    p = makeNewStrListElement();    // target
                    // use quotes around name if it contains spaces [vs98 1935]
                    if (_tcschr(*argv, ' ')) {
                        p->text = makeQuotedString(*argv);
                    }
                    else {
                        p->text = makeString(*argv);    // needs to be on heap [rm]
                    }
                    appendItem(&makeTargets, p);
                }
            }
            *argv = NULL;               // so we won't try to free this space
        }                               //  if processing command file stuff
    }

    if (fUsage) {
        usage();
        exit(0);
    }
}


//  useDefaultMakefile -- tries to use the default makefile
//
// Scope:
//  Local
//
// Purpose:
//  When no makefile has been specified by the user, set up the default makefile
//  to be used.
//
// Input:
// Output:
// Errors/Warnings:
//  CMDLINE_NO_MAKEFILE -- 'makefile' does not exist & no target specified
//
// Assumes:
// Modifies Globals:
//  makeTargets -- if 'makefile' does not exist then the first target is removed
//                   from this list,
//  makeFiles -- if 'makefile' does not exist then the first target is attached
//                   to this list.
//
// Uses Globals:
//  makeTargets -- the list of targets to be made
//
// Notes:
//  Given a commandline not containing a '-f makefile', this is how NMAKE
//  behaves --
//      If ['makefile' exists] then use it as the makefile,
//      if [(the first target exists and has no extension) or
//       (if it exists and has an extension for which no inference rule
//        exists)]
//      then use it as the makefile.

void
useDefaultMakefile(
    void
    )
{
    STRINGLIST *p;
    char *s, *ext;
    char nameBuf[MAXNAME];
    struct _finddata_t finddata;

    if (!_access("makefile", READ)) {
        // if 'makefile' exists then use it
        p = makeNewStrListElement();
        p->text = makeString("makefile");
        makeFiles = p;
    } else if (makeTargets) {
        //check first target
        s = makeTargets->text;
        if (_access(s, READ) ||         // 1st target does not exist
              ((ext = _tcsrchr(s, '.'))
            && findRule(nameBuf, s, ext, &finddata))) {  //has no ext or inf rule
            return;
        }

        p = makeTargets;
        makeTargets = makeTargets->next;    // one less target
        makeFiles = p;                      // 1st target is the makefile
    } else if (OFF(gFlags, F1_PRINT_INFORMATION)) {
        //if -p and no makefile, simply give information ...
        makeError(0, CMDLINE_NO_MAKEFILE);  //  no 'makefile' or target
    }
}


//  setFlags()
//
// arguments:  line    current line number in makefile (or 0
//                      if still parsing commandline)
//             c       letter presumed to be a commandline option
//             value   TRUE if flag should be turned on, FALSE for off
//
// actions:    checks to see if c is a valid option-letter
//             if no, error, halt
//             if value is TRUE, sets corresponding flag bit
//               and adds flag letter to MAKEFLAGS macro def
//             else if flag is resettable, clears corresponding bit
//               and removes letter from MAKEFLAGS macro def
//
// modifies:   flags       external resettable-flags
//             gFlags      external non-resettable flags
//             (MAKEFLAGS  nmake internal macrodefs)
//
// Only the flags w/in the "flags" variable can be turned off.  Once the
// bits in "gFlags" are set, they remain unchanged.  The bits in "flags"
// are modified via the !CMDSWITCHES directive.

void
setFlags(
    char c,
    BOOL value
    )
{
    // Use lexer's line count.  If this gets called w/in mkfil, might be from
    // directive, which never makes it to the parser, so parser's line count
    // might be out of sync.

    char d = c;
    UCHAR arg;
    UCHAR *f;
    char *s;
    extern char *makeStr;
    extern MACRODEF * pMacros;
    extern STRINGLIST * pValues;

    f = &flags;
    switch(c = (char) _totupper(c)) {
        case 'A':
            arg = F2_FORCE_BUILD;
            break;

        case 'B':
            fRebuildOnTie = TRUE;
            return;

        case 'C':
            arg = F1_CRYPTIC_OUTPUT;
            f = &gFlags;
            bannerDisplayed = TRUE;
            break;

        case 'D':
            arg = F2_DISPLAY_FILE_DATES;
            break;

        case 'E':
            arg = F1_USE_ENVIRON_VARS;
            f = &gFlags;
            break;

        case 'I':
            arg = F2_IGNORE_EXIT_CODES;
            break;

        case 'K':
            fOptionK = TRUE;
            return;

        case 'L':
            arg = F1_NO_LOGO;
            f = &gFlags;
            bannerDisplayed = TRUE;
            break;

        case 'N':
            arg = F2_NO_EXECUTE;
            break;

        case 'O':
            fDescRebuildOrder = TRUE;
            return;

        case 'P':
            arg = F1_PRINT_INFORMATION;
            f = &gFlags;
            break;

        case 'Q':
            arg = F1_QUESTION_STATUS;
            f = &gFlags;
            break;

        case 'R':
            arg = F1_IGNORE_EXTERN_RULES;
            f = &gFlags;
            break;

        case 'S':
            arg = F2_NO_ECHO;
            break;

        case 'T':
            arg = F1_TOUCH_TARGETS;
            f = &gFlags;
            break;

        case 'U':
            arg = F2_DUMP_INLINE;
            break;

        case 'Y':
            arg = F1_NO_BATCH;
            f = &gFlags;
            break;

        case ' ':
            return;                     // recursive make problem

        default:
            makeError(0, CMDLINE_BAD_OPTION, d);
    }

    if (!pMacros) {
        pMacros = findMacro("MAKEFLAGS");
        pValues = pMacros->values;
    }

    if (value) {
        SET(*f, arg);                   // set bit in flags variable
        if (c == 'Q') SET(*f, F1_CRYPTIC_OUTPUT);
            if (!_tcschr(pValues->text, c)) {          // don't want to dup any chars
                if (s = _tcschr(pValues->text, ' '))   // append ch to MAKEFLAGS
                    *s = c;
            if (PutEnv(makeString(makeflags)) == -1)    // pValues->text pts into makeflags
                makeError(line, OUT_OF_ENV_SPACE);
        }
    } else if (f == &flags
        ) {
        // make sure pointer is valid (we can't change gFlags, except if /Z
        CLEAR(*f, arg);
        if (s = _tcschr(pValues->text, c)) // adjust MAKEFLAGS
            do {
                *s = *(s+1);                //  move remaining chars over
            } while (*(++s));
        if (PutEnv(makeString(makeflags)) == -1)
            makeError(line, OUT_OF_ENV_SPACE);
    }
}

//  chkPrecious -- handle ^c or ^Break
//
// Actions:    unlink all non-precious files and unrequired scriptFiles
//             quit with error message (makeError unlinks temp. files)

void __cdecl
chkPrecious(
    int sig
    )
{
    // disable ctrl-C during handler
    signal(SIGINT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    if (okToDelete &&
        OFF(flags, F2_NO_EXECUTE) &&
        OFF(gFlags, F1_TOUCH_TARGETS) &&
        dollarAt &&
        _access(dollarAt, 0x00) &&      // existence check
        !isPrecious(dollarAt)
       ) {
        if (_unlink(dollarAt) == 0)
            makeError(line, REMOVED_TARGET, dollarAt);
    }
    makeError(0, USER_INTERRUPT);
    delScriptFiles();
}

UCHAR
isPrecious(
    char *p
    )
{
    STRINGLIST *temp;

    for (temp = dotPreciousList; temp; temp = temp->next)
        if (!_tcsicmp(temp->text, p))
            return(1);
    return(0);
}

//  delScriptFiles -- deletes script files
//
// Scope:   Global
//
// Purpose:
//  Since script files may be reused in the makefile the script files which have
//  NOKEEP action specified are deleted at the end of the make.
//
// Uses Globals:    delList -- the list of script files to be deleted
//
// Notes:
//  We ignore the exit code as a result of a delete because the system will
//  inform the user that a delete failed.

void
delScriptFiles(
    void
    )
{
    STRINGLIST *del;

    _fcloseall();

    for (del = delList; del;del = del->next) {
        _unlink(del->text);
        // UNDONE: Investigate whether next is really needed
        if (ON(flags, F2_NO_EXECUTE)) {
            printf("\tdel %s\n", del->text);
            fflush(stdout);
        }
    }
}


//  removeTrailChars - removes trailing blanks and dots
//
// Scope:   Local.
//
// Purpose:
//  OS/2 1.2 filenames dictate removal of trailing blanks and periods. This
//  function removes them from filenames provided to it.
//
// Input:   szFile - name of file
//
// Notes:
//  This function handles Quoted filenames as well. It maintains the quotes if
//  they were present. This is basically for OS/2 1.2 filename support.

void
removeTrailChars(
    char *szFile
    )
{
    char *t = szFile + _tcslen(szFile) - 1;
    BOOL fQuoted = FALSE;

    if (*szFile == '"' && *t == '"') {
        // Quoted so set flag
        t--;
        fQuoted = TRUE;
    }

    // Scan backwards for trailing characters
    while (t > szFile && (*t == ' ' || *t == '.'))
        t--;

    // t points to last non-trailing character.  It it was quited, add quotes
    // to the end
    if (fQuoted)
        *++t = '"';

    t[1] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\inline.cpp ===
//  INLINE.C - contains routines used to handle processing of in-line files
//
//    Copyright (c) 1989-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the in-line file handling routines of NMAKE.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  01-Jun-1993 HV Use UngetTxtChr() instead of ungetc()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  02-Feb-1990 SB change fopen() to FILEOPEN()
//  03-Jan-1990 SB removed unitiallized variable
//  04-Dec-1989 SB Removed to unreferenced variables in makeInlineFiles()
//  01-Dec-1989 SB Changed realloc() to REALLOC()
//  22-Nov-1989 SB Changed free() to FREE()
//  07-Nov-1989 SB Length of action word not evaluated correct for multiple
//          inline files for the same command
//  06-Nov-1989 SB allow macros in action word for inline files
//  24-Sep-1989 SB added processInline(), createInline()
//  20-Sep-1989 SB Created from routines previously scattered in the sources.
//
// Notes:
//  Sections with 'NOTE:' inside comments marks important/incomplete items.

// NOTE: Function headers yet to be completed; other comments are incomplete

#include "precomp.h"
#pragma hdrstop

void        processEschIn(char *);
// NOTE: This may go soon (use nextInlineFile ?)
void        parseInlineFileList(char *);
// NOTE: The next one has to go soon
void        appendScript(SCRIPTLIST**,SCRIPTLIST*);
void        delInlineSymbol(char*);
char      * nextInlineFile(char **);

// NOTE: Probably needs a new name
void        replaceLtLt(char **, char *);
void        createInline(FILE *, const char *, char **, BOOL);
char *      getLine(char *, int);
void        echoLine(char *, const char *, BOOL);


// NOTE: delScriptFiles() from nmake.c not yet brought in here
extern FILE      * createDosTmp(char *);

      char      * makeInlineFiles(char *, char **, char **);
      BOOL        processInline(char *, char **, STRINGLIST **, BOOL);

//  makeInlineFiles - creates memory images for in-line files
//
// Scope:   Global.
//
// Purpose: This is the function that handles dynamic in-line files
//
// Input:   s - Input command line string after first << (pts to char Buffer)
//
// Output:  Returns ...
//
// Errors/Warnings:
//  SYNTAX_UNEXPECTED_TOKEN - The makefile cannot end without the in-line file
//                            ending.
//  CANT_READ_FILE          - When the makefile is unreadable.
//  SYNTAX_KEEP_INLINE_FILE - An inline file should end
//  OUT_OF_MEMORY           - On failing to extend in-memory in-line file.
//
// Uses Globals:
//  file - global stream
//  line - lexer's line count
//
// Notes:
//  Usage notes and other important notes

char *
makeInlineFiles(
    char *s,
    char **begin,
    char **end
    )
{
    char rgchBuf[MAXBUF];
    char *t;
    unsigned size;
    BOOL fPastCmd = FALSE;              // If seen line past Cmd line
    // used when rgchBuf is insuff for in-memory-inline file
    char *szTmpBuf = NULL;

    _tcscpy(rgchBuf, "<<");            // to help parseInlineFileList
    if (!getLine(rgchBuf+2,MAXBUF - 2)) {
        if (feof(file))
            makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
        makeError(line, CANT_READ_FILE);
    }

    parseInlineFileList(rgchBuf);
    for (;scriptFileList;scriptFileList = scriptFileList->next) {
        for (;;) {
            for (t = rgchBuf;;) {
                *s++ = *t++;
                if (s == *end) {
                    if (!szTmpBuf) {              /* Increase size of s */
                        szTmpBuf = (char *) allocate(MAXBUF<<1);
                        _tcsncpy(szTmpBuf, *begin, MAXBUF);
                        s = szTmpBuf + MAXBUF;
                        size = MAXBUF << 1;
                        *end = szTmpBuf + size;
                    } else {
                        if ((size + MAXBUF < size)    /* overflow error */
                            || !(szTmpBuf = (char *) REALLOC(szTmpBuf,size+MAXBUF)))
                            makeError(line, MACRO_TOO_LONG);
                        s = szTmpBuf + size;
                        size += MAXBUF;
                        *end = szTmpBuf + size;
                    }
                    *begin = szTmpBuf;
                }
                if (!*t)
                    break;
            }
            if (fPastCmd && rgchBuf[0] == '<' && rgchBuf[1] == '<') {
                //We don't care about action specified here; could be a macro
                if (scriptFileList->next) {
                    if (!getLine(rgchBuf, MAXBUF)) {
                        if (feof(file))
                            makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
                        makeError(line, CANT_READ_FILE);
                    }
                }
                break;
            }
            fPastCmd = TRUE;
            if (!getLine(rgchBuf,MAXBUF)) {
                if (feof(file))
                    makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
                makeError(line,CANT_READ_FILE);
            }
        }
    }
    *s = '\0';
    return(s);
}

//  processEschIn - Handles Esch characters in Script File lines
//
// Scope:   Global.
//
// Purpose:
//  Inline file lines are handled for escape characters. If a line contains an
//  escaped newline then append the next line to it.
//
// Input:   buf - the command line to be processed for ESCH characters
//
// Errors/Warnings:
//  SYNTAX_UNEXPECTED_TOKEN - The makefile cannot end without the in-line file
//                 ending.
//  CANT_READ_FILE - When the makefile is unreadable.
//
// Assumes:
//  If the newline is escaped the newline is last char in 'pGlobalbuf'. Safe
//  to do so because we got 'pGlobalBuf' via fgets(). ????
//
// Modifies Globals:
//  line - if newline was Escaped update line
//  file - the makefile being processed
//  buf    - gets next line appended if newline was Escaped (indirectly)
//
// Uses Globals:
//  buf - Indirectly

void
processEschIn(
    char *pGlobalBuf
    )
{
    char *p, *q;

    p = pGlobalBuf;
    while (p = _tcschr(p, '\n')) {
        if (p > pGlobalBuf) {
            char * pprev = _tcsdec(pGlobalBuf, p);
            if (*pprev != ESCH) {
                break;
            }
        }

        p++;

        if (!(q = fgets(p, (int)(size_t) (MAXBUF - (p - pGlobalBuf)), file))) {
            if (feof(file)) {
                makeError(line, SYNTAX_UNEXPECTED_TOKEN, "EOF");
            }

            makeError(line, CANT_READ_FILE);
        }

        line++;
    }
}


//  parseInlineFileList - Parses file list and makes list of Inline files
//
// Scope:   Global.
//
// Purpose:
//  To handle multiple inline files, the names of the files are to be stored
//  in a list. This function creates the list by parsing the command file
//
// Input:   buf - the line to be parsed
//
// Modifies Globals:
//  scriptFileList -- the list of script files.

void
parseInlineFileList(
    char *buf
    )
{
    char *token;

    processEschIn(buf);

    token = nextInlineFile(&buf);       //next inline file

    while (token != NULL) {
        SCRIPTLIST *newScript;

        newScript = makeNewScriptListElement();
        newScript->sFile = makeString(token);
        appendScript(&scriptFileList, newScript);

        token = nextInlineFile(&buf);   // next inline file
    }
}

//  appendScript  --  appends an element to the tail of a scriptlist
//
// Purpose:
//  Traverse to the end of the list and append element there.
//
// Input:
//  list     --    the list to append to
//  element  --    the element inserted
//
// Modifies:
//  the global list

void
appendScript(
    SCRIPTLIST **list,
    SCRIPTLIST *element
    )
{
    for (; *list; list = &(*list)->next)
        ;

    *list = element;
}

char tok[MAXNAME];

// Space not included in the following macro as it is now a valid
// character for filenames [DS 14966]
#define NAME_CHAR(c) (c) != '>' && (c) != '<' && \
             (c) != '^' && (c) != ',' && (c) != '\t' && \
             (c) != '\n'

//  nextInlineFile - gets next Inline file name from command line
//
// Scope:   Local.
//
// Purpose:
//  The command line syntax is complex. This function returns the next Inline
//  file in the command line part passed to it. As a side effect it changes the
//  pointer to just after this inline file name.
//
// Input:   str - address of the part of command line under consideration.
//
// Output:  Returns the next inline filename.
//
// Modifies Globals:
//  Global - How and why modified
//
// Uses Globals:
//  tok - the address of this static array is returned.

char *
nextInlineFile(
    char **str
    )
{
    char *t = tok, *pStr = *str;
    BOOL fFound = FALSE;                // '<<' not found
    BOOL fQuoted = FALSE;               // found '\"'

    while (!fFound) {
        if (!(pStr = _tcschr(pStr, '<'))) {
            return(NULL);
        }

        if (*++pStr == '<') {
            fFound = TRUE;
        }
    }

    // Since '<<' has been found we definitely have another Inline File
    pStr++;
    while (*pStr && NAME_CHAR(*pStr)) {
        if (*pStr == '\"') {
            fQuoted = !fQuoted;
        }

        if (*pStr == ' ' && !fQuoted) {
            break;
        }

        if (*pStr == '$' && pStr[1] == '(') {
            *t = '$';
            *++t = '(';

            while (*++pStr != '\n' && *pStr != ')') {
                *t++ = *pStr;
            }

            if (*pStr == '\n') {
                break;
            }
        } else {
            *t = *pStr;
            ++t; ++pStr;
        }
    }

    *t = '\0';
    *str = pStr;
    return(tok);
}

//  processInline - Brief description of the function
//
// Output:  Returns ... TRUE if cmdline returned is expanded

BOOL
processInline(
    char *szCmd,
    char **szCmdLine,
    STRINGLIST **pMacroList,
    BOOL fDump
    )
{
    char *szInline, *szUnexpInline;     // Inline name, unexpanded
    char *pCmdLine;                     // The executable line
    FILE *infile;                       // The inline file
    char *begInBlock, *inBlock, *pInBlock;  // inline block
    char szTmp[MAXNAME + 2];                // add 2 to allow space for quotes
    STRINGLIST *newString;
    int iKeywordLen;

    if (begInBlock = _tcschr(szCmd, '\n')) {
        *begInBlock = '\0';
        *szCmdLine = expandMacros(szCmd, pMacroList);
        *begInBlock = '\n';
        begInBlock++;
        // if not expanded, allocate a copy
        if (*szCmdLine == szCmd)
            *szCmdLine = makeString(szCmd);
    } else {
        *szCmdLine = makeString(szCmd);
        return(FALSE);
    }

    pCmdLine = *szCmdLine;
    //expand macros in the inline file ...
    pInBlock = inBlock = expandMacros(begInBlock, pMacroList);

    while (szUnexpInline = nextInlineFile(&pCmdLine)) {
        BOOL fKeep = FALSE;             // default is NOKEEP
        char *newline;

        // CAVIAR 3410 -- the inline filename has already been expaned
        // by the time we get here... we just need to dup the name
        // so that it is preserved long enough to delete it later... [rm]
        //
        // szInline = removeMacros(szUnexpInline);

        szInline = makeString(szUnexpInline);

        if (!*szInline) {
            char *nmTmp;

            if ((nmTmp = getenv("TMP")) != NULL && *nmTmp) {
                assert(_tcslen(nmTmp) <= MAXNAME);
                _tcsncpy(szTmp, nmTmp, MAXNAME);
            } else
                szTmp[0] = '\0';

            if (!(infile = createDosTmp(szTmp)))
                makeError(line, CANT_MAKE_INLINE, szTmp);

            if (_tcschr(szTmp, ' ') && !_tcschr(szTmp, '"')) {
                // if the filename (str) contains spaces
                // and is unquoted, quote it, so that we can
                // feed it properly to the command interpreter! [VS98 1931]
                size_t size = _tcslen(szTmp);
                memmove(szTmp+1, szTmp, size);
                *szTmp = '"';
                *(szTmp + size + 1) = '"';
                *(szTmp + size + 2) = '\0';
            }

            replaceLtLt(szCmdLine, szTmp);

            FREE(szInline);
            szInline = makeString(szTmp);
        } else if (!(infile = FILEOPEN(szInline, "w")))
            makeError(line, CANT_MAKE_INLINE, szInline);
        else
            delInlineSymbol(*szCmdLine);
        pCmdLine = *szCmdLine;          // Because szCmdLine changed

        createInline(infile, szInline, &pInBlock, fDump);

        // Add handling of KEEP and NOKEEP here
        // iKeywordLen is length of word after << on that line
        newline = _tcschr(pInBlock , '\n');
        iKeywordLen = newline ? ((int) (newline - pInBlock)) : _tcslen(pInBlock);

        if (iKeywordLen > 3 && !_tcsnicmp(pInBlock, "keep", 4)) {
            pInBlock +=4;
            fKeep = (BOOL)TRUE;
        } else if (iKeywordLen > 5 && !_tcsnicmp(pInBlock, "nokeep", 6))
            pInBlock += 6;
        else if (iKeywordLen)
            makeError(line, SYNTAX_KEEP_INLINE_FILE);

        if (*pInBlock == '\n')
            pInBlock++;
        fclose(infile);
        // Add the file to list to be deleted; except for "KEEP"
        if (!fKeep) {
            newString = makeNewStrListElement();
            newString->text = makeString(szInline);
            appendItem(&delList, newString);
        }
        FREE(szInline);
    }

    if (inBlock != begInBlock)
        FREE(inBlock);
    return(TRUE);
}


void
replaceLtLt(
    char **source,
    char *str
    )
{
    char *szBuf;
    char *p, *q;

    // Don't subtract two for the << and forget to add 1 for the null termination.

    szBuf = (char *) _alloca(_tcslen(*source) - 1 + _tcslen(str));
    for (p = *source, q = szBuf;;++p,++q)
    if (*p != '<')
        *q = *p;
    else if (*(p+1) != '<') {
        *q = '<';
    } else {
        *q = '\0';
        _tcscat(_tcscat(szBuf, str), p+2);
        *source = (char *) REALLOC(*source, _tcslen(szBuf) + 1);
        if (*source == NULL) {
            makeError(0, OUT_OF_MEMORY);
        }
        _tcscpy(*source, szBuf);
        break;
    }
}

void
createInline(
    FILE *file,
    const char *szFName,
    char **szString,
    BOOL fDump
    )
{
    char *t, *u;
    BOOL fFirstLine = TRUE;

    while (t = _tcschr(*szString, '\n'))
    if (!_tcsncmp(*szString, "<<", 2)) {
        *szString += 2;
        break;
    } else {
        // [msdev96 #3036]
        // "nmake /n" should somehow show the contents of
        // response files (esp. temp ones that are deleted
        // right after use). In order to preserve the batch
        // file format of the output (at least in common
        // cases), we use a syntax like
        // "echo. command >> resp_file" (the dot after
        // the "echo" command is useful for echo'ing
        // empty strings.)
        //
        // A new switch has been added for this
        // purpose ("nmake /u" dumps inline files)
        if (fDump) {
            *t = '\0';
            echoLine(*szString, szFName, !fFirstLine);
            *t = '\n';
        }
        for (u = *szString; u <= t; u++)
        fputc(*u, file);
        *szString = u;
        fFirstLine = FALSE;
    }

    if (!t && !_tcsncmp(*szString, "<<", 2))
        *szString += 2;
}


// echoLine
//
// Usage:   echoLine (szLine, szFName, fAppend)
//
// Description:
//      prints an "echo szLine >> szFName"-like command
//      uses ">>" if fAppend is TRUE, ">" otherwise

void
echoLine(char *szLine, const char *szFName, BOOL fAppend)
{
    // use a 1024-byte buffer to split long lines, so that "echo"
    // commands can be handled by the command interpreter
    static char buf[1024];
    BOOL fBlankLine = TRUE;
    char *pch;
    char *szCur = szLine;
    size_t cbBuf;

    for (pch = szLine; *pch; pch = _tcsinc (pch)) {
        if (!_istspace((unsigned char)*pch)) {
            fBlankLine = FALSE;
            break;
        }
    }

    if (fBlankLine) {
        printf("\techo. %s %s\n",
            fAppend ? ">>" : ">",
            szFName);
        return;
    }

    // calculate available buffer length for szLine
    // assuming space for "\techo. ", " >> " and szFName
    cbBuf = sizeof(buf) - 11 - _tcslen( szFName ) - 1;

    while (*szCur) {
        size_t iLast;
        _tcsncpy (buf, szCur, cbBuf);
        iLast = _tcslen (buf);
        if (cbBuf < _tcslen (szCur)) {
            // find index of character next to the
            // last occurence of white space in buffer
            for (pch = buf; *pch; pch = _tcsinc(pch)) {
                if (_istspace((unsigned char)*pch)) {
                    iLast = (size_t) (pch - buf + 1);
                }
            }
        }

        buf[iLast] = 0;
        printf("\techo %s %s %s\n",
            buf,
            fAppend ? ">>" : ">",
            szFName);

        szCur += iLast;
        fAppend = TRUE;
    }
}


void
delInlineSymbol(
    char *s
    )
{
    char *p = _tcschr(s, '<');
    while (p[1] != '<')
    p = _tcschr(p+1, '<');
    // "<<" found
    _tcscpy(p, p+2);
}



//  getLine - get next line processing NMAKE conditionals enroute
//
// Scope:   Local
//
// Purpose:
//  This function handles directives in inline files. This function gets the
//  next line of input ... managing conditionals on the way.
//
// Input:
//  pchLine - pointer to buffer where line is copied
//  n - size of buffer
//
// Output:
//  Returns ... NULL, on EOF
//       ... non-zero on success
//
// Uses Globals:
//  line    - lexer's line count
//  colZero - if starting from colZero, needed by lgetc()
//
// Notes:
//  Similar to fgets() without stream
//
// Implementation Notes:
//  lgetc() handles directives while getting the next character. It handles
//  directives when the global colZero is TRUE.

char *
getLine(
    char *pchLine,
    int n
    )
{
    char *end = pchLine + n;
    int c;

    while (c = lgetc()) {
        switch (c) {
            case EOF:
                *pchLine = '\0';
                return(NULL);

            default:
                *pchLine++ = (char)c;
                break;
        }

        if (pchLine == end) {
            pchLine[-1] = '\0';
            UngetTxtChr(c, file);
            return(pchLine);
        } else if (c == '\n') {
            colZero = TRUE;
            ++line;
            *pchLine = '\0';
            return(pchLine);
        } else
            colZero = FALSE;    // the last character was not a '\n' and
                                // we are not at the beginning of the file
    }
    return(pchLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\nmtime.h ===
//  nmtime.h - defines DOS packed date and time types
//
//  Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//    This file defines the DOS packed date and time types.
//
// Revision History:
//  19-May-1993 HV  Changed _dtoxtime() to _dostotime_t() so that we can
//                  use the standard llibce.lib instead of the private
//                  llibcer.lib.
//  04-Dec-1989 SB  added proper fn proto for _dtoxtime() (c6 -W3 reqmemt)
//  05-Dec-1988 SB  added CDECL for _dtoxtime()
//  ??-???-???? ??  Taken from dostypes.h


#define MASK4   0xf     // 4 bit mask
#define MASK5   0x1f    // 5 bit mask
#define MASK6   0x3f    // 6 bit mask
#define MASK7   0x7f    // 7 bit mask

#define DAYLOC      0   // day value starts in bit 0
#define MONTHLOC    5   // month value starts in bit 5
#define YEARLOC     9   // year value starts in bit 9

#define SECLOC      0   // seconds value starts in bit 0
#define MINLOC      5   // minutes value starts in bit 5
#define HOURLOC     11  // hours value starts in bit 11

#define DOS_DAY(dword)      (((dword) >> DAYLOC) & MASK5)
#define DOS_MONTH(dword)    (((dword) >> MONTHLOC) & MASK4)
#define DOS_YEAR(dword)     (((dword) >> YEARLOC) & MASK7)

#define DOS_HOUR(tword) (((tword) >> HOURLOC) & MASK5)
#define DOS_MIN(tword)  (((tword) >> MINLOC) & MASK6)
#define DOS_SEC(tword)  (((tword) >> SECLOC) & MASK5)

extern time_t CDECL _dostotime_t(int, int, int, int, int, int);

#define XTIME(d,t)  _dostotime_t(DOS_YEAR(d),                      \
            DOS_MONTH(d),                          \
            DOS_DAY(d),                        \
            DOS_HOUR(t),                           \
            DOS_MIN(t),                        \
            DOS_SEC(t)*2)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\parser.cpp ===
//  PARSER.C -- parsing routines
//
//  Copyright (c) 1988-1989, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains the NMAKE grammar parser. It parses input and uses the
//  getToken() routine to get the next token.
//
// Revision History:
//   05-Apr-1989 SB made all funcs NEAR; Reqd to make all function calls NEAR
//   17-Aug-1988 RB Clean up.

#include "precomp.h"
#pragma hdrstop

#include "table.h"

// macros that deal w/ the productions stack and the actions function table

#define topStack()  (stack[top])
#define popStack()  (stack[top--])
#define pushStack(A)    (stack[++top] = A)
#define doAction(A) (*(actions[A & LOW_NIBBLE]))()



//  parse()     table-driven parser for makefile grammar
//
// arguments:       init    global boolean value -- TRUE if tools.ini is the
//              file being parsed
//
// actions:     initializes the stack (by pushing the empty-stack symbol
//      and the start symbol)
//      keeps track of current line (because the lexer may have
//      read '\n' as a delimiter, and will thus be one line
//      ahead of the parser)
//      while the stack is not empty
//      if the top symbol on the stack is an action
//          do the action, popping the stack
//      if the symbol on top of the stack now is a token
//          if it's not the token we're expecting
//          syntax error, halt
//          else
//          pop token off the stack
//          if the top symbol on the stack is an action
//              do the action, popping the stack
//          reset curent line to lexer's current line
//          get another token (use the lookahead token
//              if it exists, and if it had caused the
//              lexer's line count to be incremented,
//              decrement our local count because we're
//              still parsing the preceding line)
//      else the symbol on top of the stack is a production
//          find next production to do in production table
//          (based on current input token and current
//          production on stack)
//          if the table entry is an error condition
//          print appropriate error message, halt
//          pop current production off stack
//          if the "next production" can be one of two
//          things, decide which one to use by peeking
//          at the next input token and looking in the
//          "useAlternate" decision table (using the last
//          production and next input token as indexes)
//          if the appropriate table entry is YES,
//              use the next larger production from the one
//              we found in the production table
//          push each symbol in the production on the stack
//      loop
//
// modifies:        stack   production stack, static to this module
//      top     index of current symbol at top of stack
//
// Use extreme care in modifying this code or any of the tables associated
// with it.  The methods used to build the tables are described in detail
// in grammar.h and table.h.  This parser is based on the predictive parser
// described on pages 186-191 of Aho & Ullman "Principles of Compiler Design."
// I have modified it to use an extra symbol of lookahead to deal w/ an
// ambiguous grammar and have added code to perform appropriate actions as
// it parses the productions.

void
parse()
{
    UCHAR stackTop, token, nextToken = 0;
    register unsigned n, i;

    firstToken = TRUE;                      // global var
    pushStack(ACCEPT);                      // init stack
    pushStack(START);
    currentLine = line;
    token = getToken(MAXBUF,START);         // get first token
    while ((stackTop = topStack()) != ACCEPT) {
        if (ON(stackTop,ACTION_MASK)) {
            doAction(popStack());
        } else if (ON(stackTop,TOKEN_MASK)) {
            if (stackTop != token) {
                makeError(currentLine,SYNTAX+FATAL_ERR,buf);
            } else {
                popStack();
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 1: %d\n", line);
#endif
                if (ON(topStack(),ACTION_MASK)) {
                    doAction(popStack());
                }
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 2: %d\n", line);
#endif
                currentLine = line;
                if (nextToken) {                        // if we already
                    if (*buf == '\n') --currentLine;    //  have a token,
                    token = nextToken;                  //  use it . . .
                    nextToken = 0;
                } else {
                    token = getToken(MAXBUF,topStack());
                    currentLine = line;
                }
            }
        } else {
            n = table[stackTop][token & LOW_NIBBLE];
#ifdef DEBUG_ALL
            printf ("DEBUG: parse 3: %x %d %x %x\n", n, stackTop, token & LOW_NIBBLE, token);
#endif
            if (ON(n,ERROR_MASK)) {
#ifdef DEBUG_ALL
                printf ("DEBUG: parse 4: %d %s\n", line, buf);
#endif
                makeError(currentLine,n+FATAL_ERR,buf);
            }
            popStack();
            if (ON(n,AMBIG_MASK)) {             // 2 possible prod
                n &= LOW_NIBBLE;                // only use 4 bits
                if (!nextToken) {               // peek to decide
                    nextToken = getToken(MAXBUF,stackTop);
                }
                n += (useAlternate[stackTop][nextToken & LOW_NIBBLE]);
            }
            for (i = productions[n][0]; i; --i) {   // put production
                pushStack(productions[n][i]);       //  on stack
            }
        }                           // 1st elt in prod
    }                               //  is its length
    popStack();    // pop the ACCEPT off the stack
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\nmake.h ===
//  NMAKE.H -- main header file
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This file is the main header file for NMAKE and contains global typedef and
//  macros. Global constants are also defined here. Global data is in global.h
//
// Revision History:
//  01-Feb-1994 HV  Move messages to external file.
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  23-Jun-1993 HV  Kill the near keyword
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  10-May-1993 HV  Add _MBCS version of the string library.
//  10-Jul-1992 SB  Port to NTMIPS
//  08-Jun-1992 SS  Port to DOSX32
//  02-Feb-1990 SB  add definition of FILEOPEN
//  04-Dec-1989 SB  Changed definition of PFV to have prototype of function
//                  which it dereferences
//  01-Dec-1989 SB  Contains an hack #ifdef'ed for Overlayed version
//                  also defined REALLOC
//  22-Nov-1989 SB  #define FREE
//  13-Nov-1989 SB  Definitions CCHMAXPATH(COMP) conform with bsedos.h
//  02-Oct-1989 SB  added support for dynamic inline files
//  14-Sep-1989 SB  added inLines field to block
//  04-Sep-1989 SB  Added M_COMMAND_LINE but not used
//  24-Aug-1989 SB  Add A_DEPENDENT for NMAKE to know that it is to look for a
//                  dependent
//  16-May-1989 SB  NOLOGO flag /L set up for passing to recursive builds
//  24-Apr-1989 SB  added CCHMAXPATH & CCHMAXPATHCOMP for OS/2 ver 1.2 support
//                  & removed FILEINFO typedef's (not needed anymore)
//  22-Feb-1989 SB  changed value of MAXCMDLINELENGTH to 2k
//  03-Feb-1989 SB  Added struct for FILEINFO for OS2 ver 1.2
//  02-Feb-1989 SB  Redefined SPAWNV(P) and SYSTEM as NMAKE was really not
//                  supporting KANJI
//  31-Jan-1989 SB  Changed MAXNAME to 257 for OS2 Ver 1.2 support
//  21-Dec-1988 SB  Added SCRIPTLIST and makeNewScriptListElement() to allow
//                  multiple script fileseach with its KEEP/NOKEEP action
//  06-Dec-1988 SB  Updated Comment about bits corr to flags set
//  05-Dec-1988 SB  Added #define CDECL; NMAKE now uses Pascal Calling
//                  Add SIG_IGN to handle compiler problem
//  30-Nov-1988 SB  Added suppport for 'z' option in setFlags()
//  23-Nov-1988 SB  Defined MAXCMDLINELENGTH for extmake syntax
//  10-Nov-1988 SB  Changed BOOL as 'unsigned short' as in 'os2.h'
//  17-Aug-1988 RB  Clean up.
//  14-Jul-1988 rj  Added dateTime to BUILDBLOCK def to support multiple
//                  targets with the same command block.
//  07-Jul-1988 rj  Added targetFlag parameter to findMacro, findTarget
//  15-Jun-1988 rj  Add definition of EScapeCHaracter.
//  25-May-1988 rb  Clean up definition of LOCAL.
//                  Better char-type defs for ECS.

// Include from the LANGAPI (shared components) project

#include <assert.h>
#include <direct.h>
#include <dos.h>
#include <errno.h>
#include <io.h>
#include <limits.h>
#include <malloc.h>
#include <mbctype.h>
#include <process.h>
#include <share.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "getmsg.h"

#define STRICT

#define NOMINMAX               // windef.h
#define NOGDI                  // wingdi.h
#define NOIME                  // ime.h
#define NOUSER                 // winuser.h
#define NOHELP
#define NOPROFILER
#define NOSYSPARAMSINFO
#define NONLS                  // winnls.h
#define NOSERVICE              // winsvc.h
#include <windows.h>

#define FILEOPEN open_file

#define FREE_STRINGLIST free_stringlist
#define ALLOC_STRINGLIST(type) (STRINGLIST *)alloc_stringlist()

#define FREE free
#define REALLOC realloc

typedef char CHAR;
typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

#define NMHANDLE INT_PTR

typedef void (*PFV) (void);            // pointer to void function

//  size constants for buffers
//
//  I impose an arbitrary limit of 128 bytes for a macro or target name.
//  This should be much larger than any intelligent user would need.
//  The value of a macro can be longer -- up to MAXBUF in length.
//
//  The hash table for macros was only 64 pointers long. That seemed a
//  reasonable number, since most makefiles have fewer than 64 variables
//  defined. Measurements on real makefiles (P1) showed that we had almost
//  8 elements per chain, so it was increased to 256 on FLAT architectures.
//  The hashing algorithm isn't perfect, but it should be good
//  enough.  Even if the macro we're looking up is in a bucket w/ more
//  than one entry, we'll only have to chain one or two links down the
//  list to find it.  When we add macros a bucket's list we prepend them,
//  so we don't have to chain at all there.

#define MAXNAME     257
#define MAXMACRO    256
#define MAXTARGET   128
#define MAXBUF      1024
#define MAXSEGMENT  65535
#define MAXARG      MAXNAME / 2 - 1
#define CHUNKSIZE   8

#define MAXCMDLINELENGTH  8192

//  constants used by error.c
//
//  error numbers are of the form Unxxx, where the 'U' stands for utility,
//  n is the 1st digit of one of the values below indicating the type of
//  error, and xxx is the number of the error (error messages aren't in any
//  order right now -- related ones should probably be grouped together
//  when all error messages have been added)

#define FATAL_ERR   1000
#define NONFATAL_ERR    2000
#define WARNING_ERR 4000

//  other constants

#define WRITE   2               // READ,WRITE,APPEND used by
#define APPEND  3               //  redirect() in build.c
#define READ    4               // also value for access()
#define ESCH    '^'             // general escape character

typedef struct INCLUDEINFO
{
    unsigned line;
    char *name;
    FILE *file;
} INCLUDEINFO;

#define MAXINCLUDE  16

//  STRINGLIST structure is used to construct lists that keep track of the
//      makefiles to read, the targets to update, the dependency list for each
//  target, the list of build commands for each target, and the values
//  for a macro.

typedef struct strlist {
    struct strlist *next;
    char *text;
} STRINGLIST;

typedef struct inlinelist {
    struct inlinelist *next;
    char *text;
    char *name;
    BOOL fKeep;
    unsigned size;
} INLINELIST;

typedef struct scrptlist {          // List used to handle multiple
    struct scrptlist *next;         //      scriptfiles
    char *sFile;                    // -- Script file name & its
    BOOL fKeep;                     // -- keep status (default nokeep)
} SCRIPTLIST;

typedef struct BLOCK {
    STRINGLIST *dependents;         // dependents of the target
    STRINGLIST *dependentMacros;    //
    STRINGLIST *buildCommands;      // command list to build target
    STRINGLIST *buildMacros;
    UCHAR flags;
    time_t dateTime;
} BUILDBLOCK;

typedef struct bldlist {
    struct bldlist *next;
    BUILDBLOCK *buildBlock;
} BUILDLIST;

typedef struct BATCH {				// State info for deferred batch commands
	struct BATCH *next;		
	struct RULE *pRule;				// batch inference rule
	UCHAR flags;					// build flags
	STRINGLIST *nameList;			// list of names to be "touched" (nmake -t)
	STRINGLIST *dollarLt;			// list for constructing batch $< 
} BATCHLIST;

typedef struct OBJECT {
    struct OBJECT *next;
    char *name;
    UCHAR flags2;
    UCHAR flags3;
    time_t dateTime;
    BUILDLIST *buildList;
	BATCHLIST **ppBatch;			// batch list that contains this object,
									// if being built in batch-mode
} MAKEOBJECT;

typedef struct iobject {            // used for dependents NOT in
    struct object *next;            //  the makefile.  We add them
    char *name;                     //  to the target table w/ a
    UCHAR flags2;                   //  flag that says "already
    UCHAR flags3;                   //  built" and then we never
    long datetime;                  //  have to time-stamp again
} IMPLIEDOBJECT;

typedef struct RULE {
    struct RULE *next;
    struct RULE *back;              // doubly-link rules for ease
    char *name;                     //  in sorting later . . .
    STRINGLIST *buildCommands;      // (# of rules is mostly small
    STRINGLIST *buildMacros;        //  so not much memory used
	BOOL fBatch;					// TRUE if batch rule (doublecolon)
} RULELIST;


typedef struct deplist {
    struct deplist *next;
    char *name;
    time_t depTime;
} DEPLIST;


//  Bits in flags/gFlags indicate which cmdline options are set
//
//  -a  sets FORCE_BUILD
//  -c  sets CRYPTIC_OUTPUT (only fatal errors get displayed)
//  -d  sets DISPLAY_FILE_DATES
//  -e  sets USE_ENVIRON_VARS
//  -i  sets IGNORE_EXIT_CODES
//  -n  sets NO_EXECUTE
//  -p  sets PRINT_INFORMATION
//  -q  sets QUESTION_STATUS
//  -r  sets IGNORE_EXTERN_RULES
//  -s  sets NO_ECHO
//  -t  sets TOUCH_TARGETS
//  -z  sets REVERSE_BATCH_FILE (Required by PWB)
//  -l  sets NO_LOGO (internally /l actually -nologo)
//
//  Also included are  bits for
//
//     BUILDING_THIS_ONE  -  to detect cycles in dependencies
//     DOUBLECOLON    -  to indicate type of separator found between
//              the targets and dependencies (':' or '::')
//     ALREADY_BUILT      -  to indicate that a target has been built
//     OUT_OF_DATE    -  to indicate that this target is out of date

#define F1_PRINT_INFORMATION    0x01        // "global" flags that affect
#define F1_IGNORE_EXTERN_RULES  0x02        //  all targets (it doesn't
#define F1_USE_ENVIRON_VARS 0x04        //  make sense to allow the
#define F1_QUESTION_STATUS  0x08        //  user to change these)
#define F1_TOUCH_TARGETS    0x10
#define F1_CRYPTIC_OUTPUT   0x20
#define F1_NO_BATCH			0x40		// disable batching functionality
#define F1_NO_LOGO      0x80

#define F2_DISPLAY_FILE_DATES   0x01        // these are resettable w/in
#define F2_IGNORE_EXIT_CODES    0x02        //  the makefile
#define F2_NO_EXECUTE       0x04        // each target keeps own copy
#define F2_NO_ECHO      0x08
#define F2_FORCE_BUILD      0x10        // build even if up-to-date
#define F2_DOUBLECOLON      0x20        // indicates separator type
#define F2_DUMP_INLINE		0x40		// dump inline files

#define F3_BUILDING_THIS_ONE    0x01        // finds cyclical dependencies
#define F3_ALREADY_BUILT    0x02
#define F3_OUT_OF_DATE      0x04        // reuse :: bit after target
                        //  has been built
#define F3_ERROR_IN_CHILD   0x08        // used to implement slash k

//  ----------------------------------------------------------------------------
//  MACRODEF structure is used to make a list of macro definitions from the
//      commandline, makefile, TOOLS.INI file, and environment.  It contains
//      a flag which is set for macros defined in the command line so that
//      a later definition of the same macro will be ignored.  It also contains
//      a flag that gets set when NMAKE is expanding the macro so that recursive
//      definitions can be detected.
///

typedef struct macro {
    struct macro *next;
    char *name;
    STRINGLIST *values;             // can just be list of size 1
    UCHAR flags;
} MACRODEF;



//  Bits in flags field for macros.  We really only need to know if a macro
//  was defined on the commandline (in which case we ignore all redefinitions),
//  or if we're currently expanding macros in its value (so when we look
//  up a macro and that bit is set we can tell that the macro is defined
//  recursively).

#define M_EXPANDING_THIS_ONE    0x01
#define M_NON_RESETTABLE    0x02
#define M_ENVIRONMENT_DEF   0x04
#define M_WARN_IF_RESET     0x08
#define M_UNDEFINED     0x10
#define M_COMMAND_LINE      0x20
#define M_LITERAL			0x40	// value contains no other macros
									// treat $ literary


//  macros to simplify dealing w/ bits in flags, allocating memory, and
//  testing characters

#define SET(A,B)        ((A) |= (UCHAR)(B)) // turn bit B on in A
#define CLEAR(A,B)      ((A) &= (UCHAR)(~B))    // turn bit B off in A
#define ON(A,B)         ((A) &  (UCHAR)(B)) // is bit B on in A?
#define OFF(A,B)        (!ON(A,B))      // is bit B off in A?
#define FLIP(A,B)       (ON(A,B)) ? (CLEAR(A,B)) : (SET(A,B))
#define CANT_REDEFINE(A)    (ON((A)->flags,M_NON_RESETTABLE)           \
                    || (ON(gFlags,F1_USE_ENVIRON_VARS)         \
                    && ON((A)->flags,M_ENVIRONMENT_DEF)))


#define ALLOCATE_OBJECT(type) ((type *) allocate(sizeof(type)))

#define makeNewStrListElement()     ALLOC_STRINGLIST(STRINGLIST)
#define makeNewInlineListElement()  ALLOCATE_OBJECT(INLINELIST)
#define makeNewScriptListElement()  ALLOCATE_OBJECT(SCRIPTLIST)
#define makeNewMacro()          ALLOCATE_OBJECT(MACRODEF)
#define makeNewObject()         ALLOCATE_OBJECT(MAKEOBJECT)
#define makeNewImpliedObject()      ALLOCATE_OBJECT(MAKEOBJECT)
#define makeNewBuildBlock()     ALLOCATE_OBJECT(BUILDBLOCK)
#define makeNewBldListElement()     ALLOCATE_OBJECT(BUILDLIST)
#define makeNewRule()           ALLOCATE_OBJECT(RULELIST)
#define MakeNewDepListElement()     ALLOCATE_OBJECT(DEPLIST)
#define makeNewBatchListElement()	ALLOCATE_OBJECT(BATCHLIST)


#define WHITESPACE(A)       ((A) == ' '  || (A) == '\t')
#if 1       //JdR       see charmap.h
// #define MACRO_CHAR(A)    IS_MACROCHAR(A) 
// Modified MACRO_CHAR to fix handling of mbcs characters.
// 'A' may combine the bytes of the mbcs char in a single value and 
// end up being >= 256. All values >=128 can be treated as 
// valid macro characters [vc98 #9973 georgiop 9/19/97]
#define MACRO_CHAR(A)       (IS_MACROCHAR(A) || ((unsigned)(A)) >= 128)
#else
#define MACRO_CHAR(A)       ((A) == '_' || _istalnum(A) || ((unsigned)(A)) >= 128)
#endif
#define PATH_SEPARATOR(A)   ((A) == '\\' || (A) == '/')
#define DYNAMIC_DEP(A)      ((A)[2] == '('                     \
                    && (A)[3] == '@'                   \
                    && (A)[5] == ')'                   \
                    && (((A)[4] == 'F'                 \
                    || (A)[4] == 'D'               \
                    || (A)[4] == 'B'               \
                    || (A)[4] == 'R')))

//  values passed to getSpecialValue() to indicate which type of macro
//  we're expanding

#define SPECIAL_MACRO    0x01               // $* $@ $? $< $**
#define DYNAMIC_MACRO    0x02               // $$@
#define X_SPECIAL_MACRO  0x03               // $(*F) $(@D) etc.
#define X_DYNAMIC_MACRO  0x04               // $$(@F) $$(@D)
#define DOLLAR_MACRO     0x05               // $$ -> $


//  Bits in elements placed in the stack (ifStack) that keeps state
//  information about if/else/endif directives. Here "if" directive
//  includes if/ifdef/ifndef/if defined().
//                              -- used in routine lgetc() in ifexpr.c

#define NMIFELSE    0x01            // set for if/ifdef etc...reset for else
#define NMCONDITION 0x02            // set if condition part of if is true
#define NMIGNORE    0x04            // set if if/endif block is to be ignored/skipped
#define NMELSEIF    0x08            // set for else if/ifdef etc...reset for else


//  Values to record which of if/ifdef/ifndef/etc was seen to decide
//  the kind of processing to be done.

#define IF_TYPE         0x01
#define ELSE_TYPE       0x02
#define ELSE_IF_TYPE        0x03
#define ELSE_IFDEF_TYPE     0x04
#define ELSE_IFNDEF_TYPE    0x05
#define IFDEF_TYPE      0x06
#define IFNDEF_TYPE     0x07
#define ENDIF_TYPE      0x08


// Values to indicate if we are reading from the raw stream or thru'
// the routine lgetc() which preprocesses directives. These are used
// by a routine common to lgetc() module and the lexer.

#define FROMLOCAL    0x00
#define FROMSTREAM   0x01

//  macros to simplify accessing hash tables
//  find() returns a STRINGLIST pointer, which is then cast to a pointer
//  of the appropriate structure type

#define findTarget(A) (MAKEOBJECT*) find(A, MAXTARGET,                 \
                     (STRINGLIST**)targetTable,        \
                     (BOOL)TRUE)

//  "action" flags for building target-table entries
//  if any of the bits in A_SUFFIX to A_RULE is set, the action routines
//  WON'T build a targetblock for the current target (really pseudotarget
//  or rule)

// A_TARGET says expand names on input (dependent names get expanded when
// target is built) */

#define A_SUFFIX    0x01
#define A_SILENT    0x02
#define A_IGNORE    0x04
#define A_PRECIOUS  0x08
#define A_RULE      0x10
#define A_TARGET    0x20
#define A_STRING    0x40
#define A_DEPENDENT 0x80

//  "build" flags used by recursive target-building function

#define B_COMMANDS  0x01
#define B_BUILD     0x02
#define B_INMAKEFILE    0x04
#define B_NOTARGET  0x08
#define B_ADDDEPENDENT  0x10
#define B_DOUBLECOLON   0x20
#define B_DEP_OUT_OF_DATE 0x40

//  "command" flags used by doCommand function

#define C_SILENT    0x01
#define C_IGNORE    0x02
#define C_ITERATE   0x04
#define C_EXECUTE   0x08
#define C_EXPANDED  0x10

//  keyword for better profiling, normally set to "static".

#ifndef LOCAL
#define LOCAL static
#endif

// GetTxtChr and UngetTxtChr are the MBCS counterparts of getc and ungetc.
#ifdef _MBCS
extern int GetTxtChr(FILE*);
extern int UngetTxtChr(int, FILE*);
#else
#define GetTxtChr(a)    getc(a)
#define UngetTxtChr(c,f) ungetc(c,f)
#endif

#define strend(p) (p + _tcslen(p))

#include "charmap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\precomp.h ===
#include "nmake.h"
#include "nmmsg.h"
#include "proto.h"
#include "globals.h"
#include "grammar.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\print.cpp ===
//  PRINT.C -- routines to display info for -p option
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Contains routines that print stuff for -p (and also -z, ifdef'ed)
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  16-May-1991 SB  Move printDate() here from build.c
//  02-Feb-1990 SB  change fopen() to FILEOPEN()
//  22-Nov-1989 SB  Changed free() to FREE()
//  07-Nov-1989 SB  When TMP ended in '\\' then don't add '\\' at end of path
//                  specification for PWB.SHL
//  19-Oct-1989 SB  added searchHandle parameter
//  18-Aug-1989 SB  added fclose() error check
//  05-Jul-1989 SB  Cleaned up -p output to look neater
//  19-Jun-1989 SB  Localized messages with -p option
//  24-Apr-1989 SB  added 1.2 filename support, FILEINFO replaced by void *
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  10-Mar-1989 SB  printReverse() now prints to TMP:PWB.SHL instead of stdout
//   1-Dec-1988 SB  Added printReverseFile() to handle 'z' option
//  17-Aug-1988 RB  Clean up.

#include "precomp.h"
#pragma hdrstop

#include <time.h>
#include "nmtime.h"

// for formatting -p info
#define PAD1        40

size_t   checkLineLength(size_t i, char *s);
void     showDependents(STRINGLIST*, STRINGLIST*);

size_t
checkLineLength(
    size_t i,       // current length
    char *s         // string whose length is to be checked
    )
{
    if ((i += _tcslen(s)) > 40) {
        printf("\n\t\t\t");
        i = 0;
    }
    return(i);
}


void
printDate(
    unsigned spaces,        // spaces to print
    char *name,             // name of file whose date is to be printed
    time_t dateTime         // dateTime of file
    )
{
    if (dateTime == 0) {
        makeMessage(TARGET_DOESNT_EXIST, spaces, "", name);
    } else {
        char *s;

        s = ctime(&dateTime);
        s[24] = '\0';

        makeMessage(TIME_FORMAT, spaces, "", name, PAD1-spaces, s);
    }
}


void
showDependents(
    STRINGLIST *q,          // list of dependents
    STRINGLIST *macros      // macros in the dependents
    )
{
    char *u, *v;
    char *w;
    size_t i;
    struct _finddata_t finddata;
    NMHANDLE searchHandle;

    makeMessage(DEPENDENTS_MESSAGE);
    for (i = 0; q; q = q->next) {
        char *szFilename;

        if (_tcschr(q->text, '$')) {
            u = expandMacros(q->text, &macros);

            for (v = _tcstok(u, " \t"); v; v = _tcstok(NULL, " \t")) {
                if (_tcspbrk(v, "*?")) {
                    if (szFilename = findFirst(v, &finddata, &searchHandle)) {
                        do {
                            w = prependPath(v, szFilename);
                            printf("%s ", w);
                            i = checkLineLength(i, w);
                            FREE(w);
                        }
                        while (szFilename = findNext(&finddata, searchHandle));
                    }
                } else {
                    printf("%s ", v);
                    i = checkLineLength(i, v);
                }
            }

            FREE(u);
        } else if (_tcspbrk(q->text, "*?")) {
            if (szFilename = findFirst(q->text, &finddata, &searchHandle)) {
                do {
                    v = prependPath(q->text, szFilename);
                    printf("%s ", v);
                    i = checkLineLength(i, v);
                    FREE(v);
                }
                while (szFilename = findNext(&finddata, searchHandle));
            }
        } else {
            printf("%s ", q->text);
            i = checkLineLength(i, q->text);
        }
    }
}


void
showMacros(
    void
    )
{
    MACRODEF *p;
    STRINGLIST *q;
    int n = 0;

    makeMessage(MACROS_MESSAGE);

    for (n = 0; n < MAXMACRO; ++n) {
        for (p = macroTable[n]; p; p = p->next) {
            if (p->values && p->values->text) {
                makeMessage(MACRO_DEFINITION, p->name, p->values->text);
                for (q = p->values->next; q; q = q->next) {
                    if (q->text) {
                        printf("\t\t%s\n", q->text);
                    }
                }
            }
        }
    }

    putchar('\n');

    fflush(stdout);
}


void
showRules(
    void
    )
{
    RULELIST *p;
    STRINGLIST *q;
    unsigned n;

    makeMessage(INFERENCE_MESSAGE);

    for (p = rules, n = 1; p; p = p->next, ++n)  {
        printf(p->fBatch? "%s::" : "%s:", p->name);

        makeMessage(COMMANDS_MESSAGE);

        if (q = p->buildCommands) {
            printf("%s\n", q->text);

            while (q = q->next) {
                printf("\t\t\t%s\n", q->text);
            }
        }

        putchar('\n');
    }

    printf("%s: ", suffixes);

    for (q = dotSuffixList; q; q = q->next) {
        printf("%s ", q->text);
    }

    putchar('\n');

    fflush(stdout);
}


void
showTargets(
    void
    )
{
    unsigned bit, i;
    STRINGLIST *q;
    BUILDLIST  *s;
    BUILDBLOCK *r;
    MAKEOBJECT *t;
    unsigned n;
    LOCAL char *flagLetters = "dinsb";

    makeMessage(TARGETS_MESSAGE);
    for (n = 0; n < MAXTARGET; ++n) {
        for (t = targetTable[n]; t; t = t->next, putchar('\n')) {
            printf("%s:%c", t->name,
                   ON(t->buildList->buildBlock->flags, F2_DOUBLECOLON)
                       ? ':' : ' ');
            dollarStar = dollarAt = dollarDollarAt = t->name;
            for (s = t->buildList; s; s = s->next) {
                r = s->buildBlock;
                makeMessage(FLAGS_MESSAGE);
                for (i = 0, bit = F2_DISPLAY_FILE_DATES;
                     bit < F2_FORCE_BUILD;
                     ++i, bit <<= 1)
                     if (ON(r->flags, bit))
                        printf("-%c ", flagLetters[i]);
                showDependents(r->dependents, r->dependentMacros);
                makeMessage(COMMANDS_MESSAGE);
                if (q = r->buildCommands) {
                    if (q->text) printf("%s\n", q->text);
                    while (q = q->next)
                        if (q->text) printf("\t\t\t%s\n", q->text);
                }
                else putchar('\n');
            }
        }
    }
    dollarStar = dollarAt = dollarDollarAt = NULL;
    putchar('\n');
    fflush(stdout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\proto.h ===
//  PROTO.H -- function prototypes
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This include file contains global function prototypes for all modules.
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  01-Jun-1993 HV  Change #ifdef KANJI to _MBCS
//  02-Feb-1990 SB  Add open_file() prototype
//  31-Jan-1990 SB  Debug version changes
//  08-Dec-1989 SB  Changed proto of SPRINTF()
//  04-Dec-1989 SB  Changed proto of expandFileNames() to void from void *
//  01-Dec-1989 SB  realloc_memory() added #ifdef DEBUG_MEMORY
//  22-Nov-1989 SB  free_memory() and mem_status() added #ifdef DEBUG_MEMORY
//  19-Oct-1989 SB  added param (searchHandle) to protos of file functions
//  02-Oct-1989 SB  setdrive() proto change
//  18-Aug-1989 SB  heapdump() gets two parameters
//  05-Jun-1989 SB  heapdump() prototype was added
//  22-May-1989 SB  added parameter to freeRules()
//  19-Apr-1989 SB  getFileName(), getDateTime(), putDateTime() added
//                  changed FILEINFO to void * in
//                  findFirst(), findNext(), searchPath(), findRule()
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  22-Mar-1989 SB  rm unlinkTmpFiles(); add delScriptFiles()
//  09-Mar-1989 SB  Changed param from FILEINFO* to FILEINFO** for findRule
//  03-Feb-1989 SB  Changed () to (void) for prototypes
//  02-Feb-1989 SB  Moved freeUnusedRules() prototype from nmake.c to here and
//                  renamed as freeRules()
//  05-Dec-1988 SB  Added CDECL for functions with var params, ecs_strchr() and
//                  ecs_strrchr(); deleted proto for exit() - not reqd
//  23-Oct-1988 SB  Added putEnvStr()
//  07-Jul-1988 rj  Added targetFlag parameter to find and hash
//  06-Jul-1988 rj  Added ecs_system declaration
//  28-Jun-1988 rj  Added doCmd parameter to execLine
//  23-Jun-1988 rj  Added echoCmd parameter to execLine

void        displayBanner(void);
void __cdecl makeError(unsigned, unsigned, ...);
void __cdecl makeMessage(unsigned, ...);
UCHAR       getToken(unsigned, UCHAR);
int         skipWhiteSpace(UCHAR);
int         skipBackSlash(int, UCHAR);
void        parse(void);
void        appendItem(STRINGLIST **, STRINGLIST *);
void        prependItem(STRINGLIST **, STRINGLIST *);
STRINGLIST * removeFirstString(STRINGLIST **);
void      * allocate(size_t);
void      * alloc_stringlist(void);
void      * rallocate(size_t);
char      * makeString(const char *);
char	  * makeQuotedString(const char *);
char      * reallocString(char * pszTarget, const char *szAppend);
BOOL        tagOpen(char *, char *, char *);
void        parseCommandLine(unsigned, char **);
void        getRestOfLine(char **, size_t *);
BOOL        defineMacro(char *, char *, UCHAR);
STRINGLIST * find(char *, unsigned, STRINGLIST **, BOOL);
MACRODEF *  findMacro(char *);
void        insertMacro(STRINGLIST *);
unsigned    hash(char *, unsigned, BOOL);
void        prependList(STRINGLIST **, STRINGLIST **);
BOOL        findMacroValues(char *, STRINGLIST **, STRINGLIST **, char *, unsigned, unsigned, UCHAR);
BOOL        findMacroValuesInRule(RULELIST *, char *, STRINGLIST **);
char      * removeMacros(char *);
void        delScriptFiles(void);
char      * expandMacros(char *, STRINGLIST **);
STRINGLIST * expandWildCards(char *);
void        readCommandFile(char *);
void        setFlags(char, BOOL);
void        showTargets(void);
void        showRules(void);
void        showMacros(void);
char      * findFirst(char*, void *, NMHANDLE*);
char      * findNext(void *, NMHANDLE);

int         processTree(void);
void        expandFileNames(char *, STRINGLIST **, STRINGLIST **);
void        sortRules(void);
BOOL        isRule(char *);
char      * prependPath(const char *, const char *);
char      * searchPath(char *, char *, void *, NMHANDLE*);
BOOL        putMacro(char *, char *, UCHAR);
int         execLine(char *, BOOL, BOOL, BOOL, char **);
RULELIST  * findRule(char *, char *, char *, void *);
int         lgetc(void);
UCHAR       processIncludeFile(char *);
BOOL        evalExpr(char *, UCHAR);
int         doMake(unsigned, char **, char *);
void        freeList(STRINGLIST *);
void        freeStringList(STRINGLIST *);
#ifdef _MBCS
int         GetTxtChr(FILE*);
int         UngetTxtChr (int, FILE *);
#endif
int         putEnvStr(char *, char *);
#define PutEnv(x) _putenv(x)
void        expandExtmake(char *, char *, char*);
BOOL		ZFormat(char *, unsigned, char *, char *);
void        printReverseFile(void);
void        freeRules(RULELIST *, BOOL);
char      * getFileName(void *);
time_t      getDateTime(const _finddata_t *);
void        putDateTime(_finddata_t *, time_t);
char      * getCurDir(void);

void        free_memory(void *);
void        free_stringlist(STRINGLIST *);
void      * realloc_memory(void *, unsigned);

FILE      * open_file(char *, char *);
void        initMacroTable(MACRODEF *table[]);
void        TruncateString(char *, unsigned);
BOOL        IsValidMakefile(FILE *fp);
FILE      * OpenValidateMakefile(char *name,char *mode);

// from util.c
char      * unQuote(char*);
int         strcmpiquote(char *, char*);
char     ** copyEnviron(char **environ);
void        printStats(void);
void        curTime(time_t *);

// from charmap.c
void        initCharmap(void);

// from print.c
void        printDate(unsigned, char*, time_t);

// from build.c
int         invokeBuild(char*, UCHAR, time_t *, char *);
void        DumpList(STRINGLIST *pList);

// from exec.c
extern int  doCommands(char*, STRINGLIST*, STRINGLIST*, UCHAR, char *);
extern int  doCommandsEx(STRINGLIST*, STRINGLIST*, STRINGLIST*, UCHAR, char *);

// from rule.c
extern RULELIST * useRule(MAKEOBJECT*, char*, time_t,
              STRINGLIST**, STRINGLIST**, int*, time_t *,
              char **);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\register.h ===
//  register.h - definitions for register variable specifiers
//
//  Copyright (c) 1985-1990, Microsoft Corporation.  All rights reserved.
//
//Purpose:
//  This file contains definitions for register variable specifiers.
//  [Internal]
//
//Revision History:
//  06-08-88  SKS   Removed M_M68000 ifdef
//  08-22-89  GJF   Fixed copyright (again)

#define REG1    register
#define REG2    register

#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\rpn.h ===
// header file with all the necessary structures and tables for
// the expression evaluator.
//
//  Modifications:
//
//  15-Nov-1993 JdR Major speed improvements
//  26-Jul-1988 rj  Removed entry defining "^" as bitwise xor.  Left the
//                  BIT_XOR entries in to avoid bothering with rpn.c.
//                  Then realized it had to go in, so fixed it to handle
//                  IBM and Microsoft versions properly.

typedef struct rpn_info {
    UCHAR type;
    INT_PTR valPtr;   // value or ptr to string
}RPNINFO;

// The precedence vector is also indexed by the operator/operand type
// code to get the precedence for the operator/operand.
// The precedence is used to determine if an item is to stay on the
// temporary stack or is to be moved to the reverse-polish list.

static UCHAR precVector[] = {
    0,      // right paren ')'
    1,      // logical or
    2,      // logical and
    3,      // bit or
    4,      // bit xor
    5,      // bit and
    6,      // equals  '!='
    6,      // equals  '=='
    7,      // relation '>'
    7,      // relation '<'
    7,      // relation '>='
    7,      // relation '<='
    8,      // shift    '>>'
    8,      // shift    '<<'
    9,      // add      '-'
    9,      // add      '+'
    10,     // mult     '%'
    10,     // mult     '/'
    10,     // mult     '*'
    11,     // unary    '-'
    11,     // unary    '~'
    11,     // unary    '!'
    12,     // primary  int
    12,     // primary  str
    12,     // primary  str-sp
    0       // left paren '('
};


// these are the various type codes for the operator/operand tokens

#define RIGHT_PAREN     0
#define LOGICAL_OR      1
#define LOGICAL_AND     2
#define BIT_OR          3
#define BIT_XOR         4
#define BIT_AND         5
#define NOT_EQUAL       6
#define EQUAL           7
#define GREATER_THAN    8
#define LESS_THAN       9
#define GREATER_EQ     10
#define LESS_EQ        11
#define SHFT_RIGHT     12
#define SHFT_LEFT      13
#define BINARY_MINUS   14
#define ADD            15
#define MODULUS        16
#define DIVIDE         17
#define MULTIPLY       18
#define UNARY_MINUS    19
#define COMPLEMENT     20
#define LOGICAL_NOT    21
#define INTEGER        22
#define STR            23
#define PROG_INVOC_STR 24
#define LEFT_PAREN     25


// error table used by the getTok() routines to detect illegal token combinations.
// The table is explained with the routine check_syntax_error()

static UCHAR errTable[5][5] =  {
    { 0, 1, 0, 0, 1 },
    { 1, 0, 1, 1, 0 },
    { 1, 0, 0, 1, 0 },
    { 1, 0, 1, 1, 0 },
    { 0, 1, 0, 0, 1 }
};


// we save space by placing most of the tokens returned to the
// expr-eval parser in a table as shown below. At any time, the
// longest possible token is to be returned, hence the order of
// the strings is very important. eg: '||' is placed BEFORE '|'

typedef struct _tok_tab_rec {
    char *op_str;
    UCHAR op;
} TOKTABREC;

static TOKTABREC tokTable[] = {
    { "(",   LEFT_PAREN   },
    { ")",   RIGHT_PAREN  },
    { "*",   MULTIPLY     },
    { "/",   DIVIDE       },
    { "%",   MODULUS      },
    { "+",   ADD          },
    { "<<",  SHFT_LEFT    },
    { ">>",  SHFT_RIGHT   },
    { "<=",  LESS_EQ      },
    { ">=",  GREATER_EQ   },
    { "<",   LESS_THAN    },
    { ">",   GREATER_THAN },
    { "==",  EQUAL        },
    { "!=",  NOT_EQUAL    },
    { "&&",  LOGICAL_AND  },
    { "||",  LOGICAL_OR   },
    { "&",   BIT_AND      },
    { "|",   BIT_OR       },
    { "^^",  BIT_XOR      },
    { "~",   COMPLEMENT   },
    { "!",   LOGICAL_NOT  },
    { NULL,  0            }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\rpn.cpp ===
//  RPN.C -- expression evaluator
//
//    Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains NMAKE's expression evaluator routines.
//
// Revision History:
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  04-Dec-1989 SB  Add prototype for match() and chkInvokeAndPush()
//  09-Oct-1989 SB  Added HACK to handle pointer arithmetic quirks; Done to
//                  avoid rewriting entire module
//  08-Oct-1989 SB  '!if' expressions can be decimal, octal or hex now
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  19-Sep-1988 RB  Split ptr_to_string().  Process ESCH in program invocations.
//  17-Aug-1988 RB  Clean up.
//  28-Jun-1988 rj  Added doCmd parameter to execLine.
//  23-Jun-1988 rj  Add parameter to execLine (no echo of command).
//  25-May-1988 rb  Change isspace to _istspace, isdigit to _istdigit.

#include "precomp.h"
#pragma hdrstop

#include "rpn.h"

char      * GetEndQuote(void);
char      * GetEndBracket(void);
void      check_syntax_error(UCHAR);
void      type_and_val(UCHAR, INT_PTR);
void      pushIntoList(void);
void      printList(void);
BOOL      handleExpr(void);
BOOL      handleExists(char*);
BOOL      handleDefines(char*);
void      getTok(void);
BOOL      do_binary_op(UCHAR);
BOOL      do_unary_op(UCHAR);
UCHAR     match(char *tokPtr);
void      chkInvocAndPush(RPNINFO *pListPtr);

#define TEMPSTACKSIZE   512         // size of temporary stack
#define LISTSIZE        1024        // size of list of rpn-form items

RPNINFO     tempStack[TEMPSTACKSIZE];   // temporary/operand stack
RPNINFO     rpnList[LISTSIZE];      // list of items in rpn order
char    * text;               // pointer to expr text in lbufPtr
UCHAR     prevTok;            // initial token put on tempstack
BOOL      done;               // true if there are no more tokens
UCHAR     errRow;             // first token is '(' so error table
                                    //  row val is 3. See check_syntax....
RPNINFO * pTop;               // top item on tempStack
RPNINFO * pList;              // next free slot in list
RPNINFO * pEnd     = &(tempStack[TEMPSTACKSIZE-1]);
RPNINFO * pListEnd = &(rpnList[LISTSIZE-1]);
RPNINFO   tokRec;


// do_binary_op() - do operation on two stack operands
//
// arguments:  type - operator type code
//
// actions  :  pops first operand from the stack (tempStack).
//             checks the types of the two operands (the operand
//             that was popped as well as the operand currently
//             on top of the stack).
//             if both operands are integers then do the operation
//             else if both operands are strings and operation is
//               the equality operation then do it.
//             else return FALSE ( illegal operation )
//
// modifies :  tempStack - top element will now be the result of
//                   the operation.

BOOL
do_binary_op(
    UCHAR type
    )
{
    INT_PTR *left;
    INT_PTR *right;
    RPNINFO *pOldTop;

    pOldTop = pTop--;               // pop one item off stack, with a ptr to it
    right = &pOldTop->valPtr;
    left = &pTop->valPtr;

    if ((pOldTop->type == INTEGER) && (pTop->type == INTEGER)) {
        switch (type) {
            case LOGICAL_OR:
                *left = *left || *right;
                break;

            case LOGICAL_AND:
                *left = *left && *right;
                break;

            case BIT_OR:
                *left |= *right;
                break;

            case BIT_XOR:
                *left ^= *right;
                break;

            case BIT_AND:
                *left &= *right;
                break;

            case NOT_EQUAL:
                *left = *right != *left;
                break;

            case EQUAL:
                *left = *right == *left;
                break;

            case GREATER_THAN:
                *left = *left > *right;
                break;

            case LESS_THAN:
                *left = *left < *right;
                break;

            case GREATER_EQ:
                *left = *left >= *right;
                break;

            case LESS_EQ:
                *left = *left <= *right;
                break;

            case SHFT_RIGHT:
                *left >>= *right;
                break;

            case SHFT_LEFT:
                *left <<= *right;
                break;

            case BINARY_MINUS:
                *left -= *right;
                break;

            case ADD:
                *left += *right;
                break;

            case MODULUS:
                if (!*right)
                    makeError(line, DIVIDE_BY_ZERO);
                *left %= *right;
                break;

            case DIVIDE:
                if (!*right)
                    makeError(line, DIVIDE_BY_ZERO);
                *left /= *right;
                break;

            case MULTIPLY:
                *left *= *right;
                break;

            default:
                return(FALSE);
                break;
        }
    } else if ((pOldTop->type == STR) &&
                (pTop->type == STR) &&
                ((type == EQUAL) || (type == NOT_EQUAL))) {
        pTop->type = INTEGER;
        *left = !_tcscmp((char *) *left, (char *) *right);
        if (type == NOT_EQUAL) {
            if (!do_unary_op(LOGICAL_NOT)) {
                return(FALSE);
            }
        }
    } else {
        return(FALSE);
    }

    return(TRUE);
}


// do_unary_op() - do operation on top stack operand
//
// arguments:  type - operator type code
//
// actions  :  checks the type of the top operand on the stack
//             if operand is an integer then do the operation
//             else return FALSE ( illegal operation )
//
// modifies :  tempStack - top element will now be the result of
//                   the operation.

BOOL
do_unary_op(
    UCHAR type
    )
{
    INT_PTR *top;

    top = &pTop->valPtr;

    if (pTop->type == INTEGER) {
        switch (type) {
            case UNARY_MINUS:
                *top = -*top;
                break;

            case COMPLEMENT:
                *top = ~*top;
                break;

            case LOGICAL_NOT:
                *top = !*top;
                break;

            default:
                return(FALSE);
                break;
        }
    } else {
        return(FALSE);
    }

    return(TRUE);
}



// GetEndQuote
//
// Return the pointer to the next double-quote character in text.  A
// double-quote followed immediately by a double-quote is skipped.
//
// text : the global ptr to the buffer is moved up beyond this string.

char *
GetEndQuote()
{
    char *pStart;

    for (pStart = ++text; *text; ++text)
        if (*text == '\"') {
            if (text[1] == '\"')
                ++text;
            else
                break;
        }

    if (!*text)
        makeError(line, SYNTAX_MISSING_END_CHAR, '\"');

    *text++ = '\0';                     // null byte over closing quote
    return(pStart);
}


// GetEndBracket
//
// Lexes a program invocation.
//
// Program invocation is of the form: [ prog <arglist> ].
// Process escaped ']' here because this is where we do the lexing.
//
// text : the global ptr to the buffer is moved up beyond this string.

char *
GetEndBracket()
{
    char *pStart;

    for (pStart = ++text; *text; text = _tcsinc (text)) {
        if (*text == ESCH && text[1] == ']')
            memmove(text, text + 1, 1 + _tcslen(text + 1));
        else if (*text == ']')
            break;
    }

    if (!*text)
        makeError(line, SYNTAX_MISSING_END_CHAR, ']');

    *text++ = '\0';                     // null byte over closing bracket
    return(pStart);
}


//  check_syntax_error()  - check if there is a syntax error in expr
//
//  arguments:  type  - type of the current token
//
//  actions:    checks the type of the current token against the type
//              of the previous token.
//
//  ERROR_TABLE :
//                  2nd tok
//
//              alpha     op    unary_op       (        )
//             ------------------------------------------------
//      alpha |   0   |   1   |    0      |     0   |   1     |
//            -------------------------------------------------
//        op  |   1   |   0   |    1      |     1   |   0     |
//            -------------------------------------------------
//   unary_op |   1   |   0   |    0      |     1   |   0     |
//            -------------------------------------------------
//      (     |   1   |   0   |    1      |     1   |   0     |
//            -------------------------------------------------
//        )   |   0   |   1   |    0      |     0   |   1     |
//            -------------------------------------------------
//   1st tok.
//
//    alpha : a primary ( integer, str, prog. invoc. )
//       op : a binary operator
// unary_op : a unary operator ( ~, !, - ). A  ZERO in the slot => error
//
// NOTE: ANY CHANGES TO THE TYPE VALUES WILL AFFECT THIS ROUTINE.

void
check_syntax_error(
    UCHAR newTok
    )
{
    extern UCHAR errTable[5][5];
    extern UCHAR errRow;
    UCHAR errCol;

    if (newTok == LEFT_PAREN)
        errCol = 3;
    else if (newTok == RIGHT_PAREN)
        errCol = 4;
    else if (newTok > LOGICAL_NOT)
        errCol = 0;
    else if (newTok > MULTIPLY)
        errCol = 2;
    else
        errCol = 1;

    if (!errTable[errRow][errCol])
        makeError(line, SYNTAX_INVALID_EXPR);
    errRow = errCol;            // this becomes the first token the next time
}


// type_and_val()
//
// arguments:  type - the type code of the present operator.
//             val  - ptr to a str/or integer
//
// initialises a record with the type code, after checking for any
// syntax errors. The new token is checked against the previous token
// for illegal combinations of tokens.
// initialises the record with the integer value/string ptr.

void
type_and_val(
    UCHAR type,
    INT_PTR val
    )
{
    extern RPNINFO tokRec;              // returned to handleExpr
    extern UCHAR prevTok;               // token last seen

    check_syntax_error(type);
    prevTok = type;
    tokRec.type = type;
    tokRec.valPtr = val;
}


// match()
//
// arguments:  tokPtr - ptr to a token string ( in tokTable )
//
// actions  :  looks for a substring in the expression buffer
//             pointed to by 'text', that matches the given token.
//             if substring found, returns TRUE, else returns FALSE.

UCHAR
match(
    char *tokPtr
    )
{
    extern char *text;
    char *t = text;

    while (*tokPtr && (*t == *tokPtr)) {
        t++;
        tokPtr++;
    }
    if (!*tokPtr) {
        text = t;
        return(TRUE);
    }
    return(FALSE);
}


// getTok()
//
// arguments: none
//
// gets a token from the expression buffer.
// if the current char from the buffer is a space/tab, skip space/tabs
//   until we get a non-space char ( could be NULL char ).
// Check if we are now at the beginning of one of the tokens in the
//   tokenTable. This covers most tokens.
// Check if we have a minus. If a minus and the previous token was an
//   integer, this is a binary minus, else a unary minus.
// If the current char is a double-quote, we are at the start of a
//     string-token.
// If the current char is a '[', we are at the start of a program
//   invocation. In both cases, the escape character is '\\'.
// If current char is a digit, we have a constant ( integer ).
// Else we have defined(ID).
// If none of the above, if current char is NULL, break out, else
//   report error ( illegal character string has been found ).
//
// If we came to the NULL char at the end of the buffer, set global
//    flag 'done' to TRUE, return a RIGHT_PAREN to match the opening
//    LEFT_PAREN.
//
//
// modifies:  text  : ptr to expression buffer.
//           prevTok: thru' calls to type_and_val().
//             done : at end of buffer
//           errRow : index into error table, thru calls to
//                    type_and_val()
// returns : token in tokRec(global, static to the module). The
//             token has the new type/integer/ptr values.

void
getTok()
{
    extern UCHAR prevTok;
    extern BOOL done;
    char c;
    TOKTABREC *p;
    char *ptr;
    long constant;

    c = *text;
    if (c == ' ' || c == '\t') {
        while(_istspace(c))
            c = *++text;                // skip white spaces
    }

    if (IS_OPERATORCHAR(c)) {
        for (p = tokTable; p->op_str && !match(p->op_str); p++)
            ;
    } else {
        // make p point to last entry in table
        p = &tokTable[(sizeof(tokTable) / sizeof(TOKTABREC)) - 1];
    }

    if (p->op_str) {
        type_and_val(p->op, 0);
    } else
    if (c == '-') {         // now check if binary or unary minus to be returned
        text++;
        if (prevTok == INTEGER)
            type_and_val(BINARY_MINUS, 0);
        else
            type_and_val(UNARY_MINUS, 0);
    } else
    if (c == '\"') {
        type_and_val(STR, (INT_PTR) GetEndQuote());
    } else
    if (c == '[') {
        type_and_val(PROG_INVOC_STR, (INT_PTR) GetEndBracket());
    } else {                            // integers and IDs handled here
        if (_istdigit(c)) {
            char *pNumber = text;

            errno = 0;                  // Accept decimal, octal or hex no (richgi)
            constant = strtol(text, &text, 0);
            if (errno == ERANGE) {
                *text = '\0';
                makeError(line, CONST_TOO_BIG, pNumber);
            }

            if (_totupper(*text) == 'L')
                text++;
            type_and_val(INTEGER, constant);
        } else {                        // defined(ID) comes here
            if (c) {
                if (!_tcsnicmp(text, "DEFINED", 7)) {
                    if (!(ptr = _tcschr(text, '(')))
                        makeError(line, SYNTAX_INVALID_EXPR);
                    ptr++;
                    text = ptr + _tcscspn(ptr, ")");
                    *text++ = '\0';
                    type_and_val(INTEGER, handleDefines(ptr));
                }
                else if (!_tcsnicmp(text, "EXIST", 5)) {
                    if (!(ptr = _tcschr(text, '(')))
                        makeError(line, SYNTAX_INVALID_EXPR);
                    ptr++;
                    text = ptr + _tcscspn(ptr, ")");
                    *text++ = '\0';
                    type_and_val(INTEGER, handleExists(ptr));
                }
                else
                    makeError(line, SYNTAX_INVALID_EXPR);
            } else {        // we are now at the end of the string (c is null)
                done = TRUE;
                type_and_val(RIGHT_PAREN, 0);  // this is the last token
            }
        }
    }
}


// chkInvocAndPush()  - check if program invocation required
//
// arguments:  pListPtr - might have a program invocation string
//                         present.
//
// actions  :  if this is a program invocation string, make the
//             program invocation.
//             the return value is got and placed on the stack.
//             the type of the new stack element is now INTEGER.
//             else place list item on stack.
//
//             in either case it moves one item from list to stack.

void
chkInvocAndPush(
    RPNINFO *pListPtr
    )
{
    ++pTop;
    if (pListPtr->type == PROG_INVOC_STR) {
        pTop->valPtr = execLine((char *) pListPtr->valPtr, FALSE, TRUE, FALSE, NULL);
        pTop->type = INTEGER;
    } else {
        *pTop = *pListPtr;
    }
}


// processList()
//
// arguments:  none
//
// actions :   remove an item from the list.
//             if the item is an operand, place it on the operand
//              stack (tempStack).
//             if the operand is a program invocation string, make
//              the invocation, place the return code on stack.
//             if the item is an operator, call the function to
//              do the operation on one/two elements on tempStack.
//
//             finally, check if there is exactly one item on stack.
//             if this item has a value of zero, return FALSE.
//             else return TRUE.
//             if more than one item on stack, abort with error.
//
// modifies:   pTop    - ptr to top of tempStack.
//             pList   - ptr to next position in list.

BOOL
processList()
{
    extern RPNINFO *pList;
    extern RPNINFO *pTop;
    RPNINFO *pTemp;
    BOOL (* func)(UCHAR);

    for (pTemp = rpnList; pTemp < pList; pTemp++) {
        if (pTemp->type > LOGICAL_NOT) {            // operand
            chkInvocAndPush(pTemp);
        } else {
            if (pTemp->type > MULTIPLY)
                func = do_unary_op;
            else
                func = do_binary_op;

            if (!(*func)(pTemp->type))
                makeError(line, BAD_OP_TYPES);
        }
    }

    if ((pTop == tempStack) && (pTop->type == INTEGER))
        if (!pTop->valPtr)
            return(FALSE);
        else
            return(TRUE);
    else
        makeError(line, SYNTAX_INVALID_EXPR);

    return(FALSE);
}


// pushIntoList()
//
// arguments:  none
//
// actions :   pops an item from the tempStack and pushes it onto
//             the list. checks list for overflow ( internal error )
//             and tempStack for underflow ( syntax error in expr ).
//
// modifies:   tempTop    - index of top of tempStack.
//             nextInList - index to next position in list.

void
pushIntoList()
{
    if (pTop < tempStack)
        makeError(line, SYNTAX_INVALID_EXPR);

    if (pList > pListEnd)
        makeError(line, EXPR_TOO_LONG_INTERNAL);

#if !defined(NDEBUG)
    // Keep track of the high water mark on the stack just for grins
    {
        static int  iStackMax = 0;
        if ( pList - rpnList > iStackMax )
            iStackMax = (int) (pList - rpnList);
    }
#endif

    *pList++ = *pTop--;
}


// handleExpr()
//
// arguments:  text - pointer to the buffer that has the expression.
//
// actions  :  calls getTok() to get tokens from the buffer. Places
//             tokens in a tempStack, and moves them into a list in
//             reverse-polish order.
//
//             We need the list so that ALL syntax errors are caught
//             BEFORE processing of the expression begins (especially
//             program invocations that have side effects)
//
//             Once the list is available, an operand stack is used
//             Items are popped and pushed from this stack by the
//             evaluation routines (add, mult, negate etc.)
//
//             we don't really need a separate operand stack. the
//             tempStack has served its purpose when the list is
//             formed and so it may be used for operand processing.

BOOL
handleExpr()
{
    extern RPNINFO tokRec;
    BOOL fRParen;                       // was the token got a right paren?
    extern BOOL done;
    extern RPNINFO *pTop, *pList;
    extern UCHAR errRow;
    extern UCHAR prevTok;

    pTop = tempStack;
    pList = rpnList;
    done = FALSE;
    errRow = 3;                     // row for the first token put in,left paren
    prevTok = LEFT_PAREN;
    type_and_val(LEFT_PAREN, 0);
    *pTop = tokRec;

    while (!done) {                 // while there are more tokens in buffer
        getTok();
        fRParen = FALSE;
        if (tokRec.type != LEFT_PAREN) {
            while (precVector[tokRec.type] <= precVector[pTop->type]) {
                if (!precVector[tokRec.type]) { // if RIGHT_PAREN pop till a
                                                // left paren is seen
                    while (pTop->type != LEFT_PAREN)
                        pushIntoList();
                    fRParen = TRUE;
                    if (pTop < tempStack) {
                        makeError(line, SYNTAX_INVALID_EXPR);
                    } else {
                        pTop--;                 // pop the left paren
                        break;
                    }
                } else {
                    pushIntoList();
                }
            }
        }
        // if token is a left paren, it has to go on the stack
        if (!fRParen) {
            if (pTop == pEnd)
                makeError(line, EXPR_TOO_LONG_INTERNAL);
            else
                *++pTop = tokRec;
        }
    }

    // check the stack here for not empty state
    if (pTop != tempStack - 1)
        makeError(line, SYNTAX_INVALID_EXPR);
    return(processList());
}


// handleDefines()
//
// arguments:  t   pointer to buffer that has the identifier
//
// actions:    Checks if one of 'ID' is present.
//             Aborts with error if more IDs present.
//             Is called for ifdef/ifndef/defined(ID).
//
// returns :   TRUE if ID found in table. FALSE otherwise.

BOOL
handleDefines(
    char *t
    )
{
    char *s;

    s = _tcstok(t, " \t");
    if (_tcstok(NULL, " \t")) {
        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
    }

    if (!s) {
        makeError(line, MISSING_ARG_BEFORE_PAREN);
    }

    if (findMacro(s)) {
        return(TRUE);
    }

    return(FALSE);
}


// handleExists()
//
// arguments:  t   pointer to buffer that has the identifier
//
// actions:    Checks if 'name' is a valid file/directory
//             Aborts with error if more names present.
//             Is called for exist(name).
//
// returns :   TRUE if ID found in table. FALSE otherwise.

BOOL
handleExists(
    char *_t
    )
{
    char *s;
    char *szUnQuoted;
    BOOL fResult = FALSE;
    char *szDelim;
    char *t;

    // make local copy, strip blank space before and after string
    char *tSav = t = makeString(_t);
    while (*t && WHITESPACE (*t)) {
        t++;
    }
    s = t + _tcslen(t);
    while (s > t) {
        s = _tcsdec(t, s);
        if (WHITESPACE (*s)) {
            *s = '\0';
        }
        else {
            break;
        }
    }

    szDelim = ('\"' == *t) ? "\t" : " \t";
    // DS 15360: if id starts with a quote,
    // use "\t" instead of " \t" in _tcstok
    // (handle paths with embedded spaces)
    s = _tcstok(t, szDelim);
    if (_tcstok(NULL, szDelim)) {
        makeError(line, SYNTAX_UNEXPECTED_TOKEN, s);
    }

    if (NULL == s || NULL == (szUnQuoted = unQuote(s))) {   // handle quoted names
        makeError(line, MISSING_ARG_BEFORE_PAREN);
    }

    if (!_access(szUnQuoted, 0x00)) {                       // existence check
        fResult = TRUE;
    }

    FREE(szUnQuoted);
    FREE(tSav);

    return(fResult);
}


// evalExpr()
//
// arguments:    t    pointer to buffer that has the expression
//               kind specifies if it is if/ifdef/ifndef etc.
//
//
//
// returns :     TRUE if expression evaluates to true.
//               FALSE otherwise.

BOOL
evalExpr(
    char *t,
    UCHAR kind
    )
{
    if (!*t) {
        makeError(line, SYNTAX_MISSING_DIRECTIVE);
    }

    switch (kind) {
        case IFDEF_TYPE:
        case ELSE_IFDEF_TYPE:
            return(handleDefines(t));

        case IFNDEF_TYPE:
        case ELSE_IFNDEF_TYPE:
             return((BOOL)!handleDefines(t));

        default:
             text = t;
             return(handleExpr());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\rule.cpp ===
//  RULE.C -- routines that have to do with inference rules
//
// Copyright (c) 1988-1991, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  Routines that have to do with inference rules
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  10-May-1993 HV Add include file mbstring.h
//                 Change the str* functions to STR*
//  16-May-1991 SB Created using routines from other modules

#include "precomp.h"
#pragma hdrstop

#define PUBLIC

extern char * QueryFileInfo(char *, void **);

BOOL   removeDuplicateRules(RULELIST*, RULELIST*);
char * skipPathList(char*);

//  findRule -- finds the implicit rule which can be used to build a target
//
// Scope:   Global
//
// Purpose:
//  Given a target findRule() finds if an implicit rule exists to create this
//  target. It does this by scanning the extensions in the list of rules.
//
// Input:
//  name   -- the name of the file corresponding to the rule (see Notes)
//  target -- the target to be built
//  ext    -- the extension of the target
//  dBuf   -- a pointer to the file information about name
//
// Output:
//  Returns a pointer to the applicable rule (NULL if none is found)
//       On return dBuf points to the fileInfo of the file corresponding
//       to the applicable inference rule. (see Notes)
//
// Assumes:
//  It assumes that name points to a buffer of size MAXNAME of allocated memory
//  and dBuf points to an allocated memory area corr to the size of FILEINFO.
//
// Modifies Globals:
//  global  --  how/what
//
// Uses Globals:
//  rules -- the list of implicit rules
//
// Notes:
//  Once NMAKE finds a rule for the extension it looks for the file with the same
//  base name as the target and an extension which is part of the rule. This
//  file is the file corresponding to the rule. Only when this file exists does
//  NMAKE consider the inference rule to be applicable. This file is returned
//  in name and dBuf points to the information about this file.
//   It handles quotes in filenames too.

RULELIST *
findRule(
    char *name,
    char *target,
    char *ext,
    void *dBuf
    )
{
    RULELIST *r;                    // pointer to rule
    char *s,                        // name of rule
     *ptrToExt;                     // extension
    char *endPath, *ptrToTarg, *ptrToName, *temp;
    int n, m;
    MAKEOBJECT *object = NULL;

    for (r = rules; r; r = r->next) {
        s = r->name;
#ifdef DEBUG_ALL
        printf("* findRule: %s,\n", r->name);
        DumpList(r->buildCommands);
        DumpList(r->buildMacros);
#endif
        ptrToExt = _tcsrchr(s, '.');
        // Compare ignoring enclosing quotes
        if (!strcmpiquote(ptrToExt, ext)) {
            *name = '\0';
            for (ptrToTarg = (s+1); *ptrToTarg && *ptrToTarg != '{';ptrToTarg = _tcsinc(ptrToTarg))
                if (*ptrToTarg == ESCH)
                    ptrToTarg++;
                // If Quotes present skip to end-quote
                else if (*ptrToTarg == '"')
                    for (ptrToTarg++; *ptrToTarg != '"'; ptrToTarg++)
                        ;

            if (*ptrToTarg) {
                for (endPath = ptrToTarg; *endPath && *endPath != '}';endPath = _tcsinc(endPath))
                    if (*endPath == ESCH)
                        endPath++;
                n = (int) (endPath - (ptrToTarg + 1));

                // ignore leading quote on target
                temp = target;
                if (*temp == '"')
                    temp++;

                for (ptrToExt = ptrToTarg+1; n; n -= (int) _tclen(ptrToExt),
                    ptrToExt = _tcsinc(ptrToExt),
                    temp = _tcsinc(temp)) { // compare paths
                    if (*ptrToExt == '\\' || *ptrToExt == '/') {
                        if (*temp != '\\' && *temp != '/') {
                            n = -1;
                            break;
                        }
                    } else if (_tcsnicmp(ptrToExt, temp, _tclen(ptrToExt))) {
                        n = -1;
                        break;
                    }
                }

                if (n == -1)
                    continue;           // match failed; do next rule
                ptrToExt = ptrToTarg;
                n = (int) (endPath - (ptrToTarg + 1));

                char *pchLast = _tcsdec(ptrToTarg, endPath);

                ptrToName = target + n + 1;                 // if more path
                if (((temp = _tcschr(ptrToName, '\\'))      // left in target (we
                    || (temp = _tcschr(ptrToName, '/')))    // let separator in
                    && (temp != ptrToName                   // target path in rule,
                    || *pchLast == '\\'                     // e.g. .c.{\x}.obj
                    || *pchLast == '/'))                    // same as .c.{\x\}.obj)
                    continue;                               // use dependent's path,
            }                                               // not target's

            if (*s == '{') {
                for (endPath = ++s; *endPath && *endPath != '}'; endPath = _tcsinc (endPath))
                    if (*endPath == ESCH)
                        endPath++;
                n = (int) (endPath - s);

                if (n) {
                    _tcsncpy(name, s, n);
                    s += n + 1;                 // +1 to go past '}'
                    if (*(s-2) != '\\')
                        *(name+n++) = '\\';
                } else {
                    if (*target == '"')
                        _tcsncpy(name, "\".\\", n = 3);
                    else
                        _tcsncpy(name, ".\\", n = 2);
                    s += 1;
                }

                ptrToName = _tcsrchr(target, '\\');
                temp = _tcsrchr(target, '/');

                if (ptrToName = (temp > ptrToName) ? temp : ptrToName) {
                    _tcscpy(name+n, ptrToName+1);
                    n += (int) (ext - (ptrToName + 1));
                } else {
                    char *szTargNoQuote = *target == '"' ? target + 1 : target;
                    _tcscpy(name+n, szTargNoQuote);
                    n += (int) (ext - szTargNoQuote);
                }
            } else {
                char *t;

                //if rule has path for target then strip off path part
                if (*ptrToTarg) {

                    t = _tcsrchr(target, '.');

                    while (*t != ':' && *t != '\\' && *t != '/' && t > target)
                        t = _tcsdec(target, t);
                    if (*t == ':' || *t == '\\' || *t == '/')
                        t++;
                } else
                    t = target;
                n = (int) (ext - t);

                // preserve the opening quote on target if stripped off path part
                m = 0;
                if ((t != target) && (*target == '"')) {
                    *name = '"';
                    m = 1;
                }
                _tcsncpy(name + m, t, n);
                n += m;
            }

            m = (int) (ptrToExt - s);
            if (n + m > MAXNAME) {
                makeError(0, NAME_TOO_LONG);
            }

            _tcsncpy(name+n, s, m);    // need to be less
            // If quoted add a quote at the end too
            if (*name == '"' && *(name+n+m-1) != '"') {
                *(name+n+m) = '"';
                m++;
            }
            *(name+n+m) = '\0';         // cryptic w/ error

            // Call QueryFileInfo() instead of DosFindFirst() because we need
            // to circumvent the non-FAPI nature of DosFindFirst()

            if ((object = findTarget(name)) || QueryFileInfo(name, (void **)dBuf)) {
                if (object) {
                    putDateTime((_finddata_t*)dBuf, object->dateTime);
                }

                return(r);
            }
        }
    }

    return(NULL);
}


//  freeRules -- free inference rules
//
// Scope:   Global
//
// Purpose: This function clears the list of inference rules presented to it.
//
// Input:
//  r     -- The list of rules to be freed.
//  fWarn -- Warn if rules is not in .SUFFIXES
//
// Assumes:
//  That the list presented to it is a list of rules which are not needed anymore
//
// Uses Globals:
//  gFlags -- The global actions flag, to find if -p option is specified

void
freeRules(
    RULELIST *r,
    BOOL fWarn
    )
{
    RULELIST *q;

    while (q = r) {
        if (fWarn && ON(gFlags, F1_PRINT_INFORMATION))  // if -p option specified
            makeError(0, IGNORING_RULE, r->name);
        FREE(r->name);                  // free name of rule
        freeStringList(r->buildCommands);   // free command list
        freeStringList(r->buildMacros); // free command macros Note: free a Macro List
        r = r->next;
        FREE(q);                        // free rule
    }
}


BOOL
removeDuplicateRules(
    RULELIST *newRule,
    RULELIST *rules
    )
{
    RULELIST *r;
    STRINGLIST *p;

    for (r = rules; r; r = r->next) {
        if (!_tcsicmp(r->name, newRule->name)) {
            FREE(newRule->name);
            while (p = newRule->buildCommands) {
                newRule->buildCommands = p->next;
                FREE(p->text);
                FREE_STRINGLIST(p);
            }
            FREE(newRule);
            return(TRUE);
        }
    }
    return(FALSE);
}


//  skipPathList -- skip any path list in string
//
// Scope:   Local
//
// Purpose:
//  This function skips past any path list in an inference rule. A rule can have
//  optionally a path list enclosed in {} before the extensions. skipPathList()
//  checks if any path list is present and if found skips past it.
//
// Input:   s -- rule under consideration
//
// Output:  Returns pointer to the extension past the path list
//
// Assumes: That the inference rule is syntactically correct & its syntax
//
// Notes:   The syntax of a rule is -- {toPathList}.to{fromPathList}.from

char *
skipPathList(
    char *s
    )
{
    if (*s == '{') {
        while (*s != '}') {
            if (*s == ESCH)
                s++;
            s = _tcsinc(s);
        }
        s = _tcsinc(s);
    }
    return(s);
}


//  sortRules -- sorts the list of inference rules on .SUFFIXES order
//
// Scope:   Global
//
// Purpose:
//  This function sorts the inference rules list into an order depending on the
//  order in which the suffixes are listed in '.SUFFIXES'. The inference rules
//  which have their '.toext' part listed earlier in .SUFFIXES are reordered to
//  be earlier in the inference rules list. The inference rules for suffixes that
//  are not in .SUFFIXES are detected here and are ignored.
//
// Modifies Globals:
//  rules -- the list of rules which gets sorted
//
// Uses Globals:
//  dotSuffixList -- the list of valid suffixes for implicit inference rules.
//
// Notes:
//  The syntax of a rule is -- '{toPath}.toExt{fromPath}.fromExt'. This function
//  sorts the rule list into an order. Suffixes are (as of 1.10.016) checked in a
//  case insensitive manner.

PUBLIC void
sortRules(
    void
    )
{
    STRINGLIST *p,                      // suffix under consideration
               *s,
               *macros = NULL;
    RULELIST *oldRules,                 // inference rule list before sort
             *newRules,
             *r;                        // rule under consideration in oldRules
    char *suff, *toExt;
    size_t n;

    oldRules = rules;
    rules = NULL;
    for (p = dotSuffixList; p; p = p->next) {
        n = _tcslen(suff = p->text);
        for (r = oldRules; r;) {
            toExt = skipPathList(r->name);
            if (!_tcsnicmp(suff, toExt, n) &&
                (*(toExt+n) == '.' || *(toExt+n) == '{')
               ) {
                newRules = r;
                if (r->back)
                    r->back->next = r->next;
                else
                    oldRules = r->next;
                if (r->next)
                    r->next->back = r->back;
                r = r->next;
                newRules->next = NULL;
                if (!removeDuplicateRules(newRules, rules)) {
                    for (s = newRules->buildCommands; s; s = s->next) {
                        findMacroValuesInRule(newRules, s->text, &macros);
                    }
                    newRules->buildMacros = macros;
                    macros = NULL;
                    appendItem((STRINGLIST**)&rules, (STRINGLIST*)newRules);
                }
            } else
                r = r->next;
        }
    }
    // forget about rules whose suffixes not in .SUFFIXES
    if (oldRules)
        freeRules(oldRules, TRUE);
}


//  useRule -- applies inference rules for a target (if possible)
//
// Scope:   Local.
//
// Purpose:
//  When no explicit commands are available for a target NMAKE tries to use the
//  available inference rules. useRule() checks if an applicable inference rule
//  is present. If such a rule is found then it attempts a build using this rule
//  and if no applicable rule is present it conveys this to the caller.
//
// Input:
//  object     - object under consideration
//  name       - name of target
//  targetTime - time of target
//  qList      - QuestionList for target
//  sList      - StarStarList for target
//  status     - is dependent available
//  maxDepTime - maximum time of dependent
//  pFirstDep  - first dependent
//
// Output:
//  Returns ... applicable rule

RULELIST *
useRule(
    MAKEOBJECT *object,
    char *name,
    time_t targetTime,
    STRINGLIST **qList,
    STRINGLIST **sList,
    int *status,
    time_t *maxDepTime,
    char **pFirstDep
    )
{
    struct _finddata_t finddata;
    STRINGLIST *temp;
    RULELIST *r;
    time_t tempTime;
    char *t;


    if (!(t = _tcsrchr(object->name, '.')) ||
         (!(r = findRule(name, object->name, t, &finddata)))
       ) {
        return(NULL);                   // there is NO rule applicable
    }
    tempTime = getDateTime(&finddata);
    *pFirstDep = name;
    for (temp = *sList; temp; temp = temp->next) {
        if (!_tcsicmp(temp->text, name)) {
            break;
        }
    }

    if (temp) {
        CLEAR(object->flags2, F2_DISPLAY_FILE_DATES);
    }

    *status += invokeBuild(name, object->flags2, &tempTime, NULL);
   if (ON(object->flags2, F2_FORCE_BUILD) ||
        targetTime < tempTime ||
        (fRebuildOnTie && (targetTime == tempTime))
       ) {
        if (!temp) {
            temp = makeNewStrListElement();
            temp->text = makeString(name);
            appendItem(qList, temp);
            if (!*sList) {              // if this is the only dep found for
                *sList = *qList;        //  the target, $** list is updated
            }
        }

        if (ON(object->flags2, F2_DISPLAY_FILE_DATES) &&
            OFF(object->flags2, F2_FORCE_BUILD)
           ) {
            makeMessage(UPDATE_INFO, name, object->name);
        }
    }

    *maxDepTime = __max(*maxDepTime, tempTime);

    return(r);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\version.h ===
#define rmj             7
#define rmm             0
#define rup             8882
#define szVerName       ""
#define szVerUser       "BryanT2"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\verstamp.h ===
#include "version.h"				   /* SLM maintained version file */

#if defined(_WIN32) || defined(WIN32)
#include <winver.h>
#else	/* !WIN32 */
#include <ver.h>
#endif	/* !WIN32 */

#if 	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if 	(rup == 0)

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b

#else	/* !(rup == 0) */

#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b "." ruppad #c

#if 	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c) 		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR		VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION			rmj,rmm,0,rup

/*--------------------------------------------------------------*/
/* the following section defines values used in the version 	*/
/* data structure for all files, and which do not change.		*/
/*--------------------------------------------------------------*/

#if defined(_SHIP)
#define VER_DEBUG					0
#else
#define VER_DEBUG					VS_FF_DEBUG
#endif

#if defined(_SHIP)
#define VER_PRIVATEBUILD			0
#else
#define VER_PRIVATEBUILD			VS_FF_PRIVATEBUILD
#endif

#if defined(_SHIP)
#define VER_PRERELEASE				0
#else
#define VER_PRERELEASE				VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK			VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS					VOS__WINDOWS32
#else
#define VER_FILEOS					VOS_DOS_WINDOWS16
#endif
#define VER_FILEFLAGS				(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR 		"Microsoft Corporation"
#define VER_PRODUCTNAME_STR		"Microsoft (R) Developer Studio"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\win32.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "windows.h"

#ifdef _M_IX86

UCHAR
FIsChicago(void)
{
    DWORD dw;

    dw = GetVersion();

    // Test the "win32s" bit

    if ((dw & 0x80000000) == 0) {
        // If Win32s bit not set, it's Windows NT.

        return 0;
    }

    if (LOBYTE(dw) < 4) {
        // Win32s version 3 is really Win32s. There
        // won't ever be a real Win32s version 4.

        return 0;
    }

    // Yep.  It is really Chicago

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\utilp.cpp ===
//  UTILB.C -- Data structure manipulation functions specific to OS/2
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This file was created from functions in util.c & esetdrv.c which were system
//  dependent. This was done so that the build of the project became simpler and
//  there was a clear flow in the build process.
//
// Method of Creation:
//  1. Identified all functions having mixed mode code.
//  2. Deleted all code blocked out by '#ifndef BOUND' preprocessor directives
//     in these functions
//  3. Deleted all local function & their prototypes not referred by these
//  4. Deleted all global data unreferenced by these, including data blocked
//     of by '#ifdef DEBUG'
//
// Revision History:
//  21-Feb-1994 HV  Get rid of _alloca in findFirst: it confuses the compiler's
//                  backend scheduler (PhilLu).
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  15-Jun-1993 HV  No longer display warning about filenames being longer than
//                  8.3.  Decision made by EmerickF, see Ikura bug #86 for more
//                  details.
//  03-Jun-1993 HV  Fixed findFirst's pathname truncation (Ikura bug #86)
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Jun-1992 SS  Port to DOSX32
//  10-Apr-1990 SB  removed if _osmode stuff, not needed in protect only version.
//  04-Dec-1989 SB  removed unreferenced local variables in findFirst()
//  01-Dec-1989 SB  changed a remaining free() to FREE(); now FREE()'ing all
//                  allocated stuff from findFirst() on exit
//  22-Nov-1989 SB  Add #ifdef DEBUG_FIND to debug FIND_FIRST, etc.
//  13-Nov-1989 SB  Define INCL_NOPM to exclude <pm.h>
//  19-Oct-1989 SB  findFirst() and findNext() get extra parameter
//  08-Oct-1989 SB  remove quotes around a name before making system call
//  02-Oct-1989 SB  setdrive() proto change
//  04-Sep-1989 SB  Add DOSFINDCLOSE calls is findFirst and QueryFileInfo
//  05-Jul-1989 SB  add curTime() to get current time. (C Runtime function
//                  differs from DOS time and so time() is no good
//  05-Jun-1989 SB  call DosFindClose if DosFindNext returns an error
//  28-May-1989 SB  Add getCurDir() to initialize MAKEDIR macro
//  24-Apr-1989 SB  made FILEINFO a thing of the past. Replace by void *
//                  added OS/2 ver 1.2 support
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  09-Mar-1989 SB  Added function QueryFileInfo() because DosFindFirst has FAPI
//                  restrictions. ResultBuf was being allocated on the heap but
//                  not being freed. This saves about 36 bytes for every call to
//                  findAFile i.e. to findFirst(), findNext() or expandWildCards
//  09-Nov-1988 SB  Created

#include "precomp.h"
#pragma hdrstop

#include <io.h>
#include <direct.h>
#include <time.h>

STRINGLIST *
expandWildCards(
    char *s                             // text to expand
    )
{
    struct _finddata_t finddata;
    NMHANDLE searchHandle;
    STRINGLIST *xlist,                  // list of expanded names
               *p;
    char *namestr;

    if (!(namestr = findFirst(s, &finddata, &searchHandle))) {
        return(NULL);
    }

    xlist = makeNewStrListElement();
    xlist->text = prependPath(s, namestr);

    while (namestr = findNext(&finddata, searchHandle)) {
        p = makeNewStrListElement();
        p->text = prependPath(s, namestr);
        prependItem(&xlist, p);
    }

    return(xlist);
}


//  QueryFileInfo -- it does a DosFindFirst which circumvents FAPI restrictions
//
// Scope:   Global (used by Build.c also)
//
// Purpose:
//  DosFindFirst() has a FAPI restriction in Real mode. You cannot ask it give
//  you a handle to a DTA structure other than the default handle. This function
//  calls C Library Function _dos_findfirst in real mode (which sets the DTA) and
//  does the job. In protect mode it asks OS/2 for a new handle.
//
// Input:
//  file -- the file to be searched for
//  dta  -- the struct containing result of the search
//
// Output:  Returns a pointer to the filename found (if any)
//
// Assumes: That dta points to a structure which has been allocated enough memory
//
// Uses Globals:
//  _osmode --  to determine whether in Real or Bound mode

char *
QueryFileInfo(
    char *file,
    void **dta
    )
{
    NMHANDLE  hDir;
    char *t;

    // Remove Quotes around filename, if existing
    t = file + _tcslen(file) - 1;
    if (*file == '"' && *t == '"') {
        file = unQuote(file);           // file is quoted, so remove quote
    }

#if defined(DEBUG_FIND)
    printf("QueryFileInfo file: %s\n", file);
#endif

    if ((hDir = _findfirst(file, (struct _finddata_t *) dta)) == -1) {
        return(NULL);
    }

    _findclose(hDir);

    return(((struct _finddata_t *) dta)->name);
}


//
// Truncate filename to system limits
//
void
truncateFilename(
    char * s
    )
{
    char szDrive[_MAX_DRIVE];
    char szDir[_MAX_DIR];
    char szName[_MAX_FNAME];
    char szExtension[_MAX_EXT];

    // Ikura bug #86: pathname incorrectly truncated.  Solution: first parse it
    // using _splitpath(), then truncate the filename and extension part.
    // Finally reconstruct the pathname by calling _makepath().

    _splitpath(s, szDrive, szDir, szName, szExtension);
    _makepath(s, szDrive, szDir, szName, szExtension);
}


char *
findFirst(
    char *s,                            // text to expand
    void *dta,
    NMHANDLE *dirHandle
    )
{
    BOOL anyspecial;                   // flag set if s contains special characters.
    char buf[_MAX_PATH];               // buffer for removing ESCH

    // Check if name contains any special characters

    anyspecial = (_tcspbrk(s, "\"^*?") != NULL);

    if (anyspecial) {
        char *t;
        char *x;                       // Pointers for truncation, walking for ESCH

        t = s + _tcslen(s) - 1;

        // Copy pathname, skipping ESCHs and quotes
        x = buf;
        while( *s ) {
            if (*s == '^' || *s == '"') {
                s++;
            }
			else {
				if (_istlead(*(unsigned char *)s)) 
					*x++ = *s++;
            *x++ = *s++;
			}
        }

        *x = '\0';
        s = buf;                       // only elide ESCH the first time!
    }

    truncateFilename(s);

    if ((*dirHandle = _findfirst(s, (struct _finddata_t *) dta)) == -1) {
        // BUGBUG Use GetLastError to get details
        return(NULL);
    }

    // If it had no wildcard then close the search handle

    if (!anyspecial || (!_tcschr(s, '*') && !_tcschr(s, '?'))) {
        _findclose(*dirHandle);
    }

    return(((struct _finddata_t *) dta)->name);
}

char *
findNext(
    void *dta,
    NMHANDLE dirHandle
    )
{
    if (_findnext(dirHandle, (struct _finddata_t *) dta)) {
        _findclose(dirHandle);

        return(NULL);
    }

    return(((struct _finddata_t *) dta)->name);
}


char *
getCurDir(void)
{
	// Convert $ to $$ before returning current dir
	// [DS 14983]. This allows $(MAKEDIR) to work properly in 
	// case the current path contains a $ sign.
	//
    char *pszPath;
    char pbPath[_MAX_DIR+1];
	char *pchSrc = pbPath;
	char *pchDst;
	char ch;

	pszPath = (char *) rallocate(2 * _tcslen(_getcwd(pbPath, _MAX_DIR+1)) + 1);

	pchDst = pszPath;

	// non-MBCS aware implementation ('$' can't be a trailbyte)
	while (ch = *pchSrc) {
		*pchDst++ = *pchSrc++;
		if ('$' == ch)
			*pchDst++ = ch;
	}
	*pchDst = '\0';

    return(pszPath);
}


void
curTime(
    time_t *plTime
    )
{
    time(plTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\table.h ===
//  TABLE.H -- contains tables used by lexer and parser
//
//  Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This include file contains parser tables and lexer tables.
//
// Revision History:
//  04-Dec-1989 SB Add proper proto's for PFV fn's which actions[] refers to
//  08-Oct-1989 SB Modified nameStates[][] to handle OS/2 1.2 quoted names
//  31-Jul-1989 SB changed entries in nameStates to symbolic BKS (seen Bkslash)
//  20-May-1989 SB changed nameStates[][] to 16x14 to handle at end of the
//        dependency lines
//  13-Jun-1988 rj Modified stringStates to handle \nl as in xmake (v1.5)

// ALL VALUES USED IN THESE TABLES ARE DEFINED IN GRAMMAR.H
// WHEN PRODUCTIONS CHANGE, UPDATE THE FOLLOWING TABLE
//
// The first element in a production line is the number of symbols on
// the right-hand-side of the production arrow.  If the first element
// is 0, the nonterminal to the left of the arrow goes to the null string.
// Table entries beginning w/ "DO" are actions to be carried out at
// that particular point in the production.  All other entries are
// either tokens or non-terminals.

const UCHAR prod0[] = {0};              // MAKEFILE -> prod0 | prod1 | prod2
const UCHAR prod1[] = {2,
               BLANKLINES,
               MAKEFILE};
const UCHAR prod2[] = {5,
               NEWLINE,
               NAME,
               DONAME,
               BODY,
               MAKEFILE};
const UCHAR prod3[] = {5,               // BODY -> prod3 | prod4
               NAMELIST,
               SEPARATOR,
               DOLASTNAME,
               BUILDINFO,
               DOBUILDCMDS};
const UCHAR prod4[] = {3,
               EQUALS,
               VALUE,
               DOMACRO};
const UCHAR prod5[] = {0};              // NAMELIST ->  prod5 | prod6
const UCHAR prod6[] = {3,
               NAME,
               DONAMELIST,
               NAMELIST};
const UCHAR prod7[] = {0};              // COMMANDS -> prod7 | prod8 | prod9
const UCHAR prod8[] = {1,
               MOREBUILDLINES};
const UCHAR prod9[] = {4,
               SEMICOLON,
               STRING,
               DONAMELIST,
               MOREBUILDLINES};
const UCHAR prod10[] = {4,              // MOREBUILDLINES -> prod10 | prod 11
            NEWLINESPACE,               //        | prod12
            STRING,
            DONAMELIST,
            MOREBUILDLINES};
const UCHAR prod11[] = {0};
const UCHAR prod12[] = {2,
            NEWLINE,
            MOREBUILDLINES};

const UCHAR prod13[] = {0};             // BLANKLINES -> prod13 | prod14 |
const UCHAR prod14[] = {2,              //        | prod15
            NEWLINE,
            BLANKLINES};
const UCHAR prod15[] = {2,
            NEWLINESPACE,
            BLANKLINES};
const UCHAR prod16[] = {1,
            DODEPENDS};                 // BUILDINFO -> prod16 | prod17
const UCHAR prod17[] = {3,
            NAMELIST,
            DODEPENDS,
            COMMANDS};
const UCHAR prod18[] = {1, COLON};      // SEPARATOR -> prod18 | prod19
const UCHAR prod19[] = {1, DOUBLECOLON};

const UCHAR * const productions[] = {
    prod0,
    prod1,
    prod2,
    prod3,
    prod4,
    prod5,
    prod6,
    prod7,
    prod8,
    prod9,
    prod10,
    prod11,
    prod12,
    prod13,
    prod14,
    prod15,
    prod16,
    prod17,
    prod18,
    prod19
};


// When either of the high bit (AMBIG_MASK) of something that isn't an ERROR
// condition is set, it means that there are two productions that apply for
// that entry, the one given, and the one given plus one.  The next token
// token must be examined to know which production to use.


// name    newline      newline  semi   colon   double  equals  $
//                      white   colon           colon
//                      space
static const UCHAR table[8][8] = {
    {SEPRTR,1 |AMBIG_MASK,  1,      SYNTAX, NOTARG, NOTARG, MACRO,  0},
    {SYNTAX,13|AMBIG_MASK,  15,     SYNTAX, SYNTAX, SYNTAX, SYNTAX, 13},
    {PARSER,11|AMBIG_MASK,  10,     PARSER, SYNTAX, SYNTAX, SYNTAX, 11},
    {PARSER,7,          8,      9,      SYNTAX, SYNTAX, SYNTAX, 7},
    {3,     SEPEQU,     SEPEQU, SEPRTR, 3,      3,      4,      SEPEQU},
    {6,     5,          5,      5,      5,      5,      NAMES,  5},
    {17,    16,         17,     17,     SYNTAX, SYNTAX, SYNTAX, 16},
    {PARSER,SEPRTR,     SEPRTR, SEPRTR, 18,     19,     SYNTAX, SEPRTR}};


static const UCHAR useAlternate[3][8] = {
    {YES,   NO,         NO,     YES,    YES,    YES,    YES,    NO},
    {NO,    YES,        YES,    NO,     NO,     NO,     NO,     YES},
    {NO,    YES,        YES,    NO,     NO,     NO,     NO,     NO}};

void makeName(void);
void addItemToList(void);
void makeMacro(void);
void assignDependents(void);
void endNameList(void);
void assignBuildCommands(void);

static PFV const actions[] = {
    makeName,
    addItemToList,
    makeMacro,
    assignDependents,
    endNameList,
    assignBuildCommands};


// state tables for lexer's name and string recognizers
// values are defined in grammar.h
//
//   d
//   e
//   f                   m
//   a                   a c      B
//   u |   |    |   |   |   |   |   |   |   |c h|   | @ | F |
//   l | # | =  | \ | : |WS |NL | $ | ( | ) |r a| * | < | D |
//   t |   |    |   |   |   |EOF|   |   |   |o r|   | ? | R |

extern const UCHAR stringStates[13][14] = {
    { 1, 2,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 0 in col 0
    { 1, 1,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 1 default
    { 1, 1,  1,  3,  1,  2,  OK, 4,  1,  1,  1,  1,  1,  1},   // 2 whitespace
    { 1, 1,  1,  1,  1,  2,  0,  4,  1,  1,  1,  1,  1,  1},   // 3 line cont.
    {CHR,CHR,CHR,CHR,CHR,BAD,BAD,1,  5,  CHR,1,  1,  1,  1},   // 4 macro inv.
    {CHR,CHR,CHR,CHR,CHR,NAM,PAR,CHR,CHR,NAM,6,  11, 8,  6},   // 5 found (
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  6,  BAD,BAD,6},   // 6 legal name
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD,BAD,BAD,BAD}, // 7 ext sp mac
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD,BAD,BAD,7},   // 8 sp ch aft(
    {10, 10, SEQ,10, 10, 10, PAR,10, 10, SEQ,10, 10, 10, 10},  // 9 found a :
    {10, 10, 12, 10, 10, 10, PAR,10, 10, EQU,10, 10, 10, 10},  //10 macro subs
    {CHR,CHR,CHR,CHR,9,  PAR,PAR,CHR,CHR,2,  BAD, 8, BAD,7},   //11 found $(*
    {12, 12, 12, 12, 12, 12, PAR,12, 12, 2,  12, 12, 12, 12}}; //12 look for )


// In the above table, the columns hold the next state to go to
// for the given input symbol and the lines represent the states
// themselves.
//
// WS       stands for whitespace, meaning space or tab
// NL       stands for newline, EOF stands for end of file
// macrochar    is any alphanumeric character or underscore
// *        is used in the special macros $* and $** ($** is the only
//  two-letter macro that doesn't require parentheses, thus
//  we must treat it specially)
// @ < ?    are characters found in special macros (they are not
//  allowed in the names of a user-defined macros)
// BFDR are modifiers to special macros which may be appended
//  to the macro name (but they necessitate the use of
//  parentheses in the macro invocation)
// #        is the comment char.  # is a comment anywhere on a macro
//  definition line, but is only a comment if it appears in
//  column 0 of a build line.  If we're lexing the tools
//  initialization file, then semicolon is also a comment char
//  if it appears in column 0.  (Note that the only way
//  to have a pound sign appear in the makefile and NOT be
//  considered a comment is to define a macro "$A = #" on
//  the commandline that invokes nmake.)
// default  is anything not contained in the above groups and not
//  appearing above a column in the table
//
// OK       means that we accept the string
//  all other mnemonic values are error codes (see end of grammar.h)


//  the states: there is no state to handle comments -- if we see a
//      comment char and we're not ignoring comments, we eat
//      the comment and get another input symbol before consulting
//      the state table
//
//      0   initial state -- for all practical purposes, we can
//          assume that we're in column 0.  If we're getting a
//          macro value, we don't care what column we're in.
//          If we're getting a build line, the only way we won't
//          be in column 0 is if we're getting a command following
//          a semicolon on the target-dependency line.  If the
//          use puts a comment char here, I think it's reasonable
//          to treat it as a comment, since it comes at the beginning
//          of the build command, even though the command itself
//          doesn't start in column 0.
//          We return to the initial state after seeing space-
//          backslash-newline.
//
//      1   on any input symbol that isn't a backslash, comment char,
//          or whitespace, we move here whenever we're not in a
//          comment, or a macro definition
//
//      2   if the input symbol is whitespace, we move here whenever
//          we're not in a comment or a macro definition.
//
//      3   We move here from states 0, 1, or 2 when we've seen a
//          backslash, because if it's followed by a newline, we
//          continue getting the string from the next line of the file.
//          If the next character is a backslash, followed by a newline,
//          there's a kludge in lexer.c that ignores the second back-
//          slash.
//          (The above applies to v. 1.5.  v. 1.0 requires whitespace
//          before a backslash.)
//
//      4   we move here when we see a dollar sign -- this is where
//          all the error checking starts.  We make sure that the
//          macro name is legal, that the substitution sequences
//          are specified correctly (if any is specified at all),
//          and that parens match up.  If our next input is $, a
//          special-macro char, or a legal char in a user-defined-
//          macro name, we go back to state 1.
//
//      5   found an open paren
//
//      6   found a legal macrochar
//
//      7   go here for an extended special macro, and from here we
//          look for a close paren (out of order w/ 8)
//
//      8   we found a special-macro char after the open paren
//          If we find a special-macro modifier
//          after the special macro char following the open paren
//          then we go to 7
//
//      9   found a colon (meaning that the user is going to do
//          some substitution in the macro value)

//      10  any character that isn't newline, right paren, or EOF
//          brings us here,a nd we loop until we see an equals sign.
//          Newline, EOF, or right paren generate error messages.
//
//      11  we move here from state 5 if we see an asterisk, because
//          we have to check for a second asterisk.  A second *
//          takes us to state 8 (because a modifier may follow **).
//          If we find a modifier here (instead of a 2nd *), we go
//          to state 7.
//
//      12  found an equals sign, so we loop, picking up characters
//          for the replacement string, until we find a close paren.
//          Newline, EOF generate error messages.



// The following table is used to recognize names
// It differs from the previous one in that we don't have to deal
// w/ continuations or comments, and we don't allow special macros
// (other than the dynamic dependency macros) to be used as part
// of names.
//
// d
// e
// f                      m
// a                      a c
// u |   |   |   |   |   |   |   |   |   |c h|   |   |   |
// l | # | = | ; | : |WS |NL | $ | ( | ) |r a| { | } | \ | "
// t |   |   |   |   |   |EOF|   |   |   |o r|   |   |   |

extern const UCHAR nameStates[19][15] = {
 {1,  OK, OK, OK, 1,  OK, OK, 2,  1,  1,  1,  8,  1,  BKS,16}, // 0 initial state
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  BKS,QUO},// 1 do normal name
 {CHR,BAD,CHR,CHR,CHR,BAD,BAD,1,  3,  CHR,1,  CHR,CHR,CHR,CHR},// 2 handle macro
 {CHR,PAR,CHR,CHR,NAM,NAM,PAR,CHR,CHR,NAM,4,  CHR,CHR,CHR,CHR},// 3 do macro name
 {CHR,PAR,CHR,CHR,5,  PAR,PAR,CHR,CHR,1,  4,  CHR,CHR,CHR,CHR},// 4 do mac (name)
 {6,  6,  SEQ,6,  6,  6,  PAR,6,  6,  EQU,6,  6,  6,  6  ,6},  // 5 found : do sub
 {6,  6,  7,  6,  6,  6,  SEQ,6,  6,  SEQ,6,  6,  6,  6  ,6},  // 6 read until =
 {7,  7,  7,  7,  7,  7,  SEQ,7,  7,  1,  7,  7,  7,  7  ,7},  // 7 read until )
 {8,  OK, 8,  8,  8,  8,  OK, 9,  8,  8,  8,  8,  18,  8  ,8}, // 8 do path list
 {CHR,BAD,CHR,CHR,CHR,BAD,BAD,8,  10, CHR,8,  CHR,CHR,CHR,CHR},// 9 do macro in {}
 {CHR,PAR,CHR,CHR,NAM,10, PAR,CHR,CHR,NAM,11, CHR,CHR,CHR,CHR},//10 do macro name
 {CHR,PAR,CHR,CHR,12, PAR,PAR,CHR,CHR,8,  11, CHR,CHR,CHR,CHR},//11 do mac (name)
 {13, 13, SEQ,13, 13, 13, PAR,13, 13, EQU,13, 13, 13, 13 ,13}, //12 found : do sub
 {13, 13, 14, 13, 13, 13, SEQ,13, 13, SEQ,13, 13, 13, 13 ,13}, //13 read until =
 {14, 14, 14, 14, 14, 14, SEQ,14, 14, 8,  14, 14, 14, 14 ,14}, //14 read until )
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  1  ,1},  //15 \ found so ...
 {16, 16, 16, 16, 16, 16, NOQ,2,  16, 16, 16, 8,  16, BKS,17}, //16 quoted name
 {OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK, OK ,OK}, //17 quoted name
 {1,  OK, OK, OK, OK, OK, OK, 2,  1,  1,  1,  8,  1,  BKS,16}};//18 read after {}


// manis :-   changed state[8][7]'s value from 10 to 9
//    changed state[9][10]'s value from 1 to 8.....(25th jan 88)
//
// this is to allow macros inside path portions of rules, e.g.
// {$(abc)}.c{$(def)}.obj: .......
// or   foo : {$a;$(bcd);efg\hijk\}lmn.opq .......

// georgiop: added state 18 to handle quoted names following path lists
// e.g., {whatever}"foo" [DS #4296, 10/30/96]
//		We now enter state 18 as soon as a path list is read. (We used
//		to return to state 1 in that case and generate an error as
//		soon as the quotes were encountered)
//		Also changed state[8][5] from OK to 8 in order to allow paths
//		containing white space. [DS #14575]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nvram\nvram.h ===
#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <shellapi.h>

#include <stdio.h>

#define SIZECHARS(x)    (sizeof((x))/sizeof(WCHAR))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nmake\util.cpp ===
//  UTIL.C -- Data structure manipulation functions
//
// Copyright (c) 1988-1990, Microsoft Corporation.  All rights reserved.
//
// Purpose:
//  This module contains routines manipulating the Data Structures of NMAKE. The
//  routines are independent of the Mode of execution (Real/Bound).
//
// Revision History:
//  04-Feb-2000 BTF Ported to Win64
//  01-Feb-1994 HV  Turn off extra info display.
//  17-Jan-1994 HV  Fixed bug #3548: possible bug in findMacroValues because we
//                  are scanning 'string' byte-by-byte instead of char-by-char
//  15-Nov-1993 JdR Major speed improvements
//  15-Oct-1993 HV  Use tchar.h instead of mbstring.h directly, change STR*() to _ftcs*()
//  03-Jun-1993 HV  Add helper local function TruncateString for findFirst.
//  10-May-1993 HV  Add include file mbstring.h
//                  Change the str* functions to STR*
//  08-Apr-1993 HV  Rewrite prependPath() to use _splitpath() and _makepath()
//  31-Mar-1993 HV  Rewrite drive(), path(), filename(), and extension() to use
//                  _splitpath() instead of parsing the pathname by itself.
//  08-Jun-1992 SS  Port to DOSX32
//  27-May-1992 RG  Changed open_file to use _fsopen with _SH_DENYWR
//  29-May-1990 SB  ^$ was not becoming same as $$ for command lines ...
//  01-May-1990 SB  Nasty Preprocessor quirk bug in modifySpecialvalue() fixed
//  27-Feb-1990 SB  GP fault for '!if "$(debug"=="y"' fixed (bug t119)
//  08-Feb-1990 SB  GP fault for 'echo $(FOO:" =" ^) fixed
//  06-Feb-1990 SB  Handle $* etc in presence of Quoted names.
//  02-Feb-1990 SB  Add file_open() function
//  31-Jan-1990 SB  Debug changes; testAddr used to track problems at that addr
//  08-Dec-1989 SB  Changed SPRINTF() to avoid C6 warnings with -Oes
//  04-Dec-1989 SB  ZFormat() proto was misspelled as Zformat()
//  01-Dec-1989 SB  realloc_memory() added; allocate() uses _msize() now
//  22-Nov-1989 SB  Add strcmpiquote() and unQuote()
//  22-Nov-1989 SB  add #ifdef DEBUG_MEMORY funcs free_memory() and mem_status()
//  13-Nov-1989 SB  restoreEnv() function unreferenced
//  08-Oct-1989 SB  Added searchBucket(); find() now checks equivalence of quoted
//                  and unquoted versions of a target.
//  06-Sep-1989 SB  $* in in-line files was clobbering Global variable 'buf'
//  18-Aug-1989 SB  heapdump() gets two parameters
//  03-Jul-1989 SB  moved curTime() to utilb.c and utilr.c to handle DOSONLY ver
//  30-Jun-1989 SB  added curTime() to get current Time.
//  28-Jun-1989 SB  changed copyEnviron()
//  05-Jun-1989 SB  makeString("") instead of using "" in DGROUP for null macro
//  21-May-1989 SB  modified find() to understand that targets 'foo.c', '.\foo.c'
//                  and './foo.c' are the same.
//  13-May-1989 SB  Added functions path(), drive(), filename(), extension(),
//                  strbskip(), strbscan() instead of ZTOOLS library
//  12-May-1989 SB  Fixed bug in substitute strings
//  10-May-1989 SB  Added stuff for ESCH handling changes in Quotes;
//  01-May-1989 SB  changed return value of allocate().
//  14-Apr-1989 SB  restoreEnv() created for macroBackInheritance
//  05-Apr-1989 SB  made all funcs NEAR; Reqd to make all function calls NEAR
//  17-Mar-1989 SB  substituteStrings() now has 3 new error checks & avoids GPs
//  13-Mar-1989 SB  ZFormat() was missing the legal case of '%%'
//  22-Feb-1989 SB  ZFormat() has buffer overflow check with extra parameter
//                  and SPRINTF() gives a new error
//  15-Feb-1989 SB  Changed modifySpecialValue(), was not performing correctly
//                  for $(@D) and $(@B) for some cases.
//  13-Feb-1989 SB  Made Prototypes for ZTools Library functions as extern
//   5-Dec-1988 SB  Made SPRINTF() cdecl as NMAKE now uses Pascal calling
//  25-Nov-1988 SB  Added SPRINTF() and ZFormat() and also added prototypes for
//                  functions used from ZTools Library (6 of them)
//  10-Nov-1988 SB  Removed mixed mode functions (bound & real) to utilr.c
//                  & utilb.c; corr globals/debug data also moved
//  10-Oct-1988 SB  Add Comments for hash().
//  18-Sep-1988 RB  Fix bad flag checking for targets in find().
//  15-Sep-1988 RB  Move some def's out to GLOBALS.
//  22-Aug-1988 RB  Don't find undefined macros.
//  17-Aug-1988 RB  Clean up.  Clear memory in allocate().
//   8-Jul-1988 rj  Minor speedup (?) to find().
//   7-Jul-1988 rj  Modified find and hash; less efficient, but case-indep.
//   1-Jul-1988 rj  Fixed line truncation after null special macro.
//  30-Jun-1988 rj  Fixed bug with checkDynamicDependency not handling $$.
//  29-Jun-1988 rj  Fixed bug with extra * after expanding $**.
//                  Fixed abysmal with $$(@?).
//                  Fixed handling of F, B, R modifiers.
//  22-Jun-1988 rj  Added friendly filename truncation (findFirst).
//  22-Jun-1988 rj  Fixed bug #3 (.abc.def.ghi not detected).
//  16-Jun-1988 rj  Modified several routines to look for escape
//                  character when walking through strings.
//  27-May-1988 rb  Fixed space-appending on list-expansion macros.
//                  Don't include trailing path separator in $(@D).

#include "precomp.h"
#pragma hdrstop

// Prototypes of functions local to this module

void   putValue(char**, char**, char**, char**, char*, unsigned*, char *);
void   substituteStrings(char**, char**, char**, char**, char*,
                    unsigned*, char *);
char * isolateMacroName(char*, char*);
char * checkDynamicDependency(char*);
void   increaseBuffer(char**, char**, char**, unsigned*, char *);
void   putSpecial(char**, char**, char**, char**, unsigned*,
                 unsigned, char *);
      char * modifySpecialValue(char, char*, char*);
STRINGLIST * searchBucket(char *, STRINGLIST **, unsigned);
int envVars(char **environ);

// Prototypes of functions used by ZFormat from ZTools Library

      char * strbscan(char *, char *);
char * strbskip(char *, char *);
int    drive(const char *, char *);
int    path(const char *, char *);
int    filenamepart(const char *, char *);
int    extension(const char *, char *);

const char special1[] = "*@<?";
const char special2[] = "DFBR";

// These two variables are needed in order to provide
// more informative error messages in case findMacroValue
// detects an illegal macro in the command block of
// a batch mode rule.
static BOOL fFindingMacroInBatchRule = FALSE;
static char * szBatchRuleName;                // current rule name

#if !defined(NDEBUG)
size_t TotalAlloc;
unsigned long CntAlloc;

void
printStats(
    void
    )
{
#if defined(STATISTICS)
    fprintf(stderr,"\n   Memory Allocation:\n"
                     "       total allocation:\t%12.lu\n"
                     "       individual allocations:\t%12.lu\n"
                     "   Macros:\n"
                     "       searches:\t\t%12.lu\n"
                     "       chain walks:\t\t%12.lu\n"
                     "       insertions:\t\t%12.lu\n"
                   "\n   Targets:\n"
                     "       searches:\t\t%12.lu\n"
                     "       chain walks:\t\t%12.lu\n"
                   "\n   Others:\n"
                     "       stricmp compares:\t%12.lu\n"
                     "       String List frees:\t%12.lu\n"
                     "       String List allocs:\t%12.lu\n",
                    TotalAlloc,
                    CntAlloc,
                    CntfindMacro,
                    CntmacroChains,
                    CntinsertMacro,
                    CntfindTarget,
                    CnttargetChains,
                    CntStriCmp,
                    CntFreeStrList,
                    CntAllocStrList);
#endif
}
#endif
#define ALLOCBLKSIZE 32768
unsigned long AllocFreeCnt;
char * PtrAlloc;
STRINGLIST *PtrFreeStrList;


// rallocate - allocate raw memory (not cleared)
//
// Tries to allocate a chunk of memory, prints error message and exits if
// the requested amount is not available.

void *
rallocate(
    size_t size
    )
{
    void *chunk = malloc(size);

    if (chunk == NULL) {
        makeError(currentLine, OUT_OF_MEMORY);
    }

#if !defined(NDEBUG)
    TotalAlloc += size;
    CntAlloc++;
#endif

    return(chunk);
}


// allocate - allocate memory and clear it
//
// Tries to allocate a chunk of memory, prints error message and exits if
// the requested amount is not available.
// IMPORTANT: we must clear the memory here. Code elsewhere relies on this.

void *
allocate(
    size_t size                        // Number of bytes requested
    )
{
    void *chunk = rallocate(size);

    memset(chunk, 0, size);

    return(chunk);
}


void *
alloc_stringlist(
    void
    )
{
    STRINGLIST *chunk;

#if defined(STATISTICS)
    CntAllocStrList++;
#endif

    if (PtrFreeStrList != NULL) {
        chunk = PtrFreeStrList;
        PtrFreeStrList = chunk->next;
    } else {
        if (AllocFreeCnt < sizeof(STRINGLIST)) {
            PtrAlloc = (char *) rallocate(ALLOCBLKSIZE);
            AllocFreeCnt = ALLOCBLKSIZE;
        }

        chunk = (STRINGLIST *) PtrAlloc;

        PtrAlloc += sizeof(STRINGLIST);
        AllocFreeCnt -= sizeof(STRINGLIST);
    }

    chunk->next = NULL;
    chunk->text = NULL;

    return (void *)chunk;
}


void
free_stringlist(
    STRINGLIST *pMem
    )
{
#if !defined(NDEBUG)
    STRINGLIST *tmp;

    for (tmp = PtrFreeStrList; tmp != NULL; tmp = tmp->next) {
        if (tmp == pMem) {
            fprintf(stderr, "free same pointer twice: %p\n", pMem);
            return;
        }
    }

    pMem->text = NULL;
#endif

    pMem->next = PtrFreeStrList;
    PtrFreeStrList = pMem;

#if defined(STATISTICS)
    CntFreeStrList++;
#endif
}


// allocate space, copies the given string into the newly allocated space, and
// returns ptr.
char *
makeString(
    const char *s
    )
{
    char *t;
    size_t l = _tcslen(s) + 1;
    t = (char *) rallocate(l);
    memcpy(t, s, l);
    return(t);
}

// like makeString, but creates quoted string
char *
makeQuotedString(
    const char *s
    )
{
    char *t;
    size_t l = _tcslen(s);
    t = (char *) rallocate(l + 3);
    t[0] = '"';
    memcpy(t+1, s, l);
    t[l+1] = '"';
    t[l+2] = '\0';
    return(t);
}

// reallocate String sz1 and append sz2
char *
reallocString(
    char * szTarget,
    const char * szAppend
    )
{
    char *szNew;
    size_t cbNew = _tcslen(szTarget) + _tcslen(szAppend) + 1;
    szNew = (char *) REALLOC(szTarget, cbNew);
    if (!szNew)
        makeError(0, OUT_OF_MEMORY);
    return  _tcscat(szNew, szAppend);
}


// makes element the head of list
void
prependItem(
    STRINGLIST **list,
    STRINGLIST *element
    )
{
    element->next = *list;
    *list = element;
}


// makes element the tail of list
void
appendItem(
    STRINGLIST **list,
    STRINGLIST *element
    )
{
    for (; *list; list = &(*list)->next)
        ;
    *list = element;
}



// hash - returns hash value corresponding to a string
//
// Purpose:
//  This is a hash function. The hash function uses the following Algorithm --
//   Add the characters making up the string (s) to get N (ASCII values)
//      N mod total         ,gives the hash value,
//       where,  total is   MAXMACRO       for macros
//                  MAXTARGET        targets
//  Additionally, for targets it takes Uppercase Values alone, since, targets
//  are generally filenames and DOS/OS2 filenames are case independent.
//
// Input:
//  s           = name for which a hash is required
//  total      = Constant used in the hash function
//  targetFlag = boolean flag; true for targets, false for macros
//
// Output:
//  Returns hash value between 0 and (total-1)

unsigned
hash(
    char *s,
    unsigned total,
    BOOL targetFlag
    )
{
    unsigned n;
    unsigned c;

    if (targetFlag) {
        for (n = 0; c = *s; (n += c), s++)
            if (c == '/') {
                c = '\\';               // slash == backslash in targets
            } else {
                c = _totupper(c);       // lower-case == upper-case in targets
            }
    } else {
        for (n = 0; *s; n += *s++)
            ;
    }

    return(n % total);
}


// find - look up a string in a hash table
//
// Look up a macro or target name in a hash table and return the entry
// or NULL.
// If a macro and undefined, return NULL.
// Targets get matched in a special way because of filename equivalence.

STRINGLIST *
find(
    char *str,
    unsigned limit,
    STRINGLIST *table[],
    BOOL targetFlag
    )
{
    unsigned n;
    char *string = str;
    char *quote;
    STRINGLIST *found;
    BOOL fAllocStr = FALSE;

    if (*string) {
        n = hash(string, limit, targetFlag);

        if (targetFlag) {
#if defined(STATISTICS)
            CntfindTarget++;
#endif

            found = searchBucket(string, table, n);

            if (found) {
                return(found);
            }

            //Look for .\string
            if (!_tcsncmp(string, ".\\", 2) || !_tcsncmp(string, "./", 2)) {
                string += 2;
            } else {
                string = (char *)rallocate(2 + _tcslen(str) + 1);
                _tcscat(_tcscpy(string, ".\\"), str);
                fAllocStr = (BOOL)TRUE;
            }

            n = hash(string, limit, targetFlag);
            found = searchBucket(string, table, n);

            if (found) {
                if (fAllocStr) {
                    FREE(string);
                }

                return(found);
            }

            // Look for ./string
            if (string != (str + 2)) {
                string[1] = '/';
            }

            n = hash(string, limit, targetFlag);
            found = searchBucket(string, table, n);

            if (fAllocStr) {
                FREE(string);
            }

            if (found) {
                return(found);
            }

            //Look for "foo" or foo
            if (*str == '"') {
                quote = unQuote(str);
            } else {
                size_t len = _tcslen(str) + 2;
                quote = (char *) allocate(len + 1);
                _tcscat(_tcscat(_tcscpy(quote, "\""), str), "\"");
            }

            n = hash(quote, limit, targetFlag);
            found = searchBucket(quote, table, n);

            FREE(quote);

            return found;
        }

        for (found = table[n]; found; found = found->next) {
            if (!_tcscmp(found->text, string)) {
                return((((MACRODEF *)found)->flags & M_UNDEFINED) ? NULL : found);
            }
        }

    }

    return(NULL);
}


// FINDMACROVALUES --
// looks up a macro's value in hash table, prepends to list a STRINGLIST
// element holding pointer to macro's text, then recurses on any macro
// invocations in the value
//
// The lexer checks for overrun in names (they must be < 128 chars).
// If a longer, undefined macro is only referred to in the value of
// another macro which is never invoked, the error will not be flagged.
// I think this is reasonable behavior.
//
// MACRO NAMES CAN ONLY CONSIST OF ALPHANUMERIC CHARS AND UNDERSCORE
//
// we pass a null list pointer-pointer if we just want to check for cyclical
// definitions w/o building the list.
//
// the name parameter is what's on the left side of an = when we're just
// checking cyclical definitions.   When we "find" the macros in a target
// block, we have to pass the name of the macro whose text we're recursing
// on in our recursive call to findMacroValues().
//
// Might want to check into how to do this w/o recursion (is it possible?)
//
// This function is RECURSIVE.

// Added a fix to make this function handle expand macros which refer
// to other recursive macros.
//
// levelSeen is the recLevel at which a macroname was first seen so that
// the appropriate expansion can be calculated (even when recursing ...)

BOOL
findMacroValues(
    char *string,                       // string to check
    STRINGLIST **list,                  // list to build
    STRINGLIST **newtail,               // tail of list to update
    char *name,                         // name = string
    unsigned recLevel,                  // recursion level
    unsigned levelSeen,
    UCHAR flags
    )
{
    char macroName[MAXNAME];
    char *s;
    MACRODEF *p;
    STRINGLIST *q, *r, dummy, *tail;
    unsigned i;
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks

    if (list) {
        if (newtail) {
            tail = *newtail;
        } else {
            tail = *list;
            if (tail) {
                while (tail->next) {
                    tail = tail->next;
                }
            }
        }
    } else {
        tail = NULL;
    }

    for (s = string; *s; ++s) {         // walk the string
        for (; *s && *s != '$'; s = _tcsinc(s)) {  // find next macro
            if (*s == '\"')
                inQuotes = (BOOL) !inQuotes;
            if (!inQuotes && *s == ESCH) {
                ++s;                    // skip past ESCH
                if (*s == '\"')
                    inQuotes = (BOOL) !inQuotes;
            }
        }
        if (!*s)
            break;                      // move past '$'
        if (!s[1])
            if (ON(flags, M_ENVIRONMENT_DEF)) {
                if (newtail)
                    *newtail = tail;
                return(FALSE);
            } else
                makeError(currentLine, SYNTAX_ONE_DOLLAR);
        s = _tcsinc(s);
        if (!inQuotes && *s == ESCH) {
            s = _tcsinc(s);
            if (!MACRO_CHAR(*s))
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail)
                        *newtail = tail;
                    return(FALSE);
                } else
                    makeError(currentLine, SYNTAX_BAD_CHAR, *s);
        }
        if (*s == '$') {                            // $$ = dynamic
            s = checkDynamicDependency(s);          //    dependency
            continue;                               //    or just $$->$
        } else if (*s == '(') {                     // name is longer
            s = isolateMacroName(s+1, macroName);   //    than 1 char
            if (_tcschr(special1, *macroName)) {
                if (fFindingMacroInBatchRule && OFF(gFlags, F1_NO_BATCH)) {
                    // we only allow $< in batch rules
                    // so this is an error
                    char * szBadMacro = (char *) _alloca(_tcslen(macroName) + 4);
                    sprintf(szBadMacro, "$(%s)", macroName);
                    makeError(0, BAD_BATCH_MACRO, szBadMacro, szBatchRuleName);
                }
                else
                    continue;
            }
        } else {
            if (_tcschr(special1, *s)){
                if (fFindingMacroInBatchRule && OFF(gFlags, F1_NO_BATCH) && *s != '<') {
                    char szBadMacro[3];
                    szBadMacro[0] = '$';
                    szBadMacro[1] = *s;
                    szBadMacro[2] = '\0';
                    // we only allow $< in batch rules
                    // so this is an error
                    makeError(0, BAD_BATCH_MACRO, szBadMacro, szBatchRuleName);
                }
                else
                    continue;                       // 1-letter macro
            }

            if (!MACRO_CHAR(*s))
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail) *newtail = tail;
                        return(FALSE);
                } else
                    makeError(currentLine, SYNTAX_ONE_DOLLAR);
            macroName[0] = *s;
            macroName[1] = '\0';
        }
        // If list isn't NULL, allocate storage for a new node.  Otherwise
        // this function was called purely to verify the macro name was
        // valid and we can just use the dummy node as a place holder.
        //
        // 2/28/92  BryanT    dummy.text wasn't being initialized each
        //              time.  As a result, if we were to recurse
        //              this function, whatever value was in text
        //              on the last iteration is still there.
        //              In the case where the macroName doesn't exist
        //              in the the call to findMacro(), and the old
        //              dummy->text field contained a '$', the
        //              function would recurse infinitely.
        //              Set to an empty string now
        //
        // q = (list) ? makeNewStrListElement() : &dummy;

        if (list != NULL) {
            q = makeNewStrListElement();
        } else {
            dummy.next = NULL;
            dummy.text = makeString(" ");
            q = &dummy;
        }

        if (p = findMacro(macroName)) {
            // macro names are case sensitive
            if (name && !_tcscmp(name, macroName)) {       // self-refer-
                r = p->values;                              // ential macro
                for (i = recLevel; i != levelSeen && r; --i)
                    r = r->next;                            // (a = $a;b)
                q->text = (r) ? r->text : makeString("");
            }
            else if (ON(p->flags, M_EXPANDING_THIS_ONE)) {  // recursive def
                if (ON(flags, M_ENVIRONMENT_DEF)) {
                    if (newtail) *newtail = tail;
                        return(FALSE);
                } else
                    makeError(currentLine, CYCLE_IN_MACRODEF, macroName);
            }
            else if (ON(p->flags, M_UNDEFINED)) {
                q->text = makeString("");       // if macro undefd [DS 18040]
            }
            else
                q->text = p->values->text;
        }

        if (list) {                             // if blding list
            if (!p || ON(p->flags, M_UNDEFINED))
                q->text = makeString("");       // if macro undefd
            q->next = NULL;                     // use NULL as its value
            if (tail) {
                tail->next = q;
            }else {
                *list = q;
            }
            tail = q;
        }                                       // if found text,

        if (!p || !_tcschr(q->text, '$'))
            continue;                           // and found $ in
        SET(p->flags, M_EXPANDING_THIS_ONE);    // text, recurse
        findMacroValues(q->text,
                        list,
                        &tail,
                        macroName,
                        recLevel+1,
                        (name && _tcscmp(name, macroName)? recLevel : levelSeen),
                        flags);
        CLEAR(p->flags, M_EXPANDING_THIS_ONE);
    }
    if (newtail) *newtail = tail;
        return(TRUE);
}

//
// findMacroValuesInRule --
// This is a wrapper around findMacroValues that generates an
// error if an illegal special macro is referenced (directly
// or indirectly) by the command block of a batch-mode rule
//
BOOL
findMacroValuesInRule(
    RULELIST *pRule,                    // pointer to current rule
    char *string,                       // string to check
    STRINGLIST **list                   // list to build
    )
{
    BOOL retval;
    if (fFindingMacroInBatchRule = pRule->fBatch)
        szBatchRuleName = pRule->name;
    retval = findMacroValues(string, list, NULL, NULL, 0, 0, 0);
    fFindingMacroInBatchRule = FALSE;
    return retval;
}

// isolateMacroName -- returns pointer to name of macro in extended invocation
//
// arguments:   s       pointer to macro invocation
//              macro   pointer to location to store macro's name
//
// returns:    pointer to end of macro's name
//
// isolates name and moves s

char *
isolateMacroName(
    char *s,                            // past closing paren
    char *macro                         // lexer already ckd for bad syntax
    )
{
    char *t;

    for (t = macro; *s && *s != ')' && *s != ':'; t=_tcsinc(t), s=_tcsinc(s)) {
        if (*s == ESCH) {
            s++;
            if (!MACRO_CHAR(*s))
                makeError(currentLine, SYNTAX_BAD_CHAR, *s);
        }
        _tccpy(t, s);
    }
    while (*s != ')') {
        if (*s == ESCH)
            s++;
        if (!*s)
            break;
        s++;
    }
    if (*s != ')')
        makeError(currentLine, SYNTAX_NO_PAREN);

    *t = '\0';
    if (t - macro > MAXNAME)
        makeError(currentLine, NAME_TOO_LONG);
    return(s);
}


// figures out length of the special macro in question, and returns a ptr to
// the char after the last char in the invocation

char *
checkDynamicDependency(
    char *s
    )
{
    char *t;

    t = s + 1;
    if (*t == ESCH)
        return(t);                      // If $^, leave us at the ^
    if (*t == '(') {
        if (*++t == ESCH) {
            return(t);
        } else {
            if (*t == '@') {
                if (*++t == ESCH)
                    makeError(currentLine, SYNTAX_BAD_CHAR, *++t);
                else if (*t == ')')
                    return(t);
                else if (_tcschr(special2, *t)) {
                    if (*++t == ESCH)
                        makeError(currentLine, SYNTAX_BAD_CHAR, *++t);
                    else if (*t == ')')
                        return(t);
                }
            } else {
                t = s + 1;              // invalid spec. mac.
                if (*t == ESCH)
                    return(t);          // evals. to $(
                return(++t);
            }
        }
    }
    return(s);                          // char matched
}


// removes and expands any macros that exist in the string macroStr.
// could return a different string (in case expandMacros needs more
// buffer size for macro expansion. it is the caller's responsibility
// to free the string soon as it is not required....

char *
removeMacros(
    char *macroStr
    )
{
    STRINGLIST *eMacros = NULL;
    STRINGLIST *m;

    if (_tcschr(macroStr, '$')) {
        findMacroValues(macroStr, &eMacros, NULL, NULL, 0, 0, 0);
        m = eMacros;
        macroStr = expandMacros(macroStr, &eMacros);
        while (eMacros = m) {
            m = m->next;
            FREE_STRINGLIST(eMacros);
        }
    }
    return(macroStr);
}


// expandMacros -- expand all macros in a string s
//
// arguments:  s       string to expand
//             macros  list of macros being expanded (for recursive calls)
//
// actions:    allocate room for expanded string
//             look for macros in string (handling ESCH properly (v1.5))
//             parse macro--determine its type
//             use putSpecial to handle special macros
//             recurse on list of macros
//             use putValue to put value of just-found macro in string
//             return expanded string
//
// returns:    string with all macros expanded
//
// CALLER CHECKS TO SEE IF _tcschr(STRING, '$') IN ORER TO CALL THIS.
// this doesn't work for HUGE macros yet.  need to make data far.
//
// we save the original string and the list of ptrs to macro values
// to be substituted.
// the caller has to free the expansion buffer
//
// expandMacros updates the macros pointer and frees the skipped elements

char *
expandMacros(
    char *s,                            // text to expand
    STRINGLIST **macros
    )
{
    STRINGLIST *p;
    char *t, *end;
    char *text, *xresult;
    BOOL inQuotes = (BOOL) FALSE;       // flag when inside quote marks
    char *w;
    BOOL freeFlag = FALSE;
    char resultbuffer[MAXBUF];
    unsigned len = MAXBUF;
    char *result = resultbuffer;

    end = result + MAXBUF;
    for (t = result; *s;) {                         // look for macros
        for (; *s && *s != '$'; *t++ = *s++) {      // as we copy the string
            if (t == end) {
                increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
            }
            if (*s == '\"')
                inQuotes = (BOOL) !inQuotes;
            if (!inQuotes && *s == ESCH) {
                *t++ = ESCH;
                if (t == end) {
                    increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
                }
                s++;
                if (*s == '\"')
                    inQuotes = (BOOL) !inQuotes;
            }
        }
        if (t == end) {                             //  string
            increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
        }
        if (!*s)
            break;                                  // s exhausted
        w = (s+1);   // don't check for ^ here; already did in findMacroValues
        if (*w == '('                               // found a macro
            && _tcschr(special1, *(w+1))) {
            putSpecial(&result, &s, &t, &end, &len, X_SPECIAL_MACRO, &resultbuffer[0]);
            continue;
        } else
        if (*w++ == '$') {                          // double ($$)
            if (*w == ESCH)                         // $$^...
                putSpecial(&result, &s, &t, &end, &len, DOLLAR_MACRO, &resultbuffer[0]);
            else if (*w == '@')                     // $$@
                putSpecial(&result, &s, &t, &end, &len, DYNAMIC_MACRO, &resultbuffer[0]);
            else if ((*w == '(') && (*++w == '@') && (*w == ')'))
                putSpecial(&result, &s, &t, &end, &len, DYNAMIC_MACRO, &resultbuffer[0]);
            else if (((*++w=='F') || (*w=='D') || (*w=='B') || (*w=='R')) && (*++w == ')'))
                putSpecial(&result, &s, &t, &end, &len, X_DYNAMIC_MACRO, &resultbuffer[0]);
            else                                    // $$
                putSpecial(&result, &s, &t, &end, &len, DOLLAR_MACRO, &resultbuffer[0]);
            continue;
        } else
        if (_tcschr(special1, s[1])) {             // $?*<
            putSpecial(&result, &s, &t, &end, &len, SPECIAL_MACRO, &resultbuffer[0]);
            continue;
        }
        if (!*macros)
            makeError(currentLine, MACRO_INTERNAL);

        // skip this element in the macros list

        if (_tcschr((*macros)->text, '$')) {       // recurse
            p = *macros;
            *macros = (*macros)->next;
            text = expandMacros(p->text, macros);
            freeFlag = TRUE;
        } else {
            text = (*macros)->text;
            *macros = (*macros)->next;
        }
        putValue(&result, &s, &t, &end, text, &len, &resultbuffer[0]);
        if (freeFlag) {
            FREE(text);
            freeFlag = FALSE;
        }
    }

    if (t == end) {
        increaseBuffer(&result, &t, &end, &len, &resultbuffer[0]);
    }
    *t++ = '\0';

    // Allocate result buffer
    if (!(xresult = (char *) rallocate((size_t) (t - result)))) {
        makeError(currentLine, MACRO_TOO_LONG);
    }
    memcpy(xresult, result, (size_t) (t - result));
    return(xresult);
}


// increaseBuffer -- increase the size of a string buffer, with error check
//
// arguments:   result  pointer to pointer to start of buffer
//              t       pointer to pointer to end of buffer (before expansion)
//              end     pointer to pointer to end of buffer (after expansion)
//              len     pointer to amount by which to expand buffer
//              first   address of initial stack buffer
//
// actions:    check for out of memory
//        allocate new buffer
//        reset pointers properly
//
// modifies:    t, end to point to previous end and new end of buffer
//
// uses 0 as line number because by the time we hit an error in this routine,
// the line number will be set at the last line of the makefile (because we'll
// have already read and parsed the file)

void
increaseBuffer(
    char **result,
    char **t,
    char **end,
    unsigned *len,
    char *first
    )
{
    unsigned newSize;

    // determine if result points to the firstbuffer and make a dynamic copy first.

    if (*result == first) {
        char *p = (char *) rallocate(*len);
        memcpy(p, *result, *len);
        *result = p;
    }
    newSize = *len + MAXBUF;
#ifdef DEBUG
    if (fDebug) {
        fprintf(stderr,"\t\tAttempting to reallocate %d bytes to %d\n", *len, newSize);
    }
#endif
    if (!(*result =(char *)  REALLOC(*result, newSize))) {
        makeError(currentLine, MACRO_TOO_LONG);
    }
    *t = *result + *len;                // reset pointers, len
    *len = newSize;
    *end = *result + *len;
}


// putSpecial -- expand value of special macro
//
// arguments:  result  ppointer to start of string being expanded
//             name    ppointer to macro name being expanded
//             dest    ppointer to place to store expanded value
//             end     ppointer to end of dest's buffer
//             length  pointer to amount by which to increase dest's buffer
//             which   ype of special macro
//             first   address of initial stack buffer
//
// actions:    depending on type of macro, set "value" equal to macro's value
//             if macro expands to a list, store whole list in "value" ($?, $*)
//             otherwise, modify value according to F, B, D, R flag
//             use putValue to insert the value in dest
//
// has to detect error if user tries $* etc. when they aren't defined
// fix to handle string substitutions, whitespace around names, etc
// right now list macros are limited to 1024 bytes total

void
putSpecial(
    char **result,
    char **name,
    char **dest,
    char **end,
    unsigned *length,
    unsigned which,
    char *first
    )
{
    char *value = 0;
    STRINGLIST *p;
    BOOL listMacro = FALSE, modifier = FALSE, star = FALSE;
    unsigned i = 1;
    char c, nameBuf[MAXNAME], *temp;

    switch (which) {
        case X_SPECIAL_MACRO:
            i = 2;
            modifier = TRUE;

        case SPECIAL_MACRO:
            switch ((*name)[i]) {
                case '<':
                    value = dollarLessThan;
                    break;

                    case '@':
                        value = dollarAt;
                        break;

                    case '?':
                        value = (char*) dollarQuestion;
                        listMacro = TRUE;
                        break;

                    case '*':
                        if ((*name)[i+1] != '*') {
                            value = dollarStar;
                            star = TRUE;
                            break;
                        }
                        value = (char*) dollarStarStar;
                        listMacro = TRUE;
                        ++i;
                        break;

                    default:
                        break;
            }
            ++i;
            break;

        case X_DYNAMIC_MACRO:
            i = 4;
            modifier = TRUE;

        case DYNAMIC_MACRO:
            value = dollarDollarAt;
            break;

        case DOLLAR_MACRO:
            if (*dest == *end)
                increaseBuffer(result, dest, end, length, first);
            *(*dest)++ = '$';
            *name += 2;
            return;

        default:
            return;                     // can't happen
    }
    if (!value) {
        for (temp = *name; *temp && *temp != ' ' && *temp != '\t'; temp++)
            ;
        c = *temp; *temp = '\0';
        makeError(currentLine, ILLEGAL_SPECIAL_MACRO, *name);
        *temp = c;
        listMacro = FALSE;
        value = makeString("");    // value is freed below, must be on heap [rm]
    }
    if (listMacro) {
        char *pVal, *endVal;
        unsigned lenVal = MAXBUF;
        p = (STRINGLIST*) value;
        pVal = (char *)allocate(MAXBUF);

        endVal = pVal + MAXBUF;
        for (value = pVal; p; p = p->next) {
            temp = p->text;
            if (modifier)
                temp = modifySpecialValue((*name)[i], nameBuf, temp);
            while(*temp) {
                if (value == endVal)
                    increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
                *value++ = *temp++;
            }
            if (value == endVal)
                increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
            *value = '\0';

            // Append a space if there are more elements in the list.  [RB]

            if (p->next) {
                *value++ = ' ';
                if (value == endVal)
                    increaseBuffer(&pVal, &value, &endVal, &lenVal, NULL);
                *value = '\0';
            }
        }
        value = pVal;
    } else {
        //For some reason 'buf' was being used here clobbering global 'buf
        //  instead of nameBuf
        if (star)
            value = modifySpecialValue('R', nameBuf, value);

        if (modifier)
            value = modifySpecialValue((*name)[i], nameBuf, value);
    }
    putValue(result, name, dest, end, value, length, first);

    if (value != dollarAt &&
        value != dollarDollarAt &&
        value != dollarLessThan &&
        (value < nameBuf || value >= nameBuf + MAXNAME)
       )
        FREE(value);
}


//  modifySpecialValue -- alter path name according to modifier
//
// Scope:   Local.
//
// Purpose:
//  The dynamic macros of NMAKE have modifiers F,B,D & R. This routine does the
//  job of producing a modified special value for a given filename.
//
// Input:
//  c        -- determines the type of modification (modifier is one of F,B,D & R
//  buf      -- location for storing modified value
//  value    -- The path specification to be modified
//
// Output:  Returns a pointer to the modified value
//
// Assumes: That initially buf pointed to previously allocated memory of size MAXNAME.
//
// Notes:
//  Given a path specification of the type "<drive:><path><filename><.ext>", the
//  modifiers F,B,D and R stand for following --
//   F - <filename><.ext>     - actual Filename
//   B - <filename>         - Base filename
//   D - <drive:><path>         - Directory
//   R - <drive:><path><filename> - Real filename (filename without extension)
//  This routine handles OS/2 1.20 filenames as well. The last period in the
//  path specification is the start of the extension. When directory part is null
//  the function returns '.' for current directory.
//
//  This function now handles quoted filenames too

char *
modifySpecialValue(
    char c,
    char *buf,
    char *value
    )
{
    char *lastSlash,                    // last path separator from "\\/"
     *extension;                        // points to the extension
    char *saveBuf;
    BOOL fQuoted;

    lastSlash = extension = NULL;
    saveBuf=buf;
    _tcscpy(buf, value);
    fQuoted = (BOOL) (buf[0] == '"');
    value = buf + _tcslen(buf) - 1;     // start from the end of pathname
    for (;value >= buf; value--) {
        if (PATH_SEPARATOR(*value)) {   // scan upto first path separator
            lastSlash = value;
            break;
        } else
        if (*value == '.' && !extension) //last '.' is extension
            extension = value;
    }

    switch(c) {
        case 'D':
            if (lastSlash) {
                if (buf[1] == ':' && lastSlash == buf + 2)
                    ++lastSlash;        // 'd:\foo.obj' --> 'd:\'
                *lastSlash = '\0';
            } else if (buf[1] == ':')
                buf[2] = '\0';          // 'd:foo.obj'  --> 'd:'
            else
                _tcscpy(buf, ".");      // 'foo.obj'    --> '.'
            break;

        case 'B':
            if (extension)              // for 'B' extension is clobbered
                *extension = '\0';

        case 'F':
            if (lastSlash)
                buf = lastSlash + 1;
            else if (buf[1] == ':')     // 'd:foo.obj'  --> foo     for B
                buf+=2;                 // 'd:foo.obj'  --> foo.obj for F
          break;

        case 'R':
            if (extension)
                *extension = '\0';      // extension clobbered
    }

    if (fQuoted) {                      // [fabriced] make sure we have quotes
        char *pEnd;                     // at both ends
        if(*buf!='"' && buf>saveBuf) { // make sure we can go back one char
            buf--;
            *buf='"';
        }
        pEnd = _tcschr(buf, '\0');
        if(*(pEnd-1)!='"') {
            *pEnd++ =  '"';
            *pEnd = '\0';
        }
    }
    return(buf);
}


// putValue -- store expanded macro's value in dest and advance past it
//
//  arguments:  result    ppointer to start of string being expanded
//              name      ppointer to macro name being expanded
//              dest      ppointer to place to store expanded value
//              end       ppointer to end of dest's buffer
//              source    pointer to text of expanded macro
//              length    pointer to amount by which to increase dest's buffer
//              first     address of initial stack buffer
//
//  actions:    if there is a substitution, call substituteStrings to do it
//              else copy source text into dest
//                advance *name past end of macro's invocation
//
// already did error checking in lexer

void
putValue(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length,
    char *first
    )
{
    char *s;
    char *t;                            // temporary pointer

    if (*++*name == ESCH)
        ++*name;                        // go past $ & ESCH if any
    s = _tcschr(*name, ':');
    for (t = *name; *t && *t != ')'; t++)   // go find first non-escaped )
        if (*t == ESCH)
            t++;
    if ((**name == '(')                 // substitute only if there is
        && s                            // a : before a non-escaped )
        && (s < t)
       ) {
        substituteStrings(result, &s, dest, end, source, length, first);
        *name = s;
    } else {
        for (; *source; *(*dest)++ = *source++)     // copy source into dest
            if (*dest == *end)
                increaseBuffer(result, dest, end, length, first);

        if (**name == '$')
            ++*name;                    // go past $$
        if (**name == '(')              // advance from ( to )
            while (*++*name != ')');
        else
            if (**name == '*' && *(*name + 1) == '*')
                ++*name;   // skip $**

        ++*name;                        // move all the way past
    }
}


// substituteStrings -- perform macro substitution
//
// arguments:  result  ppointer to start of string being expanded
//             name    ppointer to macro name being expanded
//             dest    ppointer to place to store substituted value
//             end     ppointer to end of dest's buffer
//             source  pointer to text of expanded macro (before sub.)
//             length  pointer to amount by which to increase dest's buffer
//             first   address of initial stack buffer
//
// changes: [SB]
//   old, new now dynamically allocated; saves memory; 3 errors detected
//   for macro syntax in script files.
//
// note: [SB]
//   we could use lexer routines recursively if we get rid of the globals
//   and then these errors needn't be flagged. [?]
//
// actions:    store text to convert from in old
//             store text to convert to in new
//             scan source text
//             when a match is found, copy new text into dest &
//              skip over old text
//             else copy one character from source text into dest
//
// returns:    nothing

void
substituteStrings(
    char **result,
    char **name,
    char **dest,
    char **end,
    char *source,
    unsigned *length,
    char *first
    )
{
    char *oldString, *newString;
    char *pEq, *pPar, *t;
    char *s;
    size_t i;

    ++*name;
    for (pEq = *name; *pEq && *pEq != '='; pEq++)
        if (*pEq == ESCH)
            pEq++;

    if (*pEq != '=')
        makeError(line, SYNTAX_NO_EQUALS);

    if (pEq == *name)
        makeError(line, SYNTAX_NO_SEQUENCE);

    for (pPar = pEq; *pPar && *pPar != ')'; pPar++)
        if (*pPar == ESCH)
            pPar++;

    if (*pPar != ')')
        makeError(line, SYNTAX_NO_PAREN);

    oldString = (char *) allocate((size_t) ((pEq - *name) + 1));
    for (s = oldString, t = *name; *t != '='; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    i = _tcslen(oldString);
    newString = (char *) allocate((size_t) (pPar - pEq));
    for (s = newString, t++; *t != ')'; *s++ = *t++)
        if (*t == ESCH)
            ++t;

    *s = '\0';
    *name = pPar + 1;
    while (*source) {
        if ((*source == *oldString)                     // check for match
            && !_tcsncmp(source, oldString, i)) {       // copy new in for
            for (s = newString; *s; *(*dest)++ = *s++)  //  old string
                if (*dest == *end)
                    increaseBuffer(result, dest, end, length, first);
            source += i;
            continue;
        }
        if (*dest == *end)
            increaseBuffer(result, dest, end, length, first);
        *(*dest)++ = *source++;         // else copy 1 char
    }
    FREE(oldString);
    FREE(newString);
}

//  prependPath -- prepend the path from pszWildcard to pszFilename
//
// Scope:   Global.
//
// Purpose:
//  This function is called to first extract the path (drive & dir parts) from
//  pszWildcard, the prepend that path to pszFilename.  The result string is
//  a reconstruction of the full pathname.  Normally, the pszWildcard parameter
//  is the same as the first parameter supplied to findFirst(), and pszFilename
//  is what returned by findFirst/findNext.
//
// Input:
//  pszWildcard -- Same as the first parameter supplied to findFirst()
//  pszFilename -- Same as the return value of findFirst/FindNext()
//
// Output:
//  Return the reconstructed full pathname.  The user must be responsible to
//  free up the memory allocated by this string.
//
// Assumes:
//  Since pszWildcard, the first parameter to findFirst() must include a filename
//  part; this is what I assume.  If the filename part is missing, then
//  _splitpath will mistaken the directory part of pszWildcard as the filename
//   part and things will be very ugly.
//
// History:
//  08-Apr-1993 HV Rewrite prependPath() to use _splitpath() and _makepath()

char *
prependPath(
    const char *pszWildcard,
    const char *pszFilename
    )
{
    // The following are the components when breaking up pszWildcard
    char  szDrive[_MAX_DRIVE];
    char  szDir[_MAX_DIR];

    // The following are the resulting full pathname.
    char  szPath[_MAX_PATH];
    char *pszResultPath;

    // First break up the pszWildcard, throwing away the filename and the
    // extension parts.
    _splitpath(pszWildcard, szDrive, szDir, NULL, NULL);

    // Then, glue the drive & dir components of pszWildcard to pszFilename
    _makepath(szPath, szDrive, szDir, pszFilename, NULL);

    // Make a copy of the resulting string and return it.
    pszResultPath = makeString(szPath);
    return (pszResultPath);
}


//  isRule -- examines a string to determine whether it's a rule definition
//
// arguments:    s   string to examine for rule-ness
//
// actions:    assume it's not a rule
//       skip past first brace pair (if any)
//       if next character is a period,
//       look for next brace
//       if there are no path separators between second brace pair,
//           and there's just a suffix after them, it's a rule
//       else if there's another period later on, and no path seps
//           after it, then it's a rule.
//
// returns:    TRUE if it's a rule, FALSE otherwise.

BOOL
isRule(
    char *s
    )
{
    char *t = s, *u;
    BOOL result = FALSE;

    if (*t == '{') {                        // 1st char is {, so
        while (*++t && *t != '}')           //  we skip over rest
            if (*t == ESCH)
                ++t;
        if (*t)
            ++t;                            //  of path (no error
    }                                       //  checking)

    if (*t == '.') {
        for (u = t; *u && *u != '{'; ++u)   // find first non-escaped {
            if (*u == ESCH)
                ++u;
        s = t;
        while (t < u) {                     // look for path seps.
            if (PATH_SEPARATOR(*t))
                break;                      // if we find any, it's
            ++t;                            // not a rule (they
        }                                   // can't be in suffix)
        if (*u && (t == u)) {               // if not at end & no path sep
            while (*++u && *u != '}')       // find first non-esc }
                if (*u == ESCH)
                    ++u;
            if (*u) {
                ++u;
                if (*u == '.'                   // if you find it, with . just
                    && !_tcschr(u+1, '/' )      // next to it & no path seps.,
                    && !_tcschr(u+1, '\\'))     // it's a rule
                    if (_tcschr(u+1, '.'))      // too many suffixes
                        makeError(currentLine, TOO_MANY_RULE_NAMES);
                    else
                        result = TRUE;
            }
        } else if (((u = _tcspbrk(s+1, "./\\")) && (*u == '.'))
                 && !_tcschr(u+1, '/')
                 && !_tcschr(u+1, '\\'))
            if (_tcschr(u+1, '.'))             // too many suffixes
                makeError(currentLine, TOO_MANY_RULE_NAMES);
            else
                result = TRUE;
    }
    return(result);
}

// ZFormat - extmake syntax worker routine.
//
// pStr    destination string where formatted result is placed.
// fmt     formatting string. The valid extmake syntax is ...
//           %%        is always %
//           %s        is the first dependent filename
//           %|<dpfe>F    is the appropriate portion out of %s
//              d    drive
//           p    path
//           f    filename
//           e    extension
//           %|F     same as %s
//       One needn't escape a %, unless it is a valid extmake syntax
// pFirstDep    is the dependent filename used for expansion

BOOL
ZFormat(
    char *pStr,
    unsigned limit,
    char *fmt,
    char *pFirstDep
    )
{
    char c;
    char *pEnd = pStr + limit;
    char *s;
    BOOL fError;
    BOOL fDrive;
    BOOL fPath;
    BOOL fFilename;
    BOOL fExtension;
    char buf[_MAX_PATH];

    for (; (c = *fmt) && (pStr < pEnd); fmt++) {
        if (c != '%') {
            *pStr++ = c;
        } else {
            switch (*++fmt) {
                case '%':        // '%%' -> '%'
                    *pStr++ = '%';
                    break;

                case 's':
                    for (s = pFirstDep; s && *s && pStr < pEnd; *pStr++ = *s++)
                        ;
                    break;

                case '|':
                    s = fmt-1;
                    fError = fDrive = fPath = fFilename = fExtension = FALSE;
                    *buf = '\0';
                    do {
                        switch (*++fmt) {
                            case 'd':
                                fDrive = TRUE;
                                break;

                            case 'p':
                                fPath = TRUE;
                                break;

                            case 'f':
                                fFilename = TRUE;
                                break;

                            case 'e':
                                fExtension = TRUE;
                                break;

                            case 'F':
                                if (fmt[-1] == '|') {
                                    fDrive = TRUE;
                                    fPath = TRUE;
                                    fFilename = TRUE;
                                    fExtension = TRUE;
                                }
                                break;

                            case '\0':
                                // backtrack, so that we don't read past
                                // the end of the string in the for loop
                                // [msdev96 #4057]
                                fmt--;
                                // fall trhough

                            default :
                                fError = TRUE;
                                break;
                        }

                        if (fError) {
                            break;
                        }
                    } while (*fmt != 'F');

                    if (fError) {
                        for (; s <= fmt && pStr < pEnd; *pStr++ = *s++)
                            ;
                        break;
                    }

                    if (!pFirstDep) {
                        makeError(0, EXTMAKE_NO_FILENAME);
                    }

                    if (fDrive) {
                        drive(pFirstDep, buf);
                    }

                    if (fPath) {
                        path(pFirstDep, strend(buf));
                    }

                    if (fFilename) {
                        filenamepart(pFirstDep, strend(buf));
                    }

                    if (fExtension) {
                        extension(pFirstDep, strend(buf));
                    }

                    for (s = buf; *s && pStr < pEnd; *pStr++ = *s++)
                        ;
                    break;

                case '\0':
                    // backtrack, so that we don't read past
                    // the end of the string in the for loop
                    // [msdev96 #4057]
                    fmt--;
                    // *pStr++ = '%';
                    break;


                default:
                    *pStr++ = '%';
                    if (pStr == pEnd) {
                        return(TRUE);
                    }
                    *pStr++ = *fmt;
                    break;
            }
        }
    }

    if (pStr < pEnd) {
        *pStr = '\0';
        return(FALSE);
    }

    return(TRUE);
}

void
expandExtmake(
    char *buf,
    char *fmt,
    char *pFirstDep
    )
{
    if (ZFormat(buf, MAXCMDLINELENGTH, fmt, pFirstDep))
        makeError(0, COMMAND_TOO_LONG, fmt);
}


//  drive -- copy a drive from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a drive from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the drive from.
//  char *dst       -- The buffer to copy the drive to, must be alloc'd before.
//
// Output:  Return TRUE if a drive part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
drive(
    const char *src,
    char *dst
    )
{
    _splitpath(src, dst, NULL, NULL, NULL);
    return (0 != _tcslen(dst));
}


//  extension -- copy a extension from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a drive from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the extension from.
//  char *dst       -- The buffer to copy the extension to.
//
// Output:  Return TRUE if a extension part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
extension(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, NULL, NULL, dst);
    return (0 != _tcslen(dst));
}


//  filename -- copy a filename from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a filename from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the filename from.
//  char *dst       -- The buffer to copy the filename to.
//
// Output:  Return TRUE if a filename part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// Notes:
//  BUGBUG: (posible) when src == '..' --> dst = '.', src == '.', dst = ''
//          This is the way _splitpath works.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
filenamepart(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, NULL, dst, NULL);
    return (0 != _tcslen(dst));
}


//  path -- copy a path from source to dest if present
//
// Scope:   Local.
//
// Purpose: copy a path from source to dest if present, return TRUE if we found one
//
// Input:
//  const char *src -- The full path to extract the path from.
//  char *dst       -- The buffer to copy the path to.
//
// Output:  Return TRUE if a path part is found, else return FALSE.
//
// Assumes:
//  1. src is a legal pathname.
//  2. src does not contain network path (i.e. \\foo\bar)
//  3. The buffer dst is large enough to contain the result.
//  4. src does not contain quote since _splitpath() treat quotes a normal char.
//
// History:
//  31-Mar-1993 HV Rewrite drive(), path(), filenamepart(), and extension() to use
//          _splitpath() instead of parsing the pathname by itself.

int
path(
    const char *src,
    char *dst
    )
{
    _splitpath(src, NULL, dst, NULL, NULL);
    return (0 != _tcslen(dst));
}


STRINGLIST *
searchBucket(
    char *string,
    STRINGLIST *table[],
    unsigned hash
    )
{
    char *s, *t;
    STRINGLIST *p;

    for (p = table[hash]; p; p = p->next) {
#if defined(STATISTICS)
        CnttargetChains++;
#endif
        for (s = string, t = p->text; *s && *t; s++, t++) {
            if (*s == '\\' || *s == '/')            // / == \ in targets
                if (*t == '\\' || *t == '/')
                    continue;
                else
                    break;
            else if (_totupper(*s) == _totupper(*t))    // lc == UC
                continue;
            else
                break;
        }
        if (!*s && !*t)
            return(p);
    }
    return(NULL);
}


int
strcmpiquote(
    char *str1,
    char *str2
    )
{
    int rc;
    char *s1, *s2;
    char *t;

#if defined(STATISTICS)
    CntStriCmp++;
#endif
    s1 = (char *) _alloca(_tcslen(str1) + 1);
    s2 = (char *) _alloca(_tcslen(str2) + 1);

    if (*str1 == '"')
        str1++;
    for (t = s1;*str1;*t++=*str1++)
        ;
    if (t[-1] == '"')
        t--;
    *t = '\0';

    if (*str2 == '"')
        str2++;
    for (t = s2;*str2;*t++=*str2++)
        ;
    if (t[-1] == '"')
        t--;
    *t = '\0';

    rc = _tcsicmp(s1, s2);
    return(rc);
}


// Remove quotes from a string, if any
// Returns a copy of the string
// Note that there may be quotes at the start, the end or either side.

char *
unQuote(
    char *str
    )
{
    char *s = (char *) rallocate(_tcslen(str) + 1);
    char *t;

#if defined(STATISTICS)
    CntunQuotes++;
#endif

    if (*str == '"') {
        str++;
    }
    for (t = s;*str;*t++=*str++)
        ;
    if (t[-1] == '"') {
        t--;
    }
    *t = '\0';
    return(s);
}


FILE *
open_file(
    char *name,
    char *mode
    )
{
    // If name contains Quotes, remove these before opening the file
    if (*name == '"') {
        *(_tcsrchr(name, '"')) = '\0';
        _tcscpy(name, name+1);
    }

    // Allow sharing between makes running at the same time

    return(_fsopen(name, mode, _SH_DENYWR));
}


//  TruncateString -- Truncate a string to certain size, take care of MBCS
//
// Scope:   GLOBAL.
//
// Purpose:
//  Since an MBCS string can mix double-byte & single-byte characters, simply
//  truncating the string by terminate it with a NULL byte won't work.
//  TruncateString will make sure that the string is cut off at the character
//  boundary.
//
// Input:
//  pszString    -- The string to be truncated.
//  uLen         -- The length to truncate.  The final string's length might be
//                   less than this be cause of double-byte character.
//
// Output:  pszString    -- The truncated string.
//
// History:
//  03-Jun-1993 HV Add helper local function TruncateString for findFirst.

void
TruncateString(
    char *pszString,
    unsigned uLen
    )
{
    char *pEnd = pszString;     // Points to the end of the string
    unsigned cByte;             // Number of bytes to advance depend on lead
                                // byte or not

    // Loop to get to the end of the string, exit only when we have exhausted
    // the string, or when the length limit is reached.
    while(*pEnd) {
        // If the the character is a lead byte, advance 2 bytes,
        // else, just advance 1 byte.
#ifdef _MBCS
    cByte = _ismbblead(*pEnd) ? 2 : 1;
#else
    cByte = 1;
#endif
        // If we hit the limit by advancing, stop now.
        if (pEnd - pszString + cByte > uLen) {
            *pEnd = '\0';    // Truncate it.
            break;
        }

        // Otherwise, advance the pointer to the next character (not byte)
        pEnd += cByte;
    }
}

// IsValidMakefile - Checks if the makefile is in plain ascii text format.
//
// Scope:   GLOBAL.
//
// Purpose:
//  We don't want to open UTF8 or unicode makefiles, only to report an
//  error at some random place in the makefile.
//
// Input:
//  file         -- File pointer.
//
// Output:       -- Returns FALSE if in UTF8 or Unicode format
//
// History:

BOOL IsValidMakefile(FILE *fp)
{
    const char sigUTF8[] = { '\xef', '\xbb', '\xbf' };
    const char sigUnicode[] = { '\xff', '\xfe' };
    char sig[4];
    const unsigned int len = sizeof sig;
    BOOL fResult = fp != NULL;

    if (fp != NULL && fread(sig, len, 1, fp)) {
        fResult = memcmp(sig, sigUTF8, __min(len, sizeof sigUTF8))
               && memcmp(sig, sigUnicode, __min(len, sizeof sigUnicode));
    }

    fseek(fp, 0, SEEK_SET);
    return fResult;
}


// OpenValidateMakefile - Open a makefile, only if it's valid.
//
// Scope:   GLOBAL.
//
// Purpose:
//  We don't want to open UTF8 or unicode makefiles, only to report an
//  error at some random place in the makefile.
//
// Input:
//  file         -- File pointer.
//
// Output:       -- Returns FALSE if in UTF8 or Unicode format
//
// History:


FILE *OpenValidateMakefile(char *name,char *mode)
{
    FILE *fp = open_file(name, mode);

    if (fp != NULL && !IsValidMakefile(fp))
    {
        fclose(fp);
        makeError(0, CANT_SUPPORT_UNICODE, 0);
    }

    return fp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nvram\nvram.c ===
/*++

Copyright (c) 1993-1996 Microsoft Corporation

Module Name:

    nvram.c

Abstract:

    ARC/NV-RAM manipulation routines for 32-bit winnt setup.
    Also works on boot.ini on i386 machines.

Author:

    Ted Miller (tedm) 19-December-1993

Revision History:

--*/


#include "nvram.h"

typedef enum {
    BootVarSystemPartition,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarCountdown,
    BootVarMax
} BOOT_VARS;

PWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                   L"OSLOADER",
                                   L"OSLOADPARTITION",
                                   L"OSLOADFILENAME",
                                   L"LOADIDENTIFIER",
                                   L"OSLOADOPTIONS",
                                   L"COUNTDOWN"
                                 };

PWSTR PaddedBootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                         L"       OSLOADER",
                                         L"OSLOADPARTITION",
                                         L" OSLOADFILENAME",
                                         L" LOADIDENTIFIER",
                                         L"  OSLOADOPTIONS",
                                         L"      COUNTDOWN"
                                       };

#ifndef i386

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )



BOOL
DoSetNvRamVar(
    IN PWSTR VarName,
    IN PWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


VOID
PrintNvRamVariable(
    IN PWSTR VariableName,
    IN PWSTR VariableValue
    )
{
    PWSTR pEnd;
    WCHAR c;
    BOOL FirstComponent = TRUE;

    while(*VariableValue) {

        //
        // Find the termination of the current component,
        // which is either a ; or 0.
        //
        pEnd = wcschr(VariableValue,L';');
        if(!pEnd) {
            pEnd = wcschr(VariableValue,0);
        }

        c = *pEnd;
        *pEnd = 0;

        wprintf(
            L"%s%s %s\n",
            FirstComponent ? VariableName : L"               ",
            FirstComponent ? L":" : L" ",
            VariableValue
            );

        *pEnd = c;

        VariableValue = pEnd + (c ? 1 : 0);

        FirstComponent = FALSE;
    }
}

VOID
RotateNvRamVariable(
    IN PWSTR VariableValue
    )
{
    PWSTR pEnd;
    WCHAR Buffer[32768];
    //
    // Find the termination of the current component,
    // which is either a ; or 0.
    //
    pEnd = wcschr(VariableValue,L';');
    if(!pEnd) {
        pEnd = wcschr(VariableValue,0);
    }

    //
    // Copy VariableValue into Buffer starting at second entry
    //
    wcscpy(Buffer, pEnd + (*pEnd ? 1 : 0));

    //
    // Append first entry at the end of Buffer
    //
    if (*pEnd) wcscpy(Buffer + wcslen(Buffer), L";");

    *pEnd = 0;

    wcscpy(Buffer + wcslen(Buffer), VariableValue);

    //
    // Copy whole thing back into VariableValue
    //
    wcscpy(VariableValue, Buffer);

}

int _cdecl main(
    IN int argc,
    IN char *argv[]
    )
{
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOLEAN OldPriv;
    WCHAR Buffer[32768];
    WCHAR Buffer1[32768];
    WCHAR Buffer2[32768];

    Status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &OldPriv
                );

    if(!NT_SUCCESS(Status)) {
        wprintf(L"Insufficient privilege.\n");
        return(0);
    }

    if(argc == 1) {

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                PrintNvRamVariable(PaddedBootVarNames[var],Buffer);
            } else {
                wprintf(L"%s: <empty>\n",PaddedBootVarNames[var]);
            }

            wprintf(L"\n");
        }
    }

    if((argc == 2) && !lstrcmpiA(argv[1],"rotate")){

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                RotateNvRamVariable(Buffer);
                printf(
                    "Setting variable %ws to %ws [%s]\n",
                    UnicodeString.Buffer,
                    Buffer,
                    DoSetNvRamVar(UnicodeString.Buffer,Buffer) ? "OK" : "Error"
                );
            } else {
                wprintf(L"%s: <empty>\n",PaddedBootVarNames[var]);
            }

            wprintf(L"\n");
        }
    }

    if((argc == 5) && !lstrcmpiA(argv[1]+1,"set") && !lstrcmpA(argv[3],"=")) {

        MultiByteToWideChar(
            CP_OEMCP,
            MB_PRECOMPOSED,
            argv[2],
            -1,
            Buffer1,
            SIZECHARS(Buffer1)
            );

        MultiByteToWideChar(
            CP_OEMCP,
            MB_PRECOMPOSED,
            argv[4],
            -1,
            Buffer2,
            SIZECHARS(Buffer2)
            );

        printf(
            "Setting variable %ws to %ws [%s]\n",
            Buffer1,
            Buffer2,
            DoSetNvRamVar(Buffer1,Buffer2) ? "OK" : "Error"
            );
    }

    return(0);
}

#else

TCHAR LoadID[500];          // load identifier (no quotes)
TCHAR CountDown[100];       // countdown timer
TCHAR OsLoadOptions[500];   // load options
TCHAR OsName[500];          // name of default os

TCHAR OsLine[500];          // complete line of os description and options

#define STR_BOOTINI           TEXT("c:\\boot.ini")
#define STR_BOOTLDR           TEXT("boot loader")
#define STR_TIMEOUT           TEXT("timeout")
#define STR_DEFAULT           TEXT("default")
#define STR_OPERATINGSYS      TEXT("operating systems")
#define STR_NULL              TEXT("")

//
// HandleOption - add option to OsLoadOptions
//

VOID HandleOption( TCHAR* Option )
{
    TCHAR SlashOption[200];
    TCHAR SlashOptionSlash[200];
    //
    // find out if option already exists
    // add blank to end to prevent debug from matching debugport
    //

    wsprintf( SlashOption, TEXT("/%s "), Option );
    wsprintf( SlashOptionSlash, TEXT("/%s/"), Option );

    if( wcsstr( OsLoadOptions, SlashOption )   || 
        wcsstr( OsLoadOptions, SlashOptionSlash ) )
    {
        printf("option already exists: %ws\n",Option);
    }
    else
    {
        //
        // append option without the trailing blank
        //

        printf("added option %ws\n",Option);
        lstrcat( OsLoadOptions, TEXT("/") );
        lstrcat( OsLoadOptions, Option );
    }
}

//
// WriteBootIni - update the boot.ini file with our changes
//

VOID WriteBootIni()
{
    DWORD FileAttr;

    //
    // Get file attributes of boot.ini for later restoration
    //

    FileAttr= GetFileAttributes( STR_BOOTINI );

    //
    // Change file attributes on boot.ini so we can write to it.
    //

    if( !SetFileAttributes( STR_BOOTINI, FILE_ATTRIBUTE_NORMAL ) )
    {
        printf("Failed to turn off read-only on boot.ini  (lasterr= %d)\n",
                GetLastError() );
    }

    //
    // Update boot.ini strings
    //

    if( !WritePrivateProfileString( STR_BOOTLDR, STR_TIMEOUT, 
                                   CountDown, STR_BOOTINI ) )
    {
        printf("failed to write timeout (lasterr= %d)\n",GetLastError());
    }

    //
    // create the osline from its parts
    //
    
    wsprintf(OsLine, TEXT("\"%s\"%s"), LoadID, OsLoadOptions );

    if( !WritePrivateProfileString( STR_OPERATINGSYS, OsName,  
                                    OsLine, STR_BOOTINI ) )
    {
        printf("failed to write OS line (lasterr= %d)\n",GetLastError());
    }

    //
    // Restore boot.ini file attributes
    //

    if( FileAttr != 0xFFFFFFFF )
    {
        SetFileAttributes( STR_BOOTINI, FileAttr );
    }

}

//
// Usage - print out usage information
//

VOID Usage()
{
        printf("\nUsage:\n");
        printf("    no parameters:  prints current settings.\n");
        printf("   /set parameter = value  : sets value in boot.ini\n");
        printf("   rotate : rotates default build through boot options\n");
        printf("\n");
        printf("Example:  nvram /set osloadoptions = debug\n");
        printf("   This will set the debug option on\n\n");
        printf("Available options:\n");
        printf("    loadidentifier, osloadoptions, countdown\n");
}


int _cdecl main(
    IN int argc,
    IN char *argv[]
    )
{
    DWORD dwStatus;
    LPWSTR* pArgs;

    // parse command line in unicode

    pArgs= CommandLineToArgvW( GetCommandLine(), &argc );

    //
    // Get the boot information from boot.ini
    //

    // timeout

    dwStatus= GetPrivateProfileString(
                 STR_BOOTLDR, 
                 STR_TIMEOUT,
                 STR_NULL,
                 CountDown,
                 SIZECHARS(CountDown),
                 STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get timeout value\n");
        return(-1);
    }

    // default os description and options

    dwStatus= GetPrivateProfileString(
                  STR_BOOTLDR,
                  STR_DEFAULT,
                  STR_NULL,
                  OsName,
                  SIZECHARS(OsName),
                  STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get default OS name\n");
        return(-1);
    }

    dwStatus= GetPrivateProfileString(
                  STR_OPERATINGSYS,
                  OsName,
                  STR_NULL,
                  OsLine,
                  SIZECHARS(OsLine),
                  STR_BOOTINI );
    if( !dwStatus )
    {
        printf("Failed to get default os description\n");
        return(-1);
    }
                 
    //
    // Now parse the line into description and options.
    // If it starts with a quote, it may have options.
    // If it doesn't start with a quote, it won't.
    //

    *LoadID= *OsLoadOptions= TEXT('\0');

    if( *OsLine == TEXT('"') )
    {
        INT i;

        for( i=1; OsLine[i]; i++ )
        {
            LoadID[i-1]= OsLine[i];
            if( OsLine[i] == TEXT('"') )
               break;
        }

        if( OsLine[i] )
        {
            LoadID[i-1]= TEXT('\0');   // don't copy final quote
            lstrcpy( OsLoadOptions, &OsLine[i+1] );
            lstrcat( OsLoadOptions, TEXT(" ") ); // all options end with blank
        }
    }
    else
    {
        lstrcpy( LoadID, OsLine );
        lstrcpy( OsLoadOptions, TEXT("") );
    }

    // no parameters prints out values

    if( argc == 1 )
    {
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarLoadIdentifier], LoadID);
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarOsLoadOptions], OsLoadOptions);
        printf("%ws: %ws\n",PaddedBootVarNames[BootVarCountdown], CountDown);
    }
    
    // -set parameter = value
    // sets parameter to some value

    if( (argc == 2) &&
       !lstrcmpiW(pArgs[1],L"rotate") )
    {
        INT i;
        DWORD FileAttr;

        //
        // Read in all boot options
        //

        dwStatus= GetPrivateProfileString(
                      STR_OPERATINGSYS,
                      NULL,
                      STR_NULL,
                      OsLine,
                      SIZECHARS(OsLine),
                      STR_BOOTINI );
        if( !dwStatus )
        {
            printf("Failed to get os section\n");
            return(-1);
        }

        //
        // read through boot options until we find default entry
        //

        i = 0;

        while( lstrcmpiW( OsName, &(OsLine[i]) ) ){

            i = i + wcslen(&OsLine[i]) + 1;
        }

        //
        // increment one more entry
        //

        i = i + wcslen(&OsLine[i]) + 1;

        //
        // if we've gone off the end then start over
        //

        if (!lstrcmpiW( &(OsLine[i]), L"\0\0" ) ){
            i = 0;
        }

        //
        // Get file attributes of boot.ini for later restoration
        //

        FileAttr= GetFileAttributes( STR_BOOTINI );

        //
        // Change file attributes on boot.ini so we can write to it.
        //

        if( !SetFileAttributes( STR_BOOTINI, FILE_ATTRIBUTE_NORMAL ) )
        {
            printf("Failed to turn off read-only on boot.ini  (lasterr= %d)\n",
                    GetLastError() );
        }

        if( !WritePrivateProfileString( STR_BOOTLDR, STR_DEFAULT,
                                       &(OsLine[i]), STR_BOOTINI ) )
        {
            printf("failed to write default (lasterr= %d)\n",GetLastError());
        }

        //
        // Restore boot.ini file attributes
        //

        if( FileAttr != 0xFFFFFFFF )
        {
            SetFileAttributes( STR_BOOTINI, FileAttr );
        }

    }
    if( (argc == 5) && 
       !lstrcmpiW(pArgs[1]+1,L"set") && 
       !lstrcmpW(pArgs[3],L"=") )
    {
        INT i;

        // see if we understand parameter

        for( i=0; i<BootVarMax; i++ )
        {
            if( lstrcmpiW( pArgs[2], BootVarNames[i] ) == 0 )
                break;
        }

        // handle the ones we can

        switch( i )
        {
            default:
                printf("Not valid parameter name to set: %ws\n",pArgs[2]);
                Usage();
                return(-1);
                break;

            case BootVarLoadIdentifier:
                lstrcpyW( LoadID, pArgs[4] );
                break;

            case BootVarOsLoadOptions:
                HandleOption( pArgs[4] );
                break;

            case BootVarCountdown:
                lstrcpyW( CountDown, pArgs[4] );
                break;
        }

        WriteBootIni();
    }

    // -?     
    // usage message

    if( argc == 2 && !lstrcmpW(pArgs[1]+1, L"?") )
    {
        Usage();
    }

    return(0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\opprec\opprec.h ===
extern void   cdecl main(int, char **);
extern void     ReadMat(FILE *, int *, char **, int);
extern void     DumpMat(int *, int);
extern void     CopyMat(int *, int *, int);
extern void     AddClosure(int *, int);
extern char *   SkipBlank (FILE *, char *, int);


#define FALSE 0
#define TRUE ~FALSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\opprec\opprec.c ===
/**	opprec.c - compute operator predecence function values
 *	R. A. Garmoe	89/05/09
 */

/*	This program accepts a directed graph (in matrix form) and calculates
 *	the operator precedence function values f(op) and g(op).  For more
 *	information see Compilers: Principles, Techniques and Tools, by Aho,
 *	Sethi and Ullman [Addison-Wesley], Section 4.6.  A value of 1 in the
 *	matrix indicates an edge; a value of 0 indicates no edge.  Note
 *	also that the entries fx -> fy and gx -> gy are only present as
 *	placeholders (to make the matrix easier to read in); these values
 *	should always be zero.
 *
 *	To use this program, first generate the directed graph file expr2.z and
 *	run it through the C preprocessor to remove comments:
 *
 *		cl -P expr2.z
 *
 *	This will produce the file expr2.i, which can then be run through
 *	opprec.exe:
 *
 *		graph {option} expr2.i > expr2.out
 *
 *	The output file expr2.out then contains the precedence function
 *	values in either assembler or C format.
 */



/*	Call
 *
 *	opprec vca file
 *
 *	where
 *		v	include operator values in output as comments
 *		c	generate C compilable output
 *		a	generate MASM assemblable output
 *		file	input file stripped of comments
 */





#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "opprec.h"

struct token {
	struct token *next;
	char   precstr[17];
	char   type[17];
	char   tclass[17];
	char   bind[17];
	char   eval[17];
};
struct token *tokhead = NULL;
struct token *toktail = NULL;
int	asmout = FALSE; 	//output assembler form if true
int	verbose = FALSE;	//output operator group data if true

void cdecl main(int argc, char **argv)
{
	int 	i;
	int 	j;
	int 	d;
	int    *pMat;
	int    *pPrec;
	char  **pStr;
	int 	cEnt;
	FILE   *fh;
	char   *p, *q;
	int 	len, f, g;
	struct	token *pt;
	int 	ntoken = 0;
	char	str[200];

	// check arguments

	if (argc != 3) {
		printf ("Usage: graph -vca file\n");
		exit (1);
	}

	for (i = 0; argv[1][i] != 0; i++) {
		switch (argv[1][i]) {
			case 'a':
				asmout = TRUE;
				break;

			case 'c':
				asmout = FALSE;
				break;

			case 'v':
				verbose = TRUE;
				break;

			default:
				printf ("Unknown argument %c\n", argv[1][i]);
				exit (1);
		}
	}
	if ((fh = fopen (argv[2], "r")) == NULL) {
		printf ("Unable to open '%s'\n", argv[1]);
		exit (1);
	}

	// read and print token class definitions

	for (;;) {
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p)) {
			p++;
		}
		q = strpbrk (p, " \t");
		if ( q )
			*q = 0;
		if (strcmp (p, "END") == 0) {
			break;
		}
		if (asmout) {
			printf ("OPCDAT %s\n", p);
		}
		else {
			printf ("OPCDAT (%s)\n", p);
		}
	}
	printf ("\n");

	// read token definitions

	for (;;) {
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p)) {
			p++;
		}
		if (strcmp (p, "END") == 0) {
			break;
		}
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		ntoken++;
		if ((pt = (struct token *)malloc (sizeof (struct token))) == NULL) {
			printf ("insufficient memory\n");
			exit (2);
		}
		pt->next = NULL;
		strcpy (pt->precstr, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		strcpy (pt->type, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->tclass, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->bind, p);
		p = q + 1;
		while (isspace (*p)) {
			p++;
		}
		if ((q = strpbrk (p, " \t")) != NULL) {
			*q = 0;
		}
		strcpy (pt->eval, p);




		if (tokhead == NULL) {
			tokhead = pt;
			toktail = pt;
		}
		else {
			toktail->next = pt;
			toktail = pt;
		}
	}
	if (asmout) {
		printf ("OPCNT COPS_EXPR,\t%d\n\n", ntoken);
	}
	else {
		printf ("OPCNT (COPS_EXPR,\t%d\t)\n\n", ntoken);
	}

	// read dimension of matrix.	note that the upper left and lower right
	// quadrants of the matrix must be zero.

	if (SkipBlank (fh, str, 200) == NULL) {
		printf ("EOF reached\n");
		exit (1);
	}
	cEnt = atoi (str);

	// allocate space for the matrix and the description strings

	pMat = (int *)malloc (cEnt * cEnt * sizeof(int));
	pStr = malloc (cEnt * sizeof (char *));
	pPrec = (int *)malloc (cEnt * sizeof (int));
	if ((pMat == NULL) || (pStr == NULL) || (pPrec == NULL)) {
		printf ("insufficient memory\n");
		exit (2);
	}

	ReadMat (fh, pMat, pStr, cEnt);

	AddClosure (pMat, cEnt);

	// check for acyclic graph

	for (i = 0; i < cEnt; ++i) {
		if (pMat[i * cEnt + i] != 0) {
			printf ("Graph is cyclic for %s!!!\n", pStr[i]);
			exit(3);
		}
	}

	// print precedence function values

	for (i = 0; i < cEnt; ++i) {
		d = 0;
		for (j = 0; j < cEnt; ++j) {
			if (pMat[i * cEnt + j] > d) {
				d = pMat[i * cEnt + j];
			}
		}
		pPrec[i] = d;
		if (verbose) {
			if (asmout) {
				printf (";%-4s : %3d\n", pStr[i], d);
			}
			else {
				printf ("/*%-4s : %3d*/\n", pStr[i], d);
			}
		}
	}

	// print token definitions

	for (pt = tokhead; pt != NULL; pt = pt->next) {
		len = strlen (pt->precstr);

		// search for F string in list of precedence groupings

		for (i = 0; i < cEnt; i++) {
			if ((p = strstr(pStr[i], pt->precstr)) &&
			  ((*(p + len) == 0) || (*(p + len) == 'G'))) {
				break;
			}
		}
		if (i == cEnt) {
			printf ("F precedence string \"%s\" not found\n", pt->precstr);
			exit (4);
		}
		else {
			f = pPrec[i];
		}

		// search for G string in list of precedence groupings

		*pt->precstr = 'G';
		for (i = 0; i < cEnt; i++) {
			// search for string in list of precedence groupings
			if ((p = strstr(pStr[i], pt->precstr)) && (*(p + len) == 0)) {
				break;
			}
		}
		if (i == cEnt) {
			printf ("G precedence string \"%s\" not found\n", pt->precstr);
			exit (4);
		}
		else {
			g = pPrec[i];
		}
		if (asmout) {
			printf ("OPDAT %-16s,%4d,%4d,\t%-16s\n", pt->type, f, g,pt->tclass);
		}
		else {
			printf ("OPDAT (%-16s,%4d,%4d,\t%-16s,%-16s,%-16s\t)\n",
			  pt->type, f, g,pt->tclass, pt->bind, pt->eval);
		}
	}
	fclose (fh);
}




char *SkipBlank (FILE *fh, char *pStr, int cnt)
{
	int	len;

	for (;;) {
		if (fgets (pStr, cnt, fh) == NULL) {
			return (NULL);
		}
		len = strlen (pStr);
		if ((len == 1) || (*pStr == '#')) {
			continue;
		}
		*(pStr + len - 1) = 0;
		return (pStr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\opprec\mat.c ===
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "opprec.h"

void	ReadMat(FILE *fh, int *pMat, char **pStr, int cEnt)
{
	register int	i, j;
	int ind = 0;
	char str[200];
	char *p, *q;

	for (i = 0 ; i < cEnt ; ++i) {
		if ((pStr[i] = malloc(8)) == NULL) {
			printf("insufficient memory\n");
			exit(2);
		}
		if ((p = SkipBlank (fh, str, 200)) == NULL) {
			printf ("EOF reached\n");
			exit (1);
		}
		while (isspace (*p))
			p++;
		if ((q = strpbrk (p, " \t")) == NULL) {
			printf ("Bad format (%s)\n", str);
			exit (1);
		}
		*q = 0;
		strcpy (pStr[i], p);
		p = q + 1;
		for (j = 0; j < cEnt; j++, ind++) {
			// read group and matrix values
			while (isspace (*p))
				p++;
			if ((*p == 0) || ((*p != '0') && (*p != '1'))) {
				printf ("Bad format (%s)\n", str);
				exit (1);
			}
			pMat[ind] = *p++ - '0';
		}
	}
}

void	DumpMat(int *pMat, int cEnt)
{
	register int	i;
	register int	j;

	for (i=0 ; i<cEnt ; ++i)
	{
		for (j=0 ; j<cEnt ; ++j)
			printf("%d ", pMat[i * cEnt + j]);

		printf("\n");
	}
}



void AddClosure(int *pMat, int cEnt)
{
				int	d;
				int	e, f;
				int	i;
	register int	j;
	register	int	k;
				int	n;
				int	*pMatTmp;

	pMatTmp = malloc(cEnt * cEnt * sizeof(int));
    if (!pMatTmp) {
        return;
    }

	for (n = 0; n < cEnt; ++n) {
		for (i = 0; i < cEnt; ++i) {
			for (j = 0; j < cEnt; ++j) {
				d = pMat[i * cEnt + j];

				for (k = 0; k < cEnt; ++k) {
					e = pMat[i * cEnt + k];
					f = pMat[k * cEnt + j];

					if ((e != 0) && (f != 0))
						if (e + f > d)
							d = e + f;
				}

				pMatTmp[i * cEnt + j] = d;
			}
		}
		memcpy (pMat, pMatTmp, cEnt * cEnt * sizeof (int));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\nvram\setnvram.c ===
/*++

Copyright (c) 1994-1996 Microsoft Corporation

Module Name:

    setnvram.c

Abstract:

    This program is an example of how you could use a text file to create
    input for nvram.exe.

Author:

    Chuck Lenzmeier (chuckl)

Revision History:

--*/

//
// setnvram.c
//
// This program is an example of

#define _DLL 1
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SEPARATOR "|"

#define MAXLINESIZE 256

#define FALSE 0
#define TRUE 1

char Line[MAXLINESIZE];

char Countdown[MAXLINESIZE];

char LoadIdentifier[MAXLINESIZE];
char SystemPartition[MAXLINESIZE];
char OsLoader[MAXLINESIZE];
char OsLoadPartition[MAXLINESIZE];
char OsLoadFilename[MAXLINESIZE];
char OsLoadOptions[MAXLINESIZE];

char DefaultSystemPartition[MAXLINESIZE];
char DefaultOsLoadPartition[MAXLINESIZE];
char DefaultOsLoadOptions[MAXLINESIZE];

char *
Trim (
    char *String
    )
{
    char *start;
    char *end;

    start = String;
    while ( (*start == ' ') || (*start == '\t') ) {
        start++;
    }

    end = strrchr( start, 0 ) - 1;
    if ( (end > start) && ((*end == ' ') || (*end == '\t')) ) {
        do {
            end--;
        } while ( (*end == ' ') || (*end == '\t') );
        end++;
        *end = 0;
    }

    return start;
}

int
ParsePartition (
    char *String,
    char *Partition
    )
{
    char buffer[MAXLINESIZE];
    char *multi;
    char *scsi;
    char *disk;
    char *part;
    char *dot;

    strcpy( buffer, String );

    if ( _strnicmp(buffer, "scsi.", 5) != 0 ) {
        return FALSE;
    }
    multi = "0";
    scsi = "0";
    disk = &buffer[5];
    dot = strchr( disk, '.' );
    if ( dot == NULL ) {
        return FALSE;
    }
    *dot = 0;
    part = dot + 1;
    dot = strchr( part, '.' );
    if ( dot != NULL ) {
        scsi = disk;
        disk = part;
        *dot = 0;
        part = dot + 1;
        dot = strchr( part, '.' );
        if ( dot != NULL ) {
            multi = scsi;
            scsi = disk;
            disk = part;
            *dot = 0;
            part = dot + 1;
        }
    }

#if !defined(_PPC_)
    strcpy( Partition, "scsi()disk(" );
#else
    strcpy( Partition, "multi(" );
    strcat( Partition, multi );
    strcat( Partition, ")scsi(" );
    strcat( Partition, scsi );
    strcat( Partition, ")disk(" );
#endif
    strcat( Partition, disk );
#if !defined(_PPC_)
    strcat( Partition, ")rdisk()partition(" );
#else
    strcat( Partition, ")rdisk(0)partition(" );
#endif
    strcat( Partition, part );
    strcat( Partition, ")" );

    return TRUE;
}

int
main (
    int argc,
    char *argv[]
    )
{
    FILE *file = stdin;

    char *build;
    int len;
    int linenum;

    char *ident;
    char *token;
    char *sysdir;
    char *osdir;
    char *options;
    char *syspart;
    char *ospart;
    char *loader;

    char options1[MAXLINESIZE];
    char syspart1[MAXLINESIZE];
    char ospart1[MAXLINESIZE];

    if ( argc > 1 ) {
#if 1
      if ( argc > 2 ) {
#endif
        fprintf( stderr, "This program accepts no arguments\n" );
        fprintf( stderr, "Redirect stdin to build data file\n" );
        fprintf( stderr, "Redirect stdout to nvram.exe input file\n" );
        return 1;
#if 1
      } else {
        file = fopen( argv[1], "r" );
        if ( file == NULL ) {
            fprintf( stderr, "Can't open input file %s\n", argv[1] );
            return 1;
        }
      }
#endif
    }

    Countdown[0] = 0;

    LoadIdentifier[0] = 0;
    SystemPartition[0] = 0;
    OsLoader[0] = 0;
    OsLoadPartition[0] = 0;
    OsLoadFilename[0] = 0;
    OsLoadOptions[0] = 0;

    DefaultOsLoadOptions[0] = 0;
    DefaultOsLoadPartition[0] = 0;
    DefaultSystemPartition[0] = 0;

    linenum = 0;

    while ( TRUE ) {

        //
        // Get the next line from the input stream.
        //

        linenum++;

        build = fgets( Line, MAXLINESIZE, file );
        if ( build == NULL ) {
            if ( feof(file) ) break;
            fprintf( stderr, "Error %d reading input at line %d\n", ferror(file), linenum );
            return ferror(file);
        }

        build = Trim( build );
        len = strlen( build );

        //
        // Ignore blank lines and lines that start with //.
        //

        if ( len == 0 ) continue;
        if ( (build[0] == '/') && (build[1] == '/') ) continue;
        if ( build[len-1] != '\n' ) {
            fprintf( stderr, "Line %d is too long; %d characters max\n", linenum, MAXLINESIZE-2 );
            return 1;
        }
        if ( len == 1 ) continue;
        build[len-1] = 0;

        //
        // Check for the special "countdown" line.  If found, save the countdown value.
        //

        if ( strstr(build,"countdown=") == build ) {
            strcpy( Countdown, strchr(build,'=') + 1 );
            continue;
        }

        //
        // Check for the special "default systempartition" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default systempartition=") == build ) {
            strcpy( DefaultSystemPartition, Trim( strchr(build,'=') + 1 ) );
            continue;
        }

        //
        // Check for the special "default osloadpartition" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default osloadpartition=") == build ) {
            strcpy( DefaultOsLoadPartition, Trim( strchr(build,'=') + 1 ) );
            continue;
        }

        //
        // Check for the special "default options" line.  If found, save the
        // default string.
        //

        if ( strstr(build,"default options=") == build ) {
            strcpy( DefaultOsLoadOptions, Trim( strchr(build,'=') + 1 ) );
            strcat( DefaultOsLoadOptions, " " );
            continue;
        }

        //
        // OK, we should have an OS load line.  Required format is:
        //
        //   <ident>[|<sys-dir>][|<os-dir>][<dir>][|<options>][|<sys-part>][|<os-part>][|<loader>]
        //
        // Everything after <ident> is optional and may be specified in any order.
        //
        // <sys-dir> defines the directory path to the osloader/hal directory.
        // <os-dir>  defines the directory path to the OS directory.
        // The default value for both of these fields is <ident>.
        // <dir> sets both <sys-dir> and <os-dir>.
        //
        // <sys-part> and <os-part> are optional only if the corresponding defaults
        // have been specified.
        //
        // <loader> is used to override the selection of osloader.exe as the OS loader.
        //
        // <sys-dir>  format is sysdir=<directory path (no leading \)>
        // <os-dir>   format is osdir=<directory path (no leading \)>
        // <dir>      format is dir=<directory path (no leading \)>
        // <options>  format is options=<text of options>
        // <sys-part> format is syspart=<partition specification>
        // <os-part>  format is ospart=<partition specification>
        // <loader>   format is loader=<filename>
        //

        //
        // Get the load-identifier.
        //

        ident = Trim( strtok( build, SEPARATOR ) );

        //
        // Set defaults for optional fields.
        //

        osdir = ident;
        sysdir = ident;
        options = DefaultOsLoadOptions;
        syspart = DefaultSystemPartition;
        ospart = DefaultOsLoadPartition;
        loader = "osloader.exe";

        //
        // Get optional fields.
        //

        while ( (token = strtok( NULL, SEPARATOR )) != NULL ) {

            token = Trim( token );

            if ( strstr(token,"sysdir=") == token ) {

                sysdir = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"osdir=") == token ) {

                osdir = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"dir=") == token ) {

                sysdir = Trim( strchr(token,'=') + 1 );
                osdir = sysdir;

            } else if ( strstr(token,"options=") == token ) {

                //
                // If the options do not start with "nodef", preface the
                // default options (if any) to the specified options.
                //

                options = Trim( strchr(token,'=') + 1 );
                if ( _strnicmp(options,"nodef",5) == 0 ) {
                    options = options+5;
                } else {
                    strcpy( options1, DefaultOsLoadOptions );
                    strcat( options1, options );
                    options = options1;
                }

            } else if ( strstr(token,"syspart=") == token ) {

                syspart = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"ospart=") == token ) {

                ospart = Trim( strchr(token,'=') + 1 );

            } else if ( strstr(token,"loader=") == token ) {

                loader = Trim( strchr(token,'=') + 1 );

            } else {

                //
                // Unrecognized optional field.
                //

                fprintf( stderr, "Unreconized optional field at line %d\n", linenum );
                return 1;

            }

        } // while

        //
        // Verify the validity of the input fields.
        //

        if ( strlen(ident) == 0 ) {
            fprintf( stderr, "Bad <load-identifier> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(sysdir) == 0 ) {
            fprintf( stderr, "Bad <system-directory> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(osdir) == 0 ) {
            fprintf( stderr, "Bad <os-directory> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(syspart) == 0 ) {
            fprintf( stderr, "Missing <system-partition> (no default) at line %d\n", linenum );
            return 1;
        }
        if ( strlen(ospart) == 0 ) {
            fprintf( stderr, "Missing <os-partition> (no default) at line %d\n", linenum );
            return 1;
        }
        if ( !ParsePartition(syspart, syspart1) ) {
            fprintf( stderr, "Bad <system-partition> at line %d\n", linenum );
            return 1;
        }
        if ( !ParsePartition(ospart, ospart1) ) {
            fprintf( stderr, "Bad <os-partition> at line %d\n", linenum );
            return 1;
        }
        if ( strlen(loader) == 0 ) {
            fprintf( stderr, "Bad <loader> at line %d\n", linenum );
            return 1;
        }

        //
        // If this is not the first load line, append ';' to all of the NVRAM strings.
        //

        if ( strlen(LoadIdentifier) != 0 ) {
            strcat( LoadIdentifier, ";" );
            strcat( SystemPartition, ";" );
            strcat( OsLoader, ";" );
            strcat( OsLoadPartition, ";" );
            strcat( OsLoadFilename, ";" );
            strcat( OsLoadOptions, ";" );
        }

        //
        // Append this load line to the NVRAM strings.
        //

        strcat( LoadIdentifier, ident );

        strcat( SystemPartition, syspart1 );

        strcat( OsLoader, syspart1 );
        if ( loader[0] != '\\' ) {
            strcat( OsLoader, "\\" );
            strcat( OsLoader, sysdir );
            strcat( OsLoader, "\\" );
        }
        strcat( OsLoader, loader );

        strcat( OsLoadPartition, ospart1 );

        strcat( OsLoadFilename, "\\" );
        strcat( OsLoadFilename, osdir );

        strcat( OsLoadOptions, options );
        Trim( OsLoadOptions );

    }

    //
    // Write the necessary nvram.exe commands to the output stream.
    //

    if ( Countdown[0] != 0 ) {
        fprintf( stdout, "nvram /set COUNTDOWN = \"%s\"\n", Countdown );
    }
    fprintf( stdout, "nvram /set LOADIDENTIFIER = \"%s\"\n", LoadIdentifier );
    fprintf( stdout, "nvram /set SYSTEMPARTITION = \"%s\"\n", SystemPartition );
    fprintf( stdout, "nvram /set OSLOADER = \"%s\"\n", OsLoader );
    fprintf( stdout, "nvram /set OSLOADPARTITION = \"%s\"\n", OsLoadPartition );
    fprintf( stdout, "nvram /set OSLOADFILENAME = \"%s\"\n", OsLoadFilename );
    fprintf( stdout, "nvram /set OSLOADOPTIONS = \"%s\"\n", OsLoadOptions );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\packer\packer.c ===
/* ************************************************************ *
 *
 *  'Packer.C
 *
 *  Packer.C is a tool that packages the structure and data within
 *  a given directory into two C header files.  Currently this tool
 *  is specific for the WorkGroup PostOffice.  If there is some
 *  interest in making this tool more general, I would be happy
 *  to make it so, time permitting.
 *
 * ************************************************************ */
#include <windows.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma pack(1)

/* ************************************************************ *
 *
 *  Constants and definitions
 *
 * ************************************************************ */

#define rgbMaxBuffer        16 * 1024

#define crgMaxFile          256
#define cchMaxFile          64

#define szCR                "\n"

typedef int FO;

#define FO_Open             101
#define FO_Write            102
#define FO_Close            103


/* ************************************************************ *
 *
 *  Function prototypes
 *
 * ************************************************************ */

int EcTravelDir(char *);
int EcFileInfo(FO, char *);
int EcFileData(FO, char *);

/* ************************************************************ *
 *
 *  Global variables
 *
 * ************************************************************ */

// Store file info
char    rgszFile[crgMaxFile][cchMaxFile];
int     rgFileState[crgMaxFile];

// Store file data
unsigned char    rgbBuffer[rgbMaxBuffer];


/* ************************************************************ *
 *
 *  void 'Main
 *
 *  In:     int cArg            Count of arguments
 *  In:     char *rgszArg[]     Argument string array
 *
 *  Main returns void.
 *
 *  Main checks if the command-line arguments are valid.
 *  If so, it calls EcTravelDir to pack the given directory.
 *
 *  Main causes no side-effects.
 *
 *  Main indicates any error with a message to stdout.
 *
 * ************************************************************ */

void
__cdecl
main(
    int cArg,
    char *rgszArg[]
    )
{
    int     ec = 0;

    // Check count of command-line arguments
    if (cArg != 2) {
        printf("USAGE: packer [directory]\n");
        exit(EXIT_FAILURE);
    }

    if (EcTravelDir(rgszArg[1]) != 0)
        exit(EXIT_FAILURE);

    exit(EXIT_SUCCESS);

}

/* ************************************************************ *
 *
 *  int 'EcTravelDir
 *
 *  In:     char *szTravelDir       Directory to pack
 *
 *  EcTravelDir returns a standard exit code.
 *
 *  EcTravelDir packages the directory structure and all files
 *  within the given directory into two C header files.  The
 *  directory tree is travelled in a current node, "low" branch,
 *  "high" branch pattern.  This means the files and sub-directories
 *  of the current directory are enumerated and saved, then the
 *  sub-directories are traversed from the lowest to the highest
 *  as they appear in the directory list.  Directory structure
 *  info is handled by EcFileInfo while file data is handled by
 *  EcFileData.
 *
 *  EcTravelDir causes a disk side-effect.
 *
 *  EcTravelDir indicates any error via the exit code.
 *
 * ************************************************************ */

int
EcTravelDir(
    char *szTravelDir
    )
{
    int     ec = 0;

    int     iFile = 0;
    int     iFileParent;

    char    szFile[cchMaxFile]     = "";
    char    szDir[cchMaxFile]      = "";

    char    szDrive[_MAX_DRIVE]    = "";
    char    szPath[_MAX_DIR]       = "";
    char    szFileName[_MAX_FNAME] = "";
    char    szFileExt[_MAX_EXT]    = "";

    int     ixType;
    long    lcbxFile;
    char    szxFile[cchMaxFile];

    unsigned short us;
    HANDLE  hdir;
    WIN32_FIND_DATA     findbuf;

    _splitpath(szTravelDir, szDrive, szPath, szFileName, szFileExt);
    _makepath(szDir, "", szPath, szFileName, szFileExt);
    if (szDir[strlen(szDir)-1] != '\\')
        strcat(szDir, "\\");

    // *** Open header files ***
    ec = EcFileInfo(FO_Open, "_fileinf.h");
    if (ec != 0)
        goto RET;

    ec = EcFileData(FO_Open, "_filedat.h");
    if (ec != 0)
        goto RET;

    // *** Traverse directory tree ***

    // Initial directory
    strcpy(rgszFile[0], "");
    rgFileState[0] = '\0';

    while (1) {
        if (rgFileState[iFile] == 0) {
            // Keep track of parent directory
            rgFileState[iFile] = 1;
            iFileParent = iFile;

            // Prepare szFile and hdir
            strcpy(szFile, szDrive);
            strcat(szFile, szDir);
            strcat(szFile, rgszFile[iFile]);
            strcat(szFile, "*.*");

            // Skip . entry
            hdir = FindFirstFile(szFile, &findbuf);
            if (hdir == INVALID_HANDLE_VALUE) {
                ec = 1;
                goto CLOSE;
            }

            // Skip .. entry
            //FindNextFile(hdir, &findbuf);

            // *** Enumerate current directory ***

            while (1) {
                if(!FindNextFile(hdir, &findbuf) &&
                    GetLastError() == ERROR_NO_MORE_FILES)
                        break;

                //
                //  Skip over any file that begins with '.'.
                //
                if (findbuf.cFileName[0] == '.')
                    continue;

                //
                //  Skip over hidden and system files.
                //
                if (findbuf.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM))
                    continue;

                // *** Set file info data ***

                if (findbuf.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    iFile += 1;
                    strcpy(rgszFile[iFile], rgszFile[iFileParent]);
                    strcat(rgszFile[iFile], findbuf.cFileName);
                    strcat(rgszFile[iFile], "\\");
                    rgFileState[iFile] = 0;
                    ixType = 0;
                    lcbxFile = 0;
                    strcpy(szxFile, rgszFile[iFile]);
                } else {
                    ixType = 1;
                    lcbxFile = findbuf.nFileSizeLow;
                    strcpy(szxFile, rgszFile[iFileParent]);
                    strcat(szxFile, findbuf.cFileName);
                }

                // *** Write file info ***
                sprintf(szFile, "%d, %4ld, \"%s\"," szCR,
                    ixType, lcbxFile, szxFile);
                ec = EcFileInfo(FO_Write, szFile);
                if (ec != 0)
                    goto CLOSE;

                if (lcbxFile == 0)
                    continue;

                // *** Write file data ***
                strcpy(szFile, szDrive);
                strcat(szFile, szDir);
                strcat(szFile, szxFile);
                ec = EcFileData(FO_Write, szFile);
                if (ec != 0)
                    goto CLOSE;
            }
        } else {
            iFile -= 1;
        }

        if (iFile == 0)
            break;
    }

CLOSE:
    EcFileInfo(FO_Close, "");
    EcFileData(FO_Close, "");

RET:
    if (ec != 0) {
        printf("ERROR: Disk error %d\n", ec);
        remove("_fileinf.h");
        remove("_filedat.h");
    }

    return ec;

}


/* ************************************************************ *
 *
 *  int 'EcFileInfo
 *
 *  In:     FO foType           File operation
 *  In:     char *szFileInfo    File name or data string
 *
 *  EcFileInfo returns a standard exit code.
 *
 *  EcFileInfo opens, writes, and closes the directory structure
 *  header file.  The info is saved in an array of type HDR.
 *  The array is rghdrFile and the constant chdrFile counts the
 *  number of elements in the array.
 *
 *  EcFileInfo causes a disk side-effect.
 *
 *  EcFileInfo indicates any error via the exit code.
 *
 * ************************************************************ */

int
EcFileInfo(
    FO foType,
    char *szFileInfo
    )
{
    int ec = 0, dos;
    char szT[cchMaxFile] = "";
    int iszT;

    static FILE *hfFileInfo;
    static int chdrFileInfo;

    unsigned iszFileInfo;

    switch (foType) {
        case FO_Open:
            // Open szFileInfo file
            hfFileInfo = fopen(szFileInfo, "wt");
            if (hfFileInfo == NULL) {
                printf("ERROR: Can't open %s\n", szFileInfo);
                exit(EXIT_FAILURE);
            }

            // Open rghdrFile declaration and set chdFileInfo to 0
            fprintf(hfFileInfo, szCR);
            fprintf(hfFileInfo, "static CSRG(HDR) rghdrFile[] =" szCR);
            fprintf(hfFileInfo, "{" szCR);
            chdrFileInfo = 0;

            break;

        case FO_Write:
            // Double every backlash in szFileInfo
            for (iszFileInfo = 0, iszT = 0; iszFileInfo < strlen(szFileInfo);
                iszFileInfo += 1)
            {
                szT[iszT++] = szFileInfo[iszFileInfo];
                if (szFileInfo[iszFileInfo] == '\\') szT[iszT++] = '\\';
            }
            szT[iszT] = '\0';

            // Write file info
            fwrite(szT, sizeof(char), iszT, hfFileInfo);
            chdrFileInfo += 1;
            break;

        case FO_Close:
            // Close rghdrFile definition and set chdrFile
            fprintf(hfFileInfo, szCR);
            fprintf(hfFileInfo, "// END" szCR);
            fprintf(hfFileInfo, szCR);
            fprintf(hfFileInfo, "0,    0, \"\"" szCR);
            fprintf(hfFileInfo, szCR);
            fprintf(hfFileInfo, "}; // rghdrFile" szCR);
            fprintf(hfFileInfo, szCR);
            fprintf(hfFileInfo, "#define chdrFile %d" szCR, chdrFileInfo);
            fprintf(hfFileInfo, szCR);

            // Close szFileInfo
            dos = fclose(hfFileInfo);
            assert(dos == 0);
            break;

        default:
            printf("ERROR: Unknown EcFileInfo foType %d\n", foType);
            break;

    }
    return ec;
}


/* ************************************************************ *
 *
 *  int 'EcFileData
 *
 *  In:     FO foType           File operation
 *  In:     char *szFileData    File name or data string
 *
 *  EcFileData returns a standard exit code.
 *
 *  EcFileData opens, writes, and closes the file data header
 *  file.  The file data is saved in an array of char (bytes).
 *  The array is named rgbFile and the constant cbFile counts
 *  the number of elements in the array.
 *
 *  EcFileData causes a disk side-effect.
 *
 *  EcFileData indicates any error via the exit code.
 *
 * ************************************************************ */

int
EcFileData(
    FO foType,
    char *szFileData
    )
{
    int ec = 0, dos;
    int fContinue;

    static FILE *hfFileData;
    static int cbFileData;

    FILE *hfSourceFile;
    long lcbRead;

    long ibBuffer, ibOffset, cbOffset;

    switch (foType) {
        case FO_Open:
            // Open szFileData file
            hfFileData = fopen(szFileData, "wt");
            if (hfFileData == NULL) {
                printf("ERROR: Can't open %s\n", szFileData);
                exit(EXIT_FAILURE);
            }

            // Write rgbFile declaration and set cbFiledata to 0
            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "static CSRG(unsigned char) rgbFile[] =" szCR);
            fprintf(hfFileData, "{" szCR);
            cbFileData = 0;
            break;

        case FO_Write:
            // Open source file
            hfSourceFile = fopen(szFileData, "rb");
            if (!hfSourceFile) {
                break;
            }

            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "// %s" szCR, szFileData);
            fprintf(hfFileData, szCR);

            // Write file data
            fContinue = 1;
            while (fContinue == 1) {
                // Read source file
                lcbRead = fread(rgbBuffer, sizeof(char),
                    rgbMaxBuffer, hfSourceFile);
                assert(ferror(hfSourceFile) == 0);

                if (feof(hfSourceFile) != 0) fContinue = 0;

                // Write target file
                for (ibBuffer = 0; ibBuffer < lcbRead; ibBuffer += 16) {
                    cbOffset = min((long) 16, lcbRead-ibBuffer);
                    for (ibOffset = 0; ibOffset < cbOffset; ibOffset += 1) {
                        fprintf(hfFileData, "%3u, ",
                            rgbBuffer[ibBuffer+ibOffset]);
                        cbFileData += 1;
                    }
                    fprintf(hfFileData, szCR);
                }
            }

            // Close source file
            dos = fclose(hfSourceFile);
            assert(dos == 0);
            break;

        case FO_Close:
            // Close rgbFile definition and set cbFile
            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "// END" szCR);
            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "000" szCR);
            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "}; // rgbFile" szCR);
            fprintf(hfFileData, szCR);
            fprintf(hfFileData, "#define cbFile %d" szCR, cbFileData);
            fprintf(hfFileData, szCR);

            // Close szFileData
            dos = fclose(hfFileData);
            assert(dos == 0);
            break;

        default:
            printf("ERROR: Unknown EcFileData foType %d\n", foType);
            break;

    }
    return ec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\objdir\objdir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    obdir.c

Abstract:

    Utility to obtain a directory of Object Manager Directories for NT.

Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:


--*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <malloc.h>
#include <ntlsa.h>

#define BUFFERSIZE 1024
#define Error(N,S) {                \
    printf(#S);                    \
    printf(" Error %08lX\n", S);   \
    }

typedef struct _TYPEINFO {
    PWSTR       pszName;
    char * *    AccessRights;
    DWORD       NumberRights;
} TYPEINFO, * PTYPEINFO;


////////////////////////////////////////////////////////
//                                                    //
//          Internal Prototypes                       //
//                                                    //
////////////////////////////////////////////////////////

BOOLEAN
EnableAllPrivileges(
    VOID
    );

VOID
QueryDirectory(
    IN PSTRING DirectoryName
    );

NTSTATUS
OpenObject(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name,
    IN  ACCESS_MASK       DesiredAccess,
    OUT PHANDLE           Object
    );

VOID
OpenAndDisplaySacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    );

VOID
QueryAndDisplaySacl(
    IN  HANDLE              Object,
    IN  PWSTR               Type

    );

NTSTATUS
DisplaySacl(
    PSECURITY_DESCRIPTOR SD,
    IN PWSTR Type
    );

VOID
OpenAndDisplayDacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    );

VOID
QueryAndDisplayDacl(
    IN  HANDLE              Object,
    IN  PWSTR               Type
    );

NTSTATUS
DisplayDacl(
    PSECURITY_DESCRIPTOR SD,
    IN PWSTR Type
    );

VOID
DumpAce(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    );

VOID
DumpStandardAceInfo(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    );

VOID
DisplaySid(
    IN  PSID        Sid
    );

VOID
ConnectToLsa( VOID );

VOID
Usage( VOID );


////////////////////////////////////////////////////////
//                                                    //
//          Global Variables                          //
//                                                    //
////////////////////////////////////////////////////////


UCHAR
    Buffer[BUFFERSIZE];


LSA_HANDLE
    LsaHandle;

BOOLEAN
    CompoundLineOutput = FALSE;
    DumpDacl = FALSE;       // May be changed by command parameter
    DumpDaclFull = FALSE;   // May be changed by command parameter
    DumpSacl = FALSE;       // May be changed by command parameter
    DumpSaclFull = FALSE;   // May be changed by command parameter


char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef" };

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };


#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_MAX        20

LPWSTR   pszTypeNames[TYPE_MAX] = { L"None", L"Event", L"Section", L"File",
                                L"Port", L"Directory", L"SymbolicLink",
                                L"Mutant", L"WindowStation", L"Semaphore",
                                L"Key", L"Token", L"Process", L"Thread",
                                L"Desktop", L"IoCompletion", L"Channel",
                                L"Timer", L"Job", L"WaitablePort" };



TYPEINFO TypeNames[TYPE_MAX] = {
    { L"Unknown", NULL, 0 },
    { L"Event", EventRights, 2 },
    { L"Section", SectionRights, 5 },
    { L"File", FileRights, 9 },
    { L"Port", PortRights, 1 },
    { L"Directory", DirRights, 4 },
    { L"SymbolicLink", SymLinkRights, 1 },
    { L"Mutant", MutantRights, 2 },
    { L"WindowStation", WinstaRights, 10 },
    { L"Semaphore", SemaphoreRights, 2 },
    { L"Key", KeyRights, 6 },
    { L"Token", TokenRights, 8 },
    { L"Process", ProcessRights, 12 },
    { L"Thread", ThreadRights, 10 },
    { L"Desktop", DesktopRights, 10 },
    { L"IoCompletion", CompletionRights, 2 },
    { L"Channel", ChannelRights, 4 },
    { L"Timer", TimerRights, 2 },
    { L"Job", JobRights, 5 },
    { L"WaitablePort", PortRights, 1 }
    };


DWORD
GetObjectTypeIndex(
    PWSTR    TypeName )
{
    DWORD   i;


    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_wcsicmp( TypeNames[i].pszName, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( 0 );
}

VOID 
DisplayFlags(  
    ULONG       Flags,
    ULONG       FlagLimit,
    char        *flagset[],
    ULONG       Indent,
    ULONG       LineBreak,
    ULONG       BufferSize,
    UCHAR *     buffer)
{
   char *         offset;
   char *         limit ;
   char *         linelimit ;
   DWORD          mask, test, i, flagsize ;
   DWORD          scratch;


   if ( LineBreak > BufferSize )
   {
       strcpy( (CHAR *)buffer, "Invalid Parameter");
       
       return;
   }

   mask = 0;
   offset = (CHAR *) buffer;
   test = 1;

   limit = offset + BufferSize ;

   if ( LineBreak )
   {
       linelimit = offset + LineBreak ;
   }
   else
   {

       linelimit = limit ;
   }

   if ( linelimit > limit )
   {
       linelimit = limit ;
       
   }

   memset(offset, ' ', Indent);
   offset += Indent ;

   if (!Flags) {
      strcpy( offset, "None");
      return;
   }

   for ( i = 0 ; i < FlagLimit ; i++ )
   {
       if ( ( Flags & test ) != 0 )
       {
           //
           // Found a flag set in the flag word.  Try to write the text
           // form into the buffer
           //

           flagsize = strlen( flagset[ i ] );

           if ( offset + flagsize + 2 > limit )
           {
               return;
           }

           if ( offset + flagsize + 2 > linelimit )
           {
               //
               // Need to do a linebreak:
               //

               *offset++ = '\r';
               *offset++ = '\n';

               if ( LineBreak )
               {
                   linelimit = offset + LineBreak ;
               }
               else
               {

                   linelimit = limit ;
               }

               if ( linelimit > limit )
               {
                   linelimit = limit ;

               }

               memset(offset, ' ', Indent);
               offset += Indent ;

               if ( offset + flagsize + 2 > linelimit )
               {
                   *offset++ = '\0';
                   return;
                   
               }
           }

           CopyMemory( offset, flagset[ i ], flagsize );

           offset += flagsize ;

           mask |= test;

           if ( ( Flags & (~mask) ) != 0 )
           {
               *offset++ = ' ' ;
               
           }
           
       }

       test <<= 1 ;
       
   }

   *offset = '\0';

}


////////////////////////////////////////////////////////
//                                                    //
//          Routines                                  //
//                                                    //
////////////////////////////////////////////////////////


VOID
__cdecl main(
    int argc,
    char *argv[]
    )
{

    STRING
        String;

    int
        arg;

    char
        *s;

    BOOLEAN
        DirectoryNameArg;




    //
    // process any qualifiers
    //
    // All arguments are considered qualifiers until we reach a backslash ("\").
    // If we reach a backslash, then that argument is accepted as the last argument
    // and it is expected to the the name of the directory to be listed.
    //


    DirectoryNameArg = FALSE;
    arg = 1;
    while (arg < argc) {

        s = argv[arg];

        if (*s == '\\') {
            DirectoryNameArg = TRUE;
            break;  // break out of while loop
        }

        if (*s != '/') {
            Usage();
            return;
        }
        s++;

        if (*s == 'd') {

            //
            // Dump DACL qualifier
            //

            if (DumpDaclFull == TRUE) {
                printf("\n\n    Conflicting qualifiers:  /d and /D\n");
                Usage();
                return;
            }
            DumpDacl = TRUE;
            DumpDaclFull = FALSE;
            CompoundLineOutput = TRUE;


        } else if (*s == 'D') {

            //
            // Dump DACL qualifier
            //

            if ((DumpDacl== TRUE) && (DumpDaclFull == FALSE)) {
                printf("\n\n    Conflicting qualifiers:  /d and /D\n");
                Usage();
                return;
            }
            DumpDacl = TRUE;
            DumpDaclFull = TRUE;
            CompoundLineOutput = TRUE;

        } else if (*s == 's') {

            //
            // Dump SACL qualifier
            //

            if (DumpSaclFull == TRUE) {
                printf("\n\n    Conflicting qualifiers:  /s and /S\n");
                Usage();
                return;
            }
            DumpSacl = TRUE;
            DumpSaclFull = FALSE;
            CompoundLineOutput = TRUE;


        } else if (*s == 'S') {

            //
            // Dump SACL qualifier
            //

            if ((DumpSacl== TRUE) && (DumpSaclFull == FALSE)) {
                printf("\n\n    Conflicting qualifiers:  /s and /S\n");
                Usage();
                return;
            }
            DumpSacl = TRUE;
            DumpSaclFull = TRUE;
            CompoundLineOutput = TRUE;


        } else {

            Usage();
            return;
        }

        arg++;
    } // end_while

    if (DumpDacl || DumpSacl) {
        ConnectToLsa();
    }

    //
    // Set up the name of the directory to list
    //


    if (!DirectoryNameArg) {
        RtlInitString( &String, "\\" );
    } else {
        RtlInitString( &String, argv[arg] );
    }


    if (EnableAllPrivileges()) {
        QueryDirectory( &String );
    }
}


WCHAR LinkTargetBuffer[ 1024 ];

typedef struct _DIR_ENTRY {
    PWSTR Name;
    PWSTR Type;
} DIR_ENTRY, *PDIR_ENTRY;

#define MAX_DIR_ENTRIES 1024
ULONG NumberOfDirEntries;
DIR_ENTRY DirEntries[ MAX_DIR_ENTRIES ];


int
__cdecl
CompareDirEntry(
    void const *p1,
    void const *p2
    )
{
    return _wcsicmp( ((PDIR_ENTRY)p1)->Name, ((PDIR_ENTRY)p2)->Name );
}


VOID
QueryDirectory(
    IN PSTRING DirectoryName
    )
//
// DumpDacl and DumpSacl are expected to be set prior to calling this routine.
//

{
    NTSTATUS Status;
    HANDLE DirectoryHandle, LinkHandle;
    ULONG Context = 0;
    ULONG i, ReturnedLength;
    UNICODE_STRING LinkTarget;

    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;
    ACCESS_MASK ExtraAccess = 0;
    UNICODE_STRING Match = { 0 };
    UNICODE_STRING Separators = { 0 };
    USHORT Offset ;
    ULONG DisplayedEntries = 0 ;
    BOOLEAN PrefixMatch = FALSE ;
    BOOLEAN SuffixMatch = FALSE ;
    ULONG ObjectNameLength ;
    BOOL PrefixMatched, SuffixMatched ;



    //
    //  Perform initial setup
    //

    RtlZeroMemory( Buffer, BUFFERSIZE );

    if (DumpDacl) {
        ExtraAccess |= READ_CONTROL;
    }
    if (DumpSacl) {
        ExtraAccess |= ACCESS_SYSTEM_SECURITY;
    }


    //
    //  Open the directory for list directory access
    //

    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           DirectoryName,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    Status = NtOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY | ExtraAccess,
                                    &Attributes
                                  );

    if ( ( Status == STATUS_OBJECT_TYPE_MISMATCH ) ||
         ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) ||
         ( Status == STATUS_OBJECT_PATH_NOT_FOUND ) ) {

        RtlInitUnicodeString( &Separators, L"\\" );

        Status = RtlFindCharInUnicodeString(
                    RTL_FIND_CHAR_IN_UNICODE_STRING_START_AT_END,
                    &UnicodeString,
                    &Separators,
                    &Offset );

        if ( NT_SUCCESS( Status ) )
        {
            UnicodeString.Length = Offset ;
            RtlInitUnicodeString( &Match, UnicodeString.Buffer + ((Offset + 2) / sizeof( WCHAR ) ) );

            if ( Match.Buffer[ 0 ] == L'*' )
            {
                Match.Buffer++ ;
                Match.Length -= sizeof( WCHAR );
                SuffixMatch = TRUE ;
                
            }

            if ( Match.Buffer[ Match.Length / sizeof( WCHAR ) - 1 ] == L'*' )
            {
                Match.Buffer[ Match.Length / sizeof( WCHAR ) - 1 ] = L'\0';
                Match.Length -= sizeof( WCHAR );
                PrefixMatch = TRUE ;
                
            }

            if ( PrefixMatch && SuffixMatch )
            {
                printf("Too complicated a search\n" );
                return;
                
            }
#if DBG
            printf("Searching for %c%ws%c\n",
                (SuffixMatch ? '*' : ' '), Match.Buffer, (PrefixMatch ? '*' : ' ') );
#endif 

            Status = NtOpenDirectoryObject( &DirectoryHandle,
                                            DIRECTORY_QUERY | ExtraAccess,
                                            &Attributes );

        }


    }

    if (!NT_SUCCESS( Status )) {


        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {

            printf( "%Z is not a valid Object Directory Object name\n",
                    DirectoryName );
            }
        else {
            Error( OpenDirectory, Status );
            }

        return;
        }

    //
    // Get the actual name of the object directory object.
    //

    NameInfo = (POBJECT_NAME_INFORMATION) &Buffer[0];
    if (!NT_SUCCESS( Status = NtQueryObject( DirectoryHandle,
                                             ObjectNameInformation,
                                             NameInfo,
                                             BUFFERSIZE,
                                             (PULONG) NULL ) )) {
        printf( "Unexpected error obtaining actual object directory name\n" );
        printf( "Error was:  %X\n", Status );
        return;
    }

    //
    // Output initial informational message
    //

    printf( "Directory of:  %wZ\n", &NameInfo->Name );

    if ( Match.Length == 0 )
    {
        if (DumpDacl) {
            QueryAndDisplayDacl( DirectoryHandle, L"Directory" );
        }
        if (DumpSacl) {
            QueryAndDisplaySacl( DirectoryHandle, L"Directory" );
        }
        printf( "\n" );
        
    }

    //
    //  Query the entire directory in one sweep
    //

    NumberOfDirEntries = 0;
    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_FILES) {
                Error( Status, Status );
            }
            break;
        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

        while (TRUE) {

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }

            //
            //  Print out information about the file
            //

            if (NumberOfDirEntries >= MAX_DIR_ENTRIES) {
                printf( "OBJDIR: Too many directory entries.\n" );
                exit( 1 );
                }

            DirEntries[ NumberOfDirEntries ].Name = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->Name.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );
            DirEntries[ NumberOfDirEntries ].Type = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->TypeName.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );
            memmove( DirEntries[ NumberOfDirEntries ].Name,
                     DirInfo->Name.Buffer,
                     DirInfo->Name.Length
                   );
            memmove( DirEntries[ NumberOfDirEntries ].Type,
                     DirInfo->TypeName.Buffer,
                     DirInfo->TypeName.Length
                   );

            NumberOfDirEntries++;

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );

        }

        RtlZeroMemory( Buffer, BUFFERSIZE );

    }


    qsort( DirEntries,
           NumberOfDirEntries,
           sizeof( DIR_ENTRY ),
           CompareDirEntry
         );
    for (i=0; i<NumberOfDirEntries; i++) {

        if ( Match.Length )
        {
            ObjectNameLength = wcslen( DirEntries[ i ].Name );

            if ( PrefixMatch )
            {
                PrefixMatched = _wcsnicmp( DirEntries[ i ].Name,
                                           Match.Buffer,
                                           Match.Length / sizeof( WCHAR ) ) == 0 ;
                
            }

            if ( SuffixMatch )
            {
                if ( ObjectNameLength >= Match.Length / sizeof( WCHAR ) )
                {
                    SuffixMatched = 
                        _wcsnicmp( DirEntries[ i ].Name + ( ObjectNameLength - (Match.Length / sizeof( WCHAR ) )),
                                   Match.Buffer,
                                   Match.Length / sizeof( WCHAR) ) == 0 ;
                    
                }
                else 
                {
                    SuffixMatched = FALSE ;
                }
                
            }

            if ( SuffixMatch && !SuffixMatched )
            {
                continue;
            } 

            if ( PrefixMatch && !PrefixMatched )
            {
                continue;
            }

            if ( (!SuffixMatch) && (!PrefixMatch) &&
                 _wcsicmp( Match.Buffer, DirEntries[ i ].Name ) )
            {
                continue;
                
            }
            
        }

        DisplayedEntries++ ;

        printf( "%-32ws ", DirEntries[ i ].Name);
        if (CompoundLineOutput) {
            printf("\n    ");
        }
        printf( "%ws", DirEntries[ i ].Type );

        if (!wcscmp( DirEntries[ i ].Type, L"SymbolicLink" )) {
            RtlInitUnicodeString( &UnicodeString, DirEntries[ i ].Name );
            InitializeObjectAttributes( &Attributes,
                                        &UnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        DirectoryHandle,
                                        NULL );
            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes
                                             );
            if (NT_SUCCESS( Status )) {
                LinkTarget.Buffer = LinkTargetBuffer;
                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof( LinkTargetBuffer );
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &LinkTarget,
                                                    NULL
                                                  );
                NtClose( LinkHandle );
                }

            if (!NT_SUCCESS( Status )) {
                printf( " - unable to query link target (Status == %09X)\n", Status );
                }
            else {
                printf( " - %wZ\n", &LinkTarget );
                }
            }
        else {
            printf( "\n" );
            }

        if (DumpDacl) {
            OpenAndDisplayDacl( DirectoryHandle, DirEntries[ i ].Type, DirEntries[ i ].Name);
            }
        if (DumpSacl) {
            OpenAndDisplaySacl( DirectoryHandle, DirEntries[ i ].Type, DirEntries[ i ].Name);
            }
        }

    //
    // Output final messages
    //

    if ( Match.Length != 0 )
    {
        if ( DisplayedEntries == 0 )
        {
            printf("not found\n" );
            
        }
        else if ( DisplayedEntries == 1 )
        {
            printf("\n1 entry\n" );
            
        }
        else 
        {

            printf("\n%ld entries\n", DisplayedEntries );
        }
        
    }
    else 
    {

        if (NumberOfDirEntries == 0) {
            printf( "no entries\n" );
            }
        else
        if (NumberOfDirEntries == 1) {
            printf( "\n1 entry\n" );
            }
        else {
            printf( "\n%ld entries\n", NumberOfDirEntries );
            }


    }


    //
    //  Now close the directory object
    //

    (VOID) NtClose( DirectoryHandle );

    //
    //  And return to our caller
    //

    return;

}


BOOLEAN
EnableAllPrivileges(
    VOID
    )
/*++


Routine Description:

    This routine enables all privileges in the token.

    If we are being asked to dump SACLs then we will check
    to make sure we have SE_SECURITY_PRIVILEGE enabled too.


Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE Token;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState;
    BOOLEAN Result;
    LUID SecurityPrivilege;

    SecurityPrivilege =
        RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);

    Token = NULL;
    NewState = NULL;

    Result = (OpenProcessToken( GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &Token
                              ) ? 1 : 0);
    if (Result) {
        ReturnLength = 4096;
        NewState = malloc( ReturnLength );
        Result = (BOOLEAN)(NewState != NULL);
        if (Result) {
            Result = (GetTokenInformation( Token,            // TokenHandle
                                           TokenPrivileges,  // TokenInformationClass
                                           NewState,         // TokenInformation
                                           ReturnLength,     // TokenInformationLength
                                           &ReturnLength     // ReturnLength
                                         ) ? 1 : 0);

            if (Result) {
                //
                // Set the state settings so that all privileges are enabled...
                //

                if (DumpSacl) {
                    Result = FALSE;
                    }

                if (NewState->PrivilegeCount > 0) {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++ ) {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                        if (RtlEqualLuid(&NewState->Privileges[Index].Luid, &SecurityPrivilege )) {
                            Result = TRUE;
                            }
                        }
                    }
                if (!Result) {
                    // Don't have privilege to dump SACL
                    ASSERT(DumpSacl);

                    printf("\n\n    You do not have sufficient privilege to display SACLs.\n\n");
                    }
                else {
                    Result = (AdjustTokenPrivileges( Token,          // TokenHandle
                                                     FALSE,          // DisableAllPrivileges
                                                     NewState,       // NewState (OPTIONAL)
                                                     ReturnLength,   // BufferLength
                                                     NULL,           // PreviousState (OPTIONAL)
                                                     &ReturnLength   // ReturnLength
                                                   ) ? 1 : 0);
                    if (!Result) {
                        DbgPrint( "AdjustTokenPrivileges( %lx ) failed - %u\n", Token, GetLastError() );
                        }
                    }
                }
            else {
                DbgPrint( "GetTokenInformation( %lx ) failed - %u\n", Token, GetLastError() );
                }
            }
        else {
            DbgPrint( "malloc( %lx ) failed - %u\n", ReturnLength, GetLastError() );
            }
        }
    else {
        DbgPrint( "OpenProcessToken( %lx ) failed - %u\n", GetCurrentProcess(), GetLastError() );
        }

    if (NewState != NULL) {
        free( NewState );
        }

    if (Token != NULL) {
        CloseHandle( Token );
        }

    return( Result );
}


NTSTATUS
OpenObject(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name,
    IN  ACCESS_MASK       DesiredAccess,
    OUT PHANDLE           Object
    )

{
    NTSTATUS
        Status,
        IgnoreStatus;

    UNICODE_STRING
        UnicodeName;

    OBJECT_ATTRIBUTES
        Attributes;

    IO_STATUS_BLOCK
        Iosb;


    RtlInitUnicodeString( &UnicodeName, Name );
    InitializeObjectAttributes( &Attributes, &UnicodeName, OBJ_CASE_INSENSITIVE, Root, NULL );

    //
    // This is effectively a big switch statement of object types
    // that we know how to open...
    //

    if (!wcscmp( Type, L"SymbolicLink" )) {

        Status = NtOpenSymbolicLinkObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Device" )) {

        Status = NtOpenFile( Object, DesiredAccess, &Attributes, &Iosb, 0, 0 );

    } else if (!wcscmp( Type, L"Event" )) {

        Status = NtOpenEvent( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"EventPair" )) {

        Status = NtOpenEventPair( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Mutant" )) {

        Status = NtOpenMutant( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Timer" )) {

        Status = NtOpenTimer( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Semaphore" )) {

        Status = NtOpenSemaphore( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Section" )) {

        Status = NtOpenSection( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Directory" )) {

        Status = NtOpenDirectoryObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"Process" )) {

        Status = NtOpenProcess( Object, DesiredAccess, &Attributes, NULL );

    } else if (!wcscmp( Type, L"Job" )) {

        Status = NtOpenJobObject( Object, DesiredAccess, &Attributes );

    } else if (!wcscmp( Type, L"WindowStation" )) {

        *Object = OpenWindowStationW( Name, FALSE, DesiredAccess );

        if (*Object)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;
        }

    } else if (!wcscmp( Type, L"Desktop" )) {

        *Object = OpenDesktopW( Name, 0, FALSE, DesiredAccess );

        if (*Object)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;
        }


    } else {

        //
        // this utility doesn't yet support opening this type of object
        //

        Status = STATUS_NOT_SUPPORTED;
    }

    return(Status);
}


VOID
OpenAndDisplaySacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    )

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Object;


    Status = OpenObject( Root, Type, Name, ACCESS_SYSTEM_SECURITY, &Object);


    if (NT_SUCCESS(Status)) {


        QueryAndDisplaySacl( Object, Type );
        IgnoreStatus = NtClose( Object );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_NOT_SUPPORTED) {
            printf("    Utility doesn't yet query SACLs for this type of object.\n\n");
        } else {
            printf("    Error attempting to query SACL:  0x%lx.\n\n", Status);
        }
    }
    return;
}


VOID
QueryAndDisplaySacl(
    IN HANDLE Object,
    IN PWSTR Type
    )
{
    NTSTATUS
        Status;

    PSECURITY_DESCRIPTOR
        SD;

    ULONG
        LengthNeeded,
        TypeIndex ;


    Status = NtQuerySecurityObject( Object,
                                    SACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &LengthNeeded
                                    );
    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        SD = RtlAllocateHeap( RtlProcessHeap(), 0, LengthNeeded );
        if (SD == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {

            Status = NtQuerySecurityObject( Object,
                                            SACL_SECURITY_INFORMATION,
                                            SD,
                                            LengthNeeded,
                                            &LengthNeeded
                                            );
            if (NT_SUCCESS(Status)) {

                //
                // Display the SACL
                //

                Status = DisplaySacl( SD, Type );
            }
        }
    }
    return;
}



NTSTATUS
DisplaySacl(
    PSECURITY_DESCRIPTOR SD,
    PWSTR Type
    )
/*++

Routine Description:

    This function dumps out a SACL

    If an error status is returned, then the caller is responsible
    for printing a message.



--*/
{
    NTSTATUS
        Status;

    BOOLEAN
        AclPresent,
        AclDefaulted;

    PACL
        Acl;

    ACL_SIZE_INFORMATION
        AclInfo;

    ULONG
        i;

    PACE_HEADER
        Ace;

    ULONG TypeIndex ;


    TypeIndex = GetObjectTypeIndex( Type );

    Status = RtlGetSaclSecurityDescriptor ( SD, &AclPresent, &Acl, &AclDefaulted );

    if (NT_SUCCESS(Status)) {

        printf("    SACL - ");
        if (!AclPresent) {
            printf("No SACL present on object\n");
        } else {

           if (AclDefaulted) {
               printf("SACL Defaulted flag set\n           ");
           }

           if (Acl == NULL) {
               printf("NULL SACL - no auditing performed.\n");
           } else {
               Status = RtlQueryInformationAcl ( Acl,
                                                 &AclInfo,
                                                 sizeof(ACL_SIZE_INFORMATION),
                                                 AclSizeInformation);
               ASSERT(NT_SUCCESS(Status));

               if (AclInfo.AceCount == 0) {
                   printf("No ACEs in ACL, Auditing performed.\n");
               } else {
                   printf("\n");
                   for (i=0; i<AclInfo.AceCount; i++) {

                       Status = RtlGetAce( Acl, i, &Ace );
                       ASSERT(NT_SUCCESS(Status));

                       printf("       Ace[%2d] - ", i);
                       DumpAce( Ace, FALSE, &TypeNames[ TypeIndex ] );
                       printf("\n");
                   }
               }
           }
        }
    }
    printf("\n");

    return(Status);

}


VOID
OpenAndDisplayDacl(
    IN  HANDLE            Root,
    IN  PWCHAR            Type,
    IN  PWCHAR            Name
    )

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Object;

    ULONG TypeIndex ;


    Status = OpenObject( Root, Type, Name, READ_CONTROL, &Object);

    

    if (NT_SUCCESS(Status)) {
        QueryAndDisplayDacl( Object, Type );

        IgnoreStatus = NtClose( Object );

        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_ACCESS_DENIED) {
            printf("    Protection on object prevented querying the DACL.\n\n");
        } else if (Status == STATUS_NOT_SUPPORTED) {
            printf("    Utility doesn't yet query DACLs for this type of object.\n\n");
        } else {
            printf("    Error attempting to query DACL:  0x%lx.\n\n", Status);
        }
    }
    return;
}



VOID
QueryAndDisplayDacl(
    IN HANDLE Object,
    IN PWSTR Type
    )
{
    NTSTATUS
        Status;

    PSECURITY_DESCRIPTOR
        SD;

    ULONG
        LengthNeeded;

    Status = NtQuerySecurityObject( Object,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &LengthNeeded
                                    );
    ASSERT(!NT_SUCCESS(Status));

    if (Status == STATUS_BUFFER_TOO_SMALL) {

        SD = RtlAllocateHeap( RtlProcessHeap(), 0, LengthNeeded );
        if (SD == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {

            Status = NtQuerySecurityObject( Object,
                                            DACL_SECURITY_INFORMATION,
                                            SD,
                                            LengthNeeded,
                                            &LengthNeeded
                                            );
            if (NT_SUCCESS(Status)) {

                //
                // Display the DACL
                //

                Status = DisplayDacl( SD, Type );
            }
        }
    }
    return;
}


NTSTATUS
DisplayDacl(
    PSECURITY_DESCRIPTOR SD,
    PWSTR Type
    )
/*++

Routine Description:

    This function dumps out a DACL

    If an error status is returned, then the caller is responsible
    for printing a message.



--*/
{
    NTSTATUS
        Status;

    BOOLEAN
        AclPresent,
        AclDefaulted;

    PACL
        Acl;

    ACL_SIZE_INFORMATION
        AclInfo;

    ULONG
        i;

    PACE_HEADER
        Ace;

    ULONG TypeIndex ;


    TypeIndex = GetObjectTypeIndex( Type );


    Status = RtlGetDaclSecurityDescriptor ( SD, &AclPresent, &Acl, &AclDefaulted );

    if (NT_SUCCESS(Status)) {

        printf("    DACL - ");
        if (!AclPresent) {
            printf("No DACL present on object\n");
        } else {

           if (AclDefaulted) {
               printf("DACL Defaulted flag set\n           ");
           }

           if (Acl == NULL) {
               printf("NULL DACL - grants all access to Everyone\n");
           } else {
               Status = RtlQueryInformationAcl ( Acl,
                                                 &AclInfo,
                                                 sizeof(ACL_SIZE_INFORMATION),
                                                 AclSizeInformation);
               ASSERT(NT_SUCCESS(Status));

               if (AclInfo.AceCount == 0) {
                   printf("No ACEs in ACL, Denies all access to everyone\n");
               } else {
                   printf("\n");
                   for (i=0; i<AclInfo.AceCount; i++) {

                       Status = RtlGetAce( Acl, i, &Ace );
                       ASSERT(NT_SUCCESS(Status));

                       printf("       Ace[%2d] - ", i);
                       DumpAce( Ace, TRUE, &TypeNames[ TypeIndex ] );
                       printf("\n");
                   }
               }
           }
        }
    }
    printf("\n");

    return(Status);

}



VOID
DumpAce(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    )
/*++

Routine Description:

    This function displays a single ACE

Arguments:

    Ace - Points to an ACE.

    AclIsDacl - TRUE if acl is a DACL.  False if acl is an SACL.

Return Value:

    None.


--*/
{

    if ((Ace->AceFlags & INHERIT_ONLY_ACE) != 0) {
        printf("Inherit Only - ");
    }

    switch (Ace->AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:

        printf("Grant -");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;

    case ACCESS_DENIED_ACE_TYPE:

        printf("Deny -");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:

        printf("Audit ");
        DumpStandardAceInfo(Ace, AclIsDacl, TypeInfo);
        break;


    default:
        printf(" ** Unknown ACE Type **");
    }
    return;
}



VOID
DumpStandardAceInfo(
    PACE_HEADER     Ace,
    BOOLEAN         AclIsDacl,
    PTYPEINFO       TypeInfo
    )
/*++

Routine Description:

    This function dumps out the standard information for a single ACE.



Arguments:

    Ace - Points to an ACE_HEADER.  The ACE must be one of the known types.

    AclIsDacl - TRUE if acl is a DACL.  False if acl is an SACL.

Return Value:

    None.


--*/
{

    PACCESS_ALLOWED_ACE
        Local;

    ACCESS_MASK
        Specific;

    CHAR FlagBuffer[ 256 ];

    //
    // WARNING -
    //
    // It is assumed that all the known ACE types have their ACCESS_MASK
    // and SID fields in the same location as the ACCESS_ALLOWED_ACE.
    //

    Local = (PACCESS_ALLOWED_ACE)(Ace);


    if (Ace->AceType == SYSTEM_AUDIT_ACE_TYPE) {
        printf("[");
        if (Ace->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
            printf("S");
            if (Ace->AceFlags & FAILED_ACCESS_ACE_FLAG) {
                printf(",F");
            }
        } else if (Ace->AceFlags & FAILED_ACCESS_ACE_FLAG) {
            printf(" ,F");
        } else {
            printf("Neither Success nor Failure flag set]");
            return;
        }
        printf("] -");
    }

    printf(" 0x%lx - ", Local->Mask );
    DisplaySid( (PSID)(&Local->SidStart) );


    //
    // Everything else is only printed for FULL displays

    if (AclIsDacl && !DumpDaclFull) {
        return;
    }
    if (!AclIsDacl && !DumpSaclFull) {
        return;
    }


    //
    // Print the inheritance
    //

    printf("\n                             Inherit: ");

    if ((Ace->AceFlags & INHERIT_ONLY_ACE) != 0) {
        printf("IO ");
    }

    if ((Ace->AceFlags & OBJECT_INHERIT_ACE) != 0) {
        printf("OI ");
    }

    if ((Ace->AceFlags & CONTAINER_INHERIT_ACE) != 0) {
        printf("CI ");
    }

    if ((Ace->AceFlags & NO_PROPAGATE_INHERIT_ACE) != 0) {
        printf("NPI");
    }



    //
    // Print the accesses
    //

    Specific = (Local->Mask & 0xFFFF);
    printf("\n                             Access: 0x%04lX", Specific);

    if ( TypeInfo->NumberRights )
    {
        DisplayFlags( 
            Specific, 
            TypeInfo->NumberRights, 
            TypeInfo->AccessRights,
            38,
            80,
            sizeof( Buffer ),
            (PUCHAR) Buffer );

        printf("\n%s\n                                ", Buffer);

        
    }
    if (Local->Mask != Specific) {
        printf("  and  (");
    }

    if ((Local->Mask & DELETE) != 0) {
        printf(" D");
    }

    if ((Local->Mask & READ_CONTROL) != 0) {
        printf(" RCtl");
    }

    if ((Local->Mask & WRITE_OWNER) != 0) {
        printf(" WOwn");
    }

    if ((Local->Mask & WRITE_DAC) != 0) {
        printf(" WDacl");
    }
    if ((Local->Mask & SYNCHRONIZE) != 0) {
        printf(" Synch");
    }
    if ((Local->Mask & GENERIC_READ) != 0) {
        printf(" R");
    }

    if ((Local->Mask & GENERIC_WRITE) != 0) {
        printf(" W");
    }

    if ((Local->Mask & GENERIC_EXECUTE) != 0) {
        printf(" E");
    }

    if ((Local->Mask & GENERIC_ALL) != 0) {
        printf(" ALL");
    }

    if ((Local->Mask & ACCESS_SYSTEM_SECURITY) != 0) {
        printf(" ACC_SYS_SEC");
    }
    if ((Local->Mask & MAXIMUM_ALLOWED) != 0) {
        printf(" MAX_ALLOWED");
    }

    if (Local->Mask != Specific) {
        printf(" )");
    }
    printf("\n");


    return;
}



VOID
DisplaySid(
    IN  PSID        Sid
    )

/*++

Routine Description:

    This function calls LSA to lookup a SID and displays the result.

Arguments:

    Sid


Return Value:

    None.


--*/
{
    NTSTATUS
        Status;

    PLSA_REFERENCED_DOMAIN_LIST
        ReferencedDomains;

    PLSA_TRANSLATED_NAME
        SidName;

    ULONG
        DomainIndex;

    UNICODE_STRING
        SidString;


    if (LsaHandle == NULL) {
        printf("Can't call LSA to lookup sid");
        return;
    }

    Status = LsaLookupSids(
                  LsaHandle,
                  1,
                  &Sid,
                  &ReferencedDomains,
                  &SidName
                  );
    if (!NT_SUCCESS(Status)) {
        RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );
        printf("%ws (Unable to translate)", SidString.Buffer );
        RtlFreeUnicodeString( &SidString );
        return;
    }

    DomainIndex = SidName[0].DomainIndex;

    printf("%wZ", &ReferencedDomains->Domains[DomainIndex].Name );
    if (ReferencedDomains->Domains[DomainIndex].Name.Length != 0) {
        printf("\\");
    }
    printf("%wZ", &SidName[0].Name );
    LsaFreeMemory( ReferencedDomains );
    LsaFreeMemory( SidName );
    return;
}


VOID
ConnectToLsa( VOID )
/*++

Routine Description:

    This function connects to LSA in preparation for expected SID
    lookup calls.

--*/
{
    NTSTATUS
        Status;

    OBJECT_ATTRIBUTES
        ObjectAttributes;


    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );

    LsaHandle = NULL;
    Status = LsaOpenPolicy(
                  NULL,                   // SystemName
                  &ObjectAttributes,
                  POLICY_LOOKUP_NAMES,    // DesiredAccess
                  &LsaHandle
                  );

    if (!NT_SUCCESS(Status)) {
        LsaHandle = NULL;
    }

    return;
}


VOID
Usage(VOID)
{
    printf("\n\n"
           "    Usage:\n"
           "                objdir [/d | /D] [/s | /S] [<dir_name>]\n\n"
           "    Where:\n"
           "                /d - causes DACLs to be displayed in short form.\n\n"
           "                /D - causes DACLs to be displayed in long form.\n\n"
           "                /s - causes SACLs to be displayed in short form.\n\n"
           "                /S - causes SACLs to be displayed in long form.\n\n"
           "                <dir_name> - is the name of the directory you\n"
           "                             would like to see displayed.  Default\n"
           "                             is the root directory.\n\n"
           "    Examples:\n"
           "        objdir /d\n"
           "                - displays dacls of objects in root directory\n\n"
           "        objdir \\DosDevices\n"
           "                - displays objects in \\DosDevices\n\n"
           "        objdir /d \\BaseNamedObjects\n"
           "                - displays dacls of objects in \\BaseNamedObjects\n\n"
           "        objdir /s /d \\Windows\n"
           "                - displays sacls and dacls of objects in \\Windowss\n\n"
           "        objdir /d \\Windows\\Windowstations\\Service*\n"
           "                - displays dacls of all windowstations beginning with 'service'\n\n"
           "        objdir \\Global??\\w*\n"
           "                - displays objects starting with w in \\Global??\n\n"
           );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\parcomp\makefile.inc ===
$(O)\parcomp.res: parcomp.rc

$(O)\parsync.res: parsync.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\order\order.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    order.c

Abstract:

    This module contains the order tool which reads a call graph output
    by the linker and the performance data from the kernel profile and
    produces a .prf file subsequent input to the linker.

Author:

    David N. Cutler (davec) 24-Feb-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

//
// Define maximum values for table sizes.
//

#define MAXIMUM_CALLED 75               // maximum number of called functions
#define MAXIMUM_FUNCTION 5000           // maximum number of program functions
#define MAXIMUM_TOKEN 100               // maximum character in input token
#define MAXIMUM_SECTION 20              // maximum number of allocation sections
#define MAXIMUM_SYNONYM 10              // maximum number of synonym symbols

//
// Define file numbers.
//

#define CALLTREE_FILE 0                 // call tree file produced by linker
#define PROFILE_FILE 1                  // profile file produced by kernprof
#define ORDER_FILE 2                    // order file produced by this program

//
// Define back edge node sttucture.
//
// Back edge nodes are used to represent back edges in the call graph and
// are constructed after the function list has been defined.
//
//

typedef struct _BACK_EDGE_NODE {
    LIST_ENTRY Entry;
    struct _FUNCTION_NODE *Node;
} BACK_EDGE_NODE, *PBACK_EDGE_NODE;

//
// Define called node structure.
//
// Called nodes are used to represent forward edges in the call graph and
// are constructed when the function list is being defined.
//

#define REFERENCE_NODE 0                // called entry is reference to node
#define REFERENCE_NAME 1                // called entry is reference to name

struct _FUNCTION_NODE;

typedef struct _CALLED_NODE {
    union {
        struct _FUNCTION_NODE *Node;
        PCHAR Name;
    } u;

    ULONG Type;
} CALLED_NODE, *PCALLED_NODE;

//
// Define section node structure.
//
// Section nodes collect allocation information and contain the list of
// function nodes in the section.
//

typedef struct _SECTION_NODE {
    LIST_ENTRY SectionListHead;
    LIST_ENTRY OrderListHead;
    PCHAR Name;
    ULONG Base;
    ULONG Size;
    ULONG Offset;
    ULONG Number;
    ULONG Threshold;
} SECTION_NODE, *PSECTION_NODE;

//
// Define symbol node structure.
//
// Symbol nodes are associated with function nodes and store synonym names
// for the functions and their type of allocation.
//

typedef struct _SYMBOL_NODE {
    PCHAR Name;
    LONG Type;
} SYMBOL_NODE, *PSYMBOL_NODE;

//
// Define function node structure.
//
// Function nodes contain information about a paritcular function and its
// edges in the call graph.
//

typedef struct _FUNCTION_NODE {
    SYMBOL_NODE SynonymList[MAXIMUM_SYNONYM];
    CALLED_NODE CalledList[MAXIMUM_CALLED];
    LIST_ENTRY CallerListHead;
    LIST_ENTRY OrderListEntry;
    LIST_ENTRY SectionListEntry;
    PSECTION_NODE SectionNode;
    ULONG NumberSynonyms;
    ULONG NumberCalled;
    ULONG Rva;
    ULONG Size;
    ULONG HitCount;
    ULONG HitDensity;
    ULONG Offset;
    ULONG Placed;
    ULONG Ordered;
} FUNCTION_NODE, *PFUNCTION_NODE;

//
// Define forward referenced functions.
//

VOID
CheckForConflict (
    PFUNCTION_NODE FunctionNode,
    PFUNCTION_NODE ConflictNode,
    ULONG Depth
    );

VOID
DumpInternalTables (
    VOID
    );

PFUNCTION_NODE
FindHighestDensityFunction (
    PFUNCTION_NODE CallerNode
    );

LONG
GetNextToken (
    IN FILE *InputFile,
    OUT PCHAR TokenBuffer
    );

PFUNCTION_NODE
LookupFunctionNode (
    IN PCHAR Name,
    IN ULONG Rva,
    IN ULONG Size,
    IN LONG Type
    );

PSECTION_NODE
LookupSectionNode (
    IN PCHAR Name
    );

VOID
OrderFunctionList (
    VOID
    );

ULONG
ParseCallTreeFile (
    IN FILE *InputFile
    );

ULONG
ParseProfileFile (
    IN FILE *InputFile
    );

VOID
PlaceCallerList (
    IN PFUNCTION_NODE FunctionNode,
    IN ULONG Depth
    );

VOID
SortFunctionList (
    VOID
    );

VOID
WriteOrderFile (
    IN FILE *OutputFile
    );

//
// Define function list data.
//

ULONG NumberFunctions = 0;
PFUNCTION_NODE FunctionList[MAXIMUM_FUNCTION];

//
// Define section list data.
//

ULONG NumberSections = 0;
PSECTION_NODE SectionList[MAXIMUM_SECTION];

//
// Define input and output file name defaults.
//

PCHAR FileName[3] = {"calltree.out", "profile.out", "order.prf"};

//
// Define dump flags.
//

ULONG DumpBackEdges = 0;
ULONG DumpFunctionList = 0;
ULONG DumpGoodnessValue = 0;
ULONG DumpSectionList = 0;
ULONG TraceAllocation = 0;

//
// Define primary cache mask parameter.
//

ULONG CacheMask = 8192 - 1;
ULONG CacheSize = 8192;

VOID
__cdecl
main (
    int argc,
    char *argv[]
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{

    FILE *InputFile;
    ULONG Index;
    FILE *OutputFile;
    ULONG Shift;
    ULONG Status;
    PCHAR Switch;

    //
    // Parse the command parameters.
    //

    for (Index = 1; Index < (ULONG)argc; Index += 1) {
        Switch = argv[Index];
        if (*Switch++ == '-') {
            if (*Switch == 'b') {
                DumpBackEdges = 1;

            } else if (*Switch == 'c') {
                Switch += 1;
                if (sscanf(Switch, "%d", &Shift) != 1) {
                    fprintf(stderr, "ORDER: Conversion of the shift failed\n");
                    exit(1);
                }

                CacheMask = (1024 << Shift) - 1;
                CacheSize = (1024 << Shift);

            } else if (*Switch == 'f') {
                DumpFunctionList = 1;

            } else if (*Switch == 'g') {
                Switch += 1;
                FileName[CALLTREE_FILE] = Switch;

            } else if (*Switch == 'k') {
                Switch += 1;
                FileName[PROFILE_FILE] = Switch;

            } else if (*Switch == 's') {
                DumpSectionList = 1;

            } else if (*Switch == 't') {
                TraceAllocation = 1;

            } else if (*Switch == 'v') {
                DumpGoodnessValue = 1;

            } else {
                if (*Switch != '?') {
                    fprintf(stderr, "ORDER: Invalid switch %s\n", argv[Index]);
                }

                fprintf(stderr, "ORDER: Usage order [switch] [output-file]\n");
                fprintf(stderr, "       -b = print graph backedges\n");
                fprintf(stderr, "       -cn = primary cache size 1024*2**n\n");
                fprintf(stderr, "       -f = print function list\n");
                fprintf(stderr, "       -gfile = specify graph input file, default calltree.out\n");
                fprintf(stderr, "       -kfile = specify profile input file, default profile.out\n");
                fprintf(stderr, "       -s = print section list\n");
                fprintf(stderr, "       -t = trace allocation\n");
                fprintf(stderr, "       -v = print graph placement value\n");
                fprintf(stderr, "       -? - print usage\n");
                exit(1);
            }

        } else {
            FileName[ORDER_FILE] = argv[Index];
        }
    }

    //
    // Open and parse the call tree file.
    //

    InputFile = fopen(FileName[CALLTREE_FILE], "r");
    if (InputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of call tree file %s failed\n",
                FileName[CALLTREE_FILE]);

        exit(1);
    }

    Status = ParseCallTreeFile(InputFile);
    fclose(InputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Open and parse the profile file.
    //

    InputFile = fopen(FileName[PROFILE_FILE], "r");
    if (InputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of profile file %s failed\n",
                FileName[PROFILE_FILE]);

        exit(1);
    }

    Status = ParseProfileFile(InputFile);
    fclose(InputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Sort the function list and create the section lists.
    //

    SortFunctionList();

    //
    // Order function list.
    //

    OrderFunctionList();

    //
    // Open the output file and write the ordered function list.
    //

    OutputFile = fopen(FileName[ORDER_FILE], "w");
    if (OutputFile == NULL) {
        fprintf(stderr,
                "ORDER: Open of order file %s failed\n",
                FileName[ORDER_FILE]);

        exit(1);
    }

    WriteOrderFile(OutputFile);
    fclose(OutputFile);
    if (Status != 0) {
        exit(1);
    }

    //
    // Dump internal tables as appropriate.
    //

    DumpInternalTables();
    return;
}

VOID
CheckForConflict (
    PFUNCTION_NODE FunctionNode,
    PFUNCTION_NODE ConflictNode,
    ULONG Depth
    )

/*++

Routine Description:

    This function checks for an allocation conflict .

Arguments:

    FunctionNode - Supplies a pointer to a function node that has been
        placed.

    ConflictNode - Supplies a pointer to a function node that has not
        been placed.

    Depth - Supplies the current allocation depth.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Offset;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;
    ULONG Wrap;

    //
    // Compute the cache size truncated offset and bound of the placed
    // function.
    //

    Offset = FunctionNode->Offset & CacheMask;
    Bound = Offset + FunctionNode->Size;
    SectionNode = FunctionNode->SectionNode;

    //
    // If the section offset conflicts with the placed function,
    // then attempt to allocate a function from the end of the
    // section list that will pad the memory allocation so the
    // conflict function does not overlap with the placed function.
    //

    Base = SectionNode->Offset & CacheMask;
    Wrap = (Base + ConflictNode->Size) & CacheMask;
    while (((Base >= Offset) && (Base < Bound)) ||
           ((Base < Offset) && (Wrap >= Bound)) ||
           ((Wrap >= Offset) && (Wrap < Base))) {
        ListHead = &SectionNode->SectionListHead;
        ListEntry = ListHead->Blink;
        while (ListEntry != ListHead) {
            PadNode = CONTAINING_RECORD(ListEntry,
                                        FUNCTION_NODE,
                                        SectionListEntry);

            if ((PadNode->Ordered == 0) &&
                (PadNode->SynonymList[0].Type == 'C')) {
                PadNode->Ordered = 1;
                PadNode->Placed = 1;
                InsertTailList(&SectionNode->OrderListHead,
                               &PadNode->OrderListEntry);

                PadNode->Offset = SectionNode->Offset;
                SectionNode->Offset += PadNode->Size;

                //
                // If allocation is being trace, then output the
                // allocation and depth information.
                //

                if (TraceAllocation != 0) {
                    fprintf(stdout,
                            "pp %6lx %4lx %-8s",
                            PadNode->Offset,
                            PadNode->Size,
                            SectionNode->Name);

                    for (Index = 0; Index < Depth; Index += 1) {
                        fprintf(stdout, " ");
                    }

                    fprintf(stdout, "%s\n",
                            PadNode->SynonymList[0].Name);
                }

                Base = SectionNode->Offset & CacheMask;
                Wrap = (Base + ConflictNode->Size) & CacheMask;
                break;
            }

            ListEntry = ListEntry->Blink;
        }

        if (ListEntry == ListHead) {
            break;
        }
    }

    return;
}

VOID
DumpInternalTables (
    VOID
    )

/*++

Routine Description:

    This function dumps various internal tables.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    PFUNCTION_NODE CalledNode;
    PFUNCTION_NODE CallerNode;
    PFUNCTION_NODE FunctionNode;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Loop;
    PCHAR Name;
    ULONG Number;
    ULONG Offset;
    PSECTION_NODE SectionNode;
    ULONG Sum;
    ULONG Total;
    ULONG Wrap;

    //
    // Scan the function list and dump each function entry.
    //

    if (DumpFunctionList != 0) {
        fprintf(stdout, "Dump of function list with attributes\n\n");
        for (Index = 0; Index < NumberFunctions; Index += 1) {

            //
            // Dump the function node.
            //

            FunctionNode = FunctionList[Index];
            fprintf(stdout,
                    "%7d %-36s %c %-8s %6lx %4lx %7d\n",
                    FunctionNode->HitDensity,
                    FunctionNode->SynonymList[0].Name,
                    FunctionNode->SynonymList[0].Type,
                    FunctionNode->SectionNode->Name,
                    FunctionNode->Rva,
                    FunctionNode->Size,
                    FunctionNode->HitCount);

            //
            // Dump the synonym names.
            //

            for (Loop = 1; Loop < FunctionNode->NumberSynonyms; Loop += 1) {
                fprintf(stdout,
                        "       syno: %-34s %c\n",
                        FunctionNode->SynonymList[Loop].Name,
                        FunctionNode->SynonymList[Loop].Type);
            }

            //
            // Dump the called references.
            //

            for (Loop = 0; Loop < FunctionNode->NumberCalled; Loop += 1) {
                CalledNode = FunctionNode->CalledList[Loop].u.Node;
                Name = CalledNode->SynonymList[0].Name;
                fprintf(stdout,"       calls: %-s\n", Name);
            }
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Scan the function list and dump the back edges of each function
    // entry.
    //

    if (DumpBackEdges != 0) {
        fprintf(stdout, "Dump of function list back edges\n\n");
        for (Index = 0; Index < NumberFunctions; Index += 1) {
            FunctionNode = FunctionList[Index];
            fprintf(stdout, "%s\n", FunctionNode->SynonymList[0].Name);
            ListHead = &FunctionNode->CallerListHead;
            ListEntry = ListHead->Flink;
            while (ListEntry != ListHead) {
                CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                fprintf(stdout, "  %s\n", CallerNode->SynonymList[0].Name);
                ListEntry = ListEntry->Flink;
            }
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Scan the section list and dump each entry.
    //

    if (DumpSectionList != 0) {
        fprintf(stdout, "Dump of section list\n\n");
        for (Index = 0; Index < NumberSections; Index += 1) {
            SectionNode = SectionList[Index];
            fprintf(stdout,
                    "%-8s %6lx, %6lx, %6lx, %4d %7d\n",
                    SectionNode->Name,
                    SectionNode->Base,
                    SectionNode->Size,
                    SectionNode->Offset,
                    SectionNode->Number,
                    SectionNode->Threshold);
        }

        fprintf(stdout, "\n\n");
    }

    //
    // Compute the graph goodness value as the summation of the hit
    // count of all functions whose allocation does not conflict with
    // the functions that call it and whose hit density is great than
    // the section threshold.
    //

    if (DumpGoodnessValue != 0) {
        Number = 0;
        Sum = 0;
        Total = 0;
        for (Index = 0; Index < NumberFunctions; Index += 1) {
            FunctionNode = FunctionList[Index];
            SectionNode = FunctionNode->SectionNode;
            Total += FunctionNode->Size;
            if ((FunctionNode->HitDensity > SectionNode->Threshold) &&
                (FunctionNode->SynonymList[0].Type == 'C')) {
                Offset = FunctionNode->Offset & CacheMask;
                Bound = (Offset + FunctionNode->Size) & CacheMask;
                Sum += FunctionNode->Size;
                ListHead = &FunctionNode->CallerListHead;
                ListEntry = ListHead->Flink;
                while (ListEntry != ListHead) {
                    CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                    Base = CallerNode->Offset & CacheMask;
                    Wrap = (Base + CallerNode->Size) & CacheMask;
                    if ((((Base >= Offset) && (Base < Bound)) ||
                        ((Base < Offset) && (Wrap >= Bound)) ||
                        ((Wrap >= Offset) && (Wrap < Base))) &&
                        (CallerNode != FunctionNode) &&
                        (CallerNode->HitDensity > SectionNode->Threshold)) {
                        Number += 1;
                        fprintf(stdout,
                                "%-36s   %6lx %4lx conflicts with\n  %-36s %6lx %4lx\n",
                                FunctionNode->SynonymList[0].Name,
                                FunctionNode->Offset,
                                FunctionNode->Size,
                                CallerNode->SynonymList[0].Name,
                                CallerNode->Offset,
                                CallerNode->Size);

                    } else {
                        Sum += CallerNode->Size;
                    }

                    ListEntry = ListEntry->Flink;
                }
            }
        }

        Sum = Sum * 100 / Total;
        fprintf(stdout, "Graph goodness value is %d\n", Sum);
        fprintf(stdout, "%d conflicts out of %d functions\n", Number, NumberFunctions);
    }
}

PFUNCTION_NODE
FindHighestDensityFunction (
    PFUNCTION_NODE CallerNode
    )

/*++

Routine Description:

    This function finds the function node that has the highest hit density
    of all the functions called by the caller node.

Arguments:

    CallerNode - Supplies a pointer to a function node whose highest
        hit density called function is to be found.

Return Value:

    The address of the function node for the highest hit density called
    function is returned as the function value.

--*/

{

    PFUNCTION_NODE CheckNode;
    PFUNCTION_NODE FoundNode;
    ULONG Index;

    //
    // Scan all the functions called by the specified function and
    // compute the address of the highest hit density called function.
    //

    FoundNode = NULL;
    for (Index = 0; Index < CallerNode->NumberCalled; Index += 1) {
        if (CallerNode->CalledList[Index].Type == REFERENCE_NODE) {
            CheckNode = CallerNode->CalledList[Index].u.Node;
            if ((FoundNode == NULL) ||
                (CheckNode->HitDensity > FoundNode->HitDensity)) {
                FoundNode = CheckNode;
            }
        }
    }

    return FoundNode;
}

LONG
GetNextToken (
    IN FILE *InputFile,
    OUT PCHAR TokenBuffer
    )

/*++

Routine Description:

    This function reads the next token from the specified input file,
    copies it to the token buffer, zero terminates the token, and
    returns the delimiter character.

Arguments:

    InputFile - Supplies a pointer to the input file descripor.

    TokenBuffer - Supplies a pointer to the output token buffer.

Return Value:

    The token delimiter character is returned as the function value.

--*/

{

    CHAR Character;

    //
    // Read characters from the input stream and copy them to the token
    // buffer until an EOF or token delimiter is encountered. Terminate
    // the token will a null and return the token delimiter character.
    //

    do {
        Character = (CHAR)fgetc(InputFile);
        if ((Character != ' ') &&
            (Character != '\t')) {
            break;
        }

    } while(TRUE);

    do {
        if ((Character == EOF) ||
            (Character == ' ') ||
            (Character == '\n') ||
            (Character == '\t')) {
            break;
        }

        *TokenBuffer++ = Character;
        Character = (CHAR)fgetc(InputFile);
    } while(TRUE);

    *TokenBuffer = '\0';
    return Character;
}

PFUNCTION_NODE
LookupFunctionNode (
    IN PCHAR Name,
    IN ULONG Rva,
    IN ULONG Size,
    IN LONG Type
    )

/*++

Routine Description:

    This function searches the function list for a matching entry.

Arguments:

    Name - Supplies a pointer to the name of the function.

    Rva - Supplies the revlative virtual address of the function.

    Size - Supplies the size of the function.

    Type - specified the type of the function (0, N, or C).

Return Value:

    If a matching entry is found, then the function node address is
    returned as the function value. Otherwise, NULL is returned.

--*/

{

    ULONG Index;
    ULONG Loop;
    PFUNCTION_NODE Node;
    ULONG Number;

    //
    // Search the function list for a matching function.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        Node = FunctionList[Index];

        //
        // Search the synonym list for the specified function name.
        //

        for (Loop = 0; Loop < Node->NumberSynonyms; Loop += 1) {
            if (strcmp(Name, Node->SynonymList[Loop].Name) == 0) {
                if (Type != 0) {
                    fprintf(stderr,
                            "ORDER: Warning - duplicate function name %s\n",
                            Name);
                }

                return Node;
            }
        }

        //
        // If the type is nonzero, then a function definition is being
        // looked up and the RVA/size must be checked for a synonym. If
        // the RVA and size of the entry are equal to the RVA and size
        // of the reference, then the function name is added to the node
        // as a synonym.
        //

        if (Type != 0) {
            if ((Node->Rva == Rva) && (Node->Size == Size)) {
                Number = Node->NumberSynonyms;
                if (Number >= MAXIMUM_SYNONYM) {
                    fprintf(stderr,
                            "ORDER: Warning - Too many synonyms %s\n",
                            Name);

                } else {
                    if (Type == 'C') {
                        Node->SynonymList[Number].Name = Node->SynonymList[0].Name;
                        Node->SynonymList[Number].Type = Node->SynonymList[0].Type;
                        Number = 0;
                    }

                    Node->SynonymList[Number].Name = Name;
                    Node->SynonymList[Number].Type = Type;
                    Node->NumberSynonyms += 1;
                }

                return Node;
            }
        }

    }

    return NULL;
}

PSECTION_NODE
LookupSectionNode (
    IN PCHAR Name
    )

/*++

Routine Description:

    This function searches the section list for a matching entry.

Arguments:

    Name - Supplies a pointer to the name of the section.

Return Value:

    If a matching entry is found, then the section node address is
    returned as the function value. Otherwise, NULL is returned.

--*/

{

    ULONG Index;
    PSECTION_NODE SectionNode;

    //
    // Search the function list for a matching function.
    //

    for (Index = 0; Index < NumberSections; Index += 1) {
        SectionNode = SectionList[Index];
        if (strcmp(Name, SectionNode->Name) == 0) {
            return SectionNode;
        }
    }

    return NULL;
}

VOID
PlaceCallerList (
    IN PFUNCTION_NODE FunctionNode,
    ULONG Depth
    )

/*++

Routine Description:

    This function recursively places all the functions in the caller list
    for the specified function.

Arguments:

    FunctionNode - Supplies a pointer to a function node.

    Depth - Supplies the depth of the function in the caller tree.

Return Value:

    None.

--*/

{

    PFUNCTION_NODE CallerNode;
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;

    //
    // Scan the caller list and process each function that has not been
    // placed.
    //
    //

    Depth += 1;
    SectionNode = FunctionNode->SectionNode;
    ListHead = &FunctionNode->CallerListHead;
    ListEntry = ListHead->Flink;
    while (ListHead != ListEntry) {
        CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;

        //
        // If the caller is in the same section, has not been placed, is
        // placeable, has a hit density above the section threshold, has
        // not been placed, and the current function is the highest density
        // called function of the caller, then insert the function in the
        // section order list and compute it's offset and bound.
        //

        if ((SectionNode == CallerNode->SectionNode) &&
            (CallerNode->Placed == 0) &&
            (CallerNode->Ordered == 0) &&
            (CallerNode->SynonymList[0].Type == 'C') &&
            (CallerNode->HitDensity > SectionNode->Threshold) &&
            (FindHighestDensityFunction(CallerNode) == FunctionNode)) {
            CallerNode->Placed = 1;
            CallerNode->Ordered = 1;

            //
            // Resolve any allocation conflict, insert function in the
            // section order list, and place the fucntion.
            //

            CheckForConflict(FunctionNode, CallerNode, Depth);
            InsertTailList(&SectionNode->OrderListHead,
                           &CallerNode->OrderListEntry);

            CallerNode->Offset = SectionNode->Offset;
            SectionNode->Offset += CallerNode->Size;

            //
            // If allocation is being trace, then output the allocation and
            // depth information.
            //

            if (TraceAllocation != 0) {
                fprintf(stdout,
                        "%2d %6lx %4lx %-8s",
                        Depth,
                        CallerNode->Offset,
                        CallerNode->Size,
                        SectionNode->Name);

                for (Index = 0; Index < Depth; Index += 1) {
                    fprintf(stdout, " ");
                }

                fprintf(stdout, "%s\n",
                        CallerNode->SynonymList[0].Name);
            }

            PlaceCallerList(CallerNode, Depth);
        }

        ListEntry = ListEntry->Flink;
    }

    return;
}

VOID
OrderFunctionList (
    VOID
    )

/*++

Routine Description:

    This function computes the link order for based on the information
    in the function list.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Base;
    ULONG Bound;
    PFUNCTION_NODE CallerNode;
    FUNCTION_NODE DummyNode;
    PFUNCTION_NODE FunctionNode;
    ULONG High;
    ULONG Index;
    ULONG Limit;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Low;
    ULONG Offset;
    PFUNCTION_NODE PadNode;
    PSECTION_NODE SectionNode;
    ULONG Span;

    //
    // Scan forward through the function list and compute the link order.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        FunctionNode = FunctionList[Index];

        //
        // If the function has not been placed, then place the function.
        //

        if ((FunctionNode->Placed == 0) &&
            (FunctionNode->SynonymList[0].Type == 'C')) {
            FunctionNode->Ordered = 1;
            FunctionNode->Placed = 1;
            SectionNode = FunctionNode->SectionNode;

            //
            // Attempt to find the highest hit density caller than has
            // already been placed and compute the total bounds for all
            // placed caller functions.
            //

            Bound = 0;
            Offset = CacheMask;
            ListHead = &FunctionNode->CallerListHead;
            ListEntry = ListHead->Flink;
            while (ListEntry != ListHead) {
                CallerNode = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
                if ((SectionNode == CallerNode->SectionNode) &&
                    (CallerNode->Placed != 0) &&
                    (CallerNode->Ordered != 0) &&
                    (CallerNode->SynonymList[0].Type == 'C') &&
                    (CallerNode->HitDensity > SectionNode->Threshold)) {
                    Base = CallerNode->Offset & CacheMask;
                    Limit = Base + CallerNode->Size;
                    Low = min(Offset, Base);
                    High = max(Bound, Limit);
                    Span = High - Low;
                    if ((Span < CacheSize) &&
                        ((CacheSize - Span) > FunctionNode->Size)) {
                        Offset = Low;
                        Bound = High;
                    }
                }

                ListEntry = ListEntry->Flink;
            }

            //
            // If a caller has already been placed and the hit density is
            // above the section threshold, then resolve any allocation
            // conflict before inserting the function in the section order
            // list and placing it in memory.
            //

            if (Bound != 0) {
                Span = Bound - Offset;
                if ((Span < CacheSize) &&
                    ((CacheSize - Span) > FunctionNode->Size)) {
                    DummyNode.SectionNode = SectionNode;
                    DummyNode.Offset = Offset;
                    DummyNode.Size = Span;
                    CheckForConflict(&DummyNode, FunctionNode, 1);
                }
            }

            InsertTailList(&SectionNode->OrderListHead,
                           &FunctionNode->OrderListEntry);

            FunctionNode->Offset = SectionNode->Offset;
            SectionNode->Offset += FunctionNode->Size;

            //
            // If allocation is being trace, then output the allocation and
            // depth information.
            //

            if (TraceAllocation != 0) {
                fprintf(stdout,
                        "%2d %6lx %4lx %-8s %s\n",
                        1,
                        FunctionNode->Offset,
                        FunctionNode->Size,
                        SectionNode->Name,
                        FunctionNode->SynonymList[0].Name);
            }

            PlaceCallerList(FunctionNode, 1);
        }
    }

    return;
}

ULONG
ParseCallTreeFile (
    IN FILE *InputFile
    )

/*++

Routine Description:

    This function reads the call tree data and produces the initial call
    graph.

Arguments:

    InputFile - Supplies a pointer to the input file stream.

Return Value:

    A value of zero is returned if the call tree is successfully parsed.
    Otherwise, a nonzero value is returned.

--*/

{

    PCHAR Buffer;
    PFUNCTION_NODE CalledNode;
    PBACK_EDGE_NODE CallerNode;
    LONG Delimiter;
    ULONG HitCount;
    ULONG Index;
    ULONG Loop;
    PCHAR Name;
    PFUNCTION_NODE Node;
    ULONG Number;
    ULONG Rva;
    PSECTION_NODE SectionNode;
    ULONG Size;
    CHAR TokenBuffer[MAXIMUM_TOKEN];
    LONG Type;

    //
    // Process the call tree file.
    //

    Buffer = &TokenBuffer[0];
    do {

        //
        // Get the relative virtual address of the next function.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            break;
        }

        if (sscanf(Buffer, "%lx", &Rva) != 1) {
            fprintf(stderr, "ORDER: Conversion of the RVA failed\n");
            return 1;
        }

        //
        // Get the function type.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function type\n");
            return 1;
        }

        Type = *Buffer;

        //
        // Get the section name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at section name\n");
            return 1;
        }

        //
        // If the specfied section is not already in the section list, then
        // allocate and initialize a new section list entry.
        //

        SectionNode = LookupSectionNode(Buffer);
        if (SectionNode == NULL) {

            //
            // Allocate a section node and zero.
            //

            if (NumberSections >= MAXIMUM_SECTION) {
                fprintf(stderr, "ORDER: Maximum number of sections exceeded\n");
                return 1;
            }

            SectionNode = (PSECTION_NODE)malloc(sizeof(SECTION_NODE));
            if (SectionNode == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate section node\n");
                return 1;
            }

            memset((PCHAR)SectionNode, 0, sizeof(SECTION_NODE));
            SectionList[NumberSections] = SectionNode;
            NumberSections += 1;

            //
            // Initialize section node.
            //

            InitializeListHead(&SectionNode->OrderListHead);
            InitializeListHead(&SectionNode->SectionListHead);
            Name = (PCHAR)malloc(strlen(Buffer) + 1);
            if (Name == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate section name\n");
                return 1;
            }

            strcpy(Name, Buffer);
            SectionNode->Name = Name;
        }

        //
        // Get the function size.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function size\n");
            return 1;
        }

        if (sscanf(Buffer, "%lx", &Size) != 1) {
            fprintf(stderr, "ORDER: Conversion of the function size failed\n");
            return 1;
        }

        //
        // Get the function name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at function name\n");
            return 1;
        }

        Name = (PCHAR)malloc(strlen(Buffer) + 1);
        if (Name == NULL) {
            fprintf(stderr, "ORDER: Failed to allocate function name\n");
            return 1;
        }

        strcpy(Name, Buffer);

        //
        // If the specified function is not already in the function list,
        // then allocate and initialize a new function list entry.
        //

        Node = LookupFunctionNode(Name, Rva, Size, Type);
        if (Node == NULL) {

            //
            // Allocate a function node and zero.
            //

            if (NumberFunctions >= MAXIMUM_FUNCTION) {
                fprintf(stderr, "ORDER: Maximum number of functions exceeded\n");
                return 1;
            }

            Node = (PFUNCTION_NODE)malloc(sizeof(FUNCTION_NODE));
            if (Node == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate function node\n");
                return 1;
            }

            memset((PCHAR)Node, 0, sizeof(FUNCTION_NODE));
            FunctionList[NumberFunctions] = Node;
            NumberFunctions += 1;

            //
            // Initialize function node.
            //

            InitializeListHead(&Node->CallerListHead);
            Node->SynonymList[0].Name = Name;
            Node->SynonymList[0].Type = Type;
            Node->NumberSynonyms = 1;
            Node->SectionNode = SectionNode;

            //
            // Initialize relative virtual address and function size.
            //

            Node->Rva = Rva;
            if (Size == 0) {
                Size = 4;
            }

            Node->Size = Size;
        }

        //
        // Parse the called forward edges and add them to the current node.
        //

        if (Delimiter != '\n') {
            do {

                //
                // Get next function reference.
                //

                Delimiter = GetNextToken(InputFile, Buffer);
                if (Delimiter == EOF) {
                    fprintf(stderr, "ORDER: Premature end of file called scan\n");
                    return 1;
                }

                Number = Node->NumberCalled;
                if (Number >= MAXIMUM_CALLED) {
                    fprintf(stderr,
                            "ORDER: Too many called references %s\n",
                            Buffer);

                    return 1;
                }

                //
                // Lookup the specified function in the function list. If the
                // specified function is found, then store the address of the
                // function node in the called list. Otherwise, allocate a name
                // buffer, copy the function name to the buffer, and store the
                // address of the name buffer in the called list.
                //

                CalledNode = LookupFunctionNode(Buffer, 0, 0, 0);
                if (CalledNode == NULL) {
                    Name = (PCHAR)malloc(strlen(Buffer) + 1);
                    if (Name == NULL) {
                        fprintf(stderr, "ORDER: Failed to allocate reference name\n");
                        return 1;
                    }

                    strcpy(Name, Buffer);
                    Node->CalledList[Number].u.Name = Name;
                    Node->CalledList[Number].Type = REFERENCE_NAME;

                } else {
                    Node->CalledList[Number].u.Node = CalledNode;
                    Node->CalledList[Number].Type = REFERENCE_NODE;
                }

                Node->NumberCalled += 1;
            } while (Delimiter != '\n');
        }

    } while(TRUE);

    //
    // Scan the function table and do the final resolution for all called
    // functions names that were unresolved when the individual functions
    // were defined.
    //

    for (Index = 0; Index < NumberFunctions; Index += 1) {
        Node = FunctionList[Index];
        for (Loop = 0; Loop < Node->NumberCalled; Loop += 1) {
            if (Node->CalledList[Loop].Type == REFERENCE_NAME) {
                CalledNode =
                        LookupFunctionNode(Node->CalledList[Loop].u.Name,
                                           0,
                                           0,
                                           0);

                if (CalledNode == NULL) {
                    fprintf(stderr,
                            "ORDER: Unresolved reference name %s\n",
                            Node->CalledList[Loop].u.Name);

                    return 1;

                } else {
                    Node->CalledList[Loop].Type = REFERENCE_NODE;
                    Node->CalledList[Loop].u.Node = CalledNode;
                }

            } else {
                CalledNode = Node->CalledList[Loop].u.Node;
            }

            //
            // Allocate a back edge node and place the node in the caller
            // list of called function.
            //

            CallerNode = (PBACK_EDGE_NODE)malloc(sizeof(BACK_EDGE_NODE));
            if (CallerNode == NULL) {
                fprintf(stderr, "ORDER: Failed to allocate caller node\n");
                return 1;
            }

            CallerNode->Node = Node;
            InsertTailList(&CalledNode->CallerListHead, &CallerNode->Entry);
        }
    }

    return 0;
}

ULONG
ParseProfileFile (
    IN FILE *InputFile
    )

/*++

Routine Description:

    This function reads the profile data and computes the hit density
    for each funtion.

Arguments:

    InputFile - Supplies a pointer to the input file stream.

Return Value:

    A value of zero is returned if the call tree is successfully parsed.
    Otherwise, a nonzero value is returned.

--*/

{

    PCHAR Buffer;
    ULONG HitCount;
    LONG Delimiter;
    PFUNCTION_NODE FunctionNode;
    CHAR TokenBuffer[MAXIMUM_TOKEN];

    //
    // Process the profile file.
    //

    Buffer = &TokenBuffer[0];
    do {

        //
        // Get the bucket hit count.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            break;
        }

        if (sscanf(Buffer, "%d", &HitCount) != 1) {
            fprintf(stderr, "ORDER: Conversion of bucket hit failed\n");
            return 1;
        }

        //
        // Get the function name.
        //

        Delimiter = GetNextToken(InputFile, Buffer);
        if (Delimiter == EOF) {
            fprintf(stderr, "ORDER: Premature end of file at profile name\n");
            return 1;
        }

        //
        // Lookup the function name in the function table and update the
        // hit count.
        //

        FunctionNode = LookupFunctionNode(Buffer, 0, 0, 0);
        if (FunctionNode == NULL) {
            fprintf(stderr, "ORDER: Warning function name %s undefined\n", Buffer);

        } else {
            FunctionNode->HitCount += HitCount;
//          FunctionNode->HitDensity = FunctionNode->HitCount;
            FunctionNode->HitDensity =
                            (FunctionNode->HitCount * 100) / FunctionNode->Size;
        }

    } while (TRUE);

    return 0;
}

VOID
SortFunctionList (
    VOID
    )

/*++

Routine Description:

    This function sorts the function list by hit density and creates
    the section list ordered by hit density.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PFUNCTION_NODE CallerList[MAXIMUM_FUNCTION];
    PFUNCTION_NODE CallerNode;
    PFUNCTION_NODE FunctionNode;
    LONG i;
    LONG j;
    LONG k;
    PSECTION_NODE InitNode;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG NumberCallers;
    PSECTION_NODE SectionNode;

    //
    // All functions that are in the INIT section or cannot be placed are
    // forced to have a hit density of zero.
    //

    InitNode = LookupSectionNode("INIT");
    if (InitNode == NULL) {
        fprintf(stderr, "ORDER: Warning - unable to find INIT section\n");
    }

    for (i = 0; i < (LONG)NumberFunctions; i += 1) {
        FunctionNode = FunctionList[i];
        SectionNode = FunctionNode->SectionNode;
        if ((SectionNode == InitNode) ||
            (FunctionNode->SynonymList[0].Type != 'C')) {
            FunctionNode->HitDensity = 0;
        }
    }

    //
    // Perform a bubble sort on the function list hit density.
    //

    if (NumberFunctions > 1) {
        i = 0;
        do {
            for (j = i; j >= 0; j -= 1) {
                if (FunctionList[j]->HitDensity >= FunctionList[j + 1]->HitDensity) {
                    if (FunctionList[j]->HitDensity > FunctionList[j + 1]->HitDensity) {
                        break;

                    } else if (FunctionList[j]->Size >= FunctionList[j + 1]->Size) {
                        break;
                    }
                }

                FunctionNode = FunctionList[j];
                FunctionList[j] = FunctionList[j + 1];
                FunctionList[j + 1] = FunctionNode;
            }

            i += 1;
        } while (i < (LONG)(NumberFunctions - 1));
    }

    //
    // Perform a bubble sort on the caller list of each function.
    //

    for (k = 0; k < (LONG)NumberFunctions; k += 1) {
        FunctionNode = FunctionList[i];
        ListHead = &FunctionNode->CallerListHead;
        ListEntry = ListHead->Flink;
        i = 0;
        while (ListEntry != ListHead) {
            CallerList[i] = CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node;
            i += 1;
            ListEntry = ListEntry->Flink;
        }

        if (i > 1) {
            NumberCallers = i;
            i = 0;
            do {
                for (j = i; j >= 0; j -= 1) {
                    if (CallerList[j]->HitDensity >= CallerList[j + 1]->HitDensity) {
                        if (CallerList[j]->HitDensity > CallerList[j + 1]->HitDensity) {
                            break;

                        } else if (CallerList[j]->Size >= CallerList[j + 1]->Size) {
                            break;
                        }
                    }

                    CallerNode = CallerList[j];
                    CallerList[j] = CallerList[j + 1];
                    CallerList[j + 1] = CallerNode;
                }

                i += 1;
            } while (i < (LONG)(NumberCallers - 1));

            ListEntry = FunctionNode->CallerListHead.Flink;
            for (i = 0; i < (LONG)NumberCallers; i += 1) {
                CONTAINING_RECORD(ListEntry, BACK_EDGE_NODE, Entry)->Node = CallerList[i];
                ListEntry = ListEntry->Flink;
            }
        }
    }

    //
    // Compute the size of each section and create the section lists ordered
    // by hit density.
    //

    for (i = 0; i < (LONG)NumberFunctions; i += 1) {
        FunctionNode = FunctionList[i];
        SectionNode = FunctionNode->SectionNode;
        SectionNode->Size += FunctionNode->Size;
        SectionNode->Number += 1;
        InsertTailList(&SectionNode->SectionListHead,
                       &FunctionNode->SectionListEntry);
    }

    //
    // Set the hit density threshold to zero.
    //


    for (i = 0; i < (LONG)NumberSections; i += 1) {
        SectionList[i]->Threshold = 0;
    }
}

VOID
WriteOrderFile (
    IN FILE *OutputFile
    )

/*++

Routine Description:

    This function scans the section list and writes the link order file.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;
    PFUNCTION_NODE FunctionNode;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PSECTION_NODE SectionNode;

    //
    // Scan the section list and write the link order list.
    //

    for (Index = 0; Index < NumberSections; Index += 1) {
        SectionNode = SectionList[Index];
        ListHead = &SectionNode->OrderListHead;
        ListEntry = ListHead->Flink;
        while (ListHead != ListEntry) {
            FunctionNode = CONTAINING_RECORD(ListEntry,
                                             FUNCTION_NODE,
                                             OrderListEntry);

            fprintf(OutputFile, "%s\n", FunctionNode->SynonymList[0].Name);
            ListEntry = ListEntry->Flink;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pageheap\makefile.inc ===
!IF "$(BUILD_ALT_DIR)" == "d"
PAGEHEAP_COPY_BIN_DIR=binD
!ELSE
PAGEHEAP_COPY_BIN_DIR=bin
!ENDIF

copyexe:
    if exist $(_OBJ_DIR)\i386\*.exe copy $(_OBJ_DIR)\i386\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\i386\*.dll copy $(_OBJ_DIR)\i386\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\i386
    if exist $(_OBJ_DIR)\Alpha\*.exe copy $(_OBJ_DIR)\Alpha\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\alpha
    if exist $(_OBJ_DIR)\Alpha\*.dll copy $(_OBJ_DIR)\Alpha\*.exe ..\$(PAGEHEAP_COPY_BIN_DIR)\alpha
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\paranoia\paranoia.c ===
//#define NOSIGNAL	1
#define NOPAUSE         1

#include <stdio.h>
#include <stdlib.h>
#ifndef NOSIGNAL
#include <signal.h>
#endif
#include <setjmp.h>

#include <math.h>//extern double fabs(), floor(), log(), pow(), sqrt();
#include <float.h> //for rounding mode

#ifdef Single
#define FLOAT float
#define FABS(x) (float)fabs((double)(x))
#define FLOOR(x) (float)floor((double)(x))
#define LOG(x) (float)log((double)(x))
#define POW(x,y) (float)pow((double)(x),(double)(y))
#define SQRT(x) (float)sqrt((double)(x))
#else
#define FLOAT double
#define FABS(x) fabs(x)
#define FLOOR(x) floor(x)
#define LOG(x) log(x)
#define POW(x,y) pow(x,y)
#define SQRT(x) sqrt(x)
#endif

jmp_buf ovfl_buf;
typedef void (__cdecl *Sig_type)(int);
Sig_type sigsave;

#define KEYBOARD 0

FLOAT Radix, BInvrse, RadixD2, BMinusU2;
FLOAT Sign(), Random();

/*Small floating point constants.*/
FLOAT Zero = 0.0;
FLOAT Half = 0.5;
FLOAT One = 1.0;
FLOAT Two = 2.0;
FLOAT Three = 3.0;
FLOAT Four = 4.0;
FLOAT Five = 5.0;
FLOAT Eight = 8.0;
FLOAT Nine = 9.0;
FLOAT TwentySeven = 27.0;
FLOAT ThirtyTwo = 32.0;
FLOAT TwoForty = 240.0;
FLOAT MinusOne = -1.0;
FLOAT OneAndHalf = 1.5;
/*Integer constants*/
int NoTrials = 20; /*Number of tests for commutativity. */
#define False 0
#define True 1

/* Definitions for declared types
        Guard == (Yes, No);
        Rounding == (Chopped, Rounded, Other);
        Message == packed array [1..40] of char;
        Class == (Flaw, Defect, Serious, Failure);
          */
#define Yes 1
#define No  0
#define Chopped 2
#define Rounded 1
#define Other   0
#define Flaw    3
#define Defect  2
#define Serious 1
#define Failure 0
typedef int Guard, Rounding, Class;
typedef char Message;

/* Declarations of Variables */
int Indx;
char ch[8];
FLOAT AInvrse, A1;
FLOAT C, CInvrse;
FLOAT D, FourD;
FLOAT E0, E1, Exp2, E3, MinSqEr;
FLOAT SqEr, MaxSqEr, E9;
FLOAT Third;
FLOAT F6, F9;
FLOAT H, HInvrse;
int I;
FLOAT StickyBit, J;
FLOAT MyZero;
FLOAT Precision;
FLOAT Q, Q9;
FLOAT R, Random9;
FLOAT T, Underflow, S;
FLOAT OneUlp, UfThold, U1, U2;
FLOAT V, V0, V9;
FLOAT W;
FLOAT X, X1, X2, X8, Random1;
FLOAT Y, Y1, Y2, Random2;
FLOAT Z, PseudoZero, Z1, Z2, Z9;
int ErrCnt[4];
int fpecount;
int Milestone;
int PageNo;
int M, N, N1;
Guard GMult, GDiv, GAddSub;
Rounding RMult, RDiv, RAddSub, RSqrt;
int Break, Done, NotMonot, Monot, Anomaly, IEEE,
                SqRWrng, UfNGrad;
/* Computed constants. */
/*U1  gap below 1.0, i.e, 1.0-U1 is next number below 1.0 */
/*U2  gap above 1.0, i.e, 1.0+U2 is next number above 1.0 */

void Instructions(void);
void Pause(void);
void Heading(void);
void Characteristics(void);
void History(void);
void notify(char *s);
void TstPtUf(void);
void PrintIfNPositive(void);
void SR3980(void);
void IsYeqX(void);
void SR3750(void);
void NewD(void);
void SqXMinX (int ErrKind);
FLOAT Random(void);
void BadCond(int K, char *T);
void TstCond (int K, int Valid, char *T);
FLOAT Sign (FLOAT X);

/* floating point exception receiver */
 void
__cdecl
sigfpe(int x)
{
        x;
        fpecount++;
        printf("\n* * * FLOATING-POINT ERROR * * *\n");
        fflush(stdout);
        if (sigsave) {
#ifndef NOSIGNAL
                signal(SIGFPE, sigsave);
#endif
                sigsave = 0;
                longjmp(ovfl_buf, 1);
                }
        abort();
}

int __cdecl
main()
{
	_controlfp(_PC_53, _MCW_PC);
	/* First two assignments use integer right-hand sides. */
        Zero = 0;
        One = 1;
        Two = One + One;
        Three = Two + One;
        Four = Three + One;
        Five = Four + One;
        Eight = Four + Four;
        Nine = Three * Three;
        TwentySeven = Nine * Three;
        ThirtyTwo = Four * Eight;
        TwoForty = Four * Five * Three * Four;
        MinusOne = -One;
        Half = One / Two;
        OneAndHalf = One + Half;
        ErrCnt[Failure] = 0;
        ErrCnt[Serious] = 0;
        ErrCnt[Defect] = 0;
        ErrCnt[Flaw] = 0;
        PageNo = 1;
        /*=============================================*/
        Milestone = 0;
        /*=============================================*/
//#ifndef NOSIGNAL
//	 signal(SIGFPE, sigfpe);
//#endif
        Instructions();
        Pause();
        Heading();
        Pause();
        Characteristics();
        Pause();
        History();
        Pause();
        /*=============================================*/
        Milestone = 7;
        /*=============================================*/
        printf("Program is now RUNNING tests on small integers:\n");

        TstCond (Failure, (Zero + Zero == Zero) && (One - One == Zero)
                   && (One > Zero) && (One + One == Two),
                        "0+0 != 0, 1-1 != 0, 1 <= 0, or 1+1 != 2");
        Z = - Zero;
        if (Z != 0.0) {
                ErrCnt[Failure] = ErrCnt[Failure] + 1;
                printf("Comparison alleges that -0.0 is Non-zero!\n");
                U1 = 0.001;
                Radix = 1;
                TstPtUf();
                }
        TstCond (Failure, (Three == Two + One) && (Four == Three + One)
                   && (Four + Two * (- Two) == Zero)
                   && (Four - Three - One == Zero),
                   "3 != 2+1, 4 != 3+1, 4+2*(-2) != 0, or 4-3-1 != 0");
        TstCond (Failure, (MinusOne == (0 - One))
                   && (MinusOne + One == Zero ) && (One + MinusOne == Zero)
                   && (MinusOne + FABS(One) == Zero)
                   && (MinusOne + MinusOne * MinusOne == Zero),
                   "-1+1 != 0, (-1)+abs(1) != 0, or -1+(-1)*(-1) != 0");
        TstCond (Failure, Half + MinusOne + Half == Zero,
                  "1/2 + (-1) + 1/2 != 0");
        /*=============================================*/
        /*SPLIT
        part2();
        part3();
        part4();
        part5();
        part6();
        part7();
        part8();
        }
#include "paranoia.h"
part2(){
*/
        Milestone = 10;
        /*=============================================*/
        TstCond (Failure, (Nine == Three * Three)
                   && (TwentySeven == Nine * Three) && (Eight == Four + Four)
                   && (ThirtyTwo == Eight * Four)
                   && (ThirtyTwo - TwentySeven - Four - One == Zero),
                   "9 != 3*3, 27 != 9*3, 32 != 8*4, or 32-27-4-1 != 0");
        TstCond (Failure, (Five == Four + One) &&
                        (TwoForty == Four * Five * Three * Four)
                   && (TwoForty / Three - Four * Four * Five == Zero)
                   && ( TwoForty / Four - Five * Three * Four == Zero)
                   && ( TwoForty / Five - Four * Three * Four == Zero),
                  "5 != 4+1, 240/3 != 80, 240/4 != 60, or 240/5 != 48");
        if (ErrCnt[Failure] == 0) {
                printf("-1, 0, 1/2, 1, 2, 3, 4, 5, 9, 27, 32 & 240 are O.K.\n");
                printf("\n");
                }
        printf("Searching for Radix and Precision.\n");
        W = One;
        do  {
                W = W + W;
                Y = W + One;
                Z = Y - W;
                Y = Z - One;
                } while (MinusOne + FABS(Y) < Zero);
        /*.. now W is just big enough that |((W+1)-W)-1| >= 1 ...*/
        Precision = Zero;
        Y = One;
        do  {
                Radix = W + Y;
                Y = Y + Y;
                Radix = Radix - W;
                } while ( Radix == Zero);
        if (Radix < Two) Radix = One;
        printf("Radix = %f .\n", Radix);
        if (Radix != 1) {
                W = One;
                do  {
                        Precision = Precision + One;
                        W = W * Radix;
                        Y = W + One;
                        } while ((Y - W) == One);
                }
        /*... now W == Radix^Precision is barely too big to satisfy (W+1)-W == 1
                                                      ...*/
        U1 = One / W;
        U2 = Radix * U1;
        printf("Closest relative separation found is U1 = %.7e .\n\n", U1);
        printf("Recalculating radix and precision\n ");

        /*save old values*/
        E0 = Radix;
        E1 = U1;
        E9 = U2;
        E3 = Precision;

        X = Four / Three;
        Third = X - One;
        F6 = Half - Third;
        X = F6 + F6;
        X = FABS(X - Third);
        if (X < U2) X = U2;

        /*... now X = (unknown no.) ulps of 1+...*/
        do  {
                U2 = X;
                Y = Half * U2 + ThirtyTwo * U2 * U2;
                Y = One + Y;
                X = Y - One;
                } while ( ! ((U2 <= X) || (X <= Zero)));

        /*... now U2 == 1 ulp of 1 + ... */
        X = Two / Three;
        F6 = X - Half;
        Third = F6 + F6;
        X = Third - Half;
        X = FABS(X + F6);
        if (X < U1) X = U1;

        /*... now  X == (unknown no.) ulps of 1 -... */
        do  {
                U1 = X;
                Y = Half * U1 + ThirtyTwo * U1 * U1;
                Y = Half - Y;
                X = Half + Y;
                Y = Half - X;
                X = Half + Y;
                } while ( ! ((U1 <= X) || (X <= Zero)));
        /*... now U1 == 1 ulp of 1 - ... */
        if (U1 == E1) printf("confirms closest relative separation U1 .\n");
        else printf("gets better closest relative separation U1 = %.7e .\n", U1);
        W = One / U1;
        F9 = (Half - U1) + Half;
        Radix = FLOOR(0.01 + U2 / U1);
        if (Radix == E0) printf("Radix confirmed.\n");
        else printf("MYSTERY: recalculated Radix = %.7e .\n", Radix);
        TstCond (Defect, Radix <= Eight + Eight,
                   "Radix is too big: roundoff problems");
        TstCond (Flaw, (Radix == Two) || (Radix == 10)
                   || (Radix == One), "Radix is not as good as 2 or 10");
        /*=============================================*/
        Milestone = 20;
        /*=============================================*/
        TstCond (Failure, F9 - Half < Half,
                   "(1-U1)-1/2 < 1/2 is FALSE, prog. fails?");
        X = F9;
        I = 1;
        Y = X - Half;
        Z = Y - Half;
        TstCond (Failure, (X != One)
                   || (Z == Zero), "Comparison is fuzzy,X=1 but X-1/2-1/2 != 0");
        X = One + U2;
        I = 0;
        /*=============================================*/
        Milestone = 25;
        /*=============================================*/
        /*... BMinusU2 = nextafter(Radix, 0) */
        BMinusU2 = Radix - One;
        BMinusU2 = (BMinusU2 - U2) + One;
        /* Purify Integers */
        if (Radix != One)  {
                X = - TwoForty * LOG(U1) / LOG(Radix);
                Y = FLOOR(Half + X);
                if (FABS(X - Y) * Four < One) X = Y;
                Precision = X / TwoForty;
                Y = FLOOR(Half + Precision);
                if (FABS(Precision - Y) * TwoForty < Half) Precision = Y;
                }
        if ((Precision != FLOOR(Precision)) || (Radix == One)) {
                printf("Precision cannot be characterized by an Integer number\n");
                printf("of significant digits but, by itself, this is a minor flaw.\n");
                }
        if (Radix == One)
                printf("logarithmic encoding has precision characterized solely by U1.\n");
        else printf("The number of significant digits of the Radix is %f .\n",
                        Precision);
        TstCond (Serious, U2 * Nine * Nine * TwoForty < One,
                   "Precision worse than 5 decimal figures  ");
        /*=============================================*/
        Milestone = 30;
        /*=============================================*/
        /* Test for extra-precise subepressions */
        X = FABS(((Four / Three - One) - One / Four) * Three - One / Four);
        do  {
                Z2 = X;
                X = (One + (Half * Z2 + ThirtyTwo * Z2 * Z2)) - One;
                } while ( ! ((Z2 <= X) || (X <= Zero)));
        X = Y = Z = FABS((Three / Four - Two / Three) * Three - One / Four);
        do  {
                Z1 = Z;
                Z = (One / Two - ((One / Two - (Half * Z1 + ThirtyTwo * Z1 * Z1))
                        + One / Two)) + One / Two;
                } while ( ! ((Z1 <= Z) || (Z <= Zero)));
        do  {
                do  {
                        Y1 = Y;
                        Y = (Half - ((Half - (Half * Y1 + ThirtyTwo * Y1 * Y1)) + Half
                                )) + Half;
                        } while ( ! ((Y1 <= Y) || (Y <= Zero)));
                X1 = X;
                X = ((Half * X1 + ThirtyTwo * X1 * X1) - F9) + F9;
                } while ( ! ((X1 <= X) || (X <= Zero)));
        if ((X1 != Y1) || (X1 != Z1)) {
                BadCond(Serious, "Disagreements among the values X1, Y1, Z1,\n");
                printf("respectively  %.7e,  %.7e,  %.7e,\n", X1, Y1, Z1);
                printf("are symptoms of inconsistencies introduced\n");
                printf("by extra-precise evaluation of arithmetic subexpressions.\n");
                notify("Possibly some part of this");
                if ((X1 == U1) || (Y1 == U1) || (Z1 == U1))  printf(
                        "That feature is not tested further by this program.\n") ;
                }
        else  {
                if ((Z1 != U1) || (Z2 != U2)) {
                        if ((Z1 >= U1) || (Z2 >= U2)) {
                                BadCond(Failure, "");
                                notify("Precision");
                                printf("\tU1 = %.7e, Z1 - U1 = %.7e\n",U1,Z1-U1);
                                printf("\tU2 = %.7e, Z2 - U2 = %.7e\n",U2,Z2-U2);
                                }
                        else {
                                if ((Z1 <= Zero) || (Z2 <= Zero)) {
                                        printf("Because of unusual Radix = %f", Radix);
                                        printf(", or exact rational arithmetic a result\n");
                                        printf("Z1 = %.7e, or Z2 = %.7e ", Z1, Z2);
                                        notify("of an\nextra-precision");
                                        }
                                if (Z1 != Z2 || Z1 > Zero) {
                                        X = Z1 / U1;
                                        Y = Z2 / U2;
                                        if (Y > X) X = Y;
                                        Q = - LOG(X);
                                        printf("Some subexpressions appear to be calculated extra\n");
                                        printf("precisely with about %g extra B-digits, i.e.\n",
                                                (Q / LOG(Radix)));
                                        printf("roughly %g extra significant decimals.\n",
                                                Q / LOG(10.));
                                        }
                                printf("That feature is not tested further by this program.\n");
                                }
                        }
                }
        Pause();
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part3(){
*/
        Milestone = 35;
        /*=============================================*/
        if (Radix >= Two) {
                X = W / (Radix * Radix);
                Y = X + One;
                Z = Y - X;
                T = Z + U2;
                X = T - Z;
                TstCond (Failure, X == U2,
                        "Subtraction is not normalized X=Y,X+Z != Y+Z!");
                if (X == U2) printf(
                        "Subtraction appears to be normalized, as it should be.");
                }
        printf("\nChecking for guard digit in *, /, and -.\n");
        Y = F9 * One;
        Z = One * F9;
        X = F9 - Half;
        Y = (Y - Half) - X;
        Z = (Z - Half) - X;
        X = One + U2;
        T = X * Radix;
        R = Radix * X;
        X = T - Radix;
        X = X - Radix * U2;
        T = R - Radix;
        T = T - Radix * U2;
        X = X * (Radix - One);
        T = T * (Radix - One);
        if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)) GMult = Yes;
        else {
                GMult = No;
                TstCond (Serious, False,
                        "* lacks a Guard Digit, so 1*X != X");
                }
        Z = Radix * U2;
        X = One + Z;
        Y = FABS((X + Z) - X * X) - U2;
        X = One - U2;
        Z = FABS((X - U2) - X * X) - U1;
        TstCond (Failure, (Y <= Zero)
                   && (Z <= Zero), "* gets too many final digits wrong.\n");
        Y = One - U2;
        X = One + U2;
        Z = One / Y;
        Y = Z - X;
        X = One / Three;
        Z = Three / Nine;
        X = X - Z;
        T = Nine / TwentySeven;
        Z = Z - T;
        TstCond(Defect, X == Zero && Y == Zero && Z == Zero,
                "Division lacks a Guard Digit, so error can exceed 1 ulp\n\
or  1/3  and  3/9  and  9/27 may disagree");
        Y = F9 / One;
        X = F9 - Half;
        Y = (Y - Half) - X;
        X = One + U2;
        T = X / One;
        X = T - X;
        if ((X == Zero) && (Y == Zero) && (Z == Zero)) GDiv = Yes;
        else {
                GDiv = No;
                TstCond (Serious, False,
                        "Division lacks a Guard Digit, so X/1 != X");
                }
        X = One / (One + U2);
        Y = X - Half - Half;
        TstCond (Serious, Y < Zero,
                   "Computed value of 1/1.000..1 >= 1");
        X = One - U2;
        Y = One + Radix * U2;
        Z = X * Radix;
        T = Y * Radix;
        R = Z / Radix;
        StickyBit = T / Radix;
        X = R - X;
        Y = StickyBit - Y;
        TstCond (Failure, X == Zero && Y == Zero,
                        "* and/or / gets too many last digits wrong");
        Y = One - U1;
        X = One - F9;
        Y = One - Y;
        T = Radix - U2;
        Z = Radix - BMinusU2;
        T = Radix - T;
        if ((X == U1) && (Y == U1) && (Z == U2) && (T == U2)) GAddSub = Yes;
        else {
                GAddSub = No;
                TstCond (Serious, False,
                        "- lacks Guard Digit, so cancellation is obscured");
                }
        if (F9 != One && F9 - One >= Zero) {
                BadCond(Serious, "comparison alleges  (1-U1) < 1  although\n");
                printf("  subtraction yields  (1-U1) - 1 = 0 , thereby vitiating\n");
                printf("  such precautions against division by zero as\n");
                printf("  ...  if (X == 1.0) {.....} else {.../(X-1.0)...}\n");
                }
        if (GMult == Yes && GDiv == Yes && GAddSub == Yes) printf(
                "     *, /, and - appear to have guard digits, as they should.\n");
        /*=============================================*/
        Milestone = 40;
        /*=============================================*/
        Pause();
        printf("Checking rounding on multiply, divide and add/subtract.\n");
        RMult = Other;
        RDiv = Other;
        RAddSub = Other;
        RadixD2 = Radix / Two;
        A1 = Two;
        Done = False;
        do  {
                AInvrse = Radix;
                do  {
                        X = AInvrse;
                        AInvrse = AInvrse / A1;
                        } while ( ! (FLOOR(AInvrse) != AInvrse));
                Done = (X == One) || (A1 > Three);
                if (! Done) A1 = Nine + One;
                } while ( ! (Done));
        if (X == One) A1 = Radix;
        AInvrse = One / A1;
        X = A1;
        Y = AInvrse;
        Done = False;
        do  {
                Z = X * Y - Half;
                TstCond (Failure, Z == Half,
                        "X * (1/X) differs from 1");
                Done = X == Radix;
                X = Radix;
                Y = One / X;
                } while ( ! (Done));
        Y2 = One + U2;
        Y1 = One - U2;
        X = OneAndHalf - U2;
        Y = OneAndHalf + U2;
        Z = (X - U2) * Y2;
        T = Y * Y1;
        Z = Z - X;
        T = T - X;
        X = X * Y2;
        Y = (Y + U2) * Y1;
        X = X - OneAndHalf;
        Y = Y - OneAndHalf;
        if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T <= Zero)) {
                X = (OneAndHalf + U2) * Y2;
                Y = OneAndHalf - U2 - U2;
                Z = OneAndHalf + U2 + U2;
                T = (OneAndHalf - U2) * Y1;
                X = X - (Z + U2);
                StickyBit = Y * Y1;
                S = Z * Y2;
                T = T - Y;
                Y = (U2 - Y) + StickyBit;
                Z = S - (Z + U2 + U2);
                StickyBit = (Y2 + U2) * Y1;
                Y1 = Y2 * Y1;
                StickyBit = StickyBit - Y2;
                Y1 = Y1 - Half;
                if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)
                        && ( StickyBit == Zero) && (Y1 == Half)) {
                        RMult = Rounded;
                        printf("Multiplication appears to round correctly.\n");
                        }
                else    if ((X + U2 == Zero) && (Y < Zero) && (Z + U2 == Zero)
                                && (T < Zero) && (StickyBit + U2 == Zero)
                                && (Y1 < Half)) {
                                RMult = Chopped;
                                printf("Multiplication appears to chop.\n");
                                }
                        else printf("* is neither chopped nor correctly rounded.\n");
                if ((RMult == Rounded) && (GMult == No)) notify("Multiplication");
                }
        else printf("* is neither chopped nor correctly rounded.\n");
        /*=============================================*/
        Milestone = 45;
        /*=============================================*/
        Y2 = One + U2;
        Y1 = One - U2;
        Z = OneAndHalf + U2 + U2;
        X = Z / Y2;
        T = OneAndHalf - U2 - U2;
        Y = (T - U2) / Y1;
        Z = (Z + U2) / Y2;
        X = X - OneAndHalf;
        Y = Y - T;
        T = T / Y1;
        Z = Z - (OneAndHalf + U2);
        T = (U2 - OneAndHalf) + T;
        if (! ((X > Zero) || (Y > Zero) || (Z > Zero) || (T > Zero))) {
                X = OneAndHalf / Y2;
                Y = OneAndHalf - U2;
                Z = OneAndHalf + U2;
                X = X - Y;
                T = OneAndHalf / Y1;
                Y = Y / Y1;
                T = T - (Z + U2);
                Y = Y - Z;
                Z = Z / Y2;
                Y1 = (Y2 + U2) / Y2;
                Z = Z - OneAndHalf;
                Y2 = Y1 - Y2;
                Y1 = (F9 - U1) / F9;
                if ((X == Zero) && (Y == Zero) && (Z == Zero) && (T == Zero)
                        && (Y2 == Zero) && (Y2 == Zero)
                        && (Y1 - Half == F9 - Half )) {
                        RDiv = Rounded;
                        printf("Division appears to round correctly.\n");
                        if (GDiv == No) notify("Division");
                        }
                else if ((X < Zero) && (Y < Zero) && (Z < Zero) && (T < Zero)
                        && (Y2 < Zero) && (Y1 - Half < F9 - Half)) {
                        RDiv = Chopped;
                        printf("Division appears to chop.\n");
                        }
                }
        if (RDiv == Other) printf("/ is neither chopped nor correctly rounded.\n");
        BInvrse = One / Radix;
        TstCond (Failure, (BInvrse * Radix - Half == Half),
                   "Radix * ( 1 / Radix ) differs from 1");
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part4(){
*/
        Milestone = 50;
        /*=============================================*/
        TstCond (Failure, ((F9 + U1) - Half == Half)
                   && ((BMinusU2 + U2 ) - One == Radix - One),
                   "Incomplete carry-propagation in Addition");
        X = One - U1 * U1;
        Y = One + U2 * (One - U2);
        Z = F9 - Half;
        X = (X - Half) - Z;
        Y = Y - One;
        if ((X == Zero) && (Y == Zero)) {
                RAddSub = Chopped;
                printf("Add/Subtract appears to be chopped.\n");
                }
        if (GAddSub == Yes) {
                X = (Half + U2) * U2;
                Y = (Half - U2) * U2;
                X = One + X;
                Y = One + Y;
                X = (One + U2) - X;
                Y = One - Y;
                if ((X == Zero) && (Y == Zero)) {
                        X = (Half + U2) * U1;
                        Y = (Half - U2) * U1;
                        X = One - X;
                        Y = One - Y;
                        X = F9 - X;
                        Y = One - Y;
                        if ((X == Zero) && (Y == Zero)) {
                                RAddSub = Rounded;
                                printf("Addition/Subtraction appears to round correctly.\n");
                                if (GAddSub == No) notify("Add/Subtract");
                                }
                        else printf("Addition/Subtraction neither rounds nor chops.\n");
                        }
                else printf("Addition/Subtraction neither rounds nor chops.\n");
                }
        else printf("Addition/Subtraction neither rounds nor chops.\n");
        S = One;
        X = One + Half * (One + Half);
        Y = (One + U2) * Half;
        Z = X - Y;
        T = Y - X;
        StickyBit = Z + T;
        if (StickyBit != Zero) {
                S = Zero;
                BadCond(Flaw, "(X - Y) + (Y - X) is non zero!\n");
                }
        StickyBit = Zero;
        if ((GMult == Yes) && (GDiv == Yes) && (GAddSub == Yes)
                && (RMult == Rounded) && (RDiv == Rounded)
                && (RAddSub == Rounded) && (FLOOR(RadixD2) == RadixD2)) {
                printf("Checking for sticky bit.\n");
                X = (Half + U1) * U2;
                Y = Half * U2;
                Z = One + Y;
                T = One + X;
                if ((Z - One <= Zero) && (T - One >= U2)) {
                        Z = T + Y;
                        Y = Z - X;
                        if ((Z - T >= U2) && (Y - T == Zero)) {
                                X = (Half + U1) * U1;
                                Y = Half * U1;
                                Z = One - Y;
                                T = One - X;
                                if ((Z - One == Zero) && (T - F9 == Zero)) {
                                        Z = (Half - U1) * U1;
                                        T = F9 - Z;
                                        Q = F9 - Y;
                                        if ((T - F9 == Zero) && (F9 - U1 - Q == Zero)) {
                                                Z = (One + U2) * OneAndHalf;
                                                T = (OneAndHalf + U2) - Z + U2;
                                                X = One + Half / Radix;
                                                Y = One + Radix * U2;
                                                Z = X * Y;
                                                if (T == Zero && X + Radix * U2 - Z == Zero) {
                                                        if (Radix != Two) {
                                                                X = Two + U2;
                                                                Y = X / Two;
                                                                if ((Y - One == Zero)) StickyBit = S;
                                                                }
                                                        else StickyBit = S;
                                                        }
                                                }
                                        }
                                }
                        }
                }
        if (StickyBit == One) printf("Sticky bit apparently used correctly.\n");
        else printf("Sticky bit used incorrectly or not at all.\n");
        TstCond (Flaw, !(GMult == No || GDiv == No || GAddSub == No ||
                        RMult == Other || RDiv == Other || RAddSub == Other),
                "lack(s) of guard digits or failure(s) to correctly round or chop\n\
(noted above) count as one flaw in the final tally below");
        /*=============================================*/
        Milestone = 60;
        /*=============================================*/
        printf("\n");
        printf("Does Multiplication commute?  ");
        printf("Testing on %d random pairs.\n", NoTrials);
        Random9 = SQRT(3.0);
        Random1 = Third;
        I = 1;
        do  {
                X = Random();
                Y = Random();
                Z9 = Y * X;
                Z = X * Y;
                Z9 = Z - Z9;
                I = I + 1;
                } while ( ! ((I > NoTrials) || (Z9 != Zero)));
        if (I == NoTrials) {
                Random1 = One + Half / Three;
                Random2 = (U2 + U1) + One;
                Z = Random1 * Random2;
                Y = Random2 * Random1;
                Z9 = (One + Half / Three) * ((U2 + U1) + One) - (One + Half /
                        Three) * ((U2 + U1) + One);
                }
        if (! ((I == NoTrials) || (Z9 == Zero)))
                BadCond(Defect, "X * Y == Y * X trial fails.\n");
        else printf("     No failures found in %d integer pairs.\n", NoTrials);
        /*=============================================*/
        Milestone = 70;
        /*=============================================*/
        printf("\nRunning test of square root(x).\n");
        TstCond (Failure, (Zero == SQRT(Zero))
                   && (- Zero == SQRT(- Zero))
                   && (One == SQRT(One)), "Square root of 0.0, -0.0 or 1.0 wrong");
        MinSqEr = Zero;
        MaxSqEr = Zero;
        J = Zero;
        X = Radix;
        OneUlp = U2;
        SqXMinX (Serious);
        X = BInvrse;
        OneUlp = BInvrse * U1;
        SqXMinX (Serious);
        X = U1;
        OneUlp = U1 * U1;
        SqXMinX (Serious);
        if (J != Zero) Pause();
        printf("Testing if sqrt(X * X) == X for %d Integers X.\n", NoTrials);
        J = Zero;
        X = Two;
        Y = Radix;
        if ((Radix != One)) do  {
                X = Y;
                Y = Radix * Y;
                } while ( ! ((Y - X >= NoTrials)));
        OneUlp = X * U2;
        I = 1;
        while (I <= NoTrials) {
                X = X + One;
                SqXMinX (Defect);
                if (J > Zero) break;
                I = I + 1;
                }
        printf("Test for sqrt monotonicity.\n");
        I = - 1;
        X = BMinusU2;
        Y = Radix;
        Z = Radix + Radix * U2;
        NotMonot = False;
        Monot = False;
        while ( ! (NotMonot || Monot)) {
                I = I + 1;
                X = SQRT(X);
                Q = SQRT(Y);
                Z = SQRT(Z);
                if ((X > Q) || (Q > Z)) NotMonot = True;
                else {
                        Q = FLOOR(Q + Half);
                        if ((I > 0) || (Radix == Q * Q)) Monot = True;
                        else if (I > 0) {
                        if (I > 1) Monot = True;
                        else {
                                Y = Y * BInvrse;
                                X = Y - U1;
                                Z = Y + U1;
                                }
                        }
                        else {
                                Y = Q;
                                X = Y - U2;
                                Z = Y + U2;
                                }
                        }
                }
        if (Monot) printf("sqrt has passed a test for Monotonicity.\n");
        else {
                BadCond(Defect, "");
                printf("sqrt(X) is non-monotonic for X near %.7e .\n", Y);
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part5(){
*/
        Milestone = 80;
        /*=============================================*/
        MinSqEr = MinSqEr + Half;
        MaxSqEr = MaxSqEr - Half;
        Y = (SQRT(One + U2) - One) / U2;
        SqEr = (Y - One) + U2 / Eight;
        if (SqEr > MaxSqEr) MaxSqEr = SqEr;
        SqEr = Y + U2 / Eight;
        if (SqEr < MinSqEr) MinSqEr = SqEr;
        Y = ((SQRT(F9) - U2) - (One - U2)) / U1;
        SqEr = Y + U1 / Eight;
        if (SqEr > MaxSqEr) MaxSqEr = SqEr;
        SqEr = (Y + One) + U1 / Eight;
        if (SqEr < MinSqEr) MinSqEr = SqEr;
        OneUlp = U2;
        X = OneUlp;
        for( Indx = 1; Indx <= 3; ++Indx) {
                Y = SQRT((X + U1 + X) + F9);
                Y = ((Y - U2) - ((One - U2) + X)) / OneUlp;
                Z = ((U1 - X) + F9) * Half * X * X / OneUlp;
                SqEr = (Y + Half) + Z;
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                SqEr = (Y - Half) + Z;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                if (((Indx == 1) || (Indx == 3)))
                        X = OneUlp * Sign (X) * FLOOR(Eight / (Nine * SQRT(OneUlp)));
                else {
                        OneUlp = U1;
                        X = - OneUlp;
                        }
                }
        /*=============================================*/
        Milestone = 85;
        /*=============================================*/
        SqRWrng = False;
        Anomaly = False;
        RSqrt = Other; /* ~dgh */
        if (Radix != One) {
                printf("Testing whether sqrt is rounded or chopped.\n");
                D = FLOOR(Half + POW(Radix, One + Precision - FLOOR(Precision)));
        /* ... == Radix^(1 + fract) if (Precision == Integer + fract. */
                X = D / Radix;
                Y = D / A1;
                if ((X != FLOOR(X)) || (Y != FLOOR(Y))) {
                        Anomaly = True;
                        }
                else {
                        X = Zero;
                        Z2 = X;
                        Y = One;
                        Y2 = Y;
                        Z1 = Radix - One;
                        FourD = Four * D;
                        do  {
                                if (Y2 > Z2) {
                                        Q = Radix;
                                        Y1 = Y;
                                        do  {
                                                X1 = FABS(Q + FLOOR(Half - Q / Y1) * Y1);
                                                Q = Y1;
                                                Y1 = X1;
                                                } while ( ! (X1 <= Zero));
                                        if (Q <= One) {
                                                Z2 = Y2;
                                                Z = Y;
                                                }
                                        }
                                Y = Y + Two;
                                X = X + Eight;
                                Y2 = Y2 + X;
                                if (Y2 >= FourD) Y2 = Y2 - FourD;
                                } while ( ! (Y >= D));
                        X8 = FourD - Z2;
                        Q = (X8 + Z * Z) / FourD;
                        X8 = X8 / Eight;
                        if (Q != FLOOR(Q)) Anomaly = True;
                        else {
                                Break = False;
                                do  {
                                        X = Z1 * Z;
                                        X = X - FLOOR(X / Radix) * Radix;
                                        if (X == One)
                                                Break = True;
                                        else
                                                Z1 = Z1 - One;
                                        } while ( ! (Break || (Z1 <= Zero)));
                                if ((Z1 <= Zero) && (! Break)) Anomaly = True;
                                else {
                                        if (Z1 > RadixD2) Z1 = Z1 - Radix;
                                        do  {
                                                NewD();
                                                } while ( ! (U2 * D >= F9));
                                        if (D * Radix - D != W - D) Anomaly = True;
                                        else {
                                                Z2 = D;
                                                I = 0;
                                                Y = D + (One + Z) * Half;
                                                X = D + Z + Q;
                                                SR3750();
                                                Y = D + (One - Z) * Half + D;
                                                X = D - Z + D;
                                                X = X + Q + X;
                                                SR3750();
                                                NewD();
                                                if (D - Z2 != W - Z2) Anomaly = True;
                                                else {
                                                        Y = (D - Z2) + (Z2 + (One - Z) * Half);
                                                        X = (D - Z2) + (Z2 - Z + Q);
                                                        SR3750();
                                                        Y = (One + Z) * Half;
                                                        X = Q;
                                                        SR3750();
                                                        if (I == 0) Anomaly = True;
                                                        }
                                                }
                                        }
                                }
                        }
                if ((I == 0) || Anomaly) {
                        BadCond(Failure, "Anomalous arithmetic with Integer < ");
                        printf("Radix^Precision = %.7e\n", W);
                        printf(" fails test whether sqrt rounds or chops.\n");
                        SqRWrng = True;
                        }
                }
        if (! Anomaly) {
                if (! ((MinSqEr < Zero) || (MaxSqEr > Zero))) {
                        RSqrt = Rounded;
                        printf("Square root appears to be correctly rounded.\n");
                        }
                else  {
                        if ((MaxSqEr + U2 > U2 - Half) || (MinSqEr > Half)
                                || (MinSqEr + Radix < Half)) SqRWrng = True;
                        else {
                                RSqrt = Chopped;
                                printf("Square root appears to be chopped.\n");
                                }
                        }
                }
        if (SqRWrng) {
                printf("Square root is neither chopped nor correctly rounded.\n");
                printf("Observed errors run from %.7e ", MinSqEr - Half);
                printf("to %.7e ulps.\n", Half + MaxSqEr);
                TstCond (Serious, MaxSqEr - MinSqEr < Radix * Radix,
                        "sqrt gets too many last digits wrong");
                }
        /*=============================================*/
        Milestone = 90;
        /*=============================================*/
        Pause();
        printf("Testing powers Z^i for small Integers Z and i.\n");
        N = 0;
        /* ... test powers of zero. */
        I = 0;
        Z = -Zero;
        Break = False;
        do  {
                X = One;
                SR3980();
                if (I <= 10) {
                        I = 1023;
                        SR3980();
                        }
                if (Z == MinusOne) Break = True;
                else {
                        Z = MinusOne;
                        PrintIfNPositive();
                        N = 0;
                        /* .. if(-1)^N is invalid, replace MinusOne by One. */
                        I = - 4;
                        }
                } while ( ! Break);
        PrintIfNPositive();
        N1 = N;
        N = 0;
        Z = A1;
        Break = False;
        do  {
                X = Z;
                I = 1;
                SR3980();
                if (Z == AInvrse) Break = True;
                else Z = AInvrse;
                } while ( ! (Break));
        /*=============================================*/
                Milestone = 100;
        /*=============================================*/
        /*  Powers of Radix have been tested, */
        /*         next try a few primes     */
        M = NoTrials;
        Z = Three;
        do  {
                X = Z;
                I = 1;
                SR3980();
                do  {
                        Z = Z + Two;
                        } while ( Three * FLOOR(Z / Three) == Z );
                } while ( Z < Eight * Three );
        if (N > 0) {
                printf("Errors like this may invalidate financial calculations\n");
                printf("\tinvolving interest rates.\n");
                }
        PrintIfNPositive();
        N += N1;
        if (N == 0) printf("... no discrepancis found.\n");
        if (N > 0) Pause();
        else printf("\n");
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part6(){
*/
        Milestone = 110;
        /*=============================================*/
        printf("Seeking Underflow thresholds UfThold and E0.\n");
        D = U1;
        if (Precision != FLOOR(Precision)) {
                D = BInvrse;
                X = Precision;
                do  {
                        D = D * BInvrse;
                        X = X - One;
                        } while ( X > Zero);
                }
        Y = One;
        Z = D;
        /* ... D is power of 1/Radix < 1. */
        do  {
                C = Y;
                Y = Z;
                Z = Y * Y;
                } while ((Y > Z) && (Z + Z > Z));
        Y = C;
        Z = Y * D;
        do  {
                C = Y;
                Y = Z;
                Z = Y * D;
                } while ((Y > Z) && (Z + Z > Z));
        if (Radix < Two) HInvrse = Two;
        else HInvrse = Radix;
        H = One / HInvrse;
        /* ... 1/HInvrse == H == Min(1/Radix, 1/2) */
        CInvrse = One / C;
        E0 = C;
        Z = E0 * H;
        /* ...1/Radix^(BIG Integer) << 1 << CInvrse == 1/C */
        do  {
                Y = E0;
                E0 = Z;
                Z = E0 * H;
                } while ((E0 > Z) && (Z + Z > Z));
        UfThold = E0;
        E1 = Zero;
        Q = Zero;
        E9 = U2;
        S = One + E9;
        D = C * S;
        if (D <= C) {
                E9 = Radix * U2;
                S = One + E9;
                D = C * S;
                if (D <= C) {
                        BadCond(Failure, "multiplication gets too many last digits wrong.\n");
                        Underflow = E0;
                        Y1 = Zero;
                        PseudoZero = Z;
                        Pause();
                        }
                }
        else {
                Underflow = D;
                PseudoZero = Underflow * H;
                UfThold = Zero;
                do  {
                        Y1 = Underflow;
                        Underflow = PseudoZero;
                        if (E1 + E1 <= E1) {
                                Y2 = Underflow * HInvrse;
                                E1 = FABS(Y1 - Y2);
                                Q = Y1;
                                if ((UfThold == Zero) && (Y1 != Y2)) UfThold = Y1;
                                }
                        PseudoZero = PseudoZero * H;
                        } while ((Underflow > PseudoZero)
                                && (PseudoZero + PseudoZero > PseudoZero));
                }
        /* Comment line 4530 .. 4560 */
        if (PseudoZero != Zero) {
                printf("\n");
                Z = PseudoZero;
        /* ... Test PseudoZero for "phoney- zero" violates */
        /* ... PseudoZero < Underflow or PseudoZero < PseudoZero + PseudoZero
                   ... */
                if (PseudoZero <= Zero) {
                        BadCond(Failure, "Positive expressions can underflow to an\n");
                        printf("allegedly negative value\n");
                        printf("PseudoZero that prints out as: %g .\n", PseudoZero);
                        X = - PseudoZero;
                        if (X <= Zero) {
                                printf("But -PseudoZero, which should be\n");
                                printf("positive, isn't; it prints out as  %g .\n", X);
                                }
                        }
                else {
                        BadCond(Flaw, "Underflow can stick at an allegedly positive\n");
                        printf("value PseudoZero that prints out as %g .\n", PseudoZero);
                        }
                TstPtUf();
                }
        /*=============================================*/
        Milestone = 120;
        /*=============================================*/
        if (CInvrse * Y > CInvrse * Y1) {
                S = H * S;
                E0 = Underflow;
                }
        if (! ((E1 == Zero) || (E1 == E0))) {
                BadCond(Defect, "");
                if (E1 < E0) {
                        printf("Products underflow at a higher");
                        printf(" threshold than differences.\n");
                        if (PseudoZero == Zero)
                        E0 = E1;
                        }
                else {
                        printf("Difference underflows at a higher");
                        printf(" threshold than products.\n");
                        }
                }
        printf("Smallest strictly positive number found is E0 = %g .\n", E0);
        Z = E0;
        TstPtUf();
        Underflow = E0;
        if (N == 1) Underflow = Y;
        I = 4;
        if (E1 == Zero) I = 3;
        if (UfThold == Zero) I = I - 2;
        UfNGrad = True;
        switch (I)  {
                case    1:
                UfThold = Underflow;
                if ((CInvrse * Q) != ((CInvrse * Y) * S)) {
                        UfThold = Y;
                        BadCond(Failure, "Either accuracy deteriorates as numbers\n");
                        printf("approach a threshold = %.17e\n", UfThold);;
                        printf(" coming down from %.17e\n", C);
                        printf(" or else multiplication gets too many last digits wrong.\n");
                        }
                Pause();
                break;

                case    2:
                BadCond(Failure, "Underflow confuses Comparison, which alleges that\n");
                printf("Q == Y while denying that |Q - Y| == 0; these values\n");
                printf("print out as Q = %.17e, Y = %.17e .\n", Q, Y2);
                printf ("|Q - Y| = %.17e .\n" , FABS(Q - Y2));
                UfThold = Q;
                break;

                case    3:
                X = X;
                break;

                case    4:
                if ((Q == UfThold) && (E1 == E0)
                        && (FABS( UfThold - E1 / E9) <= E1)) {
                        UfNGrad = False;
                        printf("Underflow is gradual; it incurs Absolute Error =\n");
                        printf("(roundoff in UfThold) < E0.\n");
                        Y = E0 * CInvrse;
                        Y = Y * (OneAndHalf + U2);
                        X = CInvrse * (One + U2);
                        Y = Y / X;
                        IEEE = (Y == E0);
                        }
                }
        if (UfNGrad) {
                printf("\n");
                sigsave = sigfpe;
                if (setjmp(ovfl_buf)) {
                        printf("Underflow / UfThold failed!\n");
                        R = H + H;
                        }
                else R = SQRT(Underflow / UfThold);
                printf("### %.17e %.17e %.17e %.17e\n", Underflow, UfThold, R, H);
                sigsave = 0;
                if (R <= H) {
                        Z = R * UfThold;
                        X = Z * (One + R * H * (One + H));
                        }
                else {
                        Z = UfThold;
                        X = Z * (One + H * H * (One + H));
                        }
                printf("### %.17e %.17e %.17e %.17e %.17e %.17e\n", Underflow, UfThold, R, H, X, Z);
                if (! ((X == Z) || (X - Z != Zero))) {
                        BadCond(Flaw, "");
                        printf("X = %.17e\n\tis not equal to Z = %.17e .\n", X, Z);
                        Z9 = X - Z;
                        printf("yet X - Z yields %.17e .\n", Z9);
                        printf("    Should this NOT signal Underflow, ");
                        printf("this is a SERIOUS DEFECT\nthat causes ");
                        printf("confusion when innocent statements like\n");;
                        printf("    if (X == Z)  ...  else");
                        printf("  ... (f(X) - f(Z)) / (X - Z) ...\n");
                        printf("encounter Division by Zero although actually\n");
                        sigsave = sigfpe;
                        if (setjmp(ovfl_buf)) printf("X / Z fails!\n");
                        else printf("X / Z = 1 + %g .\n", (X / Z - Half) - Half);
                        sigsave = 0;
                        }
                }
        printf("The Underflow threshold is %.17e, %s\n", UfThold,
                   " below which");
        printf("calculation may suffer larger Relative error than ");
        printf("merely roundoff.\n");
        Y2 = U1 * U1;
        Y = Y2 * Y2;
        Y2 = Y * U1;
        if (Y2 <= UfThold) {
                if (Y > E0) {
                        BadCond(Defect, "");
                        I = 5;
                        }
                else {
                        BadCond(Serious, "");
                        I = 4;
                        }
                printf("Range is too narrow; U1^%d Underflows.\n", I);
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part7(){
*/
        Milestone = 130;
        /*=============================================*/
        Y = - FLOOR(Half - TwoForty * LOG(UfThold) / LOG(HInvrse)) / TwoForty;
        Y2 = Y + Y;
        printf("Since underflow occurs below the threshold\n");
        printf("UfThold = (%.17e) ^ (%.17e)\nonly underflow ", HInvrse, Y);
        printf("should afflict the expression\n\t(%.17e) ^ (%.17e);\n", HInvrse, Y);
        V9 = POW(HInvrse, Y2);
        printf("actually calculating yields: %.17e .\n", V9);
        if (! ((V9 >= Zero) && (V9 <= (Radix + Radix + E9) * UfThold))) {
                BadCond(Serious, "this is not between 0 and underflow\n");
                printf("   threshold = %.17e .\n", UfThold);
                }
        else if (! (V9 > UfThold * (One + E9)))
                printf("This computed value is O.K.\n");
        else {
                BadCond(Defect, "this is not between 0 and underflow\n");
                printf("   threshold = %.17e .\n", UfThold);
                }
        /*=============================================*/
        Milestone = 140;
        /*=============================================*/
        printf("\n");
        /* ...calculate Exp2 == exp(2) == 7.389056099... */
        X = Zero;
        I = 2;
        Y = Two * Three;
        Q = Zero;
        N = 0;
        do  {
                Z = X;
                I = I + 1;
                Y = Y / (I + I);
                R = Y + Q;
                X = Z + R;
                Q = (Z - X) + R;
                } while(X > Z);
        Z = (OneAndHalf + One / Eight) + X / (OneAndHalf * ThirtyTwo);
        X = Z * Z;
        Exp2 = X * X;
        X = F9;
        Y = X - U1;
        printf("Testing X^((X + 1) / (X - 1)) vs. exp(2) = %.17e as X -> 1.\n",
                Exp2);
        for(I = 1;;) {
                Z = X - BInvrse;
                Z = (X + One) / (Z - (One - BInvrse));
                Q = POW(X, Z) - Exp2;
                if (FABS(Q) > TwoForty * U2) {
                        N = 1;
                        V9 = (X - BInvrse) - (One - BInvrse);
                        BadCond(Defect, "Calculated");
                        printf(" %.17e for\n", POW(X,Z));
                        printf("\t(1 + (%.17e) ^ (%.17e);\n", V9, Z);
                        printf("\tdiffers from correct value by %.17e .\n", Q);
                        printf("\tThis much error may spoil financial\n");
                        printf("\tcalculations involving tiny interest rates.\n");
                        break;
                        }
                else {
                        Z = (Y - X) * Two + Y;
                        X = Y;
                        Y = Z;
                        Z = One + (X - F9)*(X - F9);
                        if (Z > One && I < NoTrials) I++;
                        else  {
                                if (X > One) {
                                        if (N == 0)
                                           printf("Accuracy seems adequate.\n");
                                        break;
                                        }
                                else {
                                        X = One + U2;
                                        Y = U2 + U2;
                                        Y += X;
                                        I = 1;
                                        }
                                }
                        }
                }
        /*=============================================*/
        Milestone = 150;
        /*=============================================*/
        printf("Testing powers Z^Q at four nearly extreme values.\n");
        N = 0;
        Z = A1;
        Q = FLOOR(Half - LOG(C) / LOG(A1));
        Break = False;
        do  {
                X = CInvrse;
                Y = POW(Z, Q);
                IsYeqX();
                Q = - Q;
                X = C;
                Y = POW(Z, Q);
                IsYeqX();
                if (Z < One) Break = True;
                else Z = AInvrse;
                } while ( ! (Break));
        PrintIfNPositive();
        if (N == 0) printf(" ... no discrepancies found.\n");
        printf("\n");

        /*=============================================*/
        Milestone = 160;
        /*=============================================*/
        Pause();
        printf("Searching for Overflow threshold:\n");
        printf("This may generate an error.\n");
        Y = - CInvrse;
        V9 = HInvrse * Y;
        sigsave = sigfpe;
        if (setjmp(ovfl_buf)) { I = 0; V9 = Y; goto overflow; }
        do {
                V = Y;
                Y = V9;
                V9 = HInvrse * Y;
                } while(V9 < Y);
        I = 1;
overflow:
        sigsave = 0;
        Z = V9;
        printf("Can `Z = -Y' overflow?\n");
        printf("Trying it on Y = %.17e .\n", Y);
        V9 = - Y;
        V0 = V9;
        if (V - Y == V + V0) printf("Seems O.K.\n");
        else {
                printf("finds a ");
                BadCond(Flaw, "-(-Y) differs from Y.\n");
                }
        if (Z != Y) {
                BadCond(Serious, "");
                printf("overflow past %.17e\n\tshrinks to %.17e .\n", Y, Z);
                }
        if (I) {
                Y = V * (HInvrse * U2 - HInvrse);
                Z = Y + ((One - HInvrse) * U2) * V;
                if (Z < V0) Y = Z;
                if (Y < V0) V = Y;
                if (V0 - V < V0) V = V0;
                }
        else {
                V = Y * (HInvrse * U2 - HInvrse);
                V = V + ((One - HInvrse) * U2) * Y;
                }
        printf("Overflow threshold is V  = %.17e .\n", V);
        if (I) printf("Overflow saturates at V0 = %.17e .\n", V0);
        else printf("There is no saturation value because \
the system traps on overflow.\n");
        V9 = V * One;
        printf("No Overflow should be signaled for V * 1 = %.17e\n", V9);
        V9 = V / One;
        printf("                           nor for V / 1 = %.17e .\n", V9);
        printf("Any overflow signal separating this * from the one\n");
        printf("above is a DEFECT.\n");
        /*=============================================*/
        Milestone = 170;
        /*=============================================*/
        if (!(-V < V && -V0 < V0 && -UfThold < V && UfThold < V)) {
                BadCond(Failure, "Comparisons involving ");
                printf("+-%g, +-%g\nand +-%g are confused by Overflow.",
                        V, V0, UfThold);
                }
        /*=============================================*/
        Milestone = 175;
        /*=============================================*/
        printf("\n");
        for(Indx = 1; Indx <= 3; ++Indx) {
                switch (Indx)  {
                        case 1: Z = UfThold; break;
                        case 2: Z = E0; break;
                        case 3: Z = PseudoZero; break;
                        }
                if (Z != Zero) {
                        V9 = SQRT(Z);
                        Y = V9 * V9;
                        if (Y / (One - Radix * E9) < Z
                           || Y > (One + Radix * E9) * Z) { /* dgh: + E9 --> * E9 */
                                if (V9 > U1) BadCond(Serious, "");
                                else BadCond(Defect, "");
                                printf("Comparison alleges that what prints as Z = %.17e\n", Z);
                                printf(" is too far from sqrt(Z) ^ 2 = %.17e .\n", Y);
                                }
                        }
                }
        /*=============================================*/
        Milestone = 180;
        /*=============================================*/
        for(Indx = 1; Indx <= 2; ++Indx) {
                if (Indx == 1) Z = V;
                else Z = V0;
                V9 = SQRT(Z);
                X = (One - Radix * E9) * V9;
                V9 = V9 * X;
                if (((V9 < (One - Two * Radix * E9) * Z) || (V9 > Z))) {
                        Y = V9;
                        if (X < W) BadCond(Serious, "");
                        else BadCond(Defect, "");
                        printf("Comparison alleges that Z = %17e\n", Z);
                        printf(" is too far from sqrt(Z) ^ 2 (%.17e) .\n", Y);
                        }
                }
        /*=============================================*/
        /*SPLIT
        }
#include "paranoia.h"
part8(){
*/
        Milestone = 190;
        /*=============================================*/
        Pause();
        X = UfThold * V;
        Y = Radix * Radix;
        if (X*Y < One || X > Y) {
                if (X * Y < U1 || X > Y/U1) BadCond(Defect, "Badly");
                else BadCond(Flaw, "");

                printf(" unbalanced range; UfThold * V = %.17e\n\t%s\n",
                        X, "is too far from 1.\n");
                }
        /*=============================================*/
        Milestone = 200;
        /*=============================================*/
        for (Indx = 1; Indx <= 5; ++Indx)  {
                X = F9;
                switch (Indx)  {
                        case 2: X = One + U2; break;
                        case 3: X = V; break;
                        case 4: X = UfThold; break;
                        case 5: X = Radix;
                        }
                Y = X;
                sigsave = sigfpe;
                if (setjmp(ovfl_buf))
                        printf("  X / X  traps when X = %g\n", X);
                else {
                        V9 = (Y / X - Half) - Half;
                        if (V9 == Zero) continue;
                        if (V9 == - U1 && Indx < 5) BadCond(Flaw, "");
                        else BadCond(Serious, "");
                        printf("  X / X differs from 1 when X = %.17e\n", X);
                        printf("  instead, X / X - 1/2 - 1/2 = %.17e .\n", V9);
                        }
                sigsave = 0;
                }
        /*=============================================*/
        Milestone = 210;
        /*=============================================*/
        MyZero = Zero;
        printf("\n");
        printf("What message and/or values does Division by Zero produce?\n") ;
#ifndef NOPAUSE
        printf("This can interupt your program.  You can ");
        printf("skip this part if you wish.\n");
        printf("Do you wish to compute 1 / 0? ");
        fflush(stdout);
        read (KEYBOARD, ch, 8);
        if ((ch[0] == 'Y') || (ch[0] == 'y')) {
#endif
                sigsave = sigfpe;
                printf("    Trying to compute 1 / 0 produces ...");
                if (!setjmp(ovfl_buf)) printf("  %.7e .\n", One / MyZero);
                sigsave = 0;
#ifndef NOPAUSE
                }
        else printf("O.K.\n");
        printf("\nDo you wish to compute 0 / 0? ");
        fflush(stdout);
        read (KEYBOARD, ch, 80);
        if ((ch[0] == 'Y') || (ch[0] == 'y')) {
#endif
                sigsave = sigfpe;
                printf("\n    Trying to compute 0 / 0 produces ...");
                if (!setjmp(ovfl_buf)) printf("  %.7e .\n", Zero / MyZero);
                sigsave = 0;
#ifndef NOPAUSE
                }
        else printf("O.K.\n");
#endif
        /*=============================================*/
        Milestone = 220;
        /*=============================================*/
        Pause();
        printf("\n");
        {
                static char *msg[] = {
                        "FAILUREs  encountered =",
                        "SERIOUS DEFECTs  discovered =",
                        "DEFECTs  discovered =",
                        "FLAWs  discovered =" };
                int i;
                for(i = 0; i < 4; i++) if (ErrCnt[i])
                        printf("The number of  %-29s %d.\n",
                                msg[i], ErrCnt[i]);
                }
        printf("\n");
        if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[Defect]
                        + ErrCnt[Flaw]) > 0) {
                if ((ErrCnt[Failure] + ErrCnt[Serious] + ErrCnt[
                        Defect] == 0) && (ErrCnt[Flaw] > 0)) {
                        printf("The arithmetic diagnosed seems ");
                        printf("Satisfactory though flawed.\n");
                        }
                if ((ErrCnt[Failure] + ErrCnt[Serious] == 0)
                        && ( ErrCnt[Defect] > 0)) {
                        printf("The arithmetic diagnosed may be Acceptable\n");
                        printf("despite inconvenient Defects.\n");
                        }
                if ((ErrCnt[Failure] + ErrCnt[Serious]) > 0) {
                        printf("The arithmetic diagnosed has ");
                        printf("unacceptable Serious Defects.\n");
                        }
                if (ErrCnt[Failure] > 0) {
                        printf("Potentially fatal FAILURE may have spoiled this");
                        printf(" program's subsequent diagnoses.\n");
                        }
                }
        else {
                printf("No failures, defects nor flaws have been discovered.\n");
                if (! ((RMult == Rounded) && (RDiv == Rounded)
                        && (RAddSub == Rounded) && (RSqrt == Rounded)))
                        printf("The arithmetic diagnosed seems Satisfactory.\n");
                else {
                        if (StickyBit >= One &&
                                (Radix - Two) * (Radix - Nine - One) == Zero) {
                                printf("Rounding appears to conform to ");
                                printf("the proposed IEEE standard P");
                                if ((Radix == Two) &&
                                         ((Precision - Four * Three * Two) *
                                          ( Precision - TwentySeven -
                                           TwentySeven + One) == Zero))
                                        printf("754");
                                else printf("854");
                                if (IEEE) printf(".\n");
                                else {
                                        printf(",\nexcept for possibly Double Rounding");
                                        printf(" during Gradual Underflow.\n");
                                        }
                                }
                        printf("The arithmetic diagnosed appears to be Excellent!\n");
                        }
                }
        if (fpecount)
                printf("\nA total of %d floating point exceptions were registered.\n",
                        fpecount);
	printf("END OF TEST.\n");

/***  Begin NON_PARANOIA modification  ***/
	return( 0 );
/***  End NON_PARANOIA modification  ***/
	}

/*SPLIT subs.c
#include "paranoia.h"
*/

/* Sign */

FLOAT Sign (X)
FLOAT X;
{ return X >= 0. ? 1.0 : -1.0; }

/* Pause */

void Pause(void)
{
#ifndef NOPAUSE
        char ch[8];

        printf("\nTo continue, press RETURN");
        fflush(stdout);
        read(KEYBOARD, ch, 8);
#endif
        printf("\nDiagnosis resumes after milestone Number %d", Milestone);
        printf("          Page: %d\n\n", PageNo);
        ++Milestone;
        ++PageNo;
        }

 /* TstCond */

void TstCond (int K, int Valid, char *T)
{ if (! Valid) { BadCond(K,T); printf(".\n"); } }

void BadCond(int K, char *T)
{
        static char *msg[] = { "FAILURE", "SERIOUS DEFECT", "DEFECT", "FLAW" };

        ErrCnt [K] = ErrCnt [K] + 1;
        printf("%s:  %s", msg[K], T);
        }

/* Random */
/*  Random computes
     X = (Random1 + Random9)^5
     Random1 = X - FLOOR(X) + 0.000005 * X;
   and returns the new value of Random1
*/

FLOAT Random()
{
        FLOAT X, Y;

        X = Random1 + Random9;
        Y = X * X;
        Y = Y * Y;
        X = X * Y;
        Y = X - FLOOR(X);
        Random1 = Y + X * 0.000005;
        return(Random1);
        }

/* SqXMinX */

void SqXMinX (int ErrKind)
{
        FLOAT XA, XB;

        XB = X * BInvrse;
        XA = X - XB;
        SqEr = ((SQRT(X * X) - XB) - XA) / OneUlp;
        if (SqEr != Zero) {
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                J = J + 1.0;
                BadCond(ErrKind, "\n");
                printf("sqrt( %.17e) - %.17e  = %.17e\n", X * X, X, OneUlp * SqEr);
                printf("\tinstead of correct value 0 .\n");
                }
        }

/* NewD */

void NewD(void)
{
        X = Z1 * Q;
        X = FLOOR(Half - X / Radix) * Radix + X;
        Q = (Q - X * Z) / Radix + X * X * (D / Radix);
        Z = Z - Two * X * D;
        if (Z <= Zero) {
                Z = - Z;
                Z1 = - Z1;
                }
        D = Radix * D;
        }

/* SR3750 */

void SR3750(void)
{
        if (! ((X - Radix < Z2 - Radix) || (X - Z2 > W - Z2))) {
                I = I + 1;
                X2 = SQRT(X * D);
                Y2 = (X2 - Z2) - (Y - Z2);
                X2 = X8 / (Y - Half);
                X2 = X2 - Half * X2 * X2;
                SqEr = (Y2 + Half) + (Half - X2);
                if (SqEr < MinSqEr) MinSqEr = SqEr;
                SqEr = Y2 - X2;
                if (SqEr > MaxSqEr) MaxSqEr = SqEr;
                }
        }

/* IsYeqX */

void IsYeqX(void)
{
        if (Y != X) {
                if (N <= 0) {
                        if (Z == Zero && Q <= Zero)
                                printf("WARNING:  computing\n");
                        else BadCond(Defect, "computing\n");
                        printf("\t(%.17e) ^ (%.17e)\n", Z, Q);
                        printf("\tyielded %.17e;\n", Y);
                        printf("\twhich compared unequal to correct %.17e ;\n",
                                X);
                        printf("\t\tthey differ by %.17e .\n", Y - X);
                        }
                N = N + 1; /* ... count discrepancies. */
                }
        }

/* SR3980 */

void SR3980(void)
{
        do {
                Q = (FLOAT) I;
                Y = POW(Z, Q);
                IsYeqX();
                if (++I > M) break;
                X = Z * X;
                } while ( X < W );
        }

/* PrintIfNPositive */

void PrintIfNPositive(void)
{
        if (N > 0) printf("Similar discrepancies have occurred %d times.\n", N);
        }

/* TstPtUf */

void TstPtUf(void)
{
        N = 0;
        if (Z != Zero) {
                printf("Since comparison denies Z = 0, evaluating ");
                printf("(Z + Z) / Z should be safe.\n");
                sigsave = sigfpe;
                if (setjmp(ovfl_buf)) goto very_serious;
                Q9 = (Z + Z) / Z;
                printf("What the machine gets for (Z + Z) / Z is  %.17e .\n",
                        Q9);
                if (FABS(Q9 - Two) < Radix * U2) {
                        printf("This is O.K., provided Over/Underflow");
                        printf(" has NOT just been signaled.\n");
                        }
                else {
                        if ((Q9 < One) || (Q9 > Two)) {
very_serious:
                                N = 1;
                                ErrCnt [Serious] = ErrCnt [Serious] + 1;
                                printf("This is a VERY SERIOUS DEFECT!\n");
                                }
                        else {
                                N = 1;
                                ErrCnt [Defect] = ErrCnt [Defect] + 1;
                                printf("This is a DEFECT!\n");
                                }
                        }
                sigsave = 0;
                V9 = Z * One;
                Random1 = V9;
                V9 = One * Z;
                Random2 = V9;
                V9 = Z / One;
                if ((Z == Random1) && (Z == Random2) && (Z == V9)) {
                        if (N > 0) Pause();
                        }
                else {
                        N = 1;
                        BadCond(Defect, "What prints as Z = ");
                        printf("%.17e\n\tcompares different from  ", Z);
                        if (Z != Random1) printf("Z * 1 = %.17e ", Random1);
                        if (! ((Z == Random2)
                                || (Random2 == Random1)))
                                printf("1 * Z == %g\n", Random2);
                        if (! (Z == V9)) printf("Z / 1 = %.17e\n", V9);
                        if (Random2 != Random1) {
                                ErrCnt [Defect] = ErrCnt [Defect] + 1;
                                BadCond(Defect, "Multiplication does not commute!\n");
                                printf("\tComparison alleges that 1 * Z = %.17e\n",
                                        Random2);
                                printf("\tdiffers from Z * 1 = %.17e\n", Random1);
                                }
                        Pause();
                        }
                }
        }

void notify(char *s)
{
        printf("%s test appears to be inconsistent...\n", s);
        printf("   PLEASE NOTIFY KARPINKSI!\n");
        }

/*SPLIT msgs.c */

/* Instructions */

void msglist(char **s)
{ while(*s) printf("%s\n", *s++); }

void Instructions(void)
{
  static char *instr[] = {
        "Lest this program stop prematurely, i.e. before displaying\n",
        "    `END OF TEST',\n",
        "try to persuade the computer NOT to terminate execution when an",
        "error like Over/Underflow or Division by Zero occurs, but rather",
        "to persevere with a surrogate value after, perhaps, displaying some",
        "warning.  If persuasion avails naught, don't despair but run this",
        "program anyway to see how many milestones it passes, and then",
        "amend it to make further progress.\n",
        "Answer questions with Y, y, N or n (unless otherwise indicated).\n",
        0};

        msglist(instr);
        }

/* Heading */

void Heading(void)
{
  static char *head[] = {
        "Users are invited to help debug and augment this program so it will",
        "cope with unanticipated and newly uncovered arithmetic pathologies.\n",
        "Please send suggestions and interesting results to",
        "\tRichard Karpinski",
        "\tComputer Center U-76",
        "\tUniversity of California",
        "\tSan Francisco, CA 94143-0704, USA\n",
        "In doing so, please include the following information:",
#ifdef Single
        "\tPrecision:\tsingle;",
#else
        "\tPrecision:\tdouble;",
#endif
        "\tVersion:\t10 February 1989;",
        "\tComputer:\n",
        "\tCompiler:\n",
        "\tOptimization level:\n",
        "\tOther relevant compiler options:",
        0};

        msglist(head);
        }

/* Characteristics */

void Characteristics(void)
{
        static char *chars[] = {
         "Running this program should reveal these characteristics:",
        "     Radix = 1, 2, 4, 8, 10, 16, 100, 256 ...",
        "     Precision = number of significant digits carried.",
        "     U2 = Radix/Radix^Precision = One Ulp",
        "\t(OneUlpnit in the Last Place) of 1.000xxx .",
        "     U1 = 1/Radix^Precision = One Ulp of numbers a little less than 1.0 .",
        "     Adequacy of guard digits for Mult., Div. and Subt.",
        "     Whether arithmetic is chopped, correctly rounded, or something else",
        "\tfor Mult., Div., Add/Subt. and Sqrt.",
        "     Whether a Sticky Bit used correctly for rounding.",
        "     UnderflowThreshold = an underflow threshold.",
        "     E0 and PseudoZero tell whether underflow is abrupt, gradual, or fuzzy.",
        "     V = an overflow threshold, roughly.",
        "     V0  tells, roughly, whether  Infinity  is represented.",
        "     Comparisions are checked for consistency with subtraction",
        "\tand for contamination with pseudo-zeros.",
        "     Sqrt is tested.  Y^X is not tested.",
        "     Extra-precise subexpressions are revealed but NOT YET tested.",
        "     Decimal-Binary conversion is NOT YET tested for accuracy.",
        0};

        msglist(chars);
        }

/* History */

void History(void)
{
 /* Converted from Brian Wichmann's Pascal version to C by Thos Sumner,
        with further massaging by David M. Gay. */

  static char *hist[] = {
        "The program attempts to discriminate among",
        "   FLAWs, like lack of a sticky bit,",
        "   Serious DEFECTs, like lack of a guard digit, and",
        "   FAILUREs, like 2+2 == 5 .",
        "Failures may confound subsequent diagnoses.\n",
        "The diagnostic capabilities of this program go beyond an earlier",
        "program called `MACHAR', which can be found at the end of the",
        "book  `Software Manual for the Elementary Functions' (1980) by",
        "W. J. Cody and W. Waite. Although both programs try to discover",
        "the Radix, Precision and range (over/underflow thresholds)",
        "of the arithmetic, this program tries to cope with a wider variety",
        "of pathologies, and to say how well the arithmetic is implemented.",
        "\nThe program is based upon a conventional radix representation for",
        "floating-point numbers, but also allows logarithmic encoding",
        "as used by certain early WANG machines.\n",
        "BASIC version of this program (C) 1983 by Prof. W. M. Kahan;",
        "see source comments for more history.",
        0};

        msglist(hist);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\parcomp\parsync.c ===
#include <nt.h>
#include <ntddft.h>
#include <ntdddisk.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

int __cdecl
main( int argc, char **argv )
{
    PARTITION_INFORMATION PartitionInfo;
    FT_SYNC_INFORMATION SyncInfo;
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    ULONG BytesTransferred;

    if( argc < 2 ) {

        printf( "usage: %s DosDriveName: [-b:StartingSector] [-e:EndingSector]\n", argv[0] );
        exit(4);
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n", argv[1], GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to get volume size [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);
    }


    // Synchronize the parity information for the entire volume:
    //
    SyncInfo.ByteOffset.QuadPart = 0;
    SyncInfo.ByteCount =  PartitionInfo.PartitionLength;

    // Issue the IOCTL
    //
    if( !DeviceIoControl( VolumeHandle,
                          FT_SYNC_REDUNDANT_COPY,
                          &SyncInfo,
                          sizeof( SyncInfo ),
                          NULL,
                          0,
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Synchronization failed (Error %d).\n", GetLastError() );

    } else {

        printf( "Synchronization complete.\n" );
    }

    CloseHandle( VolumeHandle );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pageheap\pageheap.cxx ===
//
// Page heap command line manipulator
// Copyright (c) Microsoft Corporation, 1999
//
// -- History --
//
// 3.04  Whistler: protect page heap meta data option
// 3.03  Whistler: more granular fault injection option
// 3.02  Whistler: leaks detection
// 3.01  Whistler: fault injection
// 3.00  Whistler/W2000 SP1
//

//
// module: pageheap.cxx
// author: silviuc
// created: Tue Feb 02 10:43:04 1999
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>
#include <tchar.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <common.ver>

//
// Definitions copied from \nt\base\ntos\inc\heappage.h
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000


VOID
PrintFlags (
    DWORD Flags,
    BOOL ShutdownFlagsDefined = FALSE
    )
{
    if ((Flags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        printf("full ");
    }
    if ((Flags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
        printf("backwards ");
    }
    if ((Flags & PAGE_HEAP_UNALIGNED_ALLOCATIONS)) {
        printf("unaligned ");
    }
    if ((Flags & PAGE_HEAP_SMART_MEMORY_USAGE)) {
        printf("decommit ");
    }
    if ((Flags & PAGE_HEAP_USE_SIZE_RANGE)) {
        printf("size ");
    }
    if ((Flags & PAGE_HEAP_USE_DLL_RANGE)) {
        printf("address ");
    }
    if ((Flags & PAGE_HEAP_USE_RANDOM_DECISION)) {
        printf("random ");
    }
    if ((Flags & PAGE_HEAP_USE_DLL_NAMES)) {
        printf("dlls ");
    }
    if ((Flags & PAGE_HEAP_USE_FAULT_INJECTION)) {
        printf("fault ");
    }
    if ((Flags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
        printf("traces ");
    }
    if ((Flags & PAGE_HEAP_PROTECT_META_DATA)) {
        printf("protect ");
    }
    if ((Flags & PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS)) {
        printf("no_sync ");
    }
    if ((Flags & PAGE_HEAP_NO_LOCK_CHECKS)) {
        printf("no_lock_checks ");
    }

    if (ShutdownFlagsDefined) {
        printf("leaks ");
    }
}

BOOL
EnablePageHeap (
    LPCTSTR Name,
    LPTSTR HeapFlags,
    LPTSTR DebugString,
    char * * Args);

BOOL
DisablePageHeap (
    LPCTSTR Name);

BOOL
IsPageHeapEnabled (
    LPCTSTR Name);

BOOL
IsPageHeapFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value);

BOOL
ReadGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteGlobalFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
ReadHeapFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
WriteHeapFlagValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteHeapFlagValue (
    HKEY Key);

BOOL
WriteDebuggerValue (
    HKEY Key,
    LPTSTR Buffer,
    ULONG Length);

BOOL
DeleteDebuggerValue (
    HKEY Key);

HKEY
OpenImageKey (
    LPCTSTR Name,
    BOOL ShouldExist);

VOID
CloseImageKey (
    HKEY Key);

VOID
CreateImageName (
    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length);

VOID
PrintPageheapEnabledApplications (
    );

VOID
Help (
    );

VOID
__cdecl
Error (
    LPCTSTR Format,
    ...);

BOOL 
IsWow64Active (
    );

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

char * * 
SearchOption (
    char * Args[],
    char * Option
    )
{
    while (*Args) {
        if (_stricmp(*Args, Option) == 0) {
            return Args;
        }

        Args++;
    }

    return NULL;
}


void _cdecl
#if defined (_PART_OF_GFLAGS_)
PageHeapMain (int argc, char *argv[])
#else
main (int argc, char *argv[])
#endif
{
    TCHAR ImageName [MAX_PATH];
    char * * Option;

    if (IsWow64Active()) {
        _tprintf (TEXT ("Warning: pageheap.exe is running inside WOW64. \n"
                        "This scenario can be used to test x86 binaries (running inside WOW64) \n"
                        "but not native (IA64) binaries. \n\n"));
    }
    
    if (argc == 2 && strstr (argv[1], TEXT("?")) != NULL) {

        Help ();
    }
    else if ((Option = SearchOption(argv + 1, "/enable"))) {

        PCHAR DebugString = NULL;

        if (SearchOption (argv + 1, "/debug") != NULL) {
            DebugString = "ntsd -g -G -x";
        }

        if (SearchOption (argv + 1, "/kdebug") != NULL) {
            DebugString = "ntsd -g -G -d -x";
        }

        if (Option[1] && Option[1][0] != '/') {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            EnablePageHeap (ImageName, NULL, DebugString, argv);
        }
        else {
            Help();
        }
    }
    else if ((Option = SearchOption(argv + 1, "/disable"))) {
        
        if (Option[1]) {
            CreateImageName (Option[1], ImageName, MAX_PATH);
            DisablePageHeap (ImageName);
        }
        else {
            Help();
        }
    }
    else if (argc == 2) {

        CreateImageName (argv[1], ImageName, MAX_PATH);
        if (IsPageHeapEnabled (ImageName) == FALSE) {
            _tprintf (TEXT("Page heap is not enabled for %s\n"), argv[1]);
        }
        else {

            DWORD Value;

            if (IsPageHeapFlagsValueDefined (ImageName, &Value)) {
                
                _tprintf (TEXT("Page heap is enabled for %s with flags ("), argv[1]);
                PrintFlags (Value);
                _tprintf (TEXT(")\n"));
            }
            else {

                _tprintf (TEXT("Page heap is enabled for %s with flags ("), argv[1]);
                PrintFlags (0);
                _tprintf (TEXT(")\n"));
            }
        }
    }
    else {

        PrintPageheapEnabledApplications ();
    }
}


VOID
Help (

    )
{
    _tprintf (
        TEXT("pageheap - Page heap utility, v 3.04                                 \n")
        VER_LEGALCOPYRIGHT_STR TEXT("\n")
        TEXT("                                                                     \n")
        TEXT("pageheap [OPTION [OPTION ...]]                                       \n")
        TEXT("                                                                     \n")
        TEXT("    /enable PROGRAM         Enable page heap with default settings.  \n")
        TEXT("    /disable PROGRAM        Disable page heap.                       \n")
        TEXT("    /full                   Page heap for all allocations.           \n")
        TEXT("    /size START END         Page heap allocations for size range.    \n")
        TEXT("    /address START END      Page heap allocations for address range. \n")
        TEXT("    /dlls DLL ...           Page heap allocations for target dlls.   \n")
        TEXT("    /random PROBABILITY     Page heap allocations with PROBABILITY.  \n")
        TEXT("    /debug                  Launch under debugger `ntsd -g -G -x'.   \n")
        TEXT("    /kdebug                 Launch under debugger `ntsd -g -G -d -x'.\n")
        TEXT("    /backwards              Catch backwards overruns.                \n")
        TEXT("    /unaligned              No alignment for allocations.            \n")
        TEXT("    /decommit               Decommit guard pages (lower memory use). \n")
        TEXT("    /notraces               Do not collect stack traces.             \n")
        TEXT("    /fault RATE [TIMEOUT]   Probability (1..10000) for heap calls failures \n")
        TEXT("                            and time during process initialization (in seconds)\n")
        TEXT("                            when faults are not allowed.             \n")
        TEXT("    /leaks                  Check for heap leaks when process shuts down. \n")
        TEXT("    /protect                Protect heap internal structures. Can be  \n")
        TEXT("                            used to detect random corruptions but    \n")
        TEXT("                            execution is slower.                     \n")
        TEXT("    /no_sync                Check for unsynchronized access. Do not  \n")
        TEXT("                            use this flag for an MPheap process.     \n")
        TEXT("    /no_lock_checks         Disable critical section verifier.       \n")
        TEXT("                                                                     \n")
        TEXT("                                                                     \n")
        TEXT("PROGRAM      Name of the binary with extension (.exe or something else).\n")
        TEXT("DLL          Name of the binary with extension (.dll or something else).\n")
        TEXT("PROBABILITY  Decimal integer in range [0..100] representing probability.\n")
        TEXT("             to make page heap allocation vs. a normal heap allocation. \n")
        TEXT("START..END   For /size option these are decimal integers.            \n")
        TEXT("             For /address option these are hexadecimal integers.     \n")
        TEXT("                                                                     \n")
        TEXT("If no option specified the program will print all page heap enabled  \n")
        TEXT("applications and their specific options.                             \n")
        TEXT("                                                                     \n")
        TEXT("The `/leaks' option is effective only when normal page heap is enabled \n")
        TEXT("(i.e. not full page heap) therefore all flags that will force full   \n")
        TEXT("page heap will be disabled if /leaks is specified.                   \n")
        TEXT("                                                                     \n")
        TEXT("Note. Enabling page heap does not affect currently running           \n")
        TEXT("processes. If you need to use page heap for processes that are       \n")
        TEXT("already running and cannot be restarted (csrss.exe, winlogon.exe),   \n")
        TEXT("a reboot is needed after the page heap has been enabled for          \n")
        TEXT("that process.                                                        \n")
        TEXT("                                                                     \n")
        TEXT("                                                                     \n"));

    exit(1);
}

VOID
__cdecl
Error (

    LPCTSTR Format,
    ...)
{
    va_list Params;

    va_start (Params, Format);
    _tprintf (TEXT("Error: "));
    _vtprintf (Format, Params);
    _tprintf ( TEXT("\n "));
    exit (1);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#define PAGE_HEAP_BIT 0x02000000

BOOL
IsPageHeapEnabled (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

        return FALSE;
    }

    CloseImageKey (Key);

    return (Flags & PAGE_HEAP_BIT) ? TRUE : FALSE;
}


BOOL
IsPageHeapFlagsValueDefined (
    LPCTSTR Name,
    PDWORD Value)
{
    HKEY Key;
    TCHAR Buffer [128];

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        return FALSE;
    }

    if (ReadHeapFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        return FALSE;
    }

    if (_stscanf (Buffer, TEXT("%x"), Value) == 0) {
        
        return FALSE;
    }

    CloseImageKey (Key);

    return TRUE;
}


BOOL
EnablePageHeap (
    LPCTSTR Name,
    LPTSTR HeapFlagsString,
    LPTSTR DebugString,
    char * * Args
    )
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;
    DWORD HeapFlags;
    char * * Option;
    LONG Result;
    BOOL LeakDetectionEnabled = FALSE;

    if ((Key = OpenImageKey (Name, FALSE)) == NULL) {

        Error (TEXT("Cannot open image registry key for %s"), Name);
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        _stscanf (Buffer, TEXT("%x"), &Flags);
    }

    Flags |= PAGE_HEAP_BIT;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

        return FALSE;
    }

    //
    // Figure out if we have some page heap flags specified.
    //

    HeapFlags = 0;

    if (HeapFlagsString != NULL) {

        _stscanf (HeapFlagsString, "%x", &HeapFlags);
    }

    //
    // Write `Debugger' value if needed.
    //

    if (DebugString != NULL) {

        if (WriteDebuggerValue (Key, DebugString, _tcslen(DebugString)) == FALSE) {

            return FALSE;
        }
    }

    //
    // Check for /leaks option. This requires a normal page heap to be
    // fully effective. Therefore any flag that will enable full page
    // heap will be disabled.
    //

    if ((Option = SearchOption (Args, "/leaks")) != NULL) {

        DWORD ShutdownFlags = 0x03;

        Result = RegSetValueEx (
            Key, TEXT ("ShutdownFlags"), 0, REG_DWORD,
            (LPBYTE)(&ShutdownFlags), sizeof ShutdownFlags);

        if (Result) {
            Error (TEXT("Failed to write ShutdownFlags value: error %u"), Result);
        }

        LeakDetectionEnabled = TRUE;
    }

    //
    // Check for full, backward, decommit, unaligned, protect options.
    //

    HeapFlags |= PAGE_HEAP_COLLECT_STACK_TRACES;

    if ((Option = SearchOption (Args, "/notraces")) != NULL) {
        HeapFlags &= ~PAGE_HEAP_COLLECT_STACK_TRACES;
    }

    if ((Option = SearchOption (Args, "/full")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
        }
        else {
            printf("/full option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/backwards")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_CATCH_BACKWARD_OVERRUNS;
        }
        else {
            printf("/backwards option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/decommit")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_SMART_MEMORY_USAGE;
        }
        else {
            printf("/decommit option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/unaligned")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_UNALIGNED_ALLOCATIONS;
        }
        else {
            printf("/unaligned option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/protect")) != NULL) {
        if (! LeakDetectionEnabled) {
            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_PROTECT_META_DATA;
        }
        else {
            printf("/protect option disabled because /leaks is present. \n");
        }
    }

    if ((Option = SearchOption (Args, "/no_sync")) != NULL) {
        HeapFlags |= PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS;
    }
    
    if ((Option = SearchOption (Args, "/no_lock_checks")) != NULL) {
        HeapFlags |= PAGE_HEAP_NO_LOCK_CHECKS;
    }
    
    //
    // Check /size option
    //

    Option = SearchOption (Args, "/size");

    if (Option != NULL) {

        if (!LeakDetectionEnabled && Option[1] && Option[2]) {

            DWORD RangeStart;
            DWORD RangeEnd;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_SIZE_RANGE;

            sscanf (Option[1], "%u", &RangeStart);
            sscanf (Option[2], "%u", &RangeEnd);

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapSizeRangeStart"), 0, REG_DWORD,
                (LPBYTE)(&RangeStart), sizeof RangeStart);

            if (Result) {
                Error (TEXT("Failed to write SizeRangeStart value: error %u"), Result);
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapSizeRangeEnd"), 0, REG_DWORD,
                (LPBYTE)(&RangeEnd), sizeof RangeEnd);

            if (Result) {
                Error (TEXT("Failed to write SizeRangeEnd value: error %u"), Result);
            }
        }

        if (LeakDetectionEnabled) {
            printf("/size option disabled because /leaks is present. \n");
        }

    }

    //
    // Check /address option
    //

    Option = SearchOption (Args, "/address");

    if (Option != NULL) {

        if (!LeakDetectionEnabled && Option[1] && Option[2]) {

            DWORD RangeStart;
            DWORD RangeEnd;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_DLL_RANGE;

            sscanf (Option[1], "%x", &RangeStart);
            sscanf (Option[2], "%x", &RangeEnd);

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapDllRangeStart"), 0, REG_DWORD,
                (LPBYTE)(&RangeStart), sizeof RangeStart);

            if (Result) {
                Error (TEXT("Failed to write DllRangeStart value: error %u"), Result);
            }

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapDllRangeEnd"), 0, REG_DWORD,
                (LPBYTE)(&RangeEnd), sizeof RangeEnd);

            if (Result) {
                Error (TEXT("Failed to write DllRangeStart value: error %u"), Result);
            }
        }

        if (LeakDetectionEnabled) {
            printf("/address option disabled because /leaks is present. \n");
        }
    }

    //
    // Check /random option
    //

    Option = SearchOption (Args, "/random");

    if (!LeakDetectionEnabled && Option != NULL) {

        if (Option[1]) {

            DWORD Probability;

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_RANDOM_DECISION;

            sscanf (Option[1], "%u", &Probability);

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapRandomProbability"), 0, REG_DWORD,
                (LPBYTE)(&Probability), sizeof Probability);

            if (Result) {
                Error (TEXT("Failed to write RandomProbability value: error %u"), Result);
            }
        }
    }

    if (Option && LeakDetectionEnabled) {
        printf("/random option disabled because /leaks is present. \n");
    }

    //
    // Check /fault option
    //

    Option = SearchOption (Args, "/fault");

    if (Option != NULL) {

        if (Option[1]) { // FAULT-RATE

            DWORD Probability;

            HeapFlags |= PAGE_HEAP_USE_FAULT_INJECTION;

            sscanf (Option[1], "%u", &Probability);

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapFaultProbability"), 0, REG_DWORD,
                (LPBYTE)(&Probability), sizeof Probability);

            if (Result) {
                Error (TEXT("Failed to write FaultProbability value: error %u"), Result);
            }

            if (Option[2]) { // TIME-OUT

                DWORD TimeOut;

                sscanf (Option[2], "%u", &TimeOut);

                Result = RegSetValueEx (
                    Key, TEXT ("PageHeapFaultTimeOut"), 0, REG_DWORD,
                    (LPBYTE)(&TimeOut), sizeof TimeOut);

                if (Result) {
                    Error (TEXT("Failed to write FaultTimeOut value: error %u"), Result);
                }
            }
        }
    }

    //
    // Check /dlls option
    //

    Option = SearchOption (Args, "/dlls");

    if (!LeakDetectionEnabled && Option != NULL) {

        TCHAR Dlls[512];
        ULONG Index;

        if (Option[1]) {

            HeapFlags |= PAGE_HEAP_ENABLE_PAGE_HEAP;
            HeapFlags |= PAGE_HEAP_USE_DLL_NAMES;

            for (Index = 1, Dlls[0] = '\0';
                Option[Index] && Option[Index][0] != '/';
                Index++) {

                _tcscat (Dlls, Option[Index]);
                _tcscat (Dlls, " ");

                //
                // We do not allow more than 200 characters because this
                // will cause an overflow in \nt\base\ntdll\ldrinit.c in the
                // function that reads registry options.
                //

                if (_tcslen (Dlls) > 200) {
                    break;
                }
            }

            //
            // SilviuC: the call to _tcslen below is not correct if we
            // ever will want to make this program Unicode.
            //

            Result = RegSetValueEx (
                Key, TEXT ("PageHeapTargetDlls"), 0, REG_SZ,
                (LPBYTE)(Dlls), _tcslen(Dlls) + 1);

            if (Result) {
                Error (TEXT("Failed to write RandomProbability value: error %u"), Result);
            }
        }
    }

    if (Option && LeakDetectionEnabled) {
        printf("/dlls option disabled because /leaks is present. \n");
    }

    //
    // Finally write the page heap flags value.
    //

    {
        TCHAR ValueBuffer [32];

        sprintf (ValueBuffer, "0x%x", HeapFlags);

        if (WriteHeapFlagValue (Key, ValueBuffer, _tcslen(ValueBuffer)) == FALSE) {

            Error (TEXT("Failed to write PageHeapFlags value."));
            return FALSE;
        }
    }

    CloseImageKey (Key);
    return TRUE;
}

BOOL
DisablePageHeap (

    LPCTSTR Name)
{
    HKEY Key;
    TCHAR Buffer [128];
    DWORD Flags;

    if ((Key = OpenImageKey (Name, TRUE)) == NULL) {

        //
        // There is no key therefore nothing to disable.
        //

        return TRUE;
    }

    if (ReadGlobalFlagValue (Key, Buffer, sizeof Buffer) == FALSE) {

        Flags = 0;
    }
    else {

        if (_stscanf (Buffer, TEXT("%x"), &Flags) == 0) {

            Flags = 0;;
        }
    }

    Flags &= ~PAGE_HEAP_BIT;
    _stprintf (Buffer, TEXT("0x%08X"), Flags);

    //
    // If by wiping the page heap bit from `GlobalFlags' we get a zero
    // value we will wipe out the value altogether. This is important
    // when we run the app under debugger. In this case it makes a 
    // difference if the value is not there or is all zeroes.
    //

    if (Flags != 0) {
        
        if (WriteGlobalFlagValue (Key, Buffer, _tcslen(Buffer)) == FALSE) {

            return FALSE;
        }
    }
    else {

        RegDeleteValue (Key, TEXT ("GlobalFlag"));
    }

    RegDeleteValue (Key, TEXT ("PageHeapFlags"));
    RegDeleteValue (Key, TEXT ("Debugger"));
    RegDeleteValue (Key, TEXT ("ShutdownFlags"));
    RegDeleteValue (Key, TEXT ("PageHeapSizeRangeStart"));
    RegDeleteValue (Key, TEXT ("PageHeapSizeRangeEnd"));
    RegDeleteValue (Key, TEXT ("PageHeapDllRangeStart"));
    RegDeleteValue (Key, TEXT ("PageHeapDllRangeEnd"));
    RegDeleteValue (Key, TEXT ("PageHeapTargetDlls"));
    RegDeleteValue (Key, TEXT ("PageHeapRandomProbability"));
    RegDeleteValue (Key, TEXT ("PageHeapFaultProbability"));
    RegDeleteValue (Key, TEXT ("PageHeapFaultTimeOut"));

    CloseImageKey (Key);
    return TRUE;
}


BOOL
ReadGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
ReadHeapFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;
    DWORD Type;
    DWORD ReadLength = Length;

    Result = RegQueryValueEx (

        Key,
        TEXT ("PageHeapFlags"),
        0,
        &Type,
        (LPBYTE)Buffer,
        &ReadLength);

    if (Result != ERROR_SUCCESS || Type != REG_SZ) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteGlobalFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("GlobalFlag"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}

BOOL
WriteHeapFlagValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("PageHeapFlags"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
WriteDebuggerValue (

    HKEY Key,
    LPTSTR Buffer,
    ULONG Length)
{
    LONG Result;

    Result = RegSetValueEx (

        Key,
        TEXT ("Debugger"),
        0,
        REG_SZ,
        (LPBYTE)Buffer,
        Length);

    if (Result != ERROR_SUCCESS) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


BOOL
IsShutdownFlagsValueDefined (
    LPCTSTR KeyName
    )
{
    HKEY Key;
    LONG Result;
    DWORD Value;
    DWORD Type;
    DWORD ReadLength = sizeof (DWORD);

    if ((Key = OpenImageKey (KeyName, TRUE)) == NULL) {
        return FALSE;
    }
    
    Result = RegQueryValueEx (
        Key,
        TEXT ("ShutdownFlags"),
        0,
        &Type,
        (LPBYTE)(&Value),
        &ReadLength);

    CloseImageKey (Key);

    if (Result == ERROR_SUCCESS && (Value & 0x03) == 0x03) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HKEY
OpenImageKey (

    LPCTSTR Name,
    BOOL ShouldExist)
{
    HKEY Key;
    LONG Result;
    TCHAR Buffer [MAX_PATH];

    _stprintf (
        Buffer,
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s"),
        Name);

    if (ShouldExist) {

        Result = RegOpenKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            KEY_ALL_ACCESS,
            &Key);
    }
    else {

        Result = RegCreateKeyEx (

            HKEY_LOCAL_MACHINE,
            Buffer,
            0,
            0,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &Key,
            NULL);
    }

    if (Result != ERROR_SUCCESS) {

        return NULL;
    }
    else {

        return Key;
    }

}


VOID
CloseImageKey (

    HKEY Key)
{
    RegCloseKey (Key);
}


VOID
CreateImageName (

    LPCTSTR Source,
    LPTSTR Name,
    ULONG Length)
{
    _tcsncpy (Name, Source, Length - 1);
    Name [Length - 1] = L'\0';

    _tcslwr (Name);

    if (_tcsstr (Name, TEXT(".exe")) == 0) {

        _tcscat (Name, TEXT(".exe"));
    }
}


VOID
PrintPageheapEnabledApplications (

    )
{
    LPCTSTR ImageFileExecutionOptionsKeyName =
        TEXT ("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options");

    HKEY OptionsKey;
    LONG Result;
    TCHAR KeyName [MAX_PATH];
    ULONG KeySize;
    BOOL FoundOne = FALSE;
    ULONG Index;
    FILETIME FileTime;

    Result = RegOpenKeyEx (

        HKEY_LOCAL_MACHINE,
        ImageFileExecutionOptionsKeyName,
        0,
        KEY_ALL_ACCESS,
        &OptionsKey);

    if (Result != ERROR_SUCCESS) {

        Error (TEXT("Cannot open registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
    }

    for (Index = 0; TRUE; Index++) {

        KeySize = MAX_PATH;

        Result = RegEnumKeyEx (

            OptionsKey,
            Index,
            KeyName,
            &KeySize,
            NULL,
            NULL,
            NULL,
            &FileTime);

        if (Result == ERROR_NO_MORE_ITEMS) {

            break;
        }

        if (Result != ERROR_SUCCESS) {

            Error (TEXT("Cannot enumerate registry key %s: error %u"),
               ImageFileExecutionOptionsKeyName,
               Result);
        }

        if (IsPageHeapEnabled (KeyName)) {

            DWORD Value;

            FoundOne = TRUE;
            
            if (IsPageHeapFlagsValueDefined (KeyName, &Value)) {
                _tprintf (TEXT("%s: page heap enabled with flags ("), KeyName);
                PrintFlags (Value, IsShutdownFlagsValueDefined(KeyName));
                _tprintf (TEXT(")\n"));
            }
            else {
                _tprintf (TEXT("%s: page heap enabled with flags ("), KeyName);
                PrintFlags (0, IsShutdownFlagsValueDefined(KeyName));
                _tprintf (TEXT(")\n"));
            }
        }
    }

    if (FoundOne == FALSE) {

        _tprintf (TEXT("No application has page heap enabled.\n"));
    }
}


BOOL 
IsWow64Active (
    )                 
{

    ULONG_PTR       ul;
    NTSTATUS        st;

    //
    // If this call succeeds then we are on Windows 2000 or later.
    //

    st = NtQueryInformationProcess(NtCurrentProcess(), 
                                   ProcessWow64Information,
                                   &ul, 
                                   sizeof(ul), 
                                   NULL);

    if (NT_SUCCESS(st) && (0 != ul)) {
        // 32-bit code running on Win64
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\parcomp\parcomp.c ===
#include <nt.h>
#include <ntddft.h>
#include <ntdddisk.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>


#define SECTOR_SIZE 512
#define COMPARE_BUFFER_SIZE 0x4000

BYTE PrimaryBuffer[COMPARE_BUFFER_SIZE];
BYTE SecondaryBuffer[COMPARE_BUFFER_SIZE];
BYTE OutputBuffer[1024];

void
DumpMiscompare(
    IN PBYTE PrimarySector,
    IN PBYTE SecondarySector
    )
{
    BYTE ch;
    int i, j, offset;

    i = 0;

    while( i < SECTOR_SIZE && PrimarySector[i] == SecondarySector[i] ) {

        i++;
    }

    offset = i & ~7;

    while( offset < SECTOR_SIZE ) {

        printf( "%03X: ", offset );

        // display primary as hex.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( "   " );

            } else {

                printf( " %02X", PrimarySector[j] );
            }
        }

        printf( "  " );

        // display primary as character.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( " " );

            } else {

                ch = PrimarySector[j];
                if( !isprint(ch) ) {

                    ch = '.';
                }

                printf( "%c", ch );
            }
        }

        printf( " -- " );

        // Display secondary as hex.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( "   " );

            } else {

                printf( " %02X", SecondarySector[j] );
            }
        }

        printf( "  " );

        // display primary as character.

        for( j = offset; j < offset + 8; j++ ) {

            if( j < i ) {

                printf( " " );

            } else {

                ch = SecondarySector[j];
                if( !isprint(ch) ) {

                    ch = '.';
                }

                printf( "%c", ch );
            }
        }

        printf( "\n" );
        offset += 8;
    }

    // Add a blank line.
    //
    printf( "\n" );
}

BOOL
ReadSectors(
    IN HANDLE   VolumeHandle,
    IN ULONG    SectorNumber,
    IN ULONG    NumberOfSectors,
    IN PBYTE    Buffer,
    IN BOOL     Secondary
    )
{
    FT_SPECIAL_READ SpecialReadBuffer;
    ULONG BytesRead;

    SpecialReadBuffer.ByteOffset = RtlEnlargedIntegerMultiply( SectorNumber, SECTOR_SIZE );
    SpecialReadBuffer.Length = NumberOfSectors * SECTOR_SIZE;

    // Issue the IOCTL
    //
    return( DeviceIoControl( VolumeHandle,
                             Secondary ? FT_SECONDARY_READ : FT_PRIMARY_READ,
                             &SpecialReadBuffer,
                             sizeof( SpecialReadBuffer ),
                             Buffer,
                             NumberOfSectors * SECTOR_SIZE,
                             &BytesRead,
                             NULL ) &&
            BytesRead == NumberOfSectors * SECTOR_SIZE );
}

VOID
ShowUsage()
{
        printf( "usage: parcomp DosDriveName: [-d] [-b:StartingSector] [-e:EndingSector]\n" );
        exit(4);
}

int __cdecl
main( int argc, char **argv )
{
    PARTITION_INFORMATION PartitionInfo;
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    LARGE_INTEGER BigSectorsOnVolume;
    ULONG SectorsOnVolume, SectorOffset, SectorsToRead, i, Errors;
    LONG k;
    BOOL PrimaryRead, SecondaryRead, DumpErrors = FALSE;
    ULONG BytesTransferred;
    ULONG StartSector = 0, EndSector = 0;


    if( argc < 2 ) {

        ShowUsage();
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    for( k = 2;
         k < argc;
         k++ ) {

        if( argv[k][0] == '-' ||
            argv[k][0] == '/' ) {

            switch (argv[k][1]) {

            case 'd':

                //
                // Display miscompares.
                //
                DumpErrors = TRUE;
                break;

            case 'b':

                //
                // Specify beginning sector number.
                //
                if (sscanf( argv[k]+2, ":%x", &StartSector ) != 1)
                    ShowUsage();
                break;

            case 'e':

                //
                // Specify beginning sector number.
                //
                if (sscanf( argv[k]+2, ":%x", &EndSector ) != 1)
                    ShowUsage();
                break;

            default:

                ShowUsage();
                break;
            }
        } else {

            ShowUsage();
        }
    }

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n", argv[1], GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_DISK_GET_PARTITION_INFO,
                          NULL,
                          0,
                          &PartitionInfo,
                          sizeof( PartitionInfo ),
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to get volume size [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);
    }

    if( !(PartitionInfo.PartitionType & VALID_NTFT) ) {

        printf( "%s is not a Fault-Tolerant volume.\n", argv[1] );
        exit(4);
    }

    BigSectorsOnVolume = RtlExtendedLargeIntegerDivide( PartitionInfo.PartitionLength, SECTOR_SIZE, NULL );
    SectorsOnVolume = BigSectorsOnVolume.LowPart;

    if( EndSector == 0 ) {

        EndSector = SectorsOnVolume;
    }

    sprintf( OutputBuffer, "Sectors on volume = %x\n", SectorsOnVolume );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    sprintf( OutputBuffer, "Starting Sector = %x\n", StartSector );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    sprintf( OutputBuffer, "Ending Sector = %x\n", EndSector );
    printf( OutputBuffer );
    OutputDebugString( OutputBuffer );

    SectorsToRead = 0;
    Errors = 0;

    printf( "Sectors read %8x\b\b\b\b\b\b\b\b", StartSector );

    for( SectorOffset = StartSector;
         SectorOffset < EndSector;
         SectorOffset += SectorsToRead ) {

        SectorsToRead = __min( COMPARE_BUFFER_SIZE / SECTOR_SIZE,
                               EndSector - SectorOffset );

        // zero out the buffers.
        //
        memset( PrimaryBuffer, 0, COMPARE_BUFFER_SIZE );
        memset( SecondaryBuffer, 0, COMPARE_BUFFER_SIZE );

        // Read the primary:
        //
        PrimaryRead = ReadSectors( VolumeHandle,
                                   SectorOffset,
                                   SectorsToRead,
                                   PrimaryBuffer,
                                   FALSE );

        // Read the secondary:
        //
        SecondaryRead = ReadSectors( VolumeHandle,
                                     SectorOffset,
                                     SectorsToRead,
                                     SecondaryBuffer,
                                     TRUE );

        if( PrimaryRead && SecondaryRead ) {

            for( i = 0; i < SectorsToRead; i++ ) {

                if( memcmp( PrimaryBuffer + SECTOR_SIZE * i,
                    SecondaryBuffer + SECTOR_SIZE * i,
                    SECTOR_SIZE ) ) {

                    sprintf( OutputBuffer, "\rPrimary and Secondary miscompare at sector %x\n", SectorOffset + i );
                    printf( OutputBuffer );
                    OutputDebugString( OutputBuffer );

                    if( DumpErrors ) {

                      DumpMiscompare( PrimaryBuffer + SECTOR_SIZE * i,
                                      SecondaryBuffer + SECTOR_SIZE * i );
                    }

                    printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );
                    Errors++;
                }
            }

        } else if( PrimaryRead ) {

            sprintf( OutputBuffer, "\rSecondary read failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );

        } else if( SecondaryRead ) {

            sprintf( OutputBuffer, "\rPrimary read failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );

        } else {

            sprintf( OutputBuffer, "\rPrimary and Secondary reads failed at sector %x, length %x (Error %d)\n", SectorOffset, SectorsToRead, GetLastError() );
            printf( OutputBuffer );
            OutputDebugString( OutputBuffer );
            printf( "Sectors read %8x\b\b\b\b\b\b\b\b", SectorOffset );
        }
        printf( "%8x\b\b\b\b\b\b\b\b", SectorOffset );
    }

    printf( "%8x\b\b\b\b\b\b\b\b", SectorOffset );
    printf( "\n%x Errors\n", Errors );
    CloseHandle( VolumeHandle );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\passprop\passprop.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1992
//
// File:        passprop.cxx
//
// Contents:    utility program to set domain password properties
//
//
// History:     3-May-96       Created         MikeSw
//
//------------------------------------------------------------------------


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmaccess.h>
#include "passp.h"
}

void _cdecl
main(int argc, char *argv[])
{
    NTSTATUS Status;
    PDOMAIN_PASSWORD_INFORMATION PasswordInfo =  NULL;
    SAM_HANDLE ServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    PULONG UserId = NULL;
    PSID_NAME_USE NameUse = NULL;
    ULONG TurnOffFlags = 0;
    ULONG TurnOnFlags = 0;
    int Index;
    CHAR MessageBuff[1000];
    CHAR ComplexArg[20];
    CHAR SimpleArg[20];
    CHAR AdminArg[20];
    CHAR NoAdminArg[20];

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_COMPLEX,
        0,
        ComplexArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_SIMPLE,
        0,
        SimpleArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_ADMIN_LOCKOUT,
        0,
        AdminArg,
        20,
        NULL
        );

    FormatMessageA(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MSG_PASSPROP_SWITCH_NO_ADMIN_LOCKOUT,
        0,
        NoAdminArg,
        20,
        NULL
        );


    for (Index = 1; Index < argc  ; Index++)
    {
        if (_stricmp(argv[Index],ComplexArg) == 0)
        {
            TurnOnFlags |= DOMAIN_PASSWORD_COMPLEX;
        } else if (_stricmp(argv[Index],SimpleArg) == 0)
        {
            TurnOffFlags |= DOMAIN_PASSWORD_COMPLEX;
        } else if (_stricmp(argv[Index],AdminArg) == 0)
        {
            TurnOnFlags |= DOMAIN_LOCKOUT_ADMINS;
        } else if (_stricmp(argv[Index],NoAdminArg) == 0)
        {
            TurnOffFlags |= DOMAIN_LOCKOUT_ADMINS;
        } else
        {
            goto Usage;
        }
    }

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    Status = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(Status)) {
        printf("Failed to open local policy: 0x%x\n",Status);
        return;
    }

    Status = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                (PVOID *) &AccountDomainInfo
                );

    LsaClose(PolicyHandle);

    if (!NT_SUCCESS(Status)) {
        printf("Failed to query info policy: 0x%x\n",Status);
        return;
    }

    Status = SamConnect(
                NULL,
                &ServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(Status)) {
        printf("Failed to sam connect: 0x%x\n",Status);
        return;
    }

    Status = SamOpenDomain(
                ServerHandle,
                MAXIMUM_ALLOWED,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status)) {
        printf("Failed to open domain: 0x%x\n",Status);
        SamCloseHandle(ServerHandle);
        return;
    }

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainPasswordInformation,
                (PVOID *) &PasswordInfo
                );
    if (!NT_SUCCESS(Status))
    {
        printf("Failed to query domain pasword info: 0x%x\n",Status);
        SamCloseHandle(ServerHandle);
        SamCloseHandle(DomainHandle);
        return;

    }
    PasswordInfo->PasswordProperties = (PasswordInfo->PasswordProperties | TurnOnFlags) & (~TurnOffFlags);

    if ((TurnOnFlags != 0) || (TurnOffFlags != 0))
    {
        Status = SamSetInformationDomain(
                    DomainHandle,
                    DomainPasswordInformation,
                    PasswordInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            printf("Failed to query domain pasword info: 0x%x\n",Status);
            return;
        }
    }

    if ((PasswordInfo->PasswordProperties & DOMAIN_PASSWORD_COMPLEX) != 0)
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_COMPLEX,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    else
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_SIMPLE,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    printf("%s",MessageBuff);
    if ((PasswordInfo->PasswordProperties & DOMAIN_LOCKOUT_ADMINS) != 0)
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_ADMIN_LOCKOUT,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    else
    {
        FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_NO_ADMIN_LOCKOUT,
            0,
            MessageBuff,
            1000,
            NULL
            );
    }
    printf("%s",MessageBuff);

    SamCloseHandle(ServerHandle);
    SamCloseHandle(DomainHandle);
    SamFreeMemory(PasswordInfo);
    return;

Usage:
    FormatMessageA(
            FORMAT_MESSAGE_FROM_HMODULE,
            NULL,
            MSG_PASSPROP_USAGE,
            0,
            MessageBuff,
            1000,
            NULL
            );

    printf("%s",MessageBuff);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\pch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include <string.h>
#include <ntconfig.h>
#include <ntddpcm.h>
#include <tuple.h>
#include <pcmcmd.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\tuples.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tuples.c

Abstract:

    This program converses with the PCMCIA support driver to display
    tuple and other information.

Author:

    Bob Rinne

Environment:

    User process.

Notes:

Revision History:
   
    Ravisankar Pudipeddi (ravisp) June 27 1997
        - command line options & support for multiple controllers
    Neil Sandlin (neilsa) Sept 20, 1998
        - more commands        

--*/

#include <pch.h>

//
// Tuple output strings
//


StringTable CommandCodes[] = {

   "CISTPL_NULL",           CISTPL_NULL,
   "CISTPL_DEVICE",         CISTPL_DEVICE,
   "CISTPL_LONGLINK_MFC",   CISTPL_LONGLINK_MFC,   
   "CISTPL_CHECKSUM",       CISTPL_CHECKSUM,
   "CISTPL_LONGLINK_A",     CISTPL_LONGLINK_A,
   "CISTPL_LONGLINK_C",     CISTPL_LONGLINK_C,
   "CISTPL_LINKTARGET",     CISTPL_LINKTARGET,
   "CISTPL_NO_LINK",        CISTPL_NO_LINK,
   "CISTPL_VERS_1",         CISTPL_VERS_1,
   "CISTPL_ALTSTR",         CISTPL_ALTSTR,
   "CISTPL_DEVICE_A",       CISTPL_DEVICE_A,
   "CISTPL_JEDEC_C",        CISTPL_JEDEC_C,
   "CISTPL_JEDEC_A",        CISTPL_JEDEC_A,
   "CISTPL_CONFIG",         CISTPL_CONFIG,
   "CISTPL_CFTABLE_ENTRY",  CISTPL_CFTABLE_ENTRY,
   "CISTPL_DEVICE_OC",      CISTPL_DEVICE_OC,
   "CISTPL_DEVICE_OA",      CISTPL_DEVICE_OA,
   "CISTPL_GEODEVICE",      CISTPL_GEODEVICE,
   "CISTPL_GEODEVICE_A",    CISTPL_GEODEVICE_A,
   "CISTPL_MANFID",         CISTPL_MANFID,
   "CISTPL_FUNCID",         CISTPL_FUNCID,
   "CISTPL_FUNCE",          CISTPL_FUNCE,
   "CISTPL_VERS_2",         CISTPL_VERS_2,
   "CISTPL_FORMAT",         CISTPL_FORMAT,
   "CISTPL_GEOMETRY",       CISTPL_GEOMETRY,
   "CISTPL_BYTEORDER",      CISTPL_BYTEORDER,
   "CISTPL_DATE",           CISTPL_DATE,
   "CISTPL_BATTERY",        CISTPL_BATTERY,
   "CISTPL_ORG",            CISTPL_ORG,

   //
   // CISTPL_END must be the last one in the table.
   //

   "CISTPL_END",            CISTPL_END

};


//
// Procedures
//


NTSTATUS
ReadTuple(
         IN HANDLE Handle,
         IN LONG   SlotNumber,
         IN PUCHAR Buffer,
         IN LONG   BufferSize
         )

/*++

Routine Description:

    Perform the NT function to get the tuple data from the
    pcmcia support driver.

Arguments:

    Handle - an open handle to the driver.
    SlotNumber - The socket offset
    Buffer - return buffer for the data.
    BufferSize - the size of the return buffer area.

Return Value:

    The results of the NT call.

--*/

{
   NTSTATUS        status;
   IO_STATUS_BLOCK statusBlock;
   TUPLE_REQUEST   commandBlock;

   commandBlock.Socket = (USHORT) SlotNumber;

   status = NtDeviceIoControlFile(Handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &statusBlock,
                                  IOCTL_GET_TUPLE_DATA,
                                  &commandBlock,
                                  sizeof(commandBlock),
                                  Buffer,
                                  BufferSize);
   return status;
}


PUCHAR
FindTupleCodeName(
                 UCHAR TupleCode
                 )

/*++

Routine Description:

    Return an ascii string that describes the tuple code provided.

Arguments:

    TupleCode - what code to look up.

Return Value:

    A string pointer - always.

--*/

{
   ULONG index;

   for (index = 0; CommandCodes[index].CommandCode != CISTPL_END; index++) {
      if (CommandCodes[index].CommandCode == TupleCode) {
         return CommandCodes[index].CommandName;
      }
   }

   return "Command Unknown";
}


PUCHAR DeviceTypeString[] = {
   "DTYPE_NULL",
   "DTYPE_ROM",
   "DTYPE_OTPROM",
   "DTYPE_EPROM",
   "DTYPE_EEPROM",
   "DTYPE_FLASH",
   "DTYPE_SRAM",
   "DTYPE_DRAM",
   "Reserved8",
   "Reserved9",
   "Reserveda",
   "Reservedb",
   "Reservedc",
   "DTYPE_FUNCSPEC",
   "DTYPE_EXTEND"
   "Reservedf",
};

PUCHAR DeviceSpeedString[] = {
   "DSPEED_NULL",
   "DSPEED_250NS",
   "DSPEED_200NS",
   "DSPEED_150NS",
   "DSPEED_100NS",
   "DSPEED_RES1",
   "DSPEED_RES2",
   "DSPEED_EXT"
};

VOID
DisplayDeviceTuple(
                  PUCHAR TupleBuffer,
                  UCHAR  TupleSize
                  )

/*++

Routine Description:

    Display the data at the given pointer as a CISTPL_DEVICE structure.

Arguments:

    TupleBuffer - the CISTPL_DEVICE to display.
    TupleSize   - the link value for the tuple.

Return Value:

    None

--*/

{
   UCHAR  mantissa = MANTISSA_RES1;
   UCHAR  exponent;
   UCHAR  deviceTypeCode;
   UCHAR  wps;
   UCHAR  deviceSpeed;
   UCHAR  temp;

   temp = *TupleBuffer;
   deviceTypeCode = DeviceTypeCode(temp);
   wps = DeviceWPS(temp);
   deviceSpeed = DeviceSpeedField(temp);

   temp = *(TupleBuffer + 1);

   if (deviceSpeed == DSPEED_EXT) {
      exponent = SpeedExponent(temp);
      mantissa = SpeedMantissa(temp);
   }

   printf("DeviceType: %s DeviceSpeed: ", DeviceTypeString[deviceTypeCode]);
   if (mantissa != MANTISSA_RES1) {
      printf("Mantissa %.2x, Exponent %.2x\n", mantissa, exponent);
   } else {
      printf("%s\n", DeviceSpeedString[deviceSpeed]);
   }
}


VOID
DisplayVers1(
            PUCHAR TupleBuffer,
            UCHAR  TupleSize,
            USHORT Crc
            )

/*++

Routine Description:

    Display the data as a Version tuple

Arguments:

    TupleBuffer - the CISTPL_DEVICE to display.
    TupleSize   - the link value for the tuple.

Return Value:

    None

--*/

{
   PUCHAR string;
   PUCHAR cp;

   //
   // Step around the MAJOR and MINOR codes of 4/1 at
   // the beginning of the tuple to get to the strings.
   //

   string = TupleBuffer;
   string++;
   string++;

   printf("Manufacturer:\t%s\n", string);
   while (*string++) {
   }

   printf("Product Name:\t%s\n", string);
   printf("CRC:         \t%.4x\n", Crc);
   while (*string++) {
   }

   printf("Product Info:\t");
   if (isprint(*string)) {
      printf("%s", string);
   } else {
      while (*string) {
         printf("%.2x ", *string);
         string++;
      }
   }
   printf("\n");
}


VOID
DisplayConfigTuple(
                  PUCHAR TupleBuffer,
                  UCHAR  TupleSize
                  )

/*++

Routine Description:

    Display the data at the given pointer as a CISTPL_CONFIG tuple.

Arguments:

    TupleBuffer - the CISTPL_DEVICE to display.
    TupleSize   - the link value for the tuple.

Return Value:

    None

--*/

{
   UCHAR  sizeField;
   UCHAR  tpccRfsz;
   UCHAR  tpccRmsz;
   UCHAR  tpccRasz;
   UCHAR  last;
   ULONG  baseAddress;
   PUCHAR ptr;

   sizeField = *TupleBuffer;
   last = *(TupleBuffer + 1);
   tpccRfsz = TpccRfsz(sizeField);
   tpccRmsz = TpccRmsz(sizeField);
   tpccRasz = TpccRasz(sizeField);

   printf("TPCC_SZ %.2x (%.2x/%.2x/%.2x) - Last %.2x\n",
          sizeField,
          tpccRasz,
          tpccRmsz,
          tpccRfsz,
          last);

   baseAddress = 0;
   ptr = TupleBuffer + 2;
   switch (tpccRasz) {
   case 3:
      baseAddress = *(ptr + 3) << 24;
   case 2:
      baseAddress |= *(ptr + 2) << 16;
   case 1:
      baseAddress |= *(ptr + 1) << 8;
   default:
      baseAddress |= *ptr;
   }
   printf("Base Address: %8x - ", baseAddress);
   ptr += tpccRasz + 1;

   baseAddress = 0;
   switch (tpccRmsz) {
   case 3:
      baseAddress = *(ptr + 3) << 24;
   case 2:
      baseAddress |= *(ptr + 2) << 16;
   case 1:
      baseAddress |= *(ptr + 1) << 8;
   default:
      baseAddress |= *ptr;
   }
   printf("Register Presence Mask: %8x\n", baseAddress);
}


PUCHAR
ProcessMemSpace(
               PUCHAR Buffer,
               UCHAR  MemSpace
               )

/*++

Routine Description:

    Display and process memspace information

Arguments:

    Buffer - start of memspace information
    MemSpace - the memspace value from the feature byte.

Return Value:

    location of byte after all memory space information

--*/

{
   PUCHAR ptr = Buffer;
   UCHAR  item = *ptr++;
   UCHAR  lengthSize;
   UCHAR  addrSize;
   UCHAR  number;
   UCHAR  hasHostAddress;
   ULONG  cardAddress;
   ULONG  length;
   ULONG  hostAddress;

   if (MemSpace == 3) {

      lengthSize = (item & 0x18) >> 3;
      addrSize = (item & 0x60) >> 5;
      number = (item & 0x07) + 1;
      hasHostAddress = item & 0x80;
      printf("(0x%.2x) %s - %d entries - LengthSize %d - AddrSize %d\n",
             item,
             hasHostAddress ? "Host address" : "no host",
             number,
             lengthSize,
             addrSize);
      while (number) {
         cardAddress = length = hostAddress = 0;
         switch (lengthSize) {
         case 3:
            length |= (*(ptr + 2)) << 16;
         case 2:
            length |= (*(ptr + 1)) << 8;
         case 1:
            length |= *ptr;
         }
         ptr += lengthSize;
         switch (addrSize) {
         case 3:
            cardAddress |= (*(ptr + 2)) << 16;
         case 2:
            cardAddress |= (*(ptr + 1)) << 8;
         case 1:
            cardAddress |= *ptr;
         }
         ptr += addrSize;
         if (hasHostAddress) {
            switch (addrSize) {
            case 3:
               hostAddress |= (*(ptr + 2)) << 16;
            case 2:
               hostAddress |= (*(ptr + 1)) << 8;
            case 1:
               hostAddress |= *ptr;
            }
            printf("\tHost 0x%.8x ", hostAddress * 256);
            ptr += addrSize;
         } else {
            printf("\t");
         }
         printf("Card 0x%.8x Size 0x%.8x\n",
                cardAddress * 256,
                length * 256);
         number--;
      }
   }
   return ptr;
}

USHORT VoltageConversionTable[16] = {
   10, 12, 13, 14, 20, 25, 30, 35,
   40, 45, 50, 55, 60, 70, 80, 90
};

UCHAR
ConvertVoltage(
              UCHAR MantissaExponentByte,
              UCHAR ExtensionByte
              )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
   USHORT power;
   USHORT value;

   value = VoltageConversionTable[(MantissaExponentByte >> 3) & 0x0f];
   power = 1;

   if ((MantissaExponentByte & EXTENSION_BYTE_FOLLOWS) &&
       (ExtensionByte < 100)) {
      value = (100 * value + (ExtensionByte & 0x7f));
      power += 2;
   }

   power = (MantissaExponentByte & 0x07) - 4 - power;

   while (power > 0) {
      value *= 10;
      power--;
   }

   while (power < 0) {
      value /= 10;
      power++;
   }

   return (UCHAR) value;
}

PUCHAR PowerTypeTable[] = {
   "Nominal",
   "Minimum",
   "Maximum",
   "Static",
   "Average",
   "Peak",
   "PwrDown"
};

PUCHAR VoltagePinTable[] = {
   "Vcc",
   "Vpp1",
   "Vpp2"
};

PUCHAR
ProcessPower(
            PUCHAR Buffer,
            UCHAR  FeatureByte
            )

/*++

Routine Description:

    Display and process power information

Arguments:

    Power - start of power information

Return Value:

    location of byte after all power information

--*/

{
   UCHAR  powerSelect;
   UCHAR  bit;
   UCHAR  item;
   UCHAR  entries;
   PUCHAR ptr = Buffer;
   UCHAR  count = FeatureByte;

   powerSelect = *ptr;
   printf("Parameter Selection Byte = 0x%.2x\n", powerSelect);

   entries = 0;
   while (entries < count) {
      powerSelect = *ptr++;
      printf("\t%s \"%d%d%d%d%d%d%d%d\"\n",
             VoltagePinTable[entries],
             powerSelect & 0x80 ? 1 : 0,
             powerSelect & 0x40 ? 1 : 0,
             powerSelect & 0x20 ? 1 : 0,
             powerSelect & 0x10 ? 1 : 0,
             powerSelect & 0x08 ? 1 : 0,
             powerSelect & 0x04 ? 1 : 0,
             powerSelect & 0x02 ? 1 : 0,
             powerSelect & 0x01 ? 1 : 0);
      for (bit = 0; bit < 7; bit++) {
         if (powerSelect & (1 << bit)) {

            if (!bit) {

               //
               // Convert nominal power for output.
               //

               item = ConvertVoltage(*ptr,
                                     (UCHAR) (*ptr & EXTENSION_BYTE_FOLLOWS ?
                                              *(ptr + 1) :
                                              (UCHAR) 0));
            }
            printf("\t\t%s power =\t%d/10 volts\n", PowerTypeTable[bit], item);
            while (*ptr++ & EXTENSION_BYTE_FOLLOWS) {
            }
         }
      }
      entries++;
   }
   return ptr;
}

PUCHAR
ProcessTiming(
             PUCHAR Buffer
             )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
   PUCHAR ptr = Buffer;
   UCHAR  item = *ptr++;
   UCHAR  reservedScale = (item & 0xe0) >> 5;
   UCHAR  readyBusyScale = (item & 0x1c) >> 2;
   UCHAR  waitScale = (item & 0x03);

   printf("Timing (0x%.2x): reservedScale 0x%.2x, readyBusyScale 0x%.2x, waitScale 0x%.2x\n",
          item,
          reservedScale,
          readyBusyScale,
          waitScale);

   if (waitScale != 3) {
      printf("\tWaitSpeed 0x%.2x\n", *ptr);
      ptr++;
      while (*ptr & EXTENSION_BYTE_FOLLOWS) {
         ptr++;
      }
   }

   if (readyBusyScale != 7) {
      printf("\tReadyBusySpeed 0x%.2x\n", *ptr);
      ptr++;
      while (*ptr & EXTENSION_BYTE_FOLLOWS) {
         ptr++;
      }
   }

   if (reservedScale != 7) {
      printf("\tReservedSpeed 0x%.2x\n", *ptr);
      ptr++;
      while (*ptr & EXTENSION_BYTE_FOLLOWS) {
         ptr++;
      }
   }
   return ptr;
}

PUCHAR
ProcessIoSpace(
              PUCHAR Buffer
              )

/*++

Routine Description:

    Display and process iospace information

Arguments:

    Buffer - start of IoSpace information

Return Value:

    location of byte after all power information

--*/

{
   UCHAR  item;
   UCHAR  ioAddrLines;
   UCHAR  bus8;
   UCHAR  bus16;
   UCHAR  ranges;
   UCHAR  lengthSize;
   UCHAR  addressSize;
   ULONG  address;
   PUCHAR ptr = Buffer;

   item = *ptr++;
   ioAddrLines = item & IO_ADDRESS_LINES_MASK;
   bus8 = Is8BitAccess(item);
   bus16 = Is16BitAccess(item);
   ranges = HasRanges(item);

   printf("IoSpace (%.2x): IoAddressLines %.2d - %s/%s\n",
          item,
          ioAddrLines,
          bus8 ? "8bit" : "",
          bus16 ? "16bit" : "");

   //
   // This is what it looks like the IBM token ring card
   // does.  It is unclear in the specification if this
   // is correct or not.
   //

   if ((!ranges) && (!ioAddrLines)) {
      ranges = 0xFF;
   }

   if (ranges) {

      if (ranges == 0xff) {

         //
         // This is based on the tuple data as given by
         // the IBM token ring card.  This is not the
         // way I would interpret the specification.
         //

         addressSize = 2;
         lengthSize = 1;
         ranges = 1;
      } else {
         item = *ptr++;
         ranges = item & 0x0f;
         ranges++;
         addressSize = GetAddressSize(item);
         lengthSize = GetLengthSize(item);
      }

      while (ranges) {
         address = 0;
         switch (addressSize) {
         case 4:
            address |= (*(ptr + 3)) << 24;
         case 3:
            address |= (*(ptr + 2)) << 16;
         case 2:
            address |= (*(ptr + 1)) << 8;
         case 1:
            address |= *ptr;
         }
         ptr += addressSize;
         printf("\tStart %.8x - Length ", address);

         address = 0;
         switch (lengthSize) {
         case 4:
            address |= (*(ptr + 3)) << 24;
         case 3:
            address |= (*(ptr + 2)) << 16;
         case 2:
            address |= (*(ptr + 1)) << 8;
         case 1:
            address |= *ptr;
         }
         ptr += lengthSize;
         printf("%.8x\n", address);

         ranges--;
      }
   } else {
      printf("\tResponds to all ranges.\n");
   }
   return ptr;
}
PUCHAR
ProcessIrq(
          PUCHAR Buffer
          )

/*++

Routine Description:

    Display and process irq information

Arguments:

    Buffer - start of irq information

Return Value:

    location of byte after all irq information

--*/

{
   PUCHAR ptr = Buffer;
   UCHAR  level;
   USHORT mask;
   ULONG  irqNumber;

   level = *ptr++;
   if (!level) {

      //
      // NOTE: It looks like Future Domain messed up on this
      // and puts an extra zero byte into the structure.
      // skip it for now.
      //

      level = *ptr++;
   }
   if (level & 0x80) {
      printf("Share ");
   }
   if (level & 0x40) {
      printf("Pulse ");
   }
   if (level & 0x20) {
      printf("Level ");
   }
   if (level & 0x10) {
      mask = *ptr | (*(ptr + 1) << 8);
      ptr += 2;
      printf("mask = %.4x - ", mask);
      for (irqNumber = 0; mask; irqNumber++, mask = mask >> 1) {
         if (mask & 0x0001) {
            printf("IRQ%d ", irqNumber);
         }
      }
      printf("- ");

      if (level & 0x08) {
         printf("Vend ");
      }
      if (level & 0x04) {
         printf("Berr ");
      }
      if (level & 0x02) {
         printf("IOCK ");
      }
      if (level & 0x01) {
         printf("NMI");
      }
      printf("\n");
   } else {
      printf("irq = %d\n", level & 0x0f);
   }

   return ptr;
}


PUCHAR InterfaceTypeStrings[] = {
   "Memory",
   "I/O",
   "Reserved 2",
   "Reserved 3",
   "Custom 0",
   "Custom 1",
   "Custom 2",
   "Custom 3",
   "Reserved 8",
   "Reserved 9",
   "Reserved a",
   "Reserved b",
   "Reserved c",
   "Reserved d",
   "Reserved e",
   "Reserved f",
};

VOID
DisplayCftableEntryTuple(
                        PUCHAR TupleBuffer,
                        UCHAR  TupleSize
                        )

/*++

Routine Description:

    Display the data at the given pointer as a CISTPL_CFTABLE_ENTRY tuple.

Arguments:

    TupleBuffer - the CISTPL_DEVICE to display.
    TupleSize   - the link value for the tuple.

Return Value:

    None

--*/

{
   UCHAR  temp;
   UCHAR  item;
   UCHAR  defaultbit;
   UCHAR  memSpace;
   UCHAR  power;
   PUCHAR ptr;

   temp = *TupleBuffer;
   item = IntFace(temp);
   defaultbit = Default(temp);
   temp = ConfigEntryNumber(temp);

   printf("ConfigurationEntryNumber %.2x (%s/%s)\n",
          temp,
          item ? "intface" : "",
          defaultbit ? "default" : "");

   ptr = TupleBuffer + 1;
   if (item) {
      temp = *ptr++;
      item = temp & 0x0F;
      printf("InterfaceDescription (%.2x) %s (%s/%s/%s/%s)\n",
             temp,
             InterfaceTypeStrings[item],
             temp & 0x80 ? "WaitReq" : "",
             temp & 0x40 ? "RdyBsy" : "",
             temp & 0x20 ? "WP" : "",
             temp & 0x10 ? "BVD" : "");
   }
   item = *ptr++;

   memSpace = MemSpaceInformation(item);
   power = PowerInformation(item);
   printf("The following structures are present:\n");
   switch (power) {
   case 3:
      printf("Vcc, Vpp1, Vpp2; ");
      break;
   case 2:
      printf("Vcc and Vpp; ");
      break;
   case 1:
      printf("Vcc; ");
      break;
   case 0:
      break;
   }
   if (power) {
      ptr = ProcessPower(ptr, power);
   }
   if (TimingInformation(item)) {
      ptr = ProcessTiming(ptr);
   }
   if (IoSpaceInformation(item)) {
      ptr = ProcessIoSpace(ptr);
   }
   if (IRQInformation(item)) {
      printf("IRQ: ");
      ptr = ProcessIrq(ptr);
   }
   switch (memSpace) {
   case 3:
      printf("Memory selection: ");
      break;
   case 2:
      printf("Length and Card Address: ");
      break;
   case 1:
      printf("2-byte length: ");
      break;
   case 0:
      break;
   }
   if (memSpace) {
      ptr = ProcessMemSpace(ptr, memSpace);
   }

   if (MiscInformation(item)) {
      printf("Misc fields present");
   }
   printf("\n");
}


UCHAR TplList[] = {
   CISTPL_DEVICE,
   CISTPL_VERS_1,
   CISTPL_CONFIG,
   CISTPL_CFTABLE_ENTRY,
   CISTPL_MANFID,
   CISTPL_END
};

static unsigned short crc16a[] = {
   0000000,  0140301,  0140601,  0000500,
   0141401,  0001700,  0001200,  0141101,
   0143001,  0003300,  0003600,  0143501,
   0002400,  0142701,  0142201,  0002100,
};
static unsigned short crc16b[] = {
   0000000,  0146001,  0154001,  0012000,
   0170001,  0036000,  0024000,  0162001,
   0120001,  0066000,  0074000,  0132001,
   0050000,  0116001,  0104001,  0043000,
};
USHORT
GetCRC(
      PUCHAR TupleBuffer
      )

/*++

Routine Description:

    Using the same algorithm as Windows 95, calculate the CRC value
    to be appended with the manufacturer name and device name to
    obtain the unique identifier for the PCCARD.

Arguments:

    TupleBuffer - the tuple data

Return Value:

    A USHORT CRC value.

--*/

{
   USHORT  crc = 0;
   USHORT  index;
   USHORT  length;
   PUCHAR  tupleData;
   PUCHAR  cp;
   PUCHAR  tplBuffer;
   UCHAR   tupleCode;
   UCHAR   linkValue;
   UCHAR   tmp;

   //
   // Calculate CRC
   //

   tplBuffer = TupleBuffer;
   printf("Calculating CRC ");
   while (1) {
      tupleData = tplBuffer + 2;
      tupleCode = *tplBuffer++;

      if (tupleCode == CISTPL_END) {
         break;
      }

      linkValue = (tupleCode) ? *tplBuffer++ : 0;
      length = linkValue;

      printf("%x", tupleCode);
      for (index = 0; TplList[index] != CISTPL_END; index++) {

         if (tupleCode == TplList[index]) {


            //
            // This one is included in the CRC calculation
            //

            printf("*", tupleCode);
            if (tupleCode == CISTPL_VERS_1) {
               cp = tupleData + 2;

               //
               // Include all of the manufacturer name.
               //

               while (*cp) {
                  cp++;
               }

               //
               // Include the product string
               //

               cp++;
               while (*cp) {
                  cp++;
               }
               cp++;

               length = (USHORT)(cp - tupleData);
            }

            for (cp = tupleData; length; length--, cp++) {

               tmp = *cp ^ (UCHAR)crc;
               crc = (crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4];
            }
            break;
         }
      }
      printf(" ");
      tplBuffer = tplBuffer + linkValue;
   }
   printf("++\n");
   return crc;
}


VOID
DumpTuple(
         PUCHAR Buffer
         )

/*++

Routine Description:

    Control routine to process the tuple data.

Arguments:

    Buffer - the tuple data.

Return Value:

    None

--*/

{
   PUCHAR tupleBuffer = Buffer;
   PUCHAR tupleCodeName;
   USHORT crc;
   UCHAR  index;
   UCHAR  tupleCode;
   UCHAR  linkValue;

   crc = GetCRC(tupleBuffer);
   while (1) {
      tupleCode = *tupleBuffer++;
      linkValue = (tupleCode) ? *tupleBuffer : 0;

      if (tupleCode == CISTPL_END) {
         break;
      }

      tupleCodeName = FindTupleCodeName(tupleCode);

      printf("Tuple Code\t%s\t%.2x - Link %.2x:", tupleCodeName, tupleCode, linkValue);

      if (linkValue) {
         for (index = 0; index < linkValue; index++) {
            if ((index & 0x0F) == 0) {
               printf("\n");
            }
            printf(" %.2x", *(tupleBuffer + index + 1));
         }
      }
      printf("\n");

      tupleBuffer++;
      switch (tupleCode) {
      case CISTPL_DEVICE:
         DisplayDeviceTuple(tupleBuffer, linkValue);
         break;
      case CISTPL_VERS_1:
         DisplayVers1(tupleBuffer, linkValue, crc);
         break;
      case CISTPL_CONFIG:
         DisplayConfigTuple(tupleBuffer, linkValue);
         break;
      case CISTPL_CFTABLE_ENTRY:
         DisplayCftableEntryTuple(tupleBuffer, linkValue);
         break;
      case CISTPL_LONGLINK_MFC:
      case CISTPL_LONGLINK_A:
      case CISTPL_LONGLINK_C:
      case CISTPL_LINKTARGET:
      case CISTPL_NO_LINK:
      default:
         break;
      }

      tupleBuffer = tupleBuffer + linkValue;
      printf("\n");
   }
}



VOID
DumpCIS(
        HANDLE Handle,
        ULONG  Slot,
        PUCHAR Buffer,
        ULONG  BufferSize
        )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   NTSTATUS status;
   PULONG   longBuffer;
   PUCHAR   currentBufferPointer;
   UCHAR    hexBuffer[260];
   UCHAR    ascii[100];
   ULONG     i;
   UCHAR    c;
   
   longBuffer = (PULONG) Buffer;
   for (i = 0; i < (BufferSize / sizeof(ULONG)); i++) {
      *longBuffer = 0;
      longBuffer++;
   }
   status = ReadTuple(Handle, Slot, Buffer, BufferSize);

   //
   // Don't bother dumping tuples for cards that aren't there.
   //

   if (!NT_SUCCESS(status)) {
      return;
   }

   printf("\nCIS Tuples for Socket Number %d:\n\n", Slot);

   hexBuffer[0] = '\0';
   ascii[0] = '\0';
   currentBufferPointer = Buffer;
   for (i = 0; i < 512; i++) {
      c = *currentBufferPointer;
      sprintf(hexBuffer, "%s %.2x", hexBuffer, c);
      c = isprint(c) ? c : '.';
      sprintf(ascii, "%s%c", ascii, c);
      currentBufferPointer++;

      //
      // Display the line every 16 bytes.
      //

      if ((i & 0x0f) == 0x0f) {
         printf("%s", hexBuffer);
         printf(" *%s*\n", ascii);
         hexBuffer[0] = '\0';
         ascii[0] = '\0';
      }
   }
   printf("%s", hexBuffer);
   printf("\t\t*%s*\n\n", ascii);
   DumpTuple(Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcopy\pcopy.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>

// #include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>


// Generic routine to write a blob out.
void
SaveTemp(
         PVOID pFile,
         PCHAR szFile,
         DWORD FileSize
         )
{
    DWORD dwBytesWritten;
    HANDLE hFile;
    hFile = CreateFile(
                szFile,
                GENERIC_WRITE,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                CREATE_ALWAYS,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf("Unable to open %s\n", szFile);
        return;
    }

    if (!WriteFile(hFile, pFile, FileSize, &dwBytesWritten, FALSE)) {
        printf("Unable to write date to %s\n", szFile);
    }

    CloseHandle(hFile);
    return;
}

// Zero out the timestamps in a PE library.
BOOL
ZeroLibTimeStamps(
    PCHAR pFile,
    DWORD dwSize
    )
{
    PIMAGE_ARCHIVE_MEMBER_HEADER pHeader;
    DWORD dwOffset;
    CHAR MemberSize[sizeof(pHeader->Size) + 1];
    PIMAGE_FILE_HEADER pObjHeader;

    ZeroMemory(MemberSize, sizeof(MemberSize));

    __try {

        dwOffset = IMAGE_ARCHIVE_START_SIZE;
        while (dwOffset < dwSize) {
            pHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER)(pFile+dwOffset);
            ZeroMemory(pHeader->Date, sizeof(pHeader->Date));

            dwOffset += IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR;
            memcpy(MemberSize, pHeader->Size, sizeof(pHeader->Size));

            // If it's not one of the special members, it must be an object/file, zero it's timestamp also.
            if (memcmp(pHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(pHeader->Name)) &&
                memcmp(pHeader->Name, IMAGE_ARCHIVE_LONGNAMES_MEMBER, sizeof(pHeader->Name)))
            {
                IMAGE_FILE_HEADER UNALIGNED *pFileHeader = (PIMAGE_FILE_HEADER)(pFile+dwOffset);
                if ((pFileHeader->Machine == IMAGE_FILE_MACHINE_UNKNOWN) &&
                    (pFileHeader->NumberOfSections == IMPORT_OBJECT_HDR_SIG2))
                {
                    // VC6 import descriptor OR ANON object header. Eitherway,
                    // casting to IMPORT_OBJECT_HEADER will do the trick.
                    ((IMPORT_OBJECT_HEADER UNALIGNED *)pFileHeader)->TimeDateStamp = 0;
                } else {
                    pFileHeader->TimeDateStamp = 0;
                }
            }
            dwOffset += strtoul(MemberSize, NULL, 10);
            dwOffset = (dwOffset + 1) & ~1;   // align to word
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    return TRUE;
}

//
// Compare two libraries ignoring info that isn't relevant
//  (timestamps for now, debug info later).
//
int
libcomp(
    void *pFile1,
    DWORD dwSize1,
    void *pFile2,
    DWORD dwSize2
    )
{
    if (dwSize1 != dwSize2) {
        return 1;
    }

    // Normalize the two files and compare the results.

    ZeroLibTimeStamps(pFile1, dwSize1);
    ZeroLibTimeStamps(pFile2, dwSize2);

    return memcmp(pFile1, pFile2, dwSize1);
}

//
// Compare two headers.  For now, just use memcmp.  Later, we'll need to
// handle MIDL generated timestamp differences and check for comment only changes.
//

int
hdrcomp(
       void *pFile1,
       DWORD dwSize1,
       void *pFile2,
       DWORD dwSize2
      )
{
    if (dwSize1 != dwSize2) {
        return 1;
    }

    return memcmp(pFile1, pFile2, dwSize1);
}

//
// Compare two typelibs.  Initially just memcmp.  Use DougF's typelib code later.
//

int
tlbcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2
       )
{
    if (dwSize1 != dwSize2) {
        return 1;
    }

    return memcmp(pFile1, pFile2, dwSize1);
}

int
objcomp(
        void *pFile1,
        DWORD dwSize1,
        void *pFile2,
        DWORD dwSize2
       )
{
    PIMAGE_FILE_HEADER pFileHeader1 = (PIMAGE_FILE_HEADER)(pFile1);
    PIMAGE_FILE_HEADER pFileHeader2 = (PIMAGE_FILE_HEADER)(pFile2);

    if ((dwSize1 != dwSize2) || (pFileHeader1->Machine != pFileHeader2->Machine))
    {
        return 1;
    }

    pFileHeader1->TimeDateStamp = 0;
    pFileHeader2->TimeDateStamp = 0;
    return memcmp(pFile1, pFile2, dwSize1);
}

int
IsValidMachineType(USHORT usMachine)
{
    if ((usMachine == IMAGE_FILE_MACHINE_I386) ||
        (usMachine == IMAGE_FILE_MACHINE_IA64) ||
        (usMachine == IMAGE_FILE_MACHINE_ALPHA64) ||
        (usMachine == IMAGE_FILE_MACHINE_ALPHA))
    {
        return TRUE;
    } else {
        return FALSE;
    }
}



#define FILETYPE_ARCHIVE  0x01
#define FILETYPE_TYPELIB  0x02
#define FILETYPE_HEADER   0x03
#define FILETYPE_PE_OBJECT   0x04
#define FILETYPE_UNKNOWN  0xff

//
// Given a file, attempt to determine what it is.  Initial pass will just use file
//  extensions except for libs that we can search for the <arch>\n start.
//

int
DetermineFileType(
                  void *pFile,
                  DWORD dwSize,
                  CHAR *szFileName
                 )
{
    char szExt[_MAX_EXT];

    // Let's see if it's a library first:

    if ((dwSize >= IMAGE_ARCHIVE_START_SIZE) &&
        !memcmp(pFile, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE))
    {
        return FILETYPE_ARCHIVE;
    }

    // For now, guess about the headers/tlb based on the extension.

    _splitpath(szFileName, NULL, NULL, NULL, szExt);

    if (!_stricmp(szExt, ".h") ||
        !_stricmp(szExt, ".hxx") ||
        !_stricmp(szExt, ".hpp") ||
        !_stricmp(szExt, ".w") ||
        !_stricmp(szExt, ".inc"))
    {
        return FILETYPE_HEADER;
    }

    if (!_stricmp(szExt, ".tlb"))
    {
        return FILETYPE_TYPELIB;
    }

    if (!_stricmp(szExt, ".obj") && IsValidMachineType(((PIMAGE_FILE_HEADER)pFile)->Machine))
    {
        return FILETYPE_PE_OBJECT;
    }

    return FILETYPE_UNKNOWN;
}

//
// Determine if two files are materially different.
//

BOOL
CheckIfCopyNecessary(
                     char *szSourceFile,
                     char *szDestFile,
                     BOOL *fTimeStampsDiffer
                     )
{
    PVOID pFile1 = NULL, pFile2 = NULL;
    DWORD File1Size, File2Size, dwBytesRead, dwErrorCode = ERROR_SUCCESS;
    HANDLE hFile1 = INVALID_HANDLE_VALUE;
    HANDLE hFile2 = INVALID_HANDLE_VALUE;
    BOOL fCopy = FALSE;
    int File1Type, File2Type;
    FILETIME FileTime1, FileTime2;

    hFile1 = CreateFile(
                szDestFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile1 == INVALID_HANDLE_VALUE ) {
        fCopy = TRUE;           // Dest file doesn't exist.  Always do the copy.
        goto Exit;
    }

    // Now get the second file.

    hFile2 = CreateFile(
                szSourceFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile2 == INVALID_HANDLE_VALUE ) {
        // If the source is missing, always skip the copy (don't want to delete the dest file).
        dwErrorCode = ERROR_FILE_NOT_FOUND;
        goto Exit;
    }

    // Get the file time's.  If they match, assume the files match.

    if (!GetFileTime(hFile1, NULL, NULL, &FileTime1)) {
        dwErrorCode = GetLastError();
        goto Exit;
    }

    if (!GetFileTime(hFile2, NULL, NULL, &FileTime2)) {
        dwErrorCode = GetLastError();
        goto Exit;
    }

    if (!memcmp(&FileTime1, &FileTime2, sizeof(FILETIME))) {
        *fTimeStampsDiffer = FALSE;
        goto Exit;
    }

    *fTimeStampsDiffer = TRUE;

    // Read file 1 in.

    File1Size = GetFileSize(hFile1, NULL);

    pFile1 = malloc(File1Size);

    if (!pFile1) {
        dwErrorCode = ERROR_OUTOFMEMORY;
        goto Exit;              // Can't compare - don't copy.
    }

    SetFilePointer(hFile1, 0, 0, FILE_BEGIN);
    if (!ReadFile(hFile1, pFile1, File1Size, &dwBytesRead, FALSE)) {
        dwErrorCode = GetLastError();
        goto Exit;              // Can't compare - don't copy
    }

    CloseHandle(hFile1);
    hFile1 = INVALID_HANDLE_VALUE;

    // Read file 2 in.

    File2Size = GetFileSize(hFile2, NULL);
    pFile2 = malloc(File2Size);

    if (!pFile2) {
        dwErrorCode = ERROR_OUTOFMEMORY;
        goto Exit;              // Can't compare - don't copy.
    }

    SetFilePointer(hFile2, 0, 0, FILE_BEGIN);
    if (!ReadFile(hFile2, pFile2, File2Size, &dwBytesRead, FALSE)) {
        dwErrorCode = GetLastError();
        goto Exit;              // Can't compare - don't copy
    }

    CloseHandle(hFile2);
    hFile2 = INVALID_HANDLE_VALUE;

    // Let's see what we've got.

    File1Type = DetermineFileType(pFile1, File1Size, szSourceFile);
    File2Type = DetermineFileType(pFile2, File2Size, szDestFile);

    if (File1Type == File2Type) {
        switch (File1Type) {
            case FILETYPE_ARCHIVE:
                fCopy = libcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_HEADER:
                fCopy = hdrcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_TYPELIB:
                fCopy = tlbcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_PE_OBJECT:
                fCopy = objcomp(pFile1, File1Size, pFile2, File2Size);
                break;

            case FILETYPE_UNKNOWN:
            default:
                if (File1Size == File2Size) {
                    fCopy = memcmp(pFile1, pFile2, File1Size);
                } else {
                    fCopy = TRUE;
                }
        }
    } else {
        // They don't match according to file extensions - just memcmp them.
        if (File1Size == File2Size) {
            fCopy = memcmp(pFile1, pFile2, File1Size);
        } else {
            fCopy = TRUE;
        }
    }

Exit:
    if (pFile1)
        free(pFile1);

    if (pFile2)
        free(pFile2);

    if (hFile1 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile1);

    if (hFile2 != INVALID_HANDLE_VALUE)
        CloseHandle(hFile2);

    SetLastError(dwErrorCode);

    return fCopy;
}

BOOL
UpdateDestTimeStamp(
                     char *szSourceFile,
                     char *szDestFile
                     )
{
    HANDLE hFile;
    FILETIME LastWriteTime;
    DWORD dwAttributes;
    BOOL fTweakAttributes;

    hFile = CreateFile(
                szSourceFile,
                GENERIC_READ,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    if (!GetFileTime(hFile, NULL, NULL, &LastWriteTime)) {
        return FALSE;
    }

    CloseHandle(hFile);

    dwAttributes = GetFileAttributes(szDestFile);

    if ((dwAttributes != (DWORD) -1) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        // Make sure it's not readonly
        SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
        fTweakAttributes = TRUE;
    } else {
        fTweakAttributes = FALSE;
    }

    hFile = CreateFile(
                szDestFile,
                GENERIC_WRITE,
                (FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE),
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if ( hFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    SetFileTime(hFile, NULL, NULL, &LastWriteTime);
    CloseHandle(hFile);

    if (fTweakAttributes) {
        // Put the readonly attribute back on.
        if (!SetFileAttributes(szDestFile, dwAttributes)) {
            printf("PCOPY: SetFileAttributes(%s, %X) failed - error code: %d\n", szDestFile, dwAttributes, GetLastError());
        }
    }
    return TRUE;
}

//
// Log routine to find out what files were actually copied and why.
//

void
LogCopyFile(
            char * szSource,
            char * szDest,
            BOOL fCopy,
            DWORD dwReturnCode
            )
{
    if (getenv("LOG_PCOPY")) {
        FILE *FileHandle = fopen("\\pcopy.log", "a");

        if (FileHandle) {
             time_t Time;
             UCHAR const *szTime = "";
             Time = time(NULL);
             szTime = ctime(&Time);
             fprintf(FileHandle, "%s: %.*s, %s, %s, %d\n", fCopy ? (dwReturnCode ? "ERROR" : "DONE") : "SKIP", strlen(szTime)-1, szTime, szSource, szDest, dwReturnCode);
             fclose(FileHandle);
        }
    }
}

BOOL
MyMakeSureDirectoryPathExists(
    char * DirPath
    )
{
    LPSTR p;
    DWORD dw;

    char szDir[_MAX_DIR];
    char szMakeDir[_MAX_DIR];

    _splitpath(DirPath, szMakeDir, szDir, NULL, NULL);
    strcat(szMakeDir, szDir);

    p = szMakeDir;

    dw = GetFileAttributes(szMakeDir);
    if ( (dw != (DWORD) -1) && (dw & FILE_ATTRIBUTE_DIRECTORY) ) {
        // Directory already exists.
        return TRUE;
    }

    //  If the second character in the path is "\", then this is a UNC
    //  path, and we should skip forward until we reach the 2nd \ in the path.

    if ((*p == '\\') && (*(p+1) == '\\')) {
        p++;            // Skip over the first \ in the name.
        p++;            // Skip over the second \ in the name.

        //  Skip until we hit the first "\" (\\Server\).

        while (*p && *p != '\\') {
            p = p++;
        }

        // Advance over it.

        if (*p) {
            p++;
        }

        //  Skip until we hit the second "\" (\\Server\Share\).

        while (*p && *p != '\\') {
            p = p++;
        }

        // Advance over it also.

        if (*p) {
            p++;
        }

    } else
    // Not a UNC.  See if it's <drive>:
    if (*(p+1) == ':' ) {

        p++;
        p++;

        // If it exists, skip over the root specifier

        if (*p && (*p == '\\')) {
            p++;
        }
    }

    while( *p ) {
        if ( *p == '\\' ) {
            *p = '\0';
            dw = GetFileAttributes(szMakeDir);
            // Nothing exists with this name.  Try to make the directory name and error if unable to.
            if ( dw == 0xffffffff ) {
                if ( !CreateDirectory(szMakeDir,NULL) ) {
                    if( GetLastError() != ERROR_ALREADY_EXISTS ) {
                        return FALSE;
                    }
                }
            } else {
                if ( (dw & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY ) {
                    // Something exists with this name, but it's not a directory... Error
                    return FALSE;
                }
            }

            *p = '\\';
        }
        p = p++;
    }

    return TRUE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *szSourceFile, *szDestFile;
    BOOL fCopyFile = 0, fDoCopy, fTimeStampsDiffer;
    int CopyErrorCode;

    if (argc < 3) {
        puts("pcopy <source file> <dest file>\n"
             "Returns: -1 if no copy necessary (no material change to the files)\n"
             "          0 if a successful copy was made\n"
             "          otherwise the error code for why the copy was unsuccessful\n");
        return ((int)ERROR_INVALID_COMMAND_LINE);
    }

    szSourceFile = argv[1];
    szDestFile = argv[2];

    fDoCopy = CheckIfCopyNecessary(szSourceFile, szDestFile, &fTimeStampsDiffer);

    if (fDoCopy) {
        DWORD dwAttributes = GetFileAttributes(szDestFile);

        if (dwAttributes != (DWORD) -1) {
            // Make sure it's not readonly
            SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
        }

        // Make sure destination directory exists.
        MyMakeSureDirectoryPathExists(szDestFile);

        fCopyFile = CopyFileA(szSourceFile, szDestFile, FALSE);
        if (!fCopyFile) {
            CopyErrorCode = (int) GetLastError();
        } else {
            dwAttributes = GetFileAttributes(szDestFile);

            if (dwAttributes != (DWORD) -1) {
                // Make sure the dest is read/write
                SetFileAttributes(szDestFile, dwAttributes & ~FILE_ATTRIBUTE_READONLY);
            }

            CopyErrorCode = 0;
        }
    } else {
        CopyErrorCode = GetLastError();
        if (!CopyErrorCode && fTimeStampsDiffer) {
            // No copy necessary.  Touch the timestamp on the dest to match the source.
            UpdateDestTimeStamp(szSourceFile, szDestFile);
        }
    }

    LogCopyFile(szSourceFile, szDestFile, fDoCopy, CopyErrorCode);

    if (fDoCopy) {
        return CopyErrorCode;
    } else {
        return CopyErrorCode ? CopyErrorCode : -1;      // No copy necessary.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\registry.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module contains the code that dumps pccard info from the registry

Author:

    Neil Sandlin (neilsa) 11 Feb 1999

Environment:

    User mode

Revision History :


--*/

#include "pch.h"

#define PCMCIA_REGISTRY_CONTROLLER_TYPE    "OtherController"



VOID
DumpIrqMap(
   PUCHAR IRQMap
   )
{

   ULONG i;
   ULONG usable = 0, crossed = 0;
   
   for (i = 1; i < 16; i++) {
      if (IRQMap[i] == i) {
         usable++;
      } else if (IRQMap[i] != 0) {
         crossed++;
      }
   }
   
   if (usable == 0) {
      printf("NO usable IRQs found!\n");
   } else {
      if (usable == 1) {
         printf("1 usable IRQ found: ");
      } else {
         printf("%d usable IRQs found: ", usable);
      }
      
   
      for (i = 1; (i < 16) && usable; i++) {
         if (IRQMap[i] == i) {
            printf("%X", i);
            if (--usable != 0) {
               printf(",");
            }
         }

      }               
      printf("\n");
   }
   
   if (crossed) {
      printf("Crosswired IRQs found!\n");
   
      for (i = 1; (i < 16) && crossed; i++) {
         if (IRQMap[i] && (IRQMap[i] != i)) {
            printf("          %X ==> %X\n", i, IRQMap[i]);
            crossed--;
         }
      }               
   }
   printf("\n");
}   


VOID
DumpDetectedIrqMaskData(
   PVOID pArgData,
   ULONG DataSize
   )
{
   static PUCHAR ErrorStrings[] = {
        "Unknown",
        "Scan Disabled",
        "Map Zero",
        "No Timer",
        "No Pic",
        "No Legacy Base",
        "Dup Legacy Base",
        "No Controllers"
        };
#define MAX_ERROR_CODE 7


   if (DataSize == sizeof(CM_PCCARD_DEVICE_DATA)) {
      PCM_PCCARD_DEVICE_DATA pData = (PCM_PCCARD_DEVICE_DATA) pArgData;
      printf("Version 1.0 Data\n");
      if (pData->Flags & PCCARD_MAP_ERROR) {
          UCHAR ec = pData->ErrorCode;
          
          if (ec > MAX_ERROR_CODE) {
              ec = 0;
          }
          printf("\n*** Detection error: %s\n\n", ErrorStrings[ec]);
      }
      
      if (pData->Flags & PCCARD_DEVICE_PCI) {
          printf("Device is PCI enumerated\n");
      } else {
          printf("Device is legacy detected\n");
      }
      printf("DeviceId = %X\n", pData->DeviceId);
      printf("LegacyBase = %X\n", pData->LegacyBaseAddress);
      DumpIrqMap(pData->IRQMap);
      
   } else if (DataSize == sizeof(OLD_PCCARD_DEVICE_DATA)) { 
      POLD_PCCARD_DEVICE_DATA pData = (POLD_PCCARD_DEVICE_DATA) pArgData;
      printf("Version 0.9 Data\n");
      printf("DeviceId = %X\n", pData->DeviceId);
      printf("LegacyBase = %X\n", pData->LegacyBaseAddress);
      DumpIrqMap(pData->IRQMap);

   } else {
      printf("Error: unrecognized data size\n");
   }      
}
                           


VOID
DumpPcCardKey(
   HKEY handlePcCard
   )
/*++

Routine Description:

   This routine looks through the OtherController key for pccard entries
   created by NTDETECT. For each entry, the IRQ scan data is read in and
   saved for later.
   

Arguments:

   handlePcCard - open handle to "OtherController" key in registry at
                  HARDWARE\Description\System\MultifunctionAdapter\<ISA>

Return value:

   status

--*/
{
#define VALUE2_BUFFER_SIZE sizeof(CM_PCCARD_DEVICE_DATA) + sizeof(CM_FULL_RESOURCE_DESCRIPTOR)
   UCHAR valueInfo[VALUE2_BUFFER_SIZE];
   ULONG valueInfoSize;
   ULONG DataType;

   LONG   status;
   LPTSTR subKeyInfo;
   HKEY   handleSubKey = NULL;
   ULONG  subKeyInfoSize;
   ULONG  index;
   ULONG  resultLength;
   DWORD SubKeys;
   BOOLEAN FoundPcCard = FALSE;
   
   status = RegQueryInfoKey(handlePcCard,
                            NULL, NULL, 0,
                            &SubKeys,
                            &subKeyInfoSize,
                            NULL, NULL, NULL, NULL, NULL, NULL);
                            
   if ((status != ERROR_SUCCESS) &&
       (status != ERROR_MORE_DATA) &&
       (status != ERROR_INSUFFICIENT_BUFFER)) {
      printf("Error: unable to query info on PcCardKey\n");   
      goto cleanup;
   }
   
   subKeyInfo = malloc(subKeyInfoSize+1);
   
   if (!subKeyInfo) {
      printf("Error: unable to malloc subKeyInfo (%d)\n", subKeyInfoSize+1);   
      goto cleanup;
   }

   for (index=0; index < SubKeys; index++) {   
   
      //
      // Loop through the children of the PcCardController key
      //
      status = RegEnumKey(handlePcCard,
                          index,
                          subKeyInfo,
                          subKeyInfoSize+1);

      if (status != NO_ERROR) {
         if (!FoundPcCard) {
            printf("\nError: unable to find pccard detection key\n\n");
         }
         goto cleanup;
      }
   
      if (handleSubKey) {
         // close handle from previous iteration
         RegCloseKey(handleSubKey);
         handleSubKey = NULL;
      }

      status = RegOpenKeyEx(handlePcCard,
                            subKeyInfo,
                            0,
                            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                            &handleSubKey);

      if (status != NO_ERROR) {
         printf("Error: unable to open enumerated key %s (%d)\n", subKeyInfo, status);
         goto cleanup;
      }
      
      //
      // Get the value of "Identifier"
      //

      valueInfoSize = VALUE2_BUFFER_SIZE;
      status = RegQueryValueEx(handleSubKey,
                               "Identifier",
                               0,
                               &DataType,
                               valueInfo,
                               &valueInfoSize
                               );

      if (status == NO_ERROR) {
      
         if ((valueInfoSize == 17) &&
            (valueInfo[0] == 'P') &&
            (valueInfo[1] == 'c') &&
            (valueInfo[2] == 'C') &&
            (valueInfo[3] == 'a') &&
            (valueInfo[4] == 'r') &&
            (valueInfo[5] == 'd')) {

            FoundPcCard = TRUE;            
            //
            // Get the IRQ detection data
            //
            valueInfoSize = VALUE2_BUFFER_SIZE;
            status = RegQueryValueEx(handleSubKey,
                                     "Configuration Data",
                                     0,
                                     &DataType,
                                     valueInfo,
                                     &valueInfoSize
                                     );
           
            if (status == NO_ERROR) {
               PCM_FULL_RESOURCE_DESCRIPTOR pFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) valueInfo;
               PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) pFullDesc->PartialResourceList.PartialDescriptors;

               
               if (pPartialDesc->Type == CmResourceTypeDeviceSpecific) {
                  printf("\n*** PcCard Irq Detection Data:%s ***\n\n", subKeyInfo);

                  DumpDetectedIrqMaskData((PVOID)((ULONG_PTR)&pPartialDesc->u.DeviceSpecificData + 3*sizeof(ULONG)),
                                          pPartialDesc->u.DeviceSpecificData.DataSize);
               }
            }
         }
      }
 
   }
cleanup:
   if (handleSubKey) {
      RegCloseKey(handleSubKey);
   }
   
   if (subKeyInfo) {
      free(subKeyInfo);
   }
   return;      
}



VOID
DumpIrqScanInfo(
   VOID
   )
/*++

Routine Description:

   This routine finds the "OtherController" entry in
   HARDWARE\Description\System\MultifunctionAdapter\<ISA>. This is
   where NTDETECT stores irq scan results.
   
Arguments:

Return value:

   status

--*/
{

#define VALUE_BUFFER_SIZE 4

   UCHAR valueInfo[VALUE_BUFFER_SIZE];
   ULONG valueInfoSize;
   
   HKEY   handleRoot = NULL;
   HKEY   handleSubKey = NULL;
   HKEY   handlePcCard = NULL;
   LPTSTR subKeyInfo = NULL;
   ULONG  subKeyInfoSize;
   LONG   status;
   ULONG  resultLength;
   ULONG  index;
   ULONG  DataType;
   DWORD  SubKeys;
   BOOLEAN FoundIsa = FALSE;
   
   //
   // Get a handle to the MultifunctionAdapter key
   //


   status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter",
                         0,
                         KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                         &handleRoot);

   if (status != NO_ERROR) {
      printf("Error: unable to open MultiFunctionAdapter key (%d)\n", status);   
      goto cleanup;
   }   

   status = RegQueryInfoKey(handleRoot,
                            NULL, NULL, 0,
                            &SubKeys,
                            &subKeyInfoSize,
                            NULL, NULL, NULL, NULL, NULL, NULL);
                            
    if ((status != ERROR_SUCCESS) &&
        (status != ERROR_MORE_DATA) &&
        (status != ERROR_INSUFFICIENT_BUFFER)) {
      printf("Error: unable to query info on MultiFunctionAdapter key (%d)\n", status);   
      goto cleanup;
    }

   subKeyInfo = malloc(subKeyInfoSize+1);
   
   if (!subKeyInfo) {
      printf("Error: unable to malloc subKeyInfo (%d)\n", subKeyInfoSize+1);   
      goto cleanup;
   }
   
   for (index=0; index < SubKeys; index++) {
   
      //
      // Loop through the children of "MultifunctionAdapter"
      //
      status = RegEnumKey(handleRoot,
                          index,
                          subKeyInfo,
                          subKeyInfoSize+1);   

      if (status != NO_ERROR) {
         if (!FoundIsa) {
            printf("Error: ISA key not found (%d)\n", status);
         }            
         goto cleanup;
      }

   
      if (handleSubKey) {
         // close handle from previous iteration
         RegCloseKey(handleSubKey);
         handleSubKey = NULL;
      }
      
      status = RegOpenKeyEx(handleRoot,
                            subKeyInfo,
                            0,
                            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                            &handleSubKey);
   
      if (status != NO_ERROR) {
         printf("Error: unable to open enumerated key %s (%d)\n", subKeyInfo, status);
         goto cleanup;
      }



      //
      // Get the value of "Identifier"
      //
      valueInfoSize = VALUE_BUFFER_SIZE;
      status = RegQueryValueEx(handleSubKey,
                               "Identifier",
                               0,
                               &DataType,
                               valueInfo,
                               &valueInfoSize
                               );
      
      if (status == NO_ERROR) {
         
         if ((valueInfoSize == 4) &&
            (valueInfo[0] == 'I') &&
            (valueInfo[1] == 'S') &&
            (valueInfo[2] == 'A') &&
            (valueInfo[3] == 0)) {

            FoundIsa = TRUE;
            status = RegOpenKeyEx(handleSubKey,
                                  PCMCIA_REGISTRY_CONTROLLER_TYPE,
                                  0,
                                  KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                                  &handlePcCard);
            
            if (status == NO_ERROR) {
            
               DumpPcCardKey(handlePcCard);
               RegCloseKey(handlePcCard);
            } else {
               printf("\nError: unable to find pccard detection data\n\n");
            } 
         }
      }
   }
   
cleanup:
   if (handleRoot) {
      RegCloseKey(handleRoot);
   }

   if (handleSubKey) {
      RegCloseKey(handleSubKey);
   }
   
   if (subKeyInfo) {
      free(subKeyInfo);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\getopt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    getopt.c

Abstract:

    Utility function to parse command line options.
    Inspired by UNIX getopt - but coded from scratch.
    Not thread-safe currently (don't call this from
    multiple threads simultaneously)
   
Author:

    Ravisankar Pudipeddi (ravisp) 27 June 1997

Environment:

    User

Notes:

Revision History:

--*/

#include <pch.h>

PUCHAR optarg;
ULONG  optind=1;
static ULONG optcharind;
static ULONG hyphen=0;

CHAR
getopt (ULONG Argc, PUCHAR *Argv, PCHAR Opts)

/*++

Routine Description:

    Parses command line arguments.
    This function should be repeatedly called
    to parse all the supplied command line options.
    A command line argument prefixed with a hyphen/slash
    ('-' or '/') is treated as a command line option(s).
    The set of options the caller is interested in
    is passed via the Opts argument.

    The format of this desired options list is:

    "<option-letter1>[:]<option-letter2>[:]......."

    Examples: "ds:g",  "x:o:r" etc. 
    Each letter in this string is an option the
    caller is interested in.
    If there is a colon (':') after the option letter,
    then the caller expects an argument with this option
    letter. 
    On each call, successive options are processed and
    the next matching option in the list of desired options
    is returned. If the option requires an argument, then
    the option argument is in the global 'optarg'.
    If all the options have been processed then the value
    EOF is returned at which point caller should desist
    calling this function again for the lifetime of the process.

    A single hyphen/slash ('-' or '/) unaccompanied by any option 
    letter in the command line indicates  getopt to stop processing
    command line options and treat the rest of the arguments
    as regular command line arguments.
    
    After all the options have been processed (i.e. getopt
    returned EOF), the global 'optind' contains the index
    to the start of the non-option arguments which may be
    processed by the caller.

    Note: This function *does not* return an error code if 
    an non-desired option is encountered in the command line.
    
Arguments:
    
    Argc  -  number of command line arguments
    Argv  -  pointer to array of command line arguments 
             (Argv[0] is skipped in processing the options,
              treated as the base filename of the executable)

    Opts  -  String containing the desired options

Return Value:
    
    EOF   - No more options. Don't call this function again.
            The global 'optind' points to index of the first argument
            following the options on the command line
    
    0     - Error in specifying command line options 
           
    Any other character -  Next option on the command line.
                           The value 'optarg' points to the command line
                           argument string following this option, if 
                           the option was indicated as requiring an argument
                           (i.e. preceding a colon in the Opts string)

--*/
{
    CHAR  ch;
    PCHAR indx;

    do {
        if (optind >= Argc) {
            return EOF;
        }
    
        ch = Argv[optind][optcharind++];
        if (ch == '\0') {
            optind++; optcharind=0;
            hyphen = 0;
            continue;
        }
        
        if ( hyphen || (ch == '-') || (ch == '/')) {
            if (!hyphen) {
                ch = Argv[optind][optcharind++];
                if (ch == '\0') {
                    //
                    // just a '-' (or '/')  without any other
                    // char after it indicates to stop
                    // processing options, the rest are
                    // regular command line arguments
                    // optind points to the arguments after
                    // this lone hyphen
                    //
                    optind++;
                    return EOF;
                }
            } else if (ch == '\0') {
                //
                // End of options on this arg.
                // continue to next...
                optind++; 
                optcharind = 0;
                continue;
            }
            indx = strchr(Opts, ch);
            if (indx == NULL) {
                //
                // Non-desired option encountered
                // We just ignore it
                //
                continue;
            }
            if (*(indx+1) == ':') {
                if (Argv[optind][optcharind] != '\0'){
                    optarg = &Argv[optind][optcharind];
                } else {
                    if ((optind + 1) >= Argc ||
                        (Argv[optind+1][0] == '-' ||
                         Argv[optind+1][0] == '/' )) {
                        //
                        // This is a case when one of the following error
                        // condition exists: 
                        //  1. The user didn't supply an argument to an option
                        //     which requires one (ie, this option was the last
                        //     command line argument on the line)
                        //  2. The  supplied another option as an argument to this
                        //     option. Currently we treat this as an error
                        //
                        return 0;
                    }
                    optarg = Argv[++optind];
                }
                optind++;
                hyphen = optcharind = 0;
                return ch;
            }
            //
            // Argument not required for this option
            // So any other characters in the same
            // argument would be other valid options
            //
            hyphen = 1;
            return ch;
        } else {
            //
            // Non option encountered.
            // No more options present..
            //
            return EOF;
        }
    } while (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\pcmcmd.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcmcmd.h

Abstract:

    This file provides definitions for the pcmcmd utility

Author:

    Neil Sandlin

Environment:

    User process.

Notes:

Revision History:
   
--*/

extern
CHAR
getopt (ULONG argc, PUCHAR *argv, PCHAR opts);



VOID
DumpCIS(
        HANDLE Handle,
        ULONG  Slot,
        PUCHAR Buffer,
        ULONG  BufferSize
        );

VOID
DumpIrqScanInfo(
    VOID
    );

//
// Constants
//

#define PCMCIA_DEVICE_NAME "\\DosDevices\\Pcmcia"

#define BUFFER_SIZE 4096
#define CISTPL_END  0xFF

#define CMD_DUMP_TUPLES         0x00000001
#define CMD_DUMP_CONFIGURATION  0x00000002
#define CMD_DUMP_REGISTERS      0x00000004 
#define CMD_DUMP_SOCKET_INFO    0x00000008
#define CMD_DUMP_IRQ_SCAN_INFO  0x00000010

typedef struct _StringTable {
   PUCHAR  CommandName;
   UCHAR   CommandCode;
} StringTable, *PStringTable;


typedef struct _OLD_PCCARD_DEVICE_DATA {
    ULONG DeviceId;
    ULONG LegacyBaseAddress;
    UCHAR IRQMap[16];
} OLD_PCCARD_DEVICE_DATA, *POLD_PCCARD_DEVICE_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pcmcmd\pcmcmd.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    pcmcmd.c

Abstract:

    This program converses with the PCMCIA support driver to display
    tuple and other information.

Author:

    Bob Rinne

Environment:

    User process.

Notes:

Revision History:
   
    Ravisankar Pudipeddi (ravisp) June 27 1997
        - command line options & support for multiple controllers
    Neil Sandlin (neilsa) Sept 20, 1998
        - more commands        

--*/

#include <pch.h>

//
// Procedures
//


NTSTATUS
OpenDevice(
          IN PUCHAR      DeviceName,
          IN OUT PHANDLE HandlePtr
          )

/*++

Routine Description:

    This routine will open the device.

Arguments:

    DeviceName - ASCI string of device path to open.
    HandlePtr - A pointer to a location for the handle returned on a
                successful open.

Return Value:

    NTSTATUS

--*/

{
   OBJECT_ATTRIBUTES objectAttributes;
   STRING            NtFtName;
   IO_STATUS_BLOCK   status_block;
   UNICODE_STRING    unicodeDeviceName;
   NTSTATUS          status;

   RtlInitString(&NtFtName,
                 DeviceName);


   (VOID)RtlAnsiStringToUnicodeString(&unicodeDeviceName,
                                      &NtFtName,
                                      TRUE);

   memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));

   InitializeObjectAttributes(&objectAttributes,
                              &unicodeDeviceName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);


   status = NtOpenFile(HandlePtr,
                       SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                       &objectAttributes,
                       &status_block,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       FILE_SYNCHRONOUS_IO_ALERT );

   RtlFreeUnicodeString(&unicodeDeviceName);

   return status;

} // OpenDevice

PUCHAR Controllers[] = {
   "PcmciaIntelCompatible",  
   "PcmciaCardBusCompatible",
   "PcmciaElcController",    
   "PcmciaDatabook",         
   "PcmciaPciPcmciaBridge",  
   "PcmciaCirrusLogic",         
   "PcmciaTI",           
   "PcmciaTopic",          
   "PcmciaRicoh",          
   "PcmciaDatabookCB",          
   "PcmciaOpti",       
   "PcmciaTrid",       
   "PcmciaO2Micro",          
   "PcmciaNEC",            
   "PcmciaNEC_98",            
};



VOID
DumpSocketInfo(
              HANDLE Handle,
              ULONG  Slot,
              PUCHAR Buffer,
              ULONG  BufferSize
              )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
   NTSTATUS              status;
   IO_STATUS_BLOCK       statusBlock;
   PCMCIA_SOCKET_INFORMATION commandBlock;
   ULONG                 index;
   ULONG                 ctlClass, ctlModel, ctlRev;

   memset(&commandBlock, 0, sizeof(commandBlock));
   commandBlock.Socket = (USHORT) Slot;

   status = NtDeviceIoControlFile(Handle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &statusBlock,
                                  IOCTL_SOCKET_INFORMATION,
                                  &commandBlock,
                                  sizeof(commandBlock),
                                  &commandBlock,
                                  sizeof(commandBlock));
   if (NT_SUCCESS(status)) {
      printf("Basic Information for Socket %d:\n", Slot);

      printf("   Manufacturer = %s\n", commandBlock.Manufacturer);
      printf("   Identifier   = %s\n", commandBlock.Identifier);
      printf("   TupleCRC     = %x\n", commandBlock.TupleCrc);
      printf("   DriverName   = %s\n", commandBlock.DriverName);
      printf("   Function ID = %d\n", commandBlock.DeviceFunctionId);

      ctlClass = PcmciaClassFromControllerType(commandBlock.ControllerType);
      if (ctlClass >= sizeof(Controllers)/sizeof(PUCHAR)) {
         printf("   ControllerType = Unknown (%x)\n", commandBlock.ControllerType);
      } else {
         printf("   ControllerType(%x) = %s", commandBlock.ControllerType,
                                              Controllers[ctlClass]);
         ctlModel = PcmciaModelFromControllerType(commandBlock.ControllerType);
         ctlRev   = PcmciaRevisionFromControllerType(commandBlock.ControllerType);

         if (ctlModel) {
            printf("%d", ctlModel);
         }
         if (ctlRev) {
            printf(", rev(%d)", ctlRev);
         }            
                  
         printf("\n");
      }
      if (commandBlock.CardInSocket) {
         printf("   Card In Socket\n");
      }
      if (commandBlock.CardEnabled) {
         printf("   Card Enabled\n");
      }
   }
}


NTSTATUS
ProcessCommands(IN ULONG DeviceNumber,
                IN ULONG slotNumberMin,
                IN ULONG slotNumberMax,
                IN ULONG Commands
                )
{
   NTSTATUS status;
   HANDLE   handle;
   PUCHAR   buffer;
   UCHAR    deviceName[128];
   ULONG    slotNumber;

   sprintf(deviceName, "%s%d", PCMCIA_DEVICE_NAME, DeviceNumber);
   status = OpenDevice(deviceName, &handle);

   if (!NT_SUCCESS(status)) {
      return status;
   }

   buffer = malloc(BUFFER_SIZE);
   if (!buffer) {
      printf("Unable to malloc\n");
      return STATUS_NO_MEMORY;
   }

   printf("\n** PC-Card information for PCMCIA controller %s **\n\n", deviceName);


   for (slotNumber = slotNumberMin; slotNumber <= slotNumberMax; slotNumber++) {

      if (Commands & CMD_DUMP_TUPLES) {
         DumpCIS(handle, slotNumber, buffer, BUFFER_SIZE);
      }
      if (!Commands || (Commands & CMD_DUMP_SOCKET_INFO)) {
         DumpSocketInfo(handle, slotNumber, buffer, BUFFER_SIZE); 
      }
   }

   NtClose(handle);
   return STATUS_SUCCESS;
}


int __cdecl
main(
    int   argc,
    char *argv[]
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/
{
   ULONG    deviceNumber = 0;
   ULONG    slotNumber = 0;
   NTSTATUS status;
   BOOLEAN  error = FALSE;
   CHAR    c;
   BOOLEAN  allControllers = TRUE, allSlots = TRUE, registers = FALSE, configuration = FALSE;
   ULONG    slotNumberMin, slotNumberMax;
   ULONG    Commands = 0;

   extern   PUCHAR optarg;

   while ((c = getopt(argc, argv, "d:s:crti?")) != EOF) {
      switch (c) {
      case 'd': {
            allControllers = FALSE;
            deviceNumber = atoi(optarg);
            break;
         }
      case 's': {
            allSlots = FALSE;
            slotNumber = atoi(optarg);
            break;
         }
      case 't': {
            Commands |= CMD_DUMP_TUPLES;
            break;
         }
      case 'i': {
            Commands |= CMD_DUMP_IRQ_SCAN_INFO;
            break;
         }
      case '?': {
            error = TRUE;
            break;
         }
      case 0: {
            error = TRUE;
            printf("Error in command line options\n");
            break;
         }
      default: {
            error = TRUE;
            break;
         }
      }
   }

   if (error) {
      printf("Usage: pcmcmd [-[d <arg>] [s <arg>][c][r][t]]\n");
      printf("Issues commands to the pc-card (PCMCIA) driver\n");
      printf("-d ControllerNumber         specifies PCMCIA controller number (zero-based)\n");
      printf("-s SocketNumber             specifies PCMCIA socket number (zero-based)\n");
      printf("-t                          Dumps the CIS tuples of the PC-Card\n");
      printf("-i                          Dumps irq detection info\n");
      return (1);
   }
   
   if (Commands & CMD_DUMP_IRQ_SCAN_INFO) {
      DumpIrqScanInfo();
      if (!(Commands & ~CMD_DUMP_IRQ_SCAN_INFO)) {
         return(0);
      }
   }
   
   if (allSlots) {
      //
      // Probe all slots
      //

      slotNumberMin = 0;
      slotNumberMax = 7;
   } else {
      //
      // Probe only the specified slot
      //

      slotNumberMin = slotNumberMax = slotNumber;
   }
   
   if (allControllers) {
   
      deviceNumber = 0;
      do {
         status = ProcessCommands(deviceNumber++, slotNumberMin, slotNumberMax, Commands);
      } while (NT_SUCCESS(status));
      deviceNumber--; // set back to last device processed
      
      if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
         printf("Failed for Pcmcia controller number %d: status 0x%x\n", deviceNumber, status);
      } else if (deviceNumber == 0) {
         printf("Error - no active Pcmcia controllers found\n");
      }
      
      
   } else {
   
      status = ProcessCommands(deviceNumber, slotNumberMin, slotNumberMax, Commands);
      if (!NT_SUCCESS(status)) {
         printf("Failed for Pcmcia controller number %d: status 0x%x\n", deviceNumber, status);
      }
      
   };

   return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\dll\compose.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    compose.c

Abstract:

    Counter composition functions

--*/

#include <windows.h>
#include <stdlib.h>
//#include <assert.h>
#include <pdh.h>
//#include "pdhitype.h"
#include "pdhidef.h"
//#include "pdhicalc.h"

double
WINAPI
PdhAverage(
    IN double *CounterArray,
    IN ULONG  nEntries
    )
{
    double sum = 0;
    if ((CounterArray == NULL) || (nEntries == 0))
        return PDH_INVALID_ARGUMENT;

    __try {
        ULONG  i;

        for (i=0; i<nEntries; i++) {
            if (CounterArray[i] > 0.0)
                sum += CounterArray[i];
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
    }
    return (sum / (double) nEntries);
}

double
WINAPI
PdhMax(
    IN double *CounterArray,
    IN ULONG  nEntries
    )
{
    double max = 0;
    if ((CounterArray == NULL) || (nEntries == 0))
        return PDH_INVALID_ARGUMENT;

    __try {
        ULONG  i;

        for (i=0; i<nEntries; i++) {
            if (max < CounterArray[i])
                max = CounterArray[i];
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
    }
    return (max);
}

double
WINAPI
PdhMin(
    IN double *CounterArray,
    IN ULONG  nEntries
    )
{
    double min = 0;
    if ((CounterArray == NULL) || (nEntries == 0))
        return PDH_INVALID_ARGUMENT;

    __try {
        ULONG  i;

        for (i=0; i<nEntries; i++) {
            if (min > CounterArray[i])
                min = CounterArray[i];
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
    }
    return (min);
}

double
WINAPI
PdhNormalizeCpu(
    IN double *CounterArray,
    IN ULONG  nEntries
    )
{
    double sum = 0;
    if ((CounterArray == NULL) || (nEntries == 0))
        return PDH_INVALID_ARGUMENT;

    __try {
        ULONG  i;

        for (i=0; i<nEntries; i++) {
            if (CounterArray[i] > 0.0)
                sum += CounterArray[i];     // need to get weight of array
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        SetLastError( GetExceptionCode() );
    }
    return (sum / (double) nEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\pdh.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PDH.H

Abstract:

    Header file for the Performance Data Helper (PDH) DLL functions.

--*/
#ifndef _PDH_H_
#define _PDH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201)

// system include files required for datatype and constant definitions
#include <windows.h>    // necessary for data types used in this file
#include <winperf.h>    // necessary for the Detail Level definitions

#ifdef __cplusplus
extern "C" {
#endif

typedef LONG            PDH_STATUS;

#define PDH_FUNCTION    PDH_STATUS __stdcall

// version info
#define PDH_CVERSION_WIN40  ((DWORD)(0x0400))
#define PDH_CVERSION_WIN50  ((DWORD)(0x0500))
// v1.1 revision of PDH -- basic log functions
// v1.2 of the PDH -- adds variable instance counters
// v1.3 of the PDH -- adds log service control & stubs for NT5/PDH v2 fn's
// v2.0 of the PDH -- is the NT v 5.0 B2 version
#define PDH_VERSION         ((DWORD)((PDH_CVERSION_WIN50) + 0x0003))

// define severity masks
#define IsSuccessSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x00000000L) ? TRUE : FALSE)
#define IsInformationalSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x40000000L) ? TRUE : FALSE)
#define IsWarningSeverity(ErrorCode)    \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0x80000000L) ? TRUE : FALSE)
#define IsErrorSeverity(ErrorCode)      \
    ((((DWORD)(ErrorCode) & (0xC0000000L)) == 0xC0000000L) ? TRUE : FALSE)

#define MAX_COUNTER_PATH    256         // Maximum counter path length

// data type definitions

typedef HANDLE       PDH_HCOUNTER;
typedef HANDLE       PDH_HQUERY;
typedef HANDLE       PDH_HLOG;

typedef PDH_HCOUNTER HCOUNTER;
typedef PDH_HQUERY   HQUERY;
#ifndef _LMHLOGDEFINED_
typedef PDH_HLOG     HLOG;
#endif

#ifdef INVALID_HANDLE_VALUE
#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE  ((HANDLE)((LONG_PTR)-1))
#endif

#define H_REALTIME_DATASOURCE NULL
#define H_WBEM_DATASOURCE     INVALID_HANDLE_VALUE


typedef struct _PDH_RAW_COUNTER {
    DWORD       CStatus;
    FILETIME    TimeStamp;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
    DWORD       MultiCount;
} PDH_RAW_COUNTER, *PPDH_RAW_COUNTER;

typedef struct _PDH_RAW_COUNTER_ITEM_A {
    LPSTR           szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_A, *PPDH_RAW_COUNTER_ITEM_A;

typedef struct _PDH_RAW_COUNTER_ITEM_W {
    LPWSTR          szName;
    PDH_RAW_COUNTER RawValue;
} PDH_RAW_COUNTER_ITEM_W, *PPDH_RAW_COUNTER_ITEM_W;

typedef struct _PDH_FMT_COUNTERVALUE {
    DWORD    CStatus;
    union {
        LONG        longValue;
        double      doubleValue;
        LONGLONG    largeValue;
        LPCSTR      AnsiStringValue;
        LPCWSTR     WideStringValue;
    };
} PDH_FMT_COUNTERVALUE, *PPDH_FMT_COUNTERVALUE;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_A {
    LPSTR                   szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_A, *PPDH_FMT_COUNTERVALUE_ITEM_A;

typedef struct _PDH_FMT_COUNTERVALUE_ITEM_W {
    LPWSTR                  szName;
    PDH_FMT_COUNTERVALUE    FmtValue;
} PDH_FMT_COUNTERVALUE_ITEM_W, *PPDH_FMT_COUNTERVALUE_ITEM_W;

typedef struct _PDH_STATISTICS {
    DWORD                   dwFormat;
    DWORD                   count;
    PDH_FMT_COUNTERVALUE    min;
    PDH_FMT_COUNTERVALUE    max;
    PDH_FMT_COUNTERVALUE    mean;
} PDH_STATISTICS, *PPDH_STATISTICS;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    LPSTR   szObjectName;
    LPSTR   szInstanceName;
    LPSTR   szParentInstance;
    DWORD   dwInstanceIndex;
    LPSTR   szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_A, *PPDH_COUNTER_PATH_ELEMENTS_A;

typedef struct _PDH_COUNTER_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    LPWSTR  szObjectName;
    LPWSTR  szInstanceName;
    LPWSTR  szParentInstance;
    DWORD   dwInstanceIndex;
    LPWSTR  szCounterName;
} PDH_COUNTER_PATH_ELEMENTS_W, *PPDH_COUNTER_PATH_ELEMENTS_W;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_A {
    LPSTR   szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPSTR   szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_A, * PPDH_DATA_ITEM_PATH_ELEMENTS_A;

typedef struct _PDH_DATA_ITEM_PATH_ELEMENTS_W {
    LPWSTR  szMachineName;
    GUID    ObjectGUID;
    DWORD   dwItemId;
    LPWSTR  szInstanceName;
} PDH_DATA_ITEM_PATH_ELEMENTS_W, * PPDH_DATA_ITEM_PATH_ELEMENTS_W;

typedef struct _PDH_COUNTER_INFO_A {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPSTR   szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_A DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_A CounterPath;
        struct {
            LPSTR   szMachineName;
            LPSTR   szObjectName;
            LPSTR   szInstanceName;
            LPSTR   szParentInstance;
            DWORD   dwInstanceIndex;
            LPSTR   szCounterName;
        };
    };
    LPSTR   szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_A, *PPDH_COUNTER_INFO_A;

typedef struct _PDH_COUNTER_INFO_W {
    DWORD   dwLength;
    DWORD   dwType;
    DWORD   CVersion;
    DWORD   CStatus;
    LONG    lScale;
    LONG    lDefaultScale;
    DWORD_PTR   dwUserData;
    DWORD_PTR   dwQueryUserData;
    LPWSTR  szFullPath;
    union   {
        PDH_DATA_ITEM_PATH_ELEMENTS_W DataItemPath;
        PDH_COUNTER_PATH_ELEMENTS_W CounterPath;
        struct {
            LPWSTR   szMachineName;
            LPWSTR   szObjectName;
            LPWSTR   szInstanceName;
            LPWSTR   szParentInstance;
            DWORD    dwInstanceIndex;
            LPWSTR   szCounterName;
        };
    };
    LPWSTR  szExplainText;
    DWORD   DataBuffer[1];
} PDH_COUNTER_INFO_W, *PPDH_COUNTER_INFO_W;

typedef struct _PDH_TIME_INFO {
    LONGLONG    StartTime;
    LONGLONG    EndTime;
    DWORD       SampleCount;
} PDH_TIME_INFO, *PPDH_TIME_INFO;

typedef struct _PDH_RAW_LOG_RECORD {
    DWORD       dwStructureSize;
    DWORD       dwRecordType;
    DWORD       dwItems;
    UCHAR       RawBytes[1];
} PDH_RAW_LOG_RECORD, *PPDH_RAW_LOG_RECORD;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_A {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPSTR   szLogFileCaption;
    LPSTR   szDefaultDir;
    LPSTR   szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPSTR   PdlCommandFilename;
            LPSTR   PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPSTR   TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_A, *PPDH_LOG_SERVICE_QUERY_INFO_A;

typedef struct _PDH_LOG_SERVICE_QUERY_INFO_W {
    DWORD   dwSize;
    DWORD   dwFlags;
    DWORD   dwLogQuota;
    LPWSTR  szLogFileCaption;
    LPWSTR  szDefaultDir;
    LPWSTR  szBaseFileName;
    DWORD   dwFileType;
    DWORD   dwReserved;
    union {
        struct {
            DWORD   PdlAutoNameInterval;
            DWORD   PdlAutoNameUnits;
            LPWSTR  PdlCommandFilename;
            LPWSTR  PdlCounterList;
            DWORD   PdlAutoNameFormat;
            DWORD   PdlSampleInterval;
            FILETIME    PdlLogStartTime;
            FILETIME    PdlLogEndTime;
        };
        struct {
            DWORD   TlNumberOfBuffers;
            DWORD   TlMinimumBuffers;
            DWORD   TlMaximumBuffers;
            DWORD   TlFreeBuffers;
            DWORD   TlBufferSize;
            DWORD   TlEventsLost;
            DWORD   TlLoggerThreadId;
            DWORD   TlBuffersWritten;
            DWORD   TlLogHandle;
            LPWSTR  TlLogFileName;
        };
    };
} PDH_LOG_SERVICE_QUERY_INFO_W, *PPDH_LOG_SERVICE_QUERY_INFO_W;

//
//  Time value constants
//
#define MAX_TIME_VALUE      ((LONGLONG)0x7FFFFFFFFFFFFFFF)
#define MIN_TIME_VALUE      ((LONGLONG)0)

// function definitions

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
);

//
//  Query Functions
//

PDH_FUNCTION
PdhOpenQueryW (
    IN      LPCWSTR      szDataSource,
    IN      DWORD_PTR    dwUserData,
    IN      PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhOpenQueryA (
    IN      LPCSTR       szDataSource,
    IN      DWORD_PTR    dwUserData,
    IN      PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhAddCounterW (
    IN      PDH_HQUERY     hQuery,
    IN      LPCWSTR        szFullCounterPath,
    IN      DWORD_PTR      dwUserData,
    IN      PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhAddCounterA (
    IN      PDH_HQUERY     hQuery,
    IN      LPCSTR         szFullCounterPath,
    IN      DWORD_PTR      dwUserData,
    IN      PDH_HCOUNTER * phCounter
);

PDH_FUNCTION
PdhRemoveCounter (
    IN      PDH_HCOUNTER    hCounter
);

PDH_FUNCTION
PdhCollectQueryData (
    IN      PDH_HQUERY      hQuery
);

PDH_FUNCTION
PdhCloseQuery (
    IN      PDH_HQUERY      hQuery
);

//
//  Counter Functions
//

PDH_FUNCTION
PdhGetFormattedCounterValue (
    IN      PDH_HCOUNTER            hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwType,
    IN      PPDH_FMT_COUNTERVALUE   pValue
);

PDH_FUNCTION
PdhGetFormattedCounterArrayA (
    IN      PDH_HCOUNTER                 hCounter,
    IN      DWORD                        dwFormat,
    IN      LPDWORD                      lpdwBufferSize,
    IN      LPDWORD                      lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetFormattedCounterArrayW (
    IN      PDH_HCOUNTER                 hCounter,
    IN      DWORD                        dwFormat,
    IN      LPDWORD                      lpdwBufferSize,
    IN      LPDWORD                      lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_W ItemBuffer
);


// dwFormat flag values
//
#define PDH_FMT_RAW     ((DWORD)0x00000010)
#define PDH_FMT_ANSI    ((DWORD)0x00000020)
#define PDH_FMT_UNICODE ((DWORD)0x00000040)
#define PDH_FMT_LONG    ((DWORD)0x00000100)
#define PDH_FMT_DOUBLE  ((DWORD)0x00000200)
#define PDH_FMT_LARGE   ((DWORD)0x00000400)
#define PDH_FMT_NOSCALE ((DWORD)0x00001000)
#define PDH_FMT_1000    ((DWORD)0x00002000)
#define PDH_FMT_NODATA  ((DWORD)0x00004000)
#define PDH_FMT_NOCAP100 ((DWORD)0x00008000)

#define PERF_DETAIL_COSTLY   ((DWORD)0x00010000)
#define PERF_DETAIL_STANDARD ((DWORD)0x0000FFFF)

PDH_FUNCTION
PdhGetRawCounterValue (
    IN      PDH_HCOUNTER      hCounter,
    IN      LPDWORD           lpdwType,
    IN      PPDH_RAW_COUNTER  pValue
);

PDH_FUNCTION
PdhGetRawCounterArrayA (
    IN      PDH_HCOUNTER            hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_A ItemBuffer
);

PDH_FUNCTION
PdhGetRawCounterArrayW (
    IN      PDH_HCOUNTER            hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_W ItemBuffer
);

PDH_FUNCTION
PdhCalculateCounterFromRawValue (
    IN      PDH_HCOUNTER            hCounter,
    IN      DWORD                   dwFormat,
    IN      PPDH_RAW_COUNTER        rawValue1,
    IN      PPDH_RAW_COUNTER        rawValue2,
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
);

PDH_FUNCTION
PdhComputeCounterStatistics (
    IN      PDH_HCOUNTER        hCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
);

PDH_FUNCTION
PdhGetCounterInfoW (
    IN      PDH_HCOUNTER        hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W lpBuffer
);

PDH_FUNCTION
PdhGetCounterInfoA (
    IN      PDH_HCOUNTER        hCounter,
    IN      BOOLEAN             bRetrieveExplainText,
    IN      LPDWORD             pdwBufferSize,
    IN      PPDH_COUNTER_INFO_A lpBuffer
);

#define PDH_MAX_SCALE    (7L)
#define PDH_MIN_SCALE   (-7L)

PDH_FUNCTION
PdhSetCounterScaleFactor (
    IN      PDH_HCOUNTER  hCounter,
    IN      LONG          lFactor
);
//
//   Browsing and enumeration functions
//
PDH_FUNCTION
PdhConnectMachineW (
    IN      LPCWSTR  szMachineName
);

PDH_FUNCTION
PdhConnectMachineA (
    IN      LPCSTR  szMachineName
);

PDH_FUNCTION
PdhEnumMachinesW (
    IN      LPCWSTR szDataSource,
    IN      LPWSTR  mszMachineList,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesA (
    IN      LPCSTR   szDataSource,
    IN      LPSTR    mszMachineList,
    IN      LPDWORD  pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   mszObjectList,
    IN      LPDWORD pcchBufferSize,
    IN      DWORD   dwDetailLevel,
    IN      BOOL    bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPWSTR  mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   mszCounterList,
    IN      LPDWORD pcchCounterListLength,
    IN      LPSTR   mszInstanceList,
    IN      LPDWORD pcchInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags
);

#define PDH_OBJECT_HAS_INSTANCES    ((DWORD) 0x00000001)

PDH_FUNCTION
PdhMakeCounterPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhMakeCounterPathA (
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPSTR                       szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhParseCounterPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pdwBufferSize,
    IN      DWORD                       dwFlags
);

#define PDH_PATH_WBEM_RESULT        ((DWORD)0x00000001)
#define PDH_PATH_WBEM_INPUT         ((DWORD)0x00000002)

#define PDH_PATH_LANG_FLAGS(LangId, Flags)  ((DWORD)(((LangId & 0x0000FFFF) << 16) | (Flags & 0x0000FFFF)))

PDH_FUNCTION
PdhParseInstanceNameW (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPWSTR  szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhParseInstanceNameA (
    IN      LPCSTR  szInstanceString,
    IN      LPSTR   szInstanceName,
    IN      LPDWORD pcchInstanceNameLength,
    IN      LPSTR   szParentName,
    IN      LPDWORD pcchParentNameLength,
    IN      LPDWORD lpIndex
);

PDH_FUNCTION
PdhValidatePathW (
    IN      LPCWSTR szFullPathBuffer
);

PDH_FUNCTION
PdhValidatePathA (
    IN      LPCSTR  szFullPathBuffer
);

PDH_FUNCTION
PdhGetDefaultPerfObjectW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPWSTR  szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPSTR   szDefaultObjectName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterW (
    IN      LPCWSTR szDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPWSTR  szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szMachineName,
    IN      LPCSTR  szObjectName,
    IN      LPSTR   szDefaultCounterName,
    IN      LPDWORD pcchBufferSize
);

typedef PDH_STATUS (__stdcall *CounterPathCallBack)(DWORD_PTR);

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4214 )  // Disable warning messages
typedef struct _BrowseDlgConfig_HW {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HW, *PPDH_BROWSE_DLG_CONFIG_HW;

typedef struct _BrowseDlgConfig_HA {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    PDH_HLOG            hDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_HA, *PPDH_BROWSE_DLG_CONFIG_HA;

typedef struct _BrowseDlgConfig_W {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPWSTR              szDataSource;
    LPWSTR              szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPWSTR              szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_W, *PPDH_BROWSE_DLG_CONFIG_W;

typedef struct _BrowseDlgConfig_A {
    // Configuration flags
    DWORD   bIncludeInstanceIndex:1,
            bSingleCounterPerAdd:1,
            bSingleCounterPerDialog:1,
            bLocalCountersOnly:1,
            bWildCardInstances:1,
            bHideDetailBox:1,
            bInitializePath:1,
            bDisableMachineSelection:1,
            bIncludeCostlyObjects:1,
            bShowObjectBrowser:1,
            bReserved:22;

    HWND                hWndOwner;
    LPSTR               szDataSource;
    LPSTR               szReturnPathBuffer;
    DWORD               cchReturnPathLength;
    CounterPathCallBack pCallBack;
    DWORD_PTR           dwCallBackArg;
    PDH_STATUS          CallBackStatus;
    DWORD               dwDefaultDetailLevel;
    LPSTR               szDialogBoxCaption;
} PDH_BROWSE_DLG_CONFIG_A, *PPDH_BROWSE_DLG_CONFIG_A;
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4214 )
#endif

PDH_FUNCTION
PdhBrowseCountersW (
    IN      PPDH_BROWSE_DLG_CONFIG_W    pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersA (
    IN      PPDH_BROWSE_DLG_CONFIG_A    pBrowseDlgData
);

PDH_FUNCTION
PdhExpandCounterPathW (
    IN      LPCWSTR     szWildCardPath,
    IN      LPWSTR      mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

PDH_FUNCTION
PdhExpandCounterPathA (
    IN      LPCSTR      szWildCardPath,
    IN      LPSTR       mszExpandedPathList,
    IN      LPDWORD     pcchPathListLength
);

//
//  v2.0 functions
//
PDH_FUNCTION
PdhLookupPerfNameByIndexW (
    LPCWSTR szMachineName,
    DWORD   dwNameIndex,
    LPWSTR  szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfNameByIndexA (
    LPCSTR  szMachineName,
    DWORD   dwNameIndex,
    LPSTR   szNameBuffer,
    LPDWORD pcchNameBufferSize
);

PDH_FUNCTION
PdhLookupPerfIndexByNameW (
    LPCWSTR szMachineName,
    LPCWSTR szNameBuffer,
    LPDWORD pdwIndex
);

PDH_FUNCTION
PdhLookupPerfIndexByNameA (
    LPCSTR  szMachineName,
    LPCSTR  szNameBuffer,
    LPDWORD pdwIndex
);

#define     PDH_NOEXPANDCOUNTERS    1
#define     PDH_NOEXPANDINSTANCES   2

PDH_FUNCTION
PdhExpandWildCardPathA (
    IN      LPCSTR  szDataSource,
    IN      LPCSTR  szWildCardPath,
    IN      LPSTR   mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathW (
    IN      LPCWSTR  szDataSource,
    IN      LPCWSTR  szWildCardPath,
    IN      LPWSTR  mszExpandedPathList,
    IN      LPDWORD pcchPathListLength,
    IN      DWORD   dwFlags
);

//
//   Logging Functions
//

#define PDH_LOG_READ_ACCESS     ((DWORD)0x00010000)
#define PDH_LOG_WRITE_ACCESS    ((DWORD)0x00020000)
#define PDH_LOG_UPDATE_ACCESS   ((DWORD)0x00040000)
#define PDH_LOG_ACCESS_MASK     ((DWORD)0x000F0000)

#define PDH_LOG_CREATE_NEW      ((DWORD)0x00000001)
#define PDH_LOG_CREATE_ALWAYS   ((DWORD)0x00000002)
#define PDH_LOG_OPEN_ALWAYS     ((DWORD)0x00000003)
#define PDH_LOG_OPEN_EXISTING   ((DWORD)0x00000004)
#define PDH_LOG_CREATE_MASK     ((DWORD)0x0000000F)

#define PDH_LOG_OPT_USER_STRING  ((DWORD)0x01000000)
#define PDH_LOG_OPT_CIRCULAR     ((DWORD)0x02000000)
#define PDH_LOG_OPT_MAX_IS_BYTES ((DWORD)0x04000000)
#define PDH_LOG_OPT_APPEND       ((DWORD)0x08000000)
#define PDH_LOG_OPT_MASK         ((DWORD)0x0F000000)

#define PDH_LOG_TYPE_UNDEFINED      0
#define PDH_LOG_TYPE_CSV            1
#define PDH_LOG_TYPE_TSV            2
//#define PDH_LOG_TYPE_BINARY         3 // this is the retired binary format
#define PDH_LOG_TYPE_TRACE_KERNEL   4
#define PDH_LOG_TYPE_TRACE_GENERIC  5
#define PDH_LOG_TYPE_PERFMON        6
#define PDH_LOG_TYPE_SQL            7
#define PDH_LOG_TYPE_BINARY         8

PDH_FUNCTION
PdhOpenLogW (
    IN      LPCWSTR     szLogFileName,
    IN      DWORD       dwAccessFlags,
    IN      LPDWORD     lpdwLogType,
    IN      PDH_HQUERY  hQuery,
    IN      DWORD       dwMaxSize,
    IN      LPCWSTR     szUserCaption,
    IN      PDH_HLOG  * phLog
);

PDH_FUNCTION
PdhOpenLogA (
    IN      LPCSTR       szLogFileName,
    IN      DWORD        dwAccessFlags,
    IN      LPDWORD      lpdwLogType,
    IN      PDH_HQUERY   hQuery,
    IN      DWORD        dwMaxSize,
    IN      LPCSTR       szUserCaption,
    IN      PDH_HLOG   * phLog
);

PDH_FUNCTION
PdhUpdateLogW (
    IN      PDH_HLOG hLog,
    IN      LPCWSTR  szUserString
);

PDH_FUNCTION
PdhUpdateLogA (
    IN      PDH_HLOG hLog,
    IN      LPCSTR   szUserString
);

PDH_FUNCTION
PdhUpdateLogFileCatalog (
    IN      PDH_HLOG    hLog
);

PDH_FUNCTION
PdhGetLogFileSize (
    IN  PDH_HLOG     hLog,
    IN  LONGLONG   * llSize
);

PDH_FUNCTION
PdhCloseLog(
    IN  PDH_HLOG    hLog,
    IN  DWORD       dwFlags
);

#define PDH_FLAGS_CLOSE_QUERY   ((DWORD)0x00000001)
//
//  Data source selection dialog
//
#define PDH_FLAGS_FILE_BROWSER_ONLY ((DWORD)0x00000001)

PDH_FUNCTION
PdhSelectDataSourceW (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPWSTR  szDataSource,
    IN  LPDWORD pcchBufferLength
);

PDH_FUNCTION
PdhSelectDataSourceA (
    IN  HWND    hWndOwner,
    IN  DWORD   dwFlags,
    IN  LPSTR   szDataSource,
    IN  LPDWORD pcchBufferLength
);

BOOL
PdhIsRealTimeQuery (
    IN  PDH_HQUERY  hQuery
);

PDH_FUNCTION
PdhSetQueryTimeRange (
    IN      PDH_HQUERY      hQuery,
    IN      PPDH_TIME_INFO  pInfo
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeW (
    IN      LPCWSTR         szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeA (
    IN      LPCSTR          szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         dwBufferSize
);

PDH_FUNCTION
PdhCollectQueryDataEx (
    IN      PDH_HQUERY  hQuery,
    IN      DWORD       dwIntervalTime,
    IN      HANDLE      hNewDataEvent
);

PDH_FUNCTION
PdhFormatFromRawValue (
    IN      DWORD               dwCounterType,
    IN      DWORD               dwFormat,
    IN      LONGLONG            *pTimeBase,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PPDH_FMT_COUNTERVALUE   pFmtValue
);

PDH_FUNCTION
PdhGetCounterTimeBase (
    IN  PDH_HCOUNTER   hCounter,
    IN  LONGLONG     * pTimeBase
);

PDH_FUNCTION
PdhReadRawLogRecord (
    IN  PDH_HLOG                hLog,
    IN  FILETIME                ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pRawLogRecord,
    IN  LPDWORD                 pdwBufferLength
);


#define DATA_SOURCE_REGISTRY    ((DWORD)0x00000001)
#define DATA_SOURCE_LOGFILE     ((DWORD)0x00000002)
#define DATA_SOURCE_WBEM        ((DWORD)0x00000004)

PDH_FUNCTION
PdhSetDefaultRealTimeDataSource (
    IN  DWORD   dwDataSourceId
);

// flags for the log service api's
#define PDH_LOGSVC_NO_WAIT          ((DWORD)0x80000000)
#define PDH_LOGSVC_ALL_QUERIES      ((DWORD)0x00000001)
#define PDH_LOGSVC_TRACE_LOG        ((DWORD)0x00000002)

#define PDH_LOGSVC_CMD_START        ((DWORD)0x00000010)
#define PDH_LOGSVC_CMD_STOP         ((DWORD)0x00000020)

#define PDH_LOGSVC_CTRL_ADD         ((DWORD)0x00000100)
#define PDH_LOGSVC_CTRL_REMOVE      ((DWORD)0x00000200)
#define PDH_LOGSVC_CTRL_INFO        ((DWORD)0x00000400)

#define PDH_LOGSVC_STATUS_RUNNING   ((DWORD)0x00001000)
#define PDH_LOGSVC_STATUS_STOPPED   ((DWORD)0x00002000)
#define PDH_LOGSVC_STATUS_PAUSED    ((DWORD)0x00004000)
#define PDH_LOGSVC_STATUS_ERROR     ((DWORD)0x00008000)
#define PDH_LOGSVC_STATUS_PENDING   ((DWORD)0x00010000)

#define PDH_LOGSVC_NAME_UNDEFINED  ((DWORD)-1)
#define PDH_LOGSVC_NAME_MMDDHH     ((DWORD)0)
#define PDH_LOGSVC_NAME_NNNNNN     ((DWORD)1)
#define PDH_LOGSVC_NAME_YYDDD      ((DWORD)2)
#define PDH_LOGSVC_NAME_YYMM       ((DWORD)3)
#define PDH_LOGSVC_NAME_YYMMDD     ((DWORD)4)
#define PDH_LOGSVC_NAME_YYMMDDHH   ((DWORD)5)

#define PDH_LOGSVC_RENAME_UNDEFINED ((DWORD)-1)
#define PDH_LOGSVC_RENAME_HOURS    ((DWORD)0)
#define PDH_LOGSVC_RENAME_DAYS     ((DWORD)1)
#define PDH_LOGSVC_RENAME_MONTHS   ((DWORD)2)
#define PDH_LOGSVC_RENAME_KBYTES   ((DWORD)3)
#define PDH_LOGSVC_RENAME_MBYTES   ((DWORD)4)

PDH_FUNCTION
PdhLogServiceCommandA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceCommandW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  LPDWORD         pdwStatus
);

PDH_FUNCTION
PdhLogServiceControlA (
    IN  LPCSTR          szMachineName,
    IN  LPCSTR          szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_A pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhLogServiceControlW (
    IN  LPCWSTR         szMachineName,
    IN  LPCWSTR         szQueryName,
    IN  DWORD           dwFlags,
    IN  PPDH_LOG_SERVICE_QUERY_INFO_W pInfoBuffer,
    IN  LPDWORD         pdwBufferSize
);

// Extended API for WMI event trace logfile format
//
PDH_FUNCTION
PdhBindInputDataSourceW (
    IN PDH_HLOG    * phDataSource,
    IN LPCWSTR       LogFileNameList
);

PDH_FUNCTION
PdhBindInputDataSourceA (
    IN PDH_HLOG   * phDataSource,
    IN LPCSTR       LogFileNameList
);

PDH_FUNCTION
PdhOpenQueryH (
    IN PDH_HLOG     hDataSource,
    IN DWORD_PTR    dwUserData,
    IN PDH_HQUERY * phQuery
);

PDH_FUNCTION
PdhEnumMachinesHW (
    IN PDH_HLOG    hDataSource,
    IN LPWSTR      mszMachineList,
    IN LPDWORD     pcchBufferSize
);

PDH_FUNCTION
PdhEnumMachinesHA (
    IN PDH_HLOG    hDataSource,
    IN LPSTR       mszMachineList,
    IN LPDWORD     pcchBufferSize
);

PDH_FUNCTION
PdhEnumObjectsHW (
    IN PDH_HLOG    hDataSource,
    IN LPCWSTR     szMachineName,
    IN LPWSTR      mszObjectList,
    IN LPDWORD     pcchBufferSize,
    IN DWORD       dwDetailLevel,
    IN BOOL        bRefresh
);

PDH_FUNCTION
PdhEnumObjectsHA (
    IN PDH_HLOG    hDataSource,
    IN LPCSTR      szMachineName,
    IN LPSTR       mszObjectList,
    IN LPDWORD     pcchBufferSize,
    IN DWORD       dwDetailLevel,
    IN BOOL        bRefresh
);

PDH_FUNCTION
PdhEnumObjectItemsHW (
    IN PDH_HLOG    hDataSource,
    IN LPCWSTR     szMachineName,
    IN LPCWSTR     szObjectName,
    IN LPWSTR      mszCounterList,
    IN LPDWORD     pcchCounterListLength,
    IN LPWSTR      mszInstanceList,
    IN LPDWORD     pcchInstanceListLength,
    IN DWORD       dwDetailLevel,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhEnumObjectItemsHA (
    IN PDH_HLOG    hDataSource,
    IN LPCSTR      szMachineName,
    IN LPCSTR      szObjectName,
    IN LPSTR       mszCounterList,
    IN LPDWORD     pcchCounterListLength,
    IN LPSTR       mszInstanceList,
    IN LPDWORD     pcchInstanceListLength,
    IN DWORD       dwDetailLevel,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHW (
    IN PDH_HLOG    hDataSource,
    IN LPCWSTR     szWildCardPath,
    IN LPWSTR      mszExpandedPathList,
    IN LPDWORD     pcchPathListLength,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhExpandWildCardPathHA (
    IN PDH_HLOG    hDataSource,
    IN LPCSTR      szWildCardPath,
    IN LPSTR       mszExpandedPathList,
    IN LPDWORD     pcchPathListLength,
    IN DWORD       dwFlags
);

PDH_FUNCTION
PdhGetDataSourceTimeRangeH (
    IN PDH_HLOG        hDataSource,
    IN LPDWORD         pdwNumEntries,
    IN PPDH_TIME_INFO  pInfo,
    IN LPDWORD         pdwBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHW (
    IN PDH_HLOG  hDataSource,
    IN LPCWSTR   szMachineName,
    IN LPWSTR    szDefaultObjectName,
    IN LPDWORD   pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfObjectHA (
    IN PDH_HLOG    hDataSource,
    IN LPCSTR      szMachineName,
    IN LPSTR       szDefaultObjectName,
    IN LPDWORD     pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHW (
    IN PDH_HLOG    hDataSource,
    IN LPCWSTR     szMachineName,
    IN LPCWSTR     szObjectName,
    IN LPWSTR      szDefaultCounterName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhGetDefaultPerfCounterHA (
    IN PDH_HLOG    hDataSource,
    IN LPCSTR      szMachineName,
    IN LPCSTR      szObjectName,
    IN LPSTR       szDefaultCounterName,
    IN LPDWORD pcchBufferSize
);

PDH_FUNCTION
PdhBrowseCountersHW (
    IN PPDH_BROWSE_DLG_CONFIG_HW pBrowseDlgData
);

PDH_FUNCTION
PdhBrowseCountersHA (
    IN PPDH_BROWSE_DLG_CONFIG_HA pBrowseDlgData
);

//Check that a DSN points to a database that contains the correct Perfmon tables.
PDH_FUNCTION
PdhVerifySQLDBW (
	IN	LPCWSTR			szDataSource
);

PDH_FUNCTION
PdhVerifySQLDBA (
	IN	LPCSTR			szDataSource
);


//Create the correct perfmon tables in the database pointed to by a DSN.
PDH_FUNCTION
PdhCreateSQLTablesW (
	IN	LPCWSTR			szDataSource
);  

PDH_FUNCTION
PdhCreateSQLTablesA (
	IN	LPCSTR			szDataSource
);     

//Return the list of Log set names in the database pointed to by the DSN.
PDH_FUNCTION
PdhEnumLogSetNamesW (
	IN	LPCWSTR			szDataSource,
	IN	LPWSTR			mszDataSetNameList,
	IN	LPDWORD			pcchBufferLength
);

PDH_FUNCTION
PdhEnumLogSetNamesA (
	IN	LPCSTR			szDataSource,
	IN	LPSTR			mszDataSetNameList,
	IN	LPDWORD			pcchBufferLength
);

//Retrieve the GUID for an open Log Set
PDH_FUNCTION
PdhGetLogSetGUID (
	IN	PDH_HLOG    hLog,             
	IN	GUID      * pGuid,
	IN	int       * pRunId
);

//Set the RunID for an open Log Set
PDH_FUNCTION
PdhSetLogSetRunID (
	IN	PDH_HLOG    hLog,             
	IN	int         RunId
);

//
//   Unicode/ANSI compatibility section
//
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif

#ifdef UNICODE
// start of UNICODE definitions
#define PdhOpenQuery                PdhOpenQueryW
#define PdhAddCounter               PdhAddCounterW
#define PdhGetCounterInfo           PdhGetCounterInfoW
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_W
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_W
#define PdhConnectMachine           PdhConnectMachineW
#define PdhEnumMachines             PdhEnumMachinesW
#define PdhEnumObjects              PdhEnumObjectsW
#define PdhEnumObjectItems          PdhEnumObjectItemsW
#define PdhMakeCounterPath          PdhMakeCounterPathW
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_W
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_W
#define PdhParseCounterPath         PdhParseCounterPathW
#define PdhParseInstanceName        PdhParseInstanceNameW
#define PdhValidatePath             PdhValidatePathW
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectW
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterW
#define PdhBrowseCounters           PdhBrowseCountersW
#define PdhBrowseCountersH          PdhBrowseCountersHW
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_W
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_W
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HW
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HW
#define PdhExpandCounterPath        PdhExpandCounterPathW
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_W
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_W
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_W
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_W
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayW
#define PdhGetRawCounterArray       PdhGetRawCounterArrayW
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexW
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameW
#define PdhOpenLog                  PdhOpenLogW
#define PdhUpdateLog                PdhUpdateLogW
#define PdhSelectDataSource         PdhSelectDataSourceW
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeW
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_W
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_W
#define PdhLogServiceControl        PdhLogServiceControlW
#define PdhLogServiceQuery          PdhLogServiceQueryW
#define PdhExpandWildCardPath       PdhExpandWildCardPathW
#define PdhBindInputDataSource      PdhBindInputDataSourceW
#define PdhEnumMachinesH            PdhEnumMachinesHW
#define PdhEnumObjectsH             PdhEnumObjectsHW
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHW
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHW
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHW
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHW
#define PdhEnumLogSetNames	    PdhEnumLogSetNamesW
#define PdhCreateSQLTables	    PdhCreateSQLTablesW
#define	PdhVerifySQLDB		    PdhVerifySQLDBW

// end of UNICODE definitions
#else
// start of ANSI definitions
#define PdhOpenQuery                PdhOpenQueryA
#define PdhAddCounter               PdhAddCounterA
#define PdhGetCounterInfo           PdhGetCounterInfoA
#define PDH_COUNTER_INFO            PDH_COUNTER_INFO_A
#define PPDH_COUNTER_INFO           PPDH_COUNTER_INFO_A
#define PdhConnectMachine           PdhConnectMachineA
#define PdhEnumMachines             PdhEnumMachinesA
#define PdhEnumObjects              PdhEnumObjectsA
#define PdhEnumObjectItems          PdhEnumObjectItemsA
#define PdhMakeCounterPath          PdhMakeCounterPathA
#define PDH_COUNTER_PATH_ELEMENTS   PDH_COUNTER_PATH_ELEMENTS_A
#define PPDH_COUNTER_PATH_ELEMENTS  PPDH_COUNTER_PATH_ELEMENTS_A
#define PdhParseCounterPath         PdhParseCounterPathA
#define PdhParseInstanceName        PdhParseInstanceNameA
#define PdhValidatePath             PdhValidatePathA
#define PdhGetDefaultPerfObject     PdhGetDefaultPerfObjectA
#define PdhGetDefaultPerfCounter    PdhGetDefaultPerfCounterA
#define PdhBrowseCounters           PdhBrowseCountersA
#define PdhBrowseCountersH          PdhBrowseCountersHA
#define PDH_BROWSE_DLG_CONFIG       PDH_BROWSE_DLG_CONFIG_A
#define PPDH_BROWSE_DLG_CONFIG      PPDH_BROWSE_DLG_CONFIG_A
#define PDH_BROWSE_DLG_CONFIG_H     PDH_BROWSE_DLG_CONFIG_HA
#define PPDH_BROWSE_DLG_CONFIG_H    PPDH_BROWSE_DLG_CONFIG_HA
#define PdhExpandCounterPath        PdhExpandCounterPathA
// v2.0 functions
#define PDH_FMT_COUNTERVALUE_ITEM   PDH_FMT_COUNTERVALUE_ITEM_A
#define PPDH_FMT_COUNTERVALUE_ITEM  PPDH_FMT_COUNTERVALUE_ITEM_A
#define PDH_RAW_COUNTER_ITEM        PDH_RAW_COUNTER_ITEM_A
#define PPDH_RAW_COUNTER_ITEM       PPDH_RAW_COUNTER_ITEM_A
#define PdhGetFormattedCounterArray PdhGetFormattedCounterArrayA
#define PdhGetRawCounterArray       PdhGetRawCounterArrayA
#define PdhLookupPerfNameByIndex    PdhLookupPerfNameByIndexA
#define PdhLookupPerfIndexByName    PdhLookupPerfIndexByNameA
#define PdhOpenLog                  PdhOpenLogA
#define PdhUpdateLog                PdhUpdateLogA
#define PdhSelectDataSource         PdhSelectDataSourceA
#define PdhGetDataSourceTimeRange   PdhGetDataSourceTimeRangeA
#define PDH_LOG_SERVICE_QUERY_INFO  PDH_LOG_SERVICE_QUERY_INFO_A
#define PPDH_LOG_SERVICE_QUERY_INFO PPDH_LOG_SERVICE_QUERY_INFO_A
#define PdhLogServiceControl        PdhLogServiceControlA
#define PdhLogServiceQuery          PdhLogServiceQueryA
#define PdhExpandWildCardPath       PdhExpandWildCardPathA
#define PdhBindInputDataSource      PdhBindInputDataSourceA
#define PdhEnumMachinesH            PdhEnumMachinesHA
#define PdhEnumObjectsH             PdhEnumObjectsHA
#define PdhEnumObjectItemsH         PdhEnumObjectItemsHA
#define PdhExpandWildCardPathH      PdhExpandWildCardPathHA
#define PdhGetDefaultPerfObjectH    PdhGetDefaultPerfObjectHA
#define PdhGetDefaultPerfCounterH   PdhGetDefaultPerfCounterHA
#define PdhEnumLogSetNames	    PdhEnumLogSetNamesA
#define PdhCreateSQLTables	    PdhCreateSQLTablesA
#define PdhVerifySQLDB	            PdhVerifySQLDBA

// end of ANSI definitions
#endif  // UNICODE

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif

#endif //_PDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\pdhp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __PDHP__
#define __PDHP__

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Private Pdh Section
\*****************************************************************************/


typedef struct _PDH_RELOG_INFO_A {
    LPSTR           strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_A, *PPDH_RELOG_INFO_A;

typedef struct _PDH_RELOG_INFO_W {
    LPWSTR          strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_W, *PPDH_RELOG_INFO_W;

PDH_FUNCTION
PdhRelogA( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_A  pRelogInfo
);

PDH_FUNCTION
PdhRelogW( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_W pRelogInfo
);

#ifdef UNICODE
#define PdhRelog            PdhRelogW
#define PDH_RELOG_INFO      PDH_RELOG_INFO_W
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_W
#else
#define PdhRelog            PdhRelogA
#define PDH_RELOG_INFO      PDH_RELOG_INFO_A
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_A
#endif

/*****************************************************************************\
    Performance Logs and Alerts Section
\*****************************************************************************/


#ifdef UNICODE
#define PdhPlaStart                PdhPlaStartW
#define PdhPlaStop                 PdhPlaStopW
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateW
#define PdhPlaDelete               PdhPlaDeleteW
#define PdhPlaAddItem              PdhPlaAddItemW
#define PdhPlaSetItemList          PdhPlaSetItemListW
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemsW
#define PdhPlaGetInfo              PdhPlaGetInfoW
#define PdhPlaSetInfo              PdhPlaSetInfoW
#define PdhPlaSetRunAs             PdhPlaSetRunAsW
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsW
#define PdhPlaValidateInfo         PdhPlaValidateInfoW
#define PDH_PLA_INFO               PDH_PLA_INFO_W
#define PPDH_PLA_INFO              PPDH_PLA_INFO_W
#define PDH_PLA_ITEM               PDH_PLA_ITEM_W
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_W
#define PdhTranslate009Counter     PdhTranslate009CounterW
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterW
#define PdhAdd009Counter           PdhAdd009CounterW
#define PdhGetLogFileType          PdhGetLogFileTypeW
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameW
#define PdhPlaGetSchedule          PdhPlaGetScheduleW
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksW
#else
#define PdhPlaStart                PdhPlaStartA
#define PdhPlaStop                 PdhPlaStopA
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateA
#define PdhPlaDelete               PdhPlaDeleteA
#define PdhPlaAddItem              PdhPlaAddItemA
#define PdhPlaSetItemList          PdhPlaSetItemListA
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemA
#define PdhPlaGetInfo              PdhPlaGetInfoA
#define PdhPlaSetInfo              PdhPlaSetInfoA
#define PdhPlaSetRunAs             PdhPlaSetRunAsA
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsA
#define PdhPlaValidateInfo         PdhPlaValidateInfoA
#define PDH_PLA_INFO               PDH_PLA_INFO_A
#define PPDH_PLA_INFO              PPDH_PLA_INFO_A
#define PDH_PLA_ITEM               PDH_PLA_ITEM_A
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_A
#define PdhTranslate009Counter     PdhTranslate009CounterA
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterA
#define PdhAdd009Counter           PdhAdd009CounterA
#define PdhGetLogFileType          PdhGetLogFileTypeA
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameA
#define PdhPlaGetSchedule          PdhPlaGetScheduleA
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksA
#endif

// wDataType values
#define PLA_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define PLA_TT_DTYPE_UNITS      ((WORD)0x0002)

// dwMode values
#define PLA_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define PLA_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define PLA_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define PLA_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define PLA_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Schedule Calender

// wTimeType values
#define PLA_TT_TTYPE_START              ((WORD)0x0001)
#define PLA_TT_TTYPE_STOP               ((WORD)0x0002)
#define PLA_TT_TTYPE_RESTART            ((WORD)0x0003)
#define PLA_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define PLA_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define PLA_TT_TTYPE_CREATENEWFILE      ((WORD)0x0006)
#define PLA_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)

// dwUnitType values
#define PLA_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define PLA_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define PLA_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define PLA_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define PLA_TT_UTYPE_DAYSOFWEEK     ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _PLA_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} PLA_TIME_INFO, *PPLA_TIME_INFO;

typedef struct _PDH_PLA_ITEM_W {
    DWORD dwType;
    union {
        LPWSTR strCounters;
        struct {
            LPWSTR strProviders;
            LPWSTR strFlags;
            LPWSTR strLevels;
        };
    };
} PDH_PLA_ITEM_W, *PPDH_PLA_ITEM_W;

typedef struct _PDH_PLA_ITEM_A {
    DWORD dwType;
    union {
        LPSTR strCounters;
        struct {
            LPSTR strProviders;
            LPSTR strFlags;
            LPSTR strLevels;
        };
    };
} PDH_PLA_ITEM_A, *PPDH_PLA_ITEM_A;

#pragma warning ( default : 4201 )

// Generic Fields
#define PLA_INFO_FLAG_USER        0x00000001
#define PLA_INFO_FLAG_FORMAT      0x00000002
#define PLA_INFO_FLAG_MAXLOGSIZE  0x00000004
#define PLA_INFO_FLAG_RUNCOMMAND  0x00000008
#define PLA_INFO_FLAG_FILENAME    0x00000010
#define PLA_INFO_FLAG_AUTOFORMAT  0x00000020
#define PLA_INFO_FLAG_DATASTORE   0x00000040
#define PLA_INFO_FLAG_REPEAT      0x00000080
#define PLA_INFO_FLAG_STATUS      0x00000100
#define PLA_INFO_FLAG_TYPE        0x00000200
#define PLA_INFO_FLAG_BEGIN       0x00000400
#define PLA_INFO_FLAG_END         0x00000800
#define PLA_INFO_FLAG_CRTNEWFILE  0x00001000
#define PLA_INFO_FLAG_DEFAULTDIR  0x00002000
#define PLA_INFO_FLAG_SRLNUMBER   0x00004000
#define PLA_INFO_FLAG_SQLNAME     0x00008000
#define PLA_INFO_FLAG_ALL         0xFFFFFFFF

// Trace Fields
#define PLA_INFO_FLAG_BUFFERSIZE  0x00010000
#define PLA_INFO_FLAG_LOGGERNAME  0x00020000
#define PLA_INFO_FLAG_MODE        0x00040000
#define PLA_INFO_FLAG_MINBUFFERS  0x00080000
#define PLA_INFO_FLAG_MAXBUFFERS  0x00100000
#define PLA_INFO_FLAG_FLUSHTIMER  0x00200000
#define PLA_INFO_FLAG_PROVIDERS   0x00400000
#define PLA_INFO_FLAG_TRACE       0x00FFFFFF

// Performance Fields
#define PLA_INFO_FLAG_INTERVAL    0x01000000
#define PLA_INFO_FLAG_COUNTERS    0x02000000
#define PLA_INFO_FLAG_PERF        0xFF00FFFF

#define PLA_INFO_CREATE_FILENAME    \
    (PLA_INFO_FLAG_FORMAT|          \
    PLA_INFO_FLAG_FILENAME|         \
    PLA_INFO_FLAG_AUTOFORMAT|       \
    PLA_INFO_FLAG_TYPE|             \
    PLA_INFO_FLAG_CRTNEWFILE|       \
    PLA_INFO_FLAG_DEFAULTDIR|       \
    PLA_INFO_FLAG_SRLNUMBER|        \
    PLA_INFO_FLAG_SQLNAME|          \
    PLA_INFO_FLAG_STATUS )          \


typedef struct _PDH_PLA_INFO_W {
    DWORD       dwMask;
    LPWSTR      strUser;
    LPWSTR      strPassword;
    DWORD       dwType;
    DWORD       dwMaxLogSize;
    DWORD       dwFlags;
    DWORD       dwLogQuota;
    LPWSTR      strLogFileCaption;
    LPWSTR      strDefaultDir;
    LPWSTR      strBaseFileName;
    LPWSTR      strSqlName;
    DWORD       dwFileFormat;
    DWORD       dwAutoNameFormat;
    DWORD       dwLogFileSerialNumber;
    LPWSTR      strCommandFileName;
    DWORD       dwDatastoreAttributes;
    PLA_TIME_INFO    ptLogBeginTime;
    PLA_TIME_INFO    ptLogEndTime;
    PLA_TIME_INFO    ptCreateNewFile;
    PLA_TIME_INFO    ptRepeat;
    DWORD       dwStatus;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    union {
        struct {
            PDH_PLA_ITEM_W  piCounterList;
            DWORD           dwAutoNameInterval;
            DWORD           dwAutoNameUnits;
            PLA_TIME_INFO   ptSampleInterval;
        } Perf;
        struct {
            PDH_PLA_ITEM_W  piProviderList;
            LPWSTR  strLoggerName;
            DWORD   dwMode;
            DWORD   dwNumberOfBuffers;
            DWORD   dwMaximumBuffers;
            DWORD   dwMinimumBuffers;
            DWORD   dwBufferSize;
            DWORD   dwFlushTimer;
        } Trace;
    };
} PDH_PLA_INFO_W, *PPDH_PLA_INFO_W;

typedef struct _PDH_PLA_INFO_A {
    DWORD       dwMask;
    // NOT YET IMPLEMENTED
} PDH_PLA_INFO_A, *PPDH_PLA_INFO_A;

typedef struct _PLA_VERSION_ {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuild;
    DWORD dwSubBuild;
} PLA_VERSION, *PPLA_VERSION;

HRESULT
PdhiPlaFormatBlanksA( 
    LPSTR strComputer, 
    LPSTR strFormat 
);

HRESULT
PdhiPlaFormatBlanksW( 
    LPWSTR strComputer, 
    LPWSTR strFormat 
);

PDH_FUNCTION
PdhPlaGetScheduleA(
    LPSTR strName, 
    LPSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhPlaGetScheduleW(
    LPWSTR strName, 
    LPWSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);


PDH_FUNCTION
PlaTimeInfoToMilliSeconds(
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs
);

PDH_FUNCTION
PdhPlaValidateInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaValidateInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION 
PdhPlaScheduleA( 
    LPSTR strName, 
    LPSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaScheduleW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaStartA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaStartW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION 
PdhPlaStopA( 
    LPSTR strName, 
    LPSTR strComputer  
);

PDH_FUNCTION 
PdhPlaStopW( 
    LPWSTR strName, 
    LPWSTR strComputer  
);

PDH_FUNCTION 
PdhPlaCreateA( 
    LPSTR strName, 
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION 
PdhPlaCreateW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION 
PdhPlaDeleteA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaDeleteW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaAddItemA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A  pItem
);

PDH_FUNCTION 
PdhPlaAddItemW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItem
);

PDH_FUNCTION 
PdhPlaSetItemListA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A pItems
);

PDH_FUNCTION 
PdhPlaSetItemListW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsA(
    LPSTR strName,
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
    LPWSTR strName,
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaGetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaGetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
);

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion 
);


PDH_FUNCTION
PdhPlaEnumCollectionsA( 
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    LPSTR mszCollections
);

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    LPWSTR mszCollections
);

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR      szLocalePath,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR       szLocalePath,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR      sz009Path,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR       sz009Path,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhAdd009CounterW(
    IN  HQUERY      hQuery,
    IN  LPWSTR      szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhAdd009CounterA(
    IN  HQUERY      hQuery,
    IN  LPSTR       szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN LPCSTR  LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

#define PLA_SECONDS_IN_DAY      86400
#define PLA_SECONDS_IN_HOUR      3600
#define PLA_SECONDS_IN_MINUTE      60
#define _PLA_CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _PLA_SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define PLA_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define PLA_MAX_COLLECTION_NAME   ((DWORD)(_MAX_FNAME - PLA_MAX_AUTO_NAME_LEN - 1))

#define PLA_FILENAME_USE_SUBEXT     0x00000001
#define PLA_FILENAME_GET_SUBFMT     0x00000002
#define PLA_FILENAME_GET_SUBXXX     0x00000004
#define PLA_FILENAME_CREATEONLY     0x00000008
#define PLA_FILENAME_CURRENTLOG     0x00000010

#define PLA_SERVICE_CONTROL_SYNCHRONIZE 128
#define PLA_QUERY_STOPPED       ((DWORD)0x00000000)              
#define PLA_QUERY_RUNNING       ((DWORD)0x00000001)
#define PLA_QUERY_START_PENDING ((DWORD)0x00000002)

#define PLA_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define PLA_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define PLA_COUNTER_LOG     ((DWORD)0x00000000)
#define PLA_TRACE_LOG       ((DWORD)0x00000001)
#define PLA_ALERT           ((DWORD)0x00000002)
#define PLA_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define PLA_NUM_LOG_TYPES   ((DWORD)0x00000003)

// Sysmon log output file configuration definitions

#define PLA_DATASTORE_APPEND_MASK       ((DWORD)0x000000F)     
#define PLA_DATASTORE_OVERWRITE         ((DWORD)0x0000001)     
#define PLA_DATASTORE_APPEND            ((DWORD)0x0000002)     

#define PLA_DATASTORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define PLA_DATASTORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define PLA_DATASTORE_SIZE_KB           ((DWORD)0x0000020)     
#define PLA_DATASTORE_SIZE_MB           ((DWORD)0x0000040)     

#define PLA_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define PLA_CSV_FILE        ((DWORD)0x00000000)
#define PLA_TSV_FILE        ((DWORD)0x00000001)
#define PLA_BIN_FILE        ((DWORD)0x00000002)
#define PLA_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define PLA_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define PLA_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define PLA_SQL_LOG         ((DWORD)0x00000006)
#define PLA_NUM_FILE_TYPES  ((DWORD)0x00000007)

#define PLA_SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define PLA_SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define PLA_SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define PLA_SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define PLA_SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define PLA_SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define PLA_SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define PLA_SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define PLA_SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define PLA_SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

// Sysmon log query types and constants

// Constants
#define PLA_DISK_MAX_SIZE   ((DWORD)-1)

#define PLA_LOG_SIZE_UNIT_MB                (1024*1024)
#define PLA_LOG_SIZE_UNIT_KB                1024

#define PLA_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define PLA_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define PLA_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define PLA_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define PLA_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define PLA_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define PLA_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define PLA_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define PLA_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// alert action flags
#define PLA_ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define PLA_ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define PLA_ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define PLA_ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define PLA_ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define PLA_ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define PLA_ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define PLA_ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define PLA_ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define PLA_ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define PLA_ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define PLA_ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define PLA_ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define PLA_ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define PLA_AIBF_UNDER  0L
#define PLA_AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define PLA_AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define PLA_AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box
 
typedef struct _PLA_ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} PLA_ALERT_INFO_BLOCK, *PPLA_ALERT_INFO_BLOCK;

#ifdef __cplusplus
}
#endif

#endif // __PDHP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\pdhitype.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    pdhitype.h

Abstract:

    data types used internally by the Data Provider Helper functions.

--*/

#ifndef _PDHI_TYPE_H_
#define _PDHI_TYPE_H_

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <stdio.h>
#include <pdh.h>
//#include "pdhidef.h"
#include "wbemdef.h"
#include "perftype.h"
#include "pdhicalc.h"

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning ( disable : 4201 )

#define PDH_LOG_TYPE_RETIRED_BIN    3

typedef double  DOUBLE;

typedef struct _PDHI_MAPPED_LOG_FILE {
    struct _PDHI_MAPPED_LOG_FILE    *pNext;
    LPWSTR                          szLogFileName;
    HANDLE                          hFileHandle;
    HANDLE                          hMappedFile;
    LPVOID                          pData;
    DWORD                           dwRefCount;
    LONGLONG                        llFileSize;
} PDHI_MAPPED_LOG_FILE, *PPDHI_MAPPED_LOG_FILE;

// Two structures used in the SQL portion of the code
typedef struct _OBJECT_NAME_STRUCT 
{
	struct _OBJECT_NAME_STRUCT	   *pNext;
	LPWSTR							szMachineName;
	LPVOID							mszObjectName;
	DWORD							dwObjListLen; // in bytes
	DWORD							dwObjListUsed; // in bytes
}OBJECT_NAME_STRUCT, *POBJECT_NAME_STRUCT;

typedef struct _OBJECT_ITEM_STRUCT 
{
	struct _OBJECT_ITEM_STRUCT	   *pNext;
	LPWSTR							szMachineName;
	LPWSTR							szObjectName;
	LPVOID							mszCounterList;
	DWORD							dwCountListLen;		// lengths & used kept in bytes
	DWORD							dwCountListUsed;
	LPVOID							mszInstanceList; // contains instance index
	DWORD							dwInstListLen;
	DWORD							dwInstListUsed;
	DWORD							dwCounterStorageLen; // use this to determine how much space allocated for dword arrays below
	DWORD							dwNumOfCounters;     // use this to determine how much of dword counter space is used
	DWORD						   *pdwSQLCounterId;
	DWORD						   *pdwSequentialIndex;
	DWORD						   *pdwCounterType;
	LONG						   *plDefaultScale;
} OBJECT_ITEM_STRUCT, *POBJECT_ITEM_STRUCT;

// make signature into DWORDs to make this a little faster

#define SigQuery    ((DWORD)0x51484450)    // L"PDHQ"
#define SigCounter  ((DWORD)0x43484450)    // L"PDHC"
#define SigLog      ((DWORD)0x4C484450)    // L"PDHL"

typedef struct _PDHI_QUERY_MACHINE {
    PPERF_MACHINE   pMachine;       // pointer to the machine structure
    LPWSTR          szObjectList;   // list of objects to query on that machine
    PERF_DATA_BLOCK *pPerfData;     // query's perf data block
    LONG            lQueryStatus;   // status of last perf query
    LONGLONG        llQueryTime;    // timestamp from last query attempt
    struct _PDHI_QUERY_MACHINE *pNext;  // next machine in list
} PDHI_QUERY_MACHINE, *PPDHI_QUERY_MACHINE;

typedef struct _PDHI_COUNTER_PATH {
    // machine path
    LPWSTR  szMachineName;      // null = the local machine
    // object Info
    LPWSTR  szObjectName;
    // instance info
    LPWSTR  szInstanceName;     // NULL if no inst.
    LPWSTR  szParentName;       // points to name if instance has a parent
    DWORD   dwIndex;            // index (to support dup. names.) 0 = 1st inst.
    // counter info
    LPWSTR  szCounterName;
    // misc storage
    BYTE    pBuffer[1];         // beginning of string buffer space
} PDHI_COUNTER_PATH, *PPDHI_COUNTER_PATH;

typedef struct _PDHI_RAW_COUNTER_ITEM {
    DWORD       szName;
    DWORD       MultiCount;
    LONGLONG    FirstValue;
    LONGLONG    SecondValue;
} PDHI_RAW_COUNTER_ITEM, *PPDHI_RAW_COUNTER_ITEM;

typedef struct _PDHI_RAW_COUNTER_ITEM_BLOCK {
    DWORD                   dwLength;
    DWORD                   dwItemCount;
    DWORD                   dwReserved;
    LONG                    CStatus;
    FILETIME                TimeStamp;
    PDHI_RAW_COUNTER_ITEM   pItemArray[1];
} PDHI_RAW_COUNTER_ITEM_BLOCK, *PPDHI_RAW_COUNTER_ITEM_BLOCK;

#define HASH_TABLE_SIZE 257

typedef struct _PDHI_INSTANCE {
    LIST_ENTRY Entry;
    FILETIME   TimeStamp;
    DWORD      dwTotal;
    DWORD      dwCount;
    LPWSTR     szInstance;
} PDHI_INSTANCE, * PPDHI_INSTANCE;

typedef struct _PDHI_INST_LIST {
    struct _PDHI_INST_LIST * pNext;
    LIST_ENTRY               InstList;
    LPWSTR                   szCounter;
} PDHI_INST_LIST, * PPDHI_INST_LIST;

typedef PPDHI_INST_LIST PDHI_COUNTER_TABLE[HASH_TABLE_SIZE];

typedef struct  _PDHI_QUERY_LIST {
    struct _PDHI_QUERY  *flink;
    struct _PDHI_QUERY  *blink;
} PDHI_QUERY_LIST, *PPDHI_QUERY_LIST;

typedef struct  _PDHI_COUNTER_LIST {
    struct _PDHI_COUNTER    *flink;
    struct _PDHI_COUNTER    *blink;
} PDHI_COUNTER_LIST, *PPDHI_COUNTER_LIST;

typedef struct  _PDHI_LOG_LIST {
    struct _PDHI_LOG        *flink;
    struct _PDHI_LOG        *blink;
} PDHI_LOG_LIST, *PPDHI_LOG_LIST;

typedef struct _PDHI_COUNTER {
    CHAR   signature[4];                // should be "PDHC" for counters
    DWORD   dwLength;                   // length of this structure
    struct _PDHI_QUERY *pOwner;         // pointer to owning query
    LPWSTR  szFullName;                 // full counter path string
    PDHI_COUNTER_LIST next;             // list links
    DWORD   dwUserData;               // user defined DWORD
    LONG    lScale;                     // integer scale exponent
    // this information is obtained from the system
    DWORD    CVersion;                  // system perfdata version
    DWORD   dwFlags;                    // flags
    PPDHI_QUERY_MACHINE pQMachine;      // pointer to the machine structure
    PPDHI_COUNTER_PATH  pCounterPath;   // parsed counter path
    PDH_RAW_COUNTER ThisValue;          // most recent value
    PDH_RAW_COUNTER LastValue;          // previous value
    LPWSTR  szExplainText;              // pointer to the explain text buffer
    LPCOUNTERCALC       CalcFunc;       // pointer to the calc function
    LPCOUNTERSTAT       StatFunc;       // pointer to the statistics function
    // these fields are used by "wildcard" counter handles
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pThisRawItemList;   // pointer to current data set
    PPDHI_RAW_COUNTER_ITEM_BLOCK    pLastRawItemList;   // pointer to previous data set
    PPERF_DATA_BLOCK    pThisObject;
    PPERF_DATA_BLOCK    pLastObject;
    DWORD               dwIndex;
    // these fields are specific to the Perflib implementation
    LONGLONG            TimeBase;       // freq. of timer used by this counter
    PERFLIB_COUNTER     plCounterInfo;  // perflib specific counter data
    // fields used by WBEM Counter items
    IWbemClassObject    *pWbemObject;   // refreshable Object pointer
    LONG                lWbemRefreshId; // reffrshable ID
    IWbemObjectAccess   *pWbemAccess;   // data access Object pointer
    IWbemHiPerfEnum     *pWbemEnum;     // interface for wildcard instance queries
    LONG                lNameHandle;    // handle for name property
    LONG                lWbemEnumId;    // id for wbem enumerator
    LONG                lNumItemHandle; // handle of Numerator Property
    LONG                lNumItemType;   // WBEM Data type of numerator value
    LONG                lDenItemHandle; // handle of Denominator Property
    LONG                lDenItemType;   // WBEM Data type of Denominator value
    LONG                lFreqItemHandle; // handle of Timebase Freq Property
    LONG                lFreqItemType;   // WBEM Data type of Timebase Freqvalue
    PVOID               pBTreeNode;
} PDHI_COUNTER, *PPDHI_COUNTER;

// flags for the PDHI_COUNTER data structure.
#define  PDHIC_MULTI_INSTANCE       ((DWORD)0x00000001)
#define  PDHIC_ASYNC_TIMER          ((DWORD)0x00000002)
#define  PDHIC_WBEM_COUNTER         ((DWORD)0x00000004)
#define  PDHIC_COUNTER_BLOCK        ((DWORD)0x00000008)
#define  PDHIC_COUNTER_OBJECT       ((DWORD)0x00000010)
#define  PDHIC_COUNTER_NOT_INIT     ((DWORD)0x80000000)
#define  PDHIC_COUNTER_INVALID      ((DWORD)0x40000000)
#define  PDHIC_COUNTER_UNUSABLE     ((DWORD)0xC0000000)

typedef struct  _PDHI_QUERY {
    CHAR   signature[4];        // should be "PDHQ" for queries
    PDHI_QUERY_LIST next;       // pointer to next query in list
    PPDHI_COUNTER   pCounterListHead; // pointer to first counter in list
    DWORD   dwLength;           // length of this structure
    DWORD_PTR dwUserData;
    DWORD   dwInterval;         // interval in seconds
    DWORD   dwFlags;            // notification flags
    PDH_TIME_INFO   TimeRange;  // query time range
    HLOG    hLog;               // handle to log file (for data source)
    HLOG    hOutLog;            // Log handle for output logfile (to write query result)
    DWORD   dwReleaseLog;
    DWORD   dwLastLogIndex;     // the last log record returned to a Get Value call
    HANDLE  hMutex;             // mutex to sync changes to data.
    HANDLE  hNewDataEvent;      // handle to event that is sent when data is collected
    HANDLE  hAsyncThread;       // thread handle for async collection
    HANDLE  hExitEvent;         // event to set for thread to terminate
    union {
        struct {
        // perflib only fields
            PPDHI_QUERY_MACHINE pFirstQMachine; // pointer to first machine in list
        };
        struct {
            IWbemRefresher          *pRefresher;    // WBEM Refresher interface ptr
            IWbemConfigureRefresher *pRefresherCfg; // WBEM Ref. Config interface ptr.
            LANGID                  LangID;         // Language code for strings
        };
    };
} PDHI_QUERY, *PPDHI_QUERY;

#define  PDHIQ_WBEM_QUERY           ((DWORD)0x00000004)

typedef struct _PDHI_LOG {
    CHAR    signature[4];       // should be "PDHL" for log entries
    PDHI_LOG_LIST   next;       // links to next and previous entries
    struct _PDHI_LOG * NextLog; // next log entry for multiple WMI logfile open
    HANDLE  hLogMutex;          // sync mutex to serialize modifications to the structure
    DWORD   dwLength;           // the size of this structure
    LPWSTR  szLogFileName;      // full file name for this log file
    HANDLE  hLogFileHandle;     // handle to open log file
    HANDLE  hMappedLogFile;     // handle for memory mapped files
    LPVOID  lpMappedFileBase;   // starting address for mapped log file
    FILE    *StreamFile;        // stream pointer for text files
    LONGLONG llFileSize;        // file size (used only for reading)
    DWORD   dwRecord1Size;      // size of ID record in BLG files, not used by text files
    DWORD   dwLastRecordRead;   // index of last record read from the file
    LPVOID  pLastRecordRead;    // pointer to buffer containing the last record
    LPWSTR  szCatFileName;      // catalog file name
    HANDLE  hCatFileHandle;     // handle to the open catalog file
    PPDHI_QUERY pQuery;         // pointer to the query associated with the log
    LONGLONG llMaxSize;         // max size of a circular log file
    DWORD   dwLogFormat;        // log type and access flags
    DWORD   dwMaxRecordSize;    // size of longest record in log
    PVOID   pPerfmonInfo;       // used when reading perfmon logs
    LARGE_INTEGER    liLastRecordOffset;     // offset to last record read
	// additions for SQL
	GUID    guidSQL;			// GUID associated with the dataset
	int		iRunidSQL;			// Integer RunID associated with the dataset
	void *  henvSQL;			// HENV environment handle for to SQL
	void *  hdbcSQL;			// HDBC odbc connection handle for SQL
	LPWSTR  szDSN;				// pointer to Data Source Name within LogFileName (separators replaced with 0's)
	LPWSTR	szCommentSQL;		// pointer to the Comment string that defines the name of the data set within the SQL database
	DWORD	dwNextRecordIdToWrite; // next record number to write
    //End of additions for SQL
} PDHI_LOG, *PPDHI_LOG;

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning ( default : 4201 )
#endif


#ifdef __cplusplus
}
#endif
#endif // _PDH_TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\pdhidef.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    pdhidef.h

Abstract:

    function definitions used internally by the performance data helper
    functions

--*/

#ifndef _PDHI_DEFS_H_
#define _PDHI_DEFS_H_

#pragma warning ( disable : 4115 )

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0    // for debugging
#endif

//#define _SHOW_PDH_MEM_ALLOCS        1
//#define _VALIDATE_PDH_MEM_ALLOCS    1

#include <locale.h>

#include "pdhitype.h"   // required for data type definitions
//#include "pdhmsg.h"     // error message definitions
//#include "strings.h"    // for string constants

#if DBG
VOID
__cdecl
PdhDebugPrint(
    ULONG DebugPrintLevel,
    char* DebugMessage,
    ...
    );

#define DebugPrint(x)   PdhDebugPrint x

#else

#define DebugPrint(x)

#endif

#define STATIC_PDH_FUNCTION PDH_STATUS __stdcall
#define STATIC_BOOL         BOOL __stdcall
#define STATIC_DWORD        DWORD __stdcall
#define PDH_PLA_MUTEX       L"__PDH_PLA_MUTEX__"

// global variable declarations
extern HANDLE   ThisDLLHandle;
extern WCHAR    szStaticLocalMachineName[];
extern HANDLE   hPdhDataMutex;
extern HANDLE   hPdhContextMutex;
extern HANDLE   hPdhPlaMutex;
extern HANDLE   hPdhHeap;
extern HANDLE   hEventLog;

extern LONGLONG llRemoteRetryTime;
extern BOOL     bEnableRemotePdhAccess;
extern DWORD    dwPdhiLocalDefaultDataSource;
extern LONG     dwCurrentRealTimeDataSource;
extern BOOL     bProcessIsDetaching;

#ifndef _SHOW_PDH_MEM_ALLOCS

#define G_ALLOC(s)          HeapAlloc (hPdhHeap, (HEAP_ZERO_MEMORY), s)
#define G_REALLOC(h,s)      HeapReAlloc (hPdhHeap, (HEAP_ZERO_MEMORY), h, s)
#define G_FREE(h)           if (h != NULL) HeapFree (hPdhHeap, 0, h)
#define G_SIZE(h)           HeapSize (hPdhHeap, 0, h)

#else

#ifdef _VALIDATE_PDH_MEM_ALLOCS

__inline
LPVOID
PdhiHeapAlloc(DWORD s)
{
    LPVOID  lpRetVal;

    HeapValidate(hPdhHeap, 0, NULL);
    lpRetVal = HeapAlloc (hPdhHeap, HEAP_ZERO_MEMORY, s);

    return lpRetVal;
}

__inline
LPVOID
PdhiHeapReAlloc(LPVOID h, DWORD s)
{
    LPVOID  lpRetVal;

    HeapValidate(hPdhHeap, 0, NULL);
    lpRetVal = HeapReAlloc (hPdhHeap, HEAP_ZERO_MEMORY, h, s);

    return lpRetVal;
}

__inline
BOOL
PdhiHeapFree(LPVOID h)
{
    BOOL bRetVal;

    if (h == NULL) return TRUE;
    HeapValidate(hPdhHeap, 0, NULL);
    bRetVal = HeapFree (hPdhHeap, 0, h);
    return bRetVal;
}

#define G_ALLOC(s)          PdhiHeapAlloc (s)
#define G_REALLOC(h,s)      PdhiHeapReAlloc (h, s)
#define G_FREE(h)           PdhiHeapFree (h)
#define G_SIZE(h)           HeapSize (hPdhHeap, 0, h)

#else

__inline
LPVOID
PdhiHeapAlloc(LPSTR szSourceFileName, DWORD dwLineNo, SIZE_T s)
{
    LPVOID  lpRetVal;

    lpRetVal = HeapAlloc(hPdhHeap, HEAP_ZERO_MEMORY, s);
#ifdef _WIN64
    DebugPrint((1, "G_ALLOC(%s#%d)(%I64d,0x%08X)\n",
            szSourceFileName, dwLineNo,
            (lpRetVal != NULL ? s : 0), 
            lpRetVal));
#else
    DebugPrint((1, "G_ALLOC(%s#%d)(%d,0x%08X)\n",
            szSourceFileName, dwLineNo,
            (lpRetVal != NULL ? s : 0), 
            lpRetVal));
#endif
    return lpRetVal;
}

__inline
LPVOID
PdhiHeapReAlloc(LPSTR szSourceFileName, DWORD dwLineNo, LPVOID h, SIZE_T s)
{
    LPVOID  lpRetVal;
    SIZE_T  dwBeforeSize;
    DWORD   dwCurrentThread = GetCurrentThreadId();

    dwBeforeSize = HeapSize (hPdhHeap, 0, h);
    lpRetVal = HeapReAlloc (hPdhHeap, HEAP_ZERO_MEMORY, h, s);
#ifdef _WIN64
    DebugPrint((1, "G_REALLOC(%s#%d)(0x%08X,%I64d)(0x%08X,%I64d)\n",
            szSourceFileName, dwLineNo,
            h, dwBeforeSize,
            lpRetVal, (lpRetVal != NULL ? s : 0)));
#else
    DebugPrint((1, "G_REALLOC(%s#%d)(0x%08X,%d)(0x%08X,%d)\n",
            szSourceFileName, dwLineNo,
            h, dwBeforeSize,
            lpRetVal, (lpRetVal != NULL ? s : 0)));
#endif
    return lpRetVal;
}

__inline
BOOL
PdhiHeapFree(LPSTR szSourceFileName, DWORD dwLineNo, LPVOID h)
{
    BOOL   bRetVal;
    SIZE_T dwBlockSize;

    if (h == NULL) return TRUE;
    dwBlockSize = HeapSize (hPdhHeap, 0, h);
    bRetVal = HeapFree (hPdhHeap, 0, h);
#ifdef _WIN64
    DebugPrint((1, "G_FREE(%s#%d)(0x%08X,%I64d)\n",
            szSourceFileName, dwLineNo,
            h,
            (bRetVal ? dwBlockSize : 0)));
#else
    DebugPrint((1, "G_FREE(%s#%d)(0x%08X,%d)\n",
            szSourceFileName, dwLineNo,
            h,
            (bRetVal ? dwBlockSize : 0)));
#endif
    return bRetVal;
}

#define G_ALLOC(s)          PdhiHeapAlloc (__FILE__, __LINE__, s)
#define G_REALLOC(h,s)      PdhiHeapReAlloc (__FILE__, __LINE__, h, s)
#define G_FREE(h)           PdhiHeapFree (__FILE__, __LINE__, h)
#define G_SIZE(h)           HeapSize (hPdhHeap, 0, h)

#endif

#endif


//    (assumes dword is 4 bytes)
#define ALIGN_ON_DWORD(x) ((VOID *)(((DWORD_PTR)(x) & 3) ? (((DWORD_PTR)(x) & ~3) + 4 ) : ((DWORD_PTR)(x))))

#define DWORD_MULTIPLE(x) ((((x)+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define CLEAR_FIRST_FOUR_BYTES(x)     *(DWORD *)(x) = 0L

//    (assumes QuadWORD is 8 bytes)
#define ALIGN_ON_QWORD(x) ((VOID *)(((DWORD_PTR)(x) & 7) ? (((DWORD_PTR)(x) & ~7) + 8) : ((DWORD_PTR)(x))))

#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))
#define CLEAR_FIRST_EIGHT_BYTES(x)     *(LONGLONG *)(x) = 0L



#if _DEBUG_MUTEXES
__inline
DWORD
PdhiLocalWaitForMutex (
    LPCSTR  szSourceFileName,
    DWORD   dwLineNo,
    HANDLE  hMutex
)
{
    DWORD   dwReturnValue = PDH_INVALID_PARAMETER;
    
    if (hMutex != NULL) {
        FILETIME    ft;
        GetSystemTimeAsFileTime (&ft);
        dwReturnValue = WaitForSingleObject (hMutex, 60000);
        DebugPrint ((4, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
            ft.dwLowDateTime,
            (DWORD)hMutex,
            (dwReturnValue == 0 ? "Locked" : "Lock Failed"),
            GetCurrentThreadId(),
            szSourceFileName, dwLineNo));
    } else {
        DebugPrint((4, "\nLock of NULL Mutex attmpted at: %s (%d)",
            szSourceFileName, dwLineNo));
        dwReturnValue = PDH_INVALID_PARAMETER;
    }
    return dwReturnValue;
}

#define WAIT_FOR_AND_LOCK_MUTEX(h) PdhiLocalWaitForMutex (__FILE__, __LINE__, h);

__inline
void
PdhiLocalReleaseMutex (
    LPCSTR  szSourceFileName,
    DWORD   dwLineNo,
    HANDLE  hMutex
)
{
    BOOL    bSuccess;
    LONG    lPrevCount = 0;
    FILETIME    ft;

    if (hMutex != NULL) {
        GetSystemTimeAsFileTime (&ft);
        bSuccess = ReleaseMutex (hMutex);
        DebugPrint((4, "\n[%8.8x] Mutex [%8.8x] %s by (%d) at: %s (%d)",
            ft.dwLowDateTime,
            (DWORD)hMutex,
            (bSuccess ? "Released" : "Release Failed"),
            GetCurrentThreadId(),
            szSourceFileName, dwLineNo));
    } else {
        DebugPrint((4, "\nRelease of NULL Mutex attempted at: %s (%d)",
            szSourceFileName, dwLineNo));
    }
}

#define RELEASE_MUTEX(h)  PdhiLocalReleaseMutex (__FILE__, __LINE__, h);
#else
#define WAIT_FOR_AND_LOCK_MUTEX(h) (h != NULL ? WaitForSingleObject(h, 60000) : WAIT_TIMEOUT)
#define RELEASE_MUTEX(h)  (h != NULL ? ReleaseMutex(h) : FALSE)
#endif

#define LODWORD(ll) ((DWORD)((LONGLONG)ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll) ((DWORD)(((LONGLONG)ll >> 32) & 0x00000000FFFFFFFF))
#define MAKELONGLONG(low, high) \
        ((LONGLONG) (((DWORD) (low)) | ((LONGLONG) ((DWORD) (high))) << 32))

#define SMALL_BUFFER_SIZE   4096
#define MEDIUM_BUFFER_SIZE  16834
#define LARGE_BUFFER_SIZE   65536

// set this to 1 to report code errors (i.e. debugging information)
// to the event log.
#define PDHI_REPORT_CODE_ERRORS 0

// set this to 1 to report user errors (i.e. things the normal user
// would care about) to the event log.
#define PDHI_REPORT_USER_ERRORS 1

// USER category errors are typically configuration, schema or access
// access errors, errors the user can usually do something about
#define PDH_EVENT_CATEGORY_USER     100

// COUNTER category errors are errors returned do to valid data returning
// invalid results. These are a special subset of USER Category errors.
#define PDH_EVENT_CATEGORY_COUNTER  110

// DEBUG category errors are of interest only to PDH developers as they
// indicate problems that can normally only be fixed by modifying the
// program code.
#define PDH_EVENT_CATEGORY_DEBUG    200

#define REPORT_EVENT(t,c,id)    ReportEvent (hEventLog, t, c, id, NULL, 0, 0, NULL, NULL)

__inline
BOOL
CounterIsOkToUse ( void *pCounterArg )
{
    PPDHI_COUNTER pCounter = (PPDHI_COUNTER)pCounterArg;

    if (pCounter != NULL) {
        if (pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE) {
            return FALSE;
        } else {
            return TRUE;
        }
    } else {
        return FALSE;
    }
}


DWORD
DataSourceTypeH (
    IN HLOG hDataSource
);

DWORD
DataSourceTypeW (
    IN LPCWSTR  szDataSource
);

DWORD
DataSourceTypeA (
    IN LPCSTR   szDataSource
);

LPWSTR
GetStringResource (
    DWORD   dwResId
);

//
//  Log file entries
//
extern LPCSTR  szTsvLogFileHeader;
extern LPCSTR  szCsvLogFileHeader;
extern LPCSTR  szBinLogFileHeader;
extern LPCSTR  szTsvType;
extern LPCSTR  szCsvType;
extern LPCSTR  szBinaryType;
extern  const DWORD   dwFileHeaderLength;
extern  const DWORD   dwTypeLoc;
extern  const DWORD   dwVersionLoc;
extern  const DWORD   dwFieldLength;

DWORD
UnmapReadonlyMappedFile (
    LPVOID  pMemoryBase,
    BOOL    *bNeedToCloseHandles
);

PDH_FUNCTION
PdhiGetLogCounterInfo (
    IN  HLOG            hLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiEnumLoggedMachines (
    IN  HLOG      hDataSource,
    IN  LPVOID    mszMachineList,
    IN  LPDWORD   pcchBufferSize,
    IN  BOOL      bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjects (
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPVOID  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh,
    IN  BOOL    bUnicode
);

PDH_FUNCTION
PdhiEnumLoggedObjectItems (
    IN      HLOG    hDataSource,
    IN      LPCWSTR szMachineName,
    IN      LPCWSTR szObjectName,
    IN      LPVOID  mszCounterList,
    IN      LPDWORD pdwCounterListLength,
    IN      LPVOID  mszInstanceList,
    IN      LPDWORD pdwInstanceListLength,
    IN      DWORD   dwDetailLevel,
    IN      DWORD   dwFlags,
    IN      BOOL    bUnicode
);

BOOL
PdhiDataSourceHasDetailLevelsH (
    IN HLOG hDataSource
);

BOOL
PdhiDataSourceHasDetailLevels (
    IN  LPWSTR  szDataSource
);

PDH_FUNCTION
PdhiGetMatchingLogRecord (
    IN  HLOG        hLog,
    IN  LONGLONG    *pStartTime,
    IN  LPDWORD     pdwIndex
);

PDH_FUNCTION
PdhiGetCounterValueFromLogFile (
    IN  HLOG           hLog,
    IN  DWORD          dwIndex,
    IN  PDHI_COUNTER * pCounter
);

STATIC_PDH_FUNCTION
PdhiGetCounterInfo (
    IN      HCOUNTER    hCounter,
    IN      BOOLEAN     bRetrieveExplainText,
    IN      LPDWORD     pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W  lpBuffer,
    IN      BOOL        bUnicode
);

// log.c
BOOL
PdhiCloseAllLoggers();

ULONG HashCounter(
    LPWSTR szCounterName
);

void
PdhiInitCounterHashTable(
    IN PDHI_COUNTER_TABLE pTable
);

void
PdhiResetInstanceCount(
    IN PDHI_COUNTER_TABLE pTable
);

PDH_FUNCTION
PdhiFindCounterInstList(
    IN  PDHI_COUNTER_TABLE pHeadList,
    IN  LPWSTR             szCounter,
    OUT PPDHI_INST_LIST  * pInstList
);

PDH_FUNCTION
PdhiFindInstance(
    IN  PLIST_ENTRY      pHeadInst,
    IN  LPWSTR           szInstance,
    IN  BOOLEAN          bUpdateCount,
    OUT PPDHI_INSTANCE * pInstance
);

DWORD
AddStringToMultiSz(
    IN  LPVOID  mszDest,
    IN  LPWSTR  szSource,
    IN  BOOL    bUnicodeDest
);

// query.c
PDH_FUNCTION
PdhiCollectQueryData (
    IN      PPDHI_QUERY pQuery,
    IN      LONGLONG    *pllTimeStamp
);

BOOL
PdhiQueryCleanup (
);

PDH_FUNCTION
PdhiConvertUnicodeToAnsi(
    IN  UINT     uCodePage,
    IN  LPWSTR   wszSrc,
    IN  LPSTR    aszDest,
    IN  LPDWORD  pdwSize
);

// qutils.c

DWORD
WINAPI
PdhiAsyncTimerThreadProc (
    LPVOID  pArg
);

BOOL
IsValidQuery (
    IN  HQUERY  hQuery
);

BOOL
IsValidCounter (
    IN  HCOUNTER  hCounter
);

BOOL
InitCounter (
    IN  OUT PPDHI_COUNTER pCounter
);

BOOL
ParseFullPathNameW (
    IN      LPCWSTR szFullCounterPath,
    IN  OUT PDWORD  pdwBufferLength,
    IN  OUT PPDHI_COUNTER_PATH  pCounter,
    IN      BOOL    bWbemSyntax
);

BOOL
ParseInstanceName (
    IN      LPCWSTR szInstanceString,
    IN OUT  LPWSTR  szInstanceName,
    IN OUT  LPWSTR  szParentName,
    IN OUT  LPDWORD lpIndex
);

BOOL
FreeCounter (
    IN  PPDHI_COUNTER   pThisCounter
);

BOOL
InitPerflibCounterInfo (
    IN  OUT PPDHI_COUNTER   pCounter
);

BOOL
AddMachineToQueryLists (
    IN  PPERF_MACHINE   pMachine,
    IN  PPDHI_COUNTER   pNewCounter
);

BOOL
UpdateRealTimeCounterValue (
    IN  PPDHI_COUNTER   pCounter
);

BOOL
UpdateRealTimeMultiInstanceCounterValue (
    IN  PPDHI_COUNTER   pCounter
);

BOOL
UpdateCounterValue (
    IN  PPDHI_COUNTER    pCounter,
    IN  PPERF_DATA_BLOCK pPerfData
);

BOOL
UpdateMultiInstanceCounterValue (
    IN  PPDHI_COUNTER    pCounter,
    IN  PPERF_DATA_BLOCK pPerfData,
    IN  LONGLONG         TimeStamp
);

BOOL
UpdateCounterObject(
    IN PPDHI_COUNTER pCounter
);

#define GPCDP_GET_BASE_DATA 0x00000001
PVOID
GetPerfCounterDataPtr (
    IN  PPERF_DATA_BLOCK    pPerfData,
    IN  PPDHI_COUNTER_PATH  pPath,
    IN  PPERFLIB_COUNTER    pplCtr,
    IN  DWORD               dwFlags,
    IN  PPERF_OBJECT_TYPE   *pPerfObject,
    IN  PDWORD              pStatus
);

LONG
GetQueryPerfData (
    IN  PPDHI_QUERY         pQuery,
    IN  LONGLONG            *pTimeStamp
);

BOOL
GetInstanceByNameMatch (
    IN      PPERF_MACHINE   pMachine,
    IN OUT  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiResetLogBuffers (
    IN  HLOG    hLog
);

DWORD
AddUniqueStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPSTR   szSource,
    IN  BOOL    bUnicodeDest
);

DWORD
AddUniqueWideStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPWSTR  szSource,
    IN  BOOL    bUnicodeDest
);

BOOL
PdhiBrowseDataSource (
    IN  HWND    hWndParent,
    IN  LPVOID  szFileName,
    IN  LPDWORD pcchFileNameSize,
    IN  BOOL    bUnicodeString
);

LPWSTR
PdhiGetExplainText (
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szObjectName,
    IN  LPCWSTR     szCounterName
);

LONG
GetCurrentServiceState (
    SC_HANDLE   hService,
    BOOL * bStopped,
    BOOL * bPaused
);

// wbem.cpp

BOOL
IsWbemDataSource (
    IN  LPCWSTR  szDataSource
);

PDH_FUNCTION
PdhiFreeAllWbemServers (
);

PDH_FUNCTION
PdhiGetWbemExplainText (
    IN  LPCWSTR     szMachineName,
    IN  LPCWSTR     szObjectName,
    IN  LPCWSTR     szCounterName,
    IN  LPWSTR      szExplain,
    IN  LPDWORD     pdwExplain
);

PDH_FUNCTION
PdhiEnumWbemMachines (
    IN      LPVOID      pMachineList,
    IN      LPDWORD     pcchBufferSize,
    IN      BOOL        bUnicode
);

PDH_FUNCTION
PdhiEnumWbemObjects (
    IN  LPCWSTR     szWideMachineName,
    IN  LPVOID      mszObjectList,
    IN  LPDWORD     pcchBufferSize,
    IN  DWORD       dwDetailLevel,
    IN  BOOL        bRefresh,
    IN  BOOL        bUnicode
);

PDH_FUNCTION
PdhiGetDefaultWbemObject (
    IN  LPCWSTR     szMachineName,
    IN  LPVOID      szDefaultObjectName,
    IN  LPDWORD     pcchBufferSize,
    IN  BOOL        bUnicode
);

PDH_FUNCTION
PdhiEnumWbemObjectItems (
    IN LPCWSTR      szWideMachineName,
    IN LPCWSTR      szWideObjectName,
    IN LPVOID       mszCounterList,
    IN LPDWORD      pcchCounterListLength,
    IN LPVOID       mszInstanceList,
    IN LPDWORD      pcchInstanceListLength,
    IN DWORD        dwDetailLevel,
    IN DWORD        dwFlags,
    IN BOOL         bUnicode
);

PDH_FUNCTION
PdhiGetDefaultWbemProperty (
    IN LPCWSTR      szMachineName,
    IN LPCWSTR      szObjectName,
    IN LPVOID       szDefaultCounterName,
    IN LPDWORD      pcchBufferSize,
    IN BOOL         bUnicode
);


PDH_FUNCTION
PdhiEncodeWbemPathW (
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPWSTR                      szFullPathBuffer,
    IN      LPDWORD                     pcchBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhiDecodeWbemPathA (
    IN      LPCSTR                      szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    IN      LPDWORD                     pcchBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhiDecodeWbemPathW (
    IN      LPCWSTR                     szFullPathBuffer,
    IN      PDH_COUNTER_PATH_ELEMENTS_W *pCounterPathElements,
    IN      LPDWORD                     pcchBufferSize,
    IN      LANGID                      LangId,
    IN      DWORD                       dwFlags
);

PDH_FUNCTION
PdhiEncodeWbemPathA (
    PDH_COUNTER_PATH_ELEMENTS_A *pCounterPathElements,
    LPSTR                       szFullPathBuffer,
    LPDWORD                     pcchBufferSize,
    LANGID                      LangId,
    DWORD                       dwFlags
);

BOOL
WbemInitCounter (
    IN      PPDHI_COUNTER pCounter
);

LONG
GetQueryWbemData (
    IN  PPDHI_QUERY         pQuery,
    IN  LONGLONG            *pllTimeStamp
);

PDH_FUNCTION
PdhiCloseWbemCounter (
    PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiFreeWbemQuery (
    PPDHI_QUERY     pThisQuery
);

//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#ifdef __cplusplus
}
#endif

#endif // _PDHI_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\perftype.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perftype.h

Abstract:

    Datatype definitions used by performance api utilities

--*/
#ifndef _PERFTYPE_H_
#define _PERFTYPE_H_

#include <windows.h>
#include <winperf.h>

#ifndef _DEBUG_MUTEXES
#define _DEBUG_MUTEXES 0    // for debugging
#endif

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define STR_COUNTER 0
#define STR_HELP    1

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

// default retry interval is no more often than every 120 seconds (2 min)
#define RETRY_TIME_INTERVAL ((LONGLONG)(1200000000))

typedef struct _LOCAL_PERF_NAME_INFO {
    HKEY    hKeyPerflib;
    HANDLE  hNameFile;
    HANDLE  hHelpFile;
    HANDLE  hNameFileObject;
    HANDLE  hHelpFileObject;
    LPVOID  pNameFileBaseAddr;
    LPVOID  pHelpFileBaseAddr;
} LOCAL_PERF_NAME_INFO, * PLOCAL_PERF_NAME_INFO;

typedef struct _PERF_MACHINE {
    HKEY                    hKeyPerformanceData;
    LPWSTR                  szName;
    PERF_DATA_BLOCK       * pSystemPerfData;
    LPWSTR                * szPerfStrings;
    LPWSTR                * sz009PerfStrings;
    BYTE                  * typePerfStrings;
    FILETIME                LastStringUpdateTime;
    DWORD                   dwLastPerfString;
    DWORD                   dwRefCount;
    LPWSTR                  szQueryObjects;
    DWORD                   dwStatus;
    LONGLONG                llRetryTime;
    HANDLE                  hMutex;
    DWORD                   dwRetryFlags;
    DWORD                   dwMachineFlags;
    PLOCAL_PERF_NAME_INFO   pLocalNameInfo;
    WCHAR                   szOsVer[8];
    struct  _PERF_MACHINE * pNext;
    struct  _PERF_MACHINE * pPrev;
    DWORD                   dwThreadId;
} PERF_MACHINE, *PPERF_MACHINE;

#define PDHIPM_FLAGS_HAVE_COSTLY    ((DWORD)0x00000001)
#define PDHIPM_FLAGS_USING_RPDH     ((DWORD)0x00000002)
#define PDHIPM_FLAGS_TRY_RPDH_FIRST ((DWORD)0x00000004)

typedef struct _PERFLIB_COUNTER {
    DWORD   dwObjectId;
    LONG    lInstanceId;
    LPWSTR  szInstanceName;
    DWORD   dwParentObjectId;
    LPWSTR  szParentInstanceName;
    DWORD   dwCounterId;
    DWORD   dwCounterType;
    DWORD   dwCounterSize;
    LONG    lDefaultScale;
    DWORD	dwSQLCounterId;
} PERFLIB_COUNTER, *PPERFLIB_COUNTER;

//
//  function definitions
//
// perfutil.c

extern PPERF_MACHINE   pFirstMachine;

#define GetLocalFileTime(pTime)    GetSystemTimeAsFileTime ( (LPFILETIME)(pTime) )

PDH_STATUS
ConnectMachine (
    PPERF_MACHINE   pThisMachine
);

PDH_STATUS
ValidateMachineConnection (
    IN  PPERF_MACHINE   pMachine
);


PPERF_MACHINE
GetMachineW (
    IN      LPWSTR  szMachineName,
    IN      DWORD   dwFlags
);

#if _DEBUG_MUTEXES

__inline
PPERF_MACHINE
GetMachineDbg (
    IN  LPWSTR  szMachine,
    IN  DWORD   dwFlags,
    IN  DWORD   dwLineNo,
    IN  LPCSTR  szFilename
)
{
    CHAR    szOutputString[MAX_PATH];
    FILETIME    ft;
    
    GetSystemTimeAsFileTime (&ft);
    sprintf (szOutputString, "\n[%8.8x] GetMachine(%ws) called by (%d) at: %s (%d)",
        ft.dwLowDateTime,
        szMachine,
        GetCurrentThreadId(),
        szFilename, dwLineNo);
    OutputDebugStringA (szOutputString);

    return GetMachineW (szMachine, dwFlags);
}

#define GetMachine(a,b) GetMachineDbg (a,b,__LINE__, __FILE__);

#else

#define GetMachine(a,b) GetMachineW (a,b);

#endif

// GetMachine Flags...
#define     PDH_GM_UPDATE_NAME      ((DWORD)0x00000001)
#define     PDH_GM_UPDATE_PERFDATA  ((DWORD)0x00000002)
#define     PDH_GM_READ_COSTLY_DATA ((DWORD)0x00000004)

BOOL
FreeMachine (
    PPERF_MACHINE   pMachine,
    BOOL            bForceRelease,
    BOOL            bProcessExit
);

BOOL
FreeAllMachines (
    BOOL bProcessExit
);

DWORD
GetObjectId (
    PPERF_MACHINE   pMachine,
    LPWSTR          szObjectName,
    BOOL            *bInstances
);

DWORD
GetCounterId (
    PPERF_MACHINE   pMachine,
    DWORD           dwObjectId,
    LPWSTR          szCounterName
);

BOOL
AppendObjectToValueList (
    DWORD   dwObjectId,
    PWSTR   pwszValueList
);

BOOL
GetObjectPerfInfo (
    IN      PPERF_DATA_BLOCK  pPerfData,
    IN      DWORD           dwObjectId,
    IN OUT  LONGLONG        *pPerfTime,
    IN OUT  LONGLONG        *pPerfFreq
);

// internal PerfName.C functions

LPCWSTR
PdhiLookupPerfNameByIndex (
    PPERF_MACHINE  pMachine,
    DWORD   dwNameIndex
);

#endif // _PERFTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhcalc\pdhicalc.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    pdhicalc.h

Abstract:

    calculation functions for the Data Provider Helper.

--*/

#ifndef _PDHICALC_H_
#define _PDHICALC_H_

#include <pdh.h>        // for public PDH data types
#include <winperf.h>    // for perf counter type constants

#if defined(__cplusplus)
#define LINK_SPEC extern "C"
#else
#define LINK_SPEC
#endif

// special perf counter type used by text log files
// value is stored as a double precision floating point value
#define PERF_DOUBLE_RAW     (PERF_SIZE_DWORD | 0x00002000 | PERF_TYPE_NUMBER | \
                                PERF_NUMBER_DECIMAL)


typedef double (APIENTRY COUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);
typedef double (APIENTRY *LPCOUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);

typedef PDH_STATUS (APIENTRY COUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);
typedef PDH_STATUS (APIENTRY *LPCOUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);

// calc functions
extern COUNTERCALC PdhiCalcDouble;
extern COUNTERCALC PdhiCalcAverage;
extern COUNTERCALC PdhiCalcElapsedTime;
extern COUNTERCALC PdhiCalcRawFraction;
extern COUNTERCALC PdhiCalcCounter;
extern COUNTERCALC PdhiCalcTimer;
extern COUNTERCALC PdhiCalcInverseTimer;
extern COUNTERCALC PdhiCalcRawCounter;
extern COUNTERCALC PdhiCalcNoData;
extern COUNTERCALC PdhiCalcDelta;

// status functions
extern COUNTERSTAT PdhiComputeFirstLastStats;
extern COUNTERSTAT PdhiComputeRawCountStats;
extern COUNTERSTAT PdhiComputeNoDataStats;

LINK_SPEC
PDH_STATUS 
PdhiComputeFormattedValue (
    IN      LPCOUNTERCALC       pCalcFunc,
    IN      DWORD               dwCounterType,
    IN      LONG                lScale,
    IN      DWORD               dwFormat,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PLONGLONG           pTimeBase,
    IN      DWORD               dwReserved,
    IN  OUT PPDH_FMT_COUNTERVALUE   fmtValue
);

LINK_SPEC
BOOL
AssignCalcFunction (
    IN      DWORD   dwCounterType,
    IN      LPCOUNTERCALC   *pCalcFunc,
    IN      LPCOUNTERSTAT   *pStatFunc
);

#endif // _PDHICALC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\perfdata.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perfdata.h

Abstract:

    <abstract>

--*/

#ifndef _PERFDATA_H_
#define _PERFDATA_H_

#define INITIAL_SIZE    ((DWORD)0x00010000)
#define EXTEND_SIZE     ((DWORD)0x00008000)
#define RESERVED        0L

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

#ifndef UNICODE_NULL
// then the unicode string struct is probably not defined either
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt
#endif

LPWSTR *
BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LANGID    LangId,       // language ID
    PPERF_MACHINE pMachine  // to update member fields
);

#define FirstObject(pPerfData) \
    (PPERF_OBJECT_TYPE)((PBYTE)(pPerfData) + (pPerfData)->HeaderLength)

#define NextObject(pObject) \
    (PPERF_OBJECT_TYPE)((pObject)->TotalByteLength != 0 ? (PPERF_OBJECT_TYPE)((PBYTE)(pObject) + (pObject)->TotalByteLength) : NULL)

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
);

PERF_OBJECT_TYPE *
GetObjectDefByName (
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD           dwLastNameIndex,
    IN  LPCWSTR         *NameArray,
    IN  LPCWSTR         szObjectName
);

#define FirstInstance(pObjectDef) \
    (PERF_INSTANCE_DEFINITION *)((PCHAR) pObjectDef + pObjectDef->DefinitionLength)


__inline
PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;
    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
);

PERF_INSTANCE_DEFINITION *
GetInstanceByUniqueId(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceUniqueId
);

DWORD
GetInstanceNameStr (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage);

DWORD
GetFullInstanceNameStr (
    PERF_DATA_BLOCK             *pPerfData,
    PERF_OBJECT_TYPE            *pObjectDef,
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    LPWSTR                      szInstanceName
);

BOOL IsMatchingInstance (
    PERF_INSTANCE_DEFINITION    *pInstanceDef, 
    DWORD                       dwCodePage,
    LPWSTR                      szInstanceNameToMatch,
    DWORD                       dwInstanceNameLength
);


#define FirstCounter(pObjectDef) \
    (PERF_COUNTER_DEFINITION *)((PCHAR)(pObjectDef) + (pObjectDef)->HeaderLength)

#define NextCounter(pCounterDef) \
    (PERF_COUNTER_DEFINITION *)(((pCounterDef)->ByteLength != 0) ? (PERF_COUNTER_DEFINITION *)((PCHAR)(pCounterDef) + (pCounterDef)->ByteLength) : NULL)

PERF_COUNTER_DEFINITION *
GetCounterDefByName (
    IN  PERF_OBJECT_TYPE    *pObject,
    IN  DWORD           dwLastNameIndex,
    IN  LPWSTR          *NameArray,
    IN  LPWSTR          szCounterName
);

PERF_COUNTER_DEFINITION *
GetCounterDefByTitleIndex(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  BOOL bBaseCounterDef,
    IN  DWORD CounterTitleIndex
);

LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN LPWSTR   szObjectList,
    IN BOOL     bCollectCostlyData
);

PERF_INSTANCE_DEFINITION *
GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD   dwIndex
);

__inline
LPWSTR GetInstanceName(PPERF_INSTANCE_DEFINITION  pInstDef)
{
    return (LPWSTR)((ULONG_PTR) pInstDef + pInstDef->NameOffset);
}



__inline
PVOID
GetCounterDataPtr (
    PERF_OBJECT_TYPE *pObjectDef,
    PERF_COUNTER_DEFINITION *pCounterDef
)
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pObjectDef +
                          pObjectDef->DefinitionLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

__inline
PVOID
GetInstanceCounterDataPtr (
    PERF_OBJECT_TYPE *pObjectDef,
    PERF_INSTANCE_DEFINITION *pInstanceDef,
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    PERF_COUNTER_BLOCK *pCtrBlock;

    UNREFERENCED_PARAMETER (pObjectDef);

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pInstanceDef +
                          pInstanceDef->ByteLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}


#endif //_PERFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource symbols used by pdh.rc

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pdh.rc
//
#define IDS_ERR_UNABLE_TO_CONNECT       10005
#define IDS_BRWS_NO_OBJECTS             10006
#define IDS_BRWS_NO_COUNTERS            10007
#define IDS_BRWS_NO_INSTANCES           10008
#define IDS_BRWS_ADD                    10009
#define IDS_BRWS_CLOSE                  10010
#define IDS_BRWS_OK                     10011
#define IDS_BRWS_CANCEL                 10012
#define IDS_ERR_MACHINE_NOT_IN_LOGFILE  10013
#define IDS_ERR_NO_HELP                 10014
#define IDS_DSRC_SELECT                 10015

#define IDS_LOGTYPE_PDH_LOGS            10016
#define IDS_LOGTYPE_BIN_LOGS            10017
#define IDS_LOGTYPE_CSV_LOGS            10018
#define IDS_LOGTYPE_TSV_LOGS            10019
#define IDS_LOGTYPE_PM_LOGS             10020
#define IDS_LOGTYPE_ALL_LOGS            10021
#define IDS_LOGTYPE_ALL_FILES           10022
#define IDS_PERFFILE_FRIENDLYNAME       10023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        10024
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         4003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\strings.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    String constants used by the functions in the PDH.DLL library

--*/

#ifndef _PDH_STRINGS_H_
#define _PDH_STRINGS_H_

#ifdef __cplusplus
extern "C" {
#endif

#define POUNDSIGN_L     ((WCHAR)L'#')
#define SPLAT_L         ((WCHAR)L'*')
#define SLASH_L         ((WCHAR)L'/')
#define BACKSLASH_L     ((WCHAR)L'\\')
#define LEFTPAREN_L     ((WCHAR)L'(')
#define RIGHTPAREN_L    ((WCHAR)L')')
#define SPACE_L         ((WCHAR)L' ')
#define COLON_L         ((WCHAR)L':')
#define ATSIGN_L        ((WCHAR)L'@')

#define POUNDSIGN_A     ((UCHAR)'#')
#define BACKSLASH_A     ((UCHAR)'\\')
#define DOUBLEQUOTE_A   ((UCHAR)'\"')
#define COLON_A         ((UCHAR)':')

extern LPCWSTR    cszAppShortName;

// registry path, key and value strings
extern LPCWSTR    cszNamesKey;

extern LPCWSTR    cszDefaultLangId;
extern LPCWSTR    cszCounters;
extern LPCWSTR    cszHelp;
extern LPCWSTR    cszLastHelp;
extern LPCWSTR    cszLastCounter;
extern LPCWSTR    cszVersionName;
extern LPCWSTR    cszCounterName;
extern LPCWSTR    cszHelpName;
extern LPCWSTR    cszGlobal;
extern LPCWSTR    cszCostly;
extern LPCWSTR    cszLogQueries;
extern LPCWSTR    cszLogFileType;
extern LPCWSTR    cszAutoNameInterval;
extern LPCWSTR    cszLogFileName;
extern LPCWSTR    cszLogDefaultDir;
extern LPCWSTR    cszBaseFileName;
extern LPCWSTR    cszLogFileAutoFormat;
extern LPCWSTR    cszAutoRenameUnits;
extern LPCWSTR    cszCommandFile;
extern LPCWSTR    cszCounterList;
extern LPCSTR     caszCounterList;
extern LPCWSTR    cszPerfDataLog;
extern LPCWSTR    cszDefault;
extern LPCSTR     caszDefaultLogCaption;
extern LPCWSTR    cszPerfNamePathPrefix;
extern LPCWSTR    cszDat;
extern LPCWSTR    cszWBEM;
extern LPCWSTR    cszWMI;
extern LPCWSTR    cszSQL;
extern LPCSTR     caszWBEM;
extern LPCSTR     caszWMI;
extern LPCWSTR    cszWbemDefaultPerfRoot;
extern LPCWSTR    cszSingletonInstance;
extern LPCWSTR    cszNameParam;
extern LPCWSTR    cszCountertype;
extern LPCWSTR    cszDisplayname;
extern LPCWSTR    cszExplainText;
extern LPCWSTR    cszSingleton;
extern LPCWSTR    cszPerfdetail;
extern LPCWSTR    cszPerfdefault;
extern LPCWSTR    cszDefaultscale;
extern LPCWSTR    cszClass;
extern LPCWSTR    cszPerfRawData;
extern LPCWSTR    cszNotFound;
extern LPCWSTR    cszName;
extern LPCWSTR    cszBaseSuffix;
extern LPCWSTR    cszTimestampPerfTime;
extern LPCWSTR    cszFrequencyPerfTime;
extern LPCWSTR    cszTimestampSys100Ns;
extern LPCWSTR    cszFrequencySys100Ns;
extern LPCWSTR    cszTimestampObject;
extern LPCWSTR    cszFrequencyObject;
extern LPCWSTR    cszPerfmonLogSig;

extern LPCWSTR    cszRemoteMachineRetryTime;
extern LPCWSTR    cszEnableRemotePdhAccess;
extern LPCWSTR    cszPdhKey;
extern LPCWSTR    cszDefaultNullDataSource;
extern LPCWSTR    cszLogSectionName;
extern LPCWSTR    cszCurrentVersionKey;
extern LPCWSTR    cszCurrentVersionValueName;

extern LPCWSTR    fmtDecimal;
extern LPCWSTR    fmtSpaceDecimal;
extern LPCWSTR    fmtLangId;

// single character strings
extern LPCWSTR    cszEmptyString;
extern LPCWSTR    cszPoundSign;
extern LPCWSTR    cszSplat;
extern LPCWSTR    cszSlash;
extern LPCWSTR    cszBackSlash;
extern LPCWSTR    cszLeftParen;
extern LPCWSTR    cszRightParen;
extern LPCWSTR    cszC;
extern LPCWSTR    cszH;
extern LPCWSTR    cszColon;
extern LPCWSTR    cszDoubleQuote;

extern LPCSTR     caszPoundSign;
extern LPCSTR     caszSplat;
extern LPCSTR     caszSlash;
extern LPCSTR     caszBackSlash;
extern LPCSTR     caszDoubleBackSlash;
extern LPCSTR     caszLeftParen;
extern LPCSTR     caszRightParen;
extern LPCSTR     caszSpace;

extern LPCWSTR    cszDoubleBackSlash;
extern LPCWSTR    cszDoubleBackSlashDot;
extern LPCWSTR    cszRightParenBackSlash;

// other general strings
extern LPCWSTR    cszSpacer;
extern LPCWSTR    cszBlg;

// strings only used in DEBUG builds
#ifdef _DEBUG
extern LPCWSTR    cszNameDontMatch;
extern LPCWSTR    cszNotice;
#endif

#ifdef __cplusplus
}
#endif

#endif //_PDH_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhcalc\calcfuns.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    calcfuns.c

Abstract:

    Counter calculation functions

--*/

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <pdh.h>
#include "pdhicalc.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"

BOOL
AssignCalcFunction (
    IN      DWORD   dwCounterType,
    IN      LPCOUNTERCALC   *pCalcFunc,
    IN      LPCOUNTERSTAT   *pStatFunc
)
{
    BOOL    bReturn = TRUE;

    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    if (pCalcFunc == NULL || pStatFunc == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        return FALSE;
    }
    else {
        __try {
            * pCalcFunc = PdhiCalcNoData;
            * pStatFunc = PdhiComputeNoDataStats;
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }
    }

    switch (dwCounterType) {
        case PERF_DOUBLE_RAW:
            *pCalcFunc = PdhiCalcDouble;
            *pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_AVERAGE_TIMER:
            *pCalcFunc = PdhiCalcAverage;
            *pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_ELAPSED_TIME:
            *pCalcFunc = PdhiCalcElapsedTime;
            *pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_RAW_FRACTION:
        case PERF_LARGE_RAW_FRACTION:
            *pCalcFunc = PdhiCalcRawFraction;
            *pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_SAMPLE_COUNTER:
            *pCalcFunc = PdhiCalcCounter;
            *pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_AVERAGE_BULK:
        case PERF_COUNTER_TIMER:
        case PERF_100NSEC_TIMER:
        case PERF_OBJ_TIME_TIMER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
        case PERF_SAMPLE_FRACTION:
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER:
        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
            *pCalcFunc = PdhiCalcTimer;
            *pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_COUNTER_TIMER_INV:
        case PERF_100NSEC_TIMER_INV:
        case PERF_COUNTER_MULTI_TIMER_INV:
        case PERF_100NSEC_MULTI_TIMER_INV:
            *pCalcFunc = PdhiCalcInverseTimer;
            *pStatFunc = PdhiComputeFirstLastStats;
            break;

        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            *pCalcFunc = PdhiCalcRawCounter;
            *pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_DELTA:
        case PERF_COUNTER_LARGE_DELTA:
            *pCalcFunc = PdhiCalcDelta;
            *pStatFunc = PdhiComputeRawCountStats;
            break;

        case PERF_COUNTER_TEXT:
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        //case PERF_LARGE_RAW_BASE:
        case PERF_COUNTER_HISTOGRAM_TYPE:
        case PERF_COUNTER_NODATA:
        case PERF_PRECISION_TIMESTAMP:
            *pCalcFunc = PdhiCalcNoData;
            *pStatFunc = PdhiComputeNoDataStats;
            break;

        default:
            // an unrecognized counter type. Define the function, but
            // return false.
            *pCalcFunc = PdhiCalcNoData;
            *pStatFunc = PdhiComputeNoDataStats;
            SetLastError (PDH_FUNCTION_NOT_FOUND);
            bReturn = FALSE;
            break;
    }
    return bReturn;
}

double
APIENTRY
PdhiCalcDouble (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    double  dReturn;
    DWORD   dwStatus;

    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    dReturn = *(DOUBLE *)&pThisValue->FirstValue;

    if (dReturn < 0) {
        dReturn = 0.0f;
        dwStatus = PDH_CSTATUS_INVALID_DATA;
    } else {
        dwStatus = pThisValue->CStatus;
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }

    return dReturn;
}

double
APIENTRY
PdhiCalcAverage (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llNumDiff;
    LONGLONG    llDenDiff = 0;
    double      dNum;
    double      dDen;
    double      dReturn = 0.0f;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            } else {
                dwStatus = pLastValue->CStatus;
            }
        } else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if ((llDenDiff > 0) && (*pllTimeBase > 0)) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff > 0) {
                dNum = (double)llNumDiff;
                dNum /= (double)*pllTimeBase;

                dDen = (double)llDenDiff;

                dReturn = (dNum / dDen);
            } else if (llNumDiff != 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        } else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            } else if (*pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcElapsedTime (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llDiff;
    double      dReturn = 0.0f;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pLastValue);
    // test access to the required second parameter (lastValue)
    __try {
        if (IsSuccessSeverity(pThisValue->CStatus)) {
            llDiff = pThisValue->SecondValue - pThisValue->FirstValue;
        } else {
            dwStatus = pThisValue->CStatus;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {
        if (*pllTimeBase > 0) {
            llDiff = pThisValue->SecondValue - pThisValue->FirstValue;
            if (llDiff > 0) {
                dReturn = (double)llDiff;
                dReturn /= (double)*pllTimeBase;
            } else {
                if (llDiff < 0) {
                    dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
                }
            }
        } else {
            if (*pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }

    return dReturn;
}

double
APIENTRY
PdhiCalcRawFraction (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llDen;
    double      dReturn = 0.0f;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    if ((llDen = pThisValue->SecondValue) > 0) {
        dReturn = (double)(pThisValue->FirstValue);
        dReturn /= (double)llDen;
    } else {
        if (llDen < 0) {
            dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
        }
        dReturn = (double)0.0;
    }
    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcCounter (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llNumDiff;
    LONGLONG    llDenDiff = 0;
    double      dNum;
    double      dDen;
    double      dReturn = 0.0f;
    double      dMulti;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            } else {
                dwStatus = pLastValue->CStatus;
            }
        } else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {

        if ((llDenDiff > 0) && (*pllTimeBase)) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff > 0) {
                dNum = (double)llNumDiff;
                dDen = (double)llDenDiff;
                dDen /= (double)*pllTimeBase;
                dReturn = (dNum / dDen);
                if (pThisValue->MultiCount > 1) {
                    // don't do this if the count is <= 1
                    dMulti = (double) pThisValue->FirstValue;
                    dReturn /= dMulti;
                }
            } else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            } else {
                // just return 0 & normal status
            }
        } else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            } else if (*pllTimeBase < 0) {
                dwStatus = PDH_CALC_NEGATIVE_TIMEBASE;
            }
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcTimer (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llNumDiff;
    LONGLONG    llDenDiff = 0;
    double      dReturn = 0.0f;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);

    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            } else {
                dwStatus = pLastValue->CStatus;
            }
        } else {
            // the last value wasn't passed in
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {

        if (llDenDiff > 0) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff > 0) {
                dReturn = (double)llNumDiff;
                dReturn /= (double)llDenDiff;
                if (pThisValue->MultiCount > 1) {
                    // don't do this if the count is <= 1
                    dReturn /= (double)pThisValue->MultiCount;
                }
            } else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            } else {
                // just return 0 and a normal status
            }
        } else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }

    return dReturn;
}

double
APIENTRY
PdhiCalcInverseTimer (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llNumDiff;
    LONGLONG    llDenDiff = 0;
    double      dReturn = 0.0f;
    double      dNumDiff, dDenDiff;
    double      dRatio;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);
    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llDenDiff = pThisValue->SecondValue - pLastValue->SecondValue;
            } else {
                dwStatus = pLastValue->CStatus;
            }
        } else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {

        if (llDenDiff > 0) {
            llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            if (llNumDiff >= 0) {

                dNumDiff = (double)llNumDiff;
                dDenDiff = (double)llDenDiff;
                dRatio = dNumDiff;
                dRatio /= dDenDiff;

                if (pThisValue->MultiCount <= 1) {
                    dReturn = (double)1.0;
                } else {
                    dReturn = (double)pThisValue->MultiCount;
                }
                // subtract the result from the multi count to get the
                // "inverse" time
                dReturn -= dRatio;

                if (dReturn < (double)0.0) {
                    // allow a "fudge" factor before reporting errors
                    if (dReturn < (double)(-0.1)) {
                        dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
                    }
                    dReturn = (double)0.0;
                }

            } else if (llNumDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_VALUE;
            }
        } else {
            if (llDenDiff < 0) {
                dwStatus = PDH_CALC_NEGATIVE_DENOMINATOR;
            }
            dReturn = (double)0.0;
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }
    return dReturn;
}

double
APIENTRY
PdhiCalcRawCounter (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    if (pdwStatus != NULL) {
        *pdwStatus = pThisValue->CStatus;
    }
    return (double)pThisValue->FirstValue;
}

double
APIENTRY
PdhiCalcNoData (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    UNREFERENCED_PARAMETER(pThisValue);
    UNREFERENCED_PARAMETER(pLastValue);
    UNREFERENCED_PARAMETER(pllTimeBase);

    if (pdwStatus != NULL) {
        *pdwStatus = PDH_NO_DATA;
    }
    return (double)0.0;
}

double
APIENTRY
PdhiCalcDelta (
    PPDH_RAW_COUNTER            pThisValue,
    PPDH_RAW_COUNTER            pLastValue,
    LONGLONG                    *pllTimeBase,
    LPDWORD                     pdwStatus
)
{
    LONGLONG    llNumDiff = 0;
    double      dReturn = 0.0f;
    DWORD       dwStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(pllTimeBase);
    // test access to the required second parameter (lastValue)
    __try {
        if (pLastValue != NULL) {
            if (IsSuccessSeverity(pLastValue->CStatus)) {
                llNumDiff = pThisValue->FirstValue - pLastValue->FirstValue;
            } else {
                dwStatus = pLastValue->CStatus;
            }
        } else {
            dwStatus = PDH_CSTATUS_INVALID_DATA;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwStatus = PDH_INVALID_ARGUMENT;
    }

    if (dwStatus == PDH_CSTATUS_VALID_DATA) {

        if (llNumDiff < 0) {
            dwStatus = PDH_CALC_NEGATIVE_VALUE;
            dReturn = (double)0.0;
        } else {
            dReturn = (double)llNumDiff;
        }
    }

    if (pdwStatus != NULL) {
        *pdwStatus = dwStatus;
    }

    return dReturn;
}

PDH_STATUS
PdhiComputeFormattedValue (
    IN      LPCOUNTERCALC       pCalcFunc,
    IN      DWORD               dwCounterType,
    IN      LONG                lScale,
    IN      DWORD               dwFormat,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PLONGLONG           pTimeBase,
    IN      DWORD               dwReserved,
    IN      PPDH_FMT_COUNTERVALUE   pValue
)
{
    double      dResult = (double)0.0;
    double      dScale;
    PDH_STATUS  lStatus = ERROR_SUCCESS;
    DWORD       dwValueStatus = PDH_CSTATUS_VALID_DATA;

    UNREFERENCED_PARAMETER(dwReserved);

    __try {
        // make sure the counter values are valid before continuing

        if (pRawValue1 != NULL) {
            if ((pRawValue1->CStatus != PDH_CSTATUS_NEW_DATA) &&
                (pRawValue1->CStatus != PDH_CSTATUS_VALID_DATA)) {
                dwValueStatus = pRawValue1->CStatus;
                lStatus = PDH_INVALID_DATA;
            }
        } else {
            // this is a required parameter
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus = PDH_INVALID_ARGUMENT;
        }

        if ((lStatus == ERROR_SUCCESS) && (pRawValue2 != NULL)) {
            // this is an optional parameter, but if present, it must be valid
            if ((pRawValue2->CStatus != PDH_CSTATUS_NEW_DATA) &&
                (pRawValue2->CStatus != PDH_CSTATUS_VALID_DATA)) {
                dwValueStatus = pRawValue2->CStatus;
                lStatus = PDH_INVALID_DATA;
            }
        }

        if (   ((dwFormat & PDH_FMT_LONG) != 0)
            && ((dwFormat & PDH_FMT_LARGE) != 0)) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        else if (   ((dwFormat & PDH_FMT_LONG) != 0)
                 || ((dwFormat & PDH_FMT_LARGE) != 0)) {
            if (dwFormat & PDH_FMT_DOUBLE) {
                dwValueStatus = PDH_CSTATUS_INVALID_DATA;
                lStatus       = PDH_INVALID_ARGUMENT;
            }
        }

        if (lScale > PDH_MAX_SCALE || lScale < PDH_MIN_SCALE) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        if (pTimeBase == NULL) {
            dwValueStatus = PDH_CSTATUS_INVALID_DATA;
            lStatus       = PDH_INVALID_ARGUMENT;
        }
        else {
            LONGLONG tmpTimeBase = * pTimeBase;
            * pTimeBase = tmpTimeBase;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        dwValueStatus = PDH_CSTATUS_INVALID_DATA;
        lStatus = PDH_INVALID_ARGUMENT;
    }

    if (lStatus == ERROR_SUCCESS) {
        // call the counter's calculation function if the raw value is valid

        if (IsSuccessSeverity(pRawValue1->CStatus)) {

            __try {
                dResult = (*pCalcFunc)(
                    pRawValue1,
                    pRawValue2,
                    pTimeBase,
                    &dwValueStatus);


                // format returned value

                if ((dwCounterType & 0xF0000000) == PERF_DISPLAY_PERCENT) {
                    // scale to show percent
                    dResult *= (double)100.0;
                    // this should probably be controlled by a registry
                    // value as is the case with PERFMON
                    if (!(dwFormat & PDH_FMT_NOCAP100)) {
                        if (dResult > (double)100.0) dResult = (double)100.0;
                    }
                }

                if (!(dwFormat & PDH_FMT_NOSCALE)) {
                    //now scale
                    dScale = pow (10.0, (double)lScale);
                    dResult *= dScale;
                }

                if (dwFormat & PDH_FMT_1000) {
                    //now scale
                    dResult *= (double)1000.0;
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                // something failed
                dResult = (double)0.0;
                dwValueStatus = PDH_INVALID_ARGUMENT;
            }
        } else {
            dwValueStatus = pRawValue1->CStatus;
        }

        if (!IsSuccessSeverity(dwValueStatus)) {
            // an error occured so pass that on to the caller
            lStatus = dwValueStatus;
        }
    } //end if valid counter data

    // now format
    __try {
        if (dwFormat & PDH_FMT_LONG) {
            pValue->longValue = (LONG)dResult;
        } else if (dwFormat & PDH_FMT_LARGE) {
            pValue->largeValue = (LONGLONG)dResult;
        } else {
            // double is the default
            pValue->doubleValue = dResult;
        }
        pValue->CStatus = dwValueStatus;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = PDH_INVALID_ARGUMENT;
    }

    return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\inc\wbemdef.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

    wbemdef.h

Abstract:

    data types and other declarations used internally by the 
    Data Provider Helper functions for interface with WBEM data 
    providers

--*/

#ifndef _PDHI_WBEM_DEF_H_
#define _PDHI_WBEM_DEF_H_

#include <windows.h>
#include <wbemcli.h>
#include <wbemprov.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PDHI_WBEM_OBJECT_DEF {
    struct _PDHI_WBEM_OBJECT_DEF * pNext;
    LPWSTR                  szObject;
    LPWSTR                  szDisplay; 
    BOOL                    bDefault;
    IWbemClassObject      * pClass;
} PDHI_WBEM_OBJECT_DEF, * PPDHI_WBEM_OBJECT_DEF;
    
typedef struct _PDHI_WBEM_SERVER_DEF {
    struct _PDHI_WBEM_SERVER_DEF * pNext;
    LPWSTR                  szMachine;  // includes namespace
    DWORD                   dwCache;
    IWbemServices         * pSvc;
    LONG                    lRefCount;
    PPDHI_WBEM_OBJECT_DEF   pObjList;
} PDHI_WBEM_SERVER_DEF, * PPDHI_WBEM_SERVER_DEF;

extern PPDHI_WBEM_SERVER_DEF pFirstWbemServer;

#ifdef __cplusplus
}
#endif

#endif //_PDHI_WBEM_DEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhcalc\statfuns.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statfuns.c

Abstract:

    Statistical calculation functions

--*/

#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <pdh.h> 
#include "pdhicalc.h"
#include "pdhitype.h"
#include "pdhmsg.h"


#define PDHI_FMT_FILTER     (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE)

PDH_STATUS
APIENTRY
PdhiComputeFirstLastStats (
    IN      PPDHI_COUNTER       pCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
)
{
    DOUBLE  dThisValue = (double)0.0;
    DOUBLE  dMin = (double)+10E8;    // these are just "big" seed numbers
    DOUBLE  dMax = (double)-10E8;    
    DOUBLE  dMean = (double)0.0;
    BOOLEAN bFirstItem = TRUE;

    DWORD   dwItem;
    DWORD   dwValidItemCount = 0;
    DWORD   dwFirstValidItem = 0;
    DWORD   dwLastValidItem = 0;
    DWORD   dwComputeFormat;

    PPDH_RAW_COUNTER pNewCounter;
    PPDH_RAW_COUNTER pOldCounter;
    
    PDH_FMT_COUNTERVALUE    fmtValue;

    DWORD   cStatusReturn;

    __try {
        // initialize th user's data buffer
        data->dwFormat = 0;
        data->count = 0;
        data->min.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->min.largeValue = 0;
        data->max.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->max.largeValue = 0;
        data->mean.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->mean.largeValue = 0;

        // find first valid counter in array
        dwItem = dwFirstEntry;
        pNewCounter = NULL;
        pOldCounter = &lpRawValueArray[dwItem];
        do {
            // get value of this instance if next counter is valid
            if ((pOldCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                (pOldCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                pNewCounter = pOldCounter;
                dwFirstValidItem = dwItem;
                break;
            } else {
                dwItem = ++dwItem % dwNumEntries;
                pOldCounter = &lpRawValueArray[dwItem];
            }
        } while (dwItem != dwFirstEntry);
        
        // do calculations in Floating point format
        dwComputeFormat = dwFormat;
        dwComputeFormat &= ~PDHI_FMT_FILTER;
        dwComputeFormat |= PDH_FMT_DOUBLE | PDH_FMT_NOCAP100;

        // go to next entry to begin processing
        dwItem = ++dwItem % dwNumEntries;
        pNewCounter = &lpRawValueArray[dwItem];

        // these counters need 2 or more entrys to compute values from
        if ((dwItem != dwFirstEntry) && (dwNumEntries > 1)) {
            // start record found so initialize and continue
            dwLastValidItem = dwItem;

            // step through the remaining entries

            while (dwItem != dwFirstEntry) {
                // get value of this instance if next counter is valid
                if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                    (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {

                    // record this as a valid counter
                    dwLastValidItem = dwItem;

                    // get current value
                    cStatusReturn = PdhiComputeFormattedValue (
                            pCounter->CalcFunc,
                            pCounter->plCounterInfo.dwCounterType,
                            pCounter->lScale,
                            dwComputeFormat,
                            pNewCounter,
                            pOldCounter,
                            & pCounter->TimeBase,
                            0L,
                            & fmtValue);
                    if (cStatusReturn == ERROR_SUCCESS) {
                        dThisValue = fmtValue.doubleValue;

                        // update min & max
                        if (bFirstItem) {
                            dMax = dMin = dThisValue;
                            bFirstItem = FALSE;
                        }
                        else {
                            if (dThisValue > dMax) dMax = dThisValue;
                            if (dThisValue < dMin) dMin = dThisValue;
                        }
                        dwValidItemCount++;
                    }
                }
                pOldCounter = pNewCounter;
                dwItem = ++dwItem % dwNumEntries;
                pNewCounter = &lpRawValueArray[dwItem];
            }
            // compute average
            if (dwValidItemCount > 0) {
                pOldCounter = &lpRawValueArray[dwFirstValidItem];
                pNewCounter = &lpRawValueArray[dwLastValidItem];

                cStatusReturn = PdhiComputeFormattedValue (
                    pCounter->CalcFunc,
                    pCounter->plCounterInfo.dwCounterType,
                    pCounter->lScale,
                    dwComputeFormat,
                    pNewCounter,
                    pOldCounter,
                    &pCounter->TimeBase,
                    0L,
                    &fmtValue);
                if (cStatusReturn == ERROR_SUCCESS) {
                    dMean = fmtValue.doubleValue;
                    cStatusReturn = PDH_CSTATUS_VALID_DATA;
                }
                else {
                    dMean = 0.0;
                }
            } else {
                dMean = 0.0;
                dMax = 0.0;
                dMin = 0.0;
                cStatusReturn = PDH_CSTATUS_INVALID_DATA;
            }
            
        } else {
            // array does not contain a valid counter so exit
            dMean = 0.0;
            dMax = 0.0;
            dMin = 0.0;
            cStatusReturn = PDH_CSTATUS_INVALID_DATA;
        }

        // update user's buffer with new data
        data->dwFormat = dwFormat;
        data->count = dwValidItemCount;
        data->min.CStatus = cStatusReturn;
        data->max.CStatus = cStatusReturn;
        data->mean.CStatus = cStatusReturn;
        switch ((dwFormat & PDHI_FMT_FILTER)) {
            case PDH_FMT_LONG:
                if (dMin > (DOUBLE) MAXLONG) {
                    data->min.longValue = MAXLONG;
                    data->min.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.longValue = (long) dMin;
                }
                if (dMax > (DOUBLE) MAXLONG) {
                    data->max.longValue = MAXLONG;
                    data->max.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.longValue = (long) dMax;
                }
                if (dMean > (DOUBLE) MAXLONG) {
                    data->mean.longValue = MAXLONG;
                    data->mean.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.longValue = (long) dMean;
                }
                break;

            case PDH_FMT_DOUBLE:
                data->min.doubleValue = dMin;
                data->max.doubleValue = dMax;
                data->mean.doubleValue = dMean;
                break;

            case PDH_FMT_LARGE:
            default:
                if (dMin > (DOUBLE) MAXLONGLONG) {
                    data->min.largeValue = MAXLONGLONG;
                    data->min.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.largeValue = (LONGLONG) dMin;
                }
                if (dMax > (DOUBLE) MAXLONGLONG) {
                    data->max.largeValue = MAXLONGLONG;
                    data->max.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.largeValue = (LONGLONG) dMax;
                }
                if (dMean > (DOUBLE) MAXLONGLONG) {
                    data->mean.largeValue = MAXLONGLONG;
                    data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.largeValue = (LONGLONG) dMean;
                }
                break;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return PDH_INVALID_ARGUMENT;
    } 
    return ERROR_SUCCESS;
}

PDH_STATUS
APIENTRY
PdhiComputeRawCountStats (
    IN      PPDHI_COUNTER       pCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
)
{
    DOUBLE  dThisValue = (double)0.0;
    DOUBLE  dMin = (double)+10E8;    // these are just "big" seed numbers
    DOUBLE  dMax = (double)-10E8;    
    DOUBLE  dMean = (double)0.0;
    BOOLEAN bFirstItem = TRUE;
    DOUBLE  dScale;

    DWORD   dwItem;
    DWORD   dwValidItemCount = 0;
    DWORD   dwFirstValidItem = 0;
    DWORD   dwLastValidItem = 0;
    DWORD   dwComputeFormat;

    PPDH_RAW_COUNTER pNewCounter;
    PPDH_RAW_COUNTER pOldCounter = NULL;
    
    PDH_FMT_COUNTERVALUE    fmtValue;

    DWORD   cStatusReturn;

    UNREFERENCED_PARAMETER (dwFirstEntry);
    __try {
        // initialize the user's data buffer
        data->dwFormat = 0;
        data->count = 0;
        data->min.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->min.largeValue = 0;
        data->max.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->max.largeValue = 0;
        data->mean.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->mean.largeValue = 0;

        // find first valid counter in array
        dwItem = 0;
        pNewCounter = lpRawValueArray;
        while (dwItem < dwNumEntries) {
            // get value of this instance if next counter is valid
            if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                break;
            } else {
                pOldCounter = pNewCounter;
                pNewCounter++;
                dwItem++;
            }
        }
        
        // do calculations in Floating point format
        dwComputeFormat = dwFormat;
        dwComputeFormat &= ~PDHI_FMT_FILTER;
        dwComputeFormat |= PDH_FMT_DOUBLE | PDH_FMT_NOCAP100;

        if ((dwItem != dwNumEntries) && (dwNumEntries > 0)) {
            // start record found so continue
            dwFirstValidItem = dwItem;

            // step through the remaining entries

            while (dwItem < dwNumEntries) {
                // get value of this instance if next counter is valid
                if ((pNewCounter->CStatus == PDH_CSTATUS_VALID_DATA) ||
                    (pNewCounter->CStatus == PDH_CSTATUS_NEW_DATA)) {
                    dwLastValidItem = dwItem;

                    cStatusReturn = PdhiComputeFormattedValue (
                            pCounter->CalcFunc,
                            pCounter->plCounterInfo.dwCounterType,
                            pCounter->lScale,
                            dwComputeFormat,
                            pNewCounter,
                            pOldCounter,
                            & pCounter->TimeBase,
                            0L,
                            & fmtValue);
                    if (cStatusReturn == ERROR_SUCCESS) {
                        dThisValue = fmtValue.doubleValue;

                        if (bFirstItem) {
                            dMin = dMax = dThisValue;
                            bFirstItem = FALSE;
                        }
                        else {
                            if (dThisValue > dMax) dMax = dThisValue;
                            if (dThisValue < dMin) dMin = dThisValue;
                        }
                        dMean += dThisValue;

                        dwValidItemCount ++;
                    }
                }
                pOldCounter = pNewCounter;
                pNewCounter++;
                dwItem++;
            }
            // compute average
            if (dwValidItemCount > 0) {
                dMean /= (double)dwValidItemCount;

                if (!(dwFormat & PDH_FMT_NOSCALE)) {
                    //now scale
                    dScale = pow (10.0, (double)pCounter->lScale);
                    dMean *= dScale;
                    dMin *= dScale;
                    dMax *= dScale;
                }
                cStatusReturn = PDH_CSTATUS_VALID_DATA;
            } else {
                dMean = 0.0;
                dMax = 0.0;
                dMin = 0.0;
                cStatusReturn = PDH_CSTATUS_INVALID_DATA;
            }
            
        } else {
            // array does not contain a valid counter so exit
            dMean = 0.0;
            dMax = 0.0;
            dMin = 0.0;
            cStatusReturn = PDH_CSTATUS_INVALID_DATA;
        }

        // update user's buffer with new data
        data->dwFormat = dwFormat;
        data->count = dwValidItemCount;
        data->min.CStatus = cStatusReturn;
        data->max.CStatus = cStatusReturn;
        data->mean.CStatus = cStatusReturn;
        switch ((dwFormat & PDHI_FMT_FILTER)) {
            case PDH_FMT_LONG:
                if (dMin > (DOUBLE) MAXLONG) {
                    data->min.longValue = MAXLONG;
                    data->min.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.longValue = (long) dMin;
                }
                if (dMax > (DOUBLE) MAXLONG) {
                    data->max.longValue = MAXLONG;
                    data->max.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.longValue = (long) dMax;
                }
                if (dMean > (DOUBLE) MAXLONG) {
                    data->mean.longValue = MAXLONG;
                    data->mean.CStatus   = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.longValue = (long) dMean;
                }
                break;

            case PDH_FMT_DOUBLE:
                data->min.doubleValue = dMin;
                data->max.doubleValue = dMax;
                data->mean.doubleValue = dMean;
                break;

            case PDH_FMT_LARGE:
            default:
                if (dMin > (DOUBLE) MAXLONGLONG) {
                    data->min.largeValue = MAXLONGLONG;
                    data->min.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->min.largeValue = (LONGLONG) dMin;
                }
                if (dMax > (DOUBLE) MAXLONGLONG) {
                    data->max.largeValue = MAXLONGLONG;
                    data->max.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->max.largeValue = (LONGLONG) dMax;
                }
                if (dMean > (DOUBLE) MAXLONGLONG) {
                    data->mean.largeValue = MAXLONGLONG;
                    data->mean.CStatus    = PDH_CSTATUS_INVALID_DATA;
                }
                else {
                    data->mean.largeValue = (LONGLONG) dMean;
                }
                break;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return PDH_INVALID_ARGUMENT;
    } 
    return ERROR_SUCCESS;
}

PDH_STATUS
APIENTRY
PdhiComputeNoDataStats (
    IN      PPDHI_COUNTER       pCounter,
    IN      DWORD               dwFormat,
    IN      DWORD               dwFirstEntry,
    IN      DWORD               dwNumEntries,
    IN      PPDH_RAW_COUNTER    lpRawValueArray,
    IN      PPDH_STATISTICS     data
)
{
    UNREFERENCED_PARAMETER (pCounter);
    UNREFERENCED_PARAMETER (dwFirstEntry);
    UNREFERENCED_PARAMETER (dwNumEntries);
    UNREFERENCED_PARAMETER (lpRawValueArray);
    __try {
        data->dwFormat = dwFormat;
        data->count = 0;
        data->min.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->max.CStatus = PDH_CSTATUS_INVALID_DATA;
        data->mean.CStatus = PDH_CSTATUS_INVALID_DATA;
        switch ((dwFormat & PDHI_FMT_FILTER)) {
            case PDH_FMT_LONG:
                data->min.doubleValue = 0;
                data->max.longValue = 0;
                data->mean.longValue = 0;
                break;

            case PDH_FMT_DOUBLE:
                data->min.doubleValue = (double)0;
                data->max.doubleValue = (double)0;
                data->mean.doubleValue = (double)0.0;
                break;

            case PDH_FMT_LARGE:
            default:
                data->min.largeValue = 0;
                data->max.largeValue = 0;
                data->mean.largeValue = 0;
                break;
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return PDH_INVALID_ARGUMENT;
    } 
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\makefile.inc ===
PRIVLIB= $(O)\pdhp.lib
$(O)\pdh.lib : $(PRIVLIB)


$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\pdhp.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\pdhp.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\pdhp.def: pdh.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\cutils.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    cutils.c

Abstract:

    Counter management utility functions

--*/

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "perfdata.h"
#include "pdhmsg.h"
#include "strings.h"

BOOL
IsValidCounter (
    IN  HCOUNTER  hCounter
)
/*++

Routine Description:

    examines the counter handle to verify it is a valid counter. For now
        the test amounts to:
            the Handle is NOT NULL
            the memory is accessible (i.e. it doesn't AV)
            the signature array is valid
            the size field is correct

        if any tests fail, the handle is presumed to be invalid

Arguments:

    IN  HCOUNTER  hCounter
        the handle of the counter to test

Return Value:

    TRUE    the handle passes all the tests
    FALSE   one of the test's failed and the handle is not a valid counter

--*/
{
    BOOL    bReturn = FALSE;    // assume it's not a valid query
    PPDHI_COUNTER  pCounter;
#if DBG
    LONG    lStatus = ERROR_SUCCESS;
#endif

    __try {
        if (hCounter != NULL) {
            // see if a valid signature
            pCounter = (PPDHI_COUNTER)hCounter;
            if ((*(DWORD *)&pCounter->signature[0] == SigCounter) &&
                 (pCounter->dwLength == sizeof (PDHI_COUNTER))){
                bReturn = TRUE;
            } else {
                // this is not a valid counter because the sig is bad
            }
        } else {
            // this is not a valid counter because the handle is NULL
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
#if DBG
        lStatus = GetExceptionCode();
#endif
    }
    return bReturn;
}

BOOL
InitCounter (
    IN      PPDHI_COUNTER pCounter
)
/*++

Routine Description:

    Initialized the counter data structure by:
        Allocating the memory block to contain the counter structure
            and all the associated data fields. If this allocation
            is successful, then the fields are initialized by
            verifying the counter is valid.

Arguments:

    IN      PPDHI_COUNTER pCounter
        pointer of the counter to initialize using the system data

Return Value:

    TRUE if the counter was successfully initialized
    FALSE if a problem was encountered

    In either case, the CStatus field of the structure is updated to
    indicate the status of the operation.

--*/
{
    PPERF_MACHINE   pMachine = NULL;
    DWORD   dwBufferSize = MEDIUM_BUFFER_SIZE;
    DWORD   dwOldSize;
    BOOL    bInstances = FALSE;
    LPVOID  pLocalCounterPath = NULL;
    BOOL    bReturn = TRUE;
    LONG    lOffset;

    // reset the last error value
    pCounter->ThisValue.CStatus = ERROR_SUCCESS;
    SetLastError (ERROR_SUCCESS);

    if (pCounter->szFullName != NULL) {
        // allocate counter path buffer
        if (pCounter->pCounterPath != NULL) {
            __try {
                G_FREE(pCounter->pCounterPath);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                // no need to do anything
            }
            pCounter->pCounterPath = NULL;
        }
        pLocalCounterPath = G_ALLOC (dwBufferSize);
        if (pLocalCounterPath == NULL) {
            // could not allocate string buffer
            pCounter->ThisValue.CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            bReturn = FALSE;
        } else {
            dwOldSize = dwBufferSize;
            if (ParseFullPathNameW (pCounter->szFullName,
                    &dwBufferSize,
                    pLocalCounterPath, FALSE)) {
                // resize to only the space required
                assert(pCounter->pCounterPath == NULL);
                if (dwOldSize < dwBufferSize) {
                    pCounter->pCounterPath = G_REALLOC (
                        pLocalCounterPath, dwBufferSize);
                }
                else {
                    pCounter->pCounterPath = pLocalCounterPath;
                }

                if (pCounter->pCounterPath != NULL) {
                    if (pLocalCounterPath != pCounter->pCounterPath) { // ???
                        // the memory block moved so
                        // correct addresses inside structure
                        lOffset = (LONG)((ULONG_PTR)pCounter->pCounterPath - (ULONG_PTR)pLocalCounterPath);
                        if (pCounter->pCounterPath->szMachineName) {
                            pCounter->pCounterPath->szMachineName = (LPWSTR)(
                                (LPBYTE)pCounter->pCounterPath->szMachineName + lOffset);
                        }
                        if (pCounter->pCounterPath->szObjectName) {
                            pCounter->pCounterPath->szObjectName = (LPWSTR)(
                                (LPBYTE)pCounter->pCounterPath->szObjectName + lOffset);
                        }
                        if (pCounter->pCounterPath->szInstanceName) {
                            pCounter->pCounterPath->szInstanceName = (LPWSTR)(
                                (LPBYTE)pCounter->pCounterPath->szInstanceName + lOffset);
                        }
                        if (pCounter->pCounterPath->szParentName) {
                            pCounter->pCounterPath->szParentName = (LPWSTR)(
                                (LPBYTE)pCounter->pCounterPath->szParentName + lOffset);
                        }
                        if (pCounter->pCounterPath->szCounterName) {
                            pCounter->pCounterPath->szCounterName = (LPWSTR)(
                                (LPBYTE)pCounter->pCounterPath->szCounterName + lOffset);
                        }
                    }

                    if (pCounter->pOwner->hLog == NULL) {
                        // validate realtime counter
                        // try to connect to machine and get machine pointer

                        pMachine = GetMachine (pCounter->pCounterPath->szMachineName,
                            PDH_GM_UPDATE_NAME);

                        if (pMachine != NULL) {
                            if (pMachine->dwStatus == ERROR_SUCCESS) {
                                // init raw counter value
                                memset (&pCounter->ThisValue, 0, sizeof(pCounter->ThisValue));
                                memset (&pCounter->LastValue, 0, sizeof(pCounter->LastValue));

                                // look up object name
                                pCounter->plCounterInfo.dwObjectId = GetObjectId (
                                    pMachine,
                                    pCounter->pCounterPath->szObjectName,
                                    &bInstances);

                                if (pCounter->plCounterInfo.dwObjectId == (DWORD)-1) {
                                    // only check costly objects by default on NT v>=5.0
                                    if ((!(pMachine->dwMachineFlags & PDHIPM_FLAGS_HAVE_COSTLY)) && 
                                        (pMachine->szOsVer[0] >= L'5')) {
                                        // reconnect to machine and get the costly objects to
                                        // see if the desired ID is in that list
                                        pMachine = GetMachine (pCounter->pCounterPath->szMachineName,
                                            (PDH_GM_UPDATE_NAME | PDH_GM_READ_COSTLY_DATA |
                                            PDH_GM_UPDATE_PERFDATA));
                                        if (pMachine != NULL) {
                                            if (pMachine->dwStatus == ERROR_SUCCESS) {
                                                // machine found ok, so
                                                // try object ID lookup again
                                                pCounter->plCounterInfo.dwObjectId = GetObjectId (
                                                    pMachine,
                                                    pCounter->pCounterPath->szObjectName,
                                                    &bInstances);

                                                if (pCounter->plCounterInfo.dwObjectId == (DWORD)-1) {
                                                    // still unable to lookup object so
                                                    // bail out
                                                    pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_OBJECT;
                                                    pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                    bReturn = FALSE;
                                                }
                                                pMachine->dwRefCount--;
                                                RELEASE_MUTEX (pMachine->hMutex);
                                            } else {
                                                // unable to connect to the machine
                                                pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_MACHINE;
                                                SetLastError (PDH_CSTATUS_NO_MACHINE);
                                                bReturn = FALSE;
                                            }
                                        } else {
                                            // unable to find machine
                                            // LastError is set by GetMachine call
                                            pCounter->ThisValue.CStatus = GetLastError();
                                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                            bReturn = FALSE;
                                        }
                                    } else {
                                        // we've already tried the costly counters and
                                        // not found anything. so bail out
                                        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_OBJECT;
                                        // this counter cannot be found so indicate that it's finished 
                                        pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                                        pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                        bReturn = FALSE;
                                    }
                                }

                                // see if we found a counter object in the above code
                                if (pCounter->plCounterInfo.dwObjectId != (DWORD)-1) {
                                    // update instanceName
                                    // look up instances if necessary
                                    if (bInstances) {
                                        if (pCounter->pCounterPath->szInstanceName != NULL) {
                                            if (*pCounter->pCounterPath->szInstanceName
                                                != SPLAT_L) {
                                                if (!GetInstanceByNameMatch (pMachine,
                                                    pCounter)) {
                                                    // unable to lookup instance
                                                    pCounter->ThisValue.CStatus =
                                                        PDH_CSTATUS_NO_INSTANCE;
                                                    // keep the counter since the instance may return
                                                }
                                            } else {
                                                // this is a wild card query so don't look
                                                // for any instances yet
                                                pCounter->dwFlags |= PDHIC_MULTI_INSTANCE;
                                            }
                                        } else {
                                            // the path for this object should include
                                            // an instance name and doesn't
                                            // so return an error

                                            pCounter->ThisValue.CStatus = PDH_CSTATUS_BAD_COUNTERNAME;
                                            // this is an unrecoverable error so indicate that it's finished 
                                            pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                            bReturn = FALSE;
                                        }
                                    }

                                    if (bReturn) {
                                        // look up counter
                                        if (*pCounter->pCounterPath->szCounterName
                                                != SPLAT_L) {

                                            pCounter->plCounterInfo.dwCounterId = GetCounterId (
                                                pMachine,
                                                pCounter->plCounterInfo.dwObjectId,
                                                pCounter->pCounterPath->szCounterName);

                                            if (pCounter->plCounterInfo.dwCounterId != (DWORD)-1) {
                                                // load and initialize remaining counter values
                                                if (AddMachineToQueryLists (pMachine, pCounter)) {
                                                    if (InitPerflibCounterInfo (pCounter)) {
                                                        // assign the appropriate calculation function
                                                        bReturn =  AssignCalcFunction (
                                                            pCounter->plCounterInfo.dwCounterType,
                                                            &pCounter->CalcFunc,
                                                            &pCounter->StatFunc);
                                                        if (!bReturn) {
                                                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                        } 
                                                    } else {
                                                        // unable to initialize this counter
                                                        pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                        bReturn = FALSE;
                                                    }
                                                } else {
                                                    // machine could not be added, error is already
                                                    // in "LastError" so free string buffer and leave
                                                    pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                    bReturn = FALSE;
                                                }
                                            } else {
                                                // unable to lookup counter
                                                pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_COUNTER;
                                                pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                bReturn = FALSE;
                                            }
                                        }
                                        else {
                                            if (AddMachineToQueryLists(pMachine, pCounter)) {
                                                pCounter->dwFlags |= PDHIC_COUNTER_OBJECT;
                                                pCounter->pThisObject = NULL;
                                                pCounter->pLastObject = NULL;
                                            }
                                            else {
                                                // machine could not be added, error is already
                                                // in "LastError" so free string buffer and leave
                                                pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                                bReturn = FALSE;
                                            }
                                        }
                                    }
                                } else {
                                    // unable to lookup object on this machine
                                    pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_OBJECT;
                                    pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                                    bReturn = FALSE;
                                }
                                // this counter is finished so indicate this
                                pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                                pMachine->dwRefCount--;
                                RELEASE_MUTEX (pMachine->hMutex);
                            } else {
                                // a machine entry was found, but the machine is not available
                                pCounter->ThisValue.CStatus = pMachine->dwStatus;
                                SetLastError (pMachine->dwStatus);
                                if (pMachine->dwStatus == PDH_ACCESS_DENIED) {
                                    // then don't add this counter since the machine
                                    // won't let us in
                                    bReturn = FALSE;
                                } else {
                                    // add the counter and try connecting later
                                }
                            }
                        } else {
                            // unable to find machine
                            // last error is set by GetMachine call
                            pCounter->ThisValue.CStatus = GetLastError();
                            // if no machine was added to the list then this is not recoverable
                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                            pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                            bReturn = FALSE;
                        }
                    } else {
                        PDH_STATUS pdhStatus;
                        // validate counter from log file
                        pdhStatus = PdhiGetLogCounterInfo (
                            pCounter->pOwner->hLog,
                            pCounter);
                        if (pdhStatus == ERROR_SUCCESS) {
                            // finish initializing the counter
                            //
                            pCounter->ThisValue.TimeStamp.dwLowDateTime = 0;
                            pCounter->ThisValue.TimeStamp.dwHighDateTime = 0;
                            pCounter->ThisValue.MultiCount = 1;
                            pCounter->ThisValue.FirstValue = 0;
                            pCounter->ThisValue.SecondValue = 0;
                            //
                            pCounter->LastValue.TimeStamp.dwLowDateTime = 0;
                            pCounter->LastValue.TimeStamp.dwHighDateTime = 0;
                            pCounter->LastValue.MultiCount = 1;
                            pCounter->LastValue.FirstValue = 0;
                            pCounter->LastValue.SecondValue = 0;
                            //
                            //  lastly update status
                            //
                            pCounter->ThisValue.CStatus = PDH_CSTATUS_VALID_DATA;
                            pCounter->LastValue.CStatus = PDH_CSTATUS_VALID_DATA;
                            // assign the appropriate calculation function
                            bReturn = AssignCalcFunction (
                                    pCounter->plCounterInfo.dwCounterType,
                                    &pCounter->CalcFunc,
                                    &pCounter->StatFunc);
                        } else {
                            // set the counter status to the error returned
                            pCounter->ThisValue.CStatus = pdhStatus;
                            pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                            bReturn = FALSE;
                        }
                        pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                    }
                    if (!bReturn) {
                        //free string buffer
                        G_FREE (pCounter->pCounterPath);
                        pCounter->pCounterPath = NULL;
                    }
                } else {
                    G_FREE(pLocalCounterPath);
                    // unable to realloc
                    pCounter->ThisValue.CStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    bReturn = FALSE;
                }
            } else {
                // unable to parse counter name
                pCounter->ThisValue.CStatus = PDH_CSTATUS_BAD_COUNTERNAME;
                pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
                pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
                G_FREE(pLocalCounterPath);
                bReturn = FALSE;
            }
        }
    } else {
        // no counter name
        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_COUNTERNAME;
        pCounter->dwFlags &= ~PDHIC_COUNTER_NOT_INIT;
        pCounter->dwFlags |= PDHIC_COUNTER_INVALID;
        bReturn = FALSE;
    }

    if (! bReturn && pCounter->ThisValue.CStatus != ERROR_SUCCESS) {
        SetLastError(pCounter->ThisValue.CStatus);
    }

    return bReturn;
}

BOOL
ParseInstanceName (
    IN      LPCWSTR szInstanceString,
    IN      LPWSTR  szInstanceName,
    IN      LPWSTR  szParentName,
    IN      LPDWORD lpIndex
)
/*
    parses the instance name formatted as follows

        [parent/]instance[#index]

    parent is optional and if present, is delimited by a forward slash
    index is optional and if present, is delimited by a colon

    parent and instance may be any legal file name character except a
    delimeter character "/#\()" Index must be a string composed of
    decimal digit characters (0-9), less than 10 characters in length, and
    equate to a value between 0 and 2**32-1 (inclusive).

    This function assumes that the instance name and parent name buffers
    are of sufficient size.

    NOTE: szInstanceName and szInstanceString can be the same buffer

*/
{
    LPWSTR  szSrcChar, szDestChar;
    LPWSTR  szLastPound = NULL;
    BOOL    bReturn = FALSE;
    DWORD   dwIndex = 0;

    szDestChar = (LPWSTR)szInstanceName;
    szSrcChar = (LPWSTR)szInstanceString;

    __try {
        do {
            *szDestChar = *szSrcChar;
            if (*szDestChar == POUNDSIGN_L) szLastPound = szDestChar;
            szDestChar++;
            szSrcChar++;
        } while ((*szSrcChar != 0) &&
                 (*szSrcChar != SLASH_L));
        // see if that was really the parent or not
        if (*szSrcChar == SLASH_L) {
            // terminate destination after test in case they are the same buffer
            *szDestChar = 0;
            szSrcChar++;    // and move source pointer past delimter
            // it was the parent name so copy it to the parent
            lstrcpyW (szParentName, szInstanceName);
            // and copy the rest of the string after the "/" to the
            //  instance name field
            szDestChar = szInstanceName;
            do {
                *szDestChar = *szSrcChar;
                if (*szDestChar == POUNDSIGN_L) szLastPound = szDestChar;
                szDestChar++;
                szSrcChar++;
            } while (*szSrcChar != 0);
        } else {
            // that was the only element so load an empty string for the parent
            *szParentName = 0;
        }
        //  if szLastPound is NOT null and is inside the instance string, then
        //  see if it points to a decimal number. If it does, then it's an index
        //  otherwise it's part of the instance name
        *szDestChar = 0;    // terminate the destination string
        dwIndex = 0;
        if (szLastPound != NULL) {
            if (szLastPound > szInstanceName) {
                // there's a pound sign in the instance name
                // see if it's preceded by a non-space char
                szLastPound--;
                if (*szLastPound > SPACE_L) {
                    szLastPound++;
                    // see if it's followed by a digit
                    szLastPound++;
                    if ((*szLastPound >= L'0') && (*szLastPound <= L'9')) {
                        dwIndex = wcstoul (szLastPound, NULL, 10);
                        szLastPound--;
                        *szLastPound = 0;   // terminate the name at the pound sign
                    }
                }
            }
        }
        *lpIndex = dwIndex;
        bReturn = TRUE;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // unable to move strings
        bReturn = FALSE;
    }
    return bReturn;
}

BOOL
ParseFullPathNameW (
    IN      LPCWSTR szFullCounterPath,
    IN      PDWORD  pdwBufferSize,
    IN      PPDHI_COUNTER_PATH  pCounter,
    IN      BOOL    bWbemSyntax
)
/*
    interprets counter path string as either a

        \\machine\object(instance)\counter

    or if bWbemSyntax == TRUE

        \\machine\namespace:ClassName(InstanceName)\CounterName

    and returns the component in the counter path structure

    \\machine or \\machine\namespace may be omitted on the local machine
    (instance) may be omitted on counters with no instance structures
    if object or counter is missing, then FALSE is returned, otherwise
    TRUE is returned if the parsing was successful
*/
{
    // work buffers

    WCHAR   szWorkMachine[MAX_PATH];
    WCHAR   szWorkObject[MAX_PATH];
    WCHAR   szWorkInstance[MAX_PATH];
    WCHAR   szWorkParent[MAX_PATH];
    WCHAR   szWorkCounter[MAX_PATH];

    // misc pointers
    LPWSTR  szSrcChar, szDestChar;

    // other automatic variables

    DWORD   dwBufferLength = 0;
    DWORD   dwWorkMachineLength = 0;
    DWORD   dwWorkObjectLength = 0;
    DWORD   dwWorkInstanceLength = 0;
    DWORD   dwWorkParentLength = 0;
    DWORD   dwWorkCounterLength = 0;

    DWORD   dwWorkIndex = 0;
    DWORD   dwParenDepth =  0;

    WCHAR   wDelimiter = 0;
    LPWSTR  pszBsDelim[2] = {0,0};
    LPWSTR  szThisChar;
    DWORD   dwParenCount = 0;
    LPWSTR  szLastParen = NULL;

    if (lstrlenW(szFullCounterPath) < MAX_PATH) {
        // get machine name from counter path
        szSrcChar = (LPWSTR)szFullCounterPath;

        //define the delimiter char between the machine and the object
        // or in WBEM parlance, the server & namespace and the Class name
        if (bWbemSyntax) {
            wDelimiter = COLON_L;
        } else {
            wDelimiter = BACKSLASH_L;
            // if this is  backslash delimited string, then find the
            // backslash the denotes the end of the machine and start of the
            // object by walking down the string and finding the 2nd to the last
            // backslash.
            // this is necessary since a WBEM machine\namespace path can have
            // multiple backslashes in it while there will ALWAYS be two at
            // the end, one at the start of the object name and one at the start
            // of the counter name
            dwParenDepth = 0;
            for (szThisChar = szSrcChar;
                 *szThisChar != 0;
                 szThisChar++) {
                 if (*szThisChar == LEFTPAREN_L) {
                     if (dwParenDepth == 0) dwParenCount++;
                     dwParenDepth++;
                 } else if (*szThisChar == RIGHTPAREN_L) {
                     if (dwParenDepth > 0) dwParenDepth--;
                 } else {
                     if (dwParenDepth == 0) {
                        // ignore delimiters inside parenthesis
                        if (*szThisChar == wDelimiter) {
                            pszBsDelim[0] = pszBsDelim[1];
                            pszBsDelim[1] = szThisChar;
                        } else {
                            // ignore it and go to the next character
                        }
                     }
                }
            }

            assert (pszBsDelim[1] != NULL); // this is the addr of the last Backslash
            assert (pszBsDelim[0] != NULL); // this is the addr of the object backslash
            assert (dwParenDepth == 0); // make sure they're balanced
            

            if ((dwParenCount > 0) && (pszBsDelim[0] != NULL) && (pszBsDelim[1] != NULL)) {
                dwParenDepth = 0;
                for (szThisChar = pszBsDelim[0];
                     ((*szThisChar != 0) && (szThisChar < pszBsDelim[1]));
                     szThisChar++) {
                     if (*szThisChar == LEFTPAREN_L) {
                         if (dwParenDepth == 0) {
                             // see if the preceeding char is whitespace
                             --szThisChar;
                             if (*szThisChar > SPACE_L) {
                                 // then this could be an instance delim
                                 szLastParen = ++szThisChar;
                             } else {
                                // else it's probably part of the instance name
                                ++szThisChar;
                             }
                         }
                         dwParenDepth++;
                     } else if (*szThisChar == RIGHTPAREN_L) {
                         if (dwParenDepth > 0) dwParenDepth--;
                     }
                }
            }
        }

        // see if this is really a machine name by looking for leading "\\"
        if ((szSrcChar[0] == BACKSLASH_L) &&
            (szSrcChar[1] == BACKSLASH_L)) {
            szDestChar = szWorkMachine;
            *szDestChar++ = *szSrcChar++;
            *szDestChar++ = *szSrcChar++;
            dwWorkMachineLength = 2;
            // must be a machine name so find the object delimiter and zero terminate
            // it there
            while (*szSrcChar != 0) {
                if (pszBsDelim[0] != NULL) {
                    // then go to this pointer
                    if (szSrcChar == pszBsDelim[0]) break;
                } else {
                    // go to the next delimiter
                    if (*szSrcChar != wDelimiter) break;
                }
                *szDestChar++ = *szSrcChar++;
                dwWorkMachineLength++;
            }
            if (*szSrcChar == 0) {
                // no other required fields
                return FALSE;
            } else {
                // null terminate and continue
                *szDestChar++ = 0;
            }
        } else {
            // no machine name, so they must have skipped that field
            // which is OK. We'll insert the local machine name here
            lstrcpyW (szWorkMachine, szStaticLocalMachineName);
            dwWorkMachineLength = lstrlenW(szWorkMachine);
        }
        // szSrcChar should be pointing to the backslash preceeding the
        // object name now.
        if (szSrcChar[0] == wDelimiter) {
            szSrcChar++;    // to move past backslash
            szDestChar = szWorkObject;
            // copy until:
            //  a) the end of the source string is reached
            //  b) the instance delimiter is found "("
            //  c) the counter delimiter is found "\"
            //  d) a non-printable, non-space char is found
            while ((*szSrcChar != 0) && (szSrcChar != szLastParen) &&
                (*szSrcChar != BACKSLASH_L) && (*szSrcChar >= SPACE_L)) {
                dwWorkObjectLength++;
                *szDestChar++ = *szSrcChar++;
            }
            // see why it ended:
            if (*szSrcChar < SPACE_L) {
                // ran     of source string
                return FALSE;
            } else if (szSrcChar == szLastParen) {
                dwParenDepth = 1;
                // there's an instance so copy that to the instance field
                *szDestChar = 0; // terminate destination string
                szDestChar = szWorkInstance;
                // skip past open paren
                ++szSrcChar;
                // copy until:
                //  a) the end of the source string is reached
                //  b) the instance delimiter is found "("
                while ((*szSrcChar != 0) && (dwParenDepth > 0)) {
                    if (*szSrcChar == RIGHTPAREN_L) {
                        dwParenDepth--;
                    } else if (*szSrcChar == LEFTPAREN_L) {
                        dwParenDepth++;
                    }
                    if (dwParenDepth > 0) {
                        // copy all parenthesis except the last one
                        dwWorkInstanceLength++;
                        *szDestChar++ = *szSrcChar++;
                    }
                }
                // see why it ended:
                if (*szSrcChar == 0) {
                    // ran     of source string
                    return FALSE;
                } else {
                    // move source to object delimiter
                    if (*++szSrcChar != BACKSLASH_L) {
                        // bad format
                        return FALSE;
                    } else {
                        *szDestChar = 0;
                        // check instance string for a parent
                        if (ParseInstanceName (
                            szWorkInstance, szWorkInstance,
                            szWorkParent, &dwWorkIndex)) {
                            dwWorkInstanceLength = lstrlenW (szWorkInstance);
                            dwWorkParentLength = lstrlenW (szWorkParent);
                        } else {
                            // instance string not formatted correctly
                            return FALSE;
                        }
                    }
                }
            } else {
                // terminate the destination string
                *szDestChar = 0;
            }
            // finally copy the counter name
            szSrcChar++;    // to move past backslash
            szDestChar = szWorkCounter;
            // copy until:
            //  a) the end of the source string is reached
            while (*szSrcChar != 0) {
                dwWorkCounterLength++;
                *szDestChar++ = *szSrcChar++;
            }
            *szDestChar = 0;
            // now to see if all this will fit in the users's buffer
            dwBufferLength = sizeof (PDHI_COUNTER_PATH) - sizeof(BYTE);
            dwBufferLength += DWORD_MULTIPLE((dwWorkMachineLength + 1) * sizeof(WCHAR));
            dwBufferLength += DWORD_MULTIPLE((dwWorkObjectLength + 1) * sizeof(WCHAR));
            if (dwWorkInstanceLength > 0) {
                dwBufferLength +=
                    DWORD_MULTIPLE((dwWorkInstanceLength + 1) * sizeof(WCHAR));
            }
            if (dwWorkParentLength > 0) {
                dwBufferLength +=
                    DWORD_MULTIPLE((dwWorkParentLength + 1) * sizeof(WCHAR));
            }
            dwBufferLength += DWORD_MULTIPLE((dwWorkCounterLength + 1) * sizeof(WCHAR));

            if (dwBufferLength < *pdwBufferSize) {
                // it looks like it'll fit so start filling things in
                szDestChar = (LPWSTR)&pCounter->pBuffer[0];

                if (dwWorkMachineLength != 0) {
                    pCounter->szMachineName = szDestChar;
                    lstrcpyW (szDestChar, szWorkMachine);
                    szDestChar += dwWorkMachineLength + 1;
                    szDestChar = ALIGN_ON_DWORD (szDestChar);
                } else {
                    pCounter->szMachineName = NULL;
                }

                pCounter->szObjectName = szDestChar;
                lstrcpyW (szDestChar, szWorkObject);
                szDestChar += dwWorkObjectLength + 1;
                szDestChar = ALIGN_ON_DWORD (szDestChar);

                if (dwWorkInstanceLength != 0) {
                    pCounter->szInstanceName = szDestChar;
                    lstrcpyW (szDestChar, szWorkInstance);
                    szDestChar += dwWorkInstanceLength + 1;
                    szDestChar = ALIGN_ON_DWORD (szDestChar);
                } else {
                    pCounter->szInstanceName = NULL;
                }

                if (dwWorkParentLength != 0) {
                    pCounter->szParentName = szDestChar;
                    lstrcpyW (szDestChar, szWorkParent);
                    szDestChar += dwWorkParentLength + 1;
                    szDestChar = ALIGN_ON_DWORD (szDestChar);
                } else {
                    pCounter->szParentName = NULL;
                }

                pCounter->dwIndex = dwWorkIndex;

                pCounter->szCounterName = szDestChar;
                lstrcpyW (szDestChar, szWorkCounter);

                szDestChar += dwWorkCounterLength + 1;
                szDestChar = ALIGN_ON_DWORD (szDestChar);

                *pdwBufferSize = dwBufferLength;
                return TRUE;
            } else {
                //insufficient buffer
                return FALSE;
            }
        } else {
            // no object found so return
            return FALSE;
        }
    } else {
        // incoming string is too long
        return FALSE;
    }
}

BOOL
FreeCounter (
    PPDHI_COUNTER   pThisCounter
)
{
    // NOTE:
    //  This function assumes the query containing
    //  this counter has already been locked by the calling
    //  function.

    PPDHI_COUNTER   pPrevCounter;
    PPDHI_COUNTER   pNextCounter;

    PPDHI_QUERY     pParentQuery;

    // define pointers
    pPrevCounter = pThisCounter->next.blink;
    pNextCounter = pThisCounter->next.flink;

    pParentQuery = pThisCounter->pOwner;

    // decrement machine reference counter if a machine has been assigned
    if (pThisCounter->pQMachine != NULL) {
        if (pThisCounter->pQMachine->pMachine != NULL) {
            if (--pThisCounter->pQMachine->pMachine->dwRefCount == 0) {
                // then this is the last counter so remove machine
    //            freeing the machine in this call causes all kinds of 
    //            multi-threading problems so we'll keep it around until
    //            the DLL unloads.
    //            FreeMachine (pThisCounter->pQMachine->pMachine, FALSE);
                pThisCounter->pQMachine->pMachine = NULL;
            }  else {
                // the ref count is non-zero so leave the pointer alone
            }
        } else {
            // the pointer has already been cleared
        }
    } else {
        // there's no machine
    }

    // free allocated memory in the counter
    if (pThisCounter->pCounterPath != NULL) {
        G_FREE (pThisCounter->pCounterPath);
        pThisCounter->pCounterPath = NULL;
    }
    if (pThisCounter->szFullName != NULL) {
        G_FREE (pThisCounter->szFullName);
        pThisCounter->szFullName = NULL;
    }

    if (pParentQuery != NULL) {
        if (pParentQuery->hLog == NULL) {
            if (pThisCounter->pThisObject != NULL) {
                G_FREE (pThisCounter->pThisObject);
                pThisCounter->pThisObject = NULL;
            }
            if (pThisCounter->pLastObject != NULL) {
                G_FREE (pThisCounter->pLastObject);
                pThisCounter->pLastObject = NULL;
            }

            if (pThisCounter->pThisRawItemList != NULL) {
                G_FREE (pThisCounter->pThisRawItemList);
                pThisCounter->pThisRawItemList = NULL;
            }
            if (pThisCounter->pLastRawItemList != NULL) {
                G_FREE (pThisCounter->pLastRawItemList);
                pThisCounter->pLastRawItemList = NULL;
            }
        }
    }

    // check for WBEM items

    if (pThisCounter->dwFlags & PDHIC_WBEM_COUNTER) {
        PdhiCloseWbemCounter(pThisCounter);
    }

    // update pointers if they've been assigned

    if ((pPrevCounter != NULL) && (pNextCounter != NULL)) {
        if ((pPrevCounter != pThisCounter) && (pNextCounter != pThisCounter)) {
            // update query list pointers
            pPrevCounter->next.flink = pNextCounter;
            pNextCounter->next.blink = pPrevCounter;
        } else {
            // this is the only counter entry in the list
            // so the caller must deal with updating the head pointer
        }
    }
    memset (pThisCounter, 0, sizeof(PDHI_COUNTER));
    // delete this counter
    G_FREE (pThisCounter);

    return TRUE;
}

BOOL
UpdateCounterValue (
    IN  PPDHI_COUNTER    pCounter,
    IN  PPERF_DATA_BLOCK pPerfData
)
{
    DWORD                LocalCStatus = 0;
    DWORD                LocalCType   = 0;
    LPVOID               pData        = NULL;
    PDWORD               pdwData;
    UNALIGNED LONGLONG * pllData;
    PPERF_OBJECT_TYPE    pPerfObject  = NULL;
    BOOL                 bReturn      = FALSE;

    pData = GetPerfCounterDataPtr(pPerfData,
                                  pCounter->pCounterPath,
                                  & pCounter->plCounterInfo,
                                  0,
                                  & pPerfObject,
                                  & LocalCStatus);
    pCounter->ThisValue.CStatus = LocalCStatus;
    if (IsSuccessSeverity(LocalCStatus)) {
        // assume success
        bReturn = TRUE;
        // load counter value based on counter type
        LocalCType = pCounter->plCounterInfo.dwCounterType;
        switch (LocalCType) {
        //
        // these counter types are loaded as:
        //      Numerator = Counter data from perf data block
        //      Denominator = Perf Time from perf data block
        //      (the time base is the PerfFreq)
        //
        case PERF_COUNTER_COUNTER:
        case PERF_COUNTER_QUEUELEN_TYPE:
        case PERF_SAMPLE_COUNTER:
            pCounter->ThisValue.FirstValue  = (LONGLONG)(*(DWORD *)pData);
            pCounter->ThisValue.SecondValue =
                            pPerfData->PerfTime.QuadPart;
            break;

        case PERF_OBJ_TIME_TIMER:
            pCounter->ThisValue.FirstValue = (LONGLONG)(*(DWORD *)pData);
            pCounter->ThisValue.SecondValue = pPerfObject->PerfTime.QuadPart;
            break;

        case PERF_COUNTER_100NS_QUEUELEN_TYPE:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue  = *pllData;
            pCounter->ThisValue.SecondValue =
                            pPerfData->PerfTime100nSec.QuadPart;
            break;

        case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            pCounter->ThisValue.SecondValue = pPerfObject->PerfTime.QuadPart;
            break;

        case PERF_COUNTER_TIMER:
        case PERF_COUNTER_TIMER_INV:
        case PERF_COUNTER_BULK_COUNT:
        case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            pCounter->ThisValue.SecondValue =
                            pPerfData->PerfTime.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                pCounter->ThisValue.MultiCount = (DWORD)*++pllData;
            }
            break;

        //
        //  this is a hack to make the PDH work like PERFMON for
        //  this counter type
        //
        case PERF_COUNTER_MULTI_TIMER:
        case PERF_COUNTER_MULTI_TIMER_INV:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            // begin hack code
            pCounter->ThisValue.FirstValue *= 
                            (DWORD) pPerfData->PerfFreq.QuadPart;
            // end hack code
            pCounter->ThisValue.SecondValue =
                            pPerfData->PerfTime.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                pCounter->ThisValue.MultiCount = (DWORD)*++pllData;
            }
            break;

        //
        //  These counters do not use any time reference
        //
        case PERF_COUNTER_RAWCOUNT:
        case PERF_COUNTER_RAWCOUNT_HEX:
        case PERF_COUNTER_DELTA:
            pCounter->ThisValue.FirstValue = (LONGLONG)(*(DWORD *)pData);
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_COUNTER_LARGE_RAWCOUNT:
        case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case PERF_COUNTER_LARGE_DELTA:
            pCounter->ThisValue.FirstValue = *(LONGLONG *)pData;
            pCounter->ThisValue.SecondValue = 0;
            break;

        //
        //  These counters use the 100 Ns time base in thier calculation
        //
        case PERF_100NSEC_TIMER:
        case PERF_100NSEC_TIMER_INV:
        case PERF_100NSEC_MULTI_TIMER:
        case PERF_100NSEC_MULTI_TIMER_INV:
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            pCounter->ThisValue.SecondValue =
                            pPerfData->PerfTime100nSec.QuadPart;
            if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                ++pllData;
                pCounter->ThisValue.MultiCount = *(DWORD *)pllData;
            }
            break;

        //
        //  These counters use two data points, the one pointed to by
        //  pData and the one immediately after
        //
        case PERF_SAMPLE_FRACTION:
        case PERF_RAW_FRACTION:
            pdwData = (DWORD *)pData;
            pCounter->ThisValue.FirstValue = (LONGLONG)(* pdwData);
            // find the pointer to the base value in the structure
            pData = GetPerfCounterDataPtr (
                    pPerfData,
                    pCounter->pCounterPath,
                    & pCounter->plCounterInfo,
                    GPCDP_GET_BASE_DATA,
                    NULL,
                    & LocalCStatus);

            if (IsSuccessSeverity(LocalCStatus)) {
                pdwData = (DWORD *)pData;
                pCounter->ThisValue.SecondValue = (LONGLONG)(*pdwData);
            } else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_LARGE_RAW_FRACTION:
            pllData = (UNALIGNED LONGLONG *) pData;
            pCounter->ThisValue.FirstValue = * pllData;
            pData = GetPerfCounterDataPtr(pPerfData,
                                          pCounter->pCounterPath,
                                          & pCounter->plCounterInfo,
                                          GPCDP_GET_BASE_DATA,
                                          NULL,
                                          & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pllData = (LONGLONG *) pData;
                pCounter->ThisValue.SecondValue = * pllData;
            } else {
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_PRECISION_SYSTEM_TIMER:
        case PERF_PRECISION_100NS_TIMER:
        case PERF_PRECISION_OBJECT_TIMER:
            pllData = (LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            // find the pointer to the base value in the structure
            pData = GetPerfCounterDataPtr (
                    pPerfData,
                    pCounter->pCounterPath,
                    & pCounter->plCounterInfo,
                    GPCDP_GET_BASE_DATA,
                    NULL,
                    & LocalCStatus);

            if (IsSuccessSeverity(LocalCStatus)) {
                pllData = (LONGLONG *)pData;
                pCounter->ThisValue.SecondValue = *pllData;
            } else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;

        case PERF_AVERAGE_TIMER:
        case PERF_AVERAGE_BULK:
            // counter (numerator) is a LONGLONG, while the
            // denominator is just a DWORD
            pllData = (UNALIGNED LONGLONG *)pData;
            pCounter->ThisValue.FirstValue = *pllData;
            pData = GetPerfCounterDataPtr (
                    pPerfData,
                    pCounter->pCounterPath,
                    & pCounter->plCounterInfo,
                    GPCDP_GET_BASE_DATA,
                    NULL,
                    & LocalCStatus);
            if (IsSuccessSeverity(LocalCStatus)) {
                pdwData = (DWORD *)pData;
                pCounter->ThisValue.SecondValue = *pdwData;
            } else {
                // unable to locate base value
                pCounter->ThisValue.SecondValue = 0;
                pCounter->ThisValue.CStatus     = LocalCStatus;
                bReturn = FALSE;
            }
            break;
        //
        //  These counters are used as the part of another counter
        //  and as such should not be used, but in case they are
        //  they'll be handled here.
        //
        case PERF_SAMPLE_BASE:
        case PERF_AVERAGE_BASE:
        case PERF_COUNTER_MULTI_BASE:
        case PERF_RAW_BASE:
        case PERF_LARGE_RAW_BASE:
            pCounter->ThisValue.FirstValue = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;

        case PERF_ELAPSED_TIME:
            // this counter type needs the object perf data as well
            if (GetObjectPerfInfo(pPerfData,
                        pCounter->plCounterInfo.dwObjectId,
                        & pCounter->ThisValue.SecondValue,
                        & pCounter->TimeBase)) {
                pllData = (UNALIGNED LONGLONG *)pData;
                pCounter->ThisValue.FirstValue = *pllData;
            } else {
                pCounter->ThisValue.FirstValue = 0;
                pCounter->ThisValue.SecondValue = 0;
            }
            break;

        //
        //  These counters are not supported by this function (yet)
        //
        case PERF_COUNTER_TEXT:
        case PERF_COUNTER_NODATA:
        case PERF_COUNTER_HISTOGRAM_TYPE:
            pCounter->ThisValue.FirstValue = 0;
            pCounter->ThisValue.SecondValue = 0;
            break;

        default:
            // an unidentified counter was returned so
            pCounter->ThisValue.FirstValue = 0;
            pCounter->ThisValue.SecondValue = 0;
            bReturn = FALSE;
            break;
        }
    } else {
        // else this counter is not valid so this value == 0
        pCounter->ThisValue.FirstValue  = pCounter->LastValue.FirstValue;
        pCounter->ThisValue.SecondValue = pCounter->LastValue.SecondValue;
        pCounter->ThisValue.CStatus     = LocalCStatus;
        bReturn = FALSE;
    }
        
    return bReturn;
}

BOOL
UpdateRealTimeCounterValue(
    IN  PPDHI_COUNTER pCounter
)
{
    BOOL     bResult      = FALSE;
    DWORD    LocalCStatus = 0;
    FILETIME GmtFileTime;

    // move current value to last value buffer
    pCounter->LastValue = pCounter->ThisValue;

    // and clear the old value
    pCounter->ThisValue.MultiCount  = 1;
    pCounter->ThisValue.FirstValue  = 0;
    pCounter->ThisValue.SecondValue = 0;

    // don't process if the counter has not been initialized
    if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) {
        // get the counter's machine status first. There's no point in
        // contuning if the machine is offline
        LocalCStatus = pCounter->pQMachine->lQueryStatus;
        if (   IsSuccessSeverity(LocalCStatus)
            && pCounter->pQMachine->pPerfData != NULL) {
            // update timestamp
            SystemTimeToFileTime(& pCounter->pQMachine->pPerfData->SystemTime,
                                 & GmtFileTime);
            FileTimeToLocalFileTime(& GmtFileTime,
                                    & pCounter->ThisValue.TimeStamp);
            bResult = UpdateCounterValue(pCounter,
                                         pCounter->pQMachine->pPerfData);
        }
        else {
            // unable to read data from this counter's machine so use the
            // query's timestamp
            //
            pCounter->ThisValue.TimeStamp.dwLowDateTime  =
                            LODWORD(pCounter->pQMachine->llQueryTime);
            pCounter->ThisValue.TimeStamp.dwHighDateTime =
                            HIDWORD(pCounter->pQMachine->llQueryTime);
            // all other data fields remain un-changed
            pCounter->ThisValue.CStatus = LocalCStatus;   // save counter status
        }
    }
    else {
        if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
            // try to init it
            InitCounter (pCounter);
        }
    }

    return bResult;
}

BOOL
UpdateMultiInstanceCounterValue (
    IN  PPDHI_COUNTER    pCounter,
    IN  PPERF_DATA_BLOCK pPerfData,
    IN  LONGLONG         TimeStamp
)
{
    PPERF_OBJECT_TYPE           pPerfObject = NULL;
    PPERF_INSTANCE_DEFINITION   pPerfInstance = NULL;
    PPERF_OBJECT_TYPE           pParentObject = NULL;
    PPERF_INSTANCE_DEFINITION   pThisParentInstance = NULL;
    PPERF_COUNTER_DEFINITION    pNumPerfCounter = NULL;
    PPERF_COUNTER_DEFINITION    pDenPerfCounter = NULL;

    DWORD   LocalCStatus = 0;
    DWORD   LocalCType  = 0;
    LPVOID  pData = NULL;
    PDWORD        pdwData;
    UNALIGNED LONGLONG    *pllData;
    FILETIME    GmtFileTime;
    DWORD       dwSize;
    DWORD       dwFinalSize;
    LONG        nThisInstanceIndex;
    LONG        nParentInstanceIndex;

    LPWSTR  szNextNameString;
    PPDHI_RAW_COUNTER_ITEM   pThisItem;

    BOOL    bReturn  = FALSE;

    pPerfObject = GetObjectDefByTitleIndex (
                pPerfData, pCounter->plCounterInfo.dwObjectId);

    if (pPerfObject != NULL) {
        // this should be caught during the AddCounter operation
        assert (pPerfObject->NumInstances != PERF_NO_INSTANCES);
        //
        // allocate a new buffer for the current data
        // this should be large enough to handle the header,
        // all instances and thier name strings
        //
        dwSize = sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK) -
                sizeof (PDHI_RAW_COUNTER_ITEM);

        pPerfInstance = FirstInstance (pPerfObject);
        // make sure pointer is still within the same instance
        assert ((DWORD)pPerfInstance <  (DWORD)((LPBYTE)pPerfObject + pPerfObject->TotalByteLength));

        for (nThisInstanceIndex = 0;
            nThisInstanceIndex < pPerfObject->NumInstances;
            nThisInstanceIndex++) {
            // this should only fail in dire cases
            if (pPerfInstance == NULL) break;
            // for this instance add the size of the data item
            dwSize += sizeof(PDHI_RAW_COUNTER_ITEM);
            // and the size of the name string
            dwSize += pPerfInstance->NameLength + sizeof(WCHAR);
            // to the required buffer size

            // if this instance has a parent, see how long it's string
            // is

            // first see if we've already got the pointer to the parent

            if (pPerfInstance->ParentObjectTitleIndex != 0) {
                // then include the parent instance name
                if (pParentObject == NULL) {
                    // get parent object
                    pParentObject = GetObjectDefByTitleIndex (
                            pPerfData,
                            pPerfInstance->ParentObjectTitleIndex);
                } else {
                    if (pParentObject->ObjectNameTitleIndex !=
                        pPerfInstance->ParentObjectTitleIndex) {
                        pParentObject = GetObjectDefByTitleIndex (
                                pPerfData,
                                pPerfInstance->ParentObjectTitleIndex);
                    }
                }
                if (pParentObject == NULL) break;

                // now go to the corresponding instance entry
                pThisParentInstance = FirstInstance (pParentObject);
                // make sure pointer is still within the same instance
                assert (pThisParentInstance != NULL);
                assert ((DWORD)pThisParentInstance <
                        (DWORD)((LPBYTE)pParentObject + pParentObject->TotalByteLength));

                if (pPerfInstance->ParentObjectInstance <
                    (DWORD)pParentObject->NumInstances) {
                    for (nParentInstanceIndex = 0;
                        (DWORD)nParentInstanceIndex != pPerfInstance->ParentObjectInstance;
                        nParentInstanceIndex++) {
                        pThisParentInstance = NextInstance (pThisParentInstance);                               
                        if (pThisParentInstance == NULL) break;
                    }

                    if (pThisParentInstance != NULL) {
                        assert ((DWORD)nParentInstanceIndex ==
                            pPerfInstance->ParentObjectInstance);
                        // found it so add in it's string length
                        dwSize += pThisParentInstance->NameLength + sizeof(WCHAR);
                    }
                } else {
                    // the index is not in the parent
                    pThisParentInstance = NULL;
                    // so don't change the size required field
                }
            }
            // round up to the next DWORD address
            dwSize = DWORD_MULTIPLE(dwSize);
            // and go to the next instance
            pPerfInstance = NextInstance (pPerfInstance);
        }
        //
        //
        pCounter->pThisRawItemList = G_ALLOC (dwSize);

        assert (pCounter->pThisRawItemList != NULL);
        if (pCounter->pThisRawItemList != NULL) {

            pCounter->pThisRawItemList->dwLength = dwSize;

            pNumPerfCounter = GetCounterDefByTitleIndex (
                pPerfObject, 0, pCounter->plCounterInfo.dwCounterId);

            // just in case we need it later
            pDenPerfCounter = pNumPerfCounter + 1;

            // fill in the counter data
            pCounter->pThisRawItemList->dwItemCount =
                pPerfObject->NumInstances;

            pCounter->pThisRawItemList->CStatus = LocalCStatus;

            // update timestamp
            SystemTimeToFileTime(& pPerfData->SystemTime,
                            & GmtFileTime);
            FileTimeToLocalFileTime(& GmtFileTime,
                            & pCounter->pThisRawItemList->TimeStamp);

            pThisItem = &pCounter->pThisRawItemList->pItemArray[0];

            szNextNameString =
                (LPWSTR)&(pCounter->pThisRawItemList->pItemArray[pPerfObject->NumInstances]);

            pPerfInstance = FirstInstance (pPerfObject);

            if (pPerfInstance != NULL) {
                // make sure pointer is still within the same instance
                assert ((DWORD)pPerfInstance <  (DWORD)((LPBYTE)pPerfObject + pPerfObject->TotalByteLength));

                // for each instance log the raw data values for this counter
                for (nThisInstanceIndex = 0;
                    nThisInstanceIndex < pPerfObject->NumInstances;
                    nThisInstanceIndex++) {

                    // make sure pointe is still within the same instance
                    assert ((DWORD)pPerfInstance <  (DWORD)((LPBYTE)pPerfObject + pPerfObject->TotalByteLength));

                    // make a new instance entry

                    // get the name of this instance
                    pThisItem->szName = (DWORD)
                        (  ((LPBYTE) szNextNameString)
                         - ((LPBYTE) pCounter->pThisRawItemList));

                    dwSize = GetFullInstanceNameStr (
                        pPerfData,
                        pPerfObject, pPerfInstance,
                        szNextNameString);

                    if (dwSize == 0) {
                        // unable to read instance name
                        // so make one up  (and assert in DBG builds)
                        assert (dwSize > 0);
                        _ltow (nThisInstanceIndex, szNextNameString, 10);
                        dwSize = lstrlenW (szNextNameString);
                    }

                    szNextNameString += dwSize + 1;
                    szNextNameString = ALIGN_ON_DWORD(szNextNameString);

                    // get the data values and write them.

                    // get the pointer to the counter data
                    pData = GetPerfCounterDataPtr (
                        pPerfData,
                        pCounter->pCounterPath,
                        &pCounter->plCounterInfo,
                        0,
                        NULL,
                        &LocalCStatus);


                    pData = GetInstanceCounterDataPtr (
                        pPerfObject, pPerfInstance, pNumPerfCounter);

                    bReturn = TRUE; // assume success
                    // load counter value based on counter type
                    LocalCType = pCounter->plCounterInfo.dwCounterType;
                    switch (LocalCType) {
                    //
                    // these counter types are loaded as:
                    //      Numerator = Counter data from perf data block
                    //      Denominator = Perf Time from perf data block
                    //      (the time base is the PerfFreq)
                    //
                    case PERF_COUNTER_COUNTER:
                    case PERF_COUNTER_QUEUELEN_TYPE:
                    case PERF_SAMPLE_COUNTER:
                        pThisItem->FirstValue = (LONGLONG)(*(DWORD *)pData);
                        pThisItem->SecondValue =
                            pPerfData->PerfTime.QuadPart;
                        break;

                    case PERF_OBJ_TIME_TIMER:
                        pThisItem->FirstValue = (LONGLONG)(*(DWORD *)pData);
                        pThisItem->SecondValue = pPerfObject->PerfTime.QuadPart;
                        break;

                    case PERF_COUNTER_100NS_QUEUELEN_TYPE:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        pThisItem->SecondValue =
                            pPerfData->PerfTime100nSec.QuadPart;
                        break;

                    case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        pThisItem->SecondValue = pPerfObject->PerfTime.QuadPart;
                        break;

                    case PERF_COUNTER_TIMER:
                    case PERF_COUNTER_TIMER_INV:
                    case PERF_COUNTER_BULK_COUNT:
                    case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        pThisItem->SecondValue =
                            pPerfData->PerfTime.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            pThisItem->MultiCount = (DWORD)*++pllData;
                        }
                        break;

                    case PERF_COUNTER_MULTI_TIMER:
                    case PERF_COUNTER_MULTI_TIMER_INV:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        // begin hack code
                        pThisItem->FirstValue *= 
                                        (DWORD) pPerfData->PerfFreq.QuadPart;
                        // end hack code
                        pThisItem->SecondValue =
                            pPerfData->PerfTime.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            pThisItem->MultiCount = (DWORD)*++pllData;
                        }
                        break;

                    //
                    //  These counters do not use any time reference
                    //
                    case PERF_COUNTER_RAWCOUNT:
                    case PERF_COUNTER_RAWCOUNT_HEX:
                    case PERF_COUNTER_DELTA:
                        pThisItem->FirstValue = (LONGLONG)(*(DWORD *)pData);
                        pThisItem->SecondValue = 0;
                        break;

                    case PERF_COUNTER_LARGE_RAWCOUNT:
                    case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
                    case PERF_COUNTER_LARGE_DELTA:
                        pThisItem->FirstValue = *(LONGLONG *)pData;
                        pThisItem->SecondValue = 0;
                        break;

                    //
                    //  These counters use the 100 Ns time base in thier calculation
                    //
                    case PERF_100NSEC_TIMER:
                    case PERF_100NSEC_TIMER_INV:
                    case PERF_100NSEC_MULTI_TIMER:
                    case PERF_100NSEC_MULTI_TIMER_INV:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        pThisItem->SecondValue =
                            pPerfData->PerfTime100nSec.QuadPart;
                        if ((LocalCType & PERF_MULTI_COUNTER) == PERF_MULTI_COUNTER) {
                            ++pllData;
                            pThisItem->MultiCount = *(DWORD *)pllData;
                        }
                        break;

                    //
                    //  These counters use two data points, the one pointed to by
                    //  pData and the one pointed by the definition following
                    //  immediately after
                    //
                    case PERF_SAMPLE_FRACTION:
                    case PERF_RAW_FRACTION:
                        pdwData = (DWORD *)pData;
                        pThisItem->FirstValue = (LONGLONG)(*pdwData);
                        pData = GetInstanceCounterDataPtr (
                           pPerfObject, pPerfInstance, pDenPerfCounter);
                        pdwData = (DWORD *)pData;
                        pThisItem->SecondValue = (LONGLONG)(*pdwData);
                        break;

                    case PERF_LARGE_RAW_FRACTION:
                        pllData = (UNALIGNED LONGLONG *) pData;
                        pCounter->ThisValue.FirstValue = * pllData;
                        pData = GetInstanceCounterDataPtr(
                                pPerfObject, pPerfInstance, pDenPerfCounter);
                        if (pData) {
                            pllData = (LONGLONG *) pData;
                            pCounter->ThisValue.SecondValue = * pllData;
                        } else {
                            pCounter->ThisValue.SecondValue = 0;
                            bReturn = FALSE;
                        }
                        break;

                    case PERF_PRECISION_SYSTEM_TIMER:
                    case PERF_PRECISION_100NS_TIMER:
                    case PERF_PRECISION_OBJECT_TIMER:
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        // find the pointer to the base value in the structure
                        pData = GetInstanceCounterDataPtr (
                           pPerfObject, pPerfInstance, pDenPerfCounter);
                        pllData = (LONGLONG *)pData;
                        pThisItem->SecondValue = *pllData;
                        break;

                    case PERF_AVERAGE_TIMER:
                    case PERF_AVERAGE_BULK:
                        // counter (numerator) is a LONGLONG, while the
                        // denominator is just a DWORD
                        pllData = (UNALIGNED LONGLONG *)pData;
                        pThisItem->FirstValue = *pllData;
                        pData = GetInstanceCounterDataPtr (
                           pPerfObject, pPerfInstance, pDenPerfCounter);
                        pdwData = (DWORD *)pData;
                        pThisItem->SecondValue = (LONGLONG)*pdwData;
                        break;
                    //
                    //  These counters are used as the part of another counter
                    //  and as such should not be used, but in case they are
                    //  they'll be handled here.
                    //
                    case PERF_SAMPLE_BASE:
                    case PERF_AVERAGE_BASE:
                    case PERF_COUNTER_MULTI_BASE:
                    case PERF_RAW_BASE:
                    case PERF_LARGE_RAW_BASE:
                        pThisItem->FirstValue = 0;
                        pThisItem->SecondValue = 0;
                        break;

                    case PERF_ELAPSED_TIME:
                        // this counter type needs the object perf data as well
                        if (GetObjectPerfInfo(pPerfData,
                                pCounter->plCounterInfo.dwObjectId,
                                & pThisItem->SecondValue,
                                & pCounter->TimeBase)) {
                            pllData = (UNALIGNED LONGLONG *)pData;
                            pThisItem->FirstValue = *pllData;
                        } else {
                            pThisItem->FirstValue = 0;
                            pThisItem->SecondValue = 0;
                        }
                        break;

                    //
                    //  These counters are not supported by this function (yet)
                    //
                    case PERF_COUNTER_TEXT:
                    case PERF_COUNTER_NODATA:
                    case PERF_COUNTER_HISTOGRAM_TYPE:
                        pThisItem->FirstValue = 0;
                        pThisItem->SecondValue = 0;
                        break;

                    default:
                        // an unrecognized counter type was returned
                        pThisItem->FirstValue = 0;
                        pThisItem->SecondValue = 0;
                        bReturn = FALSE;
                        break;

                    }

                    pThisItem++;    // go to the next entry

                    // go to the next instance data block
                    pPerfInstance = NextInstance (pPerfInstance);
                } // end for each instance
            } else {
                // no instance found so ignore
            }
            // measure the memory block used
            dwFinalSize = (DWORD)((LPBYTE)szNextNameString -
                (LPBYTE)pCounter->pThisRawItemList);

            assert (dwFinalSize == pCounter->pThisRawItemList->dwLength);

        } else {
            // unable to allocate a new buffer so return error
            SetLastError (ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
    }
    else {
        pCounter->pThisRawItemList =
                        G_ALLOC(sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
        if (pCounter->pThisRawItemList != NULL) {
            pCounter->pThisRawItemList->dwLength =
                            sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
            pCounter->pThisRawItemList->dwItemCount = 0;
            pCounter->pThisRawItemList->CStatus = LocalCStatus;
            pCounter->pThisRawItemList->TimeStamp.dwLowDateTime  =
                            LODWORD(TimeStamp);
            pCounter->pThisRawItemList->TimeStamp.dwHighDateTime =
                            HIDWORD(TimeStamp);
        }
        else {
            SetLastError(ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
    }

    return bReturn;
}

BOOL
UpdateRealTimeMultiInstanceCounterValue(
    IN  PPDHI_COUNTER pCounter
)
{
    BOOL   bResult      = TRUE;
    DWORD  LocalCStatus = 0;

    if (pCounter->pThisRawItemList != NULL) {
        // free old counter buffer list
        if (   pCounter->pLastRawItemList
            && pCounter->pLastRawItemList != pCounter->pThisRawItemList) {
            G_FREE(pCounter->pLastRawItemList);
        }
        pCounter->pLastRawItemList = pCounter->pThisRawItemList;
        pCounter->pThisRawItemList = NULL;
    }

    // don't process if the counter has not been initialized
    if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) {

        // get the counter's machine status first. There's no point in
        // contuning if the machine is offline

        LocalCStatus = pCounter->pQMachine->lQueryStatus;
        if (IsSuccessSeverity(LocalCStatus)) {
            bResult = UpdateMultiInstanceCounterValue(
                      pCounter,
                      pCounter->pQMachine->pPerfData,
                      pCounter->pQMachine->llQueryTime);
        }
        else {
            // unable to read data from this counter's machine so use the
            // query's timestamp
            pCounter->pThisRawItemList =
                            G_ALLOC(sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK));
            if (pCounter->pThisRawItemList != NULL) {
                pCounter->pThisRawItemList->dwLength =
                                sizeof(PDHI_RAW_COUNTER_ITEM_BLOCK);
                pCounter->pThisRawItemList->dwItemCount = 0;
                pCounter->pThisRawItemList->CStatus = LocalCStatus;
                pCounter->pThisRawItemList->TimeStamp.dwLowDateTime  =
                                LODWORD(pCounter->pQMachine->llQueryTime);
                pCounter->pThisRawItemList->TimeStamp.dwHighDateTime =
                                HIDWORD(pCounter->pQMachine->llQueryTime);
            }
            else {
                SetLastError (ERROR_OUTOFMEMORY);
                bResult = FALSE;
            }
        }
    }
    else {
        if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
            // try to init is
            InitCounter (pCounter);
        }
    }
    return bResult;
}

BOOL
UpdateCounterObject(
    IN PPDHI_COUNTER pCounter
)
{
    BOOL              bReturn   = TRUE;
    PPERF_OBJECT_TYPE pPerfObject  = NULL;
    PPERF_OBJECT_TYPE pLogPerfObj;
    DWORD             dwBufferSize = sizeof(PERF_DATA_BLOCK);
    FILETIME          ftGmtTime;
    FILETIME          ftLocTime;

    if (pCounter == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        bReturn = FALSE;
    }
    else {
        if (pCounter->pThisObject != NULL) {
            if (   pCounter->pLastObject
                && pCounter->pThisObject != pCounter->pLastObject) {
                G_FREE(pCounter->pLastObject);
            }
            pCounter->pLastObject = pCounter->pThisObject;
            pCounter->pThisObject = NULL;
        }

        // don't process if the counter has not been initialized
        if (!(pCounter->dwFlags & PDHIC_COUNTER_UNUSABLE)) { 
            if (IsSuccessSeverity(pCounter->pQMachine->lQueryStatus)) {
                pPerfObject = GetObjectDefByTitleIndex(
                                pCounter->pQMachine->pPerfData,
                                pCounter->plCounterInfo.dwObjectId);
                dwBufferSize  = pCounter->pQMachine->pPerfData->HeaderLength;
                dwBufferSize += (  (pPerfObject == NULL)
                                 ? sizeof(PERF_OBJECT_TYPE)
                                 : pPerfObject->TotalByteLength);
                pCounter->pThisObject = G_ALLOC(dwBufferSize);
                if (pCounter->pThisObject != NULL) {
                    RtlCopyMemory(pCounter->pThisObject,
                                  pCounter->pQMachine->pPerfData,
                                  pCounter->pQMachine->pPerfData->HeaderLength);
                    pCounter->pThisObject->TotalByteLength = dwBufferSize;
                    pCounter->pThisObject->NumObjectTypes  = 1;

                    SystemTimeToFileTime(& pCounter->pThisObject->SystemTime,
                                         & ftGmtTime);
                    FileTimeToLocalFileTime(& ftGmtTime, & ftLocTime);
                    FileTimeToSystemTime(& ftLocTime,
                                         & pCounter->pThisObject->SystemTime);
                    pLogPerfObj = (PPERF_OBJECT_TYPE)
                            (  (LPBYTE) pCounter->pThisObject
                             + pCounter->pQMachine->pPerfData->HeaderLength);
                    if (pPerfObject != NULL) {
                        RtlCopyMemory(pLogPerfObj,
                                      pPerfObject,
                                      pPerfObject->TotalByteLength);
                    }
                    else {
                        ZeroMemory(pLogPerfObj, sizeof(PERF_OBJECT_TYPE));
                        pLogPerfObj->TotalByteLength      = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->DefinitionLength     = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->HeaderLength         = sizeof(PERF_OBJECT_TYPE);
                        pLogPerfObj->ObjectNameTitleIndex = pCounter->plCounterInfo.dwObjectId;
                        pLogPerfObj->ObjectHelpTitleIndex = pCounter->plCounterInfo.dwObjectId + 1;
                    }
                }
                else {
                    SetLastError(ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                }
            }
            else {
                pCounter->pThisObject = pCounter->pLastObject;
                SetLastError(PDH_CSTATUS_INVALID_DATA);
                bReturn = FALSE;
            }
        }
        else {
            if (pCounter->dwFlags & PDHIC_COUNTER_NOT_INIT) {
                InitCounter (pCounter);
            }
            pCounter->pThisObject = pCounter->pLastObject;
            SetLastError(PDH_CSTATUS_INVALID_DATA);
            bReturn = FALSE;
        }
    }

    return bReturn;
}

PVOID
GetPerfCounterDataPtr (
    IN  PPERF_DATA_BLOCK    pPerfData,
    IN  PPDHI_COUNTER_PATH  pPath,
    IN  PPERFLIB_COUNTER    pplCtr ,
    IN  DWORD               dwFlags,
    IN  PPERF_OBJECT_TYPE   *pPerfObjectArg,
    IN  PDWORD              pStatus
)
{
    PPERF_OBJECT_TYPE           pPerfObject = NULL;
    PPERF_INSTANCE_DEFINITION   pPerfInstance = NULL;
    PPERF_COUNTER_DEFINITION    pPerfCounter = NULL;
    DWORD                       dwTestValue = 0;
    PVOID                       pData = NULL;
    DWORD                       dwCStatus = PDH_CSTATUS_INVALID_DATA;

    pPerfObject = GetObjectDefByTitleIndex (
        pPerfData, pplCtr->dwObjectId);

    if (pPerfObject != NULL) {
        if (pPerfObjectArg != NULL) *pPerfObjectArg = pPerfObject;
        if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
            // then just look up the counter
            pPerfCounter = GetCounterDefByTitleIndex (
                pPerfObject,
                ((dwFlags & GPCDP_GET_BASE_DATA) ? TRUE : FALSE), pplCtr->dwCounterId);

            if (pPerfCounter != NULL) {
                // get data and return it
                pData = GetCounterDataPtr (pPerfObject, pPerfCounter);

                // test the pointer to see if it fails
                __try {
                    dwTestValue = *(DWORD *)pData;
                    dwCStatus = PDH_CSTATUS_VALID_DATA;
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pData = NULL;
                    dwCStatus = PDH_CSTATUS_INVALID_DATA;
                }
            } else {
                // unable to find counter
                dwCStatus = PDH_CSTATUS_NO_COUNTER;
            }
        } else {
            // find instance
            if (pplCtr->lInstanceId == PERF_NO_UNIQUE_ID) {
                pPerfInstance = GetInstanceByName(
                    pPerfData,
                    pPerfObject,
                    pPath->szInstanceName,
                    pPath->szParentName,
                    pPath->dwIndex);
            } else {
                pPerfInstance = GetInstanceByUniqueId (
                    pPerfObject,
                    pplCtr->lInstanceId);
            }
            if (pPerfInstance != NULL) {
                // instance found so find pointer to counter data
                pPerfCounter = GetCounterDefByTitleIndex (
                    pPerfObject,
                    ((dwFlags & GPCDP_GET_BASE_DATA) ? TRUE : FALSE),
                    pplCtr->dwCounterId);

                if (pPerfCounter != NULL) {
                    // counter found so get data pointer
                    pData = GetInstanceCounterDataPtr (
                        pPerfObject,
                        pPerfInstance,
                        pPerfCounter);

                    // test the pointer to see if it's valid
                    __try {
                        dwTestValue = *(DWORD *)pData;
                        dwCStatus = PDH_CSTATUS_VALID_DATA;
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pData = NULL;
                        dwCStatus = PDH_CSTATUS_INVALID_DATA;
                    }
                } else {
                    // counter not found
                    dwCStatus = PDH_CSTATUS_NO_COUNTER;
                }
            } else {
                // instance not found
                dwCStatus = PDH_CSTATUS_NO_INSTANCE;
            }
        }
    } else {
        // unable to find object
        dwCStatus = PDH_CSTATUS_NO_OBJECT;
    }

    if (pStatus != NULL) {
        __try {
            *pStatus = dwCStatus;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // ?
        }
    }
    return pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\dllinit.c ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    the pdh.dll

Author:

    Bob Watson (a-robw) Jul 95

Revision History:

--*/

#include <windows.h>
#include <assert.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"
#include "pdhp.h"

HANDLE  ThisDLLHandle = NULL;
WCHAR   szStaticLocalMachineName[MAX_PATH] = {0};
HANDLE  hPdhDataMutex    = NULL;
HANDLE  hPdhContextMutex = NULL;
HANDLE  hPdhHeap         = NULL;
HANDLE  hEventLog        = NULL;

LONGLONG    llRemoteRetryTime = RETRY_TIME_INTERVAL;
BOOL        bEnableRemotePdhAccess = TRUE;
DWORD       dwPdhiLocalDefaultDataSource = DATA_SOURCE_REGISTRY;
LONG        dwCurrentRealTimeDataSource = 0;
BOOL        bProcessIsDetaching = FALSE;


LPWSTR
GetStringResource (
    DWORD   dwResId
)
{
    LPWSTR  szReturnString = NULL;
    LPWSTR  szTmpString    = NULL;
    DWORD   dwStrLen = (2048 * sizeof(WCHAR));

    szReturnString = (LPWSTR) G_ALLOC (dwStrLen);
    if (szReturnString != NULL) {
        dwStrLen /= sizeof(WCHAR);
        dwStrLen = LoadStringW (
            ThisDLLHandle,
            (UINT)dwResId, 
            szReturnString, 
            dwStrLen);
        if (dwStrLen > 0) {
            // then realloc down to the size used
            dwStrLen++; // to include the NULL
            dwStrLen *= sizeof (WCHAR);
            szTmpString    = szReturnString;
            szReturnString = G_REALLOC (szReturnString, dwStrLen);
            if (szReturnString == NULL) {
                G_FREE(szTmpString);
                szTmpString = NULL;
            }
        } else {
            // free the memory since the look up failed
            G_FREE (szReturnString);
            szReturnString = NULL;
        }
    } //else  allocation failed

    return szReturnString;
}

STATIC_BOOL
PdhiOpenEventLog (
    HANDLE  *phEventLogHandle
)
{
    HANDLE  hReturn;
    BOOL    bReturn;

    if ((hReturn = RegisterEventSourceW (
        NULL, // on the local machine
        cszAppShortName    // for the PDH.DLL
        )) != NULL) {
        *phEventLogHandle = hReturn;
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }
    return bReturn;
}

STATIC_BOOL
PdhiGetRegistryDefaults ()
{
    DWORD dwStatus;
    DWORD dwType, dwSize, dwValue;

    HKEY    hKeyPDH;

    // the local data source is not initialized so use it
    dwStatus = RegOpenKeyExW (
        HKEY_LOCAL_MACHINE,
        cszPdhKey,
        0L,
        KEY_READ,
        &hKeyPDH);

    if (dwStatus == ERROR_SUCCESS) {
        //
        // get the default null data source
        //
        dwValue = 0;
        dwType = 0;
        dwSize = sizeof (dwValue);
        dwStatus = RegQueryValueExW (
            hKeyPDH,
            cszDefaultNullDataSource,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);
        if (!(dwStatus == ERROR_SUCCESS) || !(dwType == REG_DWORD)) {
            dwValue = DATA_SOURCE_REGISTRY;
        } else {
            // check the value for validity
            switch (dwValue) {
            case DATA_SOURCE_WBEM:
            case DATA_SOURCE_REGISTRY:
                // this is OK
                break;
            case DATA_SOURCE_LOGFILE:
            default:
                // these are not OK so insert default
                dwValue = DATA_SOURCE_REGISTRY;
                break;
            }
        }
        dwPdhiLocalDefaultDataSource = dwValue;

        //
        //  get the retry timeout
        //
        dwValue = 0;
        dwType = 0;
        dwSize = sizeof (dwValue);
        dwStatus = RegQueryValueExW (
            hKeyPDH,
            cszRemoteMachineRetryTime,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);
        if (!(dwStatus == ERROR_SUCCESS) || !(dwType == REG_DWORD)) {
            dwValue = 0;
        } else {
            // check the value for validity
            // must be 30 seconds or more yet no more than an hour
            if ((dwValue <= 30) || (dwValue > 3600)) {
                dwValue = 0;
            }
        }
        if (dwValue != 0) {
            // convert to 100NS units
            llRemoteRetryTime = dwValue * 10000000;   
        } else {
            // use default
            llRemoteRetryTime = RETRY_TIME_INTERVAL;
        }

        // 
        //  get the remote access mode
        //
        dwValue = 0;
        dwType = 0;
        dwSize = sizeof (dwValue);
        dwStatus = RegQueryValueExW (
            hKeyPDH,
            cszEnableRemotePdhAccess,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize);
        if (!(dwStatus == ERROR_SUCCESS) || !(dwType == REG_DWORD)) {
            dwValue = TRUE;
        } else {
            // check the value for validity
            if (dwValue != 0) {
                dwValue = TRUE;
            }            
        }
        bEnableRemotePdhAccess = (BOOL)dwValue;

        // close the registry key
        RegCloseKey (hKeyPDH);
    }
    return TRUE;
}

STATIC_BOOL
PdhiCloseEventLog (
    HANDLE  * phEventLogHandle
)
{
    BOOL    bReturn;

    if (*phEventLogHandle != NULL) {
        bReturn = DeregisterEventSource (*phEventLogHandle);
        *phEventLogHandle = NULL;
    } else {
        // it's already closed so that's OK
        bReturn = TRUE;
    }
    return bReturn;
}

HRESULT
PdhiPlaInitMutex()
{
    HRESULT hr = ERROR_SUCCESS;
    BOOL bResult = TRUE;

    PSECURITY_DESCRIPTOR  SD = NULL;
    SECURITY_ATTRIBUTES sa;
    PSID AuthenticatedUsers    = NULL;
    PSID BuiltInAdministrators = NULL;
    PSID NetworkService        = NULL;
    DWORD dwAclSize;
    ACL  *Acl;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0,0,0,0,0,0,
                        &BuiltInAdministrators);
    if( !bResult ){goto cleanup;}

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_AUTHENTICATED_USER_RID,
                        0,0,0,0,0,0,0,
                        &AuthenticatedUsers);
    if( !bResult ){goto cleanup;}

    bResult = AllocateAndInitializeSid(
                        &NtAuthority,
                        1,
                        SECURITY_NETWORK_SERVICE_RID,
                        0,0,0,0,0,0,0,
                        &NetworkService);
    if( !bResult ){goto cleanup;}

    dwAclSize = sizeof (ACL) +
                (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
                GetLengthSid(AuthenticatedUsers) +
                GetLengthSid(BuiltInAdministrators) +
                GetLengthSid(NetworkService);

    SD = (PSECURITY_DESCRIPTOR)G_ALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH + dwAclSize);
    if( NULL == SD ){ goto cleanup; }

    ZeroMemory( SD, sizeof(SD) );
    
    Acl = (ACL *)((BYTE *)SD + SECURITY_DESCRIPTOR_MIN_LENGTH);

    bResult = InitializeAcl( Acl, dwAclSize, ACL_REVISION);
    if( !bResult ){goto cleanup;}

    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, SYNCHRONIZE | GENERIC_READ, AuthenticatedUsers );
    if( !bResult ){goto cleanup;}

    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, MUTEX_ALL_ACCESS , NetworkService );
    if( !bResult ){goto cleanup;}
    
    bResult = AddAccessAllowedAce(Acl, ACL_REVISION, GENERIC_ALL, BuiltInAdministrators );
    if( !bResult ){goto cleanup;}

    bResult = InitializeSecurityDescriptor(SD, SECURITY_DESCRIPTOR_REVISION);
    if( !bResult ){goto cleanup;}

    bResult = SetSecurityDescriptorDacl(SD, TRUE, Acl,  FALSE);
    if( !bResult ){goto cleanup;}
    
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = SD;
    sa.bInheritHandle = FALSE;

    hPdhPlaMutex = CreateMutexW( &sa, FALSE, PDH_PLA_MUTEX );

cleanup:
    if( hPdhPlaMutex == NULL || !bResult ){
        hr = GetLastError();
    }
    if( NULL != AuthenticatedUsers ){
        FreeSid(AuthenticatedUsers);
    }
    if( NULL != BuiltInAdministrators){
        FreeSid(BuiltInAdministrators);
    }
    if( NULL != NetworkService){
        FreeSid(NetworkService);
    }
    G_FREE(SD);

    return hr;
}

BOOL
_stdcall
PdhDllInitRoutine(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    BOOL    bStatus;
    BOOL    bReturn = TRUE;
    OSVERSIONINFOW   os;
    ReservedAndUnused;

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            bProcessIsDetaching = FALSE;
            {
                DWORD   dwBufferLength = 0;

                ThisDLLHandle = DLLHandle;

                // make sure this is the correct operating system
                memset (&os, 0, sizeof(os));
                os.dwOSVersionInfoSize = sizeof(os);
                bReturn = GetVersionExW (&os);

                if (bReturn) {
                    // check for windows NT v4.0
                    if (os.dwPlatformId != VER_PLATFORM_WIN32_NT) {
                        // not WINDOWS NT
                        bReturn = FALSE;
                    } else if (os.dwMajorVersion < 4) {
                        // it's windows NT, but an old one
                        bReturn = FALSE;
                    }
                } else {
                    // unable to read version so give up
                }

                if (bReturn) {

                    // disable thread init calls
                    DisableThreadLibraryCalls (DLLHandle);

                    // initialize the event log so events can be reported
                    bStatus = PdhiOpenEventLog (&hEventLog);

                    bStatus = PdhiGetRegistryDefaults ();

                    // initialize the local computer name buffer
                    if (szStaticLocalMachineName[0] == 0) {
                        // initialize the computer name for this computer
                        szStaticLocalMachineName[0] = BACKSLASH_L;
                        szStaticLocalMachineName[1] = BACKSLASH_L;
                        dwBufferLength = (sizeof(szStaticLocalMachineName) / sizeof(WCHAR)) - 2;
                        GetComputerNameW (&szStaticLocalMachineName[2], &dwBufferLength);
                    }
                
                    hPdhDataMutex = CreateMutexW (NULL, FALSE, NULL);
                    hPdhContextMutex = CreateMutexW(NULL, FALSE, NULL);

                    hPdhHeap = HeapCreate (0, 0, 0);
                    if (hPdhHeap == NULL) {
                        // unable to create our own heap, so use the
                        // process heap
                        hPdhHeap = GetProcessHeap();
                        assert (hPdhHeap != NULL);
                    }

                    PdhiPlaInitMutex();
                }
            }
            break;

        case DLL_PROCESS_DETACH:

            // close all pending loggers
            //

            bProcessIsDetaching = (ReservedAndUnused != NULL)
                                ? (TRUE) : (FALSE);

            PdhiCloseAllLoggers();

            // walk down query list and close (at least disconnect) queries.
            PdhiQueryCleanup ();

            FreeAllMachines(bProcessIsDetaching);

            PdhiFreeAllWbemServers ();

            if (hPdhDataMutex != NULL) {
                bStatus = CloseHandle (hPdhDataMutex);
                assert (bStatus);
                hPdhDataMutex = NULL;
            }
            if (hPdhContextMutex != NULL) {
                bStatus = CloseHandle (hPdhContextMutex);
                assert (bStatus);
                hPdhContextMutex = NULL;
            }

            if (hPdhHeap != GetProcessHeap()) {
                HeapDestroy (hPdhHeap);
                hPdhHeap = NULL;
            }

            // lastly close the event log interface
            bStatus = PdhiCloseEventLog (&hEventLog);
            bReturn = TRUE;

            break ;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bReturn = TRUE;
            break;
    }

    return (bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\counter.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    counter.c

Abstract:

    counter processing functions exposed in pdh.dll

--*/

#include <windows.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <mbctype.h>
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

__inline
DWORD
PdhiGetStringLength(
    LPWSTR  szString,
    BOOL    bUnicode
)
{
    DWORD dwReturn = 0;

    if (bUnicode) {
        dwReturn = lstrlenW(szString);
    }
    else {
        dwReturn = WideCharToMultiByte(_getmbcp(),
                                       0,
                                       szString,
                                       lstrlenW(szString),
                                       NULL,
                                       0,
                                       NULL,
                                       NULL);
    }
    return dwReturn;
}

STATIC_PDH_FUNCTION
PdhiGetFormattedCounterArray (
    IN      PPDHI_COUNTER           pCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      LPVOID                  ItemBuffer,
    IN      BOOL                    bWideArgs
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    PDH_STATUS  PdhFnStatus = ERROR_SUCCESS;
    DWORD       dwRequiredSize = 0;
    WCHAR       wszInstanceName[1024];
    PPDHI_RAW_COUNTER_ITEM   pThisItem = NULL;
    PPDHI_RAW_COUNTER_ITEM   pLastItem = NULL;
    PDH_RAW_COUNTER          ThisRawCounter;
    PDH_RAW_COUNTER          LastRawCounter;
    LPWSTR                   szThisItem;
    LPWSTR                   szLastItem;
    PPDH_RAW_COUNTER         pThisRawCounter;
    PPDH_RAW_COUNTER         pLastRawCounter;
    PPDH_FMT_COUNTERVALUE_ITEM_W    pThisFmtItem;
    DWORD       dwThisItemIndex;
    LPWSTR      wszNextString;
    DWORD       dwNameLength;
    DWORD       dwRetItemCount = 0;

    PdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus != ERROR_SUCCESS) {
        return PdhStatus;
    }

    // compute required buffer size
    if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
        if (ItemBuffer != NULL) {
            pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W)ItemBuffer;
            if( pCounter->pThisRawItemList == NULL ){
                PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
                goto Cleanup;
            }
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                (sizeof (PDH_FMT_COUNTERVALUE_ITEM_W) *
                    pCounter->pThisRawItemList->dwItemCount));
            // verify 8 byte alignment
            assert (((DWORD)wszNextString & 0x00000007) == 0);
        } else {
            pThisFmtItem = NULL;
            wszNextString = NULL;
        }

        // for multi structs, the buffer required
        dwThisItemIndex = 0;
        dwRequiredSize += (DWORD)(pCounter->pThisRawItemList->dwItemCount) *
                            (bWideArgs ? sizeof (PDH_FMT_COUNTERVALUE_ITEM_W)
                                       : sizeof (PDH_FMT_COUNTERVALUE_ITEM_A));

        for (pThisItem = &(pCounter->pThisRawItemList->pItemArray[0]);
            dwThisItemIndex < pCounter->pThisRawItemList->dwItemCount;
            dwThisItemIndex++, pThisItem++, pLastItem++) {
            szThisItem = (LPWSTR) (  ((LPBYTE) pCounter->pThisRawItemList)
                                   + pThisItem->szName);
            if (bWideArgs) {
                dwRequiredSize += (lstrlenW(szThisItem) + 1) * sizeof(WCHAR);
                if ((dwRequiredSize <= *lpdwBufferSize) && (wszNextString != NULL)) {
                    // this is the only field that is type dependent  (i.e.
                    // wide vs ansi chars.
                    pThisFmtItem->szName = wszNextString;
                    dwNameLength         = lstrlenW(szThisItem) + 1;
                    lstrcpyW (wszNextString, szThisItem);
                    wszNextString       += dwNameLength;
                    PdhStatus            = ERROR_SUCCESS;
                }
                else {
                    PdhStatus = PDH_MORE_DATA;
                }
            }
            else {
                DWORD dwSize = (* lpdwBufferSize < dwRequiredSize)
                             ? (0) : (* lpdwBufferSize - dwRequiredSize);
                PdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            szThisItem, (LPSTR) wszNextString, & dwSize);
                if (wszNextString && PdhStatus == ERROR_SUCCESS) {
                    pThisFmtItem->szName = wszNextString;
                    wszNextString = (LPWSTR) ((LPSTR) wszNextString + dwSize);
                }
                dwRequiredSize += (dwSize * sizeof(CHAR));
            }

            if (PdhStatus == ERROR_SUCCESS) {
                //
                // COMPUTE FORMATTED VALUE HERE!!!
                //

                if (pCounter->pThisRawItemList != NULL) {
                    ThisRawCounter.CStatus = pCounter->pThisRawItemList->CStatus;
                    ThisRawCounter.TimeStamp = pCounter->pThisRawItemList->TimeStamp;
                    ThisRawCounter.FirstValue = pThisItem->FirstValue;
                    ThisRawCounter.SecondValue = pThisItem->SecondValue;
                    ThisRawCounter.MultiCount = pThisItem->MultiCount;
                    pThisRawCounter = &ThisRawCounter;
                } else {
                    memset (&ThisRawCounter, 0, sizeof(ThisRawCounter));
                    pThisRawCounter = NULL;
                }

                if (pCounter->pLastRawItemList != NULL) {
                    // test to see if "This" buffer has more entries than "last" buffer
                    if (dwThisItemIndex < pCounter->pLastRawItemList->dwItemCount) {
                        pLastItem = &(pCounter->pLastRawItemList->pItemArray[dwThisItemIndex]);
                        szLastItem = (LPWSTR)
                                (  ((LPBYTE) pCounter->pLastRawItemList)
                                 + pLastItem->szName);
                        if (lstrcmpiW(szThisItem, szLastItem) == 0) {
                            // the names match so we'll assume this is the correct instance
                            LastRawCounter.CStatus = pCounter->pLastRawItemList->CStatus;
                            LastRawCounter.TimeStamp = pCounter->pLastRawItemList->TimeStamp;
                            LastRawCounter.FirstValue = pLastItem->FirstValue;
                            LastRawCounter.SecondValue = pLastItem->SecondValue;
                            LastRawCounter.MultiCount = pLastItem->MultiCount;
                            pLastRawCounter = &LastRawCounter;
                        } else {
                            // the names DON'T match so we'll try the calc on just
                            // one value. This will work for some (e.g. instantaneous)
                            // counters, but not all
                            memset (&LastRawCounter, 0, sizeof(LastRawCounter));
                            pLastRawCounter = NULL;
                        }
                    } else {
                        // the new buffer is larger than the old one so 
                        // we'll try the calc function on just
                        // one value. This will work for some (e.g. instantaneous)
                        // counters, but not all
                        memset (&LastRawCounter, 0, sizeof(LastRawCounter));
                        pLastRawCounter = NULL;
                    }
                } else {
                    // there is no "previous" counter entry for this counter
                    memset (&LastRawCounter, 0, sizeof(LastRawCounter));
                    pLastRawCounter = NULL;
                }

                PdhFnStatus = PdhiComputeFormattedValue (
                    pCounter->CalcFunc,
                    pCounter->plCounterInfo.dwCounterType,
                    pCounter->lScale,
                    dwFormat,
                    pThisRawCounter,
                    pLastRawCounter,
                    &pCounter->TimeBase,
                    0L,
                    &pThisFmtItem->FmtValue);

                if (PdhFnStatus != ERROR_SUCCESS) {
                    // save the last error encountered for return to the caller
                    PdhStatus = PdhFnStatus;

                    // error in calculation so set the status for this
                    // counter item
                    pThisFmtItem->FmtValue.CStatus = PDH_CSTATUS_INVALID_DATA;
                    // clear the value
                    pThisFmtItem->FmtValue.largeValue = 0;
                }

                // update pointers
                pThisFmtItem++;
            }
        }

        dwRetItemCount = dwThisItemIndex;
    } else {
        if (ItemBuffer != NULL) {
            pThisFmtItem = (PPDH_FMT_COUNTERVALUE_ITEM_W)ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                            (bWideArgs ? sizeof (PDH_FMT_COUNTERVALUE_ITEM_W)
                                       : sizeof (PDH_FMT_COUNTERVALUE_ITEM_A)));
            // verify 8 byte alignment
            assert (((DWORD)wszNextString & 0x00000007) == 0);
        } else {
            pThisFmtItem = NULL;
            wszNextString = NULL;
        }
        // this is a single instance counter so the size required is:
        //      the size of the instance name +
        //      the size of the parent name +
        //      the size of any index parameter +
        //      the size of the value buffer
        //
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            dwRequiredSize += PdhiGetStringLength(
                                  pCounter->pCounterPath->szInstanceName,
                                  bWideArgs);
            if (pCounter->pCounterPath->szParentName != NULL) {
                dwRequiredSize += 1 + PdhiGetStringLength(
                                          pCounter->pCounterPath->szParentName,
                                          bWideArgs);
            }
            if (pCounter->pCounterPath->dwIndex > 0) {
                double dIndex, dLen;
                dIndex = (double) pCounter->pCounterPath->dwIndex; // cast to float
                dLen = floor(log10(dIndex));     // get integer log
                dwRequiredSize  = (DWORD) dLen;  // cast to integer
                dwRequiredSize += 2;             // increment for brackets
            }
            // add in length of null character
            dwRequiredSize += 1;
        }
        // adjust size of required buffer by size of text character
        dwRequiredSize *= ((bWideArgs) ? (sizeof(WCHAR)) : (sizeof(CHAR)));

        // add in length of data structure
        dwRequiredSize += (bWideArgs ? sizeof (PDH_FMT_COUNTERVALUE_ITEM_W)
                                     : sizeof (PDH_FMT_COUNTERVALUE_ITEM_A));

        if ((dwRequiredSize <= *lpdwBufferSize)  & (wszNextString != NULL)) {
            pThisFmtItem->szName = wszNextString;
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                if (bWideArgs) {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        lstrcatW(pThisFmtItem->szName, pCounter->pCounterPath->szParentName);
                        lstrcatW(pThisFmtItem->szName, cszSlash);
                    } else {
                        pThisFmtItem->szName[0] = 0;
                    }
                    lstrcatW(pThisFmtItem->szName, pCounter->pCounterPath->szInstanceName);

                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltow (pCounter->pCounterPath->dwIndex,
                            wszInstanceName, 10);
                        lstrcatW(pThisFmtItem->szName, cszPoundSign);
                        lstrcatW(pThisFmtItem->szName, wszInstanceName);
                    }
                    // update pointers
                    wszNextString +=  lstrlenW(pThisFmtItem->szName) + 1;
                } else {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwNameLength = lstrlenW (pCounter->pCounterPath->szParentName);
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            pCounter->pCounterPath->szParentName,
                                            dwNameLength + 1,
                                            (LPSTR) wszNextString,
                                            (dwNameLength + 1) * sizeof(WCHAR),
                                            NULL,
                                            NULL);

                        wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                      + lstrlenA((LPSTR) wszNextString));
                        dwNameLength  = lstrlenW(cszSlash);
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            cszSlash,
                                            dwNameLength + 1,
                                            (LPSTR) wszNextString,
                                            (dwNameLength + 1 ) * sizeof(WCHAR),
                                            NULL,
                                            NULL);

                        wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                      + lstrlenA((LPSTR) wszNextString));
                    }

                    dwNameLength = lstrlenW(pCounter->pCounterPath->szInstanceName);
                    WideCharToMultiByte(_getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szInstanceName,
                                        dwNameLength + 1,
                                        (LPSTR) wszNextString,
                                        (dwNameLength + 1) * sizeof(WCHAR),
                                        NULL,
                                        NULL);

                    wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                  + lstrlenA((LPSTR) wszNextString));

                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltoa (pCounter->pCounterPath->dwIndex,
                            (LPSTR)wszInstanceName, 10);
                        lstrcatA((LPSTR)wszNextString, caszPoundSign);
                        lstrcatA((LPSTR)wszNextString, (LPSTR)wszInstanceName);
                    }
                    // null terminate the string
                    *((LPSTR)wszNextString) = 0;
                    wszNextString = (LPWSTR)((LPBYTE)wszNextString + 1);

                    // insure alignment on the appropriate boundry
                    assert (bWideArgs ? (((DWORD)wszNextString & 0x00000001) == 0) : TRUE);
                }
            } else {
                *wszNextString = 0;
            }

            PdhFnStatus = PdhiComputeFormattedValue (
                    pCounter->CalcFunc,
                    pCounter->plCounterInfo.dwCounterType,
                    pCounter->lScale,
                    dwFormat,
                    & pCounter->ThisValue,
                    & pCounter->LastValue,
                    & pCounter->TimeBase,
                    0L,
                    & pThisFmtItem->FmtValue);

            if (PdhFnStatus != ERROR_SUCCESS) {
                PdhStatus = PdhFnStatus;
                // error in calculation so set the status for this
                // counter item
                pThisFmtItem->FmtValue.CStatus = PDH_CSTATUS_INVALID_DATA;
                // clear the value
                pThisFmtItem->FmtValue.largeValue = 0;
                // and return the status to the caller
            }
        } else {
            // then this was a real data request so return
            PdhStatus = PDH_MORE_DATA;
        }

        dwRetItemCount = 1;
    }

Cleanup:
    RELEASE_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        // update buffer size and item count buffers
        * lpdwBufferSize = dwRequiredSize;
        * lpdwItemCount  = dwRetItemCount;
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_A    ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    // TODO: Post W2K1 Capture lpdw* to local variables. Capture ItemBuffer

    if ((lpdwBufferSize == NULL) || (lpdwItemCount == NULL)) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (!IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    } else if (!CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    } else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = *lpdwBufferSize;

            // test argument for Read and Write access
            dwItemCount = *lpdwItemCount;

            if (dwBufferSize > 0) {
                // then the buffer must be valid
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte = (LPBYTE)ItemBuffer;
                    dwTest = (DWORD)pByte[0];
                    pByte[0] = 0;
                    pByte[0] = (BYTE)(dwTest & 0x000000FF);

                    dwTest = (DWORD)pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE)(dwTest & 0x000000FF);
                } else {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            } 

            // check for disallowed format options
            if ((dwFormat & PDH_FMT_RAW) ||
                (dwFormat & PDH_FMT_ANSI) ||
                (dwFormat & PDH_FMT_UNICODE) ||
                (dwFormat & PDH_FMT_NODATA)) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetFormattedCounterArray (
            (PPDHI_COUNTER)hCounter,
            dwFormat,
            & dwBufferSize,
            & dwItemCount,
            (LPVOID)ItemBuffer,
            FALSE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      DWORD                   dwFormat,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_FMT_COUNTERVALUE_ITEM_W    ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    // TODO: Post W2K1 Capture lpdw* to local variables. Capture ItemBuffer

    if ((lpdwBufferSize == NULL) || (lpdwItemCount == NULL)) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (!IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    } else if (!CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    } else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = *lpdwBufferSize;

            // test argument for Read and Write access
            dwItemCount = *lpdwItemCount;

            if (dwBufferSize > 0) {
                // then the buffer must be valid
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte = (LPBYTE)ItemBuffer;
                    dwTest = (DWORD)pByte[0];
                    pByte[0] = 0;
                    pByte[0] = (BYTE)(dwTest & 0x000000FF);

                    dwTest = (DWORD)pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE)(dwTest & 0x000000FF);
                } else {
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            } 

            // check for disallowed format options
            if ((dwFormat & PDH_FMT_RAW) ||
                (dwFormat & PDH_FMT_ANSI) ||
                (dwFormat & PDH_FMT_UNICODE) ||
                (dwFormat & PDH_FMT_NODATA)) {
                PdhStatus = PDH_INVALID_ARGUMENT;
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetFormattedCounterArray (
            (PPDHI_COUNTER)hCounter,
            dwFormat,
            & dwBufferSize,
            & dwItemCount,
            (LPVOID)ItemBuffer,
            TRUE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return PdhStatus;
}

STATIC_PDH_FUNCTION
PdhiGetRawCounterArray (
    IN      PPDHI_COUNTER    pCounter,
    IN      LPDWORD          lpdwBufferSize,
    IN      LPDWORD          lpdwItemCount,
    IN      LPVOID           ItemBuffer,
    IN      BOOL             bWideArgs
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwRequiredSize = 0;
    WCHAR       wszInstanceName[1024];
    PPDHI_RAW_COUNTER_ITEM   pThisItem;
    LPWSTR                   szThisItem;
    PPDH_RAW_COUNTER_ITEM_W   pThisRawItem;
    DWORD       dwThisItemIndex;
    LPWSTR      wszNextString;
    DWORD       dwNameLength;
    DWORD       dwRetItemCount = 0;

    PdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
    if (PdhStatus != ERROR_SUCCESS) {
        return PdhStatus;
    }

    // compute required buffer size
    if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
        if (ItemBuffer != NULL) {
            pThisRawItem = (PPDH_RAW_COUNTER_ITEM_W)ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                (sizeof (PDH_RAW_COUNTER_ITEM_W) *
                    pCounter->pThisRawItemList->dwItemCount));
            // verify 8 byte alignment
            assert (((DWORD)wszNextString & 0x00000007) == 0);
        } else {
            pThisRawItem = NULL;
            wszNextString = NULL;
        }

        // for multi structs, the buffer required
        dwThisItemIndex = 0;
        dwRequiredSize += pCounter->pThisRawItemList->dwItemCount *
                            (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W)
                                       : sizeof (PDH_RAW_COUNTER_ITEM_A));

        for (pThisItem = &(pCounter->pThisRawItemList->pItemArray[0]);
            dwThisItemIndex < pCounter->pThisRawItemList->dwItemCount;
            dwThisItemIndex++, pThisItem++) {
            szThisItem = (LPWSTR) (  ((LPBYTE) pCounter->pThisRawItemList)
                                   + pThisItem->szName);
            if (pThisRawItem != NULL) {
                pThisRawItem->szName = wszNextString;
            }
            else {
                PdhStatus = PDH_MORE_DATA;
            }
            if (bWideArgs) {
                dwNameLength = lstrlenW(szThisItem) + 1;
                if (   (dwRequiredSize <= * lpdwBufferSize)
                    && (wszNextString != NULL)) {
                    lstrcpyW (wszNextString, szThisItem);
                    wszNextString += dwNameLength;
                }
                else {
                    PdhStatus = PDH_MORE_DATA;
                    if (pThisRawItem != NULL) pThisRawItem->szName = NULL;
                }
                dwRequiredSize += (dwNameLength * sizeof(WCHAR));
            }
            else {
                dwNameLength = (dwRequiredSize <= * lpdwBufferSize)
                             ? (* lpdwBufferSize - dwRequiredSize) : (0);
                PdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            szThisItem,
                            (LPSTR) wszNextString,
                            & dwNameLength);
                if (PdhStatus == ERROR_SUCCESS) {
                    wszNextString = (LPWSTR)
                            (((LPSTR) wszNextString) + dwNameLength);
                }
                else if (pThisRawItem != NULL) {
                    pThisRawItem->szName = NULL;
                }
                dwRequiredSize += (dwNameLength * sizeof(CHAR));
            }

            if (PdhStatus == ERROR_SUCCESS) {
                pThisRawItem->RawValue.CStatus = pCounter->pThisRawItemList->CStatus;
                pThisRawItem->RawValue.TimeStamp = pCounter->pThisRawItemList->TimeStamp;
                pThisRawItem->RawValue.FirstValue = pThisItem->FirstValue;
                pThisRawItem->RawValue.SecondValue = pThisItem->SecondValue;
                pThisRawItem->RawValue.MultiCount = pThisItem->MultiCount;

                // update pointers
                pThisRawItem++;
            }
        }
        dwRetItemCount = dwThisItemIndex;
    } else {
        if (ItemBuffer != NULL) {
            pThisRawItem = (PPDH_RAW_COUNTER_ITEM_W)ItemBuffer;
            wszNextString = (LPWSTR)((LPBYTE)ItemBuffer +
                            (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W)
                                       : sizeof (PDH_RAW_COUNTER_ITEM_A)));
            // verify 8 byte alignment
            assert (((DWORD)wszNextString & 0x00000007) == 0);
        } else {
            pThisRawItem = NULL;
            wszNextString = NULL;
        }
        // this is a single instance counter so the size required is:
        //      the size of the instance name +
        //      the size of the parent name +
        //      the size of any index parameter +
        //      the size of the value buffer
        //
        if (pCounter->pCounterPath->szInstanceName != NULL) {
            dwRequiredSize += PdhiGetStringLength(
                                  pCounter->pCounterPath->szInstanceName,
                                  bWideArgs);
            if (pCounter->pCounterPath->szParentName != NULL) {
                dwRequiredSize += 1 + PdhiGetStringLength(
                                          pCounter->pCounterPath->szParentName,
                                          bWideArgs);
            }
            if (pCounter->pCounterPath->dwIndex > 0) {
                double dIndex, dLen;
                dIndex = (double)pCounter->pCounterPath->dwIndex; // cast to float
                dLen = floor(log10(dIndex));     // get integer log
                dwRequiredSize  = (DWORD)dLen;   // cast to integer
                dwRequiredSize += 1;             // increment for pound sign
            }
            // add in length of two null characters
            // this still has to look like an MSZ even if there is
            // is only one string in the buffer
            dwRequiredSize += 1;
        }
        // adjust size of required buffer by size of text character
        dwRequiredSize *= ((bWideArgs) ? (sizeof(WCHAR)) : (sizeof(CHAR)));

        // add in length of data structure
        dwRequiredSize +=  (bWideArgs ? sizeof (PDH_RAW_COUNTER_ITEM_W)
                                      : sizeof (PDH_RAW_COUNTER_ITEM_A));

        if ((dwRequiredSize <= *lpdwBufferSize)  && (wszNextString != NULL)) {
            if (pThisRawItem != NULL) {
                pThisRawItem->szName = wszNextString;
            }
            else {
                PdhStatus = PDH_MORE_DATA;
            }
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                if (bWideArgs) {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        lstrcpyW(pThisRawItem->szName, pCounter->pCounterPath->szParentName);
                        lstrcatW(pThisRawItem->szName, cszSlash);
                        lstrcatW(pThisRawItem->szName, pCounter->pCounterPath->szInstanceName);
                    } else {
                        lstrcpyW(pThisRawItem->szName, pCounter->pCounterPath->szInstanceName);
                    }
                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltow (pCounter->pCounterPath->dwIndex,
                            wszInstanceName, 10);
                        lstrcatW(pThisRawItem->szName, cszPoundSign);
                        lstrcatW(pThisRawItem->szName, wszInstanceName);
                    }
                    dwNameLength = lstrlenW(pThisRawItem->szName) + 1;
                    wszNextString += dwNameLength;
                } else {
                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwNameLength = lstrlenW (pCounter->pCounterPath->szParentName);
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            pCounter->pCounterPath->szParentName,
                                            dwNameLength + 1,
                                            (LPSTR) wszNextString,
                                            (dwNameLength + 1) * sizeof(WCHAR),
                                            NULL,
                                            NULL);
                        wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                      + lstrlenA((LPSTR) wszNextString));
                        dwNameLength = lstrlenW(cszSlash);
                        WideCharToMultiByte(_getmbcp(),
                                            0,
                                            cszSlash,
                                            dwNameLength + 1,
                                            (LPSTR) wszNextString,
                                            (dwNameLength + 1) * sizeof(WCHAR),
                                            NULL,
                                            NULL);
                        wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                      + lstrlenA((LPSTR) wszNextString));
                    }
                    dwNameLength = lstrlenW(pCounter->pCounterPath->szInstanceName);
                    WideCharToMultiByte(_getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szInstanceName,
                                        dwNameLength + 1,
                                        (LPSTR) wszNextString,
                                        (dwNameLength + 1) * sizeof(WCHAR),
                                        NULL,
                                        NULL);
                    wszNextString = (LPWSTR) ((LPSTR) wszNextString
                                  + lstrlenA((LPSTR) wszNextString));
                    if (pCounter->pCounterPath->dwIndex > 0) {
                        _ltoa (pCounter->pCounterPath->dwIndex,
                            (LPSTR)wszInstanceName, 10);
                        lstrcpyA((LPSTR)wszNextString, caszPoundSign);
                        lstrcatA((LPSTR)wszNextString, (LPSTR)wszInstanceName);
                        dwNameLength = lstrlenA((LPSTR)wszNextString) + 1;
                        wszNextString = (LPWSTR)((LPSTR)wszNextString + dwNameLength);
                    }
                    // null terminate the string
                    *((LPSTR)wszNextString) = 0;
                    wszNextString = (LPWSTR)((LPBYTE)wszNextString + 1);
                }
            } else {
                *wszNextString++ = 0;
            }
            pThisRawItem->RawValue = pCounter->ThisValue;
        } else {
            // then this was a real data request so return
            PdhStatus = PDH_MORE_DATA;
        }

        dwRetItemCount = 1;
    }

    RELEASE_MUTEX(pCounter->pOwner->hMutex);

    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        // update buffer size and item count buffers
        *lpdwBufferSize = dwRequiredSize;
        *lpdwItemCount = dwRetItemCount;
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetRawCounterArrayA (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_A ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    // TODO: Post W2K1 Capture lpdw* to local variables. Capture ItemBuffer

    if ((lpdwBufferSize == NULL) || (lpdwItemCount == NULL)) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (!IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    } else if (!CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    } else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = *lpdwBufferSize;

            // test argument for Read and Write access
            dwItemCount = *lpdwItemCount;

            if (dwBufferSize > 0) {
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte = (LPBYTE)ItemBuffer;
                    dwTest = (DWORD)pByte[0];
                    pByte[0] = 0;
                    pByte[0] = (BYTE)(dwTest & 0x000000FF);

                    dwTest = (DWORD)pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE)(dwTest & 0x000000FF);
                } else {
                    // if the buffer size is > 0, then a pointer
                    // must be non-null & valid
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetRawCounterArray (
                (PPDHI_COUNTER) hCounter,
                & dwBufferSize,
                & dwItemCount,
                (LPVOID) ItemBuffer,
                FALSE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetRawCounterArrayW (
    IN      HCOUNTER                hCounter,
    IN      LPDWORD                 lpdwBufferSize,
    IN      LPDWORD                 lpdwItemCount,
    IN      PPDH_RAW_COUNTER_ITEM_W ItemBuffer
)
{
    PDH_STATUS  PdhStatus = ERROR_SUCCESS;
    DWORD       dwBufferSize;
    DWORD       dwItemCount;
    DWORD       dwTest;
    LPBYTE      pByte;

    // TODO: Post W2K1 Capture lpdw* to local variables. Capture ItemBuffer

    if ((lpdwBufferSize == NULL) || (lpdwItemCount == NULL)) {
        PdhStatus = PDH_INVALID_ARGUMENT;
    }
    else if (!IsValidCounter(hCounter)) {
        PdhStatus = PDH_INVALID_HANDLE;
    } else if (!CounterIsOkToUse (hCounter)) {
        PdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
    } else {
        // validate arguments
        __try {
            // test argument for Read and Write access
            dwBufferSize = *lpdwBufferSize;

            // test argument for Read and Write access
            dwItemCount = *lpdwItemCount;

            if (dwBufferSize > 0) {
                if (ItemBuffer != NULL) {
                    // NULL is a valid value for this parameter
                    // test both ends of the buffer passed in
                    pByte = (LPBYTE)ItemBuffer;
                    dwTest = (DWORD)pByte[0];
                    pByte[0] = 0;
                    pByte[0] = (BYTE)(dwTest & 0x000000FF);

                    dwTest = (DWORD)pByte[dwBufferSize -1];
                    pByte[dwBufferSize -1] = 0;
                    pByte[dwBufferSize -1] = (BYTE)(dwTest & 0x000000FF);
                } else {
                    // if the buffer size is > 0, then a pointer
                    // must be non-null & valid
                    PdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (PdhStatus == ERROR_SUCCESS) {
        PdhStatus = PdhiGetRawCounterArray (
                (PPDHI_COUNTER) hCounter,
                & dwBufferSize,
                & dwItemCount,
                (LPVOID) ItemBuffer,
                TRUE);
    }
    if (PdhStatus == ERROR_SUCCESS || PdhStatus == PDH_MORE_DATA) {
        __try {
            * lpdwBufferSize = dwBufferSize;
            * lpdwItemCount  = dwItemCount;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetFormattedCounterValue (
    IN      HCOUNTER    hCounter,
    IN      DWORD       dwFormat,
    IN      LPDWORD     lpdwType,
    IN      PPDH_FMT_COUNTERVALUE      pValue
)
/*++

Routine Description:

    Function to retrieve, computer and format the specified counter's
        current value. The values used are those currently in the counter
        buffer. (The data is not collected by this routine.)

Arguments:

    IN      HCOUNTER    hCounter
        the handle to the counter whose value should be returned

    IN      DWORD       dwFormat
        the format flags that define how the counter value should be
        formatted prior for return. These flags are defined in the
        PDH.H header file.

    IN      LPDWORD     lpdwType
        an optional buffer in which the counter type value can be returned.
        For the prototype, the flag values are defined in WINPERF.H

    IN      PPDH_FMT_COUNTERVALUE      pValue
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is not correct or is
                incorrectly formatted.
            PDH_INVALID_DATA if the counter does not contain valid data
                or a successful status code

--*/
{
    PPDHI_COUNTER   pCounter;
    PDH_STATUS      lStatus = ERROR_SUCCESS;
    PDH_FMT_COUNTERVALUE    LocalCounterValue;
    DWORD   dwTypeMask;

    // TODO: Why bother with testing for NON-NULL stuff in mutex?
    // Check for obvious lpdwType != NULL & pValue != NULL before mutex.

    if (pValue == NULL) {
        lStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            if (pValue != NULL) {
                pValue->CStatus = (DWORD)-1;
                pValue->longValue = (LONGLONG)0;
            } else {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (lStatus == ERROR_SUCCESS) {
        lStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
        if (lStatus != ERROR_SUCCESS) {
            // bail out here
            return lStatus;
        }

        if (!IsValidCounter(hCounter)) {
            lStatus = PDH_INVALID_HANDLE;
        }
        else if (!CounterIsOkToUse(hCounter)) {
            lStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        } else {
            // validate format flags:
            //      only one of the following can be set at a time
            dwTypeMask = dwFormat &
                (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            if (!((dwTypeMask == PDH_FMT_LONG) ||
                (dwTypeMask == PDH_FMT_DOUBLE) ||
                (dwTypeMask == PDH_FMT_LARGE))) {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            // get counter pointer
            pCounter = (PPDHI_COUNTER)hCounter;

            // lock query while reading the data
            lStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (lStatus == ERROR_SUCCESS) {

                // compute and format current value
                lStatus = PdhiComputeFormattedValue (
                    pCounter->CalcFunc,
                    pCounter->plCounterInfo.dwCounterType,
                    pCounter->lScale,
                    dwFormat,
                    &pCounter->ThisValue,
                    &pCounter->LastValue,
                    &pCounter->TimeBase,
                    0L,
                    &LocalCounterValue);

                RELEASE_MUTEX(pCounter->pOwner->hMutex);

                __try {
                    if (lpdwType != NULL) {
                        *lpdwType = pCounter->plCounterInfo.dwCounterType;
                    } // NULL is OK, the counter type will not be returned, though
                    *pValue = LocalCounterValue;
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = PDH_INVALID_ARGUMENT;
                }            
            }
        }

        RELEASE_MUTEX (hPdhDataMutex);
    }

    return lStatus;
}

PDH_FUNCTION
PdhGetRawCounterValue (
    IN      HCOUNTER    hCounter,
    IN      LPDWORD     lpdwType,
    IN      PPDH_RAW_COUNTER      pValue
)
/*++

Routine Description:

    Function to retrieve the specified counter's current raw value.
        The values used are those currently in the counter
        buffer. (The data is not collected by this routine.)

Arguments:

    IN      HCOUNTER    hCounter
        the handle to the counter whose value should be returned

    IN      LPDWORD     lpdwType
        an optional buffer in which the counter type value can be returned.
        This value must be NULL if this info is not desired.
        For the prototype, the flag values are defined in WINPERF.H

    IN      PPDH_RAW_COUNTER      pValue
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is formatted incorrectly
--*/
{
    PDH_STATUS  Status = ERROR_SUCCESS;
    PPDHI_COUNTER pCounter;

    if (pValue == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    } else {

        Status = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
        if (Status == ERROR_SUCCESS) {
            // validate arguments before retrieving the data

            if (!IsValidCounter(hCounter)) {
                Status = PDH_INVALID_HANDLE;
            }
            else if (!CounterIsOkToUse(hCounter)) {
                Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
            } else {
                // the handle is good so try the rest of the args
                pCounter = (PPDHI_COUNTER)hCounter;

                Status = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
                if (Status == ERROR_SUCCESS) {
                    __try {
                        // try to write to the arguments passed in
                        *pValue = pCounter->ThisValue;
                        if (lpdwType != NULL) {
                            *lpdwType = pCounter->plCounterInfo.dwCounterType;
                        } // NULL is OK
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = PDH_INVALID_ARGUMENT;
                    }

                    RELEASE_MUTEX(pCounter->pOwner->hMutex);
                }
            }
            RELEASE_MUTEX (hPdhDataMutex);
        }
    }

    return Status;
}

PDH_FUNCTION
PdhCalculateCounterFromRawValue (
    IN      HCOUNTER    hCounter,
    IN      DWORD       dwFormat,
    IN      PPDH_RAW_COUNTER    rawValue1,
    IN      PPDH_RAW_COUNTER    rawValue2,
    IN      PPDH_FMT_COUNTERVALUE   fmtValue
)
/*++

Routine Description:

    Calculates the formatted counter value using the data in the RawValue
        buffer in the format requested by the format field using the
        calculation functions of the counter type defined by the dwType
        field.

Arguments:

    IN      HCOUNTER    hCounter
        The handle of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffer

    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.

    IN      PPDH_RAW_COUNTER    rawValue1
        pointer to the buffer that contains the first raw value structure

    IN      PPDH_RAW_COUNTER    rawValue2
        pointer to the buffer that contains the second raw value structure.
        This argument may be null if only one value is required for the
        computation.

    IN      PPDH_FMT_COUNTERVALUE   fmtValue
        the pointer to the data buffer passed by the caller to receive
        the data requested. If the counter requires 2 values, (as in the
        case of a rate counter), rawValue1 is assumed to be the most
        recent value and rawValue2, the older value.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect

--*/
{
    PDH_STATUS      lStatus = ERROR_SUCCESS;
    PPDHI_COUNTER   pCounter;
    DWORD           dwTypeMask;
    PDH_FMT_COUNTERVALUE    pdhLocalCounterValue;

    if (fmtValue == NULL) {
        lStatus = PDH_INVALID_ARGUMENT;
    } else {
        lStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (lStatus == ERROR_SUCCESS) {
        // validate arguments
        if (!IsValidCounter(hCounter)) {
            lStatus = PDH_INVALID_HANDLE;
        }
        else if (!CounterIsOkToUse(hCounter)) {
            lStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        } else {
            // the handle is valid so check the rest of the arguments
            // validate format flags:
            dwTypeMask = dwFormat &
                (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            //      only one of the following can be set at a time
            if (!((dwTypeMask == PDH_FMT_LONG) ||
                (dwTypeMask == PDH_FMT_DOUBLE) ||
                (dwTypeMask == PDH_FMT_LARGE))) {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER)hCounter;

            lStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (lStatus == ERROR_SUCCESS) {

                lStatus = PdhiComputeFormattedValue (
                    (((PPDHI_COUNTER)hCounter)->CalcFunc),
                    (((PPDHI_COUNTER)hCounter)->plCounterInfo.dwCounterType),
                    (((PPDHI_COUNTER)hCounter)->lScale),
                    dwFormat,
                    rawValue1,
                    rawValue2,
                    &((PPDHI_COUNTER)hCounter)->TimeBase,
                    0L,
                    &pdhLocalCounterValue);

                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            
                __try {
                    *fmtValue = pdhLocalCounterValue;
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    lStatus = PDH_INVALID_ARGUMENT;
                }
            }
        }
        RELEASE_MUTEX (hPdhDataMutex);
    }

    return lStatus;
}

PDH_FUNCTION
PdhComputeCounterStatistics (
    IN      HCOUNTER    hCounter,
    IN      DWORD       dwFormat,
    IN      DWORD       dwFirstEntry,
    IN      DWORD       dwNumEntries,
    IN      PPDH_RAW_COUNTER   lpRawValueArray,
    IN      PPDH_STATISTICS     data
)
/*++

Routine Description:

    Reads an array of raw value structures of the counter type specified in
        the dwType field, computes the counter values of each and formats
        and returns a statistics structure that contains the following
        statistical data from the counter information:

            Minimum     The smallest value of the computed counter values
            Maximum     The largest value of the computed counter values
            Mean        The arithmetic mean (average) of the computed values
            Median      The median value of the computed counter values

Arguments:

    IN      HCOUNTER    hCounter
        The handle of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffer

    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.

    IN      DWORD       dwNumEntries
        the number of raw value entries for the specified counter type

    IN      PPDH_RAW_COUNTER      lpRawValueArray
        pointer to the array of raw value entries to be evaluated

    IN      PPDH_STATISTICS data
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:

    The WIN32 Error status of the function's operation. Note that the
        function can return successfully even though no data was calc-
        ulated. The  status value in the statistics data buffer must be
        tested to insure the data is valid before it's used by an
        application.  Common values returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect

--*/
{
    PPDHI_COUNTER   pCounter;
    PDH_STATUS      Status = ERROR_SUCCESS;
    DWORD   dwTypeMask;

    if ((lpRawValueArray == NULL) || (data == NULL)) {
        Status = PDH_INVALID_ARGUMENT;
    } else {
        Status = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    }
    if (Status == ERROR_SUCCESS) {
        if (!IsValidCounter(hCounter)) {
            Status = PDH_INVALID_HANDLE;
        }
        else if (!CounterIsOkToUse(hCounter)) {
            Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        } else {
            // counter handle is valid so test the rest of the
            // arguments
            // validate format flags:
            //      only one of the following can be set at a time
            dwTypeMask = dwFormat &
                (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            if (!((dwTypeMask == PDH_FMT_LONG) ||
                (dwTypeMask == PDH_FMT_DOUBLE) ||
                (dwTypeMask == PDH_FMT_LARGE))) {
                Status = PDH_INVALID_ARGUMENT;
            }
        }

        if (Status == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER)hCounter;

            Status = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (Status == ERROR_SUCCESS) {
                __try {
                    DWORD   dwTest;
                    // we should have read access to the Raw Data
                    dwTest = *((DWORD volatile *)&lpRawValueArray->CStatus);

                    if (dwFirstEntry >= dwNumEntries) {
                        Status = PDH_INVALID_ARGUMENT;
                    } else {
                        // call satistical function for this counter
                        Status = (*pCounter->StatFunc)(
                            pCounter,
                            dwFormat,
                            dwFirstEntry,
                            dwNumEntries,
                            lpRawValueArray,
                            data);
                    }
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    Status = PDH_INVALID_ARGUMENT;
                }

                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            }
        }

        RELEASE_MUTEX (hPdhDataMutex);
    }

    return Status;
}

STATIC_PDH_FUNCTION
PdhiGetCounterInfo (
    IN      HCOUNTER    hCounter,
    IN      BOOLEAN     bRetrieveExplainText,
    IN      LPDWORD     pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W  lpBuffer,
    IN      BOOL        bUnicode
)
/*++

Routine Description:

    Examines the specified counter and returns the configuration and
        status information of the counter.

Arguments:

    IN      HCOUNTER    hCounter
        Handle to the desired counter.

    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text

    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.

    IN      LPPDH_COUNTER_INFO_W  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.

    IN      BOOL        bUnicode
        TRUE if wide character strings should be returned
        FALSE if ANSI strings should be returned

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect

--*/
{
    PDH_STATUS      Status = ERROR_SUCCESS;

    DWORD           dwSizeRequired = 0;
    DWORD           dwPathLength;
    DWORD           dwMachineLength;
    DWORD           dwObjectLength;
    DWORD           dwInstanceLength;
    DWORD           dwParentLength;
    DWORD           dwNameLength = 0;
    DWORD           dwHelpLength = 0;
    PPDHI_COUNTER   pCounter;
    DWORD           dwBufferSize = 0;

    Status = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);

    if (Status == ERROR_SUCCESS) {

        if (!IsValidCounter(hCounter)) {
            Status = PDH_INVALID_HANDLE;
        }
        else if (!CounterIsOkToUse(hCounter)) {
            Status = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        } else {
            // the counter is valid so test the remaining arguments
            __try {
                if (pdwBufferSize != NULL) {
                    // test read & write access
                    dwBufferSize = *pdwBufferSize;
                } else {
                    // this cannot be NULL
                    Status = PDH_INVALID_ARGUMENT;
                }

                if (Status == ERROR_SUCCESS) {
                    // test return buffer for write access at
                    // both ends of the buffer
                    if ((lpBuffer != NULL) && (dwBufferSize > 0)) {
                        *(LPDWORD)lpBuffer = 0;
                        ((LPBYTE)lpBuffer)[dwBufferSize - 1] = 0;
                    }
                }
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                Status = PDH_INVALID_ARGUMENT;
            }
        }

        if (Status == ERROR_SUCCESS) {
            pCounter = (PPDHI_COUNTER) hCounter;

            Status = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);

            if (Status == ERROR_SUCCESS) {

                // check for a "no string" request
                if ((dwBufferSize == sizeof (PDH_COUNTER_INFO_W)) &&
                    (lpBuffer != NULL)) {
                    // then return all but the strings
                    // room for the basic structure so load it
                    lpBuffer->dwLength = dwSizeRequired; // this will be updated later
                    lpBuffer->dwType = pCounter->plCounterInfo.dwCounterType;
                    lpBuffer->CVersion = pCounter->CVersion;
                    lpBuffer->CStatus = pCounter->ThisValue.CStatus;
                    lpBuffer->lScale = pCounter->lScale;
                    lpBuffer->lDefaultScale = pCounter->plCounterInfo.lDefaultScale;
                    lpBuffer->dwUserData = pCounter->dwUserData;
                    lpBuffer->dwQueryUserData = pCounter->pOwner->dwUserData;
                    lpBuffer->szFullPath = NULL;
                    lpBuffer->szMachineName = NULL;
                    lpBuffer->szObjectName = NULL;
                    lpBuffer->szInstanceName = NULL;
                    lpBuffer->szParentInstance = NULL;
                    lpBuffer->dwInstanceIndex = 0L;
                    lpBuffer->szCounterName = NULL;
                    lpBuffer->szExplainText = NULL;
                    lpBuffer->DataBuffer[0] = 0;

                    // the size value is ok to leave as is
                } else {
                    // this is a size/full request so continue

                    // compute size of data to return
                    dwSizeRequired = sizeof (PDH_COUNTER_INFO_W) - sizeof(DWORD);   // size of struct
                    // this should already end on a DWORD boundry

                    dwPathLength     = 1 + PdhiGetStringLength(
                                       pCounter->szFullName,
                                       bUnicode);
                    dwPathLength    *= (bUnicode ? sizeof(WCHAR)
                                                 : sizeof(CHAR));
                    dwPathLength     = DWORD_MULTIPLE(dwPathLength);
                    dwSizeRequired  += dwPathLength;

                    dwMachineLength  = 1 + PdhiGetStringLength(
                                       pCounter->pCounterPath->szMachineName,
                                       bUnicode);
                    dwMachineLength *= (bUnicode ? sizeof(WCHAR)
                                                 : sizeof(CHAR));
                    dwMachineLength  = DWORD_MULTIPLE(dwMachineLength);
                    dwSizeRequired  += dwMachineLength;

                    dwObjectLength   = 1 + PdhiGetStringLength(
                                       pCounter->pCounterPath->szObjectName,
                                       bUnicode);
                    dwObjectLength  *= (bUnicode ? sizeof(WCHAR)
                                                 : sizeof(CHAR));
                    dwObjectLength   = DWORD_MULTIPLE(dwObjectLength);
                    dwSizeRequired  += dwObjectLength;

                    if (pCounter->pCounterPath->szInstanceName != NULL) {
                        dwInstanceLength   = 1 + PdhiGetStringLength(
                                       pCounter->pCounterPath->szInstanceName,
                                       bUnicode);
                        dwInstanceLength  *= (bUnicode ? sizeof(WCHAR)
                                                       : sizeof(CHAR));
                        dwInstanceLength   = DWORD_MULTIPLE(dwInstanceLength);
                        dwSizeRequired  += dwInstanceLength;
                    } else {
                        dwInstanceLength = 0;
                    }

                    if (pCounter->pCounterPath->szParentName != NULL) {
                        dwParentLength   = 1 + PdhiGetStringLength(
                                       pCounter->pCounterPath->szParentName,
                                       bUnicode);
                        dwParentLength  *= (bUnicode ? sizeof(WCHAR)
                                                     : sizeof(CHAR));
                        dwParentLength   = DWORD_MULTIPLE(dwParentLength);
                        dwSizeRequired  += dwParentLength;
                    } else {
                        dwParentLength = 0;
                    }

                    dwNameLength    = 1 + PdhiGetStringLength(
                                      pCounter->pCounterPath->szCounterName,
                                       bUnicode);
                    dwNameLength   *= (bUnicode ? sizeof(WCHAR)
                                                : sizeof(CHAR));
                    dwNameLength    = DWORD_MULTIPLE(dwNameLength);
                    dwSizeRequired += dwNameLength;

                    if (bRetrieveExplainText) {
                        if (pCounter->szExplainText != NULL) {
                            dwHelpLength    = 1 + PdhiGetStringLength(
                                              pCounter->szExplainText,
                                              bUnicode);
                            dwHelpLength   *= (bUnicode ? sizeof(WCHAR)
                                                        : sizeof(CHAR));
                            dwHelpLength    = DWORD_MULTIPLE(dwHelpLength);
                        } else {
                            dwHelpLength = 0;
                        }
                        dwSizeRequired  += dwHelpLength;
                    }

                    if (dwBufferSize < dwSizeRequired) {
                        // either way, no data will be transferred
                        Status = PDH_MORE_DATA;
                    } else if (lpBuffer != NULL) {
                        // should be enough room in the buffer, so continue
                        lpBuffer->dwLength = dwSizeRequired;
                        lpBuffer->dwType = pCounter->plCounterInfo.dwCounterType;
                        lpBuffer->CVersion = pCounter->CVersion;
                        lpBuffer->CStatus = pCounter->ThisValue.CStatus;
                        lpBuffer->lScale = pCounter->lScale;
                        lpBuffer->lDefaultScale = pCounter->plCounterInfo.lDefaultScale;
                        lpBuffer->dwUserData = pCounter->dwUserData;
                        lpBuffer->dwQueryUserData = pCounter->pOwner->dwUserData;

                        // do string data now
                        lpBuffer->szFullPath = (LPWSTR)&lpBuffer->DataBuffer[0];
                        if (bUnicode) {
                            lstrcpyW (lpBuffer->szFullPath, pCounter->szFullName);
                        } else {
                            WideCharToMultiByte(_getmbcp(),
                                                0,
                                                pCounter->szFullName,
                                                lstrlenW(pCounter->szFullName),
                                                (LPSTR) lpBuffer->szFullPath,
                                                dwPathLength,
                                                NULL,
                                                NULL);
                        }

                        lpBuffer->szMachineName = (LPWSTR)((LPBYTE)lpBuffer->szFullPath +
                            dwPathLength);
                        if (bUnicode) {
                            lstrcpyW (lpBuffer->szMachineName,
                                pCounter->pCounterPath->szMachineName);
                        } else {
                            WideCharToMultiByte(
                                    _getmbcp(),
                                    0,
                                    pCounter->pCounterPath->szMachineName,
                                    lstrlenW(pCounter->pCounterPath->szMachineName),
                                    (LPSTR) lpBuffer->szMachineName,
                                    dwMachineLength,
                                    NULL,
                                    NULL);
                        }

                        lpBuffer->szObjectName = (LPWSTR)((LPBYTE)lpBuffer->szMachineName +
                            dwMachineLength);
                        if (bUnicode){
                            lstrcpyW (lpBuffer->szObjectName,
                                pCounter->pCounterPath->szObjectName);
                        } else {
                            WideCharToMultiByte(
                                    _getmbcp(),
                                    0,
                                    pCounter->pCounterPath->szObjectName,
                                    lstrlenW(pCounter->pCounterPath->szObjectName),
                                    (LPSTR) lpBuffer->szObjectName,
                                    dwObjectLength,
                                    NULL,
                                    NULL);
                        }
                        lpBuffer->szInstanceName = (LPWSTR)((LPBYTE)lpBuffer->szObjectName +
                            dwObjectLength);

                        if (dwInstanceLength > 0) {
                            if (bUnicode) {
                                lstrcpyW (lpBuffer->szInstanceName,
                                    pCounter->pCounterPath->szInstanceName);
                            } else {
                                WideCharToMultiByte(
                                        _getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szInstanceName,
                                        lstrlenW(pCounter->pCounterPath->szInstanceName),
                                        (LPSTR) lpBuffer->szInstanceName,
                                        dwInstanceLength,
                                        NULL,
                                        NULL);
                            }
                            lpBuffer->szParentInstance = (LPWSTR)((LPBYTE)lpBuffer->szInstanceName +
                                dwInstanceLength);
                        } else {
                            lpBuffer->szParentInstance = lpBuffer->szInstanceName;
                            lpBuffer->szInstanceName = NULL;
                        }

                        if (dwParentLength > 0) {
                            if (bUnicode) {
                                lstrcpyW (lpBuffer->szParentInstance,
                                    pCounter->pCounterPath->szParentName);
                            } else {
                                WideCharToMultiByte(
                                        _getmbcp(),
                                        0,
                                        pCounter->pCounterPath->szParentName,
                                        lstrlenW(pCounter->pCounterPath->szParentName),
                                        (LPSTR) lpBuffer->szParentInstance,
                                        dwParentLength,
                                        NULL,
                                        NULL);
                            }
                            lpBuffer->szCounterName = (LPWSTR)((LPBYTE)lpBuffer->szParentInstance +
                                dwParentLength);
                        } else {
                            lpBuffer->szCounterName = lpBuffer->szParentInstance;
                            lpBuffer->szParentInstance = NULL;
                        }

                        lpBuffer->dwInstanceIndex = pCounter->pCounterPath->dwIndex;

                        if (bUnicode) {
                            lstrcpyW (lpBuffer->szCounterName,
                                pCounter->pCounterPath->szCounterName);
                        } else {
                            WideCharToMultiByte(
                                    _getmbcp(),
                                    0,
                                    pCounter->pCounterPath->szCounterName,
                                    lstrlenW(pCounter->pCounterPath->szCounterName),
                                    (LPSTR) lpBuffer->szCounterName,
                                    dwNameLength,
                                    NULL,
                                    NULL);
                        }

                        if ((pCounter->szExplainText != NULL) && bRetrieveExplainText) {
                            // copy explain text
                            lpBuffer->szExplainText = (LPWSTR)((LPBYTE)lpBuffer->szCounterName +
                                dwNameLength);
                            if (bUnicode) {
                                lstrcpyW (lpBuffer->szExplainText, pCounter->szExplainText);
                            } else {
                                WideCharToMultiByte(
                                        _getmbcp(),
                                        0,
                                        pCounter->szExplainText,
                                        lstrlenW(pCounter->szExplainText),
                                        (LPSTR) lpBuffer->szExplainText,
                                        dwHelpLength,
                                        NULL,
                                        NULL);
                            }
                        } else {
                            lpBuffer->szExplainText = NULL;
                        }
                    }
                    __try {
                        * pdwBufferSize = dwSizeRequired;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = PDH_INVALID_ARGUMENT;
                    }
                }

                RELEASE_MUTEX(pCounter->pOwner->hMutex);
            }
        }

        RELEASE_MUTEX (hPdhDataMutex);
    }


    return Status;
}

PDH_FUNCTION
PdhGetCounterInfoW (
    IN      HCOUNTER    hCounter,
    IN      BOOLEAN     bRetrieveExplainText,
    IN      LPDWORD     pdwBufferSize,
    IN      PPDH_COUNTER_INFO_W  lpBuffer
)
/*++

Routine Description:

    Examines the specified counter and returns the configuration and
        status information of the counter.

Arguments:

    IN      HCOUNTER    hCounter
        Handle to the desired counter.

    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text

    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.

    IN      LPPDH_COUNTER_INFO_W  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect

--*/
{
    return PdhiGetCounterInfo (
            hCounter,
            bRetrieveExplainText,
            pdwBufferSize,
            lpBuffer,
            TRUE);
}

PDH_FUNCTION
PdhGetCounterInfoA (
    IN      HCOUNTER    hCounter,
    IN      BOOLEAN     bRetrieveExplainText,
    IN      LPDWORD     pdwBufferSize,
    IN      PPDH_COUNTER_INFO_A  lpBuffer
)
/*++

Routine Description:

    Examines the specified counter and returns the configuration and
        status information of the counter.

Arguments:

    IN      HCOUNTER    hCounter
        Handle to the desired counter.

    IN      BOOLEAN     bRetrieveExplainText
        TRUE will fill in the explain text structure
        FALSE will return a null pointer in the explain text

    IN      LPDWORD     pcchBufferSize
        The address of the buffer that contains the size of the data buffer
        passed by the caller. On entry, the value in the buffer is the
        size of the data buffer in bytes. On return, this value is the size
        of the buffer returned. If the buffer is not large enough, then
        this value is the size that the buffer needs to be in order to
        hold the requested data.

    IN      LPPDH_COUNTER_INFO_A  lpBuffer
        the pointer to the data buffer passed by the caller to receive
        the data requested.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_MORE_DATA when the buffer passed by the caller is too small
            PDH_INVALID_HANDLE    if the handle is not recognized as valid
            PDH_INVALID_ARGUMENT  if an argument is invalid or incorrect

--*/
{
    return PdhiGetCounterInfo (
            hCounter,
            bRetrieveExplainText,
            pdwBufferSize,
            (PPDH_COUNTER_INFO_W) lpBuffer,
            FALSE);
}

PDH_FUNCTION
PdhSetCounterScaleFactor (
    IN      HCOUNTER    hCounter,
    IN      LONG        lFactor
)
/*++

Routine Description:

    sets the counter multiplication scale factor used in computing formatted
        counter values. The legal range of values is -7 to +7 which equates
        to a factor of .0000007 to 10,000,000.

Arguments:

    IN      HCOUNTER    hCounter
        handle of the counter to update

    IN      LONG        lFactor
        integer value of the exponent of the factor (i.e. the multiplier is
        10 ** lFactor.)

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_ARGUMENT  if the scale value is out of range
            PDH_INVALID_HANDLE    if the handle is not recognized as valid

--*/
{
    PPDHI_COUNTER   pCounter;
    PDH_STATUS      retStatus = ERROR_SUCCESS;

    retStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);

    if (retStatus == ERROR_SUCCESS) {
        if (!IsValidCounter(hCounter)) {
            // not a valid counter
            retStatus = PDH_INVALID_HANDLE;
        } else if ((lFactor > PDH_MAX_SCALE) || (lFactor < PDH_MIN_SCALE)) {
            retStatus = PDH_INVALID_ARGUMENT;
        } else if (!CounterIsOkToUse(hCounter)) {
            retStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
        } else {
            pCounter = (PPDHI_COUNTER)hCounter;
            retStatus = WAIT_FOR_AND_LOCK_MUTEX(pCounter->pOwner->hMutex);
            if (retStatus == ERROR_SUCCESS) {
                pCounter->lScale = lFactor;
                RELEASE_MUTEX(pCounter->pOwner->hMutex);
                retStatus = ERROR_SUCCESS;
            }
        }

        RELEASE_MUTEX (hPdhDataMutex);
    }

    return retStatus;

}

#pragma optimize ("", off)
PDH_FUNCTION
PdhGetCounterTimeBase (
    IN  HCOUNTER    hCounter,
    IN  LONGLONG    *pTimeBase
)
/*++

Routine Description:

    retrieves the value of the timebase used in the computation
        of the formatted version of this counter.


Arguments:

    IN      HCOUNTER    hCounter
        handle of the counter to query

    IN      LONGLONG    pTimeBase
        pointer to the longlong value that will receive the value of the
        timebase used by the counter. The Timebase is the frequency of the
        timer used to measure the specified.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_ARGUMENT  if the scale value is out of range
            PDH_INVALID_HANDLE    if the handle is not recognized as valid

--*/
{

    PPDHI_COUNTER   pCounter;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;

    if (pTimeBase != NULL) {
        if (IsValidCounter(hCounter)) {
            if (!CounterIsOkToUse (hCounter)) {
                pdhStatus = PDH_CSTATUS_ITEM_NOT_VALIDATED;
            }
            else {
                pCounter = (PPDHI_COUNTER)hCounter;
                try {
                    LONGLONG volatile llTimeBase;
                    // test read/write access
                    llTimeBase = *pTimeBase; // TODO: Why need to read
                    * pTimeBase = 0;         // TODO: redundant
                    * pTimeBase = pCounter->TimeBase;
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    } else {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    return pdhStatus;
}
#pragma optimize ("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\perfdata.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perfdata.c

Abstract:

    <abstract>

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include <mbctype.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "perftype.h"
#include "perfdata.h"
#include "pdhmsg.h"
#include "strings.h"

// the following strings are for getting texts from perflib
#define  OLD_VERSION 0x010000
#define tohexdigit(x) ((CHAR) (((x) < 10) ? ((x) + L'0') : ((x) + L'a' - 10)))

DWORD
PdhiMakePerfPrimaryLangId(
    IN  LANGID  lID,
    OUT LPWSTR  szBuffer
)
{
    WCHAR    LangId;
    WCHAR    nDigit;

    LangId      = (WCHAR) PRIMARYLANGID(lID);
    nDigit      = (WCHAR) (LangId >> 8);
    szBuffer[0] = tohexdigit(nDigit);
    nDigit      = (WCHAR) (LangId & 0XF0) >> 4;
    szBuffer[1] = tohexdigit(nDigit);
    nDigit      = (WCHAR) (LangId & 0xF);
    szBuffer[2] = tohexdigit(nDigit);
    szBuffer[3] = L'\0';

    return ERROR_SUCCESS;
}

BOOL IsMatchingInstance (
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    DWORD                       dwCodePage,
    LPWSTR                      szInstanceNameToMatch,
    DWORD                       dwInstanceNameLength
)
// compares pInstanceName to the name in the instance
{
    DWORD   dwThisInstanceNameLength;
    LPWSTR  szThisInstanceName = NULL;
    WCHAR   szBufferForANSINames[MAX_PATH];

    ZeroMemory(szBufferForANSINames, sizeof(WCHAR) * MAX_PATH);
    if (dwInstanceNameLength == 0) {
        // get the length to compare
        dwInstanceNameLength = lstrlenW (szInstanceNameToMatch);
    }

    if (dwCodePage == 0) {
        // try to take a shortcut here if it's a unicode string
        // compare to the length of the shortest string
        // get the pointer to this string
        szThisInstanceName = GetInstanceName(pInstanceDef);

        // convert instance Name from bytes to chars
        dwThisInstanceNameLength = pInstanceDef->NameLength / sizeof(WCHAR);

        // see if this length includes the term. null. If so shorten it
        if (szThisInstanceName[dwThisInstanceNameLength-1] == 0) {
            dwThisInstanceNameLength--;
        }
    } else {
        // go the long way and read/translate/convert the string
        dwThisInstanceNameLength =GetInstanceNameStr (pInstanceDef,
                    szBufferForANSINames,
                    dwCodePage);
        if (dwThisInstanceNameLength > 0) {
            szThisInstanceName = &szBufferForANSINames[0];
        }
    }

    // if the lengths are not equal then the names can't be either
    if (dwInstanceNameLength != dwThisInstanceNameLength) {
        return FALSE;
    } else {
        if (szThisInstanceName != NULL) {
            if (lstrcmpiW(szInstanceNameToMatch, szThisInstanceName) == 0) {
                // this is a match
                return TRUE;
            } else {
                // this is not a match
                return FALSE;
            }
        } else {
            // this is not a match
            return FALSE;
        }
    }
}

LPWSTR
*BuildNameTable(
    LPWSTR        szComputerName, // computer to query names from
    LANGID        LangId,         // language ID
    PPERF_MACHINE pMachine        // update member fields
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status = ERROR_SUCCESS;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize    = 0;
    DWORD   dwHelpSize       = 0;
    DWORD   dw009CounterSize = 0;
    DWORD   dw009HelpSize    = 0;
    DWORD   dwThisCounter;
    DWORD   dwLastCounter;

    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    HKEY    hKeyRegistry = NULL;
    HKEY    hKeyValue    = NULL;
    HKEY    hKeyNames    = NULL;
    HKEY    hKey009Names = NULL;

    LPWSTR  lpValueNameString;
    LPWSTR  lp009ValueNameString;
    WCHAR   CounterNameBuffer[50];
    WCHAR   HelpNameBuffer[50];
    WCHAR   Counter009NameBuffer[50];
    WCHAR   Help009NameBuffer[50];
    WCHAR   lpszLangId[16];
    BOOL    bUse009Locale   = FALSE;
    BOOL    bUsePerfTextKey = TRUE;

    lpValueNameString          = NULL;   //initialize to NULL
    lp009ValueNameString       = NULL;
    pMachine->szPerfStrings    = NULL;
    pMachine->sz009PerfStrings = NULL;
    pMachine->typePerfStrings  = NULL;

    if (szComputerName == NULL) {
        // use local machine
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    } else {
        if ((lWin32Status = RegConnectRegistryW(szComputerName,
                    HKEY_LOCAL_MACHINE, & hKeyRegistry)) != ERROR_SUCCESS) {
            // unable to connect to registry
            goto BNT_BAILOUT;
        }
    }

    // check for null arguments and insert defaults if necessary

    if (   (LangId == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
        || (PRIMARYLANGID(LangId) == LANG_ENGLISH)) {
        bUse009Locale = TRUE;
    }
    PdhiMakePerfPrimaryLangId(LangId, lpszLangId);

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyExW (
        hKeyRegistry,
        cszNamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get last update time of registry key

    lWin32Status = RegQueryInfoKey (
        hKeyValue, NULL, NULL, NULL, NULL, NULL, NULL,
        NULL, NULL, NULL, NULL, & pMachine->LastStringUpdateTime);

    // get number of items

    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszLastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }


    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueExW (
        hKeyValue,
        cszVersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = G_ALLOC (
            lstrlenW(cszNamesKey) * sizeof (WCHAR) +
            lstrlenW(cszBackSlash) * sizeof (WCHAR) +
            lstrlenW(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));

        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpyW (lpValueNameString, cszNamesKey);
        lstrcatW (lpValueNameString, cszBackSlash);
        lstrcatW (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyExW (
                    hKeyRegistry,
                    lpValueNameString,
                    RESERVED,
                    KEY_READ,
                    &hKeyNames);
        if (! bUse009Locale && lWin32Status == ERROR_SUCCESS) {
            lp009ValueNameString = G_ALLOC(sizeof(UNICODE_NULL)
                    + lstrlenW(cszNamesKey) * sizeof (WCHAR)
                    + lstrlenW(cszBackSlash) * sizeof (WCHAR)
                    + lstrlenW(cszDefaultLangId) * sizeof (WCHAR));
            if (!lpValueNameString) goto BNT_BAILOUT;

            lstrcpyW (lpValueNameString, cszNamesKey);
            lstrcatW (lpValueNameString, cszBackSlash);
            lstrcatW (lpValueNameString, cszDefaultLangId);
            lWin32Status = RegOpenKeyExW(hKeyRegistry,
                                         lp009ValueNameString,
                                         RESERVED,
                                         KEY_READ,
                                         & hKey009Names);
        }
    } else {
        __try {
            if (bUse009Locale == FALSE) {
                if ((lWin32Status = RegConnectRegistryW(szComputerName,
                                    HKEY_PERFORMANCE_NLSTEXT,
                                    & hKeyNames)) == ERROR_SUCCESS) {
                    if ((lWin32Status = RegConnectRegistryW(szComputerName,
                                        HKEY_PERFORMANCE_TEXT,
                                        & hKey009Names)) != ERROR_SUCCESS) {
                        bUsePerfTextKey = FALSE;
                        RegCloseKey(hKeyNames);
                    }
                }
                else {
                    bUsePerfTextKey = FALSE;
                }
            }
            else {
                if ((lWin32Status = RegConnectRegistryW(szComputerName,
                                        HKEY_PERFORMANCE_TEXT,
                                        & hKeyNames)) != ERROR_SUCCESS) {
                    bUsePerfTextKey = FALSE;
                }
                else {
                    hKey009Names = hKeyNames;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            bUsePerfTextKey = FALSE;
        }
    }

    if (! bUsePerfTextKey) {
        lstrcpyW(CounterNameBuffer,    cszCounterName);
        lstrcatW(CounterNameBuffer,    lpszLangId);
        lstrcpyW(HelpNameBuffer,       cszHelpName);
        lstrcatW(HelpNameBuffer,       lpszLangId);
        lstrcpyW(Counter009NameBuffer, cszCounterName);
        lstrcatW(Counter009NameBuffer, cszDefaultLangId);
        lstrcpyW(Help009NameBuffer,    cszHelpName);
        lstrcatW(Help009NameBuffer,    cszDefaultLangId);

        // cannot open HKEY_PERFORMANCE_TEXT, try the old way
        //
        if (szComputerName == NULL) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        }
        else if ((lWin32Status = RegConnectRegistryW(szComputerName,
                                 HKEY_PERFORMANCE_DATA,
                                 & hKeyNames)) != ERROR_SUCCESS) {
            goto BNT_BAILOUT;
        }
        hKey009Names = hKeyNames;        
    }
    else {
        lstrcpyW(CounterNameBuffer,    cszCounters);
        lstrcpyW(HelpNameBuffer,       cszHelp);
        lstrcpyW(Counter009NameBuffer, cszCounters);
        lstrcpyW(Help009NameBuffer,    cszHelp);
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(
            hKeyNames,
            CounterNameBuffer,
            RESERVED,
            & dwValueType,
            NULL,
            & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
    dwCounterSize = dwBufferSize;

    if (! bUse009Locale) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueExW(hKey009Names,
                                        Counter009NameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
        dw009CounterSize = dwBufferSize;
    }
    else {
        dw009CounterSize = dwCounterSize;
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueExW(
            hKeyNames,
            HelpNameBuffer,
            RESERVED,
            & dwValueType,
            NULL,
            & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
    dwHelpSize = dwBufferSize;

    if (! bUse009Locale) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueExW(hKey009Names,
                                        Help009NameBuffer,
                                        RESERVED,
                                        & dwValueType,
                                        NULL,
                                        & dwBufferSize);
        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
        dw009HelpSize = dwBufferSize;
    }
    else {
        dw009HelpSize = dwHelpSize;
    }

    pMachine->szPerfStrings = G_ALLOC(dwArraySize + dwCounterSize + dwHelpSize);
    if (! pMachine->szPerfStrings) goto BNT_BAILOUT;

    if (bUse009Locale) {
        pMachine->sz009PerfStrings = pMachine->szPerfStrings;
    }
    else {
        pMachine->sz009PerfStrings =
                    G_ALLOC(dwArraySize + dw009CounterSize + dw009HelpSize);
        if (! pMachine->sz009PerfStrings) goto BNT_BAILOUT;
    }

    pMachine->typePerfStrings = G_ALLOC(dwLastId + 1);
    if (! pMachine->typePerfStrings) goto BNT_BAILOUT;

    // initialize pointers into buffer

    lpCounterId = pMachine->szPerfStrings;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueExW (
            hKeyNames,
            CounterNameBuffer,
            RESERVED,
            & dwValueType,
            (LPVOID)lpCounterNames,
            & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueExW (
            hKeyNames,
            HelpNameBuffer,
            RESERVED,
            & dwValueType,
            (LPVOID)lpHelpText,
            & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // load counter array items

    dwLastCounter = 0;
    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // check for registry corruption. This shouldn't occur under
        // normal conditions
        assert (dwThisCounter > dwLastCounter);

        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);

        // and load array element;
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpCounterId[dwThisCounter] = lpThisName;
            pMachine->typePerfStrings[dwThisCounter] = STR_COUNTER;
            dwLastCounter = dwThisCounter;
        }
    }

    dwLastCounter = 0;
    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlenW(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // check for registry corruption. This shouldn't occur under
        // normal conditions
        assert (dwThisCounter > dwLastCounter);

        // point to corresponding counter name

        lpThisName += (lstrlenW(lpThisName)+1);

        // and load array element;
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpCounterId[dwThisCounter] = lpThisName;
            pMachine->typePerfStrings[dwThisCounter] = STR_HELP;
            dwLastCounter = dwThisCounter;
        }
    }

    lpCounterId    = pMachine->sz009PerfStrings;
    lpCounterNames = (LPWSTR) ((LPBYTE) lpCounterId + dwArraySize);
    lpHelpText     = (LPWSTR) ((LPBYTE) lpCounterNames + dw009CounterSize);

    // read counters into memory

    dwBufferSize = dw009CounterSize;
    lWin32Status = RegQueryValueExW(hKey009Names,
                                    Counter009NameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpCounterNames,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = dw009HelpSize;
    lWin32Status = RegQueryValueExW(hKey009Names,
                                    Help009NameBuffer,
                                    RESERVED,
                                    & dwValueType,
                                    (LPVOID) lpHelpText,
                                    & dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    for (  lpThisName = lpCounterNames;
         * lpThisName;
           lpThisName += (lstrlenW(lpThisName) + 1)) {
        dwThisCounter = wcstoul(lpThisName, NULL, 10);
        lpThisName   += (lstrlenW(lpThisName) + 1);
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    for (  lpThisName = lpHelpText;
         * lpThisName;
           lpThisName += (lstrlenW(lpThisName) + 1) ) {
        dwThisCounter = wcstoul (lpThisName, NULL, 10);
        lpThisName   += (lstrlenW(lpThisName) + 1);
        if ((dwThisCounter > 0) && (dwThisCounter <= dwLastId)) {
            lpCounterId[dwThisCounter] = lpThisName;
        }
    }

    pMachine->dwLastPerfString = dwLastId;

    if (lpValueNameString)    G_FREE ((LPVOID) lpValueNameString);
    if (lp009ValueNameString) G_FREE ((LPVOID) lp009ValueNameString);

    RegCloseKey(hKeyValue);

    if (hKey009Names && hKey009Names != hKeyNames) RegCloseKey(hKey009Names);
    RegCloseKey(hKeyNames);
    if (hKeyRegistry && hKeyRegistry != HKEY_LOCAL_MACHINE)
        RegCloseKey(hKeyRegistry);
    return pMachine->szPerfStrings;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        G_FREE ((LPVOID)lpValueNameString);
    }

    if (   pMachine->sz009PerfStrings
        && pMachine->sz009PerfStrings != pMachine->szPerfStrings) {
        G_FREE(pMachine->sz009PerfStrings);
    }
    if (pMachine->szPerfStrings) {
        G_FREE(pMachine->szPerfStrings);
    }
    if (pMachine->typePerfStrings) {
        G_FREE(pMachine->typePerfStrings);
    }

    if (hKeyValue)    RegCloseKey(hKeyValue);
    if (hKey009Names && hKey009Names != hKeyNames) RegCloseKey(hKey009Names);
    if (hKeyNames)    RegCloseKey(hKeyNames);
    if (hKeyRegistry) RegCloseKey(hKeyRegistry);

    return NULL;
}

#pragma warning ( disable : 4127 )
PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
)
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {

        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        assert (pObjectDef != NULL);

        NumTypeDef = 0;
        while (1) {
            if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {
                pReturnObject = pObjectDef;
                break;
            } else {
                NumTypeDef++;
                if (NumTypeDef < pDataBlock->NumObjectTypes) {
                    pObjectDef = NextObject(pObjectDef);
                    //make sure next object is legit
                    if (pObjectDef != NULL) {
                        if (pObjectDef->TotalByteLength > 0) {
                            if (pObjectDef >= pEndOfBuffer) {
                                // looks like we ran off the end of the data buffer
                                assert (pObjectDef < pEndOfBuffer);
                                break;
                            }
                        } else {
                            // 0-length object buffer returned
                            assert (pObjectDef->TotalByteLength > 0);
                            break;
                        }
                    } else {
                        // and continue
                        assert (pObjectDef != NULL);
                        break;
                    }
                } else {
                    // no more data objects in this data block
                    break;
                }
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}

PERF_OBJECT_TYPE *
GetObjectDefByName (
    IN      PERF_DATA_BLOCK *pDataBlock,
    IN      DWORD           dwLastNameIndex,
    IN      LPCWSTR         *NameArray,
    IN      LPCWSTR         szObjectName
)
{
    DWORD NumTypeDef;
    PERF_OBJECT_TYPE *pReturnObject = NULL;
    PERF_OBJECT_TYPE *pObjectDef = NULL;
    PERF_OBJECT_TYPE *pEndOfBuffer = NULL;

    __try {

        pObjectDef = FirstObject(pDataBlock);
        pEndOfBuffer = (PPERF_OBJECT_TYPE)
                        ((DWORD_PTR)pDataBlock +
                            pDataBlock->TotalByteLength);

        assert (pObjectDef != NULL);

        NumTypeDef = 0;
        while (1) {
            if ( pObjectDef->ObjectNameTitleIndex < dwLastNameIndex ) {
                // look up name of object & compare
                if (lstrcmpiW(NameArray[pObjectDef->ObjectNameTitleIndex],
                        szObjectName) == 0) {
                    pReturnObject = pObjectDef;
                    break;
                }
            }
            NumTypeDef++;
            if (NumTypeDef < pDataBlock->NumObjectTypes) {
                pObjectDef = NextObject(pObjectDef); // get next
                //make sure next object is legit
                if (pObjectDef != NULL) {
                    if (pObjectDef->TotalByteLength > 0) {
                        if (pObjectDef >= pEndOfBuffer) {
                            // looks like we ran off the end of the data buffer
                            assert (pObjectDef < pEndOfBuffer);
                            break;
                        }
                    } else {
                        // 0-length object buffer returned
                        assert (pObjectDef->TotalByteLength > 0);
                        break;
                    }
                } else {
                    // null pointer
                    assert (pObjectDef != NULL);
                    break;
                }
            } else {
                // end of data block
                break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pReturnObject = NULL;
    }
    return pReturnObject;
}
#pragma warning ( default : 4127 )

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
)
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    LONG NumInstance;

    if (!pObjectDef) {
        return 0;
    }

    pInstanceDef = FirstInstance(pObjectDef);

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ )  {
        if ( InstanceNumber == NumInstance ) {
            return pInstanceDef;
        }
        pInstanceDef = NextInstance(pInstanceDef);
    }

    return NULL;
}

PERF_INSTANCE_DEFINITION *
GetInstanceByUniqueId(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceUniqueId
)
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    LONG NumInstance;

    if (!pObjectDef) {
        return 0;
    }

    pInstanceDef = FirstInstance(pObjectDef);

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ )  {
        if ( InstanceUniqueId == pInstanceDef->UniqueID ) {
            return pInstanceDef;
        }
        pInstanceDef = NextInstance(pInstanceDef);
    }

    return NULL;
}

DWORD
GetAnsiInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage)
{
    LPSTR   szSource;
    DWORD   dwLength;

    szSource = (LPSTR)GetInstanceName(pInstance);

    // the locale should be set here
    DBG_UNREFERENCED_PARAMETER(dwCodePage);

    // pInstance->NameLength == the number of bytes (chars) in the string
    dwLength = (DWORD) MultiByteToWideChar(_getmbcp(),
                                           0,
                                           szSource,
                                           lstrlenA(szSource),
                                           (LPWSTR) lpszInstance,
                                           pInstance->NameLength);
    lpszInstance[dwLength] = 0; // null terminate string buffer

    return dwLength;
}

DWORD
GetUnicodeInstanceName (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance)
{
   LPWSTR   wszSource;
   DWORD    dwLength;

   wszSource = GetInstanceName(pInstance) ;

   // pInstance->NameLength == length of string in BYTES so adjust to
   // number of wide characters here
   dwLength = pInstance->NameLength / sizeof(WCHAR);

   wcsncpy (lpszInstance,
        (LPWSTR)wszSource,
        dwLength);

   // add null termination if string length does not include  the null
   if ((dwLength > 0) && (lpszInstance[dwLength-1] != 0)) {    // i.e. it's the last character of the string
           lpszInstance[dwLength] = 0;    // then add a terminating null char to the string
   } else {
           // assume that the length value includes the terminating NULL
        // so adjust value to indicate chars only
           dwLength--;
   }

   return (dwLength); // just incase there's null's in the string
}

DWORD
GetInstanceNameStr (PPERF_INSTANCE_DEFINITION pInstance,
                    LPWSTR lpszInstance,
                    DWORD dwCodePage)
{
    DWORD  dwCharSize;
    DWORD  dwLength = 0;

    if (pInstance != NULL) {
        if (lpszInstance != NULL) {
            if (dwCodePage > 0) {
                    dwCharSize = sizeof(CHAR);
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
            } else { // it's a UNICODE name
                    dwCharSize = sizeof(WCHAR);
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
            }
            // sanity check here...
            // the returned string length (in characters) plus the terminating NULL
            // should be the same as the specified length in bytes divided by the
            // character size. If not then the codepage and instance data type
            // don't line up so test that here

            if ((dwLength + 1) != (pInstance->NameLength / dwCharSize)) {
                // something isn't quite right so try the "other" type of string type
                if (dwCharSize == sizeof(CHAR)) {
                    // then we tried to read it as an ASCII string and that didn't work
                    // so try it as a UNICODE (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetUnicodeInstanceName (pInstance, lpszInstance);
                } else if (dwCharSize == sizeof(WCHAR)) {
                    // then we tried to read it as a UNICODE string and that didn't work
                    // so try it as an ASCII string (if that doesn't work give up and return
                    // it any way.
                    dwLength = GetAnsiInstanceName (pInstance, lpszInstance, dwCodePage);
                }
            }
        } // else return buffer is null
    } else {
        // no instance def object is specified so return an empty string
        *lpszInstance = 0;
    }

    return dwLength;
}

PERF_INSTANCE_DEFINITION *
GetInstanceByNameUsingParentTitleIndex(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD  dwIndex
)
{
   BOOL fHaveParent;
   PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION  *pParentInst,
                 *pInstanceDef;

   LONG   NumInstance;
   DWORD    dwLocalIndex;

   DWORD  dwInstanceNameLength;

   fHaveParent = FALSE;
   pInstanceDef = FirstInstance(pObjectDef);

   if (pInstanceDef == NULL) return NULL;

   dwLocalIndex = dwIndex;

   dwInstanceNameLength = lstrlenW(pInstanceName);

   for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ )
      {
        if (IsMatchingInstance (pInstanceDef,
                                pObjectDef->CodePage,
                                pInstanceName,
                                dwInstanceNameLength)) {
         // Instance name matches

         if ( pParentName == NULL )
            {

            // No parent, we're done if this is the right "copy"

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            }
         else
            {

            // Must match parent as well

            pParentObj = GetObjectDefByTitleIndex(
               pDataBlock,
               pInstanceDef->ParentObjectTitleIndex);

            if (!pParentObj)
               {
               // can't locate the parent, forget it
               break ;
               }

            // Object type of parent found; now find parent
            // instance

            pParentInst = GetInstance(pParentObj,
               pInstanceDef->ParentObjectInstance);

            if (!pParentInst)
               {
               // can't locate the parent instance, forget it
               break ;
               }

            if (IsMatchingInstance (pParentInst,
                                pParentObj->CodePage,
                                pParentName, 0)) {
                // Parent Instance Name matches that passed in
                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }
               }
            }
         }
      pInstanceDef = NextInstance(pInstanceDef);
      if (pInstanceDef == NULL) return NULL;
      }
   return 0;
}

PERF_INSTANCE_DEFINITION *
GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE *pObjectDef,
    LPWSTR pInstanceName,
    LPWSTR pParentName,
    DWORD   dwIndex
)
{
    BOOL fHaveParent;

    PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION *pParentInst,
                 *pInstanceDef;

    LONG  NumInstance;
    DWORD  dwLocalIndex;
    DWORD  dwInstanceNameLength;

    fHaveParent = FALSE;
    pInstanceDef = FirstInstance(pObjectDef);
    if (pInstanceDef == NULL) return NULL;

    dwLocalIndex = dwIndex;
    assert (pInstanceDef != NULL);

    dwInstanceNameLength = lstrlenW(pInstanceName);

    for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ ) {

        if (IsMatchingInstance (pInstanceDef,
                                pObjectDef->CodePage,
                                pInstanceName,
                                dwInstanceNameLength)) {

            // Instance name matches

            if (( !pInstanceDef->ParentObjectTitleIndex ) || (pParentName == NULL)){

                // No parent, we're done

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            } else {

                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                                pDataBlock,
                                pInstanceDef->ParentObjectTitleIndex);

                // if parent object is not found, 
                // then exit and return NULL
                if (pParentObj == NULL) return NULL;

                // Object type of parent found; now find parent
                // instance

                pParentInst = GetInstance(pParentObj,
                        pInstanceDef->ParentObjectInstance);

                if (pParentInst != NULL) {

                    if (IsMatchingInstance (pParentInst,
                                    pParentObj->CodePage,
                                    pParentName, 0)) {

                        // Parent Instance Name matches that passed in

                        if (dwLocalIndex == 0) {
                            return pInstanceDef;
                        } else {
                            --dwLocalIndex;
                        }
                    }
                } else {
                    // continue
                }
            }
        }
        pInstanceDef = NextInstance(pInstanceDef);
        if (pInstanceDef == NULL) return NULL;
    }
    return 0;
}  // GetInstanceByName

PERF_COUNTER_DEFINITION *
GetCounterDefByName (
    IN  PERF_OBJECT_TYPE    *pObject,
    IN  DWORD           dwLastNameIndex,
    IN  LPWSTR          *NameArray,
    IN  LPWSTR          szCounterName
)
{
    DWORD NumTypeDef;
    PERF_COUNTER_DEFINITION *pThisCounter;

    pThisCounter = FirstCounter(pObject);
    // no counter found so bail out
    if (pThisCounter == NULL) return NULL;

    for ( NumTypeDef = 0;
        NumTypeDef < pObject->NumCounters;
        NumTypeDef++ ) {

        if ((pThisCounter->CounterNameTitleIndex > 0) &&
            (pThisCounter->CounterNameTitleIndex < dwLastNameIndex )) {
            // look up name of counter & compare
            if (lstrcmpiW(NameArray[pThisCounter->CounterNameTitleIndex],
                    szCounterName) == 0) {
                return pThisCounter;
            }
        }
        pThisCounter = NextCounter(pThisCounter); // get next
        if (pThisCounter == NULL) return NULL;
    }
    return NULL;
}

PERF_COUNTER_DEFINITION *
GetCounterDefByTitleIndex(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  BOOL bBaseCounterDef,
    IN  DWORD CounterTitleIndex
)
{
    DWORD NumCounters;
    PERF_COUNTER_DEFINITION * pCounterDef;

    pCounterDef = FirstCounter(pObjectDef);
    if (pCounterDef == NULL) return NULL;

    for ( NumCounters = 0;
      NumCounters < pObjectDef->NumCounters;
      NumCounters++ ) {

        if ( pCounterDef->CounterNameTitleIndex == CounterTitleIndex ) {
            if (bBaseCounterDef) {
                // get next definition block
                if (++NumCounters < pObjectDef->NumCounters) {
                    // then it should be in there
                    pCounterDef = NextCounter(pCounterDef);
                    if (pCounterDef) {
                        assert (pCounterDef->CounterType & PERF_COUNTER_BASE);
                        // make sure this is really a base counter
                        if (!(pCounterDef->CounterType & PERF_COUNTER_BASE)) {
                            // it's not and it should be so return NULL
                            pCounterDef = NULL;
                        }
                    }
                }
            } else {
                // found so return it as is
            }
            return pCounterDef;
        }
        pCounterDef = NextCounter(pCounterDef);
        if (pCounterDef == NULL) return NULL;
    }
    return NULL;
}

#pragma warning ( disable : 4127 )
LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *ppPerfData,
    IN LPWSTR   szObjectList,
    IN BOOL     bCollectCostlyData
)
{  // GetSystemPerfData
    LONG     lError = ERROR_SUCCESS;
    DWORD    Size;
    DWORD    Type;
    PPERF_DATA_BLOCK    pCostlyPerfData;
    DWORD    CostlySize;
    LPDWORD  pdwSrc, pdwDest, pdwLast;

    if (*ppPerfData == NULL) {
        *ppPerfData = G_ALLOC (INITIAL_SIZE);
        if (*ppPerfData == NULL) return PDH_MEMORY_ALLOCATION_FAILURE;
    }

    __try {
        while (TRUE) {
            Size = (DWORD)HeapSize (hPdhHeap, 0, *ppPerfData);
            lError = RegQueryValueExW (
                hKeySystem,
                szObjectList,
                RESERVED,
                &Type,
                (LPBYTE)*ppPerfData,
                &Size);

            if ((!lError) &&
                (Size > 0) &&
                ((*ppPerfData)->Signature[0] == (WCHAR)'P') &&
                ((*ppPerfData)->Signature[1] == (WCHAR)'E') &&
                ((*ppPerfData)->Signature[2] == (WCHAR)'R') &&
                ((*ppPerfData)->Signature[3] == (WCHAR)'F')) {

                if (bCollectCostlyData) {
                    // collect the costly counters now
                    // the size available is that not used by the above call

                    CostlySize = (DWORD)HeapSize (hPdhHeap, 0, *ppPerfData) - Size;
                    pCostlyPerfData =
                        (PPERF_DATA_BLOCK)((LPBYTE)(*ppPerfData) + Size);
                    lError = RegQueryValueExW (
                        hKeySystem,
                        cszCostly,
                        RESERVED,
                        &Type,
                        (LPBYTE)pCostlyPerfData,
                        &CostlySize);

                    if ((!lError) &&
                        (CostlySize > 0) &&
                        (pCostlyPerfData->Signature[0] == (WCHAR)'P') &&
                        (pCostlyPerfData->Signature[1] == (WCHAR)'E') &&
                        (pCostlyPerfData->Signature[2] == (WCHAR)'R') &&
                        (pCostlyPerfData->Signature[3] == (WCHAR)'F')) {

                        // update the header block
                        (*ppPerfData)->TotalByteLength +=
                            pCostlyPerfData->TotalByteLength -
                            pCostlyPerfData->HeaderLength;

                        (*ppPerfData)->NumObjectTypes +=
                            pCostlyPerfData->NumObjectTypes;

                        // move the costly data to the end of the global data

                        pdwSrc = (LPDWORD)((LPBYTE)pCostlyPerfData +
                            pCostlyPerfData->HeaderLength);
                        pdwDest = (LPDWORD)pCostlyPerfData ;
                        pdwLast = (LPDWORD)((LPBYTE)pCostlyPerfData +
                            pCostlyPerfData->TotalByteLength -
                            pCostlyPerfData->HeaderLength);

                        while (pdwSrc < pdwLast) {*pdwDest++ = *pdwSrc++;}

                        lError = ERROR_SUCCESS;
                        break;
                    }
                } else {
                    lError = ERROR_SUCCESS;
                    break;
                }
            }

            if (lError == ERROR_MORE_DATA) {
                Size = (DWORD)HeapSize (hPdhHeap, 0, *ppPerfData);
                G_FREE (*ppPerfData);
                *ppPerfData = NULL;
                *ppPerfData = G_ALLOC ((Size + EXTEND_SIZE));
                if (*ppPerfData == NULL) {
                    lError = PDH_MEMORY_ALLOCATION_FAILURE;
                    break;
                }
            } else {
                break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        lError = GetExceptionCode();
    }
    return lError;
}  // GetSystemPerfData
#pragma warning ( default : 4127 )

DWORD
GetFullInstanceNameStr (
    PERF_DATA_BLOCK             *pPerfData,
    PERF_OBJECT_TYPE            *pObjectDef,
    PERF_INSTANCE_DEFINITION    *pInstanceDef,
    LPWSTR                      szInstanceName
)
{

    WCHAR   szInstanceNameString[1024];
    WCHAR   szParentNameString[1024];

    // compile instance name.
    // the instance name can either be just
    // the instance name itself or it can be
    // the concatenation of the parent instance,
    // a delimiting char (backslash) followed by
    // the instance name

    DWORD                      dwLength = 0;
    PERF_OBJECT_TYPE         * pParentObjectDef;
    PERF_INSTANCE_DEFINITION * pParentInstanceDef;

    ZeroMemory(szInstanceNameString, sizeof(WCHAR) * 1024);
    ZeroMemory(szParentNameString,   sizeof(WCHAR) * 1024);

    if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
        dwLength = GetInstanceNameStr (pInstanceDef,
            szInstanceNameString,
            pObjectDef->CodePage);
    } else {
        // make a string out of the unique ID
        _ltow (pInstanceDef->UniqueID, szInstanceNameString, 10);
        dwLength = lstrlenW (szInstanceNameString);
    }

    if (dwLength > 0) {
        if (pInstanceDef->ParentObjectTitleIndex > 0) {
            // then add in parent instance name
            pParentObjectDef = GetObjectDefByTitleIndex (
                            pPerfData,
                            pInstanceDef->ParentObjectTitleIndex);

            if (pParentObjectDef != NULL) {
                pParentInstanceDef = GetInstance (
                        pParentObjectDef,
                        pInstanceDef->ParentObjectInstance);
            assert ((ULONG_PTR)pParentObjectDef != (DWORD)0xFFFFFFFF);
                if (pParentInstanceDef != NULL) {
                    if (pParentInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
                        dwLength += GetInstanceNameStr (pParentInstanceDef,
                                        szParentNameString,
                                        pParentObjectDef->CodePage);
                    } else {
                        // make a string out of the unique ID
                        _ltow (pParentInstanceDef->UniqueID, szParentNameString, 10);
                        dwLength += lstrlenW (szParentNameString);
                    }

                    lstrcatW (szParentNameString, cszSlash);
                    dwLength += 1;
                    lstrcatW (szParentNameString, szInstanceNameString);
                    lstrcpyW (szInstanceName, szParentNameString);
                } else {
                    lstrcpyW (szInstanceName, szInstanceNameString);
                }
            } else {
                lstrcpyW (szInstanceName, szInstanceNameString);
            }
        } else {
            lstrcpyW (szInstanceName, szInstanceNameString);
        }
    }

    return dwLength;

}

#if DBG

#define DEBUG_BUFFER_LENGTH 1024
UCHAR   PdhDebugBuffer[DEBUG_BUFFER_LENGTH];
// debug level:
//  5 = memory allocs  (if _VALIDATE_PDH_MEM_ALLOCS defined) and all 4's
//  4 = function entry and exits (w/ status codes) and all 3's
//  3 = Not impl
//  2 = Not impl
//  1 = Not impl
//  0 = No messages

ULONG   pdhDebugLevel = 0;

VOID
__cdecl
PdhDebugPrint(
    ULONG DebugPrintLevel,
    char * DebugMessage,
    ...
    )
{
    va_list ap;

    if ((DebugPrintLevel <= (pdhDebugLevel & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & pdhDebugLevel)) {
        DbgPrint("%d:PDH!", GetCurrentThreadId());
    }
    else return;

    va_start(ap, DebugMessage);
    _vsnprintf((PCHAR)PdhDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);
    DbgPrint((PCHAR)PdhDebugBuffer);
    va_end(ap);

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\perfname.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perfname.c

Abstract:

    <abstract>

--*/

#include <windows.h>
#include <winperf.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include <mbctype.h>
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

LPCWSTR
PdhiLookupPerfNameByIndex (
    PPERF_MACHINE  pMachine,
    DWORD   dwNameIndex
)
{
    LPWSTR  szReturn = NULL;
    LONG    lStatus = ERROR_SUCCESS;

    SetLastError (lStatus);

    if (pMachine != NULL) {
        if (pMachine->dwStatus == ERROR_SUCCESS) {
            if (dwNameIndex <= pMachine->dwLastPerfString) {
                szReturn = pMachine->szPerfStrings[dwNameIndex];
            } else {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        } else {
            lStatus = pMachine->dwStatus ;
        }
    } else {
        lStatus = PDH_CSTATUS_NO_MACHINE;
    }

    SetLastError (lStatus);
    return (LPCWSTR)szReturn;
}

DWORD
PdhiLookupPerfIndexByName (
    PPERF_MACHINE  pMachine,
    LPCWSTR szNameBuffer
)
{
    DWORD   dwCurrentIndex = 2;
    BOOL    bDone  = FALSE;
    LPWSTR  szThisPerfString;

    SetLastError (ERROR_SUCCESS);

    while (!bDone) {
        // test even indices first
        for (;
            dwCurrentIndex <= pMachine->dwLastPerfString;
            dwCurrentIndex += 2) {
            szThisPerfString = pMachine->szPerfStrings[dwCurrentIndex];
            if (szThisPerfString != NULL) {
                if (lstrcmpiW(szNameBuffer, szThisPerfString) == 0) {
                    // match found
                    bDone = TRUE;
                    break;
                }
            }
        }
        if (!bDone) {
            // if doing an odd # & not done then exit because we've
            // looked at them all and not found anything
            if (dwCurrentIndex & 0x00000001) break;
            dwCurrentIndex = 3;
        } // else just go to the loop exit
    }

    if (!bDone) {
        SetLastError (PDH_STRING_NOT_FOUND);
        dwCurrentIndex = 0;
    }

    return dwCurrentIndex;
}

PDH_FUNCTION
PdhLookupPerfNameByIndexW (
    LPCWSTR szMachineName,
    DWORD   dwNameIndex,
    LPWSTR  szNameBuffer,
    LPDWORD pcchNameBufferSize
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    LPWSTR          szLocalName;
    DWORD           dwNameLen;
    DWORD           dwLocalNameSize = 0;

    if ((szNameBuffer == NULL) ||
        (pcchNameBufferSize == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = &szStaticLocalMachineName[0];
            } else {
                if (*szMachineName == 0) {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                } else {
                    szLocalMachineName = (LPWSTR)szMachineName;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalNameSize = *pcchNameBufferSize;
                if (dwLocalNameSize >= sizeof(DWORD)) {
                    //test write access to the beginning and the end of the buffer
                    CLEAR_FIRST_FOUR_BYTES (szNameBuffer);
                    szNameBuffer[dwLocalNameSize -1] = 0;
                } else if (dwLocalNameSize >= sizeof (WORD)) {
                    // then just test the first char
                    *szNameBuffer = 0;
                } else {
                    pdhStatus = PDH_INSUFFICIENT_BUFFER;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine (szLocalMachineName, 0);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                szLocalName = (LPWSTR)PdhiLookupPerfNameByIndex (
                    pMachine, dwNameIndex);
                if (szLocalName != NULL) {
                    dwNameLen = lstrlenW(szLocalName) + 1;
                    if (dwNameLen < dwLocalNameSize) {
                        lstrcpyW (szNameBuffer, szLocalName);
                    } else {
                        *szNameBuffer = 0;
                        pdhStatus = PDH_INSUFFICIENT_BUFFER;
                    }
                    dwLocalNameSize = dwNameLen;
                } else {
                    *szNameBuffer = 0;
                    dwLocalNameSize = 0;
                    pdhStatus = GetLastError();
                }
            } else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            *szNameBuffer = 0;
            dwLocalNameSize = 0;
            pdhStatus = GetLastError();
        }

        __try {
            *pcchNameBufferSize = dwLocalNameSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfNameByIndexA (
    LPCSTR  szMachineName,
    DWORD   dwNameIndex,
    LPSTR   szNameBuffer,
    LPDWORD pcchNameBufferSize
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    LPWSTR          szLocalName;
    DWORD           dwNameLen;
    DWORD           dwLocalNameSize = 0;

    if ((szNameBuffer == NULL) ||
        (pcchNameBufferSize == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = &szStaticLocalMachineName[0];
            } else {
                if (*szMachineName == 0) {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                } else {
                    // then allocate a new buffer and convert the LPSTR to a LPWSTR
                    dwNameLen = lstrlenA(szMachineName) + 1;
                    szLocalMachineName = G_ALLOC (dwNameLen * sizeof(WCHAR));
                    if (szLocalMachineName != NULL) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szMachineName,
                                            lstrlenA(szMachineName),
                                            (LPWSTR) szLocalMachineName,
                                            dwNameLen);
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                dwLocalNameSize = *pcchNameBufferSize;
                if (dwLocalNameSize >= sizeof(DWORD)) {
                    //test write access to the beginning and the end of the buffer
                    CLEAR_FIRST_FOUR_BYTES (szNameBuffer);
                    szNameBuffer[dwLocalNameSize -1] = 0;
                } else if (dwLocalNameSize >= sizeof (CHAR)) {
                    // then just test the first char
                    *szNameBuffer = 0;
                } else {
                    pdhStatus = PDH_INSUFFICIENT_BUFFER;
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine (szLocalMachineName, 0);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                szLocalName = (LPWSTR)PdhiLookupPerfNameByIndex (
                    pMachine, dwNameIndex);

                if (szLocalName != NULL) {
                    pdhStatus = PdhiConvertUnicodeToAnsi(_getmbcp(),
                                szLocalName, szNameBuffer, & dwLocalNameSize);
                } else {
                    *szNameBuffer = 0;
                    dwLocalNameSize = 0;
                    pdhStatus = GetLastError();
                }
            } else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            *szNameBuffer = 0;
            dwLocalNameSize = 0;
            pdhStatus = GetLastError();
        }

        __try {
            *pcchNameBufferSize = dwLocalNameSize;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (szLocalMachineName != NULL) {
        if (szLocalMachineName != &szStaticLocalMachineName[0]) {
            G_FREE (szLocalMachineName);
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfIndexByNameW (
    LPCWSTR szMachineName,
    LPCWSTR szNameBuffer,
    LPDWORD pdwIndex
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName = NULL;
    DWORD           dwIndexFound;

    if ((szNameBuffer == NULL) ||
        (pdwIndex == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {

        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = &szStaticLocalMachineName[0];
            } else {
                if (*szMachineName == 0) {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                } else {
                    szLocalMachineName = (LPWSTR)szMachineName;
                }
            }

            // test read access to name
            if (*szNameBuffer == 0)  {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            if (pdhStatus == ERROR_SUCCESS)  {
                // test write access
                *pdwIndex = 0;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine (szLocalMachineName, 0);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                dwIndexFound = PdhiLookupPerfIndexByName (
                    pMachine, szNameBuffer);
                if (dwIndexFound == 0) {
                    // match not found
                    pdhStatus = GetLastError();
                } else {
                    __try {
                       // write value found
                        *pdwIndex = dwIndexFound;
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                }
            } else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            pdhStatus = GetLastError();
        }
    }

    return pdhStatus;
}

PDH_FUNCTION
PdhLookupPerfIndexByNameA (
    LPCSTR  szMachineName,
    LPCSTR  szNameBuffer,
    LPDWORD pdwIndex
)
{
    PPERF_MACHINE   pMachine;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          szLocalMachineName =  NULL;
    DWORD           dwIndexFound;
    LPWSTR          szWideName;
    DWORD           dwNameLen;

    if ((szNameBuffer == NULL) ||
        (pdwIndex == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {

        // test access to all the parameteres passed in before continuing
        __try {
            if (szMachineName == NULL) {
                // use local machine name
                szLocalMachineName = &szStaticLocalMachineName[0];
            } else {
                if (*szMachineName == 0) {
                    // NULL machine name
                    pdhStatus = PDH_INVALID_ARGUMENT;
                } else {
                    // then allocate a new buffer and convert the LPSTR to a LPWSTR
                    dwNameLen = lstrlenA(szMachineName) + 1;
                    szLocalMachineName = G_ALLOC (dwNameLen * sizeof(WCHAR));
                    if (szLocalMachineName != NULL) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szMachineName,
                                            lstrlenA(szMachineName),
                                            (LPWSTR) szLocalMachineName,
                                            dwNameLen);
                    } else {
                        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                    }
                }
            }

            // test read access to name
            if (pdhStatus == ERROR_SUCCESS) {
                if (*szNameBuffer == 0)  {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // test write access
                *pdwIndex = 0;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pMachine = GetMachine (szLocalMachineName, 0);
        if (pMachine != NULL) {
            if (pMachine->dwStatus == ERROR_SUCCESS) {
                // convert name string to wide characters for comparison
                dwNameLen = lstrlenA (szNameBuffer) + 1;
                szWideName = G_ALLOC (dwNameLen * sizeof(WCHAR));
                if (szWideName != NULL) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szNameBuffer,
                                            lstrlenA(szNameBuffer),
                                            (LPWSTR) szWideName,
                                            dwNameLen);
                    dwIndexFound = PdhiLookupPerfIndexByName (
                        pMachine, szWideName);
                    if (dwIndexFound == 0) {
                        // match not found
                        pdhStatus = GetLastError();
                    } else {
                        __try {
                           // write value found
                            *pdwIndex = dwIndexFound;
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            pdhStatus = PDH_INVALID_ARGUMENT;
                        }
                    }
                    G_FREE (szWideName);
                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } else {
                pdhStatus = pMachine->dwStatus;
            }
            pMachine->dwRefCount--;
            RELEASE_MUTEX (pMachine->hMutex);
        } else {
            pdhStatus = GetLastError();
        }
    }

    if (   szLocalMachineName != NULL
        && szLocalMachineName !=  & szStaticLocalMachineName[0]) {
        G_FREE (szLocalMachineName);
    }

    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\query.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    query.c

Abstract:

    Query management functions exposed in pdh.dll

--*/

#include <windows.h>
#include <winperf.h>
#include <pdh.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "mbctype.h"
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"

STATIC_BOOL  IsValidLogHandle(IN HLOG hLog);
PDH_FUNCTION PdhiRewindWmiLog(IN PPDHI_LOG pLog);

// query link list head pointer
PPDHI_QUERY PdhiDllHeadQueryPtr = NULL;

STATIC_BOOL
PdhiFreeQuery (
    IN  PPDHI_QUERY pThisQuery
)
/*++

Routine Description:

    removes the query from the list of queries and updates the list
        linkages

Arguments:

    IN  PPDHI_QUERY pThisQuery
        pointer to the query to remove. No testing is performed on
        this pointer so it's assumed to be a valid query pointer.
        The pointer is invalid when this function returns.

Return Value:

    TRUE

--*/
{
    PPDHI_QUERY     pPrevQuery;
    PPDHI_QUERY     pNextQuery;
    PPDHI_COUNTER   pThisCounter;
    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY_MACHINE pNextQMachine;
    LONG            lStatus;
    BOOL            bStatus;
    HANDLE          hQueryMutex;

    if (WAIT_FOR_AND_LOCK_MUTEX(pThisQuery->hMutex) != ERROR_SUCCESS)
        return WAIT_TIMEOUT;

    hQueryMutex = pThisQuery->hMutex;

    // close any async data collection threads

    if (pThisQuery->hExitEvent != NULL) {
        RELEASE_MUTEX(pThisQuery->hMutex);
        // stop current thread first
        SetEvent (pThisQuery->hExitEvent);
        // wait 1 second for the thread to stop
        lStatus = WaitForSingleObject (pThisQuery->hAsyncThread, 10000L);
        if (lStatus == WAIT_TIMEOUT) {
            REPORT_EVENT(EVENTLOG_ERROR_TYPE,
                         PDH_EVENT_CATEGORY_DEBUG,
                         PDH_ASYNC_QUERY_TIMEOUT);
        }

        if (WAIT_FOR_AND_LOCK_MUTEX (pThisQuery->hMutex) != ERROR_SUCCESS)
            return WAIT_TIMEOUT;
        bStatus = CloseHandle (pThisQuery->hExitEvent);
        assert (bStatus);
        pThisQuery->hExitEvent = NULL;
    }

    // define pointers
    pPrevQuery = pThisQuery->next.blink;
    pNextQuery = pThisQuery->next.flink;

    // free any counters in counter list
    if ((pThisCounter = pThisQuery->pCounterListHead) != NULL) {
        while (pThisCounter->next.blink != pThisCounter->next.flink) {
            // delete from list
            // the deletion routine updates the blink pointer as it
            // removes the specified entry.
            FreeCounter (pThisCounter->next.blink);
        }
        // remove last counter
        FreeCounter (pThisCounter);
        pThisQuery->pCounterListHead = NULL;
    }

    if (!(pThisQuery->dwFlags & PDHIQ_WBEM_QUERY)) {
        // free allocated memory in the query
        if ((pQMachine = pThisQuery->pFirstQMachine) != NULL) {
            //  Free list of machine pointers
            do {
                pNextQMachine = pQMachine->pNext;
                if (pQMachine->pPerfData != NULL) {
                    G_FREE (pQMachine->pPerfData);
                }
                G_FREE (pQMachine);
                pQMachine = pNextQMachine;
            } while (pQMachine != NULL);
            pThisQuery->pFirstQMachine = NULL;
        }
    }

    if (pThisQuery->dwFlags & PDHIQ_WBEM_QUERY) {
        lStatus = PdhiFreeWbemQuery (pThisQuery);
    }

    if (   pThisQuery->dwReleaseLog != FALSE
        && pThisQuery->hLog != H_REALTIME_DATASOURCE
        && pThisQuery->hLog != H_WBEM_DATASOURCE) {
        PdhCloseLog (pThisQuery->hLog, 0);
        pThisQuery->hLog = H_REALTIME_DATASOURCE;
    }
    if (pThisQuery->hOutLog != NULL && IsValidLogHandle(pThisQuery->hOutLog)) {
        PPDHI_LOG pOutLog = (PPDHI_LOG) pThisQuery->hOutLog;
        pOutLog->pQuery = NULL;
    }

    // update pointers
    if ((pPrevQuery == pThisQuery) && (pNextQuery == pThisQuery)) {
        // then this query is the only (i.e. last) one in the list
        PdhiDllHeadQueryPtr = NULL;
    } else {
        // update query list pointers
        pPrevQuery->next.flink = pNextQuery;
        pNextQuery->next.blink = pPrevQuery;
        if (PdhiDllHeadQueryPtr == pThisQuery) {
            // then this is the first entry in the list so point to the
            // next one in line
            PdhiDllHeadQueryPtr = pNextQuery;
        }
    }

    if (pThisQuery->hMutex != NULL) {        
        pThisQuery->hMutex = NULL;
    }

    // clear the query structure
    memset (pThisQuery, 0, sizeof(PDHI_QUERY));

    // delete this query
    G_FREE (pThisQuery);

    // release and free the query mutex
    RELEASE_MUTEX(hQueryMutex);
    CloseHandle(hQueryMutex);

    return TRUE;
}

PDH_FUNCTION
PdhOpenQueryH(
    IN HLOG        hDataSource,
    IN DWORD_PTR   dwUserData,
    IN HQUERY    * phQuery
)
{
    PPDHI_QUERY pNewQuery;
    PPDHI_QUERY pLastQuery;
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    BOOL        bWbemData    = FALSE;
    PPDHI_LOG   pDataSource  = NULL;
    DWORD       dwDataSource = DataSourceTypeH(hDataSource);
 
    if (phQuery == NULL) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    if (dwDataSource == DATA_SOURCE_WBEM) {
        hDataSource = H_WBEM_DATASOURCE;
        bWbemData   = TRUE;
    }

    if (   dwDataSource == DATA_SOURCE_WBEM
        || dwDataSource == DATA_SOURCE_REGISTRY) {
        pDataSource = NULL;
    }
    else if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
    }
    else {
        ReturnStatus = PDH_INVALID_ARGUMENT;
        goto Cleanup;
    }

    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);
    
    if (ReturnStatus == ERROR_SUCCESS) {
        pNewQuery = G_ALLOC(sizeof (PDHI_QUERY));
        if (pNewQuery == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }

        if (ReturnStatus == ERROR_SUCCESS) {
            pNewQuery->hMutex = CreateMutexW(NULL, TRUE, NULL);

            * (DWORD *)(& pNewQuery->signature[0]) = SigQuery;

            if (PdhiDllHeadQueryPtr == NULL) {
                PdhiDllHeadQueryPtr = pNewQuery->next.flink
                                    = pNewQuery->next.blink
                                    = pNewQuery;
            }
            else {
                pLastQuery = PdhiDllHeadQueryPtr->next.blink;
                pNewQuery->next.flink           = PdhiDllHeadQueryPtr;
                pNewQuery->next.blink           = pLastQuery;
                PdhiDllHeadQueryPtr->next.blink = pNewQuery;
                pLastQuery->next.flink          = pNewQuery;
            }

            pNewQuery->pCounterListHead = NULL;
            pNewQuery->pFirstQMachine   = NULL;
            pNewQuery->dwLength         = sizeof(PDHI_QUERY);
            pNewQuery->dwUserData       = dwUserData;
            pNewQuery->dwFlags          = 0;
            pNewQuery->dwFlags         |= (bWbemData ? PDHIQ_WBEM_QUERY : 0);
            pNewQuery->hLog             = hDataSource;
            pNewQuery->dwReleaseLog     = FALSE;
            if (   pDataSource != NULL
                && LOWORD(pDataSource->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                ReturnStatus = PdhiRewindWmiLog(pDataSource);
                if (ReturnStatus != ERROR_SUCCESS) {
                    RELEASE_MUTEX(pNewQuery->hMutex);
                    RELEASE_MUTEX(hPdhDataMutex);
                    goto Cleanup;
                }
            }
            pNewQuery->hOutLog          = NULL;

            * (LONGLONG *)(& pNewQuery->TimeRange.StartTime) = MIN_TIME_VALUE;
            * (LONGLONG *)(& pNewQuery->TimeRange.EndTime)   = MAX_TIME_VALUE;
            pNewQuery->TimeRange.SampleCount                 = 0;
            pNewQuery->dwLastLogIndex                        = 0;
            pNewQuery->dwInterval                            = 0;
            pNewQuery->hAsyncThread                          = NULL;
            pNewQuery->hExitEvent                            = NULL;
            pNewQuery->hNewDataEvent                         = NULL;

            pNewQuery->pRefresher    = NULL;
            pNewQuery->pRefresherCfg = NULL;
            pNewQuery->LangID        = GetUserDefaultUILanguage();

            RELEASE_MUTEX(pNewQuery->hMutex);

            __try {
                * phQuery    = (HQUERY) pNewQuery;
                if(pDataSource != NULL) {
                    pDataSource->pQuery = (HQUERY) pNewQuery;
                }
                ReturnStatus = ERROR_SUCCESS;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                if (pNewQuery != NULL) {
                    PdhiFreeQuery(pNewQuery);
                }
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    } 

Cleanup:
    if (ReturnStatus == ERROR_SUCCESS) {
        if (   hDataSource == H_REALTIME_DATASOURCE
            || hDataSource == H_WBEM_DATASOURCE) {
            dwCurrentRealTimeDataSource ++;
        }
    }

    return ReturnStatus;
}

PDH_FUNCTION
PdhOpenQueryW (
    IN      LPCWSTR szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY  *phQuery
)
/*++

Routine Description:

    allocates a new query structure and inserts it at the end of the
    query list.

Arguments:

    IN      LPCWSTR szDataSource
        the name of the data (log) file to read from or NULL if the
        current activity is desired.

    IN      DWORD   dwUserData
        the user defined data field for this query,

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.

--*/
{
    PPDHI_QUERY pNewQuery;
    PPDHI_QUERY pLastQuery;
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    HLOG        hLogLocal = NULL;
    DWORD       dwLogType = 0;
    BOOL        bWbemData = FALSE;
    DWORD       dwDataSource = 0;

    // try writing to return pointer
    if (phQuery == NULL) {
       return PDH_INVALID_ARGUMENT;
    } else {
        __try {
            if (szDataSource != NULL) {
                WCHAR       TestChar;
                // test for read access to the name
                TestChar = *szDataSource;
                if (TestChar == 0) {
                    ReturnStatus = PDH_INVALID_ARGUMENT;
                }
            } // else NULL is a valid arg

            dwDataSource = DataSourceTypeW (szDataSource);
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return PDH_INVALID_ARGUMENT;
        }
    }

    // validate the data source
    switch (dwDataSource) {
        case DATA_SOURCE_LOGFILE:
            // then they are planning to read from a log file so
            // try to open it
            ReturnStatus = PdhOpenLogW (
                szDataSource,
                PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                &dwLogType,
                NULL,
                0,
                NULL,
                &hLogLocal);

            if (ReturnStatus != ERROR_SUCCESS) {
                return ReturnStatus;
            }
            break;

        case DATA_SOURCE_WBEM:
            bWbemData = TRUE;
            // they want real-time data, so just keep going
            hLogLocal = NULL;
            break;

        case DATA_SOURCE_REGISTRY:
            // they want real-time data, so just keep going
            hLogLocal = NULL;
            break;

        default:
            assert (FALSE);
    }

    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
    
    if (ReturnStatus == ERROR_SUCCESS) {
        // allocate new memory
        pNewQuery = G_ALLOC (sizeof (PDHI_QUERY));

        if (pNewQuery == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        if (ReturnStatus == ERROR_SUCCESS) {

            // create and capture the mutex for this query.
            pNewQuery->hMutex = CreateMutexW (NULL, TRUE, NULL);

            //initialize structures & list pointers
            // assign signature
            *(DWORD *)(&pNewQuery->signature[0]) = SigQuery;

            // update list pointers
            // test to see if this is the first query in the list
            if (PdhiDllHeadQueryPtr == NULL) {
                // then this is the first so fill in the static link pointers
                PdhiDllHeadQueryPtr =
                    pNewQuery->next.flink =
                    pNewQuery->next.blink = pNewQuery;
            } else {
                // get pointer to "last" entry in list
                pLastQuery = PdhiDllHeadQueryPtr->next.blink;
                // update new query pointers
                pNewQuery->next.flink = PdhiDllHeadQueryPtr;
                pNewQuery->next.blink = pLastQuery;
                // update existing pointers
                PdhiDllHeadQueryPtr->next.blink = pNewQuery;
                pLastQuery->next.flink = pNewQuery;
            }

            // initialize the counter linked list pointer
            pNewQuery->pCounterListHead = NULL;

            // initialize the machine list pointer
            pNewQuery->pFirstQMachine = NULL;

            // set length & user data
            pNewQuery->dwLength = sizeof (PDHI_QUERY);
            pNewQuery->dwUserData = dwUserData;

            // initialize remaining data fields
            pNewQuery->dwFlags = 0;
            pNewQuery->dwFlags |= (bWbemData ? PDHIQ_WBEM_QUERY : 0);

            pNewQuery->hLog = hLogLocal;
            pNewQuery->hOutLog = NULL;
            pNewQuery->dwReleaseLog = TRUE;

            // initialize time range to include entire range
            *(LONGLONG *)(&pNewQuery->TimeRange.StartTime) = MIN_TIME_VALUE;
            *(LONGLONG *)(&pNewQuery->TimeRange.EndTime) = MAX_TIME_VALUE;
            pNewQuery->TimeRange.SampleCount = 0;

            pNewQuery->dwLastLogIndex = 0;

            pNewQuery->dwInterval = 0;          // no auto interval
            pNewQuery->hAsyncThread = NULL;     // timing thread;
            pNewQuery->hExitEvent = NULL;       // async timing thread exit
            pNewQuery->hNewDataEvent = NULL;    // no event

            // initialize WBEM Data fields
            pNewQuery->pRefresher = NULL;
            pNewQuery->pRefresherCfg = NULL;
            pNewQuery->LangID = GetUserDefaultUILanguage();

            // release the mutex for this query
            RELEASE_MUTEX(pNewQuery->hMutex);

            __try {
                // return new query pointer as a handle.
                *phQuery = (HQUERY)pNewQuery;
                ReturnStatus = ERROR_SUCCESS;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                if (pNewQuery != NULL) {
                    // PdhiFreeQuery expects the data to be locked
                    PdhiFreeQuery (pNewQuery);
                }
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
        // release the data mutex
        RELEASE_MUTEX (hPdhDataMutex);
    } 

    // if this query was added and it's a real-time query then disable
    // future calls to change the data source.
    if (ReturnStatus == ERROR_SUCCESS) {
        if (hLogLocal == NULL) {
            dwCurrentRealTimeDataSource ++;
        }
    }

    return ReturnStatus;
}

PDH_FUNCTION
PdhOpenQueryA (
    IN      LPCSTR  szDataSource,
    IN      DWORD_PTR   dwUserData,
    IN      HQUERY  *phQuery
)
/*++

Routine Description:

    allocates a new query structure and inserts it at the end of the
    query list.

Arguments:

    IN      LPCSTR szDataSource
        the name of the data (log) file to read from or NULL if the
        current activity is desired.

    IN      DWORD   dwUserData
        the user defined data field for this query,

Return Value:

    Returns a valid query handle if successful or INVALID_HANDLE_VALUE
        if not. WIN32 Error status is retrieved using GetLastError()

--*/
{
    LPWSTR  szWideArg = NULL;
    DWORD   dwLength = 0;
    PDH_STATUS ReturnStatus = ERROR_SUCCESS;

    if (phQuery == NULL) {
       ReturnStatus = PDH_INVALID_ARGUMENT;
    } else {
        try {
            if (szDataSource != NULL) {
                dwLength = (DWORD)strlen(szDataSource);
                szWideArg = G_ALLOC ((dwLength + 1) * sizeof(WCHAR));
            } else {
                szWideArg = NULL;
            }

            if (szWideArg != NULL) {
                // convert ANSI arg to Wide chars and call wide char version
                // include null in conversion (i.e. length+1) so wide char
                // string is null terminated.
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szDataSource,
                                    dwLength,
                                    (LPWSTR) szWideArg,
                                    dwLength + 1);
            } else if (szDataSource != NULL) {
                // then a name was passed in but not converted to a wide
                // character string so a memory allocation failure occurred
                ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
    }
    if (ReturnStatus == ERROR_SUCCESS) {
        // call wide char version of function
        ReturnStatus = PdhOpenQueryW (szWideArg, dwUserData, phQuery);
    }
    if (szWideArg != NULL) {
        // free memory
        G_FREE (szWideArg);
    }
    // and return handle
    return ReturnStatus;
}

PDH_FUNCTION
PdhiAddCounter(
    IN      HQUERY      hQuery,
    IN      LPCWSTR     szFullName,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter,
    IN      PPDHI_COUNTER pNewCounter
    )
/*  Internal function called by PdhAddCounterW, PdhAddCounterA.
    Assumes that szFullName and pNewCounter are properly allocated,
    and initialized, i.e.  szFullName has the counter path, and
    pNewCounter zeroed.
*/
{
    PPDHI_COUNTER   pLastCounter;
    PPDHI_QUERY     pQuery;
    PDH_STATUS      ReturnStatus;
    BOOL            bStatus = TRUE;

    // we're changing the contents of PDH data so lock it

    * phCounter  = NULL;
    ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex);

    if (ReturnStatus == ERROR_SUCCESS) {
        if (!IsValidQuery(hQuery)) {
            // invalid query handle
            ReturnStatus = PDH_INVALID_HANDLE;
        } else {
            // assign signature & length values
            *(DWORD *)(&pNewCounter->signature[0]) = SigCounter;
            pNewCounter->dwLength = sizeof(PDHI_COUNTER);

            pQuery = (PPDHI_QUERY)hQuery;

            ReturnStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);
            if (ReturnStatus == ERROR_SUCCESS) {

                // link to owning query
                pNewCounter->pOwner = pQuery;

                // set user data fields
                pNewCounter->dwUserData = (DWORD) dwUserData;

                // counter is not init'd yet
                pNewCounter->dwFlags = PDHIC_COUNTER_NOT_INIT;

                // initialize scale to 1X and let the caller make any changes
                pNewCounter->lScale = 0;
                pNewCounter->szFullName = (LPWSTR) szFullName;

                if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
                    pNewCounter->dwFlags |= PDHIC_WBEM_COUNTER;
                    // then this is a WBEM query so use WBEM
                    // functions to initialize it
                    bStatus = WbemInitCounter (pNewCounter);
                } else {
                    bStatus = InitCounter(pNewCounter);
                }
                // load counter data using data retrieved from system
                if (bStatus) {
                    // update list pointers
                    // test to see if this is the first query in the list
                    if (pQuery->pCounterListHead == NULL) {
                        // then this is the 1st so fill in the
                        // static link pointers
                        pQuery->pCounterListHead =
                                pNewCounter->next.flink =
                                pNewCounter->next.blink = pNewCounter;
                    } else {
                        pLastCounter = pQuery->pCounterListHead->next.blink;
                        pNewCounter->next.flink  = pQuery->pCounterListHead;
                        pNewCounter->next.blink  = pLastCounter;
                        pLastCounter->next.flink = pNewCounter;
                        pQuery->pCounterListHead->next.blink = pNewCounter;
                    }
                    * phCounter  = (HCOUNTER) pNewCounter;
                    ReturnStatus = ERROR_SUCCESS;
                } else {
                    // get the error value
                    ReturnStatus = GetLastError();
                }

                RELEASE_MUTEX (pQuery->hMutex);
            }
        }
        RELEASE_MUTEX(hPdhDataMutex);
    }

    return ReturnStatus;
}

PDH_FUNCTION
PdhAddCounterW (
    IN      HQUERY  hQuery,
    IN      LPCWSTR szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER *phCounter
)
/*++

Routine Description:

    Creates and initializes a counter structure and attaches it to the
        specified query.

Arguments:

    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.

    IN  LPCWSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.

    IN  DWORD   dwUserData
        the user defined data field for this query.

    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.

--*/
{
    PPDHI_COUNTER   pNewCounter = NULL;
    PDH_STATUS      ReturnStatus = ERROR_SUCCESS;
    SIZE_T          nPathLen = 0;
    LPWSTR          szFullName = NULL;
    HCOUNTER        hLocalCounter = NULL;

    if ((szFullCounterPath == NULL) || (phCounter == NULL)) {
        return PDH_INVALID_ARGUMENT;
    }
    __try {
        *phCounter = NULL; // init to null

        nPathLen = lstrlenW(szFullCounterPath);
        if ((nPathLen == 0) || (nPathLen >= MAX_COUNTER_PATH-1)) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
        else {
            szFullName = G_ALLOC( (nPathLen + 1) * sizeof(WCHAR) );
            if (szFullName) {
                lstrcpyW (szFullName, szFullCounterPath);
            }
            else {
                ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
    }

    if (ReturnStatus == ERROR_SUCCESS) {
        pNewCounter = G_ALLOC (sizeof (PDHI_COUNTER));
        if (pNewCounter == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            RtlZeroMemory(pNewCounter, sizeof(PDHI_COUNTER));
        }
    }

    // query handle is tested by PdhiAddCounter

    if (ReturnStatus == ERROR_SUCCESS) {
        ReturnStatus = PdhiAddCounter(
                         hQuery, szFullName,
                         dwUserData, &hLocalCounter,
                         pNewCounter);
        if (ReturnStatus == ERROR_SUCCESS && hLocalCounter != NULL) {
            __try {
                *phCounter = hLocalCounter;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    if (ReturnStatus != ERROR_SUCCESS) {
        if (pNewCounter) {
            if (pNewCounter->szFullName == NULL) {
                G_FREE(szFullName);
            }
            if (!FreeCounter(pNewCounter)) {
                G_FREE (pNewCounter);
            }
        } else if (szFullName) {    // allocated this, but not pNewCounter
            G_FREE (szFullName);
        }
    }
    return ReturnStatus;
}

PDH_FUNCTION
PdhAddCounterA (
    IN      HQUERY  hQuery,
    IN      LPCSTR   szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER *phCounter
)
/*++

Routine Description:

    Creates and initializes a counter structure and attaches it to the
        specified query.

Arguments:

    IN  HQUERY  hQuery
        handle of the query to attach this counter to once the counter
        entry has been successfully created.

    IN  LPCSTR szFullCounterPath
        pointer to the path string that describes the counter to add to
        the query referenced above. This string must specify a single
        counter. Wildcard path strings are not permitted.

    IN  DWORD   dwUserData
        the user defined data field for this query.

    IN  HCOUNTER *phCounter
        pointer to the buffer that will get the handle value of the
        successfully created counter entry.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_ARGUMENT is returned when one or more of the arguements
        is invalid or incorrect.
    PDH_MEMORY_ALLOCATION_FAILURE is returned when a memory buffer could
        not be allocated.
    PDH_INVALID_HANDLE is returned if the query handle is not valid.
    PDH_CSTATUS_NO_COUNTER is returned if the specified counter was
        not found
    PDH_CSTATUS_NO_OBJECT is returned if the specified object could
        not be found
    PDH_CSTATUS_NO_MACHINE is returned if a machine entry could not
        be created.
    PDH_CSTATUS_BAD_COUNTERNAME is returned if the counter name path
        string could not be parsed or interpreted
    PDH_CSTATUS_NO_COUNTERNAME is returned if an empty counter name
        path string is passed in
    PDH_FUNCTION_NOT_FOUND is returned if the calculation function
        for this counter could not be determined.

--*/
{
    LPWSTR   szFullName = NULL;
    int      nLength = 0;
    PDH_STATUS ReturnStatus = ERROR_SUCCESS;
    HCOUNTER    hLocalCounter   = NULL;
    PPDHI_COUNTER   pNewCounter = NULL;

    if (phCounter == NULL || szFullCounterPath == NULL)
        return PDH_INVALID_ARGUMENT;

    __try {
         // try writing to return pointer
        *phCounter = NULL;

        nLength = strlen(szFullCounterPath);
        if ((nLength == 0) || (nLength >= MAX_COUNTER_PATH-1)) {
            ReturnStatus = PDH_INVALID_ARGUMENT;
        }
        else {
            szFullName = G_ALLOC((nLength + 1) * sizeof(WCHAR));
            if (szFullName == NULL) {
                ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
            else {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szFullCounterPath,
                                    nLength,
                                    (LPWSTR) szFullName,
                                    nLength + 1);
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ReturnStatus = PDH_INVALID_ARGUMENT;
    }

    if (ReturnStatus == ERROR_SUCCESS) {
        pNewCounter = G_ALLOC (sizeof (PDHI_COUNTER));
        if (pNewCounter == NULL) {
            ReturnStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            RtlZeroMemory(pNewCounter, sizeof(PDHI_COUNTER));
        }
    }

    // query handle is tested by PdhiAddCounter

    if (ReturnStatus == ERROR_SUCCESS) {
        ReturnStatus = PdhiAddCounter(
                         hQuery, szFullName,
                         dwUserData, & hLocalCounter,
                         pNewCounter);
        if (ReturnStatus == ERROR_SUCCESS && hLocalCounter != NULL) {
            __try {
                *phCounter = hLocalCounter;
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                ReturnStatus = PDH_INVALID_ARGUMENT;
            }
        }
    }
    if (ReturnStatus != ERROR_SUCCESS) {
        if (pNewCounter) {
            if (pNewCounter->szFullName == NULL) {
                G_FREE(szFullName);
            }
            if (!FreeCounter(pNewCounter)) {
                G_FREE (pNewCounter);
            }
        } else if (szFullName) {    // allocated this, but not pNewCounter
            G_FREE (szFullName);
        }
    }
    return ReturnStatus;
}

PDH_FUNCTION
PdhRemoveCounter (
    IN      HCOUNTER    hCounter
)
/*++

Routine Description:

    Removes the specified counter from the query it is attached to and
        closes any handles and frees any memory associated with this
        counter

Arguments:

    IN  HCOUNTER  hCounter
        handle of the counter to remove from the query.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_HANDLE is returned if the counter handle is not valid.

--*/
{
    PPDHI_COUNTER   pThisCounter;
    PPDHI_QUERY     pThisQuery;
    PPDHI_COUNTER    pNextCounter;

    PPDHI_QUERY_MACHINE pQMachine;
    PPDHI_QUERY_MACHINE pNextQMachine;

    PDH_STATUS      pdhStatus = ERROR_SUCCESS;

    // we're changing the contents PDH data so lock it
    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidCounter(hCounter)) {
         // it's ok to cast it to a pointer now.
        pThisCounter = (PPDHI_COUNTER)hCounter;
        pThisQuery = pThisCounter->pOwner;

        if (! IsValidQuery(pThisQuery)) {
            pdhStatus = PDH_INVALID_HANDLE;
            goto Cleanup;
        }

        if (WAIT_FOR_AND_LOCK_MUTEX(pThisQuery->hMutex) != ERROR_SUCCESS) {
            pdhStatus = WAIT_TIMEOUT;
            goto Cleanup;
        }

        if (pThisCounter == pThisQuery->pCounterListHead) {
            if (pThisCounter->next.flink == pThisCounter){
                // then this is the only counter in the query
                FreeCounter (pThisCounter);
                pThisQuery->pCounterListHead = NULL;

                if (!(pThisQuery->dwFlags & PDHIQ_WBEM_QUERY)) {
                    // remove the QMachine list since there are now no more
                    // counters to query
                        if ((pQMachine = pThisQuery->pFirstQMachine) != NULL) {
                        //  Free list of machine pointers
                        do {
                            pNextQMachine = pQMachine->pNext;
                            if (pQMachine->pPerfData != NULL) {
                                G_FREE (pQMachine->pPerfData);
                            }
                            G_FREE (pQMachine);
                            pQMachine = pNextQMachine;
                        } while (pQMachine != NULL);
                        pThisQuery->pFirstQMachine = NULL;
                    }
                }
            } else {
                // they are deleting the first counter from the list
                // so update the list pointer
                // Free Counter takes care of the list links, we just
                // need to manage the list head pointer
                pNextCounter = pThisCounter->next.flink;
                FreeCounter (pThisCounter);
                pThisQuery->pCounterListHead = pNextCounter;
            }
        } else {
            // remove this from the list
            FreeCounter (pThisCounter);
        }
        RELEASE_MUTEX (pThisQuery->hMutex);
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }

Cleanup:
    RELEASE_MUTEX (hPdhDataMutex);
    return pdhStatus;
}

PDH_FUNCTION
PdhSetQueryTimeRange (
    IN      HQUERY          hQuery,
    IN      PPDH_TIME_INFO  pInfo
)
{
    PPDHI_QUERY     pQuery;
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;

    if (pInfo == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        if (IsValidQuery(hQuery)) {           
            pQuery = (PPDHI_QUERY)hQuery;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pQuery->hMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidQuery(hQuery)) {           
                    if (pQuery->hLog == NULL) {
                        pdhStatus = ERROR_SUCCESS;
                    } else {
                        __try {
                            if (*(LONGLONG *)(&pInfo->EndTime) > *(LONGLONG *)(&pInfo->StartTime)) {
                                // reset log file pointers to beginning so next query
                                // will read from the start of the time range
                                pdhStatus = PdhiResetLogBuffers (pQuery->hLog);
                                // ok so now load new time range
                                if (pdhStatus == ERROR_SUCCESS) {
                                    pQuery->TimeRange = *pInfo;
                                    pQuery->dwLastLogIndex = 0;
                                }
                            } else {
                                // end time is smaller (earlier) than start time
                                pdhStatus = PDH_INVALID_ARGUMENT;
                            }
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            pdhStatus = PDH_INVALID_ARGUMENT;
                        }
                    }
                } else {
                    // the query disappeared while we were waiting for it
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pQuery->hMutex);
            } // else couldn't lock query
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }
    return pdhStatus;
}

PDH_FUNCTION
PdhiCollectQueryData (
    IN      PPDHI_QUERY pQuery,
    IN      LONGLONG    *pllTimeStamp
)
{
    PDH_STATUS  Status;

    if (WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
        Status = GetQueryWbemData (pQuery, pllTimeStamp);
    } else {
        Status = GetQueryPerfData (pQuery, pllTimeStamp);
    }

    RELEASE_MUTEX(pQuery->hMutex);

    return Status;
}

PDH_FUNCTION
PdhCollectQueryData (
    IN      HQUERY      hQuery
)
/*++

Routine Description:

    Retrieves the current value of each counter attached to the specified
        query.

    For this version, each machine associated with this query is polled
    sequentially. This is simple and safe, but potentially slow so a
    multi-threaded approach will be reviewed for the next version.

    Note that while the call may succeed, no data may be available. The
    status of each counter MUST be checked before its data is used.

Arguments:

    IN  HQUERY  hQuery
        handle of the query to update.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_HANDLE is returned if the query handle is not valid.

    PDH_NO_DATA is returned if the query does not have any counters defined
        yet.

--*/
{
    PDH_STATUS  Status;
    PPDHI_QUERY pQuery;
    LONGLONG    llTimeStamp;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        pQuery = (PPDHI_QUERY)hQuery;

        Status = PdhiCollectQueryData (pQuery, &llTimeStamp);
    } else {
        Status = PDH_INVALID_HANDLE;
    }

    RELEASE_MUTEX (hPdhDataMutex);

    return Status;
}

PDH_FUNCTION
PdhCollectQueryDataEx (
    IN      HQUERY      hQuery,
    IN      DWORD       dwIntervalTime,
    IN      HANDLE      hNewDataEvent
)
/*++

Routine Description:

    Retrieves the current value of each counter attached to the specified
        query periodically based on the interval time specified.

    For this version, each machine associated with this query is polled
    sequentially.

    Note that while the call may succeed, no data may be available. The
    status of each counter MUST be checked before its data is used.

Arguments:

    IN  HQUERY  hQuery
        handle of the query to update.

    IN      DWORD       dwIntervalTime
        Interval to poll for new data in seconds
        this value must be > 0. A value of 0 will terminate any current
        data collection threads.

    IN      HANDLE      hNewDataEvent
        Handle to an Event that should be signaled when new data is
        available. This can be NULL if no notification is desired.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_HANDLE is returned if the query handle is not valid.

--*/
{
    PDH_STATUS  lStatus = ERROR_SUCCESS;
    PPDHI_QUERY pQuery;
    DWORD       dwThreadId;
    BOOL        bStatus;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        // set the query structure's interval to the caller specified
        // value then start the timing thread.
        pQuery = (PPDHI_QUERY)hQuery;

        if (WAIT_FOR_AND_LOCK_MUTEX (pQuery->hMutex) != ERROR_SUCCESS) {
            lStatus = WAIT_TIMEOUT;
            goto Cleanup;
        }

        if (pQuery->hExitEvent != NULL) {
            RELEASE_MUTEX(pQuery->hMutex);
            // stop current thread first
            SetEvent (pQuery->hExitEvent);
            // wait 1 second for the thread to stop
            lStatus = WaitForSingleObject (pQuery->hAsyncThread, 10000L);
            if (lStatus == WAIT_TIMEOUT) {
                REPORT_EVENT(EVENTLOG_ERROR_TYPE,
                             PDH_EVENT_CATEGORY_DEBUG,
                             PDH_ASYNC_QUERY_TIMEOUT);
            }

            lStatus = WAIT_FOR_AND_LOCK_MUTEX (pQuery->hMutex);
            if (lStatus == ERROR_SUCCESS) {
                bStatus = CloseHandle (pQuery->hExitEvent);
                assert (bStatus);
                pQuery->hExitEvent = NULL;
                bStatus = CloseHandle (pQuery->hAsyncThread);
                assert (bStatus);
                pQuery->hAsyncThread = 0;
            }
        }

        if (lStatus == ERROR_SUCCESS) {
            // query mutex is still locked at this point
            if (dwIntervalTime > 0) {
                // start a new interval
                // initialize new values
                pQuery->dwInterval = dwIntervalTime;
                pQuery->hNewDataEvent = hNewDataEvent;
                pQuery->hExitEvent = CreateEventW (NULL, TRUE, FALSE, NULL);
                pQuery->hAsyncThread =  CreateThread (
                    NULL, 0, PdhiAsyncTimerThreadProc,
                    (LPVOID)pQuery, 0, &dwThreadId);

                RELEASE_MUTEX(pQuery->hMutex);

                if (pQuery->hAsyncThread == NULL) {
                    lStatus = WAIT_FOR_AND_LOCK_MUTEX (pQuery->hMutex);
                    if (lStatus == ERROR_SUCCESS) {
                        pQuery->dwInterval = 0;
                        pQuery->hNewDataEvent = NULL;
                        bStatus = CloseHandle (pQuery->hExitEvent);
                        assert (bStatus);
                        pQuery->hExitEvent = NULL;
                        RELEASE_MUTEX(pQuery->hMutex);
                        lStatus = GetLastError();
                    } 
                } else {
                    // lstatus = ERROR_SUCCESS from above
                }
            } else {
                // they just wanted to stop so clean up Query struct
                pQuery->dwInterval = 0;
                pQuery->hNewDataEvent = NULL;
                RELEASE_MUTEX(pQuery->hMutex);
                // lstatus = ERROR_SUCCESS from above
            }
        }
    } else {
        lStatus = PDH_INVALID_HANDLE;
    }

Cleanup:
    RELEASE_MUTEX (hPdhDataMutex);
    return lStatus;
}

PDH_FUNCTION
PdhCloseQuery (
    IN      HQUERY      hQuery
)
/*++

Routine Description:

    closes the query, all counters, connections and other resources
        related to this query are freed as well.

Arguments:

    IN  HQUERY  hQuery
        the handle of the query to free.

Return Value:

    Returns ERROR_SUCCESS if a new query was created and initialized,
        and a PDH_ error value if not.

    PDH_INVALID_HANDLE is returned if the query handle is not valid.

--*/
{
    PDH_STATUS  dwReturn;
    // lock system data
    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    if (IsValidQuery(hQuery)) {
        // dispose of query
        PPDHI_QUERY pQuery = (PPDHI_QUERY) hQuery;
        if (pQuery->hLog == H_REALTIME_DATASOURCE
            || pQuery->hLog == H_WBEM_DATASOURCE) {
            dwCurrentRealTimeDataSource --;
            if (dwCurrentRealTimeDataSource < 0) {
                dwCurrentRealTimeDataSource = 0;
            }
        }
        PdhiFreeQuery (pQuery);
        // release data lock
        dwReturn = ERROR_SUCCESS;
    } else {
        dwReturn = PDH_INVALID_HANDLE;
    }
    RELEASE_MUTEX (hPdhDataMutex);

    return dwReturn;
}

BOOL
PdhiQueryCleanup (
)
{
    PPDHI_QUERY pThisQuery;

    if (WAIT_FOR_AND_LOCK_MUTEX(hPdhDataMutex) != ERROR_SUCCESS) return WAIT_TIMEOUT;

    // free any queries in the query list
    pThisQuery = PdhiDllHeadQueryPtr;
    if (pThisQuery != NULL) {
        while (pThisQuery->next.blink != pThisQuery->next.flink) {
            // delete from list
            // the deletion routine updates the blink pointer as it
            // removes the specified entry.
            PdhiFreeQuery (pThisQuery->next.blink);
        }
        // remove last query
        PdhiFreeQuery (pThisQuery);
        PdhiDllHeadQueryPtr = NULL;

        dwCurrentRealTimeDataSource = 0;
    }

    RELEASE_MUTEX (hPdhDataMutex);
    return TRUE;
}

PDH_FUNCTION
PdhGetDllVersion(
    IN  LPDWORD lpdwVersion
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    __try {
        *lpdwVersion = PDH_VERSION;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    return pdhStatus;
}

BOOL
PdhIsRealTimeQuery (
    IN  HQUERY  hQuery
)
{
    PPDHI_QUERY     pQuery;
    BOOL            bReturn = FALSE;
    
    SetLastError (ERROR_SUCCESS);
    if (IsValidQuery(hQuery)) {
        __try {
            pQuery = (PPDHI_QUERY)hQuery;
            if (pQuery->hLog == NULL) {
                bReturn = TRUE;
            } else {
                bReturn = FALSE;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            SetLastError (GetExceptionCode());
        }
    } else {
        bReturn = FALSE;
    }
    return bReturn;
}

PDH_FUNCTION
PdhFormatFromRawValue (
    IN      DWORD               dwCounterType,
    IN      DWORD               dwFormat,
    IN      LONGLONG            *pTimeBase,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PPDH_FMT_COUNTERVALUE   pFmtValue
)
/*++

Routine Description:

    Calculates the formatted counter value using the data in the RawValue
        buffer in the format requested by the format field using the
        calculation functions of the counter type specified by the
        dwCounterType field.

Arguments:

    IN      DWORD   dwCounterType
        The type of the counter to use in order to determine the
        calculation functions for interpretation of the raw value buffers

    IN      DWORD       dwFormat
        Format in which the requested data should be returned. The
        values for this field are described in the PDH.H header
        file.

    IN      LONGLONG            *pTimeBase
        pointer to the _int64 value containing the timebase (i.e. counter
        unit frequency) used by this counter. This can be NULL if it's not
        required by the counter type
    IN      PPDH_RAW_COUNTER    rawValue1
        pointer to the buffer that contains the first raw value structure

    IN      PPDH_RAW_COUNTER    rawValue2
        pointer to the buffer that contains the second raw value structure.
        This argument may be null if only one value is required for the
        computation.

    IN      PPDH_FMT_COUNTERVALUE   fmtValue
        the pointer to the data buffer passed by the caller to receive
        the data requested. If the counter requires 2 values, (as in the
        case of a rate counter), rawValue1 is assumed to be the most
        recent value and rawValue2, the older value.

Return Value:

    The WIN32 Error status of the function's operation. Common values
        returned are:
            ERROR_SUCCESS   when all requested data is returned
            PDH_INVALID_HANDLE if the counter handle is incorrect
            PDH_INVALID_ARGUMENT if an argument is incorrect

--*/
{
    PDH_STATUS  lStatus = ERROR_SUCCESS;
    LPCOUNTERCALC   pCalcFunc;
    LPCOUNTERSTAT   pStatFunc;
    LONGLONG        llTimeBase;
    BOOL        bReturn;

    // TODO: Need to check for pRawValue1
    //      bad arguments are caught in the PdhiComputeFormattedValue function
    // NOTE: postW2k pTimeBase really do not need to be a pointer, since it is
    // not returned
    if (pTimeBase != NULL) {
        try {
            DWORD   dwTempStatus;
            DWORD   dwTypeMask;

            // read access to the timebase
            llTimeBase = *pTimeBase;

            // we should have read access to the rawValues
            dwTempStatus = *((DWORD volatile *)&pRawValue1->CStatus);

            // this one could be NULL
            if (pRawValue2 != NULL) {
                dwTempStatus = *((DWORD volatile *)&pRawValue2->CStatus);
            }

            // and write access to the fmtValue
            pFmtValue->CStatus = 0;

            // validate format flags:
            //      only one of the following can be set at a time
            dwTypeMask = dwFormat &
                (PDH_FMT_LONG | PDH_FMT_DOUBLE | PDH_FMT_LARGE);
            if (!((dwTypeMask == PDH_FMT_LONG) ||
                (dwTypeMask == PDH_FMT_DOUBLE) ||
                (dwTypeMask == PDH_FMT_LARGE))) {
                lStatus = PDH_INVALID_ARGUMENT;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            lStatus = PDH_INVALID_ARGUMENT;
        }
    } else {
        llTimeBase = 0;
    }

    if (lStatus == ERROR_SUCCESS) {

        // get calc func for counter type this will also test the
        // validity of the counter type argument

        bReturn = AssignCalcFunction (
            dwCounterType,
            &pCalcFunc,
            &pStatFunc);

        if (!bReturn) {
            lStatus = GetLastError();
        } else {
            lStatus = PdhiComputeFormattedValue (
                pCalcFunc,
                dwCounterType,
                0L,
                dwFormat,
                pRawValue1,
                pRawValue2,
                &llTimeBase,
                0L,
                pFmtValue);
        }
    }
    return lStatus;

}

LPWSTR
PdhiMatchObjectNameInList(
    IN  LPWSTR   szObjectName,
    IN  LPWSTR * szSrcPerfStrings,
    IN  LPWSTR * szDestPerfStrings,
    IN  DWORD    dwLastString)
{
    LPWSTR szRtnName = NULL;
    DWORD  i;

    for (i = 0; i <= dwLastString; i ++) {
        if (   szSrcPerfStrings[i]
            && szSrcPerfStrings[i] != L'\0'
            && lstrcmpiW(szObjectName, szSrcPerfStrings[i]) == 0) {
            szRtnName = szDestPerfStrings[i];
            break;
        }
    }

    return szRtnName;
}

PDH_FUNCTION
PdhiBuildFullCounterPath(
    IN  BOOL               bMachine,
    IN  PPDHI_COUNTER_PATH pCounterPath,
    IN  LPWSTR             szObjectName,
    IN  LPWSTR             szCounterName,
    IN  LPWSTR             szFullPath
)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    // Internal routine,
    // Build full counter path name from counter path structure, assume
    // passed-in string buffer is large enough to hold.

    if (bMachine) {
        lstrcpyW(szFullPath, pCounterPath->szMachineName);
        lstrcatW(szFullPath, cszBackSlash);
    }
    else {
        lstrcpyW(szFullPath, cszBackSlash);
    }
    lstrcatW(szFullPath, szObjectName);
    if (   pCounterPath->szInstanceName != NULL
        && pCounterPath->szInstanceName[0] != L'\0') {
        lstrcatW(szFullPath, cszLeftParen);
        if (   pCounterPath->szParentName != NULL
            && pCounterPath->szParentName[0] != L'\0') {
            lstrcatW(szFullPath, pCounterPath->szParentName);
            lstrcatW(szFullPath, cszSlash);
        }
        lstrcatW(szFullPath, pCounterPath->szInstanceName);
        if (   pCounterPath->dwIndex != ((DWORD) -1)
            && pCounterPath->dwIndex != 0) {
            WCHAR szDigits[16];

            ZeroMemory(szDigits, 16 * sizeof(WCHAR));
            lstrcatW(szFullPath, cszPoundSign);
            _ltow((long) pCounterPath->dwIndex, szDigits, 10);
            lstrcatW(szFullPath, szDigits);
        }
        lstrcatW(szFullPath, cszRightParen);
    }
    lstrcatW(szFullPath, cszBackSlash);
    lstrcatW(szFullPath, szCounterName);

    return Status;
}

PDH_FUNCTION
PdhiTranslateCounter(
    IN  LPWSTR      szSourcePath,
    IN  LPVOID      pFullPathName,
    IN  LPDWORD     pcchPathLength,
    IN  BOOL        bLocaleTo009,
    IN  BOOL        bUnicode)
{
    PDH_STATUS         Status         = ERROR_SUCCESS;
    PPERF_MACHINE      pMachine       = NULL;
    PPDHI_COUNTER_PATH pCounterPath   = NULL;
    LPWSTR             szRtnPath      = NULL;
    DWORD              dwPathSize;
    DWORD              dwRtnPathSize;
    DWORD              dwSize;
    BOOL               bMachineThere  = FALSE;

    bMachineThere =  (lstrlenW(szSourcePath) >= 2)
                  && (szSourcePath[0] == BACKSLASH_L)
                  && (szSourcePath[1] == BACKSLASH_L);

    dwPathSize = sizeof(WCHAR) * (lstrlenW(szSourcePath) + 2);
    dwSize     = sizeof(PDHI_COUNTER_PATH) + 2 * dwPathSize;
    pCounterPath = G_ALLOC(dwSize);
    if (pCounterPath == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
        goto Cleanup;
    }

    if (ParseFullPathNameW(szSourcePath, & dwSize, pCounterPath, FALSE)) {
        pMachine = GetMachineW(pCounterPath->szMachineName, 0);
        if (pMachine && pMachine->dwStatus == ERROR_SUCCESS) {
            LPWSTR  szObjectName;
            LPWSTR  szCounterName;
            BOOLEAN bInstance = TRUE;

            if (bLocaleTo009) {
                szObjectName  = PdhiMatchObjectNameInList(
                                pCounterPath->szObjectName,
                                pMachine->szPerfStrings,
                                pMachine->sz009PerfStrings,
                                pMachine->dwLastPerfString);
                szCounterName = PdhiMatchObjectNameInList(
                                pCounterPath->szCounterName,
                                pMachine->szPerfStrings,
                                pMachine->sz009PerfStrings,
                                pMachine->dwLastPerfString);
            }
            else {
                szObjectName  = PdhiMatchObjectNameInList(
                                pCounterPath->szObjectName,
                                pMachine->sz009PerfStrings,
                                pMachine->szPerfStrings,
                                pMachine->dwLastPerfString);
                szCounterName = PdhiMatchObjectNameInList(
                                pCounterPath->szCounterName,
                                pMachine->sz009PerfStrings,
                                pMachine->szPerfStrings,
                                pMachine->dwLastPerfString);
            }
            if (   (szObjectName == NULL)
                && (* pCounterPath->szObjectName == SPLAT_L)) {
                szObjectName = pCounterPath->szObjectName;
            }
            if (   (szCounterName == NULL)
                && (* pCounterPath->szCounterName == SPLAT_L)) {
                szCounterName = pCounterPath->szCounterName;
            }

            if (szObjectName == NULL || szCounterName == NULL) {
                Status = PDH_INVALID_ARGUMENT;
                goto Cleanup;
            }

            if (   pCounterPath->szInstanceName != NULL
                && pCounterPath->szInstanceName[0] != L'\0') {
                dwRtnPathSize = sizeof(WCHAR)
                              * (  lstrlenW(pCounterPath->szMachineName)
                                 + lstrlenW(szObjectName)
                                 + lstrlenW(pCounterPath->szInstanceName)
                                 + lstrlenW(szCounterName) + 5);
                if (   pCounterPath->szParentName != NULL
                    && pCounterPath->szParentName[0] != L'\0') {
                    dwRtnPathSize += (sizeof(WCHAR)
                            * (lstrlenW(pCounterPath->szParentName) + 1));
                }
                if (   pCounterPath->dwIndex != ((DWORD) -1)
                    && pCounterPath->dwIndex != 0) {
                    dwRtnPathSize += (sizeof(WCHAR) * 16);
                }
            }
            else {
                dwRtnPathSize = sizeof(WCHAR)
                              * (  lstrlenW(pCounterPath->szMachineName)
                                 + lstrlenW(szObjectName)
                                 + lstrlenW(szCounterName) + 3);
                bInstance = FALSE;
            }
            szRtnPath = G_ALLOC(dwRtnPathSize);
            if (szRtnPath == NULL) {
                Status = PDH_MEMORY_ALLOCATION_FAILURE;
                goto Cleanup;
            }

            PdhiBuildFullCounterPath(bMachineThere,
                                     pCounterPath,
                                     szObjectName,
                                     szCounterName,
                                     szRtnPath);
            if (bUnicode) {
                if (   (pFullPathName)
                    && (   (* pcchPathLength)
                        >= (DWORD) (lstrlenW(szRtnPath) + 1))) {
                    lstrcpyW(pFullPathName, szRtnPath);
                }
                else {
                    Status = PDH_MORE_DATA;
                }
                * pcchPathLength = lstrlenW(szRtnPath) + 1;
            }
            else {
                dwRtnPathSize = * pcchPathLength;
                if (bLocaleTo009) {
                    Status = PdhiConvertUnicodeToAnsi(CP_ACP,
                            szRtnPath, pFullPathName, & dwRtnPathSize);
                }
                else {
                    Status = PdhiConvertUnicodeToAnsi(_getmbcp(),
                            szRtnPath, pFullPathName, & dwRtnPathSize);
                }
                * pcchPathLength = dwRtnPathSize;
            }

            pMachine->dwRefCount --;
            RELEASE_MUTEX(pMachine->hMutex);
        }
        else {
            Status = PDH_CSTATUS_NO_MACHINE;
        }
    }
    else {
        Status = PDH_CSTATUS_BAD_COUNTERNAME;
    }

Cleanup:
    if (szRtnPath != NULL) {
        G_FREE(szRtnPath);
    }
    if (pCounterPath != NULL) {
        G_FREE(pCounterPath);
    }
    return Status;
}

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR      szLocalePath,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    if (szLocalePath == NULL || pszFullPathName == NULL
                             || pcchPathLength == NULL
                             || * pcchPathLength == 0) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            * pszFullPathName = 0;
            * (LPWSTR) (  ((LPBYTE) pszFullPathName)
                        + ((* pcchPathLength) - sizeof(WCHAR))) = 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(
                szLocalePath, pszFullPathName, pcchPathLength, TRUE, TRUE);
    }

    return Status;
}

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR       szLocalePath,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength)
{
    PDH_STATUS Status     = ERROR_SUCCESS;
    LPWSTR     szTmpPath  = NULL;
    DWORD      dwPathSize;

    if (szLocalePath == NULL || pszFullPathName == NULL
                             || pcchPathLength == NULL
                             || * pcchPathLength == 0) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            * pszFullPathName = 0;
            * (LPSTR) (  ((LPBYTE) pszFullPathName)
                       + ((* pcchPathLength) - sizeof(CHAR))) = 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }

    if (Status == ERROR_SUCCESS) {
        dwPathSize = sizeof(WCHAR) * (lstrlenA(szLocalePath) + 1);
        szTmpPath  = G_ALLOC(dwPathSize);
        if (szTmpPath == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            MultiByteToWideChar(_getmbcp(),
                                0,
                                szLocalePath,
                                lstrlenA(szLocalePath),
                                szTmpPath,
                                dwPathSize / sizeof(WCHAR));
            Status = PdhiTranslateCounter(
                    szTmpPath, pszFullPathName, pcchPathLength, TRUE, FALSE);
            G_FREE(szTmpPath);
        }
    }

    return Status;
}

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR      sz009Path,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength)
{
    PDH_STATUS Status = ERROR_SUCCESS;

    if (sz009Path == NULL || pszFullPathName == NULL
                          || pcchPathLength == NULL
                          || * pcchPathLength == 0) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            * pszFullPathName = 0;
            * (LPWSTR) (  ((LPBYTE) pszFullPathName)
                        + ((* pcchPathLength) - sizeof(WCHAR))) = 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        Status = PdhiTranslateCounter(
                    sz009Path, pszFullPathName, pcchPathLength, FALSE, TRUE);
    }

    return Status;
}

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR       sz009Path,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength)
{
    PDH_STATUS Status     = ERROR_SUCCESS;
    LPWSTR     szTmpPath  = NULL;
    DWORD      dwPathSize;

    if (sz009Path == NULL || pszFullPathName == NULL
                          || pcchPathLength == NULL
                          || * pcchPathLength == 0) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        __try {
            * pszFullPathName = 0;
            * (LPSTR) (  ((LPBYTE) pszFullPathName)
                       + ((* pcchPathLength) - sizeof(CHAR))) = 0;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = PDH_INVALID_ARGUMENT;
        }
    }
    if (Status == ERROR_SUCCESS) {
        dwPathSize = sizeof(WCHAR) * (lstrlenA(sz009Path) + 1);
        szTmpPath = G_ALLOC(dwPathSize);
        if (szTmpPath == NULL) {
            Status = PDH_MEMORY_ALLOCATION_FAILURE;
        }
        else {
            MultiByteToWideChar(CP_ACP,
                                0,
                                sz009Path,
                                lstrlenA(sz009Path),
                                szTmpPath,
                                dwPathSize / sizeof(WCHAR));
            Status = PdhiTranslateCounter(
                    szTmpPath, pszFullPathName, pcchPathLength, FALSE, FALSE);
            G_FREE(szTmpPath);
        }
    }

    return Status;
}

PDH_FUNCTION
PdhAdd009CounterW(
    IN  HQUERY      hQuery,
    IN  LPWSTR      szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter)
{
    PDH_STATUS Status       = ERROR_SUCCESS;
    LPWSTR     szLocalePath = NULL;
    DWORD      dwPathLength = sizeof(WCHAR) * (lstrlenW(szFullPath) + 1);

    szLocalePath = G_ALLOC(dwPathLength);
    if (szLocalePath == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        Status = PdhTranslateLocaleCounterW(
                        szFullPath, szLocalePath, & dwPathLength);
        if (Status == ERROR_SUCCESS) {
            Status = PdhAddCounterW(
                            hQuery, szLocalePath, dwUserData, phCounter);
        }
        if (Status != ERROR_SUCCESS) {
            G_FREE(szLocalePath);
        }
    }

    return Status;
}

PDH_FUNCTION
PdhAdd009CounterA(
    IN  HQUERY      hQuery,
    IN  LPSTR       szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter)
{
    PDH_STATUS Status       = ERROR_SUCCESS;
    LPSTR      szLocalePath = NULL;
    DWORD      dwPathLength = sizeof(WCHAR) * (lstrlenA(szFullPath) + 1);

    szLocalePath = G_ALLOC(dwPathLength);
    if (szLocalePath == NULL) {
        Status = PDH_MEMORY_ALLOCATION_FAILURE;
    }
    else {
        Status = PdhTranslateLocaleCounterA(
                        szFullPath, szLocalePath, & dwPathLength);
        if (Status == ERROR_SUCCESS) {
            Status = PdhAddCounterA(
                            hQuery, szLocalePath, dwUserData, phCounter);
        }
        if (Status != ERROR_SUCCESS) {
            G_FREE(szLocalePath);
        }
    }

    return Status;
}

PDH_FUNCTION
PdhiConvertUnicodeToAnsi(
    IN  UINT     uCodePage,
    IN  LPWSTR   wszSrc,
    IN  LPSTR    aszDest,
    IN  LPDWORD  pdwSize
)
{
    PDH_STATUS Status  = ERROR_SUCCESS;
    DWORD      dwDest;
    DWORD      dwSrc   = 0;

    if (wszSrc == NULL || * wszSrc == L'\0' || pdwSize == NULL) {
        Status = PDH_INVALID_ARGUMENT;
    }
    else {
        dwSrc = lstrlenW(wszSrc);
        dwDest = WideCharToMultiByte(uCodePage,
                                     0,
                                     wszSrc,
                                     dwSrc,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL);
        if (aszDest != NULL && (dwDest + 1) <= * pdwSize) {
            ZeroMemory(aszDest, dwDest + 1);
            WideCharToMultiByte(_getmbcp(),
                            0,
                            wszSrc,
                            dwSrc,
                            aszDest,
                            * pdwSize,
                            NULL,
                            NULL);
        }
        else {
            Status = PDH_MORE_DATA;
        }

        * pdwSize = dwDest + 1;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\strings.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    String constants used by the functions in the PDH.DLL library

--*/

#include <windows.h>
#include "strings.h"

LPCWSTR    cszAppShortName = (LPCWSTR)L"PDH";

// registry path, key and value strings
LPCWSTR    cszNamesKey = 
    (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR    cszDefaultLangId = (LPCWSTR)L"009";
LPCWSTR    cszCounters = (LPCWSTR)L"Counters";
LPCWSTR    cszHelp = (LPCWSTR)L"Help";
LPCWSTR    cszLastHelp = (LPCWSTR)L"Last Help";
LPCWSTR    cszLastCounter = (LPCWSTR)L"Last Counter";
LPCWSTR    cszVersionName = (LPCWSTR)L"Version";
LPCWSTR    cszCounterName = (LPCWSTR)L"Counter ";
LPCWSTR    cszHelpName = (LPCWSTR)L"Explain ";
LPCWSTR    cszGlobal = (LPCWSTR)L"Global";
LPCWSTR    cszCostly = (LPCWSTR)L"Costly";
LPCWSTR    cszLogQueries = (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\PerfDataLog\\Log Queries";
LPCWSTR    cszLogFileType = (LPCWSTR)L"Log File Type";
LPCWSTR    cszAutoNameInterval = (LPCWSTR)L"Auto Name Interval";
LPCWSTR    cszLogFileName = (LPCWSTR)L"Log Filename";
LPCWSTR    cszLogDefaultDir = (LPCWSTR)L"Log Default Directory";
LPCWSTR    cszBaseFileName = (LPCWSTR)L"Base Filename";
LPCWSTR    cszLogFileAutoFormat = (LPCWSTR)L"Log File Auto Format";
LPCWSTR    cszAutoRenameUnits = (LPCWSTR)L"Auto Rename Units";
LPCWSTR    cszCommandFile = (LPCWSTR)L"Command File";
LPCWSTR    cszCounterList = (LPCWSTR)L"Counter List";
LPCSTR     caszCounterList = "Counter List";
LPCWSTR    cszPerfDataLog = (LPCWSTR)L"PerfDataLog";
LPCWSTR    cszDefault = (LPCWSTR)L"Default";
LPCSTR     caszDefaultLogCaption = "User Data";
LPCWSTR    cszPerfNamePathPrefix = (LPCWSTR)L"%systemroot%\\system32\\perf";
LPCWSTR    cszDat = (LPCWSTR)L".dat";
LPCWSTR    cszWBEM = (LPCWSTR)L"WBEM:";
LPCWSTR    cszWMI  = (LPCWSTR)L"WMI:";
LPCWSTR    cszSQL = (LPCWSTR)L"SQL:";
LPCSTR     caszWBEM = "WBEM:";
LPCSTR     caszWMI = "WMI:";
LPCWSTR    cszWbemDefaultPerfRoot = (LPCWSTR)L"\\root\\cimv2";
LPCWSTR    cszSingletonInstance = (LPCWSTR)L"=@";
LPCWSTR    cszNameParam = (LPCWSTR)L".Name=\"";
LPCWSTR    cszCountertype = (LPCWSTR)L"countertype";
LPCWSTR    cszDisplayname = (LPCWSTR)L"displayname";
LPCWSTR    cszExplainText = (LPCWSTR)L"Description";
LPCWSTR    cszDefaultscale = (LPCWSTR)L"defaultscale";
LPCWSTR    cszSingleton = (LPCWSTR)L"singleton";
LPCWSTR    cszPerfdetail = (LPCWSTR)L"perfdetail";
LPCWSTR    cszPerfdefault = (LPCWSTR)L"perfdefault";
LPCWSTR    cszClass = (LPCWSTR)L"__CLASS";
LPCWSTR    cszPerfRawData = (LPCWSTR)L"Win32_PerfRawData";
LPCWSTR    cszNotFound = (LPCWSTR)L"Not Found";
LPCWSTR    cszName = (LPCWSTR)L"Name";
LPCWSTR    cszBaseSuffix = (LPCWSTR)L"_Base";
LPCWSTR    cszTimestampPerfTime    = (LPCWSTR)L"Timestamp_PerfTime";
LPCWSTR    cszFrequencyPerfTime    = (LPCWSTR)L"Frequency_PerfTime";
LPCWSTR    cszTimestampSys100Ns    = (LPCWSTR)L"Timestamp_Sys100NS";
LPCWSTR    cszFrequencySys100Ns    = (LPCWSTR)L"Frequency_Sys100NS";
LPCWSTR    cszTimestampObject      = (LPCWSTR)L"Timestamp_Object";
LPCWSTR    cszFrequencyObject      = (LPCWSTR)L"Frequency_Object";
LPCWSTR    cszPerfmonLogSig        = (LPCWSTR)L"Loges";

LPCWSTR    cszRemoteMachineRetryTime    = (LPCWSTR)L"Remote Reconnection Retry Time";
LPCWSTR    cszEnableRemotePdhAccess     = (LPCWSTR)L"Enable Remote PDH Access";
LPCWSTR    cszPdhKey                    = (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PDH";
LPCWSTR    cszDefaultNullDataSource     = (LPCWSTR)L"DefaultNullDataSource";
LPCWSTR    cszLogSectionName            = (LPCWSTR)L"SYSMON_LOG_READONLY_";
LPCWSTR    cszCurrentVersionKey         = (LPCWSTR)L"Software\\Microsoft\\Windows NT\\CurrentVersion";
LPCWSTR    cszCurrentVersionValueName   = (LPCWSTR)L"CurrentVersion";

LPCWSTR    fmtDecimal = (LPCWSTR)L"%d";
LPCWSTR    fmtSpaceDecimal = (LPCWSTR)L" %d";
LPCWSTR    fmtLangId = (LPCWSTR)L"%3.3x";

// single character strings
LPCWSTR    cszEmptyString = (LPCWSTR)L"";
LPCWSTR    cszPoundSign = (LPCWSTR)L"#";
LPCWSTR    cszSplat = (LPCWSTR)L"*";
LPCWSTR    cszSlash = (LPCWSTR)L"/";
LPCWSTR    cszBackSlash = (LPCWSTR)L"\\";
LPCWSTR    cszLeftParen = (LPCWSTR)L"(";
LPCWSTR    cszRightParen = (LPCWSTR)L")";
LPCWSTR    cszC = (LPCWSTR)L"C";
LPCWSTR    cszH = (LPCWSTR)L"H";
LPCWSTR    cszColon = (LPCWSTR)L":";
LPCWSTR    cszDoubleQuote = (LPCWSTR)L"\"";

LPCSTR     caszPoundSign = "#";
LPCSTR     caszSplat = "*";
LPCSTR     caszSlash = "/";
LPCSTR     caszBackSlash = "\\";
LPCSTR     caszDoubleBackSlash = "\\\\";
LPCSTR     caszLeftParen = "(";
LPCSTR     caszRightParen = ")";
LPCSTR     caszSpace = " ";

LPCWSTR    cszDoubleBackSlash = (LPCWSTR)L"\\\\";
LPCWSTR    cszDoubleBackSlashDot = (LPCWSTR)L"\\\\.";
LPCWSTR    cszRightParenBackSlash = (LPCWSTR)L")\\";

// other general strings
LPCWSTR    cszSpacer = (LPCWSTR)L" - ";
LPCWSTR    cszBlg = (LPCWSTR)L"blg";

// strings only used in DEBUG builds
#ifdef _DEBUG
LPCWSTR    cszNameDontMatch = (LPCWSTR)L"Last Machine Name does not match the current selection";
LPCWSTR    cszNotice = (LPCWSTR)L"Notice!";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\qutils.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    qutils.c

Abstract:

    Query management utility functions

--*/

#include <windows.h>
#include <assert.h>
#include <pdh.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "pdhmsg.h"
#include "strings.h"
#include "log_bin.h"
#include "log_wmi.h"
#include "perftype.h"
#include "perfdata.h"

BOOL
IsValidQuery (
    IN  HQUERY  hQuery
)
{
    BOOL    bReturn = FALSE;    // assume it's not a valid query
    PPDHI_QUERY  pQuery;
#if DBG
    LONG    lStatus = ERROR_SUCCESS;
#endif

    __try {
        if (hQuery != NULL) {
            // see if a valid signature
            pQuery = (PPDHI_QUERY)hQuery;
            if ((*(DWORD *)&pQuery->signature[0] == SigQuery) &&
                 (pQuery->dwLength == sizeof (PDHI_QUERY))){
                bReturn = TRUE;
            } else {
                // this is not a valid query because the sig is bad
            }
        } else {
            // this is not a valid query because the handle is NULL
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
#if DBG
        lStatus = GetExceptionCode();
#endif
    }
    return bReturn;
}

BOOL
AddMachineToQueryLists (
    IN  PPERF_MACHINE   pMachine,
    IN  PPDHI_COUNTER   pNewCounter
)
{
    BOOL                    bReturn = FALSE; // assume failure
    PPDHI_QUERY             pQuery;
    PPDHI_QUERY_MACHINE     pQMachine;
    PPDHI_QUERY_MACHINE     pLastQMachine;

    pQuery = pNewCounter->pOwner;

    if (IsValidQuery(pQuery)) {
        assert (!(pQuery->dwFlags & PDHIQ_WBEM_QUERY));
        if (pQuery->pFirstQMachine != NULL) {
            // look for machine in list
            pLastQMachine = pQMachine = pQuery->pFirstQMachine;
            while (pQMachine != NULL) {
                if (pQMachine->pMachine == pMachine) {
                    // found the machine already in the list so continue
                    bReturn = TRUE;
                    break;
                } else {
                    pLastQMachine = pQMachine;
                    pQMachine = pQMachine->pNext;
                }
            }
            if (pQMachine == NULL) {
                // add this machine to the end of the list
                pQMachine = G_ALLOC (
                    (sizeof (PDHI_QUERY_MACHINE) +
                     (sizeof (WCHAR) * MAX_PATH)));
                if (pQMachine != NULL) {
                    pQMachine->pMachine = pMachine;
                    pQMachine->szObjectList = (LPWSTR)(&pQMachine[1]);
                    pQMachine->pNext = NULL;
                    pQMachine->lQueryStatus = pMachine->dwStatus;
                    pQMachine->llQueryTime = 0;
                    bReturn = TRUE;

                    // the pPerfData pointer will be tested prior to usage
                    pQMachine->pPerfData = G_ALLOC (MEDIUM_BUFFER_SIZE);
                    if (pQMachine->pPerfData == NULL) {
                        G_FREE(pQMachine);
                        pQMachine = NULL;
                        bReturn = FALSE;
                        SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
                    }
                    else {
                        pLastQMachine->pNext = pQMachine;
                    }
                } else {
                    // unable to alloc memory block so machine cannot
                    // be added
                    SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
                }
            }
        } else {
            // add this as the first machine
            pQMachine = G_ALLOC (
                (sizeof (PDHI_QUERY_MACHINE) +
                    (sizeof (WCHAR) * MAX_PATH)));
            if (pQMachine != NULL) {
                pQMachine->pMachine = pMachine;
                pQMachine->szObjectList = (LPWSTR)(&pQMachine[1]);
                pQMachine->pNext = NULL;
                pQMachine->lQueryStatus = pMachine->dwStatus;
                pQMachine->llQueryTime = 0;
                bReturn = TRUE;

                // the pPerfData pointer will be tested prior to usage
                pQMachine->pPerfData = G_ALLOC (MEDIUM_BUFFER_SIZE);
                if (pQMachine->pPerfData == NULL) {
                    G_FREE(pQMachine);
                    pQMachine = NULL;
                    bReturn = FALSE;
                    SetLastError(PDH_MEMORY_ALLOCATION_FAILURE);
                }
                else {
                    pQuery->pFirstQMachine = pQMachine;
                }
            } else {
                // unable to alloc memory block so machine cannot
                // be added
               SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            }
        }
        // here pQMachine should be the pointer to the correct machine
        // entry or NULL if unable to create
        if (pQMachine != NULL) {
            assert (bReturn == TRUE);
            // save the new pointer
            pNewCounter->pQMachine = pQMachine;

            // increment reference count for this machine
            pMachine->dwRefCount++;

            // update query perf. object list
            AppendObjectToValueList (pNewCounter->plCounterInfo.dwObjectId,
                pQMachine->szObjectList);
        }
    } else {
        SetLastError (PDH_INVALID_HANDLE);
        bReturn = FALSE;
    }

    return bReturn;
}

extern PDH_FUNCTION
PdhiGetBinaryLogCounterInfo (
    IN  PPDHI_LOG       pLog,
    IN  PPDHI_COUNTER   pCounter
);

PDH_FUNCTION
PdhiGetCounterFromDataBlock(
    IN PPDHI_LOG          pLog,
    IN PVOID              pDataBuffer,
    IN PPDHI_COUNTER      pCounter)
{
    PDH_STATUS        pdhStatus    = ERROR_SUCCESS;
    PERFLIB_COUNTER * pPerfCounter = & pCounter->plCounterInfo;
    PPDH_RAW_COUNTER  pRawValue    = & pCounter->ThisValue;
    WCHAR             szCompositeInstance[1024];
    DWORD             dwDataItemIndex;
    LPWSTR            szThisInstanceName;

    PPDHI_BINARY_LOG_RECORD_HEADER  pThisMasterRecord;
    PPDHI_BINARY_LOG_RECORD_HEADER  pThisSubRecord;

    PPDHI_RAW_COUNTER_ITEM_BLOCK    pDataBlock;
    PPDHI_RAW_COUNTER_ITEM          pDataItem;
    PPDH_RAW_COUNTER                pRawItem;

    PPERF_DATA_BLOCK                pPerfData;
    FILETIME                        ftDataBlock;
    FILETIME                        ftGmtDataBlock;
    LONGLONG                        TimeStamp;

    memset(pRawValue, 0, sizeof(PDH_RAW_COUNTER));
    pThisMasterRecord = (PPDHI_BINARY_LOG_RECORD_HEADER) pDataBuffer;
    assert (pThisMasterRecord->dwType == BINLOG_TYPE_DATA);
    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord,
                                      pCounter->dwIndex);

    if (pThisSubRecord != NULL) {
        if (pThisSubRecord->dwType == BINLOG_TYPE_DATA_PSEUDO) {
            PDH_STATUS Status     = ERROR_SUCCESS;
            DWORD      dwOriginal = pCounter->dwIndex;
            DWORD      dwPrevious;

            while (Status == ERROR_SUCCESS && pThisSubRecord) {
                if (pThisSubRecord->dwType != BINLOG_TYPE_DATA_PSEUDO) {
                    break;
                }
                dwPrevious = pCounter->dwIndex;
                Status     = PdhiGetBinaryLogCounterInfo(pLog, pCounter);
                if (   Status == ERROR_SUCCESS
                    && dwPrevious != pCounter->dwIndex) {
                    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord,
                                                      pCounter->dwIndex);
                }
            }
            if (   pThisSubRecord == NULL
                || Status == PDH_ENTRY_NOT_IN_LOG_FILE) {
                pCounter->dwIndex = 0;
                do {
                    dwPrevious = pCounter->dwIndex;
                    Status     = PdhiGetBinaryLogCounterInfo(pLog, pCounter);
                    if (   Status == ERROR_SUCCESS
                        && dwPrevious != pCounter->dwIndex) {
                        pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord,
                                                          pCounter->dwIndex);
                    }
                    if (pThisSubRecord->dwType != BINLOG_TYPE_DATA_PSEUDO) {
                        break;
                    }
                }
                while (   Status == ERROR_SUCCESS
                       && pCounter->dwIndex < dwOriginal
                       && pThisSubRecord);
                if (   pThisSubRecord == NULL
                    || pCounter->dwIndex >= dwOriginal) {
                    Status = PDH_ENTRY_NOT_IN_LOG_FILE;
                }
            }
            if (Status == PDH_ENTRY_NOT_IN_LOG_FILE) {
                    pCounter->dwIndex = dwOriginal;
                    pThisSubRecord = PdhiGetSubRecord(pThisMasterRecord,
                                                      pCounter->dwIndex);
            }
        }
    }
    if (pLog->pLastRecordRead != pDataBuffer) {
        pLog->pLastRecordRead = pDataBuffer;
    }

    if (pThisSubRecord != NULL) {
        switch (pThisSubRecord->dwType) {
        case BINLOG_TYPE_DATA_LOC_OBJECT:
        case BINLOG_TYPE_DATA_OBJECT:
            pPerfData = (PPERF_DATA_BLOCK) ((LPBYTE)pThisSubRecord +
                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
            if (pThisSubRecord->dwType == BINLOG_TYPE_DATA_OBJECT) {
                SystemTimeToFileTime(& pPerfData->SystemTime, & ftGmtDataBlock);
                FileTimeToLocalFileTime(& ftGmtDataBlock, & ftDataBlock);
            }
            else {
                SystemTimeToFileTime(& pPerfData->SystemTime, & ftDataBlock);
            }
            TimeStamp = MAKELONGLONG(ftDataBlock.dwLowDateTime,
                                     ftDataBlock.dwHighDateTime);
            if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                UpdateMultiInstanceCounterValue(pCounter, pPerfData, TimeStamp);
            }
            else {
                UpdateCounterValue(pCounter, pPerfData);
                pCounter->ThisValue.TimeStamp = ftDataBlock;
            }
            break;

        case BINLOG_TYPE_DATA_PSEUDO:
        case BINLOG_TYPE_DATA_SINGLE:
            pRawItem = (PPDH_RAW_COUNTER) ((LPBYTE)pThisSubRecord +
                        sizeof (PDHI_BINARY_LOG_RECORD_HEADER));
            RtlCopyMemory(pRawValue, pRawItem, sizeof (PDH_RAW_COUNTER));
            pdhStatus = ERROR_SUCCESS;
            break;

        case BINLOG_TYPE_DATA_MULTI:
            if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                // this is a wild card query
                //
                ULONG i;
                ULONG CopySize = pThisSubRecord->dwLength
                               - sizeof(PDHI_BINARY_LOG_RECORD_HEADER);
                PPDHI_RAW_COUNTER_ITEM_BLOCK pNewBlock = G_ALLOC(CopySize);

                if (pNewBlock == NULL) {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
                else if (pCounter->pThisRawItemList != NULL) {
                    if (pCounter->pLastRawItemList != NULL) {
                        G_FREE(pCounter->pLastRawItemList);
                    }
                    pCounter->pLastRawItemList = pCounter->pThisRawItemList;
                }
                pCounter->pThisRawItemList = pNewBlock;
                RtlCopyMemory(pNewBlock,
                              (  ((LPBYTE) pThisSubRecord)
                               + sizeof(PDHI_BINARY_LOG_RECORD_HEADER)),
                              CopySize);
                assert(CopySize == pNewBlock->dwLength);
            }
            else if (pPerfCounter->szInstanceName != NULL) {
                DWORD dwInstanceId = pCounter->pCounterPath->dwIndex;
                if (pPerfCounter->szParentInstanceName != NULL) {
                    lstrcpyW(szCompositeInstance,
                             pPerfCounter->szParentInstanceName);
                    lstrcatW(szCompositeInstance, cszSlash);
                    lstrcatW(szCompositeInstance, pPerfCounter->szInstanceName);
                }
                else {
                    lstrcpyW(szCompositeInstance, pPerfCounter->szInstanceName);
                }

                pDataBlock = (PPDHI_RAW_COUNTER_ITEM_BLOCK)
                          (  (LPBYTE) pThisSubRecord
                           + sizeof (PDHI_BINARY_LOG_RECORD_HEADER));

                pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
                pRawValue->CStatus = PDH_CSTATUS_NO_INSTANCE;

                for (dwDataItemIndex = 0;
                     dwDataItemIndex < pDataBlock->dwItemCount;
                     dwDataItemIndex++) {
                    pDataItem = &pDataBlock->pItemArray[dwDataItemIndex];
                    szThisInstanceName = (LPWSTR)
                                      (  (LPBYTE) pDataBlock
                                       + (DWORD_PTR)pDataItem->szName);
                    if (lstrcmpiW(szThisInstanceName,
                                  szCompositeInstance) == 0) {
                        if (dwInstanceId == 0) {
                            pdhStatus              = ERROR_SUCCESS;
                            pRawValue->CStatus     = pDataBlock->CStatus;
                            pRawValue->TimeStamp   = pDataBlock->TimeStamp;
                            pRawValue->FirstValue  = pDataItem->FirstValue;
                            pRawValue->SecondValue = pDataItem->SecondValue;
                            pRawValue->MultiCount  = pDataItem->MultiCount;
                            break;
                        }
                        else {
                            dwInstanceId --;
                        }
                    }
                }
            }
            else {
                pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
                pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
            }
            break;

        default:
            pdhStatus          = PDH_LOG_TYPE_NOT_FOUND;
            pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
            break;
        }
    }
    else {
        pdhStatus          = PDH_ENTRY_NOT_IN_LOG_FILE;
        pRawValue->CStatus = PDH_CSTATUS_INVALID_DATA;
    }

    return pdhStatus;
}

LONG
GetQueryPerfData (
    IN  PPDHI_QUERY         pQuery,
    IN  LONGLONG            *pTimeStamp
)
{
    LONG                lStatus = PDH_INVALID_DATA;
    PPDHI_COUNTER       pCounter;
    PPDHI_QUERY_MACHINE pQMachine;
    LONGLONG            llCurrentTime;
    LONGLONG            llTimeStamp = 0;
    BOOLEAN             bCounterCollected = FALSE;
    BOOL                bLastLogEntry;

    if (pQuery->hLog == H_REALTIME_DATASOURCE) {
        FILETIME LocFileTime;

        // this is a real-time query so
        // get the current data from each of the machines in the query
        //  (after this "sequential" approach is perfected, then the
        //  "parallel" approach of multiple threads can be developed
        //
        // get time stamp now so each machine will have the same time
        GetSystemTimeAsFileTime(& LocFileTime);
        llTimeStamp = MAKELONGLONG(LocFileTime.dwLowDateTime,
                                   LocFileTime.dwHighDateTime);

        assert (!(pQuery->dwFlags & PDHIQ_WBEM_QUERY));
        //
        pQMachine = pQuery->pFirstQMachine;
        while (pQMachine != NULL) {
            pQMachine->llQueryTime = llTimeStamp;

            lStatus = ValidateMachineConnection (pQMachine->pMachine);
            if (lStatus == ERROR_SUCCESS) {
                // machine is connected so get data

                lStatus = GetSystemPerfData (
                    pQMachine->pMachine->hKeyPerformanceData,
                    &pQMachine->pPerfData,
                    pQMachine->szObjectList,
                    FALSE); // never query the costly data objects as a group
                // save the machine's last status

                pQMachine->pMachine->dwStatus = lStatus;
                // if there was an error in the data collection,
                // set the retry counter and wait to try again.
                if (lStatus != ERROR_SUCCESS) {
                    GetLocalFileTime (&llCurrentTime);
                    pQMachine->pMachine->llRetryTime =
                        llCurrentTime + RETRY_TIME_INTERVAL;
                }

            }
            pQMachine->lQueryStatus = lStatus;
            // get next machine in query
            pQMachine = pQMachine->pNext;
        }
        // now update the counters using this new data
        if ((pCounter = pQuery->pCounterListHead) != NULL) {
            DWORD dwCollected = 0;
            do {
                if (pCounter->dwFlags & PDHIC_COUNTER_OBJECT) {
                    if (UpdateCounterObject(pCounter)) {
                        dwCollected ++;
                    }
                }
                else if (pCounter->dwFlags & PDHIC_MULTI_INSTANCE) {
                    if (UpdateRealTimeMultiInstanceCounterValue (pCounter)) {
                        dwCollected ++;
                    }
                } else {
                    // update single instance counter values
                    if (UpdateRealTimeCounterValue(pCounter)) {
                        dwCollected ++;
                    }
                }
                pCounter = pCounter->next.flink;
            } while (pCounter != NULL && pCounter != pQuery->pCounterListHead);
            lStatus = (dwCollected > 0) ? ERROR_SUCCESS : PDH_NO_DATA;
        } else {
            // no counters in the query  (?!)
            lStatus = PDH_NO_DATA;
        }
    } else {
        // read data from log file
        // get the next log record entry and update the
        // corresponding counter entries
        PPDHI_LOG pLog = NULL;
        DWORD dwLogType = 0;

        __try {
            pLog      = (PPDHI_LOG) (pQuery->hLog);
            dwLogType = LOWORD(pLog->dwLogFormat);
            lStatus   = ERROR_SUCCESS;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pQuery->dwLastLogIndex = (ULONG)-1;
            lStatus                = PDH_INVALID_HANDLE;
        }

        if (lStatus == ERROR_SUCCESS) {
            if (dwLogType == PDH_LOG_TYPE_BINARY) {
                if (pQuery->dwLastLogIndex == 0) {
                    lStatus = PdhiReadTimeWmiRecord(
                            pLog,
                            * (ULONGLONG *) & pQuery->TimeRange.StartTime,
                            NULL,
                            0);
                    pQuery->dwLastLogIndex = BINLOG_FIRST_DATA_RECORD;
                }
                else {
                    lStatus = PdhiReadNextWmiRecord(pLog, NULL, 0, TRUE);
                }

                if (lStatus != ERROR_SUCCESS && lStatus != PDH_MORE_DATA) {
                    pQuery->dwLastLogIndex = (DWORD) -1;
                }
                else {
                    pQuery->dwLastLogIndex --;
                }
            } else if (pQuery->dwLastLogIndex == 0) {
                // then the first matching entry needs to be
                // located in the log file
                lStatus = PdhiGetMatchingLogRecord (
                            pQuery->hLog,
                            (LONGLONG *)&pQuery->TimeRange.StartTime,
                            &pQuery->dwLastLogIndex);
                if (lStatus != ERROR_SUCCESS) {
                    // the matching time entry wasn't found in the log
                    pQuery->dwLastLogIndex = (DWORD) -1;
                } else {
                    // decrement the index so it can be incremented
                    // below. 0 is not a valid entry so there's no
                    // worry about -1 being attempted accidently.
                    pQuery->dwLastLogIndex--;
                }
            } else {
                // not WMI and not a time record no positioning required
            }

            if (pQuery->dwLastLogIndex != (DWORD)-1) {
                bLastLogEntry = FALSE;
                pQuery->dwLastLogIndex++;   // go to next entry
                if ((pCounter = pQuery->pCounterListHead) != NULL) {
                    DWORD dwCounter = 0;
                    do {
                        if (dwLogType == PDH_LOG_TYPE_BINARY) {
                            // save current value as last value since we are getting
                            // a new one, hopefully.
                            pCounter->LastValue = pCounter->ThisValue;
                            lStatus = PdhiGetCounterFromDataBlock(
                                    pLog,
                                    pLog->pLastRecordRead,
                                    pCounter);
                        }
                        else {
                            lStatus = PdhiGetCounterValueFromLogFile(
                                    pQuery->hLog,
                                    pQuery->dwLastLogIndex,
                                    pCounter);
                        }

                        if (lStatus != ERROR_SUCCESS) {
                            // see if this is because there's no more entries
                            if (lStatus == PDH_NO_MORE_DATA) {
                                bLastLogEntry = TRUE;
                                break;
                            }
                        } else {
                            // single entry or multiple entries
                            //
                            if (pCounter->ThisValue.CStatus == PDH_CSTATUS_VALID_DATA) {
                                llTimeStamp = MAKELONGLONG(
                                        pCounter->ThisValue.TimeStamp.dwLowDateTime,
                                        pCounter->ThisValue.TimeStamp.dwHighDateTime);
                                if (llTimeStamp > (pQuery->TimeRange.EndTime)) {
                                    lStatus = PDH_NO_MORE_DATA;
                                    bLastLogEntry = TRUE;
                                    break;
                                }
                                dwCounter ++;
                            }
                            bCounterCollected = TRUE;
                        }
                        // go to next counter in list
                        pCounter = pCounter->next.flink;
                    } while (pCounter != NULL && pCounter != pQuery->pCounterListHead);

                    if (bLastLogEntry){
                        lStatus = PDH_NO_MORE_DATA;
                    }
                    else if (dwCounter == 0) {
                        lStatus = PDH_NO_DATA;
                    }
                    else if (bCounterCollected) {
                        lStatus = ERROR_SUCCESS;
                    }
                } else {
                    // no counters in the query  (?!)
                    lStatus = PDH_NO_DATA;
                }
            } else {
                // all samples in the requested time frame have
                // been returned.
                lStatus = PDH_NO_MORE_DATA;
            }
        }
    }
    *pTimeStamp = llTimeStamp;
    return lStatus;
}

DWORD
WINAPI
PdhiAsyncTimerThreadProc (
    LPVOID  pArg
)
{
    PPDHI_QUERY     pQuery;
    DWORD           dwMsWaitTime;
    PDH_STATUS      Status;
    FILETIME        ftStart;
    FILETIME        ftStop;
    LONGLONG        llAdjustment;
    DWORD           dwInterval;
    LONG            lStatus = ERROR_SUCCESS;
    LONGLONG        llTimeStamp;

    pQuery = (PPDHI_QUERY)pArg;

    dwInterval =
        dwMsWaitTime = pQuery->dwInterval * 1000; // convert sec. to mS.

    // wait for timeout or exit event, then update the specified query
    while ((lStatus = WaitForSingleObject (pQuery->hExitEvent, dwMsWaitTime)) != WAIT_OBJECT_0) {
        // time out elapsed so get new sample.
        GetSystemTimeAsFileTime (&ftStart);
        lStatus = WAIT_FOR_AND_LOCK_MUTEX(pQuery->hMutex);

        if (lStatus == ERROR_SUCCESS) {

            if (pQuery->dwFlags & PDHIQ_WBEM_QUERY) {
                Status = GetQueryWbemData (pQuery, &llTimeStamp);
            } else {
                Status = GetQueryPerfData (pQuery, &llTimeStamp);
            }

            SetEvent (pQuery->hNewDataEvent);

            RELEASE_MUTEX(pQuery->hMutex);
            GetSystemTimeAsFileTime (&ftStop);
            llAdjustment = *(LONGLONG *)&ftStop;
            llAdjustment -= *(LONGLONG *)&ftStart;
            llAdjustment += 5000;   // for rounding
            llAdjustment /= 10000;  // convert 100ns Units to ms

            if (dwInterval > llAdjustment) {
                dwMsWaitTime = dwInterval -
                    (DWORD)(llAdjustment & 0x00000000FFFFFFFF);
            } else {
                dwMsWaitTime = 0; // overdue so do it now.
            }
        }
    }

    return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhdll\perfutil.c ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    Performance registry interface functions

--*/

#include <windows.h>
#include <pdh.h>
#include <stdlib.h>
#include <stdio.h>
#include "pdhitype.h"
#include "pdhidef.h"
#include "perfdata.h"
#include "perftype.h"
#include "pdhmsg.h"
#include "strings.h"

DWORD
PdhiMakePerfLangId(
    IN  LANGID  lID,
    OUT LPWSTR  szBuffer
);

PPERF_MACHINE
PdhiAddNewMachine (
    IN  PPERF_MACHINE   pLastMachine,
    IN  LPWSTR          szMachineName
);

PPERF_MACHINE   pFirstMachine = NULL;

PDH_STATUS
ConnectMachine (
    PPERF_MACHINE   pThisMachine
)
{
    PDH_STATUS  pdhStatus;
    LONG        lStatus = ERROR_SUCCESS;
    LONGLONG    llCurrentTime;
    WCHAR       szOsVer[8];
    HKEY        hKeyRemMachine;
    HKEY        hKeyRemCurrentVersion;
    DWORD       dwBufSize;
    DWORD       dwType;
    BOOL        bUpdateRetryTime = FALSE;
    DWORD       dwReconnecting;

    if (pThisMachine == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pThisMachine->hMutex);
    }

    if (pdhStatus == ERROR_SUCCESS) {
    // connect to system's performance registry
        if (lstrcmpiW(pThisMachine->szName, szStaticLocalMachineName) == 0) {
            // only one thread at a time can try to connect to a machine.

            pThisMachine->dwRefCount++;

            // assign default OS version
            // assume NT4 unless found otherwise
            lstrcpyW (pThisMachine->szOsVer, (LPCWSTR)L"4.0");   
            // this is the local machine so use the local reg key
            pThisMachine->hKeyPerformanceData = HKEY_PERFORMANCE_DATA;

            // look up the OS version and save it
            lStatus = RegOpenKeyExW (
                HKEY_LOCAL_MACHINE,
                cszCurrentVersionKey,
                0L,
                KEY_READ,
                &hKeyRemCurrentVersion);

            if (lStatus == ERROR_SUCCESS) {
                dwType=0;
                dwBufSize = sizeof (szOsVer);
                lStatus = RegQueryValueExW (
                    hKeyRemCurrentVersion,
                    cszCurrentVersionValueName,
                    0L,
                    &dwType,
                    (LPBYTE)&szOsVer[0],
                    &dwBufSize);
                if ((lStatus == ERROR_SUCCESS) && (dwType == REG_SZ)) {
                    lstrcpyW(pThisMachine->szOsVer, szOsVer);
                }
                RegCloseKey (hKeyRemCurrentVersion);
            }
        } else {
            // now try to connect if the retry timeout has elapzed
            GetLocalFileTime (&llCurrentTime);
            dwReconnecting = (DWORD)InterlockedCompareExchange (
                            (PLONG)&pThisMachine->dwRetryFlags, TRUE, FALSE);
            if (!dwReconnecting) {
               if ((pThisMachine->llRetryTime == 0) || (pThisMachine->llRetryTime < llCurrentTime)) {
                    // only one thread at a time can try to connect to a machine.

                    pThisMachine->dwRefCount++;

                    bUpdateRetryTime = TRUE; // only update after an attempt has been made

                    __try {
                        // close any open keys
                        if (pThisMachine->hKeyPerformanceData != NULL) {
                            RegCloseKey (pThisMachine->hKeyPerformanceData);
                            pThisMachine->hKeyPerformanceData = NULL;
                        }
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        lStatus = GetExceptionCode();
                    }

                    if (lStatus != ERROR_SUCCESS) {
                        pThisMachine->hKeyPerformanceData = NULL;
                    } else {
                        // get OS version of remote machine
                        lStatus = RegConnectRegistryW (
                            pThisMachine->szName,
                            HKEY_LOCAL_MACHINE,
                            &hKeyRemMachine);
                        if (lStatus == ERROR_SUCCESS) {
                            // look up the OS version and save it
                            lStatus = RegOpenKeyExW (
                                hKeyRemMachine,
                                cszCurrentVersionKey,
                                0L,
                                KEY_READ,
                                &hKeyRemCurrentVersion);
                            if (lStatus == ERROR_SUCCESS) {
                                dwType=0;
                                dwBufSize = sizeof (szOsVer);
                                lStatus = RegQueryValueExW (
                                    hKeyRemCurrentVersion,
                                    cszCurrentVersionValueName,
                                    0L,
                                    &dwType,
                                    (LPBYTE)&szOsVer[0],
                                    &dwBufSize);
                                if ((lStatus == ERROR_SUCCESS) && (dwType == REG_SZ)) {
                                    lstrcpyW(pThisMachine->szOsVer, szOsVer);
                                }
                                RegCloseKey (hKeyRemCurrentVersion);
                            }
                     
                            RegCloseKey (hKeyRemMachine);
                        }
                    }

                    if (lStatus == ERROR_SUCCESS) {
                        __try {
                            // Connect to remote registry
                            lStatus = RegConnectRegistryW (
                                pThisMachine->szName,
                                HKEY_PERFORMANCE_DATA,
                                &pThisMachine->hKeyPerformanceData);
                        } __except (EXCEPTION_EXECUTE_HANDLER) {
                            lStatus = GetExceptionCode();
                        }
                    } // else pass error through
                } else {
                   // not time to reconnect yet so save the old status and 
                   // clear the registry key
                    pThisMachine->hKeyPerformanceData = NULL;
                    lStatus = pThisMachine->dwStatus;
                }
                 // clear the reconnecting flag
                InterlockedExchange ((LONG *)&pThisMachine->dwRetryFlags, FALSE);
            } else {
                // some other thread is trying to connect
                return (PDH_CANNOT_CONNECT_MACHINE);
            }
        }

        if ((pThisMachine->hKeyPerformanceData != NULL) && (pThisMachine->dwRetryFlags == 0)) {
            // successfully connected to computer's registry, so
            // get the performance names from that computer and cache them
    /*
            the shortcut of mapping local strings cannot be used reliably until
            more synchronization of the mapped file is implemented. Just Mapping
            to the file and not locking it or checking for updates leaves it
            vulnerable to the mapped file being changed by an external program 
            and invalidating the pointer table built by the BuildLocalNameTable
            function.

            Until this synchronization and locking is implemented, the 
            BuildLocalNameTable function should not be used.
    */
            if (pThisMachine->hKeyPerformanceData != HKEY_PERFORMANCE_DATA) {
                if (pThisMachine->szPerfStrings != NULL) {
                    // reload the perf strings, incase new ones have been
                    // installed
                    if (   pThisMachine->sz009PerfStrings != NULL
                        && pThisMachine->sz009PerfStrings != pThisMachine->szPerfStrings) {
                        G_FREE(pThisMachine->sz009PerfStrings);
                    }
                    if (pThisMachine->typePerfStrings) {
                        G_FREE(pThisMachine->typePerfStrings);
                    }
                    G_FREE (pThisMachine->szPerfStrings);
                    pThisMachine->sz009PerfStrings = NULL;
                    pThisMachine->typePerfStrings  = NULL;
                    pThisMachine->szPerfStrings    = NULL;
                }
                BuildNameTable(pThisMachine->szName,
                               GetUserDefaultUILanguage(),
                               pThisMachine);
                if (pThisMachine->szPerfStrings == NULL) {
                    BuildNameTable(pThisMachine->szName,
                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                   pThisMachine);
                }
            } else {
                if (pThisMachine->szPerfStrings != NULL) {
                    // reload the perf strings, incase new ones have been
                    // installed
                    if (   pThisMachine->sz009PerfStrings != NULL
                        && pThisMachine->sz009PerfStrings != pThisMachine->szPerfStrings) {
                        G_FREE(pThisMachine->sz009PerfStrings);
                    }
                    if (pThisMachine->typePerfStrings) {
                        G_FREE(pThisMachine->typePerfStrings);
                    }
                    G_FREE (pThisMachine->szPerfStrings);
                    pThisMachine->sz009PerfStrings = NULL;
                    pThisMachine->typePerfStrings  = NULL;
                    pThisMachine->szPerfStrings    = NULL;
                }
                BuildNameTable(NULL,
                               GetUserDefaultUILanguage(),
                               pThisMachine);
                if (pThisMachine->szPerfStrings == NULL) {
                    BuildNameTable(NULL,
                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                   pThisMachine);
                }
                pThisMachine->pLocalNameInfo = NULL;
            }

            if (pThisMachine->szPerfStrings != NULL) {
                pdhStatus = ERROR_SUCCESS;
                pThisMachine->dwStatus = ERROR_SUCCESS;
            } else {
                // unable to read system counter name strings
                pdhStatus = PDH_CANNOT_READ_NAME_STRINGS;
                memset (&pThisMachine->LastStringUpdateTime, 0, sizeof(pThisMachine->LastStringUpdateTime));
                pThisMachine->dwLastPerfString = 0;
                pThisMachine->dwStatus = PDH_CSTATUS_NO_MACHINE;
            }
        } else {
            // unable to connect to the specified machine
            pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
            // Set error to either 
            //  "PDH_CSTATUS_NO_MACHINE" if no connection could be made
            // or 
            //  PDH_ACCESS_DENIED if ERROR_ACCESS_DENIED status is returned
            // since if ERROR_ACCESS_DENIED is returned, then reconnection will
            // probably be futile.
            if ((lStatus == ERROR_ACCESS_DENIED) || (lStatus == PDH_ACCESS_DENIED)) {
                pThisMachine->dwStatus = PDH_ACCESS_DENIED;
            } else {
                pThisMachine->dwStatus = PDH_CSTATUS_NO_MACHINE;
            }
        }

        if (pdhStatus != ERROR_SUCCESS) {
            if (bUpdateRetryTime) {
                // this attempt didn't work so reset retry counter  to
                // wait some more for the machine to come back up.
                GetLocalFileTime (&llCurrentTime);
                pThisMachine->llRetryTime = llCurrentTime + llRemoteRetryTime;
            }
        } else {
            // clear the retry counter to allow function calls
            pThisMachine->llRetryTime = 0;
        }
        pThisMachine->dwRefCount--;
        RELEASE_MUTEX(pThisMachine->hMutex);
    }

    return pdhStatus;
}

PPERF_MACHINE
PdhiAddNewMachine (
    IN  PPERF_MACHINE   pLastMachine,
    IN  LPWSTR          szMachineName
)
{
    PPERF_MACHINE   pNewMachine = NULL;
    LPWSTR          szNameBuffer = NULL;
    PERF_DATA_BLOCK *pdbBuffer = NULL;
    LPWSTR          szIdList = NULL;
    DWORD           dwNameSize = 0;
    BOOL            bUseLocalName = TRUE;

    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    if (szMachineName != NULL) {
        if (*szMachineName != 0) {
            bUseLocalName = FALSE;
        }
    }

    if (bUseLocalName) {
        dwNameSize = lstrlenW (szStaticLocalMachineName);
    } else {
        dwNameSize = lstrlenW (szMachineName);
    }
    dwNameSize += 1;
    dwNameSize *= sizeof (WCHAR);

    pNewMachine = (PPERF_MACHINE) G_ALLOC(sizeof(PERF_MACHINE)
                + SMALL_BUFFER_SIZE + (sizeof(WCHAR) * (dwNameSize + 1)));
    if  (pNewMachine != NULL) {
        szIdList     = (LPWSTR) ((LPBYTE) pNewMachine + sizeof(PERF_MACHINE));
        szNameBuffer = (LPWSTR) ((LPBYTE) szIdList + SMALL_BUFFER_SIZE);

        pdbBuffer = G_ALLOC (LARGE_BUFFER_SIZE);
        if (pdbBuffer != NULL) {
       
            // initialize the new buffer
            pNewMachine->hKeyPerformanceData = NULL;
            pNewMachine->pLocalNameInfo = NULL;

            pNewMachine->szName = szNameBuffer;
            if (bUseLocalName) {
                lstrcpyW (pNewMachine->szName, szStaticLocalMachineName);
            } else {
                lstrcpyW (pNewMachine->szName, szMachineName);
            }

            pNewMachine->pSystemPerfData = pdbBuffer;

            pNewMachine->szPerfStrings    = NULL;
            pNewMachine->sz009PerfStrings = NULL;
            pNewMachine->typePerfStrings  = NULL;
            pNewMachine->dwLastPerfString = 0;

            pNewMachine->dwRefCount = 0;
            pNewMachine->szQueryObjects = szIdList;

            pNewMachine->dwStatus = PDH_CSTATUS_NO_MACHINE; // not connected yet
            pNewMachine->llRetryTime = 1;   // retry connection immediately
            pNewMachine->dwRetryFlags = 0;   // Not attempting a connection.
            pNewMachine->dwMachineFlags = 0;

            pNewMachine->hMutex = CreateMutex (NULL, FALSE, NULL);

            // everything went OK so far so add this entry to the list
            if (pLastMachine != NULL) {
                pNewMachine->pNext = pLastMachine->pNext;
                pLastMachine->pNext = pNewMachine;
                pNewMachine->pPrev = pLastMachine;
                pNewMachine->pNext->pPrev = pNewMachine;
            } else {
                // this is the first item in the list so it
                // points to itself
                pNewMachine->pNext = pNewMachine;
                pNewMachine->pPrev = pNewMachine;
            }
            return pNewMachine;
        } else {
            // unable to allocate perf data buffer
            SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
            // clean up and bail out.

            if (pNewMachine != NULL) {
                G_FREE (pNewMachine);
            }

            return NULL;
        }
    } else {
        // unable to allocate machine data memory
        SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
        // clean up and bail out.

        if (pNewMachine != NULL) {
            G_FREE (pNewMachine);
        }

        return NULL;
    }
}

PPERF_MACHINE
GetMachineW (
    IN     LPWSTR  szMachineName,
    IN     DWORD   dwFlags
)
{
    PPERF_MACHINE   pThisMachine = NULL;
    PPERF_MACHINE   pLastMachine;
    BOOL            bFound = FALSE;
    LPWSTR          szFnMachineName;
    BOOL            bNew = FALSE; // true if this is a new machine to the list
    BOOL            bUseLocalName = TRUE;
    DWORD           dwLocalStatus;

    // reset the last error value
    SetLastError (ERROR_SUCCESS);

    if (WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex) == ERROR_SUCCESS) {

        if (szMachineName != NULL) {
            if (*szMachineName != 0) {
                bUseLocalName = FALSE;
            }
        }

        if (bUseLocalName) {
            szFnMachineName = szStaticLocalMachineName;
        } else {
            szFnMachineName = szMachineName;
        }

        // walk down list to find this machine

        pThisMachine = pFirstMachine;
        pLastMachine = NULL;

        // walk around entire list
        if (pThisMachine != NULL) {
            do {
                // walk down the list and look for a match
                if (lstrcmpiW(szFnMachineName, pThisMachine->szName) != 0) {
                    pLastMachine = pThisMachine;
                    pThisMachine = pThisMachine->pNext;
                } else {
                    if (dwFlags & PDH_GM_UPDATE_NAME) {
                        if (szMachineName != NULL) {
                            // match found so update name string if a real string was passed in
                            lstrcpyW (szMachineName, pThisMachine->szName);
                        }
                    }
                    // and break     now
                    bFound = TRUE;
                    break;
                }
            } while (pThisMachine != pFirstMachine);
        }
        // if thismachine == the first machine, then we couldn't find a match in
        // the list, if this machine is NULL, then there is no list
        if (!bFound) {
            // then this machine was not found so add it.
            pThisMachine = PdhiAddNewMachine (
                pLastMachine,
                szFnMachineName);
            if (pThisMachine != NULL) {
                bNew = TRUE;
                if (pFirstMachine == NULL) {
                    // then update the first pointer
                    pFirstMachine = pThisMachine;
                }
            }
        }

        if (pThisMachine->dwThreadId != GetCurrentThreadId()) {
            dwFlags |= PDH_GM_UPDATE_PERFDATA;
            pThisMachine->dwThreadId = GetCurrentThreadId();
        }

        if ((pThisMachine != NULL) &&
            (((!bFound) || (dwFlags & PDH_GM_UPDATE_PERFDATA)) ||
             (pThisMachine->dwStatus != ERROR_SUCCESS))) {
            // then this is a new machine
            //  or
            // the caller wants the data refreshed
            //  or
            // the machine has an entry, but is not yet on line
            // first try to connect to the machine
            // the call to ConnectMachine updates the machine status
            // so there's no need to keep it here.
            if (ConnectMachine (pThisMachine) == ERROR_SUCCESS) {
                // connected to the machine so
                // then lock access to it
                // the caller of this function must release the mutex
                dwLocalStatus = WAIT_FOR_AND_LOCK_MUTEX (pThisMachine->hMutex);
                
                if (dwLocalStatus == ERROR_SUCCESS) {

                    // get the current system counter info
                    pThisMachine->dwStatus = GetSystemPerfData (
                        pThisMachine->hKeyPerformanceData,
                        &pThisMachine->pSystemPerfData,
                        (LPWSTR)cszGlobal,
                        (BOOL)(dwFlags & PDH_GM_READ_COSTLY_DATA)
                        );
                    if ((dwFlags & PDH_GM_READ_COSTLY_DATA) &&
                        (pThisMachine->dwStatus == ERROR_SUCCESS)) {
                        pThisMachine->dwMachineFlags |= PDHIPM_FLAGS_HAVE_COSTLY;
                    } else {
                        pThisMachine->dwMachineFlags &= ~PDHIPM_FLAGS_HAVE_COSTLY;
                    }
                    SetLastError (pThisMachine->dwStatus);
                } else {
                    pThisMachine = NULL;
                    SetLastError (WAIT_TIMEOUT);
                }

            } else {
                SetLastError (pThisMachine->dwStatus);
            }
        }

        if (pThisMachine != NULL) {
            // machine found so bump the ref count
            // NOTE!!! the caller must release this!!!
            pThisMachine->dwRefCount++;
        }

        // at this point if pThisMachine is NULL then it was not found, nor
        // could it be added otherwise it is pointing to the matching machine
        // structure

        RELEASE_MUTEX (hPdhDataMutex);
    } else {
        SetLastError (WAIT_TIMEOUT);
    }

    return pThisMachine;
}

BOOL
FreeMachine (
    PPERF_MACHINE   pMachine,
    BOOL            bForceRelease,
    BOOL            bProcessExit
)
{
    PPERF_MACHINE   pPrev;
    PPERF_MACHINE   pNext;
    HANDLE          hMutex;

    // unlink if this isn't the only one in the list

    if ((!bForceRelease) && (pMachine->dwRefCount)) return FALSE;

    hMutex = pMachine->hMutex;

    if (WAIT_FOR_AND_LOCK_MUTEX (hMutex) != ERROR_SUCCESS) {
        SetLastError(WAIT_TIMEOUT);
        return FALSE;
    }

    pPrev = pMachine->pPrev;
    pNext = pMachine->pNext;

    if ((pPrev != pMachine) && (pNext != pMachine)) {
        // this is not the only entry in the list
        pPrev->pNext = pNext;
        pNext->pPrev = pPrev;
        if (pMachine == pFirstMachine) {
            // then we are deleting the first one in the list so
            // update the list head to point to the next one in line
            pFirstMachine = pNext;
        }
    } else {
        // this is the only entry so clear the head pointer
        pFirstMachine = NULL;
    }

    // now free all allocated memory

    if (pMachine->pSystemPerfData != NULL) {
        G_FREE (pMachine->pSystemPerfData);
    }
    if (pMachine->typePerfStrings != NULL) {
        G_FREE (pMachine->typePerfStrings);
    }
    if (   pMachine->sz009PerfStrings != NULL
        && pMachine->sz009PerfStrings != pMachine->szPerfStrings) {
        G_FREE (pMachine->sz009PerfStrings);
    }
    if (pMachine->szPerfStrings != NULL) {
        G_FREE (pMachine->szPerfStrings);
    }

    // close key
    if (pMachine->hKeyPerformanceData != NULL) {
        if (   (! bProcessExit)
            || pMachine->hKeyPerformanceData != HKEY_PERFORMANCE_DATA) {
            RegCloseKey (pMachine->hKeyPerformanceData);
        }
        pMachine->hKeyPerformanceData = NULL;
    }

    // free memory block
    G_FREE (pMachine);

    // release and close mutex

    RELEASE_MUTEX (hMutex);

    if (hMutex != NULL) {
        CloseHandle (hMutex);
    }

    return TRUE;
}

BOOL
FreeAllMachines (
    BOOL bProcessExit
)
{
    PPERF_MACHINE pThisMachine;

    // free any machines in the machine list
    if (pFirstMachine != NULL) {

        if (WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex) == ERROR_SUCCESS) {

            pThisMachine = pFirstMachine;
            while (pFirstMachine != pFirstMachine->pNext) {
                // delete from list
                // the deletion routine updates the prev pointer as it
                // removes the specified entry.
                FreeMachine (pThisMachine->pPrev, TRUE, bProcessExit);
                if (pFirstMachine == NULL)
                    break;
            }
            // remove last query
            if (pFirstMachine)
                FreeMachine (pFirstMachine, TRUE, bProcessExit);
            pFirstMachine = NULL;

            RELEASE_MUTEX (hPdhDataMutex);
        } else {
            SetLastError (WAIT_TIMEOUT);
            return FALSE;
        }
    }

    return TRUE;

}

DWORD
GetObjectId (
    IN      PPERF_MACHINE   pMachine,
    IN      LPWSTR          szObjectName,
    IN      BOOL            *bInstances
)
{
    PERF_OBJECT_TYPE * pObject;

    pObject = GetObjectDefByName (
        pMachine->pSystemPerfData,
        pMachine->dwLastPerfString,
        pMachine->szPerfStrings,
        szObjectName);

    if (pObject != NULL) {
        // copy name string
        LPCWSTR szTmpObjectName = PdhiLookupPerfNameByIndex(
                                pMachine, pObject->ObjectNameTitleIndex);
        if (szObjectName != NULL && szTmpObjectName != NULL) {
            lstrcpyW (szObjectName, szTmpObjectName);
        }
        if (bInstances != NULL) {
            *bInstances = (pObject->NumInstances != PERF_NO_INSTANCES ? TRUE : FALSE);
        }
        return pObject->ObjectNameTitleIndex;
    } else {
        return (DWORD)-1;
    }
}

DWORD
GetCounterId (
    PPERF_MACHINE   pMachine,
    DWORD           dwObjectId,
    LPWSTR          szCounterName
)
{
    PERF_OBJECT_TYPE *pObject;
    PERF_COUNTER_DEFINITION *pCounter;

    pObject = GetObjectDefByTitleIndex(
        pMachine->pSystemPerfData,
        dwObjectId);

    if (pObject != NULL) {
        pCounter = GetCounterDefByName (
            pObject,
            pMachine->dwLastPerfString,
            pMachine->szPerfStrings,
            szCounterName);
        if (pCounter != NULL) {
            // update counter name string
            LPCWSTR szTmpCounterName = PdhiLookupPerfNameByIndex(
                                    pMachine, pCounter->CounterNameTitleIndex);
            if (szCounterName != NULL && szTmpCounterName != NULL) {
                lstrcpyW (szCounterName, szTmpCounterName);
            }
            return pCounter->CounterNameTitleIndex;
        } else {
            return (DWORD)-1;
        }
    } else {
        return (DWORD)-1;
    }
}

BOOL
InitPerflibCounterInfo (
    IN      PPDHI_COUNTER   pCounter
)
/*++

Routine Description:

    Initializes the perflib related fields of the counter structure

Arguments:

    IN      PPDHI_COUNTER   pCounter
        pointer to the counter structure to initialize

Return Value:

    TRUE

--*/
{
    PERF_OBJECT_TYPE        *pPerfObject    = NULL;
    PERF_COUNTER_DEFINITION *pPerfCounter   = NULL;

    if (pCounter->pQMachine->pMachine == NULL) {
        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_MACHINE;
        return FALSE;
    } else if (pCounter->pQMachine->pMachine->dwStatus != ERROR_SUCCESS) {
        // machine not initialized
        return FALSE;
    }

    // get perf object definition from system data structure
    pPerfObject = GetObjectDefByTitleIndex (
        pCounter->pQMachine->pMachine->pSystemPerfData,
        pCounter->plCounterInfo.dwObjectId);

    if (pPerfObject != NULL) {
        // object was found now look up counter definition
        pPerfCounter = GetCounterDefByTitleIndex (pPerfObject, 0,
            pCounter->plCounterInfo.dwCounterId);
        if (pPerfCounter != NULL) {
            // get system perf data info
            // (pack into a DWORD)
            pCounter->CVersion = pCounter->pQMachine->pMachine->pSystemPerfData->Version;
            pCounter->CVersion &= 0x0000FFFF;
            pCounter->CVersion <<= 16;
            pCounter->CVersion &= 0xFFFF0000;
            pCounter->CVersion |= (pCounter->pQMachine->pMachine->pSystemPerfData->Revision & 0x0000FFFF);

            // get the counter's time base
            if (pPerfCounter->CounterType & PERF_TIMER_100NS) {
                pCounter->TimeBase = (LONGLONG)10000000;
            } else if (pPerfCounter->CounterType & PERF_OBJECT_TIMER) {
                // then get the time base freq from the object
                pCounter->TimeBase = pPerfObject->PerfFreq.QuadPart;
            } else { // if (pPerfCounter->CounterType & PERF_TIMER_TICK or other)
                pCounter->TimeBase = pCounter->pQMachine->pMachine->pSystemPerfData->PerfFreq.QuadPart;
            }

            // look up info from counter definition
            pCounter->plCounterInfo.dwCounterType =
                pPerfCounter->CounterType;
            pCounter->plCounterInfo.dwCounterSize =
                pPerfCounter->CounterSize;

            pCounter->plCounterInfo.lDefaultScale =
                pPerfCounter->DefaultScale;

            //
            //  get explain text pointer
            pCounter->szExplainText =
                (LPWSTR)PdhiLookupPerfNameByIndex (
                    pCounter->pQMachine->pMachine,
                    pPerfCounter->CounterHelpTitleIndex);

            //
            //  now clear/initialize the raw counter info
            //
            pCounter->ThisValue.TimeStamp.dwLowDateTime = 0;
            pCounter->ThisValue.TimeStamp.dwHighDateTime = 0;
            pCounter->ThisValue.MultiCount = 1;
            pCounter->ThisValue.FirstValue = 0;
            pCounter->ThisValue.SecondValue = 0;
            //
            pCounter->LastValue.TimeStamp.dwLowDateTime = 0;
            pCounter->LastValue.TimeStamp.dwHighDateTime = 0;
            pCounter->LastValue.MultiCount = 1;
            pCounter->LastValue.FirstValue = 0;
            pCounter->LastValue.SecondValue = 0;
            //
            //  clear data array pointers
            //
            pCounter->pThisRawItemList = NULL;
            pCounter->pLastRawItemList = NULL;
            //
            //  lastly update status
            //
            if (pCounter->ThisValue.CStatus == 0)  {
                // don't overwrite any other status values
                pCounter->ThisValue.CStatus = PDH_CSTATUS_VALID_DATA;
            }
            return TRUE;
        } else {
            // unable to find counter
            pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_COUNTER;
            return FALSE;
        }
    } else {
        // unable to find object
        pCounter->ThisValue.CStatus = PDH_CSTATUS_NO_OBJECT;
        return FALSE;
    }
}

#pragma warning ( disable : 4127 )
STATIC_BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = SPACE_L;
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
#pragma warning ( default : 4127 )

BOOL
AppendObjectToValueList (
    DWORD   dwObjectId,
    PWSTR   pwszValueList
)
/*++

AppendObjectToValueList

Arguments:

    IN dwNumber
        DWORD number to insert in list

    IN PWSTR
        pointer to wide char string that contains buffer that is
        Null terminated, Space delimited list of decimal numbers that
        may have this number appended to.

Return Value:

    TRUE:
            dwNumber was added to list

    FALSE:
            dwNumber was not added. (because it's already there or
                an error occured)

--*/
{
    WCHAR           tempString [16] ;
    BOOL            bReturn = FALSE;
    LPWSTR          szFormatString;

    if (!pwszValueList) {
        bReturn = FALSE;
    } else if (IsNumberInUnicodeList(dwObjectId, pwszValueList)) {
        bReturn = FALSE;   // object already in list
    } else {
        __try {
            if (*pwszValueList == 0) {
                // then this is the first string so no delimiter
                szFormatString = (LPWSTR)fmtDecimal;
            } else {
                // this is being added to the end so include the delimiter
                szFormatString = (LPWSTR)fmtSpaceDecimal;
            }
            // format number and append the new object id the  value list
            swprintf (tempString, szFormatString, dwObjectId) ;
            lstrcatW (pwszValueList, tempString);
            bReturn = TRUE;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

BOOL
GetInstanceByNameMatch (
    IN      PPERF_MACHINE   pMachine,
    IN      PPDHI_COUNTER   pCounter
)
{
    PPERF_INSTANCE_DEFINITION   pInstanceDef;
    PPERF_OBJECT_TYPE           pObjectDef;

    LONG    lInstanceId = PERF_NO_UNIQUE_ID;

    // get the instances object

    pObjectDef = GetObjectDefByTitleIndex(
        pMachine->pSystemPerfData,
        pCounter->plCounterInfo.dwObjectId);

    if (pObjectDef != NULL) {
        pInstanceDef = FirstInstance (pObjectDef);

        if (pInstanceDef->UniqueID == PERF_NO_UNIQUE_ID) {
            // get instance in that object by comparing names
            // if there is no parent specified, then just look it up by name
            pInstanceDef = GetInstanceByName (
                    pMachine->pSystemPerfData,
                    pObjectDef,
                    pCounter->pCounterPath->szInstanceName,
                    pCounter->pCounterPath->szParentName,
                    pCounter->pCounterPath->dwIndex);
        } else {
            // get numeric equivalent of Instance ID
            if (pCounter->pCounterPath->szInstanceName != NULL) {
                lInstanceId = wcstol (
                    pCounter->pCounterPath->szInstanceName,
                    NULL, 10);
            }
            pInstanceDef = GetInstanceByUniqueId (
                    pObjectDef, lInstanceId);
        }

        // update counter fields
        pCounter->plCounterInfo.lInstanceId = lInstanceId;
        if (lInstanceId == -1) {
            // use instance NAME
//            GetInstanceNameStr (pInstanceDef,
//                pCounter->pCounterPath->szInstanceName,
//                pObjectDef->CodePage);
            pCounter->plCounterInfo.szInstanceName =
                pCounter->pCounterPath->szInstanceName;
            pCounter->plCounterInfo.szParentInstanceName =
                pCounter->pCounterPath->szParentName;
        } else {
            // use instance ID number
            pCounter->plCounterInfo.szInstanceName = NULL;
            pCounter->plCounterInfo.szParentInstanceName = NULL;
        }

        if (pInstanceDef != NULL) {
            // instance found
            return TRUE;
        } else {
            // unable to find instance
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

BOOL
GetObjectPerfInfo (
    IN      PPERF_DATA_BLOCK  pPerfData,
    IN      DWORD           dwObjectId,
    IN      LONGLONG        *pPerfTime,
    IN      LONGLONG        *pPerfFreq
)
{
    PERF_OBJECT_TYPE * pObject;
    BOOL                bReturn = FALSE;

    pObject = GetObjectDefByTitleIndex (pPerfData, dwObjectId);

    if (pObject != NULL) {
        __try {
            *pPerfTime = pObject->PerfTime.QuadPart;
            *pPerfFreq = pObject->PerfFreq.QuadPart;
            bReturn = TRUE;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            bReturn = FALSE;
        }
    }
    return bReturn;
}

PDH_STATUS
ValidateMachineConnection (
    IN  PPERF_MACHINE   pMachine
)
{
    PDH_STATUS  pdhStatus;
    HANDLE      hThread;
    DWORD       ThreadId;
    DWORD       dwWaitStatus;
    DWORD       dwReconnecting;
    LONGLONG    llCurrentTime;

    // if a connection or request has failed, this will be
    // set to an error status
    if (pMachine != NULL) {
        if (pMachine->dwStatus != ERROR_SUCCESS) {
            // get the current time
            GetLocalFileTime (&llCurrentTime);

            if (pMachine->llRetryTime < llCurrentTime) {
                if (pMachine->llRetryTime != 0) {
                    // see what's up by trying to reconnect
//                    dwReconnecting = (DWORD)InterlockedCompareExchange (
//                                    (PLONG)&pMachine->dwRetryFlags, TRUE, FALSE);
                    dwReconnecting = pMachine->dwRetryFlags;
                    if (!dwReconnecting) {
                        // start another thread to connect to the machine then
                        // wait for the thread to return. If it returns in time, then
                        // use it, otherwise indicate it's not available and continue
                        hThread = CreateThread (
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)ConnectMachine,
                            (LPVOID)pMachine,
                            0,
                            &ThreadId);

                        if (hThread != NULL) {
                            // wait for the thread to complete or the timeout to expire
                            dwWaitStatus = WaitForSingleObject (hThread, 500);
                            if (dwWaitStatus == WAIT_TIMEOUT) {
                                // then this is taking too long so set an error and
                                // continue. If the machine is off line, then the
                                // thread will eventually complete and the machine
                                // status will indicate that it's offline. If the
                                // machine connects after the timeout, it'll be
                                // picked up on the next scan.
                                pdhStatus = PDH_CSTATUS_NO_MACHINE;
                            } else {
                                // get the thread's exit code
                                GetExitCodeThread (hThread, (LPDWORD)&pdhStatus);
                            }
                            CloseHandle (hThread);
                        } else {
                            // unable to creat thread to connect to machine
                            // so return not available status
                            pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
                        }
                    } else {
                        // a connection attempt is in process so do nothing here
                        pdhStatus = PDH_CANNOT_CONNECT_MACHINE;
                    }
                } else {
                    // everything's fine
                    pdhStatus = ERROR_SUCCESS;
                }
            } else {
                // it's not retry time, yet so machine is off line still
                pdhStatus = PDH_CSTATUS_NO_MACHINE;
            }
        } else {
            // everything's fine
            pdhStatus = ERROR_SUCCESS;
        }
    } else {
        pdhStatus = PDH_CSTATUS_NO_MACHINE;
    }
    return pdhStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pdh\pdhlog\log.c ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Log file interface functions exposed in pdh.dll

--*/

#include <windows.h>
#ifndef _PRSHT_H_   // to eliminate W4 errors in commdlg.h
#define _PRSHT_H_ 
#endif      
#include <commdlg.h>
#include <stdlib.h>
#include <assert.h>
#include <mbctype.h>
#include <pdh.h>
#include "pdhidef.h"
//#include "pdhdlgs.h"
#include "strings.h"
#include "log_text.h"
#include "log_bin.h"
#include "log_sql.h"
#include "log_pm.h"
#include "log_wmi.h"
//#include "datasrc.h"
#include "resource.h"
#include "pdhmsg.h"

#pragma warning ( disable : 4213)

// note that when the log file headers are written
// they will be prefixed with a double quote character
LPCSTR  szTsvLogFileHeader =    "(PDH-TSV 4.0)";
LPCSTR  szCsvLogFileHeader =    "(PDH-CSV 4.0)";
LPCSTR  szBinLogFileHeader =    "(PDH-BIN 4.0)";
LPCSTR  szTsvType          =    "PDH-TSV";
LPCSTR  szCsvType          =    "PDH-CSV";
LPCSTR  szBinaryType       =    "PDH-BIN";

const DWORD   dwFileHeaderLength =    13;
const DWORD   dwTypeLoc =             2;
const DWORD   dwVersionLoc =          10;
const DWORD   dwFieldLength =         7;
const DWORD   dwPerfmonTypeLength =   5;    //size in chars

// max mapping size of headers for binary log files
#define PDH_LOG_HEADER_MAP_SIZE 8192

#define VALUE_BUFFER_SIZE   32

typedef struct  _FILE_FILTER_INFO {
    UINT    nDisplayTextResourceId;
    LPWSTR  szFilterText;
    DWORD   dwFilterTextSize;
} FILE_FILTER_INFO;
//
//  global variables
//
PPDHI_LOG   PdhiFirstLogEntry = NULL;
PPDHI_MAPPED_LOG_FILE   PdhipFirstLogFile = NULL;

FILE_FILTER_INFO    ffiLogFilterInfo[] = {
    {IDS_LOGTYPE_PDH_LOGS,  (LPWSTR)L"*.blg;*.csv;*.tsv",       17},
    {IDS_LOGTYPE_BIN_LOGS,  (LPWSTR)L"*.blg",                    5},
    {IDS_LOGTYPE_CSV_LOGS,  (LPWSTR)L"*.csv",                    5},
    {IDS_LOGTYPE_TSV_LOGS,  (LPWSTR)L"*.tsv",                    5},
    {IDS_LOGTYPE_PM_LOGS,   (LPWSTR)L"*.log",                    5},
    {IDS_LOGTYPE_ALL_LOGS,  (LPWSTR)L"*.blg;*.csv;*.tsv;*.log", 23},
    {IDS_LOGTYPE_ALL_FILES, (LPWSTR)L"*.*",                      4},
    {0, NULL, 0}
};

STATIC_DWORD
MakeLogFilterInfoString (
    LPWSTR  szLogFilter,
    DWORD   cchLogFilterSize
)
{
    FILE_FILTER_INFO    *pFFI;
    WCHAR               szThisEntry[512];

    LPWSTR  szDestPtr;
    LPWSTR  szEndPtr;
    DWORD   dwThisStringLen;

    szDestPtr = szLogFilter;
    szEndPtr = szDestPtr + cchLogFilterSize;
    pFFI = &ffiLogFilterInfo[0];

    while ((szEndPtr > szDestPtr) && (pFFI->szFilterText != NULL)) {
        dwThisStringLen = LoadStringW(ThisDLLHandle,
            pFFI->nDisplayTextResourceId,
            szThisEntry, (sizeof(szThisEntry)/sizeof(szThisEntry[0])));
        if ((szDestPtr + dwThisStringLen) < szEndPtr) {
            // add in this string
            lstrcpyW (szDestPtr, szThisEntry);
            szDestPtr += dwThisStringLen;
            // add in NULL
            *szDestPtr++ = 0;
        }
        dwThisStringLen = pFFI->dwFilterTextSize;
        if ((szDestPtr + dwThisStringLen) < szEndPtr) {
            // add in this string
            lstrcpyW (szDestPtr, pFFI->szFilterText);
            szDestPtr += dwThisStringLen;
            // add in NULL
            *szDestPtr++ = 0;
        }
        pFFI++;
    }
    if (szEndPtr > szDestPtr) {
        // add MSZ NULL
        *szDestPtr++ = 0;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }   
}
//
//  Internal  Logging utility functions
//
STATIC_DWORD
OpenReadonlyMappedFile (
    PPDHI_LOG               pLog,
    LPCWSTR                 szFileName,
    PPDHI_MAPPED_LOG_FILE * pFileEntry,
    DWORD                   dwLogType
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwStatus;
    DWORD       dwSize;
    PPDHI_MAPPED_LOG_FILE   pOpenedFile;
    WCHAR   szSectionName[MAX_PATH * 4];
    LPWSTR  szThisChar;
    DWORD   dwLoSize, dwHiSize;

    dwStatus = WaitForSingleObject (hPdhContextMutex, 10000);
    if (dwStatus  == WAIT_TIMEOUT) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (PdhipFirstLogFile == NULL) {
            // then there are no mapped files so create a new entry and 
            // fill it with this file
            pOpenedFile = NULL;
        } else {
            for (pOpenedFile = PdhipFirstLogFile;
                pOpenedFile != NULL;
                pOpenedFile = pOpenedFile->pNext) {
                if (lstrcmpiW (szFileName, pOpenedFile->szLogFileName) == 0) break;
            }
            // here pOpenedFile will either be NULL or a ponter
        }
        if (pOpenedFile == NULL) {
            // create a new entry
            dwSize = lstrlenW (szFileName) + 1;
            dwSize *= sizeof(WCHAR);
            dwSize = QWORD_MULTIPLE (dwSize);
            dwSize += sizeof (PDHI_MAPPED_LOG_FILE);

            pOpenedFile = (PPDHI_MAPPED_LOG_FILE)G_ALLOC (dwSize);
            if (pOpenedFile != NULL) {
                // initialize the pointers
                pOpenedFile->szLogFileName = (LPWSTR)&pOpenedFile[1];
                lstrcpyW (pOpenedFile->szLogFileName, szFileName);
                pOpenedFile->hFileHandle = CreateFileW (
                    pOpenedFile->szLogFileName,
                    GENERIC_READ,           // Read Access for input
                    FILE_SHARE_READ | FILE_SHARE_WRITE, // allow read sharing
                    NULL,                   // default security
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,  // ignored
                    NULL);                  // no template file

                if (pOpenedFile->hFileHandle != INVALID_HANDLE_VALUE) {
                    DWORD   dwPID;
                    dwPID = GetCurrentProcessId ();
                    swprintf (szSectionName, (LPCWSTR)L"%s_%8.8x_%s", 
                        cszLogSectionName, dwPID, pOpenedFile->szLogFileName);

                    // remove filename type characters 
                    for (szThisChar = &szSectionName[0]; *szThisChar != 0; szThisChar++) {
                        switch (*szThisChar) {
                            case L'\\':
                            case L':':
                            case L'.':
                                *szThisChar = L'_';
                                break;

                            default:
                                break;
                        }
                    }

                    dwLoSize = GetFileSize (
                        pOpenedFile->hFileHandle,
                        & dwHiSize);

                    pOpenedFile->llFileSize = dwHiSize;
                    pOpenedFile->llFileSize <<= 32;
                    pOpenedFile->llFileSize &= 0xFFFFFFFF00000000;
                    pOpenedFile->llFileSize += dwLoSize;

                    // just map the header for starters

                    if (pOpenedFile->llFileSize > 0) {
                        pLog->iRunidSQL = 0;
                        if (dwLogType == PDH_LOG_TYPE_RETIRED_BIN) {
                            pOpenedFile->hMappedFile = CreateFileMappingW(
                                            pOpenedFile->hFileHandle,
                                            NULL,
                                            PAGE_READONLY,
                                            dwHiSize,
                                            dwLoSize,
                                            szSectionName);
                            if (pOpenedFile->hMappedFile == NULL) {
                                dwHiSize = 0;
                                dwLoSize = PDH_LOG_HEADER_MAP_SIZE;
                            }
                            else {
                                pOpenedFile->pData = MapViewOfFile(
                                                pOpenedFile->hMappedFile,
                                                FILE_MAP_READ,
                                                0,
                                                0,
                                                dwLoSize);
                                if (pOpenedFile->pData == NULL) {
                                    dwHiSize = 0;
                                    dwLoSize = PDH_LOG_HEADER_MAP_SIZE;
                                }
                                else {
                                    pLog->iRunidSQL = 1;
                                }
                            }
                        }

                        if (pLog->iRunidSQL == 0) {
                            pOpenedFile->hMappedFile = CreateFileMappingW(
                                            pOpenedFile->hFileHandle,
                                            NULL, PAGE_READONLY,
                                            dwHiSize, dwLoSize, szSectionName);
                            if (pOpenedFile->hMappedFile != NULL) {
                                pOpenedFile->pData = MapViewOfFile (
                                                pOpenedFile->hMappedFile,
                                                FILE_MAP_READ,
                                                0, 0, dwLoSize);
                                if (pOpenedFile->pData == NULL) {
                                    pdhStatus = GetLastError();
                                }
                            }
                            else {
                                pdhStatus = GetLastError();
                            }
                        }
                    } else {
                        // 0-length file
                        pdhStatus = ERROR_FILE_INVALID;
                    }
                } else {
                    pdhStatus = GetLastError();
                }
    
                if (pdhStatus == ERROR_SUCCESS) {
                    // then add this to the list and return the answer
                    pOpenedFile->pNext = PdhipFirstLogFile;
                    PdhipFirstLogFile = pOpenedFile;
                    // init ref count
                    pOpenedFile->dwRefCount = 1;
                    *pFileEntry = pOpenedFile;
                } else {
                    // delete it from the list and return NULL
                    if (pOpenedFile->pData) UnmapViewOfFile (pOpenedFile->pData);
                    if (pOpenedFile->hMappedFile) CloseHandle (pOpenedFile->hMappedFile);
                    if (pOpenedFile->hFileHandle) CloseHandle (pOpenedFile->hFileHandle);
                    G_FREE (pOpenedFile);
                    *pFileEntry = NULL;
                }
            } else {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            }
        } else {
            *pFileEntry = pOpenedFile;
            pOpenedFile->dwRefCount++;
        }

        RELEASE_MUTEX (hPdhContextMutex);
    }
    return pdhStatus;
}


DWORD
UnmapReadonlyMappedFile (
    LPVOID  pMemoryBase,
    BOOL    *bNeedToCloseHandles
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwStatus;
    PPDHI_MAPPED_LOG_FILE   pOpenedFile;
    PPDHI_MAPPED_LOG_FILE   pPrevFile = NULL;

    dwStatus = WaitForSingleObject (hPdhContextMutex, 10000);
    if (dwStatus  == WAIT_TIMEOUT) {
        pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
    }

    if (pdhStatus == ERROR_SUCCESS) {

        // find file to close
        for (pOpenedFile = PdhipFirstLogFile;
            pOpenedFile != NULL;
            pOpenedFile = pOpenedFile->pNext) {

            if (pOpenedFile->pData == pMemoryBase) {
                break;
            } else {
                pPrevFile = pOpenedFile;
            }
        }
        // here pOpenedFile will either be NULL or a ponter
        if (pOpenedFile != NULL) {
            --pOpenedFile->dwRefCount;
            if (!pOpenedFile->dwRefCount) {
                // found so remove from list and close
                if (pOpenedFile == PdhipFirstLogFile) {
                    PdhipFirstLogFile = pOpenedFile->pNext;
                } else {
#pragma warning( disable: 4701 ) // pPrevFile will only be used if the opened log is not the first log
                    pPrevFile->pNext = pOpenedFile->pNext;
#pragma warning (default : 4701 )
                }
                // close open resources
                if (pOpenedFile->pData) UnmapViewOfFile (pOpenedFile->pData);
                if (pOpenedFile->hMappedFile) CloseHandle (pOpenedFile->hMappedFile);
                if (pOpenedFile->hFileHandle) CloseHandle (pOpenedFile->hFileHandle);
                G_FREE (pOpenedFile);
            }
            *bNeedToCloseHandles = FALSE;
        } else {
            // then this must be a normal mapped file
            if (!UnmapViewOfFile (pMemoryBase)) {
                pdhStatus = GetLastError();
            }
            *bNeedToCloseHandles = TRUE;
        }
        RELEASE_MUTEX (hPdhContextMutex);
    }

    return pdhStatus;
}


STATIC_BOOL
IsValidLogHandle (
    IN  HLOG    hLog
)
/*++

Routine Description:

    examines the log handle to verify it is a valid log entry. For now
        the test amounts to:
            the Handle is NOT NULL
            the memory is accessible (i.e. it doesn't AV)
            the signature array is valid
            the size field is correct

        if any tests fail, the handle is presumed to be invalid

Arguments:

    IN  HLOG    hLog
        the handle of the log entry  to test

Return Value:

    TRUE    the handle passes all the tests
    FALSE   one of the test's failed and the handle is not a valid counter

--*/
{
    BOOL    bReturn = FALSE;    // assume it's not a valid query
    PPDHI_LOG  pLog;
#if DBG
    LONG    lStatus = ERROR_SUCCESS;
#endif

    
    __try {
        if (hLog != NULL) {
            // see if a valid signature
            pLog = (PPDHI_LOG) hLog;
            if ((*(DWORD *)&pLog->signature[0] == SigLog) &&
                 (pLog->dwLength == sizeof (PDHI_LOG))){
                bReturn = TRUE;
            } else {
                
                // this is not a valid log entry because the sig is bad
                // or the structure is the wrong size
            }
        } else {
            // this is not a valid counter because the handle is NULL
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // something failed miserably so we can assume this is invalid
#if DBG
        lStatus = GetExceptionCode();
#endif
    }
    return bReturn;
}


STATIC_DWORD
GetLogFileType (
    IN  HANDLE  hLogFile
)
{
    CHAR    cBuffer[MAX_PATH];
    CHAR    cType[MAX_PATH];
    WCHAR   wcType[MAX_PATH];
    BOOL    bStatus;
    DWORD   dwResult;
    DWORD   dwBytesRead;

    memset (&cBuffer[0], 0, sizeof(cBuffer));
    memset (&cType[0], 0, sizeof(cType));
    memset (&wcType[0], 0, sizeof(wcType));

    // read first log file record
    SetFilePointer (hLogFile, 0, NULL, FILE_BEGIN);

    bStatus = ReadFile (hLogFile,
        (LPVOID)cBuffer,
        dwFileHeaderLength,
        &dwBytesRead,
        NULL);

    if (bStatus) {
        // read header record to get type
        lstrcpynA (cType, (LPSTR)(cBuffer+dwTypeLoc), dwFieldLength+1);
        if (lstrcmpiA(cType, szTsvType) == 0) {
            dwResult = PDH_LOG_TYPE_TSV;
        } else if (lstrcmpiA(cType, szCsvType) == 0) {
            dwResult = PDH_LOG_TYPE_CSV;
        } else if (lstrcmpiA(cType, szBinaryType) == 0) {
            dwResult = PDH_LOG_TYPE_RETIRED_BIN;
        } else {
            // perfmon log file type string is in a different
            // location than sysmon logs and used wide chars.
            lstrcpynW (wcType, (LPWSTR)cBuffer, dwPerfmonTypeLength+1);
            if (lstrcmpiW(wcType, cszPerfmonLogSig) == 0) {
                dwResult = PDH_LOG_TYPE_PERFMON;
            } else {
                dwResult = PDH_LOG_TYPE_UNDEFINED;
            }
        } 
    } else {
        // unable to read file
        dwResult = PDH_LOG_TYPE_UNDEFINED;
    }
    return dwResult;

}


STATIC_PDH_FUNCTION
CreateNewLogEntry (
    IN      LPCWSTR  szLogFileName,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      PPDHI_LOG   *pLog
)
/*++
    creates a new log entry and inserts it in the list of open log files

--*/
{
    PPDHI_LOG   pNewLog;
    PPDHI_LOG   pFirstLog;
    PPDHI_LOG   pLastLog;
    DWORD       dwSize;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLogFileNameSize;

    dwLogFileNameSize = lstrlenW(szLogFileName) + 1;

    dwSize = dwLogFileNameSize;
    dwSize *= sizeof (WCHAR);
    dwSize *= 2;                        // double to make room for cat file name
    dwSize = DWORD_MULTIPLE (dwSize);   // ... rounded to the next DWORD
    dwSize += sizeof (PDHI_LOG);        // + room for the data block

    pNewLog = G_ALLOC (dwSize);   // allocate new structure

    if (pNewLog == NULL) {
        pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
        *pLog = NULL;
    } else {
        // initialize the elements in the structure
        *((LPDWORD)(&pNewLog->signature[0])) = SigLog;
        // create and acquire a data mutex for this
        pNewLog->hLogMutex = CreateMutexW (NULL, TRUE, NULL);
        assert (pNewLog->hLogMutex != NULL);

        // insert this item at the end of the list
        if (PdhiFirstLogEntry == NULL) {
             // then this is the first entry
            PdhiFirstLogEntry = pNewLog;
            pNewLog->next.flink =
            pNewLog->next.blink = pNewLog;
        } else {
            // go to the first entry and insert this one just before it
            pFirstLog = PdhiFirstLogEntry;
            pLastLog = pFirstLog->next.blink;
            pNewLog->next.flink = pLastLog->next.flink;
            pLastLog->next.flink = pNewLog;
            pNewLog->next.blink = pFirstLog->next.blink;
            pFirstLog->next.blink = pNewLog;
        }
        // set length field (this is used more for validation
        // than anything else
        pNewLog->dwLength = sizeof (PDHI_LOG);
        // append filename strings immediately after this block
        pNewLog->szLogFileName = (LPWSTR)(&pNewLog[1]);
        lstrcpyW (pNewLog->szLogFileName, szLogFileName);
        // locate catalog name immediately after log file name
        pNewLog->szCatFileName = pNewLog->szLogFileName + dwLogFileNameSize;
        // 
        // NOTE: Catalog should be in the logfile itself, so no need for
        // yet another file extension
        lstrcpyW (pNewLog->szCatFileName, szLogFileName);
        // initialize the file handles
        pNewLog->hLogFileHandle = INVALID_HANDLE_VALUE;
        pNewLog->hCatFileHandle = INVALID_HANDLE_VALUE;

        // initialize the Record Length size
        pNewLog->llMaxSize = (LONGLONG) ((ULONGLONG) dwMaxSize);
        pNewLog->dwRecord1Size = 0;

        // assign the query
        pNewLog->pQuery = (PPDHI_QUERY)hQuery;

        pNewLog->dwLogFormat = 0; // for now
        pNewLog->pPerfmonInfo = NULL;

        *pLog = pNewLog;
    }
    return pdhStatus;
}

OpenSQLLog (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    pLog->dwLogFormat = PDH_LOG_TYPE_SQL;
    pLog->dwLogFormat |=
        dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);


    if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) == PDH_LOG_WRITE_ACCESS) {
        pdhStatus = PdhiOpenOutputSQLLog (pLog);
    } else {
        pdhStatus = PdhiOpenInputSQLLog (pLog);
    }

    *lpdwLogType = (DWORD)(LOWORD(pLog->dwLogFormat));

    return pdhStatus;
}

STATIC_PDH_FUNCTION
OpenInputLogFile (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType
)
{
    LONG        Win32Error;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwFileCreate = 0;
    PPDHI_MAPPED_LOG_FILE   pMappedFileInfo = NULL;

    // for input, the query handle is NULL

    pLog->pQuery = NULL;

////////////////
// SQL goes here 
///////////////

    // First test whether logfile is WMI Event Trace format.
    // If all logfiles are WMI Event Trace format, return immediately;
    // otherwise try other formats.
    //
    pdhStatus = PdhiOpenInputWmiLog(pLog);
    if (pdhStatus == ERROR_SUCCESS) {
        pLog->dwLogFormat  = PDH_LOG_TYPE_BINARY;
        pLog->dwLogFormat |=
            dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        * lpdwLogType = PDH_LOG_TYPE_BINARY;
        return pdhStatus;
    }

    pdhStatus = ERROR_SUCCESS;

    // open file for input based on the specified access flags

    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
        case PDH_LOG_OPEN_EXISTING:
            dwFileCreate = OPEN_EXISTING;
            break;

        case PDH_LOG_CREATE_NEW:
        case PDH_LOG_CREATE_ALWAYS:
        case PDH_LOG_OPEN_ALWAYS:
            // a log file to be read from must not be empty or non-existent
        default:
            // unrecognized value
            pdhStatus = PDH_INVALID_ARGUMENT;
            break;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW (
            pLog->szLogFileName,
            GENERIC_READ,           // Read Access for input
            FILE_SHARE_READ | FILE_SHARE_WRITE, // allow read sharing
            NULL,                   // default security
            dwFileCreate,
            FILE_ATTRIBUTE_NORMAL,  // ignored
            NULL);                  // no template file

        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
                case ERROR_FILE_NOT_FOUND:
                    pdhStatus = PDH_FILE_NOT_FOUND;
                    break;

                case ERROR_ALREADY_EXISTS:
                    pdhStatus = PDH_FILE_ALREADY_EXISTS;
                    break;

                default:
                    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                        case PDH_LOG_CREATE_NEW:
                        case PDH_LOG_CREATE_ALWAYS:
                            pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                            break;

                        case PDH_LOG_OPEN_EXISTING:
                        case PDH_LOG_OPEN_ALWAYS:
                        default:
                            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                            break;
                    }
                    break;
            }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // read the log header and determine the log file type
        pLog->dwLogFormat = GetLogFileType (pLog->hLogFileHandle);
        if (pLog->dwLogFormat != 0) {
            pLog->dwLogFormat |=
                dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        } else {
            pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
        }

        switch (LOWORD(pLog->dwLogFormat)) {
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
            case PDH_LOG_TYPE_PERFMON:  
                // close file opened above
                CloseHandle (pLog->hLogFileHandle);
                pLog->iRunidSQL = 0;
                pdhStatus = OpenReadonlyMappedFile (
                                pLog,
                                pLog->szLogFileName,
                                & pMappedFileInfo,
                                (DWORD) LOWORD(pLog->dwLogFormat));
                if (pdhStatus == ERROR_SUCCESS) {
                    // then update log fields
                    pLog->hLogFileHandle = pMappedFileInfo->hFileHandle;
                    pLog->hMappedLogFile = pMappedFileInfo->hMappedFile;
                    pLog->lpMappedFileBase = pMappedFileInfo->pData;
                    pLog->llFileSize = pMappedFileInfo->llFileSize;
                }
                break;

            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
            default:
                break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
                pdhStatus = PdhiOpenInputTextLog (pLog);
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus = PdhiOpenInputBinaryLog (pLog);
                break;

            case PDH_LOG_TYPE_PERFMON:
                pdhStatus = PdhiOpenInputPerfmonLog (pLog);
                break;

            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;
        }
        *lpdwLogType = (DWORD)(LOWORD(pLog->dwLogFormat));
    }
    return pdhStatus;
}


STATIC_PDH_FUNCTION
OpenUpdateLogFile (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType
)
{
    LONG        Win32Error;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwFileCreate = 0;

    // for input, the query handle is NULL

    pLog->pQuery = NULL;

    // open file for input based on the specified access flags

    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
        case PDH_LOG_OPEN_EXISTING:
            dwFileCreate = OPEN_EXISTING;
            break;

        case PDH_LOG_CREATE_NEW:
        case PDH_LOG_CREATE_ALWAYS:
        case PDH_LOG_OPEN_ALWAYS:
            // a log file to be updated must not be empty or non-existent
        default:
            // unrecognized value
            pdhStatus = PDH_INVALID_ARGUMENT;
            break;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW (
            pLog->szLogFileName,
            GENERIC_READ | GENERIC_WRITE,       // Read & Write Access for input
            FILE_SHARE_READ,        // allow read sharing
            NULL,                   // default security
            dwFileCreate,
            FILE_ATTRIBUTE_NORMAL,  // ignored
            NULL);                  // no template file

        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
                case ERROR_FILE_NOT_FOUND:
                    pdhStatus = PDH_FILE_NOT_FOUND;
                    break;

                case ERROR_ALREADY_EXISTS:
                    pdhStatus = PDH_FILE_ALREADY_EXISTS;
                    break;

                default:
                    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                        case PDH_LOG_CREATE_NEW:
                        case PDH_LOG_CREATE_ALWAYS:
                            pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                            break;

                        case PDH_LOG_OPEN_EXISTING:
                        case PDH_LOG_OPEN_ALWAYS:
                        default:
                            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                            break;
                    }
                    break;
            }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // read the log header and determine the log file type
        pLog->dwLogFormat = GetLogFileType (pLog->hLogFileHandle);
        if (pLog->dwLogFormat != 0) {
            pLog->dwLogFormat |=
                dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        } else {
            pdhStatus = PDH_LOG_TYPE_NOT_FOUND;
        }

        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
            case PDH_LOG_TYPE_BINARY:
                // this will be added later
                // updating a text file will be limited to appending, but that
                // has it's own problems (e.g. insuring the counter list
                // is the same in the new query as the one stored in the log file
                pdhStatus = PDH_NOT_IMPLEMENTED;
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus = PdhiOpenUpdateBinaryLog (pLog);
                break;

            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;
        }
        *lpdwLogType = (DWORD)(LOWORD(pLog->dwLogFormat));
    }
    return pdhStatus;
}


STATIC_PDH_FUNCTION
OpenOutputLogFile (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwAccessFlags,
    IN  LPDWORD     lpdwLogType
)
{
    LONG        Win32Error;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwFileCreate = 0;

    // for output, the query handle must be valid

    if (!IsValidQuery ((HQUERY)pLog->pQuery)) {
        pdhStatus = PDH_INVALID_HANDLE;
    }

    // special handling PDH_LOG_TYPE_BINARY
    //
    if (* lpdwLogType == PDH_LOG_TYPE_BINARY) {
        * lpdwLogType = PDH_LOG_TYPE_BINARY;
        pLog->dwLogFormat =
            dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        pLog->dwLogFormat |=
            *lpdwLogType & ~(PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        return (PdhiOpenOutputWmiLog(pLog));
    }

    // open file for output based on the specified access flags

    if (pdhStatus == ERROR_SUCCESS) {
        switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
            case PDH_LOG_CREATE_NEW:
                dwFileCreate = CREATE_NEW;
                break;

            case PDH_LOG_CREATE_ALWAYS:
                dwFileCreate = CREATE_ALWAYS;
                break;

            case PDH_LOG_OPEN_EXISTING:
                dwFileCreate = OPEN_EXISTING;
                break;

            case PDH_LOG_OPEN_ALWAYS:
                dwFileCreate = OPEN_ALWAYS;
                break;

            default:
                // unrecognized value
                pdhStatus = PDH_INVALID_ARGUMENT;
                break;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pLog->hLogFileHandle = CreateFileW (
            pLog->szLogFileName,
            GENERIC_WRITE | GENERIC_READ,   // write access for output
            FILE_SHARE_READ,        // allow read sharing
            NULL,                   // default security
            dwFileCreate,
            FILE_ATTRIBUTE_NORMAL,
            NULL);                  // no template file

        if (pLog->hLogFileHandle == INVALID_HANDLE_VALUE) {
            Win32Error = GetLastError();
            // translate to PDH_ERROR
            switch (Win32Error) {
                case ERROR_FILE_NOT_FOUND:
                    pdhStatus = PDH_FILE_NOT_FOUND;
                    break;

                case ERROR_ALREADY_EXISTS:
                    pdhStatus = PDH_FILE_ALREADY_EXISTS;
                    break;

                default:
                    switch (dwAccessFlags & PDH_LOG_CREATE_MASK) {
                        case PDH_LOG_CREATE_NEW:
                        case PDH_LOG_CREATE_ALWAYS:
                            pdhStatus = PDH_LOG_FILE_CREATE_ERROR;
                            break;

                        case PDH_LOG_OPEN_EXISTING:
                        case PDH_LOG_OPEN_ALWAYS:
                        default:
                            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                            break;
                    }
                    break;
            }
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        // the file opened successfully so update the data structure
        // this assumes the access flags are in the HIWORD and the...
        pLog->dwLogFormat =
            dwAccessFlags & (PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);
        // the type id is in the LOWORD
        pLog->dwLogFormat |=
            *lpdwLogType & ~(PDH_LOG_ACCESS_MASK | PDH_LOG_OPT_MASK);

        // call any type-specific open functions
        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
                pdhStatus = PdhiOpenOutputTextLog(pLog);
                break;

            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus = PDH_NOT_IMPLEMENTED;
                break;

            case PDH_LOG_TYPE_PERFMON:
                pdhStatus = PDH_NOT_IMPLEMENTED;
                break;

            case PDH_LOG_TYPE_SQL:
                // SQL data soruce should be handled in PdhOpenLogW() before
                // it calls OpenOutputLogFile(). If it goes here, this is
                // an incorrect SQL datasoruce format.
                //
                pdhStatus = PDH_INVALID_SQL_LOG_FORMAT;
                break;

            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;
        }
    }
    return pdhStatus;
}


STATIC_PDH_FUNCTION
WriteLogHeader (
    IN  PPDHI_LOG   pLog,
    IN  LPCWSTR      szUserCaption
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;

    switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
            pdhStatus = PdhiWriteTextLogHeader (pLog, szUserCaption);
            break;

        case PDH_LOG_TYPE_RETIRED_BIN:
            pdhStatus = PdhiWriteBinaryLogHeader (pLog, szUserCaption);
            break;

        case PDH_LOG_TYPE_BINARY:
            break;

        case PDH_LOG_TYPE_SQL:
            pdhStatus = PdhiWriteSQLLogHeader (pLog, szUserCaption);
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
    }
    return pdhStatus;

}


STATIC_PDH_FUNCTION
DeleteLogEntry (
    PPDHI_LOG   pLog
)
{
    PDH_STATUS pdhStatus;
    PPDHI_LOG  pLogNext;

    // assumes structure is locked
    if (IsValidLogHandle ((HLOG)pLog)) {
        if (PdhiFirstLogEntry == pLog) {
            // then this is the first entry in the list so the
            // the "first" entry will be the next forward entry
            if ((pLog->next.flink == pLog->next.blink) &&
                (pLog->next.flink == pLog)){
                // then this is the only entry in the list so clear the first
                // log entry
                PdhiFirstLogEntry = NULL;
            } else {
                // remove this entry from the list
                (pLog->next.flink)->next.blink = pLog->next.blink;
                (pLog->next.blink)->next.flink = pLog->next.flink;
                PdhiFirstLogEntry = pLog->next.flink;
            }
        } else {
            // it's not the first one, so
            // just remove it from the list
            (pLog->next.flink)->next.blink = pLog->next.blink;
            (pLog->next.blink)->next.flink = pLog->next.flink;
        }
        // and release the memory block;
        RELEASE_MUTEX (pLog->hLogMutex);
        CloseHandle (pLog->hLogMutex);

        while (pLog) {
            pLogNext = pLog->NextLog;
            G_FREE (pLog);
            pLog     = pLogNext;
        }
        pdhStatus = ERROR_SUCCESS;
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


STATIC_PDH_FUNCTION
CloseAndDeleteLogEntry (
    IN  PPDHI_LOG   pLog,
    IN  DWORD       dwFlags,
    IN  BOOLEAN     bForceDelete
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    BOOL        bStatus;
    BOOL        bNeedToCloseHandles = TRUE; 

    // call any type-specific open functions
    switch (LOWORD(pLog->dwLogFormat)) {
        case PDH_LOG_TYPE_CSV:
        case PDH_LOG_TYPE_TSV:
            pdhStatus = PdhiCloseTextLog(pLog, dwFlags);
            break;

        case PDH_LOG_TYPE_RETIRED_BIN:
            pdhStatus = PdhiCloseBinaryLog(pLog, dwFlags);
            break;

        case PDH_LOG_TYPE_PERFMON:
            pdhStatus = PdhiClosePerfmonLog(pLog, dwFlags);
            break;

        case PDH_LOG_TYPE_BINARY:
            pdhStatus = PdhiCloseWmiLog(pLog, dwFlags);
            break;

        case PDH_LOG_TYPE_SQL:
            pdhStatus = PdhiCloseSQLLog(pLog, dwFlags);
            break;

        default:
            pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
            break;
    }

    if (bForceDelete || pdhStatus == ERROR_SUCCESS) {
        if (pLog->lpMappedFileBase != NULL) {
            UnmapReadonlyMappedFile (pLog->lpMappedFileBase, &bNeedToCloseHandles);
        } else {
            // if this wasn't a mapped file, then delete
            // the "current record" buffer
            if (pLog->pLastRecordRead != NULL) {
                G_FREE (pLog->pLastRecordRead);
                pLog->pLastRecordRead = NULL;
            }
        }

        if (bNeedToCloseHandles) {
            if (pLog->hMappedLogFile != NULL) {
                bStatus = CloseHandle (pLog->hMappedLogFile);
                assert (bStatus);
                pLog->hMappedLogFile  = NULL;
            }

            if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
                bStatus = CloseHandle (pLog->hLogFileHandle);
                assert (bStatus);
                pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
            }
        } else {
            // the handles have already been closed so just
            // clear their values
            pLog->lpMappedFileBase = NULL;
            pLog->hMappedLogFile  = NULL;
            pLog->hLogFileHandle = INVALID_HANDLE_VALUE;
        }

        if (pLog->pPerfmonInfo != NULL) {
            G_FREE (pLog->pPerfmonInfo);
            pLog->pPerfmonInfo = NULL;
        }

        pLog->dwLastRecordRead = 0;

        if (pLog->hCatFileHandle != INVALID_HANDLE_VALUE) {
            bStatus = CloseHandle (pLog->hCatFileHandle);
            assert (bStatus);
            pLog->hCatFileHandle = INVALID_HANDLE_VALUE;
        }

        if ((dwFlags & PDH_FLAGS_CLOSE_QUERY) == PDH_FLAGS_CLOSE_QUERY) {
            pdhStatus = PdhCloseQuery ((HQUERY)pLog->pQuery);
        }

        pdhStatus = DeleteLogEntry (pLog);
    }

    return pdhStatus;
}


//
//  Local utility functions
//
PDH_FUNCTION
PdhiGetLogCounterInfo (
    IN  HLOG    hLog,
    IN  PPDHI_COUNTER pCounter
)
// validates the counter is in the log file and initializes the data fields
{
    PPDHI_LOG   pLog;
    PDH_STATUS  pdhStatus;

    if (IsValidLogHandle(hLog)) {
        pLog = (PPDHI_LOG)hLog;
        switch (LOWORD(pLog->dwLogFormat)) {
            case PDH_LOG_TYPE_CSV:
            case PDH_LOG_TYPE_TSV:
                pdhStatus = PdhiGetTextLogCounterInfo (
                    pLog, pCounter);
                break;

            case PDH_LOG_TYPE_BINARY:
            case PDH_LOG_TYPE_RETIRED_BIN:
                pdhStatus = PdhiGetBinaryLogCounterInfo (
                    pLog, pCounter);
                break;

            case PDH_LOG_TYPE_PERFMON:
                pdhStatus = PdhiGetPerfmonLogCounterInfo (
                    pLog, pCounter);
                break;

           case PDH_LOG_TYPE_SQL:
                pdhStatus = PdhiGetSQLLogCounterInfo (
                    pLog, pCounter);
                break;
            
            default:
                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                break;

        }
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


DWORD
AddUniqueWideStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPWSTR  szSource,
    IN  BOOL    bUnicodeDest
)
/*++

Routine Description:

    searches the Multi-SZ list, mszDest for szSource and appends it
        to mszDest if it wasn't found

Arguments:

    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPWSTR  szSource    string to add if it's not already in list

ReturnValue:

    The new length of the destination string including both
    trailing NULL characters if the string was added, or 0 if the
    string is already in the list.

--*/
{
    LPVOID  szDestElem;
    DWORD   dwReturnLength;
    LPSTR   aszSource = NULL;
    DWORD   dwLength;

    // check arguments

    if ((mszDest == NULL) || (szSource == NULL)) return 0; // invalid buffers
    if (*szSource == '\0') return 0;    // no source string to add

    // if not a unicode list, make an ansi copy of the source string to
    // compare
    // and ultimately copy if it's not already in the list

    if (!bUnicodeDest) {
        dwLength = lstrlenW(szSource) + 1;
        aszSource = G_ALLOC ((dwLength * 3 * sizeof(CHAR))); // DBCS concern
        if (aszSource != NULL) {
            dwReturnLength = WideCharToMultiByte(_getmbcp(),
                                                 0,
                                                 szSource,
                                                 lstrlenW(szSource),
                                                 aszSource,
                                                 dwLength,
                                                 NULL,
                                                 NULL);

        } else {
            // unable to allocate memory for the temp string
            dwReturnLength = 0;
        }
    } else {
        // just use the ANSI version of the source file name
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        // go to end of dest string
        //
        for (szDestElem = mszDest;
                (bUnicodeDest ? (*(LPWSTR)szDestElem != 0) :
                    (*(LPSTR)szDestElem != 0));
                ) {
            if (bUnicodeDest) {
                // bail out if string already in list
                if (lstrcmpiW((LPCWSTR)szDestElem, szSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPWSTR)szDestElem +
                        (lstrlenW((LPCWSTR)szDestElem)+1));
                }
            }  else {
                // bail out if string already in list
                if (lstrcmpiA((LPSTR)szDestElem, aszSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPSTR)szDestElem +
                        (lstrlenA((LPCSTR)szDestElem)+1));
                }
            }
        }

        // if here, then add string
        // szDestElem is at end of list

        if (bUnicodeDest) {
            lstrcpyW ((LPWSTR)szDestElem, szSource);
            szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(szSource) + 1);
            *((LPWSTR)szDestElem) = L'\0';
            dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
        } else {
            lstrcpyA ((LPSTR)szDestElem, aszSource);
            szDestElem = (LPVOID)((LPSTR)szDestElem + lstrlenA(szDestElem) + 1);
            *((LPSTR)szDestElem) = '\0'; // add second NULL
            dwReturnLength = (DWORD)((LPSTR)szDestElem - (LPSTR)mszDest);
        }
    }

AddString_Bailout:
    if (aszSource != NULL) {
        G_FREE (aszSource);
    }

    return (DWORD)dwReturnLength;
}

DWORD
AddUniqueStringToMultiSz (
    IN  LPVOID  mszDest,
    IN  LPSTR   szSource,
    IN  BOOL    bUnicodeDest
)
/*++

Routine Description:

    searches the Multi-SZ list, mszDest for szSource and appends it
        to mszDest if it wasn't found

Arguments:

    OUT LPVOID  mszDest     Multi-SZ list to get new string
    IN  LPSTR   szSource    string to add if it's not already in list

ReturnValue:

    The new length of the destination string including both
    trailing NULL characters if the string was added, or 0 if the
    string is already in the list.

--*/
{
    LPVOID  szDestElem;
    DWORD   dwReturnLength;
    LPWSTR  wszSource = NULL;
    DWORD   dwLength;

    // check arguments

    if ((mszDest == NULL) || (szSource == NULL)) return 0; // invalid buffers
    if (*szSource == '\0') return 0;    // no source string to add

    // if unicode list, make a unicode copy of the source string to compare
    // and ultimately copy if it's not already in the list

    if (bUnicodeDest) {
        dwLength = lstrlenA(szSource);
        wszSource = G_ALLOC ((dwLength + 1) * sizeof(WCHAR));
        if (wszSource != NULL) {
            dwReturnLength = MultiByteToWideChar(
                        _getmbcp(),
                        0,
                        szSource,
                        dwLength,
                        (LPWSTR) wszSource,
                        dwLength + 1);
        } else {
            // unable to allocate memory for the temp string
            dwReturnLength = 0;
        }
    } else {
        // just use the ANSI version of the source file name
        dwReturnLength = 1;
    }

    if (dwReturnLength > 0) {
        // go to end of dest string
        //
        for (szDestElem = mszDest;
                (bUnicodeDest ? (*(LPWSTR)szDestElem != 0) :
                    (*(LPSTR)szDestElem != 0));
                ) {
            if (bUnicodeDest) {
                // bail out if string already in lsit
                if (lstrcmpiW((LPCWSTR)szDestElem, wszSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPWSTR)szDestElem +
                        (lstrlenW((LPCWSTR)szDestElem)+1));
                }
            }  else {
                // bail out if string already in list
                if (lstrcmpiA((LPSTR)szDestElem, szSource) == 0) {
                    dwReturnLength = 0;
                    goto AddString_Bailout;
                } else {
                    // goto the next item
                    szDestElem = (LPVOID)((LPSTR)szDestElem +
                        (lstrlenA((LPCSTR)szDestElem)+1));
                }
            }
        }

        // if here, then add string
        // szDestElem is at end of list

        if (bUnicodeDest) {
            lstrcpyW ((LPWSTR)szDestElem, wszSource);
            szDestElem = (LPVOID)((LPWSTR)szDestElem + lstrlenW(wszSource) + 1);
            *((LPWSTR)szDestElem) = L'\0';
            dwReturnLength = (DWORD)((LPWSTR)szDestElem - (LPWSTR)mszDest);
        } else {
            lstrcpyA ((LPSTR)szDestElem, szSource);
            szDestElem = (LPVOID)((LPSTR)szDestElem + lstrlenA(szDestElem) + 1);
            *((LPSTR)szDestElem) = '\0'; // add second NULL
            dwReturnLength = (DWORD)((LPSTR)szDestElem - (LPSTR)mszDest);
        }
    }

AddString_Bailout:
    if (wszSource != NULL) {
        G_FREE (wszSource);
    }

    return (DWORD) dwReturnLength;
}


//
//   Exported Logging Functions
//
PDH_FUNCTION
PdhOpenLogW (
    IN      LPCWSTR szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxSize,
    IN      LPCWSTR szUserCaption,
    IN      HLOG    *phLog
)
{
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalLogType = 0;
    PPDHI_LOG   pLog;

    WCHAR   wcType[VALUE_BUFFER_SIZE];

    if ((szLogFileName == NULL) ||
        (lpdwLogType == NULL) ||
        (phLog == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            if (*szLogFileName == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            dwLocalLogType = *lpdwLogType;
            * lpdwLogType  = dwLocalLogType;

            if (szUserCaption != NULL) {
                // if not NULL, it must be valid
                if (*szUserCaption == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                // NULL is a valid argument
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // something failed so give up here
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (hPdhDataMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            // create a log entry
            // if successful, this also acquires the lock for this structure
            pdhStatus = CreateNewLogEntry (
                (LPCWSTR)szLogFileName,
                hQuery,
                dwMaxSize,
                &pLog);
            // Here we must check for SQL: in the file name, and branch off to do SQL
            // Processing /end SJM/
            // open the file
            if (pdhStatus == ERROR_SUCCESS) {
                // find out if SQL file type
                ZeroMemory((LPWSTR) wcType, sizeof(WCHAR) * VALUE_BUFFER_SIZE);
                lstrcpynW((LPWSTR) wcType,
                          (LPWSTR) szLogFileName,
                          lstrlenW(cszSQL) + 1);
                if (lstrcmpiW((LPWSTR)wcType, (LPWSTR) cszSQL) == 0) {
                    dwLocalLogType = PDH_LOG_TYPE_SQL;
                    pLog->llMaxSize = (LONGLONG) ((ULONGLONG) dwMaxSize);
                    pdhStatus = OpenSQLLog(pLog, dwAccessFlags, &dwLocalLogType);
                    if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) == PDH_LOG_WRITE_ACCESS) {
                        pLog->pQuery->hOutLog = (HLOG) pLog;
                        if (pdhStatus == ERROR_SUCCESS) {   
                            pdhStatus = WriteLogHeader (pLog, (LPCWSTR)szUserCaption);
                        }
                    }
                // dispatch based on read/write attribute
                } else if ((dwAccessFlags & PDH_LOG_READ_ACCESS) ==
                    PDH_LOG_READ_ACCESS) {
                    pdhStatus = OpenInputLogFile (pLog,
                        dwAccessFlags, &dwLocalLogType);
                } else if ((dwAccessFlags & PDH_LOG_WRITE_ACCESS) ==
                    PDH_LOG_WRITE_ACCESS) {
                    pdhStatus = OpenOutputLogFile (pLog,
                        dwAccessFlags,
                        &dwLocalLogType);
                    if (pdhStatus == ERROR_SUCCESS) {
                        pLog->pQuery->hOutLog = (HLOG) pLog;
                        pdhStatus = WriteLogHeader (pLog,
                            (LPCWSTR)szUserCaption);
                    }

                } else if ((dwAccessFlags & PDH_LOG_UPDATE_ACCESS) ==
                    PDH_LOG_UPDATE_ACCESS) {
                    pdhStatus = OpenUpdateLogFile (pLog,
                        dwAccessFlags, &dwLocalLogType);
                } else {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
                if (pdhStatus == ERROR_SUCCESS) {
                    __try {
                        // return handle to caller
                        *phLog = (HLOG)pLog;
                        *lpdwLogType = dwLocalLogType;
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        // something failed so give up here
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                } 

                // release the lock for the next thread

                if (pdhStatus != ERROR_SUCCESS) {
                    // unable to complete this operation so toss this entry
                    // since it isn't really a valid log entry.
                    // NOTE: DeleteLogEntry will release the mutex
                    DeleteLogEntry (pLog);
                }
                else {
                    RELEASE_MUTEX (pLog->hLogMutex);
                }
            }
            RELEASE_MUTEX (hPdhDataMutex);
        } else {
            // unable to lock global data structures
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhOpenLogA (
    IN      LPCSTR  szLogFileName,
    IN      DWORD   dwAccessFlags,
    IN      LPDWORD lpdwLogType,
    IN      HQUERY  hQuery,
    IN      DWORD   dwMaxRecords,
    IN      LPCSTR  szUserCaption,
    IN      HLOG    *phLog
)
{
    LPWSTR      wszLogName = NULL;
    LPWSTR      wszUserCaption = NULL;
    DWORD       dwSize;
    DWORD       dwLocalLogType;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    if ((szLogFileName == NULL) ||
        (lpdwLogType == NULL) ||
        (phLog == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            if (*szLogFileName == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }

            dwLocalLogType = *lpdwLogType;  // test read
            * lpdwLogType  = dwLocalLogType;

            if (szUserCaption != NULL) {
                // if not NULL, it must be valid
                if (*szUserCaption == 0) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                // NULL is a valid argument
            }

            if (pdhStatus == ERROR_SUCCESS) {
                // copy ANSI names to Wide Character strings
                dwSize = lstrlenA (szLogFileName);
                wszLogName = (LPWSTR)G_ALLOC ((dwSize + 1) * sizeof(WCHAR));
                if (wszLogName != NULL) {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szLogFileName,
                                        dwSize,
                                        (LPWSTR) wszLogName,
                                        dwSize + 1);
                }

                if (szUserCaption != NULL) {
                    dwSize = lstrlenA (szUserCaption);
                    wszUserCaption = (LPWSTR)G_ALLOC ((dwSize + 1) * sizeof(WCHAR));
                    if (wszUserCaption != NULL) {
                        MultiByteToWideChar(_getmbcp(),
                                            0,
                                            szUserCaption,
                                            dwSize,
                                            (LPWSTR) wszUserCaption,
                                            dwSize + 1);
                    }
                }
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // assume a bad parameter caused the exception
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }


    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhOpenLogW (
            wszLogName,
            dwAccessFlags,
            &dwLocalLogType,
            hQuery,
            dwMaxRecords,
            wszUserCaption,
            phLog);
        __try {
            // return handle to caller
            *lpdwLogType = dwLocalLogType;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // something failed so give up here
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (wszLogName != NULL) {
        G_FREE (wszLogName);
    }

    if (wszUserCaption != NULL) {
        G_FREE (wszUserCaption);
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhUpdateLogW (
    IN      HLOG    hLog,
    IN      LPCWSTR szUserString
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    SYSTEMTIME      st;
    FILETIME        ft;
    PPDHI_LOG       pLog;

    if (szUserString != NULL) {
        __try {
            if (*szUserString == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    } else {
        //NULL is ok
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG)hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                // make sure it's still valid as it could have 
                //  been deleted while we were waiting
                if (IsValidLogHandle (hLog)) {
                    if (pLog->pQuery == NULL) {
                        pdhStatus = PDH_INVALID_ARGUMENT;
                    }
                    else {
                        // get the timestamp and update the log's query,
                        // then write the data to the log file in the
                        // appropriate format

                        // update data samples
                        pdhStatus = PdhiCollectQueryData(
                                (HQUERY) pLog->pQuery, (LONGLONG *) & ft);
                        if (pdhStatus == ERROR_SUCCESS) {
                            FILETIME LocFileTime;
                            if (DataSourceTypeH(pLog->pQuery->hLog)
                                    == DATA_SOURCE_REGISTRY) {
                                FileTimeToLocalFileTime(& ft, & LocFileTime);
                            }
                            else {
                                LocFileTime = ft;
                            }
                            FileTimeToSystemTime(& LocFileTime, & st);
                        }
                        else {
                            GetLocalTime(& st);
                        }

                        // test for end of log file in case the caller is
                        // reading from a log file. If this value is returned,
                        // then don't update the output log file any more.
                        if (pdhStatus != PDH_NO_MORE_DATA) {
                            switch (LOWORD(pLog->dwLogFormat)) {
                            case PDH_LOG_TYPE_CSV:
                            case PDH_LOG_TYPE_TSV:
                                pdhStatus =PdhiWriteTextLogRecord (
                                                  pLog,
                                                  &st,
                                                  (LPCWSTR)szUserString);
                                break;

                            case PDH_LOG_TYPE_RETIRED_BIN:
                                pdhStatus =PdhiWriteBinaryLogRecord (
                                                  pLog, 
                                                  &st,
                                                  (LPCWSTR)szUserString);
                                break;

                            case PDH_LOG_TYPE_BINARY:
                                pdhStatus = PdhiWriteWmiLogRecord(
                                                  pLog,
                                                  &st,
                                                  (LPCWSTR) szUserString);
                                break;
                            // add case for SQL
                            case PDH_LOG_TYPE_SQL:
                                pdhStatus =PdhiWriteSQLLogRecord (
                                                  pLog,
                                                  &st,
                                                  (LPCWSTR)szUserString);
                                break;

                            case PDH_LOG_TYPE_PERFMON:
                            default:
                                pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                                break;
                            }
                        } else {
                            // return the NO_MORE_DATA error to the caller
                            // so they know not to call this function any more
                        }
                    }
                } else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            } // else couldn't lock the log
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhUpdateLogA (
    IN      HLOG    hLog,
    IN      LPCSTR  szUserString
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    LPWSTR          wszLocalUserString = NULL;
    DWORD           dwUserStringLen;

    __try {
        if (szUserString != NULL) {
            if (*szUserString == 0) {
                pdhStatus = PDH_INVALID_ARGUMENT;
            }
        } else {
            //NULL is ok
        }

        if (pdhStatus == ERROR_SUCCESS) {
            if (szUserString != NULL) {
                dwUserStringLen = lstrlenA(szUserString);
                wszLocalUserString = (LPWSTR)G_ALLOC (
                    (dwUserStringLen + 1) * sizeof (WCHAR));
                if (wszLocalUserString != NULL) {
                    MultiByteToWideChar(_getmbcp(),
                                        0,
                                        szUserString,
                                        dwUserStringLen,
                                        (LPWSTR) wszLocalUserString,
                                        dwUserStringLen + 1);

                } else {
                    pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
                }
            } // else continue with NULL pointer
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }

    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhUpdateLogW (hLog, wszLocalUserString);
    }

    if (wszLocalUserString != NULL) {
        G_FREE (wszLocalUserString);
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhUpdateLogFileCatalog (
    IN      HLOG    hLog
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG       pLog;

    if (IsValidLogHandle (hLog)) {
        pLog = (PPDHI_LOG)hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        // make sure it's still valid as it could have 
        //  been deleted while we were waiting

        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hLog)) {
                pLog = (PPDHI_LOG)hLog;

                switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PDH_NOT_IMPLEMENTED;
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiUpdateBinaryLogFileCatalog (pLog);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                }
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pLog->hLogMutex);
        }
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhCloseLog(
    IN      HLOG    hLog,
    IN      DWORD   dwFlags
)
{
    PDH_STATUS      pdhStatus;
    PPDHI_LOG       pLog;

    if (hLog == H_REALTIME_DATASOURCE || hLog == H_WBEM_DATASOURCE) {
        // return immediately if datasource is realtime or wbem
        //
        return ERROR_SUCCESS;
    }

    if (IsValidLogHandle (hLog)) {
        pLog = (PPDHI_LOG)hLog;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            // make sure it's still valid as it could have 
            //  been deleted while we were waiting
            if (IsValidLogHandle (hLog)) {
                // this will release and delete the mutex
                pdhStatus = CloseAndDeleteLogEntry (pLog, dwFlags, FALSE);
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
        }
    } else {
        pdhStatus = PDH_INVALID_HANDLE;
    }
    return pdhStatus;
}


BOOL
PdhiBrowseDataSource (
    IN  HWND    hWndParent,
    IN  LPVOID  szFileName,
    IN  LPDWORD pcchFileNameSize,
    IN  BOOL    bUnicodeString
)
{
    OPENFILENAMEW   ofn;
    LPWSTR          szTempString = NULL;
    LPWSTR          szDirString = NULL;
    LPWSTR          szTempFileName = NULL;
    BOOL            bReturn;
    LPWSTR          szMsg;

    WCHAR           szLogFilterString[512];
    LPWSTR          szLogFilter;

    if (szFileName == NULL) {
        SetLastError(PDH_INVALID_ARGUMENT);
        return FALSE;
    }

    // clear last error
    SetLastError (ERROR_SUCCESS);

    szTempString = G_ALLOC (* pcchFileNameSize * sizeof(WCHAR) * 2);
    if (szTempString == NULL) {
        SetLastError (PDH_MEMORY_ALLOCATION_FAILURE);
        bReturn = FALSE;
    } else {
        ZeroMemory(szTempString, * pcchFileNameSize * sizeof(WCHAR) * 2);
        szDirString = (LPWSTR)((LPBYTE)szTempString + (*pcchFileNameSize * sizeof(WCHAR)));
        // continue
        // get the current filename

        if (bUnicodeString) {
            lstrcpyW (szTempString, (LPWSTR)szFileName);
        } else {
            MultiByteToWideChar(_getmbcp(),
                                0,
                                (LPSTR) szFileName,
                                lstrlenA((LPSTR) szFileName),
                                (LPWSTR) szTempString,
                                lstrlenA((LPSTR) szFileName) + 1);
        }

        // set the path up for the initial  dir display

        if (szTempString[0] != L'\0') {
            if (SearchPathW(NULL, szTempString, NULL,
                *pcchFileNameSize, szDirString, &szTempFileName) > 0) {
                // then update the buffers to show file and dir path
                if (szTempFileName > szDirString) {
                    // then we have a path with a file name so
                    // truncate the path at the last backslash and
                    // then copy the filename to the original buffer
                    *(szTempFileName-1) = 0;
                    lstrcpyW (szTempString, szTempFileName);
                } else {
                    // no file name found so leave things as is
                }
            } else {
                // unable to search path so leave things alone
            }
        }

        // get the log filter string
        if (MakeLogFilterInfoString (
            szLogFilterString, 
            (sizeof(szLogFilterString)/sizeof(szLogFilterString[0]))) == ERROR_SUCCESS) {
            szLogFilter = szLogFilterString;
        } else {
            // then use default filter string
            szLogFilter = NULL;
        }


        // display file open dialog to browse for log files.

        szMsg = GetStringResource (IDS_DSRC_SELECT);

        ofn.lStructSize = sizeof (ofn);
        ofn.hwndOwner = hWndParent;
        ofn.hInstance = ThisDLLHandle;
        ofn.lpstrFilter = szLogFilter;
        ofn.lpstrCustomFilter =  NULL;
        ofn.nMaxCustFilter = 0;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = szTempString;
        ofn.nMaxFile = SMALL_BUFFER_SIZE -1;
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = szDirString;
        ofn.lpstrTitle = szMsg;
        ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                    OFN_PATHMUSTEXIST;
        ofn.nFileOffset = 0;
        ofn.nFileExtension = 0;
        ofn.lpstrDefExt = cszBlg;
        ofn.lCustData = 0;
        ofn.lpfnHook = NULL;
        ofn.lpTemplateName = NULL;

        if (GetOpenFileNameW (&ofn)) {
            // then update the return string

            if (bUnicodeString) {
                lstrcpyW ((LPWSTR)szFileName, szTempString);
                * pcchFileNameSize = lstrlenW(szTempString) + 1;
            } else {
                PdhiConvertUnicodeToAnsi(_getmbcp(),
                        szTempString, (LPSTR) szFileName, pcchFileNameSize);
            }
            bReturn = TRUE;
        } else {
            bReturn = FALSE;
        }
        if (szMsg) G_FREE (szMsg);
    }

    if (szTempString != NULL) G_FREE (szTempString);

    return bReturn;

}

PDH_FUNCTION
PdhGetDataSourceTimeRangeH (
    IN      HLOG            hDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
)
{
    PDH_STATUS    pdhStatus = ERROR_SUCCESS;
    DWORD         dwLocalBufferSize = 0;
    DWORD          dwLocalNumEntries = 0;
    PDH_TIME_INFO LocalInfo;
    PPDHI_LOG     pLog;

    // TODO postW2k1: Capture pInfo. Most routines should be in try

    if (hDataSource == H_REALTIME_DATASOURCE) {
        pdhStatus = PDH_DATA_SOURCE_IS_REAL_TIME;
    }
    else if ((pdwNumEntries == NULL) || (pInfo == NULL)
                                     || (pdwBufferSize == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    }
    else {
        // test caller's buffers before trying to use them
        __try {
            dwLocalNumEntries   = * pdwNumEntries;
            dwLocalBufferSize   = * pdwBufferSize;
            LocalInfo.StartTime = pInfo->StartTime;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (pdhStatus == ERROR_SUCCESS) {
        if (IsValidLogHandle(hDataSource)) {
            pLog = (PPDHI_LOG) hDataSource;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX(pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle(hDataSource)) {
                    // enum machines based on log type
                    //
                    switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiGetTimeRangeFromTextLog(
                                    pLog,
                                    & dwLocalNumEntries,
                                    & LocalInfo,
                                    & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                        pdhStatus = PdhiGetTimeRangeFromWmiLog(
                                    pLog,
                                    & dwLocalNumEntries,
                                    & LocalInfo,
                                    & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiGetTimeRangeFromBinaryLog(
                                    pLog,
                                    & dwLocalNumEntries,
                                    & LocalInfo,
                                    & dwLocalBufferSize);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        pdhStatus = PdhiGetTimeRangeFromSQLLog(
                                    pLog,
                                    & dwLocalNumEntries,
                                    & LocalInfo,
                                    & dwLocalBufferSize);
                        break;
                                        
                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiGetTimeRangeFromPerfmonLog(
                                    pLog,
                                    & dwLocalNumEntries,
                                    & LocalInfo,
                                    & dwLocalBufferSize);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                    }
                    __try {
                        * pdwBufferSize    = dwLocalBufferSize;
                        * pdwNumEntries    = dwLocalNumEntries;

                        pInfo->StartTime   = LocalInfo.StartTime;
                        pInfo->EndTime     = LocalInfo.EndTime;
                        pInfo->SampleCount = LocalInfo.SampleCount;
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {
                        pdhStatus = PDH_INVALID_ARGUMENT;   
                    }
                }
                else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhGetDataSourceTimeRangeW (
    IN      LPCWSTR         szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
)
{
    PDH_STATUS PdhStatus = PDH_DATA_SOURCE_IS_REAL_TIME; 
    HLOG       hDataSource = NULL;
    DWORD      dwLogType = -1;

    if (szDataSource != NULL) {
        // open log file
        //
        PdhStatus = PdhOpenLogW (
                  szDataSource,
                  PDH_LOG_READ_ACCESS | PDH_LOG_OPEN_EXISTING,
                & dwLogType,
                  NULL,
                  0,
                  NULL,
                & hDataSource);
        if (PdhStatus == ERROR_SUCCESS) {
            PdhStatus = PdhGetDataSourceTimeRangeH(
                            hDataSource,
                            pdwNumEntries,
                            pInfo,
                            pdwBufferSize);
            PdhCloseLog(hDataSource, 0);
        }
    }

    return PdhStatus;
}

PDH_FUNCTION
PdhGetDataSourceTimeRangeA (
    IN      LPCSTR          szDataSource,
    IN      LPDWORD         pdwNumEntries,
    IN      PPDH_TIME_INFO  pInfo,
    IN      LPDWORD         pdwBufferSize
)
{
    LPWSTR      wszDataSource = NULL;
    DWORD       dwSize;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalBufferSize = 0;
    DWORD        dwLocalNumEntries = 0;

    // TODO postW2k1: Capture pInfo. Most routines should be in try

    if (szDataSource == NULL) {
        // null data source == the current activity so return
        pdhStatus = PDH_DATA_SOURCE_IS_REAL_TIME;
    } else if ((pdwNumEntries == NULL) || 
        (pInfo == NULL) || 
        (pdwBufferSize == NULL)) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            dwLocalBufferSize = *pdwBufferSize;
            dwLocalNumEntries = *pdwNumEntries;

            dwSize = lstrlenA(szDataSource);
            wszDataSource = G_ALLOC ((dwSize + 1) * sizeof(WCHAR));
            if (wszDataSource == NULL) {
                pdhStatus = PDH_MEMORY_ALLOCATION_FAILURE;
            } else {
                MultiByteToWideChar(_getmbcp(),
                                    0,
                                    szDataSource,
                                    dwSize,
                                    (LPWSTR) wszDataSource,
                                    dwSize + 1);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            // assume a bad parameter caused the exception
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }
    
    if (pdhStatus == ERROR_SUCCESS) {
        pdhStatus = PdhGetDataSourceTimeRangeW (
            wszDataSource,
            &dwLocalNumEntries,
            pInfo,
            &dwLocalBufferSize);

        // copy returned values regardless of status
        __try {
            *pdwBufferSize = dwLocalBufferSize;
            *pdwNumEntries = dwLocalNumEntries;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;   
        }
    }

    if (wszDataSource != NULL) {
        G_FREE (wszDataSource);
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhGetLogFileSize (
    IN  HLOG        hLog,
    IN  LONGLONG    *llSize
)
{
    PDH_STATUS      pdhStatus = ERROR_SUCCESS;
    PPDHI_LOG       pLog;
    UINT            nErrorMode;
    DWORD           dwFileSizeLow = 0;
    DWORD           dwFileSizeHigh = 0;
    LONGLONG        llFileLength;
    DWORD           dwError;

    if (llSize == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        if (IsValidLogHandle (hLog)) {
            pLog = (PPDHI_LOG)hLog;
            pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
            if (pdhStatus == ERROR_SUCCESS) {
                if (IsValidLogHandle (hLog)) {
                    if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_SQL) {
                        __try {
                           * llSize = 0;
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER) {
                           pdhStatus = PDH_INVALID_ARGUMENT;
                        }
                    }
                    else if (LOWORD(pLog->dwLogFormat) == PDH_LOG_TYPE_BINARY) {
                        pdhStatus = PdhiGetWmiLogFileSize(pLog, llSize);
                    }
                    else {
                        // disable windows error message popup
                        nErrorMode = SetErrorMode  (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
                        if (pLog->hLogFileHandle != INVALID_HANDLE_VALUE) {
                            dwFileSizeLow = GetFileSize (pLog->hLogFileHandle, &dwFileSizeHigh);
                            // test for error
                            if ((dwFileSizeLow == 0xFFFFFFFF) && 
                                ((dwError = GetLastError()) != NO_ERROR)) {
                                // then we couldn't get the file size
                                pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                            } else {
                                if (dwFileSizeHigh > 0) {
                                llFileLength = dwFileSizeHigh << (sizeof(DWORD) * 8);
                                } else {
                                    llFileLength = 0;
                                }
                                llFileLength += dwFileSizeLow;
                                // write to the caller' buffer
                                __try {
                                    *llSize = llFileLength;
                                }
                                __except (EXCEPTION_EXECUTE_HANDLER) {
                                    pdhStatus = PDH_INVALID_ARGUMENT;
                                }
                            }
                        } else {
                            pdhStatus = PDH_LOG_FILE_OPEN_ERROR;
                        }
                        SetErrorMode (nErrorMode);  // restore old error mode
                    }
                } else {
                    pdhStatus = PDH_INVALID_HANDLE;
                }
                RELEASE_MUTEX (pLog->hLogMutex);
            }
        } else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhReadRawLogRecord (
    IN  HLOG                    hLog,
    IN  FILETIME                ftRecord,
    IN  PPDH_RAW_LOG_RECORD     pBuffer,
    IN  LPDWORD                 pdwBufferLength
)
{
    PPDHI_LOG   pLog;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;

    DWORD       dwLocalBufferLength = 0;

    if (pdwBufferLength == NULL) {
        pdhStatus = PDH_INVALID_ARGUMENT;
    } else {
        __try {
            CHAR    TestChar;
            // test read & write access to the user's buffer.
            dwLocalBufferLength = *pdwBufferLength;

            if (dwLocalBufferLength > 0) {
                // test beginnging and end of the buffer passed in
                TestChar = ((CHAR *)pBuffer)[0];
                ((CHAR *)pBuffer)[0] = 0;
                ((CHAR *)pBuffer)[0] = TestChar;

                TestChar = ((CHAR *)pBuffer)[dwLocalBufferLength -1];
                ((CHAR *)pBuffer)[dwLocalBufferLength -1] = 0;
                ((CHAR *)pBuffer)[dwLocalBufferLength -1] = TestChar;
            } else {
                // 0 length buffer is OK
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            pdhStatus = PDH_INVALID_ARGUMENT;
        }
    }

    if (!IsValidLogHandle (hLog)) {
        pdhStatus = PDH_INVALID_HANDLE;
    } else if (pdhStatus == ERROR_SUCCESS) {
        pLog = (PPDHI_LOG)hLog;
        // see if the log is open, first?
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pLog->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            // make sure it's still valid
            if (IsValidLogHandle (hLog)) {
                switch (LOWORD(pLog->dwLogFormat)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiReadRawTextLogRecord (
                            hLog,
                            &ftRecord,
                            pBuffer,
                            &dwLocalBufferLength);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiReadRawBinaryLogRecord (
                            hLog,
                            &ftRecord,
                            pBuffer,
                            &dwLocalBufferLength);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        //note this is only supported with a null buffer
                        // as we don't actually read the record, and
                        // positioning the file at the record doesn't
                        // mean anything for SQL
                        pdhStatus = PdhiReadRawSQLLogRecord (
                            hLog,
                            &ftRecord,
                            pBuffer,
                            pdwBufferLength);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiReadRawPerfmonLogRecord (
                            hLog,
                            &ftRecord,
                            pBuffer,
                            &dwLocalBufferLength);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;
                }

                __try {
                    *pdwBufferLength = dwLocalBufferLength;
                } __except (EXCEPTION_EXECUTE_HANDLER) {
                    pdhStatus = PDH_INVALID_ARGUMENT;
                }
            } else {
                pdhStatus = PDH_INVALID_HANDLE;
            }

            RELEASE_MUTEX (pLog->hLogMutex);
        }
    } else {
        // return pdhStatus
    }

    return pdhStatus;

}


PDH_FUNCTION
PdhiEnumLoggedMachines (
    IN  HLOG    hDataSource,
    IN  LPVOID  mszMachineList,
    IN  LPDWORD pcchBufferSize,
    IN  BOOL    bUnicode
)
{
    PDH_STATUS  pdhStatus = PDH_INVALID_HANDLE;
    PPDHI_LOG   pDataSource;
    DWORD       dwLogType;

    // enum machines based on log type
    //
    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG) hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hDataSource)) {

                dwLogType = pDataSource->dwLogFormat;

                switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiEnumMachinesFromTextLog (
                                (PPDHI_LOG) hDataSource,
                                mszMachineList,
                                pcchBufferSize,
                                bUnicode);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiEnumMachinesFromBinaryLog (
                                (PPDHI_LOG) hDataSource,
                                mszMachineList,
                                pcchBufferSize,
                                bUnicode);
                        break;

                case PDH_LOG_TYPE_SQL:
                    pdhStatus = PdhiEnumMachinesFromSQLLog (
                                (PPDHI_LOG)hDataSource,
                                mszMachineList,
                                pcchBufferSize,
                                bUnicode);
                    break;

                case PDH_LOG_TYPE_PERFMON:
                    pdhStatus = PdhiEnumMachinesFromPerfmonLog (
                                (PPDHI_LOG) hDataSource,
                                mszMachineList,
                                pcchBufferSize,
                                bUnicode);
                    break;

                default:
                    pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                    break;
                }
            }
            else {
                   pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhiEnumLoggedObjects (
    IN  HLOG    hDataSource,
    IN  LPCWSTR szMachineName,
    IN  LPVOID  mszObjectList,
    IN  LPDWORD pcchBufferSize,
    IN  DWORD   dwDetailLevel,
    IN  BOOL    bRefresh,         // ignored by log files
    IN  BOOL    bUnicode
)
{
    PDH_STATUS  pdhStatus = PDH_INVALID_HANDLE;
    PPDHI_LOG   pDataSource;
    DWORD       dwLogType;

    UNREFERENCED_PARAMETER (bRefresh);

    if (IsValidLogHandle(hDataSource)) {
        pDataSource = (PPDHI_LOG)hDataSource;
        pdhStatus = WAIT_FOR_AND_LOCK_MUTEX (pDataSource->hLogMutex);
        if (pdhStatus == ERROR_SUCCESS) {
            if (IsValidLogHandle (hDataSource)) {

                dwLogType = pDataSource->dwLogFormat;

                // enum objects based on log type & machine name
                switch (LOWORD(dwLogType)) {
                    case PDH_LOG_TYPE_CSV:
                    case PDH_LOG_TYPE_TSV:
                        pdhStatus = PdhiEnumObjectsFromTextLog (
                            (PPDHI_LOG)hDataSource,
                            szMachineName,
                            mszObjectList,
                            pcchBufferSize,
                            dwDetailLevel,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_BINARY:
                    case PDH_LOG_TYPE_RETIRED_BIN:
                        pdhStatus = PdhiEnumObjectsFromBinaryLog (
                            (PPDHI_LOG)hDataSource,
                            szMachineName,
                            mszObjectList,
                            pcchBufferSize,
                            dwDetailLevel,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_SQL:
                        
                        pdhStatus = PdhiEnumObjectsFromSQLLog (
                            (PPDHI_LOG)hDataSource,
                            szMachineName,
                            mszObjectList,
                            pcchBufferSize,
                            dwDetailLevel,
                            bUnicode);
                        break;

                    case PDH_LOG_TYPE_PERFMON:
                        pdhStatus = PdhiEnumObjectsFromPerfmonLog (
                            (PPDHI_LOG)hDataSource,
                            szMachineName,
                            mszObjectList,
                            pcchBufferSize,
                            dwDetailLevel,
                            bUnicode);
                        break;

                    default:
                        pdhStatus = PDH_UNKNOWN_LOG_FORMAT;
                        break;

                }
            }
            else {
                pdhStatus = PDH_INVALID_HANDLE;
            }
            RELEASE_MUTEX (pDataSource->hLogMutex);
        }
    }
    else {
    }

    return pdhStatus;
}


PDH_FUNCTION
PdhiEnumLoggedObjectItems (
    IN      HLOG   