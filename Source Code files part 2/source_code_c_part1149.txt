0x3360, 0x3361, 0x3362, 0x3363, 0x3364, 0x3365,  // Offset: 3000 ~ 3007
0x3366, 0x3367, 0x3368, 0x3369, 0x336a, 0x336b, 0x336c, 0x336d,  // Offset: 3008 ~ 300f
0x336e, 0x336f, 0x3370, 0x3371, 0x3372, 0x3373, 0x3374, 0x3375,  // Offset: 3010 ~ 3017
0x3376, 0x3377, 0x3378, 0x3379, 0x337a, 0x337b, 0x337c, 0x337d,  // Offset: 3018 ~ 301f
0x337e, 0x337f, 0x3380, 0x3381, 0x3382, 0x3383, 0x3384, 0x3385,  // Offset: 3020 ~ 3027
0x3386, 0x3387, 0x3388, 0x3389, 0x338a, 0x338b, 0x338c, 0x338d,  // Offset: 3028 ~ 302f
0x3390, 0x3391, 0x3392, 0x3393, 0x3394, 0x3395, 0x3396, 0x3397,  // Offset: 3030 ~ 3037
0x3398, 0x3399, 0x339a, 0x339b, 0x339f, 0x33a0, 0x33a2, 0x33a3,  // Offset: 3038 ~ 303f
0x33a4, 0x33a5, 0x33a6, 0x33a7, 0x33a8, 0x33a9, 0x33aa, 0x33ab,  // Offset: 3040 ~ 3047
0x33ac, 0x33ad, 0x33ae, 0x33af, 0x33b0, 0x33b1, 0x33b2, 0x33b3,  // Offset: 3048 ~ 304f
0x33b4, 0x33b5, 0x33b6, 0x33b7, 0x33b8, 0x33b9, 0x33ba, 0x33bb,  // Offset: 3050 ~ 3057
0x33bc, 0x33bd, 0x33be, 0x33bf, 0x33c0, 0x33c1, 0x33c2, 0x33c3,  // Offset: 3058 ~ 305f
0x33c5, 0x33c6, 0x33c7, 0x33c8, 0x33c9, 0x33ca, 0x33cb, 0x33cc,  // Offset: 3060 ~ 3067
0x33cd, 0x33cf, 0x33d0, 0x33d3, 0x33d4, 0x33d6, 0x33d7, 0x33d8,  // Offset: 3068 ~ 306f
0x33d9, 0x33da, 0x33db, 0x33dc, 0x33dd, 0x33de, 0x33df, 0x33e0,  // Offset: 3070 ~ 3077
0x33e1, 0x33e2, 0x33e3, 0x33e4, 0x33e5, 0x33e6, 0x33e7, 0x33e8,  // Offset: 3078 ~ 307f
0x33e9, 0x33ea, 0x33eb, 0x33ec, 0x33ed, 0x33ee, 0x33ef, 0x33f0,  // Offset: 3080 ~ 3087
0x33f1, 0x33f2, 0x33f3, 0x33f4, 0x33f5, 0x33f6, 0x33f7, 0x33f8,  // Offset: 3088 ~ 308f
0x33f9, 0x33fa, 0x33fb, 0x33fc, 0x33fd, 0x33fe, 0x33ff, 0x3400,  // Offset: 3090 ~ 3097
0x3401, 0x3402, 0x3403, 0x3404, 0x3405, 0x3406, 0x3407, 0x3408,  // Offset: 3098 ~ 309f
0x3409, 0x340a, 0x340b, 0x340c, 0x340d, 0x340e, 0x340f, 0x3410,  // Offset: 30a0 ~ 30a7
0x3411, 0x3412, 0x3413, 0x3414, 0x3415, 0x3416, 0x3417, 0x3418,  // Offset: 30a8 ~ 30af
0x3419, 0x341a, 0x341b, 0x341c, 0x341d, 0x341e, 0x341f, 0x3420,  // Offset: 30b0 ~ 30b7
0x3421, 0x3422, 0x3423, 0x3424, 0x3425, 0x3426, 0x3427, 0x3428,  // Offset: 30b8 ~ 30bf
0x3429, 0x342a, 0x342b, 0x342c, 0x342d, 0x342e, 0x342f, 0x3430,  // Offset: 30c0 ~ 30c7
0x3431, 0x3432, 0x3433, 0x3434, 0x3435, 0x3436, 0x3437, 0x3438,  // Offset: 30c8 ~ 30cf
0x3439, 0x343a, 0x343b, 0x343c, 0x343d, 0x343e, 0x343f, 0x3440,  // Offset: 30d0 ~ 30d7
0x3441, 0x3442, 0x3443, 0x3444, 0x3445, 0x3446, 0x3448, 0x3449,  // Offset: 30d8 ~ 30df
0x344a, 0x344b, 0x344c, 0x344d, 0x344e, 0x344f, 0x3450, 0x3451,  // Offset: 30e0 ~ 30e7
0x3452, 0x3453, 0x3454, 0x3455, 0x3456, 0x3457, 0x3458, 0x3459,  // Offset: 30e8 ~ 30ef
0x345a, 0x345b, 0x345c, 0x345d, 0x345e, 0x345f, 0x3460, 0x3461,  // Offset: 30f0 ~ 30f7
0x3462, 0x3463, 0x3464, 0x3465, 0x3466, 0x3467, 0x3468, 0x3469,  // Offset: 30f8 ~ 30ff
0x346a, 0x346b, 0x346c, 0x346d, 0x346e, 0x346f, 0x3470, 0x3471,  // Offset: 3100 ~ 3107
0x3472, 0x3474, 0x3475, 0x3476, 0x3477, 0x3478, 0x3479, 0x347a,  // Offset: 3108 ~ 310f
0x347b, 0x347c, 0x347d, 0x347e, 0x347f, 0x3480, 0x3481, 0x3482,  // Offset: 3110 ~ 3117
0x3483, 0x3484, 0x3485, 0x3486, 0x3487, 0x3488, 0x3489, 0x348a,  // Offset: 3118 ~ 311f
0x348b, 0x348c, 0x348d, 0x348e, 0x348f, 0x3490, 0x3491, 0x3492,  // Offset: 3120 ~ 3127
0x3493, 0x3494, 0x3495, 0x3496, 0x3497, 0x3498, 0x3499, 0x349a,  // Offset: 3128 ~ 312f
0x349b, 0x349c, 0x349d, 0x349e, 0x349f, 0x34a0, 0x34a1, 0x34a2,  // Offset: 3130 ~ 3137
0x34a3, 0x34a4, 0x34a5, 0x34a6, 0x34a7, 0x34a8, 0x34a9, 0x34aa,  // Offset: 3138 ~ 313f
0x34ab, 0x34ac, 0x34ad, 0x34ae, 0x34af, 0x34b0, 0x34b1, 0x34b2,  // Offset: 3140 ~ 3147
0x34b3, 0x34b4, 0x34b5, 0x34b6, 0x34b7, 0x34b8, 0x34b9, 0x34ba,  // Offset: 3148 ~ 314f
0x34bb, 0x34bc, 0x34bd, 0x34be, 0x34bf, 0x34c0, 0x34c1, 0x34c2,  // Offset: 3150 ~ 3157
0x34c3, 0x34c4, 0x34c5, 0x34c6, 0x34c7, 0x34c8, 0x34c9, 0x34ca,  // Offset: 3158 ~ 315f
0x34cb, 0x34cc, 0x34cd, 0x34ce, 0x34cf, 0x34d0, 0x34d1, 0x34d2,  // Offset: 3160 ~ 3167
0x34d3, 0x34d4, 0x34d5, 0x34d6, 0x34d7, 0x34d8, 0x34d9, 0x34da,  // Offset: 3168 ~ 316f
0x34db, 0x34dc, 0x34dd, 0x34de, 0x34df, 0x34e0, 0x34e1, 0x34e2,  // Offset: 3170 ~ 3177
0x34e3, 0x34e4, 0x34e5, 0x34e6, 0x34e7, 0x34e8, 0x34e9, 0x34ea,  // Offset: 3178 ~ 317f
0x34eb, 0x34ec, 0x34ed, 0x34ee, 0x34ef, 0x34f0, 0x34f1, 0x34f2,  // Offset: 3180 ~ 3187
0x34f3, 0x34f4, 0x34f5, 0x34f6, 0x34f7, 0x34f8, 0x34f9, 0x34fa,  // Offset: 3188 ~ 318f
0x34fb, 0x34fc, 0x34fd, 0x34fe, 0x34ff, 0x3500, 0x3501, 0x3502,  // Offset: 3190 ~ 3197
0x3503, 0x3504, 0x3505, 0x3506, 0x3507, 0x3508, 0x3509, 0x350a,  // Offset: 3198 ~ 319f
0x350b, 0x350c, 0x350d, 0x350e, 0x350f, 0x3510, 0x3511, 0x3512,  // Offset: 31a0 ~ 31a7
0x3513, 0x3514, 0x3515, 0x3516, 0x3517, 0x3518, 0x3519, 0x351a,  // Offset: 31a8 ~ 31af
0x351b, 0x351c, 0x351d, 0x351e, 0x351f, 0x3520, 0x3521, 0x3522,  // Offset: 31b0 ~ 31b7
0x3523, 0x3524, 0x3525, 0x3526, 0x3527, 0x3528, 0x3529, 0x352a,  // Offset: 31b8 ~ 31bf
0x352b, 0x352c, 0x352d, 0x352e, 0x352f, 0x3530, 0x3531, 0x3532,  // Offset: 31c0 ~ 31c7
0x3533, 0x3534, 0x3535, 0x3536, 0x3537, 0x3538, 0x3539, 0x353a,  // Offset: 31c8 ~ 31cf
0x353b, 0x353c, 0x353d, 0x353e, 0x353f, 0x3540, 0x3541, 0x3542,  // Offset: 31d0 ~ 31d7
0x3543, 0x3544, 0x3545, 0x3546, 0x3547, 0x3548, 0x3549, 0x354a,  // Offset: 31d8 ~ 31df
0x354b, 0x354c, 0x354d, 0x354e, 0x354f, 0x3550, 0x3551, 0x3552,  // Offset: 31e0 ~ 31e7
0x3553, 0x3554, 0x3555, 0x3556, 0x3557, 0x3558, 0x3559, 0x355a,  // Offset: 31e8 ~ 31ef
0x355b, 0x355c, 0x355d, 0x355e, 0x355f, 0x3560, 0x3561, 0x3562,  // Offset: 31f0 ~ 31f7
0x3563, 0x3564, 0x3565, 0x3566, 0x3567, 0x3568, 0x3569, 0x356a,  // Offset: 31f8 ~ 31ff
0x356b, 0x356c, 0x356d, 0x356e, 0x356f, 0x3570, 0x3571, 0x3572,  // Offset: 3200 ~ 3207
0x3573, 0x3574, 0x3575, 0x3576, 0x3577, 0x3578, 0x3579, 0x357a,  // Offset: 3208 ~ 320f
0x357b, 0x357c, 0x357d, 0x357e, 0x357f, 0x3580, 0x3581, 0x3582,  // Offset: 3210 ~ 3217
0x3583, 0x3584, 0x3585, 0x3586, 0x3587, 0x3588, 0x3589, 0x358a,  // Offset: 3218 ~ 321f
0x358b, 0x358c, 0x358d, 0x358e, 0x358f, 0x3590, 0x3591, 0x3592,  // Offset: 3220 ~ 3227
0x3593, 0x3594, 0x3595, 0x3596, 0x3597, 0x3598, 0x3599, 0x359a,  // Offset: 3228 ~ 322f
0x359b, 0x359c, 0x359d, 0x359f, 0x35a0, 0x35a1, 0x35a2, 0x35a3,  // Offset: 3230 ~ 3237
0x35a4, 0x35a5, 0x35a6, 0x35a7, 0x35a8, 0x35a9, 0x35aa, 0x35ab,  // Offset: 3238 ~ 323f
0x35ac, 0x35ad, 0x35ae, 0x35af, 0x35b0, 0x35b1, 0x35b2, 0x35b3,  // Offset: 3240 ~ 3247
0x35b4, 0x35b5, 0x35b6, 0x35b7, 0x35b8, 0x35b9, 0x35ba, 0x35bb,  // Offset: 3248 ~ 324f
0x35bc, 0x35bd, 0x35be, 0x35bf, 0x35c0, 0x35c1, 0x35c2, 0x35c3,  // Offset: 3250 ~ 3257
0x35c4, 0x35c5, 0x35c6, 0x35c7, 0x35c8, 0x35c9, 0x35ca, 0x35cb,  // Offset: 3258 ~ 325f
0x35cc, 0x35cd, 0x35ce, 0x35cf, 0x35d0, 0x35d1, 0x35d2, 0x35d3,  // Offset: 3260 ~ 3267
0x35d4, 0x35d5, 0x35d6, 0x35d7, 0x35d8, 0x35d9, 0x35da, 0x35db,  // Offset: 3268 ~ 326f
0x35dc, 0x35dd, 0x35de, 0x35df, 0x35e0, 0x35e1, 0x35e2, 0x35e3,  // Offset: 3270 ~ 3277
0x35e4, 0x35e5, 0x35e6, 0x35e7, 0x35e8, 0x35e9, 0x35ea, 0x35eb,  // Offset: 3278 ~ 327f
0x35ec, 0x35ed, 0x35ee, 0x35ef, 0x35f0, 0x35f1, 0x35f2, 0x35f3,  // Offset: 3280 ~ 3287
0x35f4, 0x35f5, 0x35f6, 0x35f7, 0x35f8, 0x35f9, 0x35fa, 0x35fb,  // Offset: 3288 ~ 328f
0x35fc, 0x35fd, 0x35fe, 0x35ff, 0x3600, 0x3601, 0x3602, 0x3603,  // Offset: 3290 ~ 3297
0x3604, 0x3605, 0x3606, 0x3607, 0x3608, 0x3609, 0x360a, 0x360b,  // Offset: 3298 ~ 329f
0x360c, 0x360d, 0x360f, 0x3610, 0x3611, 0x3612, 0x3613, 0x3614,  // Offset: 32a0 ~ 32a7
0x3615, 0x3616, 0x3617, 0x3618, 0x3619, 0x361b, 0x361c, 0x361d,  // Offset: 32a8 ~ 32af
0x361e, 0x361f, 0x3620, 0x3621, 0x3622, 0x3623, 0x3624, 0x3625,  // Offset: 32b0 ~ 32b7
0x3626, 0x3627, 0x3628, 0x3629, 0x362a, 0x362b, 0x362c, 0x362d,  // Offset: 32b8 ~ 32bf
0x362e, 0x362f, 0x3630, 0x3631, 0x3632, 0x3633, 0x3634, 0x3635,  // Offset: 32c0 ~ 32c7
0x3636, 0x3637, 0x3638, 0x3639, 0x363a, 0x363b, 0x363c, 0x363d,  // Offset: 32c8 ~ 32cf
0x363e, 0x363f, 0x3640, 0x3641, 0x3642, 0x3643, 0x3644, 0x3645,  // Offset: 32d0 ~ 32d7
0x3646, 0x3647, 0x3648, 0x3649, 0x364a, 0x364b, 0x364c, 0x364d,  // Offset: 32d8 ~ 32df
0x364e, 0x364f, 0x3650, 0x3651, 0x3652, 0x3653, 0x3654, 0x3655,  // Offset: 32e0 ~ 32e7
0x3656, 0x3657, 0x3658, 0x3659, 0x365a, 0x365b, 0x365c, 0x365d,  // Offset: 32e8 ~ 32ef
0x365e, 0x365f, 0x3660, 0x3661, 0x3662, 0x3663, 0x3664, 0x3665,  // Offset: 32f0 ~ 32f7
0x3666, 0x3667, 0x3668, 0x3669, 0x366a, 0x366b, 0x366c, 0x366d,  // Offset: 32f8 ~ 32ff
0x366e, 0x366f, 0x3670, 0x3671, 0x3672, 0x3673, 0x3674, 0x3675,  // Offset: 3300 ~ 3307
0x3676, 0x3677, 0x3678, 0x3679, 0x367a, 0x367b, 0x367c, 0x367d,  // Offset: 3308 ~ 330f
0x367e, 0x367f, 0x3680, 0x3681, 0x3682, 0x3683, 0x3684, 0x3685,  // Offset: 3310 ~ 3317
0x3686, 0x3687, 0x3688, 0x3689, 0x368a, 0x368b, 0x368c, 0x368d,  // Offset: 3318 ~ 331f
0x368e, 0x368f, 0x3690, 0x3691, 0x3692, 0x3693, 0x3694, 0x3695,  // Offset: 3320 ~ 3327
0x3696, 0x3697, 0x3698, 0x3699, 0x369a, 0x369b, 0x369c, 0x369d,  // Offset: 3328 ~ 332f
0x369e, 0x369f, 0x36a0, 0x36a1, 0x36a2, 0x36a3, 0x36a4, 0x36a5,  // Offset: 3330 ~ 3337
0x36a6, 0x36a7, 0x36a8, 0x36a9, 0x36aa, 0x36ab, 0x36ac, 0x36ad,  // Offset: 3338 ~ 333f
0x36ae, 0x36af, 0x36b0, 0x36b1, 0x36b2, 0x36b3, 0x36b4, 0x36b5,  // Offset: 3340 ~ 3347
0x36b6, 0x36b7, 0x36b8, 0x36b9, 0x36ba, 0x36bb, 0x36bc, 0x36bd,  // Offset: 3348 ~ 334f
0x36be, 0x36bf, 0x36c0, 0x36c1, 0x36c2, 0x36c3, 0x36c4, 0x36c5,  // Offset: 3350 ~ 3357
0x36c6, 0x36c7, 0x36c8, 0x36c9, 0x36ca, 0x36cb, 0x36cc, 0x36cd,  // Offset: 3358 ~ 335f
0x36ce, 0x36cf, 0x36d0, 0x36d1, 0x36d2, 0x36d3, 0x36d4, 0x36d5,  // Offset: 3360 ~ 3367
0x36d6, 0x36d7, 0x36d8, 0x36d9, 0x36da, 0x36db, 0x36dc, 0x36dd,  // Offset: 3368 ~ 336f
0x36de, 0x36df, 0x36e0, 0x36e1, 0x36e2, 0x36e3, 0x36e4, 0x36e5,  // Offset: 3370 ~ 3377
0x36e6, 0x36e7, 0x36e8, 0x36e9, 0x36ea, 0x36eb, 0x36ec, 0x36ed,  // Offset: 3378 ~ 337f
0x36ee, 0x36ef, 0x36f0, 0x36f1, 0x36f2, 0x36f3, 0x36f4, 0x36f5,  // Offset: 3380 ~ 3387
0x36f6, 0x36f7, 0x36f8, 0x36f9, 0x36fa, 0x36fb, 0x36fc, 0x36fd,  // Offset: 3388 ~ 338f
0x36fe, 0x36ff, 0x3700, 0x3701, 0x3702, 0x3703, 0x3704, 0x3705,  // Offset: 3390 ~ 3397
0x3706, 0x3707, 0x3708, 0x3709, 0x370a, 0x370b, 0x370c, 0x370d,  // Offset: 3398 ~ 339f
0x370e, 0x370f, 0x3710, 0x3711, 0x3712, 0x3713, 0x3714, 0x3715,  // Offset: 33a0 ~ 33a7
0x3716, 0x3717, 0x3718, 0x3719, 0x371a, 0x371b, 0x371c, 0x371d,  // Offset: 33a8 ~ 33af
0x371e, 0x371f, 0x3720, 0x3721, 0x3722, 0x3723, 0x3724, 0x3725,  // Offset: 33b0 ~ 33b7
0x3726, 0x3727, 0x3728, 0x3729, 0x372a, 0x372b, 0x372c, 0x372d,  // Offset: 33b8 ~ 33bf
0x372e, 0x372f, 0x3730, 0x3731, 0x3732, 0x3733, 0x3734, 0x3735,  // Offset: 33c0 ~ 33c7
0x3736, 0x3737, 0x3738, 0x3739, 0x373a, 0x373b, 0x373c, 0x373d,  // Offset: 33c8 ~ 33cf
0x373e, 0x373f, 0x3740, 0x3741, 0x3742, 0x3743, 0x3744, 0x3745,  // Offset: 33d0 ~ 33d7
0x3746, 0x3747, 0x3748, 0x3749, 0x374a, 0x374b, 0x374c, 0x374d,  // Offset: 33d8 ~ 33df
0x374e, 0x374f, 0x3750, 0x3751, 0x3752, 0x3753, 0x3754, 0x3755,  // Offset: 33e0 ~ 33e7
0x3756, 0x3757, 0x3758, 0x3759, 0x375a, 0x375b, 0x375c, 0x375d,  // Offset: 33e8 ~ 33ef
0x375e, 0x375f, 0x3760, 0x3761, 0x3762, 0x3763, 0x3764, 0x3765,  // Offset: 33f0 ~ 33f7
0x3766, 0x3767, 0x3768, 0x3769, 0x376a, 0x376b, 0x376c, 0x376d,  // Offset: 33f8 ~ 33ff
0x376e, 0x376f, 0x3770, 0x3771, 0x3772, 0x3773, 0x3774, 0x3775,  // Offset: 3400 ~ 3407
0x3776, 0x3777, 0x3778, 0x3779, 0x377a, 0x377b, 0x377c, 0x377d,  // Offset: 3408 ~ 340f
0x377e, 0x377f, 0x3780, 0x3781, 0x3782, 0x3783, 0x3784, 0x3785,  // Offset: 3410 ~ 3417
0x3786, 0x3787, 0x3788, 0x3789, 0x378a, 0x378b, 0x378c, 0x378d,  // Offset: 3418 ~ 341f
0x378e, 0x378f, 0x3790, 0x3791, 0x3792, 0x3793, 0x3794, 0x3795,  // Offset: 3420 ~ 3427
0x3796, 0x3797, 0x3798, 0x3799, 0x379a, 0x379b, 0x379c, 0x379d,  // Offset: 3428 ~ 342f
0x379e, 0x379f, 0x37a0, 0x37a1, 0x37a2, 0x37a3, 0x37a4, 0x37a5,  // Offset: 3430 ~ 3437
0x37a6, 0x37a7, 0x37a8, 0x37a9, 0x37aa, 0x37ab, 0x37ac, 0x37ad,  // Offset: 3438 ~ 343f
0x37ae, 0x37af, 0x37b0, 0x37b1, 0x37b2, 0x37b3, 0x37b4, 0x37b5,  // Offset: 3440 ~ 3447
0x37b6, 0x37b7, 0x37b8, 0x37b9, 0x37ba, 0x37bb, 0x37bc, 0x37bd,  // Offset: 3448 ~ 344f
0x37be, 0x37bf, 0x37c0, 0x37c1, 0x37c2, 0x37c3, 0x37c4, 0x37c5,  // Offset: 3450 ~ 3457
0x37c6, 0x37c7, 0x37c8, 0x37c9, 0x37ca, 0x37cb, 0x37cc, 0x37cd,  // Offset: 3458 ~ 345f
0x37ce, 0x37cf, 0x37d0, 0x37d1, 0x37d2, 0x37d3, 0x37d4, 0x37d5,  // Offset: 3460 ~ 3467
0x37d6, 0x37d7, 0x37d8, 0x37d9, 0x37da, 0x37db, 0x37dc, 0x37dd,  // Offset: 3468 ~ 346f
0x37de, 0x37df, 0x37e0, 0x37e1, 0x37e2, 0x37e3, 0x37e4, 0x37e5,  // Offset: 3470 ~ 3477
0x37e6, 0x37e7, 0x37e8, 0x37e9, 0x37ea, 0x37eb, 0x37ec, 0x37ed,  // Offset: 3478 ~ 347f
0x37ee, 0x37ef, 0x37f0, 0x37f1, 0x37f2, 0x37f3, 0x37f4, 0x37f5,  // Offset: 3480 ~ 3487
0x37f6, 0x37f7, 0x37f8, 0x37f9, 0x37fa, 0x37fb, 0x37fc, 0x37fd,  // Offset: 3488 ~ 348f
0x37fe, 0x37ff, 0x3800, 0x3801, 0x3802, 0x3803, 0x3804, 0x3805,  // Offset: 3490 ~ 3497
0x3806, 0x3807, 0x3808, 0x3809, 0x380a, 0x380b, 0x380c, 0x380d,  // Offset: 3498 ~ 349f
0x380e, 0x380f, 0x3810, 0x3811, 0x3812, 0x3813, 0x3814, 0x3815,  // Offset: 34a0 ~ 34a7
0x3816, 0x3817, 0x3818, 0x3819, 0x381a, 0x381b, 0x381c, 0x381d,  // Offset: 34a8 ~ 34af
0x381e, 0x381f, 0x3820, 0x3821, 0x3822, 0x3823, 0x3824, 0x3825,  // Offset: 34b0 ~ 34b7
0x3826, 0x3827, 0x3828, 0x3829, 0x382a, 0x382b, 0x382c, 0x382d,  // Offset: 34b8 ~ 34bf
0x382e, 0x382f, 0x3830, 0x3831, 0x3832, 0x3833, 0x3834, 0x3835,  // Offset: 34c0 ~ 34c7
0x3836, 0x3837, 0x3838, 0x3839, 0x383a, 0x383b, 0x383c, 0x383d,  // Offset: 34c8 ~ 34cf
0x383e, 0x383f, 0x3840, 0x3841, 0x3842, 0x3843, 0x3844, 0x3845,  // Offset: 34d0 ~ 34d7
0x3846, 0x3847, 0x3848, 0x3849, 0x384a, 0x384b, 0x384c, 0x384d,  // Offset: 34d8 ~ 34df
0x384e, 0x384f, 0x3850, 0x3851, 0x3852, 0x3853, 0x3854, 0x3855,  // Offset: 34e0 ~ 34e7
0x3856, 0x3857, 0x3858, 0x3859, 0x385a, 0x385b, 0x385c, 0x385d,  // Offset: 34e8 ~ 34ef
0x385e, 0x385f, 0x3860, 0x3861, 0x3862, 0x3863, 0x3864, 0x3865,  // Offset: 34f0 ~ 34f7
0x3866, 0x3867, 0x3868, 0x3869, 0x386a, 0x386b, 0x386c, 0x386d,  // Offset: 34f8 ~ 34ff
0x386e, 0x386f, 0x3870, 0x3871, 0x3872, 0x3873, 0x3874, 0x3875,  // Offset: 3500 ~ 3507
0x3876, 0x3877, 0x3878, 0x3879, 0x387a, 0x387b, 0x387c, 0x387d,  // Offset: 3508 ~ 350f
0x387e, 0x387f, 0x3880, 0x3881, 0x3882, 0x3883, 0x3884, 0x3885,  // Offset: 3510 ~ 3517
0x3886, 0x3887, 0x3888, 0x3889, 0x388a, 0x388b, 0x388c, 0x388d,  // Offset: 3518 ~ 351f
0x388e, 0x388f, 0x3890, 0x3891, 0x3892, 0x3893, 0x3894, 0x3895,  // Offset: 3520 ~ 3527
0x3896, 0x3897, 0x3898, 0x3899, 0x389a, 0x389b, 0x389c, 0x389d,  // Offset: 3528 ~ 352f
0x389e, 0x389f, 0x38a0, 0x38a1, 0x38a2, 0x38a3, 0x38a4, 0x38a5,  // Offset: 3530 ~ 3537
0x38a6, 0x38a7, 0x38a8, 0x38a9, 0x38aa, 0x38ab, 0x38ac, 0x38ad,  // Offset: 3538 ~ 353f
0x38ae, 0x38af, 0x38b0, 0x38b1, 0x38b2, 0x38b3, 0x38b4, 0x38b5,  // Offset: 3540 ~ 3547
0x38b6, 0x38b7, 0x38b8, 0x38b9, 0x38ba, 0x38bb, 0x38bc, 0x38bd,  // Offset: 3548 ~ 354f
0x38be, 0x38bf, 0x38c0, 0x38c1, 0x38c2, 0x38c3, 0x38c4, 0x38c5,  // Offset: 3550 ~ 3557
0x38c6, 0x38c7, 0x38c8, 0x38c9, 0x38ca, 0x38cb, 0x38cc, 0x38cd,  // Offset: 3558 ~ 355f
0x38ce, 0x38cf, 0x38d0, 0x38d1, 0x38d2, 0x38d3, 0x38d4, 0x38d5,  // Offset: 3560 ~ 3567
0x38d6, 0x38d7, 0x38d8, 0x38d9, 0x38da, 0x38db, 0x38dc, 0x38dd,  // Offset: 3568 ~ 356f
0x38de, 0x38df, 0x38e0, 0x38e1, 0x38e2, 0x38e3, 0x38e4, 0x38e5,  // Offset: 3570 ~ 3577
0x38e6, 0x38e7, 0x38e8, 0x38e9, 0x38ea, 0x38eb, 0x38ec, 0x38ed,  // Offset: 3578 ~ 357f
0x38ee, 0x38ef, 0x38f0, 0x38f1, 0x38f2, 0x38f3, 0x38f4, 0x38f5,  // Offset: 3580 ~ 3587
0x38f6, 0x38f7, 0x38f8, 0x38f9, 0x38fa, 0x38fb, 0x38fc, 0x38fd,  // Offset: 3588 ~ 358f
0x38fe, 0x38ff, 0x3900, 0x3901, 0x3902, 0x3903, 0x3904, 0x3905,  // Offset: 3590 ~ 3597
0x3906, 0x3907, 0x3908, 0x3909, 0x390a, 0x390b, 0x390c, 0x390d,  // Offset: 3598 ~ 359f
0x390e, 0x390f, 0x3910, 0x3911, 0x3912, 0x3913, 0x3914, 0x3915,  // Offset: 35a0 ~ 35a7
0x3916, 0x3917, 0x3919, 0x391a, 0x391b, 0x391c, 0x391d, 0x391e,  // Offset: 35a8 ~ 35af
0x391f, 0x3920, 0x3921, 0x3922, 0x3923, 0x3924, 0x3925, 0x3926,  // Offset: 35b0 ~ 35b7
0x3927, 0x3928, 0x3929, 0x392a, 0x392b, 0x392c, 0x392d, 0x392e,  // Offset: 35b8 ~ 35bf
0x392f, 0x3930, 0x3931, 0x3932, 0x3933, 0x3934, 0x3935, 0x3936,  // Offset: 35c0 ~ 35c7
0x3937, 0x3938, 0x3939, 0x393a, 0x393b, 0x393c, 0x393d, 0x393e,  // Offset: 35c8 ~ 35cf
0x393f, 0x3940, 0x3941, 0x3942, 0x3943, 0x3944, 0x3945, 0x3946,  // Offset: 35d0 ~ 35d7
0x3947, 0x3948, 0x3949, 0x394a, 0x394b, 0x394c, 0x394d, 0x394e,  // Offset: 35d8 ~ 35df
0x394f, 0x3950, 0x3951, 0x3952, 0x3953, 0x3954, 0x3955, 0x3956,  // Offset: 35e0 ~ 35e7
0x3957, 0x3958, 0x3959, 0x395a, 0x395b, 0x395c, 0x395d, 0x395e,  // Offset: 35e8 ~ 35ef
0x395f, 0x3960, 0x3961, 0x3962, 0x3963, 0x3964, 0x3965, 0x3966,  // Offset: 35f0 ~ 35f7
0x3967, 0x3968, 0x3969, 0x396a, 0x396b, 0x396c, 0x396d, 0x396f,  // Offset: 35f8 ~ 35ff
0x3970, 0x3971, 0x3972, 0x3973, 0x3974, 0x3975, 0x3976, 0x3977,  // Offset: 3600 ~ 3607
0x3978, 0x3979, 0x397a, 0x397b, 0x397c, 0x397d, 0x397e, 0x397f,  // Offset: 3608 ~ 360f
0x3980, 0x3981, 0x3982, 0x3983, 0x3984, 0x3985, 0x3986, 0x3987,  // Offset: 3610 ~ 3617
0x3988, 0x3989, 0x398a, 0x398b, 0x398c, 0x398d, 0x398e, 0x398f,  // Offset: 3618 ~ 361f
0x3990, 0x3991, 0x3992, 0x3993, 0x3994, 0x3995, 0x3996, 0x3997,  // Offset: 3620 ~ 3627
0x3998, 0x3999, 0x399a, 0x399b, 0x399c, 0x399d, 0x399e, 0x399f,  // Offset: 3628 ~ 362f
0x39a0, 0x39a1, 0x39a2, 0x39a3, 0x39a4, 0x39a5, 0x39a6, 0x39a7,  // Offset: 3630 ~ 3637
0x39a8, 0x39a9, 0x39aa, 0x39ab, 0x39ac, 0x39ad, 0x39ae, 0x39af,  // Offset: 3638 ~ 363f
0x39b0, 0x39b1, 0x39b2, 0x39b3, 0x39b4, 0x39b5, 0x39b6, 0x39b7,  // Offset: 3640 ~ 3647
0x39b8, 0x39b9, 0x39ba, 0x39bb, 0x39bc, 0x39bd, 0x39be, 0x39bf,  // Offset: 3648 ~ 364f
0x39c0, 0x39c1, 0x39c2, 0x39c3, 0x39c4, 0x39c5, 0x39c6, 0x39c7,  // Offset: 3650 ~ 3657
0x39c8, 0x39c9, 0x39ca, 0x39cb, 0x39cc, 0x39cd, 0x39ce, 0x39d1,  // Offset: 3658 ~ 365f
0x39d2, 0x39d3, 0x39d4, 0x39d5, 0x39d6, 0x39d7, 0x39d8, 0x39d9,  // Offset: 3660 ~ 3667
0x39da, 0x39db, 0x39dc, 0x39dd, 0x39de, 0x39e0, 0x39e1, 0x39e2,  // Offset: 3668 ~ 366f
0x39e3, 0x39e4, 0x39e5, 0x39e6, 0x39e7, 0x39e8, 0x39e9, 0x39ea,  // Offset: 3670 ~ 3677
0x39eb, 0x39ec, 0x39ed, 0x39ee, 0x39ef, 0x39f0, 0x39f1, 0x39f2,  // Offset: 3678 ~ 367f
0x39f3, 0x39f4, 0x39f5, 0x39f6, 0x39f7, 0x39f8, 0x39f9, 0x39fa,  // Offset: 3680 ~ 3687
0x39fb, 0x39fc, 0x39fd, 0x39fe, 0x39ff, 0x3a00, 0x3a01, 0x3a02,  // Offset: 3688 ~ 368f
0x3a03, 0x3a04, 0x3a05, 0x3a06, 0x3a07, 0x3a08, 0x3a09, 0x3a0a,  // Offset: 3690 ~ 3697
0x3a0b, 0x3a0c, 0x3a0d, 0x3a0e, 0x3a0f, 0x3a10, 0x3a11, 0x3a12,  // Offset: 3698 ~ 369f
0x3a13, 0x3a14, 0x3a15, 0x3a16, 0x3a17, 0x3a18, 0x3a19, 0x3a1a,  // Offset: 36a0 ~ 36a7
0x3a1b, 0x3a1c, 0x3a1d, 0x3a1e, 0x3a1f, 0x3a20, 0x3a21, 0x3a22,  // Offset: 36a8 ~ 36af
0x3a23, 0x3a24, 0x3a25, 0x3a26, 0x3a27, 0x3a28, 0x3a29, 0x3a2a,  // Offset: 36b0 ~ 36b7
0x3a2b, 0x3a2c, 0x3a2d, 0x3a2e, 0x3a2f, 0x3a30, 0x3a31, 0x3a32,  // Offset: 36b8 ~ 36bf
0x3a33, 0x3a34, 0x3a35, 0x3a36, 0x3a37, 0x3a38, 0x3a39, 0x3a3a,  // Offset: 36c0 ~ 36c7
0x3a3b, 0x3a3c, 0x3a3d, 0x3a3e, 0x3a3f, 0x3a40, 0x3a41, 0x3a42,  // Offset: 36c8 ~ 36cf
0x3a43, 0x3a44, 0x3a45, 0x3a46, 0x3a47, 0x3a48, 0x3a49, 0x3a4a,  // Offset: 36d0 ~ 36d7
0x3a4b, 0x3a4c, 0x3a4d, 0x3a4e, 0x3a4f, 0x3a50, 0x3a51, 0x3a52,  // Offset: 36d8 ~ 36df
0x3a53, 0x3a54, 0x3a55, 0x3a56, 0x3a57, 0x3a58, 0x3a59, 0x3a5a,  // Offset: 36e0 ~ 36e7
0x3a5b, 0x3a5c, 0x3a5d, 0x3a5e, 0x3a5f, 0x3a60, 0x3a61, 0x3a62,  // Offset: 36e8 ~ 36ef
0x3a63, 0x3a64, 0x3a65, 0x3a66, 0x3a67, 0x3a68, 0x3a69, 0x3a6a,  // Offset: 36f0 ~ 36f7
0x3a6b, 0x3a6c, 0x3a6d, 0x3a6e, 0x3a6f, 0x3a70, 0x3a71, 0x3a72,  // Offset: 36f8 ~ 36ff
0x3a74, 0x3a75, 0x3a76, 0x3a77, 0x3a78, 0x3a79, 0x3a7a, 0x3a7b,  // Offset: 3700 ~ 3707
0x3a7c, 0x3a7d, 0x3a7e, 0x3a7f, 0x3a80, 0x3a81, 0x3a82, 0x3a83,  // Offset: 3708 ~ 370f
0x3a84, 0x3a85, 0x3a86, 0x3a87, 0x3a88, 0x3a89, 0x3a8a, 0x3a8b,  // Offset: 3710 ~ 3717
0x3a8c, 0x3a8d, 0x3a8e, 0x3a8f, 0x3a90, 0x3a91, 0x3a92, 0x3a93,  // Offset: 3718 ~ 371f
0x3a94, 0x3a95, 0x3a96, 0x3a97, 0x3a98, 0x3a99, 0x3a9a, 0x3a9b,  // Offset: 3720 ~ 3727
0x3a9c, 0x3a9d, 0x3a9e, 0x3a9f, 0x3aa0, 0x3aa1, 0x3aa2, 0x3aa3,  // Offset: 3728 ~ 372f
0x3aa4, 0x3aa5, 0x3aa6, 0x3aa7, 0x3aa8, 0x3aa9, 0x3aaa, 0x3aab,  // Offset: 3730 ~ 3737
0x3aac, 0x3aad, 0x3aae, 0x3aaf, 0x3ab0, 0x3ab1, 0x3ab2, 0x3ab3,  // Offset: 3738 ~ 373f
0x3ab4, 0x3ab5, 0x3ab6, 0x3ab7, 0x3ab8, 0x3ab9, 0x3aba, 0x3abb,  // Offset: 3740 ~ 3747
0x3abc, 0x3abd, 0x3abe, 0x3abf, 0x3ac0, 0x3ac1, 0x3ac2, 0x3ac3,  // Offset: 3748 ~ 374f
0x3ac4, 0x3ac5, 0x3ac6, 0x3ac7, 0x3ac8, 0x3ac9, 0x3aca, 0x3acb,  // Offset: 3750 ~ 3757
0x3acc, 0x3acd, 0x3ace, 0x3acf, 0x3ad0, 0x3ad1, 0x3ad2, 0x3ad3,  // Offset: 3758 ~ 375f
0x3ad4, 0x3ad5, 0x3ad6, 0x3ad7, 0x3ad8, 0x3ad9, 0x3ada, 0x3adb,  // Offset: 3760 ~ 3767
0x3adc, 0x3add, 0x3ade, 0x3adf, 0x3ae0, 0x3ae1, 0x3ae2, 0x3ae3,  // Offset: 3768 ~ 376f
0x3ae4, 0x3ae5, 0x3ae6, 0x3ae7, 0x3ae8, 0x3ae9, 0x3aea, 0x3aeb,  // Offset: 3770 ~ 3777
0x3aec, 0x3aed, 0x3aee, 0x3aef, 0x3af0, 0x3af1, 0x3af2, 0x3af3,  // Offset: 3778 ~ 377f
0x3af4, 0x3af5, 0x3af6, 0x3af7, 0x3af8, 0x3af9, 0x3afa, 0x3afb,  // Offset: 3780 ~ 3787
0x3afc, 0x3afd, 0x3afe, 0x3aff, 0x3b00, 0x3b01, 0x3b02, 0x3b03,  // Offset: 3788 ~ 378f
0x3b04, 0x3b05, 0x3b06, 0x3b07, 0x3b08, 0x3b09, 0x3b0a, 0x3b0b,  // Offset: 3790 ~ 3797
0x3b0c, 0x3b0d, 0x3b0e, 0x3b0f, 0x3b10, 0x3b11, 0x3b12, 0x3b13,  // Offset: 3798 ~ 379f
0x3b14, 0x3b15, 0x3b16, 0x3b17, 0x3b18, 0x3b19, 0x3b1a, 0x3b1b,  // Offset: 37a0 ~ 37a7
0x3b1c, 0x3b1d, 0x3b1e, 0x3b1f, 0x3b20, 0x3b21, 0x3b22, 0x3b23,  // Offset: 37a8 ~ 37af
0x3b24, 0x3b25, 0x3b26, 0x3b27, 0x3b28, 0x3b29, 0x3b2a, 0x3b2b,  // Offset: 37b0 ~ 37b7
0x3b2c, 0x3b2d, 0x3b2e, 0x3b2f, 0x3b30, 0x3b31, 0x3b32, 0x3b33,  // Offset: 37b8 ~ 37bf
0x3b34, 0x3b35, 0x3b36, 0x3b37, 0x3b38, 0x3b39, 0x3b3a, 0x3b3b,  // Offset: 37c0 ~ 37c7
0x3b3c, 0x3b3d, 0x3b3e, 0x3b3f, 0x3b40, 0x3b41, 0x3b42, 0x3b43,  // Offset: 37c8 ~ 37cf
0x3b44, 0x3b45, 0x3b46, 0x3b47, 0x3b48, 0x3b49, 0x3b4a, 0x3b4b,  // Offset: 37d0 ~ 37d7
0x3b4c, 0x3b4d, 0x3b4f, 0x3b50, 0x3b51, 0x3b52, 0x3b53, 0x3b54,  // Offset: 37d8 ~ 37df
0x3b55, 0x3b56, 0x3b57, 0x3b58, 0x3b59, 0x3b5a, 0x3b5b, 0x3b5c,  // Offset: 37e0 ~ 37e7
0x3b5d, 0x3b5e, 0x3b5f, 0x3b60, 0x3b61, 0x3b62, 0x3b63, 0x3b64,  // Offset: 37e8 ~ 37ef
0x3b65, 0x3b66, 0x3b67, 0x3b68, 0x3b69, 0x3b6a, 0x3b6b, 0x3b6c,  // Offset: 37f0 ~ 37f7
0x3b6d, 0x3b6e, 0x3b6f, 0x3b70, 0x3b71, 0x3b72, 0x3b73, 0x3b74,  // Offset: 37f8 ~ 37ff
0x3b75, 0x3b76, 0x3b77, 0x3b78, 0x3b79, 0x3b7a, 0x3b7b, 0x3b7c,  // Offset: 3800 ~ 3807
0x3b7d, 0x3b7e, 0x3b7f, 0x3b80, 0x3b81, 0x3b82, 0x3b83, 0x3b84,  // Offset: 3808 ~ 380f
0x3b85, 0x3b86, 0x3b87, 0x3b88, 0x3b89, 0x3b8a, 0x3b8b, 0x3b8c,  // Offset: 3810 ~ 3817
0x3b8d, 0x3b8e, 0x3b8f, 0x3b90, 0x3b91, 0x3b92, 0x3b93, 0x3b94,  // Offset: 3818 ~ 381f
0x3b95, 0x3b96, 0x3b97, 0x3b98, 0x3b99, 0x3b9a, 0x3b9b, 0x3b9c,  // Offset: 3820 ~ 3827
0x3b9d, 0x3b9e, 0x3b9f, 0x3ba0, 0x3ba1, 0x3ba2, 0x3ba3, 0x3ba4,  // Offset: 3828 ~ 382f
0x3ba5, 0x3ba6, 0x3ba7, 0x3ba8, 0x3ba9, 0x3baa, 0x3bab, 0x3bac,  // Offset: 3830 ~ 3837
0x3bad, 0x3bae, 0x3baf, 0x3bb0, 0x3bb1, 0x3bb2, 0x3bb3, 0x3bb4,  // Offset: 3838 ~ 383f
0x3bb5, 0x3bb6, 0x3bb7, 0x3bb8, 0x3bb9, 0x3bba, 0x3bbb, 0x3bbc,  // Offset: 3840 ~ 3847
0x3bbd, 0x3bbe, 0x3bbf, 0x3bc0, 0x3bc1, 0x3bc2, 0x3bc3, 0x3bc4,  // Offset: 3848 ~ 384f
0x3bc5, 0x3bc6, 0x3bc7, 0x3bc8, 0x3bc9, 0x3bca, 0x3bcb, 0x3bcc,  // Offset: 3850 ~ 3857
0x3bcd, 0x3bce, 0x3bcf, 0x3bd0, 0x3bd1, 0x3bd2, 0x3bd3, 0x3bd4,  // Offset: 3858 ~ 385f
0x3bd5, 0x3bd6, 0x3bd7, 0x3bd8, 0x3bd9, 0x3bda, 0x3bdb, 0x3bdc,  // Offset: 3860 ~ 3867
0x3bdd, 0x3bde, 0x3bdf, 0x3be0, 0x3be1, 0x3be2, 0x3be3, 0x3be4,  // Offset: 3868 ~ 386f
0x3be5, 0x3be6, 0x3be7, 0x3be8, 0x3be9, 0x3bea, 0x3beb, 0x3bec,  // Offset: 3870 ~ 3877
0x3bed, 0x3bee, 0x3bef, 0x3bf0, 0x3bf1, 0x3bf2, 0x3bf3, 0x3bf4,  // Offset: 3878 ~ 387f
0x3bf5, 0x3bf6, 0x3bf7, 0x3bf8, 0x3bf9, 0x3bfa, 0x3bfb, 0x3bfc,  // Offset: 3880 ~ 3887
0x3bfd, 0x3bfe, 0x3bff, 0x3c00, 0x3c01, 0x3c02, 0x3c03, 0x3c04,  // Offset: 3888 ~ 388f
0x3c05, 0x3c06, 0x3c07, 0x3c08, 0x3c09, 0x3c0a, 0x3c0b, 0x3c0c,  // Offset: 3890 ~ 3897
0x3c0d, 0x3c0e, 0x3c0f, 0x3c10, 0x3c11, 0x3c12, 0x3c13, 0x3c14,  // Offset: 3898 ~ 389f
0x3c15, 0x3c16, 0x3c17, 0x3c18, 0x3c19, 0x3c1a, 0x3c1b, 0x3c1c,  // Offset: 38a0 ~ 38a7
0x3c1d, 0x3c1e, 0x3c1f, 0x3c20, 0x3c21, 0x3c22, 0x3c23, 0x3c24,  // Offset: 38a8 ~ 38af
0x3c25, 0x3c26, 0x3c27, 0x3c28, 0x3c29, 0x3c2a, 0x3c2b, 0x3c2c,  // Offset: 38b0 ~ 38b7
0x3c2d, 0x3c2e, 0x3c2f, 0x3c30, 0x3c31, 0x3c32, 0x3c33, 0x3c34,  // Offset: 38b8 ~ 38bf
0x3c35, 0x3c36, 0x3c37, 0x3c38, 0x3c39, 0x3c3a, 0x3c3b, 0x3c3c,  // Offset: 38c0 ~ 38c7
0x3c3d, 0x3c3e, 0x3c3f, 0x3c40, 0x3c41, 0x3c42, 0x3c43, 0x3c44,  // Offset: 38c8 ~ 38cf
0x3c45, 0x3c46, 0x3c47, 0x3c48, 0x3c49, 0x3c4a, 0x3c4b, 0x3c4c,  // Offset: 38d0 ~ 38d7
0x3c4d, 0x3c4e, 0x3c4f, 0x3c50, 0x3c51, 0x3c52, 0x3c53, 0x3c54,  // Offset: 38d8 ~ 38df
0x3c55, 0x3c56, 0x3c57, 0x3c58, 0x3c59, 0x3c5a, 0x3c5b, 0x3c5c,  // Offset: 38e0 ~ 38e7
0x3c5d, 0x3c5e, 0x3c5f, 0x3c60, 0x3c61, 0x3c62, 0x3c63, 0x3c64,  // Offset: 38e8 ~ 38ef
0x3c65, 0x3c66, 0x3c67, 0x3c68, 0x3c69, 0x3c6a, 0x3c6b, 0x3c6c,  // Offset: 38f0 ~ 38f7
0x3c6d, 0x3c6f, 0x3c70, 0x3c71, 0x3c72, 0x3c73, 0x3c74, 0x3c75,  // Offset: 38f8 ~ 38ff
0x3c76, 0x3c77, 0x3c78, 0x3c79, 0x3c7a, 0x3c7b, 0x3c7c, 0x3c7d,  // Offset: 3900 ~ 3907
0x3c7e, 0x3c7f, 0x3c80, 0x3c81, 0x3c82, 0x3c83, 0x3c84, 0x3c85,  // Offset: 3908 ~ 390f
0x3c86, 0x3c87, 0x3c88, 0x3c89, 0x3c8a, 0x3c8b, 0x3c8c, 0x3c8d,  // Offset: 3910 ~ 3917
0x3c8e, 0x3c8f, 0x3c90, 0x3c91, 0x3c92, 0x3c93, 0x3c94, 0x3c95,  // Offset: 3918 ~ 391f
0x3c96, 0x3c97, 0x3c98, 0x3c99, 0x3c9a, 0x3c9b, 0x3c9c, 0x3c9d,  // Offset: 3920 ~ 3927
0x3c9e, 0x3c9f, 0x3ca0, 0x3ca1, 0x3ca2, 0x3ca3, 0x3ca4, 0x3ca5,  // Offset: 3928 ~ 392f
0x3ca6, 0x3ca7, 0x3ca8, 0x3ca9, 0x3caa, 0x3cab, 0x3cac, 0x3cad,  // Offset: 3930 ~ 3937
0x3cae, 0x3caf, 0x3cb0, 0x3cb1, 0x3cb2, 0x3cb3, 0x3cb4, 0x3cb5,  // Offset: 3938 ~ 393f
0x3cb6, 0x3cb7, 0x3cb8, 0x3cb9, 0x3cba, 0x3cbb, 0x3cbc, 0x3cbd,  // Offset: 3940 ~ 3947
0x3cbe, 0x3cbf, 0x3cc0, 0x3cc1, 0x3cc2, 0x3cc3, 0x3cc4, 0x3cc5,  // Offset: 3948 ~ 394f
0x3cc6, 0x3cc7, 0x3cc8, 0x3cc9, 0x3cca, 0x3ccb, 0x3ccc, 0x3ccd,  // Offset: 3950 ~ 3957
0x3cce, 0x3ccf, 0x3cd0, 0x3cd1, 0x3cd2, 0x3cd3, 0x3cd4, 0x3cd5,  // Offset: 3958 ~ 395f
0x3cd6, 0x3cd7, 0x3cd8, 0x3cd9, 0x3cda, 0x3cdb, 0x3cdc, 0x3cdd,  // Offset: 3960 ~ 3967
0x3cde, 0x3cdf, 0x3ce1, 0x3ce2, 0x3ce3, 0x3ce4, 0x3ce5, 0x3ce6,  // Offset: 3968 ~ 396f
0x3ce7, 0x3ce8, 0x3ce9, 0x3cea, 0x3ceb, 0x3cec, 0x3ced, 0x3cee,  // Offset: 3970 ~ 3977
0x3cef, 0x3cf0, 0x3cf1, 0x3cf2, 0x3cf3, 0x3cf4, 0x3cf5, 0x3cf6,  // Offset: 3978 ~ 397f
0x3cf7, 0x3cf8, 0x3cf9, 0x3cfa, 0x3cfb, 0x3cfc, 0x3cfd, 0x3cfe,  // Offset: 3980 ~ 3987
0x3cff, 0x3d00, 0x3d01, 0x3d02, 0x3d03, 0x3d04, 0x3d05, 0x3d06,  // Offset: 3988 ~ 398f
0x3d07, 0x3d08, 0x3d09, 0x3d0a, 0x3d0b, 0x3d0c, 0x3d0d, 0x3d0e,  // Offset: 3990 ~ 3997
0x3d0f, 0x3d10, 0x3d11, 0x3d12, 0x3d13, 0x3d14, 0x3d15, 0x3d16,  // Offset: 3998 ~ 399f
0x3d17, 0x3d18, 0x3d19, 0x3d1a, 0x3d1b, 0x3d1c, 0x3d1d, 0x3d1e,  // Offset: 39a0 ~ 39a7
0x3d1f, 0x3d20, 0x3d21, 0x3d22, 0x3d23, 0x3d24, 0x3d25, 0x3d26,  // Offset: 39a8 ~ 39af
0x3d27, 0x3d28, 0x3d29, 0x3d2a, 0x3d2b, 0x3d2c, 0x3d2d, 0x3d2e,  // Offset: 39b0 ~ 39b7
0x3d2f, 0x3d30, 0x3d31, 0x3d32, 0x3d33, 0x3d34, 0x3d35, 0x3d36,  // Offset: 39b8 ~ 39bf
0x3d37, 0x3d38, 0x3d39, 0x3d3a, 0x3d3b, 0x3d3c, 0x3d3d, 0x3d3e,  // Offset: 39c0 ~ 39c7
0x3d3f, 0x3d40, 0x3d41, 0x3d42, 0x3d43, 0x3d44, 0x3d45, 0x3d46,  // Offset: 39c8 ~ 39cf
0x3d47, 0x3d48, 0x3d49, 0x3d4a, 0x3d4b, 0x3d4c, 0x3d4d, 0x3d4e,  // Offset: 39d0 ~ 39d7
0x3d4f, 0x3d50, 0x3d51, 0x3d52, 0x3d53, 0x3d54, 0x3d55, 0x3d56,  // Offset: 39d8 ~ 39df
0x3d57, 0x3d58, 0x3d59, 0x3d5a, 0x3d5b, 0x3d5c, 0x3d5d, 0x3d5e,  // Offset: 39e0 ~ 39e7
0x3d5f, 0x3d60, 0x3d61, 0x3d62, 0x3d63, 0x3d64, 0x3d65, 0x3d66,  // Offset: 39e8 ~ 39ef
0x3d67, 0x3d68, 0x3d69, 0x3d6a, 0x3d6b, 0x3d6c, 0x3d6d, 0x3d6e,  // Offset: 39f0 ~ 39f7
0x3d6f, 0x3d70, 0x3d71, 0x3d72, 0x3d73, 0x3d74, 0x3d75, 0x3d76,  // Offset: 39f8 ~ 39ff
0x3d77, 0x3d78, 0x3d79, 0x3d7a, 0x3d7b, 0x3d7c, 0x3d7d, 0x3d7e,  // Offset: 3a00 ~ 3a07
0x3d7f, 0x3d80, 0x3d81, 0x3d82, 0x3d83, 0x3d84, 0x3d85, 0x3d86,  // Offset: 3a08 ~ 3a0f
0x3d87, 0x3d88, 0x3d89, 0x3d8a, 0x3d8b, 0x3d8c, 0x3d8d, 0x3d8e,  // Offset: 3a10 ~ 3a17
0x3d8f, 0x3d90, 0x3d91, 0x3d92, 0x3d93, 0x3d94, 0x3d95, 0x3d96,  // Offset: 3a18 ~ 3a1f
0x3d97, 0x3d98, 0x3d99, 0x3d9a, 0x3d9b, 0x3d9c, 0x3d9d, 0x3d9e,  // Offset: 3a20 ~ 3a27
0x3d9f, 0x3da0, 0x3da1, 0x3da2, 0x3da3, 0x3da4, 0x3da5, 0x3da6,  // Offset: 3a28 ~ 3a2f
0x3da7, 0x3da8, 0x3da9, 0x3daa, 0x3dab, 0x3dac, 0x3dad, 0x3dae,  // Offset: 3a30 ~ 3a37
0x3daf, 0x3db0, 0x3db1, 0x3db2, 0x3db3, 0x3db4, 0x3db5, 0x3db6,  // Offset: 3a38 ~ 3a3f
0x3db7, 0x3db8, 0x3db9, 0x3dba, 0x3dbb, 0x3dbc, 0x3dbd, 0x3dbe,  // Offset: 3a40 ~ 3a47
0x3dbf, 0x3dc0, 0x3dc1, 0x3dc2, 0x3dc3, 0x3dc4, 0x3dc5, 0x3dc6,  // Offset: 3a48 ~ 3a4f
0x3dc7, 0x3dc8, 0x3dc9, 0x3dca, 0x3dcb, 0x3dcc, 0x3dcd, 0x3dce,  // Offset: 3a50 ~ 3a57
0x3dcf, 0x3dd0, 0x3dd1, 0x3dd2, 0x3dd3, 0x3dd4, 0x3dd5, 0x3dd6,  // Offset: 3a58 ~ 3a5f
0x3dd7, 0x3dd8, 0x3dd9, 0x3dda, 0x3ddb, 0x3ddc, 0x3ddd, 0x3dde,  // Offset: 3a60 ~ 3a67
0x3ddf, 0x3de0, 0x3de1, 0x3de2, 0x3de3, 0x3de4, 0x3de5, 0x3de6,  // Offset: 3a68 ~ 3a6f
0x3de7, 0x3de8, 0x3de9, 0x3dea, 0x3deb, 0x3dec, 0x3ded, 0x3dee,  // Offset: 3a70 ~ 3a77
0x3def, 0x3df0, 0x3df1, 0x3df2, 0x3df3, 0x3df4, 0x3df5, 0x3df6,  // Offset: 3a78 ~ 3a7f
0x3df7, 0x3df8, 0x3df9, 0x3dfa, 0x3dfb, 0x3dfc, 0x3dfd, 0x3dfe,  // Offset: 3a80 ~ 3a87
0x3dff, 0x3e00, 0x3e01, 0x3e02, 0x3e03, 0x3e04, 0x3e05, 0x3e06,  // Offset: 3a88 ~ 3a8f
0x3e07, 0x3e08, 0x3e09, 0x3e0a, 0x3e0b, 0x3e0c, 0x3e0d, 0x3e0e,  // Offset: 3a90 ~ 3a97
0x3e0f, 0x3e10, 0x3e11, 0x3e12, 0x3e13, 0x3e14, 0x3e15, 0x3e16,  // Offset: 3a98 ~ 3a9f
0x3e17, 0x3e18, 0x3e19, 0x3e1a, 0x3e1b, 0x3e1c, 0x3e1d, 0x3e1e,  // Offset: 3aa0 ~ 3aa7
0x3e1f, 0x3e20, 0x3e21, 0x3e22, 0x3e23, 0x3e24, 0x3e25, 0x3e26,  // Offset: 3aa8 ~ 3aaf
0x3e27, 0x3e28, 0x3e29, 0x3e2a, 0x3e2b, 0x3e2c, 0x3e2d, 0x3e2e,  // Offset: 3ab0 ~ 3ab7
0x3e2f, 0x3e30, 0x3e31, 0x3e32, 0x3e33, 0x3e34, 0x3e35, 0x3e36,  // Offset: 3ab8 ~ 3abf
0x3e37, 0x3e38, 0x3e39, 0x3e3a, 0x3e3b, 0x3e3c, 0x3e3d, 0x3e3e,  // Offset: 3ac0 ~ 3ac7
0x3e3f, 0x3e40, 0x3e41, 0x3e42, 0x3e43, 0x3e44, 0x3e45, 0x3e46,  // Offset: 3ac8 ~ 3acf
0x3e47, 0x3e48, 0x3e49, 0x3e4a, 0x3e4b, 0x3e4c, 0x3e4d, 0x3e4e,  // Offset: 3ad0 ~ 3ad7
0x3e4f, 0x3e50, 0x3e51, 0x3e52, 0x3e53, 0x3e54, 0x3e55, 0x3e56,  // Offset: 3ad8 ~ 3adf
0x3e57, 0x3e58, 0x3e59, 0x3e5a, 0x3e5b, 0x3e5c, 0x3e5d, 0x3e5e,  // Offset: 3ae0 ~ 3ae7
0x3e5f, 0x3e60, 0x3e61, 0x3e62, 0x3e63, 0x3e64, 0x3e65, 0x3e66,  // Offset: 3ae8 ~ 3aef
0x3e67, 0x3e68, 0x3e69, 0x3e6a, 0x3e6b, 0x3e6c, 0x3e6d, 0x3e6e,  // Offset: 3af0 ~ 3af7
0x3e6f, 0x3e70, 0x3e71, 0x3e72, 0x3e73, 0x3e74, 0x3e75, 0x3e76,  // Offset: 3af8 ~ 3aff
0x3e77, 0x3e78, 0x3e79, 0x3e7a, 0x3e7b, 0x3e7c, 0x3e7d, 0x3e7e,  // Offset: 3b00 ~ 3b07
0x3e7f, 0x3e80, 0x3e81, 0x3e82, 0x3e83, 0x3e84, 0x3e85, 0x3e86,  // Offset: 3b08 ~ 3b0f
0x3e87, 0x3e88, 0x3e89, 0x3e8a, 0x3e8b, 0x3e8c, 0x3e8d, 0x3e8e,  // Offset: 3b10 ~ 3b17
0x3e8f, 0x3e90, 0x3e91, 0x3e92, 0x3e93, 0x3e94, 0x3e95, 0x3e96,  // Offset: 3b18 ~ 3b1f
0x3e97, 0x3e98, 0x3e99, 0x3e9a, 0x3e9b, 0x3e9c, 0x3e9d, 0x3e9e,  // Offset: 3b20 ~ 3b27
0x3e9f, 0x3ea0, 0x3ea1, 0x3ea2, 0x3ea3, 0x3ea4, 0x3ea5, 0x3ea6,  // Offset: 3b28 ~ 3b2f
0x3ea7, 0x3ea8, 0x3ea9, 0x3eaa, 0x3eab, 0x3eac, 0x3ead, 0x3eae,  // Offset: 3b30 ~ 3b37
0x3eaf, 0x3eb0, 0x3eb1, 0x3eb2, 0x3eb3, 0x3eb4, 0x3eb5, 0x3eb6,  // Offset: 3b38 ~ 3b3f
0x3eb7, 0x3eb8, 0x3eb9, 0x3eba, 0x3ebb, 0x3ebc, 0x3ebd, 0x3ebe,  // Offset: 3b40 ~ 3b47
0x3ebf, 0x3ec0, 0x3ec1, 0x3ec2, 0x3ec3, 0x3ec4, 0x3ec5, 0x3ec6,  // Offset: 3b48 ~ 3b4f
0x3ec7, 0x3ec8, 0x3ec9, 0x3eca, 0x3ecb, 0x3ecc, 0x3ecd, 0x3ece,  // Offset: 3b50 ~ 3b57
0x3ecf, 0x3ed0, 0x3ed1, 0x3ed2, 0x3ed3, 0x3ed4, 0x3ed5, 0x3ed6,  // Offset: 3b58 ~ 3b5f
0x3ed7, 0x3ed8, 0x3ed9, 0x3eda, 0x3edb, 0x3edc, 0x3edd, 0x3ede,  // Offset: 3b60 ~ 3b67
0x3edf, 0x3ee0, 0x3ee1, 0x3ee2, 0x3ee3, 0x3ee4, 0x3ee5, 0x3ee6,  // Offset: 3b68 ~ 3b6f
0x3ee7, 0x3ee8, 0x3ee9, 0x3eea, 0x3eeb, 0x3eec, 0x3eed, 0x3eee,  // Offset: 3b70 ~ 3b77
0x3eef, 0x3ef0, 0x3ef1, 0x3ef2, 0x3ef3, 0x3ef4, 0x3ef5, 0x3ef6,  // Offset: 3b78 ~ 3b7f
0x3ef7, 0x3ef8, 0x3ef9, 0x3efa, 0x3efb, 0x3efc, 0x3efd, 0x3efe,  // Offset: 3b80 ~ 3b87
0x3eff, 0x3f00, 0x3f01, 0x3f02, 0x3f03, 0x3f04, 0x3f05, 0x3f06,  // Offset: 3b88 ~ 3b8f
0x3f07, 0x3f08, 0x3f09, 0x3f0a, 0x3f0b, 0x3f0c, 0x3f0d, 0x3f0e,  // Offset: 3b90 ~ 3b97
0x3f0f, 0x3f10, 0x3f11, 0x3f12, 0x3f13, 0x3f14, 0x3f15, 0x3f16,  // Offset: 3b98 ~ 3b9f
0x3f17, 0x3f18, 0x3f19, 0x3f1a, 0x3f1b, 0x3f1c, 0x3f1d, 0x3f1e,  // Offset: 3ba0 ~ 3ba7
0x3f1f, 0x3f20, 0x3f21, 0x3f22, 0x3f23, 0x3f24, 0x3f25, 0x3f26,  // Offset: 3ba8 ~ 3baf
0x3f27, 0x3f28, 0x3f29, 0x3f2a, 0x3f2b, 0x3f2c, 0x3f2d, 0x3f2e,  // Offset: 3bb0 ~ 3bb7
0x3f2f, 0x3f30, 0x3f31, 0x3f32, 0x3f33, 0x3f34, 0x3f35, 0x3f36,  // Offset: 3bb8 ~ 3bbf
0x3f37, 0x3f38, 0x3f39, 0x3f3a, 0x3f3b, 0x3f3c, 0x3f3d, 0x3f3e,  // Offset: 3bc0 ~ 3bc7
0x3f3f, 0x3f40, 0x3f41, 0x3f42, 0x3f43, 0x3f44, 0x3f45, 0x3f46,  // Offset: 3bc8 ~ 3bcf
0x3f47, 0x3f48, 0x3f49, 0x3f4a, 0x3f4b, 0x3f4c, 0x3f4d, 0x3f4e,  // Offset: 3bd0 ~ 3bd7
0x3f4f, 0x3f50, 0x3f51, 0x3f52, 0x3f53, 0x3f54, 0x3f55, 0x3f56,  // Offset: 3bd8 ~ 3bdf
0x3f57, 0x3f58, 0x3f59, 0x3f5a, 0x3f5b, 0x3f5c, 0x3f5d, 0x3f5e,  // Offset: 3be0 ~ 3be7
0x3f5f, 0x3f60, 0x3f61, 0x3f62, 0x3f63, 0x3f64, 0x3f65, 0x3f66,  // Offset: 3be8 ~ 3bef
0x3f67, 0x3f68, 0x3f69, 0x3f6a, 0x3f6b, 0x3f6c, 0x3f6d, 0x3f6e,  // Offset: 3bf0 ~ 3bf7
0x3f6f, 0x3f70, 0x3f71, 0x3f72, 0x3f73, 0x3f74, 0x3f75, 0x3f76,  // Offset: 3bf8 ~ 3bff
0x3f77, 0x3f78, 0x3f79, 0x3f7a, 0x3f7b, 0x3f7c, 0x3f7d, 0x3f7e,  // Offset: 3c00 ~ 3c07
0x3f7f, 0x3f80, 0x3f81, 0x3f82, 0x3f83, 0x3f84, 0x3f85, 0x3f86,  // Offset: 3c08 ~ 3c0f
0x3f87, 0x3f88, 0x3f89, 0x3f8a, 0x3f8b, 0x3f8c, 0x3f8d, 0x3f8e,  // Offset: 3c10 ~ 3c17
0x3f8f, 0x3f90, 0x3f91, 0x3f92, 0x3f93, 0x3f94, 0x3f95, 0x3f96,  // Offset: 3c18 ~ 3c1f
0x3f97, 0x3f98, 0x3f99, 0x3f9a, 0x3f9b, 0x3f9c, 0x3f9d, 0x3f9e,  // Offset: 3c20 ~ 3c27
0x3f9f, 0x3fa0, 0x3fa1, 0x3fa2, 0x3fa3, 0x3fa4, 0x3fa5, 0x3fa6,  // Offset: 3c28 ~ 3c2f
0x3fa7, 0x3fa8, 0x3fa9, 0x3faa, 0x3fab, 0x3fac, 0x3fad, 0x3fae,  // Offset: 3c30 ~ 3c37
0x3faf, 0x3fb0, 0x3fb1, 0x3fb2, 0x3fb3, 0x3fb4, 0x3fb5, 0x3fb6,  // Offset: 3c38 ~ 3c3f
0x3fb7, 0x3fb8, 0x3fb9, 0x3fba, 0x3fbb, 0x3fbc, 0x3fbd, 0x3fbe,  // Offset: 3c40 ~ 3c47
0x3fbf, 0x3fc0, 0x3fc1, 0x3fc2, 0x3fc3, 0x3fc4, 0x3fc5, 0x3fc6,  // Offset: 3c48 ~ 3c4f
0x3fc7, 0x3fc8, 0x3fc9, 0x3fca, 0x3fcb, 0x3fcc, 0x3fcd, 0x3fce,  // Offset: 3c50 ~ 3c57
0x3fcf, 0x3fd0, 0x3fd1, 0x3fd2, 0x3fd3, 0x3fd4, 0x3fd5, 0x3fd6,  // Offset: 3c58 ~ 3c5f
0x3fd7, 0x3fd8, 0x3fd9, 0x3fda, 0x3fdb, 0x3fdc, 0x3fdd, 0x3fde,  // Offset: 3c60 ~ 3c67
0x3fdf, 0x3fe0, 0x3fe1, 0x3fe2, 0x3fe3, 0x3fe4, 0x3fe5, 0x3fe6,  // Offset: 3c68 ~ 3c6f
0x3fe7, 0x3fe8, 0x3fe9, 0x3fea, 0x3feb, 0x3fec, 0x3fed, 0x3fee,  // Offset: 3c70 ~ 3c77
0x3fef, 0x3ff0, 0x3ff1, 0x3ff2, 0x3ff3, 0x3ff4, 0x3ff5, 0x3ff6,  // Offset: 3c78 ~ 3c7f
0x3ff7, 0x3ff8, 0x3ff9, 0x3ffa, 0x3ffb, 0x3ffc, 0x3ffd, 0x3ffe,  // Offset: 3c80 ~ 3c87
0x3fff, 0x4000, 0x4001, 0x4002, 0x4003, 0x4004, 0x4005, 0x4006,  // Offset: 3c88 ~ 3c8f
0x4007, 0x4008, 0x4009, 0x400a, 0x400b, 0x400c, 0x400d, 0x400e,  // Offset: 3c90 ~ 3c97
0x400f, 0x4010, 0x4011, 0x4012, 0x4013, 0x4014, 0x4015, 0x4016,  // Offset: 3c98 ~ 3c9f
0x4017, 0x4018, 0x4019, 0x401a, 0x401b, 0x401c, 0x401d, 0x401e,  // Offset: 3ca0 ~ 3ca7
0x401f, 0x4020, 0x4021, 0x4022, 0x4023, 0x4024, 0x4025, 0x4026,  // Offset: 3ca8 ~ 3caf
0x4027, 0x4028, 0x4029, 0x402a, 0x402b, 0x402c, 0x402d, 0x402e,  // Offset: 3cb0 ~ 3cb7
0x402f, 0x4030, 0x4031, 0x4032, 0x4033, 0x4034, 0x4035, 0x4036,  // Offset: 3cb8 ~ 3cbf
0x4037, 0x4038, 0x4039, 0x403a, 0x403b, 0x403c, 0x403d, 0x403e,  // Offset: 3cc0 ~ 3cc7
0x403f, 0x4040, 0x4041, 0x4042, 0x4043, 0x4044, 0x4045, 0x4046,  // Offset: 3cc8 ~ 3ccf
0x4047, 0x4048, 0x4049, 0x404a, 0x404b, 0x404c, 0x404d, 0x404e,  // Offset: 3cd0 ~ 3cd7
0x404f, 0x4050, 0x4051, 0x4052, 0x4053, 0x4054, 0x4055, 0x4057,  // Offset: 3cd8 ~ 3cdf
0x4058, 0x4059, 0x405a, 0x405b, 0x405c, 0x405d, 0x405e, 0x405f,  // Offset: 3ce0 ~ 3ce7
0x4060, 0x4061, 0x4062, 0x4063, 0x4064, 0x4065, 0x4066, 0x4067,  // Offset: 3ce8 ~ 3cef
0x4068, 0x4069, 0x406a, 0x406b, 0x406c, 0x406d, 0x406e, 0x406f,  // Offset: 3cf0 ~ 3cf7
0x4070, 0x4071, 0x4072, 0x4073, 0x4074, 0x4075, 0x4076, 0x4077,  // Offset: 3cf8 ~ 3cff
0x4078, 0x4079, 0x407a, 0x407b, 0x407c, 0x407d, 0x407e, 0x407f,  // Offset: 3d00 ~ 3d07
0x4080, 0x4081, 0x4082, 0x4083, 0x4084, 0x4085, 0x4086, 0x4087,  // Offset: 3d08 ~ 3d0f
0x4088, 0x4089, 0x408a, 0x408b, 0x408c, 0x408d, 0x408e, 0x408f,  // Offset: 3d10 ~ 3d17
0x4090, 0x4091, 0x4092, 0x4093, 0x4094, 0x4095, 0x4096, 0x4097,  // Offset: 3d18 ~ 3d1f
0x4098, 0x4099, 0x409a, 0x409b, 0x409c, 0x409d, 0x409e, 0x409f,  // Offset: 3d20 ~ 3d27
0x40a0, 0x40a1, 0x40a2, 0x40a3, 0x40a4, 0x40a5, 0x40a6, 0x40a7,  // Offset: 3d28 ~ 3d2f
0x40a8, 0x40a9, 0x40aa, 0x40ab, 0x40ac, 0x40ad, 0x40ae, 0x40af,  // Offset: 3d30 ~ 3d37
0x40b0, 0x40b1, 0x40b2, 0x40b3, 0x40b4, 0x40b5, 0x40b6, 0x40b7,  // Offset: 3d38 ~ 3d3f
0x40b8, 0x40b9, 0x40ba, 0x40bb, 0x40bc, 0x40bd, 0x40be, 0x40bf,  // Offset: 3d40 ~ 3d47
0x40c0, 0x40c1, 0x40c2, 0x40c3, 0x40c4, 0x40c5, 0x40c6, 0x40c7,  // Offset: 3d48 ~ 3d4f
0x40c8, 0x40c9, 0x40ca, 0x40cb, 0x40cc, 0x40cd, 0x40ce, 0x40cf,  // Offset: 3d50 ~ 3d57
0x40d0, 0x40d1, 0x40d2, 0x40d3, 0x40d4, 0x40d5, 0x40d6, 0x40d7,  // Offset: 3d58 ~ 3d5f
0x40d8, 0x40d9, 0x40da, 0x40db, 0x40dc, 0x40dd, 0x40de, 0x40df,  // Offset: 3d60 ~ 3d67
0x40e0, 0x40e1, 0x40e2, 0x40e3, 0x40e4, 0x40e5, 0x40e6, 0x40e7,  // Offset: 3d68 ~ 3d6f
0x40e8, 0x40e9, 0x40ea, 0x40eb, 0x40ec, 0x40ed, 0x40ee, 0x40ef,  // Offset: 3d70 ~ 3d77
0x40f0, 0x40f1, 0x40f2, 0x40f3, 0x40f4, 0x40f5, 0x40f6, 0x40f7,  // Offset: 3d78 ~ 3d7f
0x40f8, 0x40f9, 0x40fa, 0x40fb, 0x40fc, 0x40fd, 0x40fe, 0x40ff,  // Offset: 3d80 ~ 3d87
0x4100, 0x4101, 0x4102, 0x4103, 0x4104, 0x4105, 0x4106, 0x4107,  // Offset: 3d88 ~ 3d8f
0x4108, 0x4109, 0x410a, 0x410b, 0x410c, 0x410d, 0x410e, 0x410f,  // Offset: 3d90 ~ 3d97
0x4110, 0x4111, 0x4112, 0x4113, 0x4114, 0x4115, 0x4116, 0x4117,  // Offset: 3d98 ~ 3d9f
0x4118, 0x4119, 0x411a, 0x411b, 0x411c, 0x411d, 0x411e, 0x411f,  // Offset: 3da0 ~ 3da7
0x4120, 0x4121, 0x4122, 0x4123, 0x4124, 0x4125, 0x4126, 0x4127,  // Offset: 3da8 ~ 3daf
0x4128, 0x4129, 0x412a, 0x412b, 0x412c, 0x412d, 0x412e, 0x412f,  // Offset: 3db0 ~ 3db7
0x4130, 0x4131, 0x4132, 0x4133, 0x4134, 0x4135, 0x4136, 0x4137,  // Offset: 3db8 ~ 3dbf
0x4138, 0x4139, 0x413a, 0x413b, 0x413c, 0x413d, 0x413e, 0x413f,  // Offset: 3dc0 ~ 3dc7
0x4140, 0x4141, 0x4142, 0x4143, 0x4144, 0x4145, 0x4146, 0x4147,  // Offset: 3dc8 ~ 3dcf
0x4148, 0x4149, 0x414a, 0x414b, 0x414c, 0x414d, 0x414e, 0x414f,  // Offset: 3dd0 ~ 3dd7
0x4150, 0x4151, 0x4152, 0x4153, 0x4154, 0x4155, 0x4156, 0x4157,  // Offset: 3dd8 ~ 3ddf
0x4158, 0x4159, 0x415a, 0x415b, 0x415c, 0x415d, 0x415e, 0x4160,  // Offset: 3de0 ~ 3de7
0x4161, 0x4162, 0x4163, 0x4164, 0x4165, 0x4166, 0x4167, 0x4168,  // Offset: 3de8 ~ 3def
0x4169, 0x416a, 0x416b, 0x416c, 0x416d, 0x416e, 0x416f, 0x4170,  // Offset: 3df0 ~ 3df7
0x4171, 0x4172, 0x4173, 0x4174, 0x4175, 0x4176, 0x4177, 0x4178,  // Offset: 3df8 ~ 3dff
0x4179, 0x417a, 0x417b, 0x417c, 0x417d, 0x417e, 0x417f, 0x4180,  // Offset: 3e00 ~ 3e07
0x4181, 0x4182, 0x4183, 0x4184, 0x4185, 0x4186, 0x4187, 0x4188,  // Offset: 3e08 ~ 3e0f
0x4189, 0x418a, 0x418b, 0x418c, 0x418d, 0x418e, 0x418f, 0x4190,  // Offset: 3e10 ~ 3e17
0x4191, 0x4192, 0x4193, 0x4194, 0x4195, 0x4196, 0x4197, 0x4198,  // Offset: 3e18 ~ 3e1f
0x4199, 0x419a, 0x419b, 0x419c, 0x419d, 0x419e, 0x419f, 0x41a0,  // Offset: 3e20 ~ 3e27
0x41a1, 0x41a2, 0x41a3, 0x41a4, 0x41a5, 0x41a6, 0x41a7, 0x41a8,  // Offset: 3e28 ~ 3e2f
0x41a9, 0x41aa, 0x41ab, 0x41ac, 0x41ad, 0x41ae, 0x41af, 0x41b0,  // Offset: 3e30 ~ 3e37
0x41b1, 0x41b2, 0x41b3, 0x41b4, 0x41b5, 0x41b6, 0x41b7, 0x41b8,  // Offset: 3e38 ~ 3e3f
0x41b9, 0x41ba, 0x41bb, 0x41bc, 0x41bd, 0x41be, 0x41bf, 0x41c0,  // Offset: 3e40 ~ 3e47
0x41c1, 0x41c2, 0x41c3, 0x41c4, 0x41c5, 0x41c6, 0x41c7, 0x41c8,  // Offset: 3e48 ~ 3e4f
0x41c9, 0x41ca, 0x41cb, 0x41cc, 0x41cd, 0x41ce, 0x41cf, 0x41d0,  // Offset: 3e50 ~ 3e57
0x41d1, 0x41d2, 0x41d3, 0x41d4, 0x41d5, 0x41d6, 0x41d7, 0x41d8,  // Offset: 3e58 ~ 3e5f
0x41d9, 0x41da, 0x41db, 0x41dc, 0x41dd, 0x41de, 0x41df, 0x41e0,  // Offset: 3e60 ~ 3e67
0x41e1, 0x41e2, 0x41e3, 0x41e4, 0x41e5, 0x41e6, 0x41e7, 0x41e8,  // Offset: 3e68 ~ 3e6f
0x41e9, 0x41ea, 0x41eb, 0x41ec, 0x41ed, 0x41ee, 0x41ef, 0x41f0,  // Offset: 3e70 ~ 3e77
0x41f1, 0x41f2, 0x41f3, 0x41f4, 0x41f5, 0x41f6, 0x41f7, 0x41f8,  // Offset: 3e78 ~ 3e7f
0x41f9, 0x41fa, 0x41fb, 0x41fc, 0x41fd, 0x41fe, 0x41ff, 0x4200,  // Offset: 3e80 ~ 3e87
0x4201, 0x4202, 0x4203, 0x4204, 0x4205, 0x4206, 0x4207, 0x4208,  // Offset: 3e88 ~ 3e8f
0x4209, 0x420a, 0x420b, 0x420c, 0x420d, 0x420e, 0x420f, 0x4210,  // Offset: 3e90 ~ 3e97
0x4211, 0x4212, 0x4213, 0x4214, 0x4215, 0x4216, 0x4217, 0x4218,  // Offset: 3e98 ~ 3e9f
0x4219, 0x421a, 0x421b, 0x421c, 0x421d, 0x421e, 0x421f, 0x4220,  // Offset: 3ea0 ~ 3ea7
0x4221, 0x4222, 0x4223, 0x4224, 0x4225, 0x4226, 0x4227, 0x4228,  // Offset: 3ea8 ~ 3eaf
0x4229, 0x422a, 0x422b, 0x422c, 0x422d, 0x422e, 0x422f, 0x4230,  // Offset: 3eb0 ~ 3eb7
0x4231, 0x4232, 0x4233, 0x4234, 0x4235, 0x4236, 0x4237, 0x4238,  // Offset: 3eb8 ~ 3ebf
0x4239, 0x423a, 0x423b, 0x423c, 0x423d, 0x423e, 0x423f, 0x4240,  // Offset: 3ec0 ~ 3ec7
0x4241, 0x4242, 0x4243, 0x4244, 0x4245, 0x4246, 0x4247, 0x4248,  // Offset: 3ec8 ~ 3ecf
0x4249, 0x424a, 0x424b, 0x424c, 0x424d, 0x424e, 0x424f, 0x4250,  // Offset: 3ed0 ~ 3ed7
0x4251, 0x4252, 0x4253, 0x4254, 0x4255, 0x4256, 0x4257, 0x4258,  // Offset: 3ed8 ~ 3edf
0x4259, 0x425a, 0x425b, 0x425c, 0x425d, 0x425e, 0x425f, 0x4260,  // Offset: 3ee0 ~ 3ee7
0x4261, 0x4262, 0x4263, 0x4264, 0x4265, 0x4266, 0x4267, 0x4268,  // Offset: 3ee8 ~ 3eef
0x4269, 0x426a, 0x426b, 0x426c, 0x426d, 0x426e, 0x426f, 0x4270,  // Offset: 3ef0 ~ 3ef7
0x4271, 0x4272, 0x4273, 0x4274, 0x4275, 0x4276, 0x4277, 0x4278,  // Offset: 3ef8 ~ 3eff
0x4279, 0x427a, 0x427b, 0x427c, 0x427d, 0x427e, 0x427f, 0x4280,  // Offset: 3f00 ~ 3f07
0x4281, 0x4282, 0x4283, 0x4284, 0x4285, 0x4286, 0x4287, 0x4288,  // Offset: 3f08 ~ 3f0f
0x4289, 0x428a, 0x428b, 0x428c, 0x428d, 0x428e, 0x428f, 0x4290,  // Offset: 3f10 ~ 3f17
0x4291, 0x4292, 0x4293, 0x4294, 0x4295, 0x4296, 0x4297, 0x4298,  // Offset: 3f18 ~ 3f1f
0x4299, 0x429a, 0x429b, 0x429c, 0x429d, 0x429e, 0x429f, 0x42a0,  // Offset: 3f20 ~ 3f27
0x42a1, 0x42a2, 0x42a3, 0x42a4, 0x42a5, 0x42a6, 0x42a7, 0x42a8,  // Offset: 3f28 ~ 3f2f
0x42a9, 0x42aa, 0x42ab, 0x42ac, 0x42ad, 0x42ae, 0x42af, 0x42b0,  // Offset: 3f30 ~ 3f37
0x42b1, 0x42b2, 0x42b3, 0x42b4, 0x42b5, 0x42b6, 0x42b7, 0x42b8,  // Offset: 3f38 ~ 3f3f
0x42b9, 0x42ba, 0x42bb, 0x42bc, 0x42bd, 0x42be, 0x42bf, 0x42c0,  // Offset: 3f40 ~ 3f47
0x42c1, 0x42c2, 0x42c3, 0x42c4, 0x42c5, 0x42c6, 0x42c7, 0x42c8,  // Offset: 3f48 ~ 3f4f
0x42c9, 0x42ca, 0x42cb, 0x42cc, 0x42cd, 0x42ce, 0x42cf, 0x42d0,  // Offset: 3f50 ~ 3f57
0x42d1, 0x42d2, 0x42d3, 0x42d4, 0x42d5, 0x42d6, 0x42d7, 0x42d8,  // Offset: 3f58 ~ 3f5f
0x42d9, 0x42da, 0x42db, 0x42dc, 0x42dd, 0x42de, 0x42df, 0x42e0,  // Offset: 3f60 ~ 3f67
0x42e1, 0x42e2, 0x42e3, 0x42e4, 0x42e5, 0x42e6, 0x42e7, 0x42e8,  // Offset: 3f68 ~ 3f6f
0x42e9, 0x42ea, 0x42eb, 0x42ec, 0x42ed, 0x42ee, 0x42ef, 0x42f0,  // Offset: 3f70 ~ 3f77
0x42f1, 0x42f2, 0x42f3, 0x42f4, 0x42f5, 0x42f6, 0x42f7, 0x42f8,  // Offset: 3f78 ~ 3f7f
0x42f9, 0x42fa, 0x42fb, 0x42fc, 0x42fd, 0x42fe, 0x42ff, 0x4300,  // Offset: 3f80 ~ 3f87
0x4301, 0x4302, 0x4303, 0x4304, 0x4305, 0x4306, 0x4307, 0x4308,  // Offset: 3f88 ~ 3f8f
0x4309, 0x430a, 0x430b, 0x430c, 0x430d, 0x430e, 0x430f, 0x4310,  // Offset: 3f90 ~ 3f97
0x4311, 0x4312, 0x4313, 0x4314, 0x4315, 0x4316, 0x4317, 0x4318,  // Offset: 3f98 ~ 3f9f
0x4319, 0x431a, 0x431b, 0x431c, 0x431d, 0x431e, 0x431f, 0x4320,  // Offset: 3fa0 ~ 3fa7
0x4321, 0x4322, 0x4323, 0x4324, 0x4325, 0x4326, 0x4327, 0x4328,  // Offset: 3fa8 ~ 3faf
0x4329, 0x432a, 0x432b, 0x432c, 0x432d, 0x432e, 0x432f, 0x4330,  // Offset: 3fb0 ~ 3fb7
0x4331, 0x4332, 0x4333, 0x4334, 0x4335, 0x4336, 0x4338, 0x4339,  // Offset: 3fb8 ~ 3fbf
0x433a, 0x433b, 0x433c, 0x433d, 0x433e, 0x433f, 0x4340, 0x4341,  // Offset: 3fc0 ~ 3fc7
0x4342, 0x4343, 0x4344, 0x4345, 0x4346, 0x4347, 0x4348, 0x4349,  // Offset: 3fc8 ~ 3fcf
0x434a, 0x434b, 0x434c, 0x434d, 0x434e, 0x434f, 0x4350, 0x4351,  // Offset: 3fd0 ~ 3fd7
0x4352, 0x4353, 0x4354, 0x4355, 0x4356, 0x4357, 0x4358, 0x4359,  // Offset: 3fd8 ~ 3fdf
0x435a, 0x435b, 0x435c, 0x435d, 0x435e, 0x435f, 0x4360, 0x4361,  // Offset: 3fe0 ~ 3fe7
0x4362, 0x4363, 0x4364, 0x4365, 0x4366, 0x4367, 0x4368, 0x4369,  // Offset: 3fe8 ~ 3fef
0x436a, 0x436b, 0x436c, 0x436d, 0x436e, 0x436f, 0x4370, 0x4371,  // Offset: 3ff0 ~ 3ff7
0x4372, 0x4373, 0x4374, 0x4375, 0x4376, 0x4377, 0x4378, 0x4379,  // Offset: 3ff8 ~ 3fff
0x437a, 0x437b, 0x437c, 0x437d, 0x437e, 0x437f, 0x4380, 0x4381,  // Offset: 4000 ~ 4007
0x4382, 0x4383, 0x4384, 0x4385, 0x4386, 0x4387, 0x4388, 0x4389,  // Offset: 4008 ~ 400f
0x438a, 0x438b, 0x438c, 0x438d, 0x438e, 0x438f, 0x4390, 0x4391,  // Offset: 4010 ~ 4017
0x4392, 0x4393, 0x4394, 0x4395, 0x4396, 0x4397, 0x4398, 0x4399,  // Offset: 4018 ~ 401f
0x439a, 0x439b, 0x439c, 0x439d, 0x439e, 0x439f, 0x43a0, 0x43a1,  // Offset: 4020 ~ 4027
0x43a2, 0x43a3, 0x43a4, 0x43a5, 0x43a6, 0x43a7, 0x43a8, 0x43a9,  // Offset: 4028 ~ 402f
0x43aa, 0x43ab, 0x43ad, 0x43ae, 0x43af, 0x43b0, 0x43b2, 0x43b3,  // Offset: 4030 ~ 4037
0x43b4, 0x43b5, 0x43b6, 0x43b7, 0x43b8, 0x43b9, 0x43ba, 0x43bb,  // Offset: 4038 ~ 403f
0x43bc, 0x43bd, 0x43be, 0x43bf, 0x43c0, 0x43c1, 0x43c2, 0x43c3,  // Offset: 4040 ~ 4047
0x43c4, 0x43c5, 0x43c6, 0x43c7, 0x43c8, 0x43c9, 0x43ca, 0x43cb,  // Offset: 4048 ~ 404f
0x43cc, 0x43cd, 0x43ce, 0x43cf, 0x43d0, 0x43d1, 0x43d2, 0x43d3,  // Offset: 4050 ~ 4057
0x43d4, 0x43d5, 0x43d6, 0x43d7, 0x43d8, 0x43d9, 0x43da, 0x43db,  // Offset: 4058 ~ 405f
0x43dc, 0x43de, 0x43df, 0x43e0, 0x43e1, 0x43e2, 0x43e3, 0x43e4,  // Offset: 4060 ~ 4067
0x43e5, 0x43e6, 0x43e7, 0x43e8, 0x43e9, 0x43ea, 0x43eb, 0x43ec,  // Offset: 4068 ~ 406f
0x43ed, 0x43ee, 0x43ef, 0x43f0, 0x43f1, 0x43f2, 0x43f3, 0x43f4,  // Offset: 4070 ~ 4077
0x43f5, 0x43f6, 0x43f7, 0x43f8, 0x43f9, 0x43fa, 0x43fb, 0x43fc,  // Offset: 4078 ~ 407f
0x43fd, 0x43fe, 0x43ff, 0x4400, 0x4401, 0x4402, 0x4403, 0x4404,  // Offset: 4080 ~ 4087
0x4405, 0x4406, 0x4407, 0x4408, 0x4409, 0x440a, 0x440b, 0x440c,  // Offset: 4088 ~ 408f
0x440d, 0x440e, 0x440f, 0x4410, 0x4411, 0x4412, 0x4413, 0x4414,  // Offset: 4090 ~ 4097
0x4415, 0x4416, 0x4417, 0x4418, 0x4419, 0x441a, 0x441b, 0x441c,  // Offset: 4098 ~ 409f
0x441d, 0x441e, 0x441f, 0x4420, 0x4421, 0x4422, 0x4423, 0x4424,  // Offset: 40a0 ~ 40a7
0x4425, 0x4426, 0x4427, 0x4428, 0x4429, 0x442a, 0x442b, 0x442c,  // Offset: 40a8 ~ 40af
0x442d, 0x442e, 0x442f, 0x4430, 0x4431, 0x4432, 0x4433, 0x4434,  // Offset: 40b0 ~ 40b7
0x4435, 0x4436, 0x4437, 0x4438, 0x4439, 0x443a, 0x443b, 0x443c,  // Offset: 40b8 ~ 40bf
0x443d, 0x443e, 0x443f, 0x4440, 0x4441, 0x4442, 0x4443, 0x4444,  // Offset: 40c0 ~ 40c7
0x4445, 0x4446, 0x4447, 0x4448, 0x4449, 0x444a, 0x444b, 0x444c,  // Offset: 40c8 ~ 40cf
0x444d, 0x444e, 0x444f, 0x4450, 0x4451, 0x4452, 0x4453, 0x4454,  // Offset: 40d0 ~ 40d7
0x4455, 0x4456, 0x4457, 0x4458, 0x4459, 0x445a, 0x445b, 0x445c,  // Offset: 40d8 ~ 40df
0x445d, 0x445e, 0x445f, 0x4460, 0x4461, 0x4462, 0x4463, 0x4464,  // Offset: 40e0 ~ 40e7
0x4465, 0x4466, 0x4467, 0x4468, 0x4469, 0x446a, 0x446b, 0x446c,  // Offset: 40e8 ~ 40ef
0x446d, 0x446e, 0x446f, 0x4470, 0x4471, 0x4472, 0x4473, 0x4474,  // Offset: 40f0 ~ 40f7
0x4475, 0x4476, 0x4477, 0x4478, 0x4479, 0x447a, 0x447b, 0x447c,  // Offset: 40f8 ~ 40ff
0x447d, 0x447e, 0x447f, 0x4480, 0x4481, 0x4482, 0x4483, 0x4484,  // Offset: 4100 ~ 4107
0x4485, 0x4486, 0x4487, 0x4488, 0x4489, 0x448a, 0x448b, 0x448c,  // Offset: 4108 ~ 410f
0x448d, 0x448e, 0x448f, 0x4490, 0x4491, 0x4492, 0x4493, 0x4494,  // Offset: 4110 ~ 4117
0x4495, 0x4496, 0x4497, 0x4498, 0x4499, 0x449a, 0x449b, 0x449c,  // Offset: 4118 ~ 411f
0x449d, 0x449e, 0x449f, 0x44a0, 0x44a1, 0x44a2, 0x44a3, 0x44a4,  // Offset: 4120 ~ 4127
0x44a5, 0x44a6, 0x44a7, 0x44a8, 0x44a9, 0x44aa, 0x44ab, 0x44ac,  // Offset: 4128 ~ 412f
0x44ad, 0x44ae, 0x44af, 0x44b0, 0x44b1, 0x44b2, 0x44b3, 0x44b4,  // Offset: 4130 ~ 4137
0x44b5, 0x44b6, 0x44b7, 0x44b8, 0x44b9, 0x44ba, 0x44bb, 0x44bc,  // Offset: 4138 ~ 413f
0x44bd, 0x44be, 0x44bf, 0x44c0, 0x44c1, 0x44c2, 0x44c3, 0x44c4,  // Offset: 4140 ~ 4147
0x44c5, 0x44c6, 0x44c7, 0x44c8, 0x44c9, 0x44ca, 0x44cb, 0x44cc,  // Offset: 4148 ~ 414f
0x44cd, 0x44ce, 0x44cf, 0x44d0, 0x44d1, 0x44d2, 0x44d3, 0x44d4,  // Offset: 4150 ~ 4157
0x44d5, 0x44d7, 0x44d8, 0x44d9, 0x44da, 0x44db, 0x44dc, 0x44dd,  // Offset: 4158 ~ 415f
0x44de, 0x44df, 0x44e0, 0x44e1, 0x44e2, 0x44e3, 0x44e4, 0x44e5,  // Offset: 4160 ~ 4167
0x44e6, 0x44e7, 0x44e8, 0x44e9, 0x44ea, 0x44eb, 0x44ec, 0x44ed,  // Offset: 4168 ~ 416f
0x44ee, 0x44ef, 0x44f0, 0x44f1, 0x44f2, 0x44f3, 0x44f4, 0x44f5,  // Offset: 4170 ~ 4177
0x44f6, 0x44f7, 0x44f8, 0x44f9, 0x44fa, 0x44fb, 0x44fc, 0x44fd,  // Offset: 4178 ~ 417f
0x44fe, 0x44ff, 0x4500, 0x4501, 0x4502, 0x4503, 0x4504, 0x4505,  // Offset: 4180 ~ 4187
0x4506, 0x4507, 0x4508, 0x4509, 0x450a, 0x450b, 0x450c, 0x450d,  // Offset: 4188 ~ 418f
0x450e, 0x450f, 0x4510, 0x4511, 0x4512, 0x4513, 0x4514, 0x4515,  // Offset: 4190 ~ 4197
0x4516, 0x4517, 0x4518, 0x4519, 0x451a, 0x451b, 0x451c, 0x451d,  // Offset: 4198 ~ 419f
0x451e, 0x451f, 0x4520, 0x4521, 0x4522, 0x4523, 0x4524, 0x4525,  // Offset: 41a0 ~ 41a7
0x4526, 0x4527, 0x4528, 0x4529, 0x452a, 0x452b, 0x452c, 0x452d,  // Offset: 41a8 ~ 41af
0x452e, 0x452f, 0x4530, 0x4531, 0x4532, 0x4533, 0x4534, 0x4535,  // Offset: 41b0 ~ 41b7
0x4536, 0x4537, 0x4538, 0x4539, 0x453a, 0x453b, 0x453c, 0x453d,  // Offset: 41b8 ~ 41bf
0x453e, 0x453f, 0x4540, 0x4541, 0x4542, 0x4543, 0x4544, 0x4545,  // Offset: 41c0 ~ 41c7
0x4546, 0x4547, 0x4548, 0x4549, 0x454a, 0x454b, 0x454c, 0x454d,  // Offset: 41c8 ~ 41cf
0x454e, 0x454f, 0x4550, 0x4551, 0x4552, 0x4553, 0x4554, 0x4555,  // Offset: 41d0 ~ 41d7
0x4556, 0x4557, 0x4558, 0x4559, 0x455a, 0x455b, 0x455c, 0x455d,  // Offset: 41d8 ~ 41df
0x455e, 0x455f, 0x4560, 0x4561, 0x4562, 0x4563, 0x4564, 0x4565,  // Offset: 41e0 ~ 41e7
0x4566, 0x4567, 0x4568, 0x4569, 0x456a, 0x456b, 0x456c, 0x456d,  // Offset: 41e8 ~ 41ef
0x456e, 0x456f, 0x4570, 0x4571, 0x4572, 0x4573, 0x4574, 0x4575,  // Offset: 41f0 ~ 41f7
0x4576, 0x4577, 0x4578, 0x4579, 0x457a, 0x457b, 0x457c, 0x457d,  // Offset: 41f8 ~ 41ff
0x457e, 0x457f, 0x4580, 0x4581, 0x4582, 0x4583, 0x4584, 0x4585,  // Offset: 4200 ~ 4207
0x4586, 0x4587, 0x4588, 0x4589, 0x458a, 0x458b, 0x458c, 0x458d,  // Offset: 4208 ~ 420f
0x458e, 0x458f, 0x4590, 0x4591, 0x4592, 0x4593, 0x4594, 0x4595,  // Offset: 4210 ~ 4217
0x4596, 0x4597, 0x4598, 0x4599, 0x459a, 0x459b, 0x459c, 0x459d,  // Offset: 4218 ~ 421f
0x459e, 0x459f, 0x45a0, 0x45a1, 0x45a2, 0x45a3, 0x45a4, 0x45a5,  // Offset: 4220 ~ 4227
0x45a6, 0x45a7, 0x45a8, 0x45a9, 0x45aa, 0x45ab, 0x45ac, 0x45ad,  // Offset: 4228 ~ 422f
0x45ae, 0x45af, 0x45b0, 0x45b1, 0x45b2, 0x45b3, 0x45b4, 0x45b5,  // Offset: 4230 ~ 4237
0x45b6, 0x45b7, 0x45b8, 0x45b9, 0x45ba, 0x45bb, 0x45bc, 0x45bd,  // Offset: 4238 ~ 423f
0x45be, 0x45bf, 0x45c0, 0x45c1, 0x45c2, 0x45c3, 0x45c4, 0x45c5,  // Offset: 4240 ~ 4247
0x45c6, 0x45c7, 0x45c8, 0x45c9, 0x45ca, 0x45cb, 0x45cc, 0x45cd,  // Offset: 4248 ~ 424f
0x45ce, 0x45cf, 0x45d0, 0x45d1, 0x45d2, 0x45d3, 0x45d4, 0x45d5,  // Offset: 4250 ~ 4257
0x45d6, 0x45d7, 0x45d8, 0x45d9, 0x45da, 0x45db, 0x45dc, 0x45dd,  // Offset: 4258 ~ 425f
0x45de, 0x45df, 0x45e0, 0x45e1, 0x45e2, 0x45e3, 0x45e4, 0x45e5,  // Offset: 4260 ~ 4267
0x45e6, 0x45e7, 0x45e8, 0x45e9, 0x45ea, 0x45eb, 0x45ec, 0x45ed,  // Offset: 4268 ~ 426f
0x45ee, 0x45ef, 0x45f0, 0x45f1, 0x45f2, 0x45f3, 0x45f4, 0x45f5,  // Offset: 4270 ~ 4277
0x45f6, 0x45f7, 0x45f8, 0x45f9, 0x45fa, 0x45fb, 0x45fc, 0x45fd,  // Offset: 4278 ~ 427f
0x45fe, 0x45ff, 0x4600, 0x4601, 0x4602, 0x4603, 0x4604, 0x4605,  // Offset: 4280 ~ 4287
0x4606, 0x4607, 0x4608, 0x4609, 0x460a, 0x460b, 0x460c, 0x460d,  // Offset: 4288 ~ 428f
0x460e, 0x460f, 0x4610, 0x4611, 0x4612, 0x4613, 0x4614, 0x4615,  // Offset: 4290 ~ 4297
0x4616, 0x4617, 0x4618, 0x4619, 0x461a, 0x461b, 0x461c, 0x461d,  // Offset: 4298 ~ 429f
0x461e, 0x461f, 0x4620, 0x4621, 0x4622, 0x4623, 0x4624, 0x4625,  // Offset: 42a0 ~ 42a7
0x4626, 0x4627, 0x4628, 0x4629, 0x462a, 0x462b, 0x462c, 0x462d,  // Offset: 42a8 ~ 42af
0x462e, 0x462f, 0x4630, 0x4631, 0x4632, 0x4633, 0x4634, 0x4635,  // Offset: 42b0 ~ 42b7
0x4636, 0x4637, 0x4638, 0x4639, 0x463a, 0x463b, 0x463c, 0x463d,  // Offset: 42b8 ~ 42bf
0x463e, 0x463f, 0x4640, 0x4641, 0x4642, 0x4643, 0x4644, 0x4645,  // Offset: 42c0 ~ 42c7
0x4646, 0x4647, 0x4648, 0x4649, 0x464a, 0x464b, 0x464d, 0x464e,  // Offset: 42c8 ~ 42cf
0x464f, 0x4650, 0x4651, 0x4652, 0x4653, 0x4654, 0x4655, 0x4656,  // Offset: 42d0 ~ 42d7
0x4657, 0x4658, 0x4659, 0x465a, 0x465b, 0x465c, 0x465d, 0x465e,  // Offset: 42d8 ~ 42df
0x465f, 0x4660, 0x4662, 0x4663, 0x4664, 0x4665, 0x4666, 0x4667,  // Offset: 42e0 ~ 42e7
0x4668, 0x4669, 0x466a, 0x466b, 0x466c, 0x466d, 0x466e, 0x466f,  // Offset: 42e8 ~ 42ef
0x4670, 0x4671, 0x4672, 0x4673, 0x4674, 0x4675, 0x4676, 0x4677,  // Offset: 42f0 ~ 42f7
0x4678, 0x4679, 0x467a, 0x467b, 0x467c, 0x467d, 0x467e, 0x467f,  // Offset: 42f8 ~ 42ff
0x4680, 0x4681, 0x4682, 0x4683, 0x4684, 0x4685, 0x4686, 0x4687,  // Offset: 4300 ~ 4307
0x4688, 0x4689, 0x468a, 0x468b, 0x468c, 0x468d, 0x468e, 0x468f,  // Offset: 4308 ~ 430f
0x4690, 0x4691, 0x4692, 0x4693, 0x4694, 0x4695, 0x4696, 0x4697,  // Offset: 4310 ~ 4317
0x4698, 0x4699, 0x469a, 0x469b, 0x469c, 0x469d, 0x469e, 0x469f,  // Offset: 4318 ~ 431f
0x46a0, 0x46a1, 0x46a2, 0x46a3, 0x46a4, 0x46a5, 0x46a6, 0x46a7,  // Offset: 4320 ~ 4327
0x46a8, 0x46a9, 0x46aa, 0x46ab, 0x46ac, 0x46ad, 0x46ae, 0x46af,  // Offset: 4328 ~ 432f
0x46b0, 0x46b1, 0x46b2, 0x46b3, 0x46b4, 0x46b5, 0x46b6, 0x46b7,  // Offset: 4330 ~ 4337
0x46b8, 0x46b9, 0x46ba, 0x46bb, 0x46bc, 0x46bd, 0x46be, 0x46bf,  // Offset: 4338 ~ 433f
0x46c0, 0x46c1, 0x46c2, 0x46c3, 0x46c4, 0x46c5, 0x46c6, 0x46c7,  // Offset: 4340 ~ 4347
0x46c8, 0x46c9, 0x46ca, 0x46cb, 0x46cc, 0x46cd, 0x46ce, 0x46cf,  // Offset: 4348 ~ 434f
0x46d0, 0x46d1, 0x46d2, 0x46d3, 0x46d4, 0x46d5, 0x46d6, 0x46d7,  // Offset: 4350 ~ 4357
0x46d8, 0x46d9, 0x46da, 0x46db, 0x46dc, 0x46dd, 0x46de, 0x46df,  // Offset: 4358 ~ 435f
0x46e0, 0x46e1, 0x46e2, 0x46e3, 0x46e4, 0x46e5, 0x46e6, 0x46e7,  // Offset: 4360 ~ 4367
0x46e8, 0x46e9, 0x46ea, 0x46eb, 0x46ec, 0x46ed, 0x46ee, 0x46ef,  // Offset: 4368 ~ 436f
0x46f0, 0x46f1, 0x46f2, 0x46f3, 0x46f4, 0x46f5, 0x46f6, 0x46f7,  // Offset: 4370 ~ 4377
0x46f8, 0x46f9, 0x46fa, 0x46fb, 0x46fc, 0x46fd, 0x46fe, 0x46ff,  // Offset: 4378 ~ 437f
0x4700, 0x4701, 0x4702, 0x4703, 0x4704, 0x4705, 0x4706, 0x4707,  // Offset: 4380 ~ 4387
0x4708, 0x4709, 0x470a, 0x470b, 0x470c, 0x470d, 0x470e, 0x470f,  // Offset: 4388 ~ 438f
0x4710, 0x4711, 0x4712, 0x4713, 0x4714, 0x4715, 0x4716, 0x4717,  // Offset: 4390 ~ 4397
0x4718, 0x4719, 0x471a, 0x471b, 0x471c, 0x471d, 0x471e, 0x471f,  // Offset: 4398 ~ 439f
0x4720, 0x4721, 0x4722, 0x4724, 0x4725, 0x4726, 0x4727, 0x4728,  // Offset: 43a0 ~ 43a7
0x472a, 0x472b, 0x472c, 0x472d, 0x472e, 0x472f, 0x4730, 0x4731,  // Offset: 43a8 ~ 43af
0x4732, 0x4733, 0x4734, 0x4735, 0x4736, 0x4737, 0x4738, 0x4739,  // Offset: 43b0 ~ 43b7
0x473a, 0x473b, 0x473c, 0x473d, 0x473e, 0x473f, 0x4740, 0x4741,  // Offset: 43b8 ~ 43bf
0x4742, 0x4743, 0x4744, 0x4745, 0x4746, 0x4747, 0x4748, 0x4749,  // Offset: 43c0 ~ 43c7
0x474a, 0x474b, 0x474c, 0x474d, 0x474e, 0x474f, 0x4750, 0x4751,  // Offset: 43c8 ~ 43cf
0x4752, 0x4753, 0x4754, 0x4755, 0x4756, 0x4757, 0x4758, 0x4759,  // Offset: 43d0 ~ 43d7
0x475a, 0x475b, 0x475c, 0x475d, 0x475e, 0x475f, 0x4760, 0x4761,  // Offset: 43d8 ~ 43df
0x4762, 0x4763, 0x4764, 0x4765, 0x4766, 0x4767, 0x4768, 0x4769,  // Offset: 43e0 ~ 43e7
0x476a, 0x476b, 0x476c, 0x476d, 0x476e, 0x476f, 0x4770, 0x4771,  // Offset: 43e8 ~ 43ef
0x4772, 0x4773, 0x4774, 0x4775, 0x4776, 0x4777, 0x4778, 0x4779,  // Offset: 43f0 ~ 43f7
0x477a, 0x477b, 0x477d, 0x477e, 0x477f, 0x4780, 0x4781, 0x4782,  // Offset: 43f8 ~ 43ff
0x4783, 0x4784, 0x4785, 0x4786, 0x4787, 0x4788, 0x4789, 0x478a,  // Offset: 4400 ~ 4407
0x478b, 0x478c, 0x478e, 0x478f, 0x4790, 0x4791, 0x4792, 0x4793,  // Offset: 4408 ~ 440f
0x4794, 0x4795, 0x4796, 0x4797, 0x4798, 0x4799, 0x479a, 0x479b,  // Offset: 4410 ~ 4417
0x479c, 0x479d, 0x479e, 0x479f, 0x47a0, 0x47a1, 0x47a2, 0x47a3,  // Offset: 4418 ~ 441f
0x47a4, 0x47a5, 0x47a6, 0x47a7, 0x47a8, 0x47a9, 0x47aa, 0x47ab,  // Offset: 4420 ~ 4427
0x47ac, 0x47ad, 0x47ae, 0x47af, 0x47b0, 0x47b1, 0x47b2, 0x47b3,  // Offset: 4428 ~ 442f
0x47b4, 0x47b5, 0x47b6, 0x47b7, 0x47b8, 0x47b9, 0x47ba, 0x47bb,  // Offset: 4430 ~ 4437
0x47bc, 0x47bd, 0x47be, 0x47bf, 0x47c0, 0x47c1, 0x47c2, 0x47c3,  // Offset: 4438 ~ 443f
0x47c4, 0x47c5, 0x47c6, 0x47c7, 0x47c8, 0x47c9, 0x47ca, 0x47cb,  // Offset: 4440 ~ 4447
0x47cc, 0x47cd, 0x47ce, 0x47cf, 0x47d0, 0x47d1, 0x47d2, 0x47d3,  // Offset: 4448 ~ 444f
0x47d4, 0x47d5, 0x47d6, 0x47d7, 0x47d8, 0x47d9, 0x47da, 0x47db,  // Offset: 4450 ~ 4457
0x47dc, 0x47dd, 0x47de, 0x47df, 0x47e0, 0x47e1, 0x47e2, 0x47e3,  // Offset: 4458 ~ 445f
0x47e4, 0x47e5, 0x47e6, 0x47e7, 0x47e8, 0x47e9, 0x47ea, 0x47eb,  // Offset: 4460 ~ 4467
0x47ec, 0x47ed, 0x47ee, 0x47ef, 0x47f0, 0x47f1, 0x47f2, 0x47f3,  // Offset: 4468 ~ 446f
0x47f4, 0x47f5, 0x47f6, 0x47f7, 0x47f8, 0x47f9, 0x47fa, 0x47fb,  // Offset: 4470 ~ 4477
0x47fc, 0x47fd, 0x47fe, 0x47ff, 0x4800, 0x4801, 0x4802, 0x4803,  // Offset: 4478 ~ 447f
0x4804, 0x4805, 0x4806, 0x4807, 0x4808, 0x4809, 0x480a, 0x480b,  // Offset: 4480 ~ 4487
0x480c, 0x480d, 0x480e, 0x480f, 0x4810, 0x4811, 0x4812, 0x4813,  // Offset: 4488 ~ 448f
0x4814, 0x4815, 0x4816, 0x4817, 0x4818, 0x4819, 0x481a, 0x481b,  // Offset: 4490 ~ 4497
0x481c, 0x481d, 0x481e, 0x481f, 0x4820, 0x4821, 0x4822, 0x4823,  // Offset: 4498 ~ 449f
0x4824, 0x4825, 0x4826, 0x4827, 0x4828, 0x4829, 0x482a, 0x482b,  // Offset: 44a0 ~ 44a7
0x482c, 0x482d, 0x482e, 0x482f, 0x4830, 0x4831, 0x4832, 0x4833,  // Offset: 44a8 ~ 44af
0x4834, 0x4835, 0x4836, 0x4837, 0x4838, 0x4839, 0x483a, 0x483b,  // Offset: 44b0 ~ 44b7
0x483c, 0x483d, 0x483e, 0x483f, 0x4840, 0x4841, 0x4842, 0x4843,  // Offset: 44b8 ~ 44bf
0x4844, 0x4845, 0x4846, 0x4847, 0x4848, 0x4849, 0x484a, 0x484b,  // Offset: 44c0 ~ 44c7
0x484c, 0x484d, 0x484e, 0x484f, 0x4850, 0x4851, 0x4852, 0x4853,  // Offset: 44c8 ~ 44cf
0x4854, 0x4855, 0x4856, 0x4857, 0x4858, 0x4859, 0x485a, 0x485b,  // Offset: 44d0 ~ 44d7
0x485c, 0x485d, 0x485e, 0x485f, 0x4860, 0x4861, 0x4862, 0x4863,  // Offset: 44d8 ~ 44df
0x4864, 0x4865, 0x4866, 0x4867, 0x4868, 0x4869, 0x486a, 0x486b,  // Offset: 44e0 ~ 44e7
0x486c, 0x486d, 0x486e, 0x486f, 0x4870, 0x4871, 0x4872, 0x4873,  // Offset: 44e8 ~ 44ef
0x4874, 0x4875, 0x4876, 0x4877, 0x4878, 0x4879, 0x487a, 0x487b,  // Offset: 44f0 ~ 44f7
0x487c, 0x487d, 0x487e, 0x487f, 0x4880, 0x4881, 0x4882, 0x4883,  // Offset: 44f8 ~ 44ff
0x4884, 0x4885, 0x4886, 0x4887, 0x4888, 0x4889, 0x488a, 0x488b,  // Offset: 4500 ~ 4507
0x488c, 0x488d, 0x488e, 0x488f, 0x4890, 0x4891, 0x4892, 0x4893,  // Offset: 4508 ~ 450f
0x4894, 0x4895, 0x4896, 0x4897, 0x4898, 0x4899, 0x489a, 0x489b,  // Offset: 4510 ~ 4517
0x489c, 0x489d, 0x489e, 0x489f, 0x48a0, 0x48a1, 0x48a2, 0x48a3,  // Offset: 4518 ~ 451f
0x48a4, 0x48a5, 0x48a6, 0x48a7, 0x48a8, 0x48a9, 0x48aa, 0x48ab,  // Offset: 4520 ~ 4527
0x48ac, 0x48ad, 0x48ae, 0x48af, 0x48b0, 0x48b1, 0x48b2, 0x48b3,  // Offset: 4528 ~ 452f
0x48b4, 0x48b5, 0x48b6, 0x48b7, 0x48b8, 0x48b9, 0x48ba, 0x48bb,  // Offset: 4530 ~ 4537
0x48bc, 0x48bd, 0x48be, 0x48bf, 0x48c0, 0x48c1, 0x48c2, 0x48c3,  // Offset: 4538 ~ 453f
0x48c4, 0x48c5, 0x48c6, 0x48c7, 0x48c8, 0x48c9, 0x48ca, 0x48cb,  // Offset: 4540 ~ 4547
0x48cc, 0x48cd, 0x48ce, 0x48cf, 0x48d0, 0x48d1, 0x48d2, 0x48d3,  // Offset: 4548 ~ 454f
0x48d4, 0x48d5, 0x48d6, 0x48d7, 0x48d8, 0x48d9, 0x48da, 0x48db,  // Offset: 4550 ~ 4557
0x48dc, 0x48dd, 0x48de, 0x48df, 0x48e0, 0x48e1, 0x48e2, 0x48e3,  // Offset: 4558 ~ 455f
0x48e4, 0x48e5, 0x48e6, 0x48e7, 0x48e8, 0x48e9, 0x48ea, 0x48eb,  // Offset: 4560 ~ 4567
0x48ec, 0x48ed, 0x48ee, 0x48ef, 0x48f0, 0x48f1, 0x48f2, 0x48f3,  // Offset: 4568 ~ 456f
0x48f4, 0x48f5, 0x48f6, 0x48f7, 0x48f8, 0x48f9, 0x48fa, 0x48fb,  // Offset: 4570 ~ 4577
0x48fc, 0x48fd, 0x48fe, 0x48ff, 0x4900, 0x4901, 0x4902, 0x4903,  // Offset: 4578 ~ 457f
0x4904, 0x4905, 0x4906, 0x4907, 0x4908, 0x4909, 0x490a, 0x490b,  // Offset: 4580 ~ 4587
0x490c, 0x490d, 0x490e, 0x490f, 0x4910, 0x4911, 0x4912, 0x4913,  // Offset: 4588 ~ 458f
0x4914, 0x4915, 0x4916, 0x4917, 0x4918, 0x4919, 0x491a, 0x491b,  // Offset: 4590 ~ 4597
0x491c, 0x491d, 0x491e, 0x491f, 0x4920, 0x4921, 0x4922, 0x4923,  // Offset: 4598 ~ 459f
0x4924, 0x4925, 0x4926, 0x4927, 0x4928, 0x4929, 0x492a, 0x492b,  // Offset: 45a0 ~ 45a7
0x492c, 0x492d, 0x492e, 0x492f, 0x4930, 0x4931, 0x4932, 0x4933,  // Offset: 45a8 ~ 45af
0x4934, 0x4935, 0x4936, 0x4937, 0x4938, 0x4939, 0x493a, 0x493b,  // Offset: 45b0 ~ 45b7
0x493c, 0x493d, 0x493e, 0x493f, 0x4940, 0x4941, 0x4942, 0x4943,  // Offset: 45b8 ~ 45bf
0x4944, 0x4945, 0x4946, 0x4948, 0x4949, 0x494a, 0x494b, 0x494c,  // Offset: 45c0 ~ 45c7
0x494d, 0x494e, 0x494f, 0x4950, 0x4951, 0x4952, 0x4953, 0x4954,  // Offset: 45c8 ~ 45cf
0x4955, 0x4956, 0x4957, 0x4958, 0x4959, 0x495a, 0x495b, 0x495c,  // Offset: 45d0 ~ 45d7
0x495d, 0x495e, 0x495f, 0x4960, 0x4961, 0x4962, 0x4963, 0x4964,  // Offset: 45d8 ~ 45df
0x4965, 0x4966, 0x4967, 0x4968, 0x4969, 0x496a, 0x496b, 0x496c,  // Offset: 45e0 ~ 45e7
0x496d, 0x496e, 0x496f, 0x4970, 0x4971, 0x4972, 0x4973, 0x4974,  // Offset: 45e8 ~ 45ef
0x4975, 0x4976, 0x4977, 0x4978, 0x4979, 0x497b, 0x497c, 0x497e,  // Offset: 45f0 ~ 45f7
0x497f, 0x4980, 0x4981, 0x4984, 0x4987, 0x4988, 0x4989, 0x498a,  // Offset: 45f8 ~ 45ff
0x498b, 0x498c, 0x498d, 0x498e, 0x498f, 0x4990, 0x4991, 0x4992,  // Offset: 4600 ~ 4607
0x4993, 0x4994, 0x4995, 0x4996, 0x4997, 0x4998, 0x4999, 0x499a,  // Offset: 4608 ~ 460f
0x499c, 0x499d, 0x499e, 0x49a0, 0x49a1, 0x49a2, 0x49a3, 0x49a4,  // Offset: 4610 ~ 4617
0x49a5, 0x49a6, 0x49a7, 0x49a8, 0x49a9, 0x49aa, 0x49ab, 0x49ac,  // Offset: 4618 ~ 461f
0x49ad, 0x49ae, 0x49af, 0x49b0, 0x49b1, 0x49b2, 0x49b3, 0x49b4,  // Offset: 4620 ~ 4627
0x49b5, 0x49b8, 0x49b9, 0x49ba, 0x49bb, 0x49bc, 0x49bd, 0x49be,  // Offset: 4628 ~ 462f
0x49bf, 0x49c0, 0x49c1, 0x49c2, 0x49c3, 0x49c4, 0x49c5, 0x49c6,  // Offset: 4630 ~ 4637
0x49c7, 0x49c8, 0x49c9, 0x49ca, 0x49cb, 0x49cc, 0x49cd, 0x49ce,  // Offset: 4638 ~ 463f
0x49cf, 0x49d0, 0x49d1, 0x49d2, 0x49d3, 0x49d4, 0x49d5, 0x49d6,  // Offset: 4640 ~ 4647
0x49d7, 0x49d8, 0x49d9, 0x49da, 0x49db, 0x49dc, 0x49dd, 0x49de,  // Offset: 4648 ~ 464f
0x49df, 0x49e0, 0x49e1, 0x49e2, 0x49e3, 0x49e4, 0x49e5, 0x49e6,  // Offset: 4650 ~ 4657
0x49e7, 0x49e8, 0x49e9, 0x49ea, 0x49eb, 0x49ec, 0x49ed, 0x49ee,  // Offset: 4658 ~ 465f
0x49ef, 0x49f0, 0x49f1, 0x49f2, 0x49f3, 0x49f4, 0x49f5, 0x49f6,  // Offset: 4660 ~ 4667
0x49f7, 0x49f8, 0x49f9, 0x49fa, 0x49fb, 0x49fc, 0x49fd, 0x49fe,  // Offset: 4668 ~ 466f
0x49ff, 0x4a00, 0x4a01, 0x4a02, 0x4a03, 0x4a04, 0x4a05, 0x4a06,  // Offset: 4670 ~ 4677
0x4a07, 0x4a08, 0x4a09, 0x4a0a, 0x4a0b, 0x4a0c, 0x4a0d, 0x4a0e,  // Offset: 4678 ~ 467f
0x4a0f, 0x4a10, 0x4a11, 0x4a12, 0x4a13, 0x4a14, 0x4a15, 0x4a16,  // Offset: 4680 ~ 4687
0x4a17, 0x4a18, 0x4a19, 0x4a1a, 0x4a1b, 0x4a1c, 0x4a1d, 0x4a1e,  // Offset: 4688 ~ 468f
0x4a1f, 0x4a20, 0x4a21, 0x4a22, 0x4a23, 0x4a24, 0x4a25, 0x4a26,  // Offset: 4690 ~ 4697
0x4a27, 0x4a28, 0x4a29, 0x4a2a, 0x4a2b, 0x4a2c, 0x4a2d, 0x4a2e,  // Offset: 4698 ~ 469f
0x4a2f, 0x4a30, 0x4a31, 0x4a32, 0x4a33, 0x4a34, 0x4a35, 0x4a36,  // Offset: 46a0 ~ 46a7
0x4a37, 0x4a38, 0x4a39, 0x4a3a, 0x4a3b, 0x4a3c, 0x4a3d, 0x4a3e,  // Offset: 46a8 ~ 46af
0x4a3f, 0x4a40, 0x4a41, 0x4a42, 0x4a43, 0x4a44, 0x4a45, 0x4a46,  // Offset: 46b0 ~ 46b7
0x4a47, 0x4a48, 0x4a49, 0x4a4a, 0x4a4b, 0x4a4c, 0x4a4d, 0x4a4e,  // Offset: 46b8 ~ 46bf
0x4a4f, 0x4a50, 0x4a51, 0x4a52, 0x4a53, 0x4a54, 0x4a55, 0x4a56,  // Offset: 46c0 ~ 46c7
0x4a57, 0x4a58, 0x4a59, 0x4a5a, 0x4a5b, 0x4a5c, 0x4a5d, 0x4a5e,  // Offset: 46c8 ~ 46cf
0x4a5f, 0x4a60, 0x4a61, 0x4a62, 0x4a63, 0x4a64, 0x4a65, 0x4a66,  // Offset: 46d0 ~ 46d7
0x4a67, 0x4a68, 0x4a69, 0x4a6a, 0x4a6b, 0x4a6c, 0x4a6d, 0x4a6e,  // Offset: 46d8 ~ 46df
0x4a6f, 0x4a70, 0x4a71, 0x4a72, 0x4a73, 0x4a74, 0x4a75, 0x4a76,  // Offset: 46e0 ~ 46e7
0x4a77, 0x4a78, 0x4a79, 0x4a7a, 0x4a7b, 0x4a7c, 0x4a7d, 0x4a7e,  // Offset: 46e8 ~ 46ef
0x4a7f, 0x4a80, 0x4a81, 0x4a82, 0x4a83, 0x4a84, 0x4a85, 0x4a86,  // Offset: 46f0 ~ 46f7
0x4a87, 0x4a88, 0x4a89, 0x4a8a, 0x4a8b, 0x4a8c, 0x4a8d, 0x4a8e,  // Offset: 46f8 ~ 46ff
0x4a8f, 0x4a90, 0x4a91, 0x4a92, 0x4a93, 0x4a94, 0x4a95, 0x4a96,  // Offset: 4700 ~ 4707
0x4a97, 0x4a98, 0x4a99, 0x4a9a, 0x4a9b, 0x4a9c, 0x4a9d, 0x4a9e,  // Offset: 4708 ~ 470f
0x4a9f, 0x4aa0, 0x4aa1, 0x4aa2, 0x4aa3, 0x4aa4, 0x4aa5, 0x4aa6,  // Offset: 4710 ~ 4717
0x4aa7, 0x4aa8, 0x4aa9, 0x4aaa, 0x4aab, 0x4aac, 0x4aad, 0x4aae,  // Offset: 4718 ~ 471f
0x4aaf, 0x4ab0, 0x4ab1, 0x4ab2, 0x4ab3, 0x4ab4, 0x4ab5, 0x4ab6,  // Offset: 4720 ~ 4727
0x4ab7, 0x4ab8, 0x4ab9, 0x4aba, 0x4abb, 0x4abc, 0x4abd, 0x4abe,  // Offset: 4728 ~ 472f
0x4abf, 0x4ac0, 0x4ac1, 0x4ac2, 0x4ac3, 0x4ac4, 0x4ac5, 0x4ac6,  // Offset: 4730 ~ 4737
0x4ac7, 0x4ac8, 0x4ac9, 0x4aca, 0x4acb, 0x4acc, 0x4acd, 0x4ace,  // Offset: 4738 ~ 473f
0x4acf, 0x4ad0, 0x4ad1, 0x4ad2, 0x4ad3, 0x4ad4, 0x4ad5, 0x4ad6,  // Offset: 4740 ~ 4747
0x4ad7, 0x4ad8, 0x4ad9, 0x4ada, 0x4adb, 0x4adc, 0x4add, 0x4ade,  // Offset: 4748 ~ 474f
0x4adf, 0x4ae0, 0x4ae1, 0x4ae2, 0x4ae3, 0x4ae4, 0x4ae5, 0x4ae6,  // Offset: 4750 ~ 4757
0x4ae7, 0x4ae8, 0x4ae9, 0x4aea, 0x4aeb, 0x4aec, 0x4aed, 0x4aee,  // Offset: 4758 ~ 475f
0x4aef, 0x4af0, 0x4af1, 0x4af2, 0x4af3, 0x4af4, 0x4af5, 0x4af6,  // Offset: 4760 ~ 4767
0x4af7, 0x4af8, 0x4af9, 0x4afa, 0x4afb, 0x4afc, 0x4afd, 0x4afe,  // Offset: 4768 ~ 476f
0x4aff, 0x4b00, 0x4b01, 0x4b02, 0x4b03, 0x4b04, 0x4b05, 0x4b06,  // Offset: 4770 ~ 4777
0x4b07, 0x4b08, 0x4b09, 0x4b0a, 0x4b0b, 0x4b0c, 0x4b0d, 0x4b0e,  // Offset: 4778 ~ 477f
0x4b0f, 0x4b10, 0x4b11, 0x4b12, 0x4b13, 0x4b14, 0x4b15, 0x4b16,  // Offset: 4780 ~ 4787
0x4b17, 0x4b18, 0x4b19, 0x4b1a, 0x4b1b, 0x4b1c, 0x4b1d, 0x4b1e,  // Offset: 4788 ~ 478f
0x4b1f, 0x4b20, 0x4b21, 0x4b22, 0x4b23, 0x4b24, 0x4b25, 0x4b26,  // Offset: 4790 ~ 4797
0x4b27, 0x4b28, 0x4b29, 0x4b2a, 0x4b2b, 0x4b2c, 0x4b2d, 0x4b2e,  // Offset: 4798 ~ 479f
0x4b2f, 0x4b30, 0x4b31, 0x4b32, 0x4b33, 0x4b34, 0x4b35, 0x4b36,  // Offset: 47a0 ~ 47a7
0x4b37, 0x4b38, 0x4b39, 0x4b3a, 0x4b3b, 0x4b3c, 0x4b3d, 0x4b3e,  // Offset: 47a8 ~ 47af
0x4b3f, 0x4b40, 0x4b41, 0x4b42, 0x4b43, 0x4b44, 0x4b45, 0x4b46,  // Offset: 47b0 ~ 47b7
0x4b47, 0x4b48, 0x4b49, 0x4b4a, 0x4b4b, 0x4b4c, 0x4b4d, 0x4b4e,  // Offset: 47b8 ~ 47bf
0x4b4f, 0x4b50, 0x4b51, 0x4b52, 0x4b53, 0x4b54, 0x4b55, 0x4b56,  // Offset: 47c0 ~ 47c7
0x4b57, 0x4b58, 0x4b59, 0x4b5a, 0x4b5b, 0x4b5c, 0x4b5d, 0x4b5e,  // Offset: 47c8 ~ 47cf
0x4b5f, 0x4b60, 0x4b61, 0x4b62, 0x4b63, 0x4b64, 0x4b65, 0x4b66,  // Offset: 47d0 ~ 47d7
0x4b67, 0x4b68, 0x4b69, 0x4b6a, 0x4b6b, 0x4b6c, 0x4b6d, 0x4b6e,  // Offset: 47d8 ~ 47df
0x4b6f, 0x4b70, 0x4b71, 0x4b72, 0x4b73, 0x4b74, 0x4b75, 0x4b76,  // Offset: 47e0 ~ 47e7
0x4b77, 0x4b78, 0x4b79, 0x4b7a, 0x4b7b, 0x4b7c, 0x4b7d, 0x4b7e,  // Offset: 47e8 ~ 47ef
0x4b7f, 0x4b80, 0x4b81, 0x4b82, 0x4b83, 0x4b84, 0x4b85, 0x4b86,  // Offset: 47f0 ~ 47f7
0x4b87, 0x4b88, 0x4b89, 0x4b8a, 0x4b8b, 0x4b8c, 0x4b8d, 0x4b8e,  // Offset: 47f8 ~ 47ff
0x4b8f, 0x4b90, 0x4b91, 0x4b92, 0x4b93, 0x4b94, 0x4b95, 0x4b96,  // Offset: 4800 ~ 4807
0x4b97, 0x4b98, 0x4b99, 0x4b9a, 0x4b9b, 0x4b9c, 0x4b9d, 0x4b9e,  // Offset: 4808 ~ 480f
0x4b9f, 0x4ba0, 0x4ba1, 0x4ba2, 0x4ba3, 0x4ba4, 0x4ba5, 0x4ba6,  // Offset: 4810 ~ 4817
0x4ba7, 0x4ba8, 0x4ba9, 0x4baa, 0x4bab, 0x4bac, 0x4bad, 0x4bae,  // Offset: 4818 ~ 481f
0x4baf, 0x4bb0, 0x4bb1, 0x4bb2, 0x4bb3, 0x4bb4, 0x4bb5, 0x4bb6,  // Offset: 4820 ~ 4827
0x4bb7, 0x4bb8, 0x4bb9, 0x4bba, 0x4bbb, 0x4bbc, 0x4bbd, 0x4bbe,  // Offset: 4828 ~ 482f
0x4bbf, 0x4bc0, 0x4bc1, 0x4bc2, 0x4bc3, 0x4bc4, 0x4bc5, 0x4bc6,  // Offset: 4830 ~ 4837
0x4bc7, 0x4bc8, 0x4bc9, 0x4bca, 0x4bcb, 0x4bcc, 0x4bcd, 0x4bce,  // Offset: 4838 ~ 483f
0x4bcf, 0x4bd0, 0x4bd1, 0x4bd2, 0x4bd3, 0x4bd4, 0x4bd5, 0x4bd6,  // Offset: 4840 ~ 4847
0x4bd7, 0x4bd8, 0x4bd9, 0x4bda, 0x4bdb, 0x4bdc, 0x4bdd, 0x4bde,  // Offset: 4848 ~ 484f
0x4bdf, 0x4be0, 0x4be1, 0x4be2, 0x4be3, 0x4be4, 0x4be5, 0x4be6,  // Offset: 4850 ~ 4857
0x4be7, 0x4be8, 0x4be9, 0x4bea, 0x4beb, 0x4bec, 0x4bed, 0x4bee,  // Offset: 4858 ~ 485f
0x4bef, 0x4bf0, 0x4bf1, 0x4bf2, 0x4bf3, 0x4bf4, 0x4bf5, 0x4bf6,  // Offset: 4860 ~ 4867
0x4bf7, 0x4bf8, 0x4bf9, 0x4bfa, 0x4bfb, 0x4bfc, 0x4bfd, 0x4bfe,  // Offset: 4868 ~ 486f
0x4bff, 0x4c00, 0x4c01, 0x4c02, 0x4c03, 0x4c04, 0x4c05, 0x4c06,  // Offset: 4870 ~ 4877
0x4c07, 0x4c08, 0x4c09, 0x4c0a, 0x4c0b, 0x4c0c, 0x4c0d, 0x4c0e,  // Offset: 4878 ~ 487f
0x4c0f, 0x4c10, 0x4c11, 0x4c12, 0x4c13, 0x4c14, 0x4c15, 0x4c16,  // Offset: 4880 ~ 4887
0x4c17, 0x4c18, 0x4c19, 0x4c1a, 0x4c1b, 0x4c1c, 0x4c1d, 0x4c1e,  // Offset: 4888 ~ 488f
0x4c1f, 0x4c20, 0x4c21, 0x4c22, 0x4c23, 0x4c24, 0x4c25, 0x4c26,  // Offset: 4890 ~ 4897
0x4c27, 0x4c28, 0x4c29, 0x4c2a, 0x4c2b, 0x4c2c, 0x4c2d, 0x4c2e,  // Offset: 4898 ~ 489f
0x4c2f, 0x4c30, 0x4c31, 0x4c32, 0x4c33, 0x4c34, 0x4c35, 0x4c36,  // Offset: 48a0 ~ 48a7
0x4c37, 0x4c38, 0x4c39, 0x4c3a, 0x4c3b, 0x4c3c, 0x4c3d, 0x4c3e,  // Offset: 48a8 ~ 48af
0x4c3f, 0x4c40, 0x4c41, 0x4c42, 0x4c43, 0x4c44, 0x4c45, 0x4c46,  // Offset: 48b0 ~ 48b7
0x4c47, 0x4c48, 0x4c49, 0x4c4a, 0x4c4b, 0x4c4c, 0x4c4d, 0x4c4e,  // Offset: 48b8 ~ 48bf
0x4c4f, 0x4c50, 0x4c51, 0x4c52, 0x4c53, 0x4c54, 0x4c55, 0x4c56,  // Offset: 48c0 ~ 48c7
0x4c57, 0x4c58, 0x4c59, 0x4c5a, 0x4c5b, 0x4c5c, 0x4c5d, 0x4c5e,  // Offset: 48c8 ~ 48cf
0x4c5f, 0x4c60, 0x4c61, 0x4c62, 0x4c63, 0x4c64, 0x4c65, 0x4c66,  // Offset: 48d0 ~ 48d7
0x4c67, 0x4c68, 0x4c69, 0x4c6a, 0x4c6b, 0x4c6c, 0x4c6d, 0x4c6e,  // Offset: 48d8 ~ 48df
0x4c6f, 0x4c70, 0x4c71, 0x4c72, 0x4c73, 0x4c74, 0x4c75, 0x4c76,  // Offset: 48e0 ~ 48e7
0x4c78, 0x4c79, 0x4c7a, 0x4c7b, 0x4c7c, 0x4c7d, 0x4c7e, 0x4c7f,  // Offset: 48e8 ~ 48ef
0x4c80, 0x4c81, 0x4c82, 0x4c83, 0x4c84, 0x4c85, 0x4c86, 0x4c87,  // Offset: 48f0 ~ 48f7
0x4c88, 0x4c89, 0x4c8a, 0x4c8b, 0x4c8c, 0x4c8d, 0x4c8e, 0x4c8f,  // Offset: 48f8 ~ 48ff
0x4c90, 0x4c91, 0x4c92, 0x4c93, 0x4c94, 0x4c95, 0x4c96, 0x4c97,  // Offset: 4900 ~ 4907
0x4c98, 0x4c99, 0x4c9a, 0x4c9b, 0x4c9c, 0x4c9d, 0x4c9e, 0x4ca4,  // Offset: 4908 ~ 490f
0x4ca5, 0x4ca6, 0x4ca7, 0x4ca8, 0x4ca9, 0x4caa, 0x4cab, 0x4cac,  // Offset: 4910 ~ 4917
0x4cad, 0x4cae, 0x4caf, 0x4cb0, 0x4cb1, 0x4cb2, 0x4cb3, 0x4cb4,  // Offset: 4918 ~ 491f
0x4cb5, 0x4cb6, 0x4cb7, 0x4cb8, 0x4cb9, 0x4cba, 0x4cbb, 0x4cbc,  // Offset: 4920 ~ 4927
0x4cbd, 0x4cbe, 0x4cbf, 0x4cc0, 0x4cc1, 0x4cc2, 0x4cc3, 0x4cc4,  // Offset: 4928 ~ 492f
0x4cc5, 0x4cc6, 0x4cc7, 0x4cc8, 0x4cc9, 0x4cca, 0x4ccb, 0x4ccc,  // Offset: 4930 ~ 4937
0x4ccd, 0x4cce, 0x4ccf, 0x4cd0, 0x4cd1, 0x4cd2, 0x4cd3, 0x4cd4,  // Offset: 4938 ~ 493f
0x4cd5, 0x4cd6, 0x4cd7, 0x4cd8, 0x4cd9, 0x4cda, 0x4cdb, 0x4cdc,  // Offset: 4940 ~ 4947
0x4cdd, 0x4cde, 0x4cdf, 0x4ce0, 0x4ce1, 0x4ce2, 0x4ce3, 0x4ce4,  // Offset: 4948 ~ 494f
0x4ce5, 0x4ce6, 0x4ce7, 0x4ce8, 0x4ce9, 0x4cea, 0x4ceb, 0x4cec,  // Offset: 4950 ~ 4957
0x4ced, 0x4cee, 0x4cef, 0x4cf0, 0x4cf1, 0x4cf2, 0x4cf3, 0x4cf4,  // Offset: 4958 ~ 495f
0x4cf5, 0x4cf6, 0x4cf7, 0x4cf8, 0x4cf9, 0x4cfa, 0x4cfb, 0x4cfc,  // Offset: 4960 ~ 4967
0x4cfd, 0x4cfe, 0x4cff, 0x4d00, 0x4d01, 0x4d02, 0x4d03, 0x4d04,  // Offset: 4968 ~ 496f
0x4d05, 0x4d06, 0x4d07, 0x4d08, 0x4d09, 0x4d0a, 0x4d0b, 0x4d0c,  // Offset: 4970 ~ 4977
0x4d0d, 0x4d0e, 0x4d0f, 0x4d10, 0x4d11, 0x4d12, 0x4d1a, 0x4d1b,  // Offset: 4978 ~ 497f
0x4d1c, 0x4d1d, 0x4d1e, 0x4d1f, 0x4d20, 0x4d21, 0x4d22, 0x4d23,  // Offset: 4980 ~ 4987
0x4d24, 0x4d25, 0x4d26, 0x4d27, 0x4d28, 0x4d29, 0x4d2a, 0x4d2b,  // Offset: 4988 ~ 498f
0x4d2c, 0x4d2d, 0x4d2e, 0x4d2f, 0x4d30, 0x4d31, 0x4d32, 0x4d33,  // Offset: 4990 ~ 4997
0x4d34, 0x4d35, 0x4d36, 0x4d37, 0x4d38, 0x4d39, 0x4d3a, 0x4d3b,  // Offset: 4998 ~ 499f
0x4d3c, 0x4d3d, 0x4d3e, 0x4d3f, 0x4d40, 0x4d41, 0x4d42, 0x4d43,  // Offset: 49a0 ~ 49a7
0x4d44, 0x4d45, 0x4d46, 0x4d47, 0x4d48, 0x4d49, 0x4d4a, 0x4d4b,  // Offset: 49a8 ~ 49af
0x4d4c, 0x4d4d, 0x4d4e, 0x4d4f, 0x4d50, 0x4d51, 0x4d52, 0x4d53,  // Offset: 49b0 ~ 49b7
0x4d54, 0x4d55, 0x4d56, 0x4d57, 0x4d58, 0x4d59, 0x4d5a, 0x4d5b,  // Offset: 49b8 ~ 49bf
0x4d5c, 0x4d5d, 0x4d5e, 0x4d5f, 0x4d60, 0x4d61, 0x4d62, 0x4d63,  // Offset: 49c0 ~ 49c7
0x4d64, 0x4d65, 0x4d66, 0x4d67, 0x4d68, 0x4d69, 0x4d6a, 0x4d6b,  // Offset: 49c8 ~ 49cf
0x4d6c, 0x4d6d, 0x4d6e, 0x4d6f, 0x4d70, 0x4d71, 0x4d72, 0x4d73,  // Offset: 49d0 ~ 49d7
0x4d74, 0x4d75, 0x4d76, 0x4d77, 0x4d78, 0x4d79, 0x4d7a, 0x4d7b,  // Offset: 49d8 ~ 49df
0x4d7c, 0x4d7d, 0x4d7e, 0x4d7f, 0x4d80, 0x4d81, 0x4d82, 0x4d83,  // Offset: 49e0 ~ 49e7
0x4d84, 0x4d85, 0x4d86, 0x4d87, 0x4d88, 0x4d89, 0x4d8a, 0x4d8b,  // Offset: 49e8 ~ 49ef
0x4d8c, 0x4d8d, 0x4d8e, 0x4d8f, 0x4d90, 0x4d91, 0x4d92, 0x4d93,  // Offset: 49f0 ~ 49f7
0x4d94, 0x4d95, 0x4d96, 0x4d97, 0x4d98, 0x4d99, 0x4d9a, 0x4d9b,  // Offset: 49f8 ~ 49ff
0x4d9c, 0x4d9d, 0x4d9e, 0x4d9f, 0x4da0, 0x4da1, 0x4da2, 0x4da3,  // Offset: 4a00 ~ 4a07
0x4da4, 0x4da5, 0x4da6, 0x4da7, 0x4da8, 0x4da9, 0x4daa, 0x4dab,  // Offset: 4a08 ~ 4a0f
0x4dac, 0x4dad, 0x4daf, 0x4db0, 0x4db1, 0x4db2, 0x4db3, 0x4db4,  // Offset: 4a10 ~ 4a17
0x4db5, 0x4db6, 0x4db7, 0x4db8, 0x4db9, 0x4dba, 0x4dbb, 0x4dbc,  // Offset: 4a18 ~ 4a1f
0x4dbd, 0x4dbe, 0x4dbf, 0x4dc0, 0x4dc1, 0x4dc2, 0x4dc3, 0x4dc4,  // Offset: 4a20 ~ 4a27
0x4dc5, 0x4dc6, 0x4dc7, 0x4dc8, 0x4dc9, 0x4dca, 0x4dcb, 0x4dcc,  // Offset: 4a28 ~ 4a2f
0x4dcd, 0x4dce, 0x4dcf, 0x4dd0, 0x4dd1, 0x4dd2, 0x4dd3, 0x4dd4,  // Offset: 4a30 ~ 4a37
0x4dd5, 0x4dd6, 0x4dd7, 0x4dd8, 0x4dd9, 0x4dda, 0x4ddb, 0x4ddc,  // Offset: 4a38 ~ 4a3f
0x4ddd, 0x4dde, 0x4ddf, 0x4de0, 0x4de1, 0x4de2, 0x4de3, 0x4de4,  // Offset: 4a40 ~ 4a47
0x4de5, 0x4de6, 0x4de7, 0x4de8, 0x4de9, 0x4dea, 0x4deb, 0x4dec,  // Offset: 4a48 ~ 4a4f
0x4ded, 0x4dee, 0x4def, 0x4df0, 0x4df1, 0x4df2, 0x4df3, 0x4df4,  // Offset: 4a50 ~ 4a57
0x4df5, 0x4df6, 0x4df7, 0x4df8, 0x4df9, 0x4dfa, 0x4dfb, 0x4dfc,  // Offset: 4a58 ~ 4a5f
0x4dfd, 0x4dfe, 0x4dff, 0x9fa6, 0x9fa7, 0x9fa8, 0x9fa9, 0x9faa,  // Offset: 4a60 ~ 4a67
0x9fab, 0x9fac, 0x9fad, 0x9fae, 0x9faf, 0x9fb0, 0x9fb1, 0x9fb2,  // Offset: 4a68 ~ 4a6f
0x9fb3, 0x9fb4, 0x9fb5, 0x9fb6, 0x9fb7, 0x9fb8, 0x9fb9, 0x9fba,  // Offset: 4a70 ~ 4a77
0x9fbb, 0x9fbc, 0x9fbd, 0x9fbe, 0x9fbf, 0x9fc0, 0x9fc1, 0x9fc2,  // Offset: 4a78 ~ 4a7f
0x9fc3, 0x9fc4, 0x9fc5, 0x9fc6, 0x9fc7, 0x9fc8, 0x9fc9, 0x9fca,  // Offset: 4a80 ~ 4a87
0x9fcb, 0x9fcc, 0x9fcd, 0x9fce, 0x9fcf, 0x9fd0, 0x9fd1, 0x9fd2,  // Offset: 4a88 ~ 4a8f
0x9fd3, 0x9fd4, 0x9fd5, 0x9fd6, 0x9fd7, 0x9fd8, 0x9fd9, 0x9fda,  // Offset: 4a90 ~ 4a97
0x9fdb, 0x9fdc, 0x9fdd, 0x9fde, 0x9fdf, 0x9fe0, 0x9fe1, 0x9fe2,  // Offset: 4a98 ~ 4a9f
0x9fe3, 0x9fe4, 0x9fe5, 0x9fe6, 0x9fe7, 0x9fe8, 0x9fe9, 0x9fea,  // Offset: 4aa0 ~ 4aa7
0x9feb, 0x9fec, 0x9fed, 0x9fee, 0x9fef, 0x9ff0, 0x9ff1, 0x9ff2,  // Offset: 4aa8 ~ 4aaf
0x9ff3, 0x9ff4, 0x9ff5, 0x9ff6, 0x9ff7, 0x9ff8, 0x9ff9, 0x9ffa,  // Offset: 4ab0 ~ 4ab7
0x9ffb, 0x9ffc, 0x9ffd, 0x9ffe, 0x9fff, 0xa000, 0xa001, 0xa002,  // Offset: 4ab8 ~ 4abf
0xa003, 0xa004, 0xa005, 0xa006, 0xa007, 0xa008, 0xa009, 0xa00a,  // Offset: 4ac0 ~ 4ac7
0xa00b, 0xa00c, 0xa00d, 0xa00e, 0xa00f, 0xa010, 0xa011, 0xa012,  // Offset: 4ac8 ~ 4acf
0xa013, 0xa014, 0xa015, 0xa016, 0xa017, 0xa018, 0xa019, 0xa01a,  // Offset: 4ad0 ~ 4ad7
0xa01b, 0xa01c, 0xa01d, 0xa01e, 0xa01f, 0xa020, 0xa021, 0xa022,  // Offset: 4ad8 ~ 4adf
0xa023, 0xa024, 0xa025, 0xa026, 0xa027, 0xa028, 0xa029, 0xa02a,  // Offset: 4ae0 ~ 4ae7
0xa02b, 0xa02c, 0xa02d, 0xa02e, 0xa02f, 0xa030, 0xa031, 0xa032,  // Offset: 4ae8 ~ 4aef
0xa033, 0xa034, 0xa035, 0xa036, 0xa037, 0xa038, 0xa039, 0xa03a,  // Offset: 4af0 ~ 4af7
0xa03b, 0xa03c, 0xa03d, 0xa03e, 0xa03f, 0xa040, 0xa041, 0xa042,  // Offset: 4af8 ~ 4aff
0xa043, 0xa044, 0xa045, 0xa046, 0xa047, 0xa048, 0xa049, 0xa04a,  // Offset: 4b00 ~ 4b07
0xa04b, 0xa04c, 0xa04d, 0xa04e, 0xa04f, 0xa050, 0xa051, 0xa052,  // Offset: 4b08 ~ 4b0f
0xa053, 0xa054, 0xa055, 0xa056, 0xa057, 0xa058, 0xa059, 0xa05a,  // Offset: 4b10 ~ 4b17
0xa05b, 0xa05c, 0xa05d, 0xa05e, 0xa05f, 0xa060, 0xa061, 0xa062,  // Offset: 4b18 ~ 4b1f
0xa063, 0xa064, 0xa065, 0xa066, 0xa067, 0xa068, 0xa069, 0xa06a,  // Offset: 4b20 ~ 4b27
0xa06b, 0xa06c, 0xa06d, 0xa06e, 0xa06f, 0xa070, 0xa071, 0xa072,  // Offset: 4b28 ~ 4b2f
0xa073, 0xa074, 0xa075, 0xa076, 0xa077, 0xa078, 0xa079, 0xa07a,  // Offset: 4b30 ~ 4b37
0xa07b, 0xa07c, 0xa07d, 0xa07e, 0xa07f, 0xa080, 0xa081, 0xa082,  // Offset: 4b38 ~ 4b3f
0xa083, 0xa084, 0xa085, 0xa086, 0xa087, 0xa088, 0xa089, 0xa08a,  // Offset: 4b40 ~ 4b47
0xa08b, 0xa08c, 0xa08d, 0xa08e, 0xa08f, 0xa090, 0xa091, 0xa092,  // Offset: 4b48 ~ 4b4f
0xa093, 0xa094, 0xa095, 0xa096, 0xa097, 0xa098, 0xa099, 0xa09a,  // Offset: 4b50 ~ 4b57
0xa09b, 0xa09c, 0xa09d, 0xa09e, 0xa09f, 0xa0a0, 0xa0a1, 0xa0a2,  // Offset: 4b58 ~ 4b5f
0xa0a3, 0xa0a4, 0xa0a5, 0xa0a6, 0xa0a7, 0xa0a8, 0xa0a9, 0xa0aa,  // Offset: 4b60 ~ 4b67
0xa0ab, 0xa0ac, 0xa0ad, 0xa0ae, 0xa0af, 0xa0b0, 0xa0b1, 0xa0b2,  // Offset: 4b68 ~ 4b6f
0xa0b3, 0xa0b4, 0xa0b5, 0xa0b6, 0xa0b7, 0xa0b8, 0xa0b9, 0xa0ba,  // Offset: 4b70 ~ 4b77
0xa0bb, 0xa0bc, 0xa0bd, 0xa0be, 0xa0bf, 0xa0c0, 0xa0c1, 0xa0c2,  // Offset: 4b78 ~ 4b7f
0xa0c3, 0xa0c4, 0xa0c5, 0xa0c6, 0xa0c7, 0xa0c8, 0xa0c9, 0xa0ca,  // Offset: 4b80 ~ 4b87
0xa0cb, 0xa0cc, 0xa0cd, 0xa0ce, 0xa0cf, 0xa0d0, 0xa0d1, 0xa0d2,  // Offset: 4b88 ~ 4b8f
0xa0d3, 0xa0d4, 0xa0d5, 0xa0d6, 0xa0d7, 0xa0d8, 0xa0d9, 0xa0da,  // Offset: 4b90 ~ 4b97
0xa0db, 0xa0dc, 0xa0dd, 0xa0de, 0xa0df, 0xa0e0, 0xa0e1, 0xa0e2,  // Offset: 4b98 ~ 4b9f
0xa0e3, 0xa0e4, 0xa0e5, 0xa0e6, 0xa0e7, 0xa0e8, 0xa0e9, 0xa0ea,  // Offset: 4ba0 ~ 4ba7
0xa0eb, 0xa0ec, 0xa0ed, 0xa0ee, 0xa0ef, 0xa0f0, 0xa0f1, 0xa0f2,  // Offset: 4ba8 ~ 4baf
0xa0f3, 0xa0f4, 0xa0f5, 0xa0f6, 0xa0f7, 0xa0f8, 0xa0f9, 0xa0fa,  // Offset: 4bb0 ~ 4bb7
0xa0fb, 0xa0fc, 0xa0fd, 0xa0fe, 0xa0ff, 0xa100, 0xa101, 0xa102,  // Offset: 4bb8 ~ 4bbf
0xa103, 0xa104, 0xa105, 0xa106, 0xa107, 0xa108, 0xa109, 0xa10a,  // Offset: 4bc0 ~ 4bc7
0xa10b, 0xa10c, 0xa10d, 0xa10e, 0xa10f, 0xa110, 0xa111, 0xa112,  // Offset: 4bc8 ~ 4bcf
0xa113, 0xa114, 0xa115, 0xa116, 0xa117, 0xa118, 0xa119, 0xa11a,  // Offset: 4bd0 ~ 4bd7
0xa11b, 0xa11c, 0xa11d, 0xa11e, 0xa11f, 0xa120, 0xa121, 0xa122,  // Offset: 4bd8 ~ 4bdf
0xa123, 0xa124, 0xa125, 0xa126, 0xa127, 0xa128, 0xa129, 0xa12a,  // Offset: 4be0 ~ 4be7
0xa12b, 0xa12c, 0xa12d, 0xa12e, 0xa12f, 0xa130, 0xa131, 0xa132,  // Offset: 4be8 ~ 4bef
0xa133, 0xa134, 0xa135, 0xa136, 0xa137, 0xa138, 0xa139, 0xa13a,  // Offset: 4bf0 ~ 4bf7
0xa13b, 0xa13c, 0xa13d, 0xa13e, 0xa13f, 0xa140, 0xa141, 0xa142,  // Offset: 4bf8 ~ 4bff
0xa143, 0xa144, 0xa145, 0xa146, 0xa147, 0xa148, 0xa149, 0xa14a,  // Offset: 4c00 ~ 4c07
0xa14b, 0xa14c, 0xa14d, 0xa14e, 0xa14f, 0xa150, 0xa151, 0xa152,  // Offset: 4c08 ~ 4c0f
0xa153, 0xa154, 0xa155, 0xa156, 0xa157, 0xa158, 0xa159, 0xa15a,  // Offset: 4c10 ~ 4c17
0xa15b, 0xa15c, 0xa15d, 0xa15e, 0xa15f, 0xa160, 0xa161, 0xa162,  // Offset: 4c18 ~ 4c1f
0xa163, 0xa164, 0xa165, 0xa166, 0xa167, 0xa168, 0xa169, 0xa16a,  // Offset: 4c20 ~ 4c27
0xa16b, 0xa16c, 0xa16d, 0xa16e, 0xa16f, 0xa170, 0xa171, 0xa172,  // Offset: 4c28 ~ 4c2f
0xa173, 0xa174, 0xa175, 0xa176, 0xa177, 0xa178, 0xa179, 0xa17a,  // Offset: 4c30 ~ 4c37
0xa17b, 0xa17c, 0xa17d, 0xa17e, 0xa17f, 0xa180, 0xa181, 0xa182,  // Offset: 4c38 ~ 4c3f
0xa183, 0xa184, 0xa185, 0xa186, 0xa187, 0xa188, 0xa189, 0xa18a,  // Offset: 4c40 ~ 4c47
0xa18b, 0xa18c, 0xa18d, 0xa18e, 0xa18f, 0xa190, 0xa191, 0xa192,  // Offset: 4c48 ~ 4c4f
0xa193, 0xa194, 0xa195, 0xa196, 0xa197, 0xa198, 0xa199, 0xa19a,  // Offset: 4c50 ~ 4c57
0xa19b, 0xa19c, 0xa19d, 0xa19e, 0xa19f, 0xa1a0, 0xa1a1, 0xa1a2,  // Offset: 4c58 ~ 4c5f
0xa1a3, 0xa1a4, 0xa1a5, 0xa1a6, 0xa1a7, 0xa1a8, 0xa1a9, 0xa1aa,  // Offset: 4c60 ~ 4c67
0xa1ab, 0xa1ac, 0xa1ad, 0xa1ae, 0xa1af, 0xa1b0, 0xa1b1, 0xa1b2,  // Offset: 4c68 ~ 4c6f
0xa1b3, 0xa1b4, 0xa1b5, 0xa1b6, 0xa1b7, 0xa1b8, 0xa1b9, 0xa1ba,  // Offset: 4c70 ~ 4c77
0xa1bb, 0xa1bc, 0xa1bd, 0xa1be, 0xa1bf, 0xa1c0, 0xa1c1, 0xa1c2,  // Offset: 4c78 ~ 4c7f
0xa1c3, 0xa1c4, 0xa1c5, 0xa1c6, 0xa1c7, 0xa1c8, 0xa1c9, 0xa1ca,  // Offset: 4c80 ~ 4c87
0xa1cb, 0xa1cc, 0xa1cd, 0xa1ce, 0xa1cf, 0xa1d0, 0xa1d1, 0xa1d2,  // Offset: 4c88 ~ 4c8f
0xa1d3, 0xa1d4, 0xa1d5, 0xa1d6, 0xa1d7, 0xa1d8, 0xa1d9, 0xa1da,  // Offset: 4c90 ~ 4c97
0xa1db, 0xa1dc, 0xa1dd, 0xa1de, 0xa1df, 0xa1e0, 0xa1e1, 0xa1e2,  // Offset: 4c98 ~ 4c9f
0xa1e3, 0xa1e4, 0xa1e5, 0xa1e6, 0xa1e7, 0xa1e8, 0xa1e9, 0xa1ea,  // Offset: 4ca0 ~ 4ca7
0xa1eb, 0xa1ec, 0xa1ed, 0xa1ee, 0xa1ef, 0xa1f0, 0xa1f1, 0xa1f2,  // Offset: 4ca8 ~ 4caf
0xa1f3, 0xa1f4, 0xa1f5, 0xa1f6, 0xa1f7, 0xa1f8, 0xa1f9, 0xa1fa,  // Offset: 4cb0 ~ 4cb7
0xa1fb, 0xa1fc, 0xa1fd, 0xa1fe, 0xa1ff, 0xa200, 0xa201, 0xa202,  // Offset: 4cb8 ~ 4cbf
0xa203, 0xa204, 0xa205, 0xa206, 0xa207, 0xa208, 0xa209, 0xa20a,  // Offset: 4cc0 ~ 4cc7
0xa20b, 0xa20c, 0xa20d, 0xa20e, 0xa20f, 0xa210, 0xa211, 0xa212,  // Offset: 4cc8 ~ 4ccf
0xa213, 0xa214, 0xa215, 0xa216, 0xa217, 0xa218, 0xa219, 0xa21a,  // Offset: 4cd0 ~ 4cd7
0xa21b, 0xa21c, 0xa21d, 0xa21e, 0xa21f, 0xa220, 0xa221, 0xa222,  // Offset: 4cd8 ~ 4cdf
0xa223, 0xa224, 0xa225, 0xa226, 0xa227, 0xa228, 0xa229, 0xa22a,  // Offset: 4ce0 ~ 4ce7
0xa22b, 0xa22c, 0xa22d, 0xa22e, 0xa22f, 0xa230, 0xa231, 0xa232,  // Offset: 4ce8 ~ 4cef
0xa233, 0xa234, 0xa235, 0xa236, 0xa237, 0xa238, 0xa239, 0xa23a,  // Offset: 4cf0 ~ 4cf7
0xa23b, 0xa23c, 0xa23d, 0xa23e, 0xa23f, 0xa240, 0xa241, 0xa242,  // Offset: 4cf8 ~ 4cff
0xa243, 0xa244, 0xa245, 0xa246, 0xa247, 0xa248, 0xa249, 0xa24a,  // Offset: 4d00 ~ 4d07
0xa24b, 0xa24c, 0xa24d, 0xa24e, 0xa24f, 0xa250, 0xa251, 0xa252,  // Offset: 4d08 ~ 4d0f
0xa253, 0xa254, 0xa255, 0xa256, 0xa257, 0xa258, 0xa259, 0xa25a,  // Offset: 4d10 ~ 4d17
0xa25b, 0xa25c, 0xa25d, 0xa25e, 0xa25f, 0xa260, 0xa261, 0xa262,  // Offset: 4d18 ~ 4d1f
0xa263, 0xa264, 0xa265, 0xa266, 0xa267, 0xa268, 0xa269, 0xa26a,  // Offset: 4d20 ~ 4d27
0xa26b, 0xa26c, 0xa26d, 0xa26e, 0xa26f, 0xa270, 0xa271, 0xa272,  // Offset: 4d28 ~ 4d2f
0xa273, 0xa274, 0xa275, 0xa276, 0xa277, 0xa278, 0xa279, 0xa27a,  // Offset: 4d30 ~ 4d37
0xa27b, 0xa27c, 0xa27d, 0xa27e, 0xa27f, 0xa280, 0xa281, 0xa282,  // Offset: 4d38 ~ 4d3f
0xa283, 0xa284, 0xa285, 0xa286, 0xa287, 0xa288, 0xa289, 0xa28a,  // Offset: 4d40 ~ 4d47
0xa28b, 0xa28c, 0xa28d, 0xa28e, 0xa28f, 0xa290, 0xa291, 0xa292,  // Offset: 4d48 ~ 4d4f
0xa293, 0xa294, 0xa295, 0xa296, 0xa297, 0xa298, 0xa299, 0xa29a,  // Offset: 4d50 ~ 4d57
0xa29b, 0xa29c, 0xa29d, 0xa29e, 0xa29f, 0xa2a0, 0xa2a1, 0xa2a2,  // Offset: 4d58 ~ 4d5f
0xa2a3, 0xa2a4, 0xa2a5, 0xa2a6, 0xa2a7, 0xa2a8, 0xa2a9, 0xa2aa,  // Offset: 4d60 ~ 4d67
0xa2ab, 0xa2ac, 0xa2ad, 0xa2ae, 0xa2af, 0xa2b0, 0xa2b1, 0xa2b2,  // Offset: 4d68 ~ 4d6f
0xa2b3, 0xa2b4, 0xa2b5, 0xa2b6, 0xa2b7, 0xa2b8, 0xa2b9, 0xa2ba,  // Offset: 4d70 ~ 4d77
0xa2bb, 0xa2bc, 0xa2bd, 0xa2be, 0xa2bf, 0xa2c0, 0xa2c1, 0xa2c2,  // Offset: 4d78 ~ 4d7f
0xa2c3, 0xa2c4, 0xa2c5, 0xa2c6, 0xa2c7, 0xa2c8, 0xa2c9, 0xa2ca,  // Offset: 4d80 ~ 4d87
0xa2cb, 0xa2cc, 0xa2cd, 0xa2ce, 0xa2cf, 0xa2d0, 0xa2d1, 0xa2d2,  // Offset: 4d88 ~ 4d8f
0xa2d3, 0xa2d4, 0xa2d5, 0xa2d6, 0xa2d7, 0xa2d8, 0xa2d9, 0xa2da,  // Offset: 4d90 ~ 4d97
0xa2db, 0xa2dc, 0xa2dd, 0xa2de, 0xa2df, 0xa2e0, 0xa2e1, 0xa2e2,  // Offset: 4d98 ~ 4d9f
0xa2e3, 0xa2e4, 0xa2e5, 0xa2e6, 0xa2e7, 0xa2e8, 0xa2e9, 0xa2ea,  // Offset: 4da0 ~ 4da7
0xa2eb, 0xa2ec, 0xa2ed, 0xa2ee, 0xa2ef, 0xa2f0, 0xa2f1, 0xa2f2,  // Offset: 4da8 ~ 4daf
0xa2f3, 0xa2f4, 0xa2f5, 0xa2f6, 0xa2f7, 0xa2f8, 0xa2f9, 0xa2fa,  // Offset: 4db0 ~ 4db7
0xa2fb, 0xa2fc, 0xa2fd, 0xa2fe, 0xa2ff, 0xa300, 0xa301, 0xa302,  // Offset: 4db8 ~ 4dbf
0xa303, 0xa304, 0xa305, 0xa306, 0xa307, 0xa308, 0xa309, 0xa30a,  // Offset: 4dc0 ~ 4dc7
0xa30b, 0xa30c, 0xa30d, 0xa30e, 0xa30f, 0xa310, 0xa311, 0xa312,  // Offset: 4dc8 ~ 4dcf
0xa313, 0xa314, 0xa315, 0xa316, 0xa317, 0xa318, 0xa319, 0xa31a,  // Offset: 4dd0 ~ 4dd7
0xa31b, 0xa31c, 0xa31d, 0xa31e, 0xa31f, 0xa320, 0xa321, 0xa322,  // Offset: 4dd8 ~ 4ddf
0xa323, 0xa324, 0xa325, 0xa326, 0xa327, 0xa328, 0xa329, 0xa32a,  // Offset: 4de0 ~ 4de7
0xa32b, 0xa32c, 0xa32d, 0xa32e, 0xa32f, 0xa330, 0xa331, 0xa332,  // Offset: 4de8 ~ 4def
0xa333, 0xa334, 0xa335, 0xa336, 0xa337, 0xa338, 0xa339, 0xa33a,  // Offset: 4df0 ~ 4df7
0xa33b, 0xa33c, 0xa33d, 0xa33e, 0xa33f, 0xa340, 0xa341, 0xa342,  // Offset: 4df8 ~ 4dff
0xa343, 0xa344, 0xa345, 0xa346, 0xa347, 0xa348, 0xa349, 0xa34a,  // Offset: 4e00 ~ 4e07
0xa34b, 0xa34c, 0xa34d, 0xa34e, 0xa34f, 0xa350, 0xa351, 0xa352,  // Offset: 4e08 ~ 4e0f
0xa353, 0xa354, 0xa355, 0xa356, 0xa357, 0xa358, 0xa359, 0xa35a,  // Offset: 4e10 ~ 4e17
0xa35b, 0xa35c, 0xa35d, 0xa35e, 0xa35f, 0xa360, 0xa361, 0xa362,  // Offset: 4e18 ~ 4e1f
0xa363, 0xa364, 0xa365, 0xa366, 0xa367, 0xa368, 0xa369, 0xa36a,  // Offset: 4e20 ~ 4e27
0xa36b, 0xa36c, 0xa36d, 0xa36e, 0xa36f, 0xa370, 0xa371, 0xa372,  // Offset: 4e28 ~ 4e2f
0xa373, 0xa374, 0xa375, 0xa376, 0xa377, 0xa378, 0xa379, 0xa37a,  // Offset: 4e30 ~ 4e37
0xa37b, 0xa37c, 0xa37d, 0xa37e, 0xa37f, 0xa380, 0xa381, 0xa382,  // Offset: 4e38 ~ 4e3f
0xa383, 0xa384, 0xa385, 0xa386, 0xa387, 0xa388, 0xa389, 0xa38a,  // Offset: 4e40 ~ 4e47
0xa38b, 0xa38c, 0xa38d, 0xa38e, 0xa38f, 0xa390, 0xa391, 0xa392,  // Offset: 4e48 ~ 4e4f
0xa393, 0xa394, 0xa395, 0xa396, 0xa397, 0xa398, 0xa399, 0xa39a,  // Offset: 4e50 ~ 4e57
0xa39b, 0xa39c, 0xa39d, 0xa39e, 0xa39f, 0xa3a0, 0xa3a1, 0xa3a2,  // Offset: 4e58 ~ 4e5f
0xa3a3, 0xa3a4, 0xa3a5, 0xa3a6, 0xa3a7, 0xa3a8, 0xa3a9, 0xa3aa,  // Offset: 4e60 ~ 4e67
0xa3ab, 0xa3ac, 0xa3ad, 0xa3ae, 0xa3af, 0xa3b0, 0xa3b1, 0xa3b2,  // Offset: 4e68 ~ 4e6f
0xa3b3, 0xa3b4, 0xa3b5, 0xa3b6, 0xa3b7, 0xa3b8, 0xa3b9, 0xa3ba,  // Offset: 4e70 ~ 4e77
0xa3bb, 0xa3bc, 0xa3bd, 0xa3be, 0xa3bf, 0xa3c0, 0xa3c1, 0xa3c2,  // Offset: 4e78 ~ 4e7f
0xa3c3, 0xa3c4, 0xa3c5, 0xa3c6, 0xa3c7, 0xa3c8, 0xa3c9, 0xa3ca,  // Offset: 4e80 ~ 4e87
0xa3cb, 0xa3cc, 0xa3cd, 0xa3ce, 0xa3cf, 0xa3d0, 0xa3d1, 0xa3d2,  // Offset: 4e88 ~ 4e8f
0xa3d3, 0xa3d4, 0xa3d5, 0xa3d6, 0xa3d7, 0xa3d8, 0xa3d9, 0xa3da,  // Offset: 4e90 ~ 4e97
0xa3db, 0xa3dc, 0xa3dd, 0xa3de, 0xa3df, 0xa3e0, 0xa3e1, 0xa3e2,  // Offset: 4e98 ~ 4e9f
0xa3e3, 0xa3e4, 0xa3e5, 0xa3e6, 0xa3e7, 0xa3e8, 0xa3e9, 0xa3ea,  // Offset: 4ea0 ~ 4ea7
0xa3eb, 0xa3ec, 0xa3ed, 0xa3ee, 0xa3ef, 0xa3f0, 0xa3f1, 0xa3f2,  // Offset: 4ea8 ~ 4eaf
0xa3f3, 0xa3f4, 0xa3f5, 0xa3f6, 0xa3f7, 0xa3f8, 0xa3f9, 0xa3fa,  // Offset: 4eb0 ~ 4eb7
0xa3fb, 0xa3fc, 0xa3fd, 0xa3fe, 0xa3ff, 0xa400, 0xa401, 0xa402,  // Offset: 4eb8 ~ 4ebf
0xa403, 0xa404, 0xa405, 0xa406, 0xa407, 0xa408, 0xa409, 0xa40a,  // Offset: 4ec0 ~ 4ec7
0xa40b, 0xa40c, 0xa40d, 0xa40e, 0xa40f, 0xa410, 0xa411, 0xa412,  // Offset: 4ec8 ~ 4ecf
0xa413, 0xa414, 0xa415, 0xa416, 0xa417, 0xa418, 0xa419, 0xa41a,  // Offset: 4ed0 ~ 4ed7
0xa41b, 0xa41c, 0xa41d, 0xa41e, 0xa41f, 0xa420, 0xa421, 0xa422,  // Offset: 4ed8 ~ 4edf
0xa423, 0xa424, 0xa425, 0xa426, 0xa427, 0xa428, 0xa429, 0xa42a,  // Offset: 4ee0 ~ 4ee7
0xa42b, 0xa42c, 0xa42d, 0xa42e, 0xa42f, 0xa430, 0xa431, 0xa432,  // Offset: 4ee8 ~ 4eef
0xa433, 0xa434, 0xa435, 0xa436, 0xa437, 0xa438, 0xa439, 0xa43a,  // Offset: 4ef0 ~ 4ef7
0xa43b, 0xa43c, 0xa43d, 0xa43e, 0xa43f, 0xa440, 0xa441, 0xa442,  // Offset: 4ef8 ~ 4eff
0xa443, 0xa444, 0xa445, 0xa446, 0xa447, 0xa448, 0xa449, 0xa44a,  // Offset: 4f00 ~ 4f07
0xa44b, 0xa44c, 0xa44d, 0xa44e, 0xa44f, 0xa450, 0xa451, 0xa452,  // Offset: 4f08 ~ 4f0f
0xa453, 0xa454, 0xa455, 0xa456, 0xa457, 0xa458, 0xa459, 0xa45a,  // Offset: 4f10 ~ 4f17
0xa45b, 0xa45c, 0xa45d, 0xa45e, 0xa45f, 0xa460, 0xa461, 0xa462,  // Offset: 4f18 ~ 4f1f
0xa463, 0xa464, 0xa465, 0xa466, 0xa467, 0xa468, 0xa469, 0xa46a,  // Offset: 4f20 ~ 4f27
0xa46b, 0xa46c, 0xa46d, 0xa46e, 0xa46f, 0xa470, 0xa471, 0xa472,  // Offset: 4f28 ~ 4f2f
0xa473, 0xa474, 0xa475, 0xa476, 0xa477, 0xa478, 0xa479, 0xa47a,  // Offset: 4f30 ~ 4f37
0xa47b, 0xa47c, 0xa47d, 0xa47e, 0xa47f, 0xa480, 0xa481, 0xa482,  // Offset: 4f38 ~ 4f3f
0xa483, 0xa484, 0xa485, 0xa486, 0xa487, 0xa488, 0xa489, 0xa48a,  // Offset: 4f40 ~ 4f47
0xa48b, 0xa48c, 0xa48d, 0xa48e, 0xa48f, 0xa490, 0xa491, 0xa492,  // Offset: 4f48 ~ 4f4f
0xa493, 0xa494, 0xa495, 0xa496, 0xa497, 0xa498, 0xa499, 0xa49a,  // Offset: 4f50 ~ 4f57
0xa49b, 0xa49c, 0xa49d, 0xa49e, 0xa49f, 0xa4a0, 0xa4a1, 0xa4a2,  // Offset: 4f58 ~ 4f5f
0xa4a3, 0xa4a4, 0xa4a5, 0xa4a6, 0xa4a7, 0xa4a8, 0xa4a9, 0xa4aa,  // Offset: 4f60 ~ 4f67
0xa4ab, 0xa4ac, 0xa4ad, 0xa4ae, 0xa4af, 0xa4b0, 0xa4b1, 0xa4b2,  // Offset: 4f68 ~ 4f6f
0xa4b3, 0xa4b4, 0xa4b5, 0xa4b6, 0xa4b7, 0xa4b8, 0xa4b9, 0xa4ba,  // Offset: 4f70 ~ 4f77
0xa4bb, 0xa4bc, 0xa4bd, 0xa4be, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c2,  // Offset: 4f78 ~ 4f7f
0xa4c3, 0xa4c4, 0xa4c5, 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca,  // Offset: 4f80 ~ 4f87
0xa4cb, 0xa4cc, 0xa4cd, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4d1, 0xa4d2,  // Offset: 4f88 ~ 4f8f
0xa4d3, 0xa4d4, 0xa4d5, 0xa4d6, 0xa4d7, 0xa4d8, 0xa4d9, 0xa4da,  // Offset: 4f90 ~ 4f97
0xa4db, 0xa4dc, 0xa4dd, 0xa4de, 0xa4df, 0xa4e0, 0xa4e1, 0xa4e2,  // Offset: 4f98 ~ 4f9f
0xa4e3, 0xa4e4, 0xa4e5, 0xa4e6, 0xa4e7, 0xa4e8, 0xa4e9, 0xa4ea,  // Offset: 4fa0 ~ 4fa7
0xa4eb, 0xa4ec, 0xa4ed, 0xa4ee, 0xa4ef, 0xa4f0, 0xa4f1, 0xa4f2,  // Offset: 4fa8 ~ 4faf
0xa4f3, 0xa4f4, 0xa4f5, 0xa4f6, 0xa4f7, 0xa4f8, 0xa4f9, 0xa4fa,  // Offset: 4fb0 ~ 4fb7
0xa4fb, 0xa4fc, 0xa4fd, 0xa4fe, 0xa4ff, 0xa500, 0xa501, 0xa502,  // Offset: 4fb8 ~ 4fbf
0xa503, 0xa504, 0xa505, 0xa506, 0xa507, 0xa508, 0xa509, 0xa50a,  // Offset: 4fc0 ~ 4fc7
0xa50b, 0xa50c, 0xa50d, 0xa50e, 0xa50f, 0xa510, 0xa511, 0xa512,  // Offset: 4fc8 ~ 4fcf
0xa513, 0xa514, 0xa515, 0xa516, 0xa517, 0xa518, 0xa519, 0xa51a,  // Offset: 4fd0 ~ 4fd7
0xa51b, 0xa51c, 0xa51d, 0xa51e, 0xa51f, 0xa520, 0xa521, 0xa522,  // Offset: 4fd8 ~ 4fdf
0xa523, 0xa524, 0xa525, 0xa526, 0xa527, 0xa528, 0xa529, 0xa52a,  // Offset: 4fe0 ~ 4fe7
0xa52b, 0xa52c, 0xa52d, 0xa52e, 0xa52f, 0xa530, 0xa531, 0xa532,  // Offset: 4fe8 ~ 4fef
0xa533, 0xa534, 0xa535, 0xa536, 0xa537, 0xa538, 0xa539, 0xa53a,  // Offset: 4ff0 ~ 4ff7
0xa53b, 0xa53c, 0xa53d, 0xa53e, 0xa53f, 0xa540, 0xa541, 0xa542,  // Offset: 4ff8 ~ 4fff
0xa543, 0xa544, 0xa545, 0xa546, 0xa547, 0xa548, 0xa549, 0xa54a,  // Offset: 5000 ~ 5007
0xa54b, 0xa54c, 0xa54d, 0xa54e, 0xa54f, 0xa550, 0xa551, 0xa552,  // Offset: 5008 ~ 500f
0xa553, 0xa554, 0xa555, 0xa556, 0xa557, 0xa558, 0xa559, 0xa55a,  // Offset: 5010 ~ 5017
0xa55b, 0xa55c, 0xa55d, 0xa55e, 0xa55f, 0xa560, 0xa561, 0xa562,  // Offset: 5018 ~ 501f
0xa563, 0xa564, 0xa565, 0xa566, 0xa567, 0xa568, 0xa569, 0xa56a,  // Offset: 5020 ~ 5027
0xa56b, 0xa56c, 0xa56d, 0xa56e, 0xa56f, 0xa570, 0xa571, 0xa572,  // Offset: 5028 ~ 502f
0xa573, 0xa574, 0xa575, 0xa576, 0xa577, 0xa578, 0xa579, 0xa57a,  // Offset: 5030 ~ 5037
0xa57b, 0xa57c, 0xa57d, 0xa57e, 0xa57f, 0xa580, 0xa581, 0xa582,  // Offset: 5038 ~ 503f
0xa583, 0xa584, 0xa585, 0xa586, 0xa587, 0xa588, 0xa589, 0xa58a,  // Offset: 5040 ~ 5047
0xa58b, 0xa58c, 0xa58d, 0xa58e, 0xa58f, 0xa590, 0xa591, 0xa592,  // Offset: 5048 ~ 504f
0xa593, 0xa594, 0xa595, 0xa596, 0xa597, 0xa598, 0xa599, 0xa59a,  // Offset: 5050 ~ 5057
0xa59b, 0xa59c, 0xa59d, 0xa59e, 0xa59f, 0xa5a0, 0xa5a1, 0xa5a2,  // Offset: 5058 ~ 505f
0xa5a3, 0xa5a4, 0xa5a5, 0xa5a6, 0xa5a7, 0xa5a8, 0xa5a9, 0xa5aa,  // Offset: 5060 ~ 5067
0xa5ab, 0xa5ac, 0xa5ad, 0xa5ae, 0xa5af, 0xa5b0, 0xa5b1, 0xa5b2,  // Offset: 5068 ~ 506f
0xa5b3, 0xa5b4, 0xa5b5, 0xa5b6, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5ba,  // Offset: 5070 ~ 5077
0xa5bb, 0xa5bc, 0xa5bd, 0xa5be, 0xa5bf, 0xa5c0, 0xa5c1, 0xa5c2,  // Offset: 5078 ~ 507f
0xa5c3, 0xa5c4, 0xa5c5, 0xa5c6, 0xa5c7, 0xa5c8, 0xa5c9, 0xa5ca,  // Offset: 5080 ~ 5087
0xa5cb, 0xa5cc, 0xa5cd, 0xa5ce, 0xa5cf, 0xa5d0, 0xa5d1, 0xa5d2,  // Offset: 5088 ~ 508f
0xa5d3, 0xa5d4, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5d8, 0xa5d9, 0xa5da,  // Offset: 5090 ~ 5097
0xa5db, 0xa5dc, 0xa5dd, 0xa5de, 0xa5df, 0xa5e0, 0xa5e1, 0xa5e2,  // Offset: 5098 ~ 509f
0xa5e3, 0xa5e4, 0xa5e5, 0xa5e6, 0xa5e7, 0xa5e8, 0xa5e9, 0xa5ea,  // Offset: 50a0 ~ 50a7
0xa5eb, 0xa5ec, 0xa5ed, 0xa5ee, 0xa5ef, 0xa5f0, 0xa5f1, 0xa5f2,  // Offset: 50a8 ~ 50af
0xa5f3, 0xa5f4, 0xa5f5, 0xa5f6, 0xa5f7, 0xa5f8, 0xa5f9, 0xa5fa,  // Offset: 50b0 ~ 50b7
0xa5fb, 0xa5fc, 0xa5fd, 0xa5fe, 0xa5ff, 0xa600, 0xa601, 0xa602,  // Offset: 50b8 ~ 50bf
0xa603, 0xa604, 0xa605, 0xa606, 0xa607, 0xa608, 0xa609, 0xa60a,  // Offset: 50c0 ~ 50c7
0xa60b, 0xa60c, 0xa60d, 0xa60e, 0xa60f, 0xa610, 0xa611, 0xa612,  // Offset: 50c8 ~ 50cf
0xa613, 0xa614, 0xa615, 0xa616, 0xa617, 0xa618, 0xa619, 0xa61a,  // Offset: 50d0 ~ 50d7
0xa61b, 0xa61c, 0xa61d, 0xa61e, 0xa61f, 0xa620, 0xa621, 0xa622,  // Offset: 50d8 ~ 50df
0xa623, 0xa624, 0xa625, 0xa626, 0xa627, 0xa628, 0xa629, 0xa62a,  // Offset: 50e0 ~ 50e7
0xa62b, 0xa62c, 0xa62d, 0xa62e, 0xa62f, 0xa630, 0xa631, 0xa632,  // Offset: 50e8 ~ 50ef
0xa633, 0xa634, 0xa635, 0xa636, 0xa637, 0xa638, 0xa639, 0xa63a,  // Offset: 50f0 ~ 50f7
0xa63b, 0xa63c, 0xa63d, 0xa63e, 0xa63f, 0xa640, 0xa641, 0xa642,  // Offset: 50f8 ~ 50ff
0xa643, 0xa644, 0xa645, 0xa646, 0xa647, 0xa648, 0xa649, 0xa64a,  // Offset: 5100 ~ 5107
0xa64b, 0xa64c, 0xa64d, 0xa64e, 0xa64f, 0xa650, 0xa651, 0xa652,  // Offset: 5108 ~ 510f
0xa653, 0xa654, 0xa655, 0xa656, 0xa657, 0xa658, 0xa659, 0xa65a,  // Offset: 5110 ~ 5117
0xa65b, 0xa65c, 0xa65d, 0xa65e, 0xa65f, 0xa660, 0xa661, 0xa662,  // Offset: 5118 ~ 511f
0xa663, 0xa664, 0xa665, 0xa666, 0xa667, 0xa668, 0xa669, 0xa66a,  // Offset: 5120 ~ 5127
0xa66b, 0xa66c, 0xa66d, 0xa66e, 0xa66f, 0xa670, 0xa671, 0xa672,  // Offset: 5128 ~ 512f
0xa673, 0xa674, 0xa675, 0xa676, 0xa677, 0xa678, 0xa679, 0xa67a,  // Offset: 5130 ~ 5137
0xa67b, 0xa67c, 0xa67d, 0xa67e, 0xa67f, 0xa680, 0xa681, 0xa682,  // Offset: 5138 ~ 513f
0xa683, 0xa684, 0xa685, 0xa686, 0xa687, 0xa688, 0xa689, 0xa68a,  // Offset: 5140 ~ 5147
0xa68b, 0xa68c, 0xa68d, 0xa68e, 0xa68f, 0xa690, 0xa691, 0xa692,  // Offset: 5148 ~ 514f
0xa693, 0xa694, 0xa695, 0xa696, 0xa697, 0xa698, 0xa699, 0xa69a,  // Offset: 5150 ~ 5157
0xa69b, 0xa69c, 0xa69d, 0xa69e, 0xa69f, 0xa6a0, 0xa6a1, 0xa6a2,  // Offset: 5158 ~ 515f
0xa6a3, 0xa6a4, 0xa6a5, 0xa6a6, 0xa6a7, 0xa6a8, 0xa6a9, 0xa6aa,  // Offset: 5160 ~ 5167
0xa6ab, 0xa6ac, 0xa6ad, 0xa6ae, 0xa6af, 0xa6b0, 0xa6b1, 0xa6b2,  // Offset: 5168 ~ 516f
0xa6b3, 0xa6b4, 0xa6b5, 0xa6b6, 0xa6b7, 0xa6b8, 0xa6b9, 0xa6ba,  // Offset: 5170 ~ 5177
0xa6bb, 0xa6bc, 0xa6bd, 0xa6be, 0xa6bf, 0xa6c0, 0xa6c1, 0xa6c2,  // Offset: 5178 ~ 517f
0xa6c3, 0xa6c4, 0xa6c5, 0xa6c6, 0xa6c7, 0xa6c8, 0xa6c9, 0xa6ca,  // Offset: 5180 ~ 5187
0xa6cb, 0xa6cc, 0xa6cd, 0xa6ce, 0xa6cf, 0xa6d0, 0xa6d1, 0xa6d2,  // Offset: 5188 ~ 518f
0xa6d3, 0xa6d4, 0xa6d5, 0xa6d6, 0xa6d7, 0xa6d8, 0xa6d9, 0xa6da,  // Offset: 5190 ~ 5197
0xa6db, 0xa6dc, 0xa6dd, 0xa6de, 0xa6df, 0xa6e0, 0xa6e1, 0xa6e2,  // Offset: 5198 ~ 519f
0xa6e3, 0xa6e4, 0xa6e5, 0xa6e6, 0xa6e7, 0xa6e8, 0xa6e9, 0xa6ea,  // Offset: 51a0 ~ 51a7
0xa6eb, 0xa6ec, 0xa6ed, 0xa6ee, 0xa6ef, 0xa6f0, 0xa6f1, 0xa6f2,  // Offset: 51a8 ~ 51af
0xa6f3, 0xa6f4, 0xa6f5, 0xa6f6, 0xa6f7, 0xa6f8, 0xa6f9, 0xa6fa,  // Offset: 51b0 ~ 51b7
0xa6fb, 0xa6fc, 0xa6fd, 0xa6fe, 0xa6ff, 0xa700, 0xa701, 0xa702,  // Offset: 51b8 ~ 51bf
0xa703, 0xa704, 0xa705, 0xa706, 0xa707, 0xa708, 0xa709, 0xa70a,  // Offset: 51c0 ~ 51c7
0xa70b, 0xa70c, 0xa70d, 0xa70e, 0xa70f, 0xa710, 0xa711, 0xa712,  // Offset: 51c8 ~ 51cf
0xa713, 0xa714, 0xa715, 0xa716, 0xa717, 0xa718, 0xa719, 0xa71a,  // Offset: 51d0 ~ 51d7
0xa71b, 0xa71c, 0xa71d, 0xa71e, 0xa71f, 0xa720, 0xa721, 0xa722,  // Offset: 51d8 ~ 51df
0xa723, 0xa724, 0xa725, 0xa726, 0xa727, 0xa728, 0xa729, 0xa72a,  // Offset: 51e0 ~ 51e7
0xa72b, 0xa72c, 0xa72d, 0xa72e, 0xa72f, 0xa730, 0xa731, 0xa732,  // Offset: 51e8 ~ 51ef
0xa733, 0xa734, 0xa735, 0xa736, 0xa737, 0xa738, 0xa739, 0xa73a,  // Offset: 51f0 ~ 51f7
0xa73b, 0xa73c, 0xa73d, 0xa73e, 0xa73f, 0xa740, 0xa741, 0xa742,  // Offset: 51f8 ~ 51ff
0xa743, 0xa744, 0xa745, 0xa746, 0xa747, 0xa748, 0xa749, 0xa74a,  // Offset: 5200 ~ 5207
0xa74b, 0xa74c, 0xa74d, 0xa74e, 0xa74f, 0xa750, 0xa751, 0xa752,  // Offset: 5208 ~ 520f
0xa753, 0xa754, 0xa755, 0xa756, 0xa757, 0xa758, 0xa759, 0xa75a,  // Offset: 5210 ~ 5217
0xa75b, 0xa75c, 0xa75d, 0xa75e, 0xa75f, 0xa760, 0xa761, 0xa762,  // Offset: 5218 ~ 521f
0xa763, 0xa764, 0xa765, 0xa766, 0xa767, 0xa768, 0xa769, 0xa76a,  // Offset: 5220 ~ 5227
0xa76b, 0xa76c, 0xa76d, 0xa76e, 0xa76f, 0xa770, 0xa771, 0xa772,  // Offset: 5228 ~ 522f
0xa773, 0xa774, 0xa775, 0xa776, 0xa777, 0xa778, 0xa779, 0xa77a,  // Offset: 5230 ~ 5237
0xa77b, 0xa77c, 0xa77d, 0xa77e, 0xa77f, 0xa780, 0xa781, 0xa782,  // Offset: 5238 ~ 523f
0xa783, 0xa784, 0xa785, 0xa786, 0xa787, 0xa788, 0xa789, 0xa78a,  // Offset: 5240 ~ 5247
0xa78b, 0xa78c, 0xa78d, 0xa78e, 0xa78f, 0xa790, 0xa791, 0xa792,  // Offset: 5248 ~ 524f
0xa793, 0xa794, 0xa795, 0xa796, 0xa797, 0xa798, 0xa799, 0xa79a,  // Offset: 5250 ~ 5257
0xa79b, 0xa79c, 0xa79d, 0xa79e, 0xa79f, 0xa7a0, 0xa7a1, 0xa7a2,  // Offset: 5258 ~ 525f
0xa7a3, 0xa7a4, 0xa7a5, 0xa7a6, 0xa7a7, 0xa7a8, 0xa7a9, 0xa7aa,  // Offset: 5260 ~ 5267
0xa7ab, 0xa7ac, 0xa7ad, 0xa7ae, 0xa7af, 0xa7b0, 0xa7b1, 0xa7b2,  // Offset: 5268 ~ 526f
0xa7b3, 0xa7b4, 0xa7b5, 0xa7b6, 0xa7b7, 0xa7b8, 0xa7b9, 0xa7ba,  // Offset: 5270 ~ 5277
0xa7bb, 0xa7bc, 0xa7bd, 0xa7be, 0xa7bf, 0xa7c0, 0xa7c1, 0xa7c2,  // Offset: 5278 ~ 527f
0xa7c3, 0xa7c4, 0xa7c5, 0xa7c6, 0xa7c7, 0xa7c8, 0xa7c9, 0xa7ca,  // Offset: 5280 ~ 5287
0xa7cb, 0xa7cc, 0xa7cd, 0xa7ce, 0xa7cf, 0xa7d0, 0xa7d1, 0xa7d2,  // Offset: 5288 ~ 528f
0xa7d3, 0xa7d4, 0xa7d5, 0xa7d6, 0xa7d7, 0xa7d8, 0xa7d9, 0xa7da,  // Offset: 5290 ~ 5297
0xa7db, 0xa7dc, 0xa7dd, 0xa7de, 0xa7df, 0xa7e0, 0xa7e1, 0xa7e2,  // Offset: 5298 ~ 529f
0xa7e3, 0xa7e4, 0xa7e5, 0xa7e6, 0xa7e7, 0xa7e8, 0xa7e9, 0xa7ea,  // Offset: 52a0 ~ 52a7
0xa7eb, 0xa7ec, 0xa7ed, 0xa7ee, 0xa7ef, 0xa7f0, 0xa7f1, 0xa7f2,  // Offset: 52a8 ~ 52af
0xa7f3, 0xa7f4, 0xa7f5, 0xa7f6, 0xa7f7, 0xa7f8, 0xa7f9, 0xa7fa,  // Offset: 52b0 ~ 52b7
0xa7fb, 0xa7fc, 0xa7fd, 0xa7fe, 0xa7ff, 0xa800, 0xa801, 0xa802,  // Offset: 52b8 ~ 52bf
0xa803, 0xa804, 0xa805, 0xa806, 0xa807, 0xa808, 0xa809, 0xa80a,  // Offset: 52c0 ~ 52c7
0xa80b, 0xa80c, 0xa80d, 0xa80e, 0xa80f, 0xa810, 0xa811, 0xa812,  // Offset: 52c8 ~ 52cf
0xa813, 0xa814, 0xa815, 0xa816, 0xa817, 0xa818, 0xa819, 0xa81a,  // Offset: 52d0 ~ 52d7
0xa81b, 0xa81c, 0xa81d, 0xa81e, 0xa81f, 0xa820, 0xa821, 0xa822,  // Offset: 52d8 ~ 52df
0xa823, 0xa824, 0xa825, 0xa826, 0xa827, 0xa828, 0xa829, 0xa82a,  // Offset: 52e0 ~ 52e7
0xa82b, 0xa82c, 0xa82d, 0xa82e, 0xa82f, 0xa830, 0xa831, 0xa832,  // Offset: 52e8 ~ 52ef
0xa833, 0xa834, 0xa835, 0xa836, 0xa837, 0xa838, 0xa839, 0xa83a,  // Offset: 52f0 ~ 52f7
0xa83b, 0xa83c, 0xa83d, 0xa83e, 0xa83f, 0xa840, 0xa841, 0xa842,  // Offset: 52f8 ~ 52ff
0xa843, 0xa844, 0xa845, 0xa846, 0xa847, 0xa848, 0xa849, 0xa84a,  // Offset: 5300 ~ 5307
0xa84b, 0xa84c, 0xa84d, 0xa84e, 0xa84f, 0xa850, 0xa851, 0xa852,  // Offset: 5308 ~ 530f
0xa853, 0xa854, 0xa855, 0xa856, 0xa857, 0xa858, 0xa859, 0xa85a,  // Offset: 5310 ~ 5317
0xa85b, 0xa85c, 0xa85d, 0xa85e, 0xa85f, 0xa860, 0xa861, 0xa862,  // Offset: 5318 ~ 531f
0xa863, 0xa864, 0xa865, 0xa866, 0xa867, 0xa868, 0xa869, 0xa86a,  // Offset: 5320 ~ 5327
0xa86b, 0xa86c, 0xa86d, 0xa86e, 0xa86f, 0xa870, 0xa871, 0xa872,  // Offset: 5328 ~ 532f
0xa873, 0xa874, 0xa875, 0xa876, 0xa877, 0xa878, 0xa879, 0xa87a,  // Offset: 5330 ~ 5337
0xa87b, 0xa87c, 0xa87d, 0xa87e, 0xa87f, 0xa880, 0xa881, 0xa882,  // Offset: 5338 ~ 533f
0xa883, 0xa884, 0xa885, 0xa886, 0xa887, 0xa888, 0xa889, 0xa88a,  // Offset: 5340 ~ 5347
0xa88b, 0xa88c, 0xa88d, 0xa88e, 0xa88f, 0xa890, 0xa891, 0xa892,  // Offset: 5348 ~ 534f
0xa893, 0xa894, 0xa895, 0xa896, 0xa897, 0xa898, 0xa899, 0xa89a,  // Offset: 5350 ~ 5357
0xa89b, 0xa89c, 0xa89d, 0xa89e, 0xa89f, 0xa8a0, 0xa8a1, 0xa8a2,  // Offset: 5358 ~ 535f
0xa8a3, 0xa8a4, 0xa8a5, 0xa8a6, 0xa8a7, 0xa8a8, 0xa8a9, 0xa8aa,  // Offset: 5360 ~ 5367
0xa8ab, 0xa8ac, 0xa8ad, 0xa8ae, 0xa8af, 0xa8b0, 0xa8b1, 0xa8b2,  // Offset: 5368 ~ 536f
0xa8b3, 0xa8b4, 0xa8b5, 0xa8b6, 0xa8b7, 0xa8b8, 0xa8b9, 0xa8ba,  // Offset: 5370 ~ 5377
0xa8bb, 0xa8bc, 0xa8bd, 0xa8be, 0xa8bf, 0xa8c0, 0xa8c1, 0xa8c2,  // Offset: 5378 ~ 537f
0xa8c3, 0xa8c4, 0xa8c5, 0xa8c6, 0xa8c7, 0xa8c8, 0xa8c9, 0xa8ca,  // Offset: 5380 ~ 5387
0xa8cb, 0xa8cc, 0xa8cd, 0xa8ce, 0xa8cf, 0xa8d0, 0xa8d1, 0xa8d2,  // Offset: 5388 ~ 538f
0xa8d3, 0xa8d4, 0xa8d5, 0xa8d6, 0xa8d7, 0xa8d8, 0xa8d9, 0xa8da,  // Offset: 5390 ~ 5397
0xa8db, 0xa8dc, 0xa8dd, 0xa8de, 0xa8df, 0xa8e0, 0xa8e1, 0xa8e2,  // Offset: 5398 ~ 539f
0xa8e3, 0xa8e4, 0xa8e5, 0xa8e6, 0xa8e7, 0xa8e8, 0xa8e9, 0xa8ea,  // Offset: 53a0 ~ 53a7
0xa8eb, 0xa8ec, 0xa8ed, 0xa8ee, 0xa8ef, 0xa8f0, 0xa8f1, 0xa8f2,  // Offset: 53a8 ~ 53af
0xa8f3, 0xa8f4, 0xa8f5, 0xa8f6, 0xa8f7, 0xa8f8, 0xa8f9, 0xa8fa,  // Offset: 53b0 ~ 53b7
0xa8fb, 0xa8fc, 0xa8fd, 0xa8fe, 0xa8ff, 0xa900, 0xa901, 0xa902,  // Offset: 53b8 ~ 53bf
0xa903, 0xa904, 0xa905, 0xa906, 0xa907, 0xa908, 0xa909, 0xa90a,  // Offset: 53c0 ~ 53c7
0xa90b, 0xa90c, 0xa90d, 0xa90e, 0xa90f, 0xa910, 0xa911, 0xa912,  // Offset: 53c8 ~ 53cf
0xa913, 0xa914, 0xa915, 0xa916, 0xa917, 0xa918, 0xa919, 0xa91a,  // Offset: 53d0 ~ 53d7
0xa91b, 0xa91c, 0xa91d, 0xa91e, 0xa91f, 0xa920, 0xa921, 0xa922,  // Offset: 53d8 ~ 53df
0xa923, 0xa924, 0xa925, 0xa926, 0xa927, 0xa928, 0xa929, 0xa92a,  // Offset: 53e0 ~ 53e7
0xa92b, 0xa92c, 0xa92d, 0xa92e, 0xa92f, 0xa930, 0xa931, 0xa932,  // Offset: 53e8 ~ 53ef
0xa933, 0xa934, 0xa935, 0xa936, 0xa937, 0xa938, 0xa939, 0xa93a,  // Offset: 53f0 ~ 53f7
0xa93b, 0xa93c, 0xa93d, 0xa93e, 0xa93f, 0xa940, 0xa941, 0xa942,  // Offset: 53f8 ~ 53ff
0xa943, 0xa944, 0xa945, 0xa946, 0xa947, 0xa948, 0xa949, 0xa94a,  // Offset: 5400 ~ 5407
0xa94b, 0xa94c, 0xa94d, 0xa94e, 0xa94f, 0xa950, 0xa951, 0xa952,  // Offset: 5408 ~ 540f
0xa953, 0xa954, 0xa955, 0xa956, 0xa957, 0xa958, 0xa959, 0xa95a,  // Offset: 5410 ~ 5417
0xa95b, 0xa95c, 0xa95d, 0xa95e, 0xa95f, 0xa960, 0xa961, 0xa962,  // Offset: 5418 ~ 541f
0xa963, 0xa964, 0xa965, 0xa966, 0xa967, 0xa968, 0xa969, 0xa96a,  // Offset: 5420 ~ 5427
0xa96b, 0xa96c, 0xa96d, 0xa96e, 0xa96f, 0xa970, 0xa971, 0xa972,  // Offset: 5428 ~ 542f
0xa973, 0xa974, 0xa975, 0xa976, 0xa977, 0xa978, 0xa979, 0xa97a,  // Offset: 5430 ~ 5437
0xa97b, 0xa97c, 0xa97d, 0xa97e, 0xa97f, 0xa980, 0xa981, 0xa982,  // Offset: 5438 ~ 543f
0xa983, 0xa984, 0xa985, 0xa986, 0xa987, 0xa988, 0xa989, 0xa98a,  // Offset: 5440 ~ 5447
0xa98b, 0xa98c, 0xa98d, 0xa98e, 0xa98f, 0xa990, 0xa991, 0xa992,  // Offset: 5448 ~ 544f
0xa993, 0xa994, 0xa995, 0xa996, 0xa997, 0xa998, 0xa999, 0xa99a,  // Offset: 5450 ~ 5457
0xa99b, 0xa99c, 0xa99d, 0xa99e, 0xa99f, 0xa9a0, 0xa9a1, 0xa9a2,  // Offset: 5458 ~ 545f
0xa9a3, 0xa9a4, 0xa9a5, 0xa9a6, 0xa9a7, 0xa9a8, 0xa9a9, 0xa9aa,  // Offset: 5460 ~ 5467
0xa9ab, 0xa9ac, 0xa9ad, 0xa9ae, 0xa9af, 0xa9b0, 0xa9b1, 0xa9b2,  // Offset: 5468 ~ 546f
0xa9b3, 0xa9b4, 0xa9b5, 0xa9b6, 0xa9b7, 0xa9b8, 0xa9b9, 0xa9ba,  // Offset: 5470 ~ 5477
0xa9bb, 0xa9bc, 0xa9bd, 0xa9be, 0xa9bf, 0xa9c0, 0xa9c1, 0xa9c2,  // Offset: 5478 ~ 547f
0xa9c3, 0xa9c4, 0xa9c5, 0xa9c6, 0xa9c7, 0xa9c8, 0xa9c9, 0xa9ca,  // Offset: 5480 ~ 5487
0xa9cb, 0xa9cc, 0xa9cd, 0xa9ce, 0xa9cf, 0xa9d0, 0xa9d1, 0xa9d2,  // Offset: 5488 ~ 548f
0xa9d3, 0xa9d4, 0xa9d5, 0xa9d6, 0xa9d7, 0xa9d8, 0xa9d9, 0xa9da,  // Offset: 5490 ~ 5497
0xa9db, 0xa9dc, 0xa9dd, 0xa9de, 0xa9df, 0xa9e0, 0xa9e1, 0xa9e2,  // Offset: 5498 ~ 549f
0xa9e3, 0xa9e4, 0xa9e5, 0xa9e6, 0xa9e7, 0xa9e8, 0xa9e9, 0xa9ea,  // Offset: 54a0 ~ 54a7
0xa9eb, 0xa9ec, 0xa9ed, 0xa9ee, 0xa9ef, 0xa9f0, 0xa9f1, 0xa9f2,  // Offset: 54a8 ~ 54af
0xa9f3, 0xa9f4, 0xa9f5, 0xa9f6, 0xa9f7, 0xa9f8, 0xa9f9, 0xa9fa,  // Offset: 54b0 ~ 54b7
0xa9fb, 0xa9fc, 0xa9fd, 0xa9fe, 0xa9ff, 0xaa00, 0xaa01, 0xaa02,  // Offset: 54b8 ~ 54bf
0xaa03, 0xaa04, 0xaa05, 0xaa06, 0xaa07, 0xaa08, 0xaa09, 0xaa0a,  // Offset: 54c0 ~ 54c7
0xaa0b, 0xaa0c, 0xaa0d, 0xaa0e, 0xaa0f, 0xaa10, 0xaa11, 0xaa12,  // Offset: 54c8 ~ 54cf
0xaa13, 0xaa14, 0xaa15, 0xaa16, 0xaa17, 0xaa18, 0xaa19, 0xaa1a,  // Offset: 54d0 ~ 54d7
0xaa1b, 0xaa1c, 0xaa1d, 0xaa1e, 0xaa1f, 0xaa20, 0xaa21, 0xaa22,  // Offset: 54d8 ~ 54df
0xaa23, 0xaa24, 0xaa25, 0xaa26, 0xaa27, 0xaa28, 0xaa29, 0xaa2a,  // Offset: 54e0 ~ 54e7
0xaa2b, 0xaa2c, 0xaa2d, 0xaa2e, 0xaa2f, 0xaa30, 0xaa31, 0xaa32,  // Offset: 54e8 ~ 54ef
0xaa33, 0xaa34, 0xaa35, 0xaa36, 0xaa37, 0xaa38, 0xaa39, 0xaa3a,  // Offset: 54f0 ~ 54f7
0xaa3b, 0xaa3c, 0xaa3d, 0xaa3e, 0xaa3f, 0xaa40, 0xaa41, 0xaa42,  // Offset: 54f8 ~ 54ff
0xaa43, 0xaa44, 0xaa45, 0xaa46, 0xaa47, 0xaa48, 0xaa49, 0xaa4a,  // Offset: 5500 ~ 5507
0xaa4b, 0xaa4c, 0xaa4d, 0xaa4e, 0xaa4f, 0xaa50, 0xaa51, 0xaa52,  // Offset: 5508 ~ 550f
0xaa53, 0xaa54, 0xaa55, 0xaa56, 0xaa57, 0xaa58, 0xaa59, 0xaa5a,  // Offset: 5510 ~ 5517
0xaa5b, 0xaa5c, 0xaa5d, 0xaa5e, 0xaa5f, 0xaa60, 0xaa61, 0xaa62,  // Offset: 5518 ~ 551f
0xaa63, 0xaa64, 0xaa65, 0xaa66, 0xaa67, 0xaa68, 0xaa69, 0xaa6a,  // Offset: 5520 ~ 5527
0xaa6b, 0xaa6c, 0xaa6d, 0xaa6e, 0xaa6f, 0xaa70, 0xaa71, 0xaa72,  // Offset: 5528 ~ 552f
0xaa73, 0xaa74, 0xaa75, 0xaa76, 0xaa77, 0xaa78, 0xaa79, 0xaa7a,  // Offset: 5530 ~ 5537
0xaa7b, 0xaa7c, 0xaa7d, 0xaa7e, 0xaa7f, 0xaa80, 0xaa81, 0xaa82,  // Offset: 5538 ~ 553f
0xaa83, 0xaa84, 0xaa85, 0xaa86, 0xaa87, 0xaa88, 0xaa89, 0xaa8a,  // Offset: 5540 ~ 5547
0xaa8b, 0xaa8c, 0xaa8d, 0xaa8e, 0xaa8f, 0xaa90, 0xaa91, 0xaa92,  // Offset: 5548 ~ 554f
0xaa93, 0xaa94, 0xaa95, 0xaa96, 0xaa97, 0xaa98, 0xaa99, 0xaa9a,  // Offset: 5550 ~ 5557
0xaa9b, 0xaa9c, 0xaa9d, 0xaa9e, 0xaa9f, 0xaaa0, 0xaaa1, 0xaaa2,  // Offset: 5558 ~ 555f
0xaaa3, 0xaaa4, 0xaaa5, 0xaaa6, 0xaaa7, 0xaaa8, 0xaaa9, 0xaaaa,  // Offset: 5560 ~ 5567
0xaaab, 0xaaac, 0xaaad, 0xaaae, 0xaaaf, 0xaab0, 0xaab1, 0xaab2,  // Offset: 5568 ~ 556f
0xaab3, 0xaab4, 0xaab5, 0xaab6, 0xaab7, 0xaab8, 0xaab9, 0xaaba,  // Offset: 5570 ~ 5577
0xaabb, 0xaabc, 0xaabd, 0xaabe, 0xaabf, 0xaac0, 0xaac1, 0xaac2,  // Offset: 5578 ~ 557f
0xaac3, 0xaac4, 0xaac5, 0xaac6, 0xaac7, 0xaac8, 0xaac9, 0xaaca,  // Offset: 5580 ~ 5587
0xaacb, 0xaacc, 0xaacd, 0xaace, 0xaacf, 0xaad0, 0xaad1, 0xaad2,  // Offset: 5588 ~ 558f
0xaad3, 0xaad4, 0xaad5, 0xaad6, 0xaad7, 0xaad8, 0xaad9, 0xaada,  // Offset: 5590 ~ 5597
0xaadb, 0xaadc, 0xaadd, 0xaade, 0xaadf, 0xaae0, 0xaae1, 0xaae2,  // Offset: 5598 ~ 559f
0xaae3, 0xaae4, 0xaae5, 0xaae6, 0xaae7, 0xaae8, 0xaae9, 0xaaea,  // Offset: 55a0 ~ 55a7
0xaaeb, 0xaaec, 0xaaed, 0xaaee, 0xaaef, 0xaaf0, 0xaaf1, 0xaaf2,  // Offset: 55a8 ~ 55af
0xaaf3, 0xaaf4, 0xaaf5, 0xaaf6, 0xaaf7, 0xaaf8, 0xaaf9, 0xaafa,  // Offset: 55b0 ~ 55b7
0xaafb, 0xaafc, 0xaafd, 0xaafe, 0xaaff, 0xab00, 0xab01, 0xab02,  // Offset: 55b8 ~ 55bf
0xab03, 0xab04, 0xab05, 0xab06, 0xab07, 0xab08, 0xab09, 0xab0a,  // Offset: 55c0 ~ 55c7
0xab0b, 0xab0c, 0xab0d, 0xab0e, 0xab0f, 0xab10, 0xab11, 0xab12,  // Offset: 55c8 ~ 55cf
0xab13, 0xab14, 0xab15, 0xab16, 0xab17, 0xab18, 0xab19, 0xab1a,  // Offset: 55d0 ~ 55d7
0xab1b, 0xab1c, 0xab1d, 0xab1e, 0xab1f, 0xab20, 0xab21, 0xab22,  // Offset: 55d8 ~ 55df
0xab23, 0xab24, 0xab25, 0xab26, 0xab27, 0xab28, 0xab29, 0xab2a,  // Offset: 55e0 ~ 55e7
0xab2b, 0xab2c, 0xab2d, 0xab2e, 0xab2f, 0xab30, 0xab31, 0xab32,  // Offset: 55e8 ~ 55ef
0xab33, 0xab34, 0xab35, 0xab36, 0xab37, 0xab38, 0xab39, 0xab3a,  // Offset: 55f0 ~ 55f7
0xab3b, 0xab3c, 0xab3d, 0xab3e, 0xab3f, 0xab40, 0xab41, 0xab42,  // Offset: 55f8 ~ 55ff
0xab43, 0xab44, 0xab45, 0xab46, 0xab47, 0xab48, 0xab49, 0xab4a,  // Offset: 5600 ~ 5607
0xab4b, 0xab4c, 0xab4d, 0xab4e, 0xab4f, 0xab50, 0xab51, 0xab52,  // Offset: 5608 ~ 560f
0xab53, 0xab54, 0xab55, 0xab56, 0xab57, 0xab58, 0xab59, 0xab5a,  // Offset: 5610 ~ 5617
0xab5b, 0xab5c, 0xab5d, 0xab5e, 0xab5f, 0xab60, 0xab61, 0xab62,  // Offset: 5618 ~ 561f
0xab63, 0xab64, 0xab65, 0xab66, 0xab67, 0xab68, 0xab69, 0xab6a,  // Offset: 5620 ~ 5627
0xab6b, 0xab6c, 0xab6d, 0xab6e, 0xab6f, 0xab70, 0xab71, 0xab72,  // Offset: 5628 ~ 562f
0xab73, 0xab74, 0xab75, 0xab76, 0xab77, 0xab78, 0xab79, 0xab7a,  // Offset: 5630 ~ 5637
0xab7b, 0xab7c, 0xab7d, 0xab7e, 0xab7f, 0xab80, 0xab81, 0xab82,  // Offset: 5638 ~ 563f
0xab83, 0xab84, 0xab85, 0xab86, 0xab87, 0xab88, 0xab89, 0xab8a,  // Offset: 5640 ~ 5647
0xab8b, 0xab8c, 0xab8d, 0xab8e, 0xab8f, 0xab90, 0xab91, 0xab92,  // Offset: 5648 ~ 564f
0xab93, 0xab94, 0xab95, 0xab96, 0xab97, 0xab98, 0xab99, 0xab9a,  // Offset: 5650 ~ 5657
0xab9b, 0xab9c, 0xab9d, 0xab9e, 0xab9f, 0xaba0, 0xaba1, 0xaba2,  // Offset: 5658 ~ 565f
0xaba3, 0xaba4, 0xaba5, 0xaba6, 0xaba7, 0xaba8, 0xaba9, 0xabaa,  // Offset: 5660 ~ 5667
0xabab, 0xabac, 0xabad, 0xabae, 0xabaf, 0xabb0, 0xabb1, 0xabb2,  // Offset: 5668 ~ 566f
0xabb3, 0xabb4, 0xabb5, 0xabb6, 0xabb7, 0xabb8, 0xabb9, 0xabba,  // Offset: 5670 ~ 5677
0xabbb, 0xabbc, 0xabbd, 0xabbe, 0xabbf, 0xabc0, 0xabc1, 0xabc2,  // Offset: 5678 ~ 567f
0xabc3, 0xabc4, 0xabc5, 0xabc6, 0xabc7, 0xabc8, 0xabc9, 0xabca,  // Offset: 5680 ~ 5687
0xabcb, 0xabcc, 0xabcd, 0xabce, 0xabcf, 0xabd0, 0xabd1, 0xabd2,  // Offset: 5688 ~ 568f
0xabd3, 0xabd4, 0xabd5, 0xabd6, 0xabd7, 0xabd8, 0xabd9, 0xabda,  // Offset: 5690 ~ 5697
0xabdb, 0xabdc, 0xabdd, 0xabde, 0xabdf, 0xabe0, 0xabe1, 0xabe2,  // Offset: 5698 ~ 569f
0xabe3, 0xabe4, 0xabe5, 0xabe6, 0xabe7, 0xabe8, 0xabe9, 0xabea,  // Offset: 56a0 ~ 56a7
0xabeb, 0xabec, 0xabed, 0xabee, 0xabef, 0xabf0, 0xabf1, 0xabf2,  // Offset: 56a8 ~ 56af
0xabf3, 0xabf4, 0xabf5, 0xabf6, 0xabf7, 0xabf8, 0xabf9, 0xabfa,  // Offset: 56b0 ~ 56b7
0xabfb, 0xabfc, 0xabfd, 0xabfe, 0xabff, 0xac00, 0xac01, 0xac02,  // Offset: 56b8 ~ 56bf
0xac03, 0xac04, 0xac05, 0xac06, 0xac07, 0xac08, 0xac09, 0xac0a,  // Offset: 56c0 ~ 56c7
0xac0b, 0xac0c, 0xac0d, 0xac0e, 0xac0f, 0xac10, 0xac11, 0xac12,  // Offset: 56c8 ~ 56cf
0xac13, 0xac14, 0xac15, 0xac16, 0xac17, 0xac18, 0xac19, 0xac1a,  // Offset: 56d0 ~ 56d7
0xac1b, 0xac1c, 0xac1d, 0xac1e, 0xac1f, 0xac20, 0xac21, 0xac22,  // Offset: 56d8 ~ 56df
0xac23, 0xac24, 0xac25, 0xac26, 0xac27, 0xac28, 0xac29, 0xac2a,  // Offset: 56e0 ~ 56e7
0xac2b, 0xac2c, 0xac2d, 0xac2e, 0xac2f, 0xac30, 0xac31, 0xac32,  // Offset: 56e8 ~ 56ef
0xac33, 0xac34, 0xac35, 0xac36, 0xac37, 0xac38, 0xac39, 0xac3a,  // Offset: 56f0 ~ 56f7
0xac3b, 0xac3c, 0xac3d, 0xac3e, 0xac3f, 0xac40, 0xac41, 0xac42,  // Offset: 56f8 ~ 56ff
0xac43, 0xac44, 0xac45, 0xac46, 0xac47, 0xac48, 0xac49, 0xac4a,  // Offset: 5700 ~ 5707
0xac4b, 0xac4c, 0xac4d, 0xac4e, 0xac4f, 0xac50, 0xac51, 0xac52,  // Offset: 5708 ~ 570f
0xac53, 0xac54, 0xac55, 0xac56, 0xac57, 0xac58, 0xac59, 0xac5a,  // Offset: 5710 ~ 5717
0xac5b, 0xac5c, 0xac5d, 0xac5e, 0xac5f, 0xac60, 0xac61, 0xac62,  // Offset: 5718 ~ 571f
0xac63, 0xac64, 0xac65, 0xac66, 0xac67, 0xac68, 0xac69, 0xac6a,  // Offset: 5720 ~ 5727
0xac6b, 0xac6c, 0xac6d, 0xac6e, 0xac6f, 0xac70, 0xac71, 0xac72,  // Offset: 5728 ~ 572f
0xac73, 0xac74, 0xac75, 0xac76, 0xac77, 0xac78, 0xac79, 0xac7a,  // Offset: 5730 ~ 5737
0xac7b, 0xac7c, 0xac7d, 0xac7e, 0xac7f, 0xac80, 0xac81, 0xac82,  // Offset: 5738 ~ 573f
0xac83, 0xac84, 0xac85, 0xac86, 0xac87, 0xac88, 0xac89, 0xac8a,  // Offset: 5740 ~ 5747
0xac8b, 0xac8c, 0xac8d, 0xac8e, 0xac8f, 0xac90, 0xac91, 0xac92,  // Offset: 5748 ~ 574f
0xac93, 0xac94, 0xac95, 0xac96, 0xac97, 0xac98, 0xac99, 0xac9a,  // Offset: 5750 ~ 5757
0xac9b, 0xac9c, 0xac9d, 0xac9e, 0xac9f, 0xaca0, 0xaca1, 0xaca2,  // Offset: 5758 ~ 575f
0xaca3, 0xaca4, 0xaca5, 0xaca6, 0xaca7, 0xaca8, 0xaca9, 0xacaa,  // Offset: 5760 ~ 5767
0xacab, 0xacac, 0xacad, 0xacae, 0xacaf, 0xacb0, 0xacb1, 0xacb2,  // Offset: 5768 ~ 576f
0xacb3, 0xacb4, 0xacb5, 0xacb6, 0xacb7, 0xacb8, 0xacb9, 0xacba,  // Offset: 5770 ~ 5777
0xacbb, 0xacbc, 0xacbd, 0xacbe, 0xacbf, 0xacc0, 0xacc1, 0xacc2,  // Offset: 5778 ~ 577f
0xacc3, 0xacc4, 0xacc5, 0xacc6, 0xacc7, 0xacc8, 0xacc9, 0xacca,  // Offset: 5780 ~ 5787
0xaccb, 0xaccc, 0xaccd, 0xacce, 0xaccf, 0xacd0, 0xacd1, 0xacd2,  // Offset: 5788 ~ 578f
0xacd3, 0xacd4, 0xacd5, 0xacd6, 0xacd7, 0xacd8, 0xacd9, 0xacda,  // Offset: 5790 ~ 5797
0xacdb, 0xacdc, 0xacdd, 0xacde, 0xacdf, 0xace0, 0xace1, 0xace2,  // Offset: 5798 ~ 579f
0xace3, 0xace4, 0xace5, 0xace6, 0xace7, 0xace8, 0xace9, 0xacea,  // Offset: 57a0 ~ 57a7
0xaceb, 0xacec, 0xaced, 0xacee, 0xacef, 0xacf0, 0xacf1, 0xacf2,  // Offset: 57a8 ~ 57af
0xacf3, 0xacf4, 0xacf5, 0xacf6, 0xacf7, 0xacf8, 0xacf9, 0xacfa,  // Offset: 57b0 ~ 57b7
0xacfb, 0xacfc, 0xacfd, 0xacfe, 0xacff, 0xad00, 0xad01, 0xad02,  // Offset: 57b8 ~ 57bf
0xad03, 0xad04, 0xad05, 0xad06, 0xad07, 0xad08, 0xad09, 0xad0a,  // Offset: 57c0 ~ 57c7
0xad0b, 0xad0c, 0xad0d, 0xad0e, 0xad0f, 0xad10, 0xad11, 0xad12,  // Offset: 57c8 ~ 57cf
0xad13, 0xad14, 0xad15, 0xad16, 0xad17, 0xad18, 0xad19, 0xad1a,  // Offset: 57d0 ~ 57d7
0xad1b, 0xad1c, 0xad1d, 0xad1e, 0xad1f, 0xad20, 0xad21, 0xad22,  // Offset: 57d8 ~ 57df
0xad23, 0xad24, 0xad25, 0xad26, 0xad27, 0xad28, 0xad29, 0xad2a,  // Offset: 57e0 ~ 57e7
0xad2b, 0xad2c, 0xad2d, 0xad2e, 0xad2f, 0xad30, 0xad31, 0xad32,  // Offset: 57e8 ~ 57ef
0xad33, 0xad34, 0xad35, 0xad36, 0xad37, 0xad38, 0xad39, 0xad3a,  // Offset: 57f0 ~ 57f7
0xad3b, 0xad3c, 0xad3d, 0xad3e, 0xad3f, 0xad40, 0xad41, 0xad42,  // Offset: 57f8 ~ 57ff
0xad43, 0xad44, 0xad45, 0xad46, 0xad47, 0xad48, 0xad49, 0xad4a,  // Offset: 5800 ~ 5807
0xad4b, 0xad4c, 0xad4d, 0xad4e, 0xad4f, 0xad50, 0xad51, 0xad52,  // Offset: 5808 ~ 580f
0xad53, 0xad54, 0xad55, 0xad56, 0xad57, 0xad58, 0xad59, 0xad5a,  // Offset: 5810 ~ 5817
0xad5b, 0xad5c, 0xad5d, 0xad5e, 0xad5f, 0xad60, 0xad61, 0xad62,  // Offset: 5818 ~ 581f
0xad63, 0xad64, 0xad65, 0xad66, 0xad67, 0xad68, 0xad69, 0xad6a,  // Offset: 5820 ~ 5827
0xad6b, 0xad6c, 0xad6d, 0xad6e, 0xad6f, 0xad70, 0xad71, 0xad72,  // Offset: 5828 ~ 582f
0xad73, 0xad74, 0xad75, 0xad76, 0xad77, 0xad78, 0xad79, 0xad7a,  // Offset: 5830 ~ 5837
0xad7b, 0xad7c, 0xad7d, 0xad7e, 0xad7f, 0xad80, 0xad81, 0xad82,  // Offset: 5838 ~ 583f
0xad83, 0xad84, 0xad85, 0xad86, 0xad87, 0xad88, 0xad89, 0xad8a,  // Offset: 5840 ~ 5847
0xad8b, 0xad8c, 0xad8d, 0xad8e, 0xad8f, 0xad90, 0xad91, 0xad92,  // Offset: 5848 ~ 584f
0xad93, 0xad94, 0xad95, 0xad96, 0xad97, 0xad98, 0xad99, 0xad9a,  // Offset: 5850 ~ 5857
0xad9b, 0xad9c, 0xad9d, 0xad9e, 0xad9f, 0xada0, 0xada1, 0xada2,  // Offset: 5858 ~ 585f
0xada3, 0xada4, 0xada5, 0xada6, 0xada7, 0xada8, 0xada9, 0xadaa,  // Offset: 5860 ~ 5867
0xadab, 0xadac, 0xadad, 0xadae, 0xadaf, 0xadb0, 0xadb1, 0xadb2,  // Offset: 5868 ~ 586f
0xadb3, 0xadb4, 0xadb5, 0xadb6, 0xadb7, 0xadb8, 0xadb9, 0xadba,  // Offset: 5870 ~ 5877
0xadbb, 0xadbc, 0xadbd, 0xadbe, 0xadbf, 0xadc0, 0xadc1, 0xadc2,  // Offset: 5878 ~ 587f
0xadc3, 0xadc4, 0xadc5, 0xadc6, 0xadc7, 0xadc8, 0xadc9, 0xadca,  // Offset: 5880 ~ 5887
0xadcb, 0xadcc, 0xadcd, 0xadce, 0xadcf, 0xadd0, 0xadd1, 0xadd2,  // Offset: 5888 ~ 588f
0xadd3, 0xadd4, 0xadd5, 0xadd6, 0xadd7, 0xadd8, 0xadd9, 0xadda,  // Offset: 5890 ~ 5897
0xaddb, 0xaddc, 0xaddd, 0xadde, 0xaddf, 0xade0, 0xade1, 0xade2,  // Offset: 5898 ~ 589f
0xade3, 0xade4, 0xade5, 0xade6, 0xade7, 0xade8, 0xade9, 0xadea,  // Offset: 58a0 ~ 58a7
0xadeb, 0xadec, 0xaded, 0xadee, 0xadef, 0xadf0, 0xadf1, 0xadf2,  // Offset: 58a8 ~ 58af
0xadf3, 0xadf4, 0xadf5, 0xadf6, 0xadf7, 0xadf8, 0xadf9, 0xadfa,  // Offset: 58b0 ~ 58b7
0xadfb, 0xadfc, 0xadfd, 0xadfe, 0xadff, 0xae00, 0xae01, 0xae02,  // Offset: 58b8 ~ 58bf
0xae03, 0xae04, 0xae05, 0xae06, 0xae07, 0xae08, 0xae09, 0xae0a,  // Offset: 58c0 ~ 58c7
0xae0b, 0xae0c, 0xae0d, 0xae0e, 0xae0f, 0xae10, 0xae11, 0xae12,  // Offset: 58c8 ~ 58cf
0xae13, 0xae14, 0xae15, 0xae16, 0xae17, 0xae18, 0xae19, 0xae1a,  // Offset: 58d0 ~ 58d7
0xae1b, 0xae1c, 0xae1d, 0xae1e, 0xae1f, 0xae20, 0xae21, 0xae22,  // Offset: 58d8 ~ 58df
0xae23, 0xae24, 0xae25, 0xae26, 0xae27, 0xae28, 0xae29, 0xae2a,  // Offset: 58e0 ~ 58e7
0xae2b, 0xae2c, 0xae2d, 0xae2e, 0xae2f, 0xae30, 0xae31, 0xae32,  // Offset: 58e8 ~ 58ef
0xae33, 0xae34, 0xae35, 0xae36, 0xae37, 0xae38, 0xae39, 0xae3a,  // Offset: 58f0 ~ 58f7
0xae3b, 0xae3c, 0xae3d, 0xae3e, 0xae3f, 0xae40, 0xae41, 0xae42,  // Offset: 58f8 ~ 58ff
0xae43, 0xae44, 0xae45, 0xae46, 0xae47, 0xae48, 0xae49, 0xae4a,  // Offset: 5900 ~ 5907
0xae4b, 0xae4c, 0xae4d, 0xae4e, 0xae4f, 0xae50, 0xae51, 0xae52,  // Offset: 5908 ~ 590f
0xae53, 0xae54, 0xae55, 0xae56, 0xae57, 0xae58, 0xae59, 0xae5a,  // Offset: 5910 ~ 5917
0xae5b, 0xae5c, 0xae5d, 0xae5e, 0xae5f, 0xae60, 0xae61, 0xae62,  // Offset: 5918 ~ 591f
0xae63, 0xae64, 0xae65, 0xae66, 0xae67, 0xae68, 0xae69, 0xae6a,  // Offset: 5920 ~ 5927
0xae6b, 0xae6c, 0xae6d, 0xae6e, 0xae6f, 0xae70, 0xae71, 0xae72,  // Offset: 5928 ~ 592f
0xae73, 0xae74, 0xae75, 0xae76, 0xae77, 0xae78, 0xae79, 0xae7a,  // Offset: 5930 ~ 5937
0xae7b, 0xae7c, 0xae7d, 0xae7e, 0xae7f, 0xae80, 0xae81, 0xae82,  // Offset: 5938 ~ 593f
0xae83, 0xae84, 0xae85, 0xae86, 0xae87, 0xae88, 0xae89, 0xae8a,  // Offset: 5940 ~ 5947
0xae8b, 0xae8c, 0xae8d, 0xae8e, 0xae8f, 0xae90, 0xae91, 0xae92,  // Offset: 5948 ~ 594f
0xae93, 0xae94, 0xae95, 0xae96, 0xae97, 0xae98, 0xae99, 0xae9a,  // Offset: 5950 ~ 5957
0xae9b, 0xae9c, 0xae9d, 0xae9e, 0xae9f, 0xaea0, 0xaea1, 0xaea2,  // Offset: 5958 ~ 595f
0xaea3, 0xaea4, 0xaea5, 0xaea6, 0xaea7, 0xaea8, 0xaea9, 0xaeaa,  // Offset: 5960 ~ 5967
0xaeab, 0xaeac, 0xaead, 0xaeae, 0xaeaf, 0xaeb0, 0xaeb1, 0xaeb2,  // Offset: 5968 ~ 596f
0xaeb3, 0xaeb4, 0xaeb5, 0xaeb6, 0xaeb7, 0xaeb8, 0xaeb9, 0xaeba,  // Offset: 5970 ~ 5977
0xaebb, 0xaebc, 0xaebd, 0xaebe, 0xaebf, 0xaec0, 0xaec1, 0xaec2,  // Offset: 5978 ~ 597f
0xaec3, 0xaec4, 0xaec5, 0xaec6, 0xaec7, 0xaec8, 0xaec9, 0xaeca,  // Offset: 5980 ~ 5987
0xaecb, 0xaecc, 0xaecd, 0xaece, 0xaecf, 0xaed0, 0xaed1, 0xaed2,  // Offset: 5988 ~ 598f
0xaed3, 0xaed4, 0xaed5, 0xaed6, 0xaed7, 0xaed8, 0xaed9, 0xaeda,  // Offset: 5990 ~ 5997
0xaedb, 0xaedc, 0xaedd, 0xaede, 0xaedf, 0xaee0, 0xaee1, 0xaee2,  // Offset: 5998 ~ 599f
0xaee3, 0xaee4, 0xaee5, 0xaee6, 0xaee7, 0xaee8, 0xaee9, 0xaeea,  // Offset: 59a0 ~ 59a7
0xaeeb, 0xaeec, 0xaeed, 0xaeee, 0xaeef, 0xaef0, 0xaef1, 0xaef2,  // Offset: 59a8 ~ 59af
0xaef3, 0xaef4, 0xaef5, 0xaef6, 0xaef7, 0xaef8, 0xaef9, 0xaefa,  // Offset: 59b0 ~ 59b7
0xaefb, 0xaefc, 0xaefd, 0xaefe, 0xaeff, 0xaf00, 0xaf01, 0xaf02,  // Offset: 59b8 ~ 59bf
0xaf03, 0xaf04, 0xaf05, 0xaf06, 0xaf07, 0xaf08, 0xaf09, 0xaf0a,  // Offset: 59c0 ~ 59c7
0xaf0b, 0xaf0c, 0xaf0d, 0xaf0e, 0xaf0f, 0xaf10, 0xaf11, 0xaf12,  // Offset: 59c8 ~ 59cf
0xaf13, 0xaf14, 0xaf15, 0xaf16, 0xaf17, 0xaf18, 0xaf19, 0xaf1a,  // Offset: 59d0 ~ 59d7
0xaf1b, 0xaf1c, 0xaf1d, 0xaf1e, 0xaf1f, 0xaf20, 0xaf21, 0xaf22,  // Offset: 59d8 ~ 59df
0xaf23, 0xaf24, 0xaf25, 0xaf26, 0xaf27, 0xaf28, 0xaf29, 0xaf2a,  // Offset: 59e0 ~ 59e7
0xaf2b, 0xaf2c, 0xaf2d, 0xaf2e, 0xaf2f, 0xaf30, 0xaf31, 0xaf32,  // Offset: 59e8 ~ 59ef
0xaf33, 0xaf34, 0xaf35, 0xaf36, 0xaf37, 0xaf38, 0xaf39, 0xaf3a,  // Offset: 59f0 ~ 59f7
0xaf3b, 0xaf3c, 0xaf3d, 0xaf3e, 0xaf3f, 0xaf40, 0xaf41, 0xaf42,  // Offset: 59f8 ~ 59ff
0xaf43, 0xaf44, 0xaf45, 0xaf46, 0xaf47, 0xaf48, 0xaf49, 0xaf4a,  // Offset: 5a00 ~ 5a07
0xaf4b, 0xaf4c, 0xaf4d, 0xaf4e, 0xaf4f, 0xaf50, 0xaf51, 0xaf52,  // Offset: 5a08 ~ 5a0f
0xaf53, 0xaf54, 0xaf55, 0xaf56, 0xaf57, 0xaf58, 0xaf59, 0xaf5a,  // Offset: 5a10 ~ 5a17
0xaf5b, 0xaf5c, 0xaf5d, 0xaf5e, 0xaf5f, 0xaf60, 0xaf61, 0xaf62,  // Offset: 5a18 ~ 5a1f
0xaf63, 0xaf64, 0xaf65, 0xaf66, 0xaf67, 0xaf68, 0xaf69, 0xaf6a,  // Offset: 5a20 ~ 5a27
0xaf6b, 0xaf6c, 0xaf6d, 0xaf6e, 0xaf6f, 0xaf70, 0xaf71, 0xaf72,  // Offset: 5a28 ~ 5a2f
0xaf73, 0xaf74, 0xaf75, 0xaf76, 0xaf77, 0xaf78, 0xaf79, 0xaf7a,  // Offset: 5a30 ~ 5a37
0xaf7b, 0xaf7c, 0xaf7d, 0xaf7e, 0xaf7f, 0xaf80, 0xaf81, 0xaf82,  // Offset: 5a38 ~ 5a3f
0xaf83, 0xaf84, 0xaf85, 0xaf86, 0xaf87, 0xaf88, 0xaf89, 0xaf8a,  // Offset: 5a40 ~ 5a47
0xaf8b, 0xaf8c, 0xaf8d, 0xaf8e, 0xaf8f, 0xaf90, 0xaf91, 0xaf92,  // Offset: 5a48 ~ 5a4f
0xaf93, 0xaf94, 0xaf95, 0xaf96, 0xaf97, 0xaf98, 0xaf99, 0xaf9a,  // Offset: 5a50 ~ 5a57
0xaf9b, 0xaf9c, 0xaf9d, 0xaf9e, 0xaf9f, 0xafa0, 0xafa1, 0xafa2,  // Offset: 5a58 ~ 5a5f
0xafa3, 0xafa4, 0xafa5, 0xafa6, 0xafa7, 0xafa8, 0xafa9, 0xafaa,  // Offset: 5a60 ~ 5a67
0xafab, 0xafac, 0xafad, 0xafae, 0xafaf, 0xafb0, 0xafb1, 0xafb2,  // Offset: 5a68 ~ 5a6f
0xafb3, 0xafb4, 0xafb5, 0xafb6, 0xafb7, 0xafb8, 0xafb9, 0xafba,  // Offset: 5a70 ~ 5a77
0xafbb, 0xafbc, 0xafbd, 0xafbe, 0xafbf, 0xafc0, 0xafc1, 0xafc2,  // Offset: 5a78 ~ 5a7f
0xafc3, 0xafc4, 0xafc5, 0xafc6, 0xafc7, 0xafc8, 0xafc9, 0xafca,  // Offset: 5a80 ~ 5a87
0xafcb, 0xafcc, 0xafcd, 0xafce, 0xafcf, 0xafd0, 0xafd1, 0xafd2,  // Offset: 5a88 ~ 5a8f
0xafd3, 0xafd4, 0xafd5, 0xafd6, 0xafd7, 0xafd8, 0xafd9, 0xafda,  // Offset: 5a90 ~ 5a97
0xafdb, 0xafdc, 0xafdd, 0xafde, 0xafdf, 0xafe0, 0xafe1, 0xafe2,  // Offset: 5a98 ~ 5a9f
0xafe3, 0xafe4, 0xafe5, 0xafe6, 0xafe7, 0xafe8, 0xafe9, 0xafea,  // Offset: 5aa0 ~ 5aa7
0xafeb, 0xafec, 0xafed, 0xafee, 0xafef, 0xaff0, 0xaff1, 0xaff2,  // Offset: 5aa8 ~ 5aaf
0xaff3, 0xaff4, 0xaff5, 0xaff6, 0xaff7, 0xaff8, 0xaff9, 0xaffa,  // Offset: 5ab0 ~ 5ab7
0xaffb, 0xaffc, 0xaffd, 0xaffe, 0xafff, 0xb000, 0xb001, 0xb002,  // Offset: 5ab8 ~ 5abf
0xb003, 0xb004, 0xb005, 0xb006, 0xb007, 0xb008, 0xb009, 0xb00a,  // Offset: 5ac0 ~ 5ac7
0xb00b, 0xb00c, 0xb00d, 0xb00e, 0xb00f, 0xb010, 0xb011, 0xb012,  // Offset: 5ac8 ~ 5acf
0xb013, 0xb014, 0xb015, 0xb016, 0xb017, 0xb018, 0xb019, 0xb01a,  // Offset: 5ad0 ~ 5ad7
0xb01b, 0xb01c, 0xb01d, 0xb01e, 0xb01f, 0xb020, 0xb021, 0xb022,  // Offset: 5ad8 ~ 5adf
0xb023, 0xb024, 0xb025, 0xb026, 0xb027, 0xb028, 0xb029, 0xb02a,  // Offset: 5ae0 ~ 5ae7
0xb02b, 0xb02c, 0xb02d, 0xb02e, 0xb02f, 0xb030, 0xb031, 0xb032,  // Offset: 5ae8 ~ 5aef
0xb033, 0xb034, 0xb035, 0xb036, 0xb037, 0xb038, 0xb039, 0xb03a,  // Offset: 5af0 ~ 5af7
0xb03b, 0xb03c, 0xb03d, 0xb03e, 0xb03f, 0xb040, 0xb041, 0xb042,  // Offset: 5af8 ~ 5aff
0xb043, 0xb044, 0xb045, 0xb046, 0xb047, 0xb048, 0xb049, 0xb04a,  // Offset: 5b00 ~ 5b07
0xb04b, 0xb04c, 0xb04d, 0xb04e, 0xb04f, 0xb050, 0xb051, 0xb052,  // Offset: 5b08 ~ 5b0f
0xb053, 0xb054, 0xb055, 0xb056, 0xb057, 0xb058, 0xb059, 0xb05a,  // Offset: 5b10 ~ 5b17
0xb05b, 0xb05c, 0xb05d, 0xb05e, 0xb05f, 0xb060, 0xb061, 0xb062,  // Offset: 5b18 ~ 5b1f
0xb063, 0xb064, 0xb065, 0xb066, 0xb067, 0xb068, 0xb069, 0xb06a,  // Offset: 5b20 ~ 5b27
0xb06b, 0xb06c, 0xb06d, 0xb06e, 0xb06f, 0xb070, 0xb071, 0xb072,  // Offset: 5b28 ~ 5b2f
0xb073, 0xb074, 0xb075, 0xb076, 0xb077, 0xb078, 0xb079, 0xb07a,  // Offset: 5b30 ~ 5b37
0xb07b, 0xb07c, 0xb07d, 0xb07e, 0xb07f, 0xb080, 0xb081, 0xb082,  // Offset: 5b38 ~ 5b3f
0xb083, 0xb084, 0xb085, 0xb086, 0xb087, 0xb088, 0xb089, 0xb08a,  // Offset: 5b40 ~ 5b47
0xb08b, 0xb08c, 0xb08d, 0xb08e, 0xb08f, 0xb090, 0xb091, 0xb092,  // Offset: 5b48 ~ 5b4f
0xb093, 0xb094, 0xb095, 0xb096, 0xb097, 0xb098, 0xb099, 0xb09a,  // Offset: 5b50 ~ 5b57
0xb09b, 0xb09c, 0xb09d, 0xb09e, 0xb09f, 0xb0a0, 0xb0a1, 0xb0a2,  // Offset: 5b58 ~ 5b5f
0xb0a3, 0xb0a4, 0xb0a5, 0xb0a6, 0xb0a7, 0xb0a8, 0xb0a9, 0xb0aa,  // Offset: 5b60 ~ 5b67
0xb0ab, 0xb0ac, 0xb0ad, 0xb0ae, 0xb0af, 0xb0b0, 0xb0b1, 0xb0b2,  // Offset: 5b68 ~ 5b6f
0xb0b3, 0xb0b4, 0xb0b5, 0xb0b6, 0xb0b7, 0xb0b8, 0xb0b9, 0xb0ba,  // Offset: 5b70 ~ 5b77
0xb0bb, 0xb0bc, 0xb0bd, 0xb0be, 0xb0bf, 0xb0c0, 0xb0c1, 0xb0c2,  // Offset: 5b78 ~ 5b7f
0xb0c3, 0xb0c4, 0xb0c5, 0xb0c6, 0xb0c7, 0xb0c8, 0xb0c9, 0xb0ca,  // Offset: 5b80 ~ 5b87
0xb0cb, 0xb0cc, 0xb0cd, 0xb0ce, 0xb0cf, 0xb0d0, 0xb0d1, 0xb0d2,  // Offset: 5b88 ~ 5b8f
0xb0d3, 0xb0d4, 0xb0d5, 0xb0d6, 0xb0d7, 0xb0d8, 0xb0d9, 0xb0da,  // Offset: 5b90 ~ 5b97
0xb0db, 0xb0dc, 0xb0dd, 0xb0de, 0xb0df, 0xb0e0, 0xb0e1, 0xb0e2,  // Offset: 5b98 ~ 5b9f
0xb0e3, 0xb0e4, 0xb0e5, 0xb0e6, 0xb0e7, 0xb0e8, 0xb0e9, 0xb0ea,  // Offset: 5ba0 ~ 5ba7
0xb0eb, 0xb0ec, 0xb0ed, 0xb0ee, 0xb0ef, 0xb0f0, 0xb0f1, 0xb0f2,  // Offset: 5ba8 ~ 5baf
0xb0f3, 0xb0f4, 0xb0f5, 0xb0f6, 0xb0f7, 0xb0f8, 0xb0f9, 0xb0fa,  // Offset: 5bb0 ~ 5bb7
0xb0fb, 0xb0fc, 0xb0fd, 0xb0fe, 0xb0ff, 0xb100, 0xb101, 0xb102,  // Offset: 5bb8 ~ 5bbf
0xb103, 0xb104, 0xb105, 0xb106, 0xb107, 0xb108, 0xb109, 0xb10a,  // Offset: 5bc0 ~ 5bc7
0xb10b, 0xb10c, 0xb10d, 0xb10e, 0xb10f, 0xb110, 0xb111, 0xb112,  // Offset: 5bc8 ~ 5bcf
0xb113, 0xb114, 0xb115, 0xb116, 0xb117, 0xb118, 0xb119, 0xb11a,  // Offset: 5bd0 ~ 5bd7
0xb11b, 0xb11c, 0xb11d, 0xb11e, 0xb11f, 0xb120, 0xb121, 0xb122,  // Offset: 5bd8 ~ 5bdf
0xb123, 0xb124, 0xb125, 0xb126, 0xb127, 0xb128, 0xb129, 0xb12a,  // Offset: 5be0 ~ 5be7
0xb12b, 0xb12c, 0xb12d, 0xb12e, 0xb12f, 0xb130, 0xb131, 0xb132,  // Offset: 5be8 ~ 5bef
0xb133, 0xb134, 0xb135, 0xb136, 0xb137, 0xb138, 0xb139, 0xb13a,  // Offset: 5bf0 ~ 5bf7
0xb13b, 0xb13c, 0xb13d, 0xb13e, 0xb13f, 0xb140, 0xb141, 0xb142,  // Offset: 5bf8 ~ 5bff
0xb143, 0xb144, 0xb145, 0xb146, 0xb147, 0xb148, 0xb149, 0xb14a,  // Offset: 5c00 ~ 5c07
0xb14b, 0xb14c, 0xb14d, 0xb14e, 0xb14f, 0xb150, 0xb151, 0xb152,  // Offset: 5c08 ~ 5c0f
0xb153, 0xb154, 0xb155, 0xb156, 0xb157, 0xb158, 0xb159, 0xb15a,  // Offset: 5c10 ~ 5c17
0xb15b, 0xb15c, 0xb15d, 0xb15e, 0xb15f, 0xb160, 0xb161, 0xb162,  // Offset: 5c18 ~ 5c1f
0xb163, 0xb164, 0xb165, 0xb166, 0xb167, 0xb168, 0xb169, 0xb16a,  // Offset: 5c20 ~ 5c27
0xb16b, 0xb16c, 0xb16d, 0xb16e, 0xb16f, 0xb170, 0xb171, 0xb172,  // Offset: 5c28 ~ 5c2f
0xb173, 0xb174, 0xb175, 0xb176, 0xb177, 0xb178, 0xb179, 0xb17a,  // Offset: 5c30 ~ 5c37
0xb17b, 0xb17c, 0xb17d, 0xb17e, 0xb17f, 0xb180, 0xb181, 0xb182,  // Offset: 5c38 ~ 5c3f
0xb183, 0xb184, 0xb185, 0xb186, 0xb187, 0xb188, 0xb189, 0xb18a,  // Offset: 5c40 ~ 5c47
0xb18b, 0xb18c, 0xb18d, 0xb18e, 0xb18f, 0xb190, 0xb191, 0xb192,  // Offset: 5c48 ~ 5c4f
0xb193, 0xb194, 0xb195, 0xb196, 0xb197, 0xb198, 0xb199, 0xb19a,  // Offset: 5c50 ~ 5c57
0xb19b, 0xb19c, 0xb19d, 0xb19e, 0xb19f, 0xb1a0, 0xb1a1, 0xb1a2,  // Offset: 5c58 ~ 5c5f
0xb1a3, 0xb1a4, 0xb1a5, 0xb1a6, 0xb1a7, 0xb1a8, 0xb1a9, 0xb1aa,  // Offset: 5c60 ~ 5c67
0xb1ab, 0xb1ac, 0xb1ad, 0xb1ae, 0xb1af, 0xb1b0, 0xb1b1, 0xb1b2,  // Offset: 5c68 ~ 5c6f
0xb1b3, 0xb1b4, 0xb1b5, 0xb1b6, 0xb1b7, 0xb1b8, 0xb1b9, 0xb1ba,  // Offset: 5c70 ~ 5c77
0xb1bb, 0xb1bc, 0xb1bd, 0xb1be, 0xb1bf, 0xb1c0, 0xb1c1, 0xb1c2,  // Offset: 5c78 ~ 5c7f
0xb1c3, 0xb1c4, 0xb1c5, 0xb1c6, 0xb1c7, 0xb1c8, 0xb1c9, 0xb1ca,  // Offset: 5c80 ~ 5c87
0xb1cb, 0xb1cc, 0xb1cd, 0xb1ce, 0xb1cf, 0xb1d0, 0xb1d1, 0xb1d2,  // Offset: 5c88 ~ 5c8f
0xb1d3, 0xb1d4, 0xb1d5, 0xb1d6, 0xb1d7, 0xb1d8, 0xb1d9, 0xb1da,  // Offset: 5c90 ~ 5c97
0xb1db, 0xb1dc, 0xb1dd, 0xb1de, 0xb1df, 0xb1e0, 0xb1e1, 0xb1e2,  // Offset: 5c98 ~ 5c9f
0xb1e3, 0xb1e4, 0xb1e5, 0xb1e6, 0xb1e7, 0xb1e8, 0xb1e9, 0xb1ea,  // Offset: 5ca0 ~ 5ca7
0xb1eb, 0xb1ec, 0xb1ed, 0xb1ee, 0xb1ef, 0xb1f0, 0xb1f1, 0xb1f2,  // Offset: 5ca8 ~ 5caf
0xb1f3, 0xb1f4, 0xb1f5, 0xb1f6, 0xb1f7, 0xb1f8, 0xb1f9, 0xb1fa,  // Offset: 5cb0 ~ 5cb7
0xb1fb, 0xb1fc, 0xb1fd, 0xb1fe, 0xb1ff, 0xb200, 0xb201, 0xb202,  // Offset: 5cb8 ~ 5cbf
0xb203, 0xb204, 0xb205, 0xb206, 0xb207, 0xb208, 0xb209, 0xb20a,  // Offset: 5cc0 ~ 5cc7
0xb20b, 0xb20c, 0xb20d, 0xb20e, 0xb20f, 0xb210, 0xb211, 0xb212,  // Offset: 5cc8 ~ 5ccf
0xb213, 0xb214, 0xb215, 0xb216, 0xb217, 0xb218, 0xb219, 0xb21a,  // Offset: 5cd0 ~ 5cd7
0xb21b, 0xb21c, 0xb21d, 0xb21e, 0xb21f, 0xb220, 0xb221, 0xb222,  // Offset: 5cd8 ~ 5cdf
0xb223, 0xb224, 0xb225, 0xb226, 0xb227, 0xb228, 0xb229, 0xb22a,  // Offset: 5ce0 ~ 5ce7
0xb22b, 0xb22c, 0xb22d, 0xb22e, 0xb22f, 0xb230, 0xb231, 0xb232,  // Offset: 5ce8 ~ 5cef
0xb233, 0xb234, 0xb235, 0xb236, 0xb237, 0xb238, 0xb239, 0xb23a,  // Offset: 5cf0 ~ 5cf7
0xb23b, 0xb23c, 0xb23d, 0xb23e, 0xb23f, 0xb240, 0xb241, 0xb242,  // Offset: 5cf8 ~ 5cff
0xb243, 0xb244, 0xb245, 0xb246, 0xb247, 0xb248, 0xb249, 0xb24a,  // Offset: 5d00 ~ 5d07
0xb24b, 0xb24c, 0xb24d, 0xb24e, 0xb24f, 0xb250, 0xb251, 0xb252,  // Offset: 5d08 ~ 5d0f
0xb253, 0xb254, 0xb255, 0xb256, 0xb257, 0xb258, 0xb259, 0xb25a,  // Offset: 5d10 ~ 5d17
0xb25b, 0xb25c, 0xb25d, 0xb25e, 0xb25f, 0xb260, 0xb261, 0xb262,  // Offset: 5d18 ~ 5d1f
0xb263, 0xb264, 0xb265, 0xb266, 0xb267, 0xb268, 0xb269, 0xb26a,  // Offset: 5d20 ~ 5d27
0xb26b, 0xb26c, 0xb26d, 0xb26e, 0xb26f, 0xb270, 0xb271, 0xb272,  // Offset: 5d28 ~ 5d2f
0xb273, 0xb274, 0xb275, 0xb276, 0xb277, 0xb278, 0xb279, 0xb27a,  // Offset: 5d30 ~ 5d37
0xb27b, 0xb27c, 0xb27d, 0xb27e, 0xb27f, 0xb280, 0xb281, 0xb282,  // Offset: 5d38 ~ 5d3f
0xb283, 0xb284, 0xb285, 0xb286, 0xb287, 0xb288, 0xb289, 0xb28a,  // Offset: 5d40 ~ 5d47
0xb28b, 0xb28c, 0xb28d, 0xb28e, 0xb28f, 0xb290, 0xb291, 0xb292,  // Offset: 5d48 ~ 5d4f
0xb293, 0xb294, 0xb295, 0xb296, 0xb297, 0xb298, 0xb299, 0xb29a,  // Offset: 5d50 ~ 5d57
0xb29b, 0xb29c, 0xb29d, 0xb29e, 0xb29f, 0xb2a0, 0xb2a1, 0xb2a2,  // Offset: 5d58 ~ 5d5f
0xb2a3, 0xb2a4, 0xb2a5, 0xb2a6, 0xb2a7, 0xb2a8, 0xb2a9, 0xb2aa,  // Offset: 5d60 ~ 5d67
0xb2ab, 0xb2ac, 0xb2ad, 0xb2ae, 0xb2af, 0xb2b0, 0xb2b1, 0xb2b2,  // Offset: 5d68 ~ 5d6f
0xb2b3, 0xb2b4, 0xb2b5, 0xb2b6, 0xb2b7, 0xb2b8, 0xb2b9, 0xb2ba,  // Offset: 5d70 ~ 5d77
0xb2bb, 0xb2bc, 0xb2bd, 0xb2be, 0xb2bf, 0xb2c0, 0xb2c1, 0xb2c2,  // Offset: 5d78 ~ 5d7f
0xb2c3, 0xb2c4, 0xb2c5, 0xb2c6, 0xb2c7, 0xb2c8, 0xb2c9, 0xb2ca,  // Offset: 5d80 ~ 5d87
0xb2cb, 0xb2cc, 0xb2cd, 0xb2ce, 0xb2cf, 0xb2d0, 0xb2d1, 0xb2d2,  // Offset: 5d88 ~ 5d8f
0xb2d3, 0xb2d4, 0xb2d5, 0xb2d6, 0xb2d7, 0xb2d8, 0xb2d9, 0xb2da,  // Offset: 5d90 ~ 5d97
0xb2db, 0xb2dc, 0xb2dd, 0xb2de, 0xb2df, 0xb2e0, 0xb2e1, 0xb2e2,  // Offset: 5d98 ~ 5d9f
0xb2e3, 0xb2e4, 0xb2e5, 0xb2e6, 0xb2e7, 0xb2e8, 0xb2e9, 0xb2ea,  // Offset: 5da0 ~ 5da7
0xb2eb, 0xb2ec, 0xb2ed, 0xb2ee, 0xb2ef, 0xb2f0, 0xb2f1, 0xb2f2,  // Offset: 5da8 ~ 5daf
0xb2f3, 0xb2f4, 0xb2f5, 0xb2f6, 0xb2f7, 0xb2f8, 0xb2f9, 0xb2fa,  // Offset: 5db0 ~ 5db7
0xb2fb, 0xb2fc, 0xb2fd, 0xb2fe, 0xb2ff, 0xb300, 0xb301, 0xb302,  // Offset: 5db8 ~ 5dbf
0xb303, 0xb304, 0xb305, 0xb306, 0xb307, 0xb308, 0xb309, 0xb30a,  // Offset: 5dc0 ~ 5dc7
0xb30b, 0xb30c, 0xb30d, 0xb30e, 0xb30f, 0xb310, 0xb311, 0xb312,  // Offset: 5dc8 ~ 5dcf
0xb313, 0xb314, 0xb315, 0xb316, 0xb317, 0xb318, 0xb319, 0xb31a,  // Offset: 5dd0 ~ 5dd7
0xb31b, 0xb31c, 0xb31d, 0xb31e, 0xb31f, 0xb320, 0xb321, 0xb322,  // Offset: 5dd8 ~ 5ddf
0xb323, 0xb324, 0xb325, 0xb326, 0xb327, 0xb328, 0xb329, 0xb32a,  // Offset: 5de0 ~ 5de7
0xb32b, 0xb32c, 0xb32d, 0xb32e, 0xb32f, 0xb330, 0xb331, 0xb332,  // Offset: 5de8 ~ 5def
0xb333, 0xb334, 0xb335, 0xb336, 0xb337, 0xb338, 0xb339, 0xb33a,  // Offset: 5df0 ~ 5df7
0xb33b, 0xb33c, 0xb33d, 0xb33e, 0xb33f, 0xb340, 0xb341, 0xb342,  // Offset: 5df8 ~ 5dff
0xb343, 0xb344, 0xb345, 0xb346, 0xb347, 0xb348, 0xb349, 0xb34a,  // Offset: 5e00 ~ 5e07
0xb34b, 0xb34c, 0xb34d, 0xb34e, 0xb34f, 0xb350, 0xb351, 0xb352,  // Offset: 5e08 ~ 5e0f
0xb353, 0xb354, 0xb355, 0xb356, 0xb357, 0xb358, 0xb359, 0xb35a,  // Offset: 5e10 ~ 5e17
0xb35b, 0xb35c, 0xb35d, 0xb35e, 0xb35f, 0xb360, 0xb361, 0xb362,  // Offset: 5e18 ~ 5e1f
0xb363, 0xb364, 0xb365, 0xb366, 0xb367, 0xb368, 0xb369, 0xb36a,  // Offset: 5e20 ~ 5e27
0xb36b, 0xb36c, 0xb36d, 0xb36e, 0xb36f, 0xb370, 0xb371, 0xb372,  // Offset: 5e28 ~ 5e2f
0xb373, 0xb374, 0xb375, 0xb376, 0xb377, 0xb378, 0xb379, 0xb37a,  // Offset: 5e30 ~ 5e37
0xb37b, 0xb37c, 0xb37d, 0xb37e, 0xb37f, 0xb380, 0xb381, 0xb382,  // Offset: 5e38 ~ 5e3f
0xb383, 0xb384, 0xb385, 0xb386, 0xb387, 0xb388, 0xb389, 0xb38a,  // Offset: 5e40 ~ 5e47
0xb38b, 0xb38c, 0xb38d, 0xb38e, 0xb38f, 0xb390, 0xb391, 0xb392,  // Offset: 5e48 ~ 5e4f
0xb393, 0xb394, 0xb395, 0xb396, 0xb397, 0xb398, 0xb399, 0xb39a,  // Offset: 5e50 ~ 5e57
0xb39b, 0xb39c, 0xb39d, 0xb39e, 0xb39f, 0xb3a0, 0xb3a1, 0xb3a2,  // Offset: 5e58 ~ 5e5f
0xb3a3, 0xb3a4, 0xb3a5, 0xb3a6, 0xb3a7, 0xb3a8, 0xb3a9, 0xb3aa,  // Offset: 5e60 ~ 5e67
0xb3ab, 0xb3ac, 0xb3ad, 0xb3ae, 0xb3af, 0xb3b0, 0xb3b1, 0xb3b2,  // Offset: 5e68 ~ 5e6f
0xb3b3, 0xb3b4, 0xb3b5, 0xb3b6, 0xb3b7, 0xb3b8, 0xb3b9, 0xb3ba,  // Offset: 5e70 ~ 5e77
0xb3bb, 0xb3bc, 0xb3bd, 0xb3be, 0xb3bf, 0xb3c0, 0xb3c1, 0xb3c2,  // Offset: 5e78 ~ 5e7f
0xb3c3, 0xb3c4, 0xb3c5, 0xb3c6, 0xb3c7, 0xb3c8, 0xb3c9, 0xb3ca,  // Offset: 5e80 ~ 5e87
0xb3cb, 0xb3cc, 0xb3cd, 0xb3ce, 0xb3cf, 0xb3d0, 0xb3d1, 0xb3d2,  // Offset: 5e88 ~ 5e8f
0xb3d3, 0xb3d4, 0xb3d5, 0xb3d6, 0xb3d7, 0xb3d8, 0xb3d9, 0xb3da,  // Offset: 5e90 ~ 5e97
0xb3db, 0xb3dc, 0xb3dd, 0xb3de, 0xb3df, 0xb3e0, 0xb3e1, 0xb3e2,  // Offset: 5e98 ~ 5e9f
0xb3e3, 0xb3e4, 0xb3e5, 0xb3e6, 0xb3e7, 0xb3e8, 0xb3e9, 0xb3ea,  // Offset: 5ea0 ~ 5ea7
0xb3eb, 0xb3ec, 0xb3ed, 0xb3ee, 0xb3ef, 0xb3f0, 0xb3f1, 0xb3f2,  // Offset: 5ea8 ~ 5eaf
0xb3f3, 0xb3f4, 0xb3f5, 0xb3f6, 0xb3f7, 0xb3f8, 0xb3f9, 0xb3fa,  // Offset: 5eb0 ~ 5eb7
0xb3fb, 0xb3fc, 0xb3fd, 0xb3fe, 0xb3ff, 0xb400, 0xb401, 0xb402,  // Offset: 5eb8 ~ 5ebf
0xb403, 0xb404, 0xb405, 0xb406, 0xb407, 0xb408, 0xb409, 0xb40a,  // Offset: 5ec0 ~ 5ec7
0xb40b, 0xb40c, 0xb40d, 0xb40e, 0xb40f, 0xb410, 0xb411, 0xb412,  // Offset: 5ec8 ~ 5ecf
0xb413, 0xb414, 0xb415, 0xb416, 0xb417, 0xb418, 0xb419, 0xb41a,  // Offset: 5ed0 ~ 5ed7
0xb41b, 0xb41c, 0xb41d, 0xb41e, 0xb41f, 0xb420, 0xb421, 0xb422,  // Offset: 5ed8 ~ 5edf
0xb423, 0xb424, 0xb425, 0xb426, 0xb427, 0xb428, 0xb429, 0xb42a,  // Offset: 5ee0 ~ 5ee7
0xb42b, 0xb42c, 0xb42d, 0xb42e, 0xb42f, 0xb430, 0xb431, 0xb432,  // Offset: 5ee8 ~ 5eef
0xb433, 0xb434, 0xb435, 0xb436, 0xb437, 0xb438, 0xb439, 0xb43a,  // Offset: 5ef0 ~ 5ef7
0xb43b, 0xb43c, 0xb43d, 0xb43e, 0xb43f, 0xb440, 0xb441, 0xb442,  // Offset: 5ef8 ~ 5eff
0xb443, 0xb444, 0xb445, 0xb446, 0xb447, 0xb448, 0xb449, 0xb44a,  // Offset: 5f00 ~ 5f07
0xb44b, 0xb44c, 0xb44d, 0xb44e, 0xb44f, 0xb450, 0xb451, 0xb452,  // Offset: 5f08 ~ 5f0f
0xb453, 0xb454, 0xb455, 0xb456, 0xb457, 0xb458, 0xb459, 0xb45a,  // Offset: 5f10 ~ 5f17
0xb45b, 0xb45c, 0xb45d, 0xb45e, 0xb45f, 0xb460, 0xb461, 0xb462,  // Offset: 5f18 ~ 5f1f
0xb463, 0xb464, 0xb465, 0xb466, 0xb467, 0xb468, 0xb469, 0xb46a,  // Offset: 5f20 ~ 5f27
0xb46b, 0xb46c, 0xb46d, 0xb46e, 0xb46f, 0xb470, 0xb471, 0xb472,  // Offset: 5f28 ~ 5f2f
0xb473, 0xb474, 0xb475, 0xb476, 0xb477, 0xb478, 0xb479, 0xb47a,  // Offset: 5f30 ~ 5f37
0xb47b, 0xb47c, 0xb47d, 0xb47e, 0xb47f, 0xb480, 0xb481, 0xb482,  // Offset: 5f38 ~ 5f3f
0xb483, 0xb484, 0xb485, 0xb486, 0xb487, 0xb488, 0xb489, 0xb48a,  // Offset: 5f40 ~ 5f47
0xb48b, 0xb48c, 0xb48d, 0xb48e, 0xb48f, 0xb490, 0xb491, 0xb492,  // Offset: 5f48 ~ 5f4f
0xb493, 0xb494, 0xb495, 0xb496, 0xb497, 0xb498, 0xb499, 0xb49a,  // Offset: 5f50 ~ 5f57
0xb49b, 0xb49c, 0xb49d, 0xb49e, 0xb49f, 0xb4a0, 0xb4a1, 0xb4a2,  // Offset: 5f58 ~ 5f5f
0xb4a3, 0xb4a4, 0xb4a5, 0xb4a6, 0xb4a7, 0xb4a8, 0xb4a9, 0xb4aa,  // Offset: 5f60 ~ 5f67
0xb4ab, 0xb4ac, 0xb4ad, 0xb4ae, 0xb4af, 0xb4b0, 0xb4b1, 0xb4b2,  // Offset: 5f68 ~ 5f6f
0xb4b3, 0xb4b4, 0xb4b5, 0xb4b6, 0xb4b7, 0xb4b8, 0xb4b9, 0xb4ba,  // Offset: 5f70 ~ 5f77
0xb4bb, 0xb4bc, 0xb4bd, 0xb4be, 0xb4bf, 0xb4c0, 0xb4c1, 0xb4c2,  // Offset: 5f78 ~ 5f7f
0xb4c3, 0xb4c4, 0xb4c5, 0xb4c6, 0xb4c7, 0xb4c8, 0xb4c9, 0xb4ca,  // Offset: 5f80 ~ 5f87
0xb4cb, 0xb4cc, 0xb4cd, 0xb4ce, 0xb4cf, 0xb4d0, 0xb4d1, 0xb4d2,  // Offset: 5f88 ~ 5f8f
0xb4d3, 0xb4d4, 0xb4d5, 0xb4d6, 0xb4d7, 0xb4d8, 0xb4d9, 0xb4da,  // Offset: 5f90 ~ 5f97
0xb4db, 0xb4dc, 0xb4dd, 0xb4de, 0xb4df, 0xb4e0, 0xb4e1, 0xb4e2,  // Offset: 5f98 ~ 5f9f
0xb4e3, 0xb4e4, 0xb4e5, 0xb4e6, 0xb4e7, 0xb4e8, 0xb4e9, 0xb4ea,  // Offset: 5fa0 ~ 5fa7
0xb4eb, 0xb4ec, 0xb4ed, 0xb4ee, 0xb4ef, 0xb4f0, 0xb4f1, 0xb4f2,  // Offset: 5fa8 ~ 5faf
0xb4f3, 0xb4f4, 0xb4f5, 0xb4f6, 0xb4f7, 0xb4f8, 0xb4f9, 0xb4fa,  // Offset: 5fb0 ~ 5fb7
0xb4fb, 0xb4fc, 0xb4fd, 0xb4fe, 0xb4ff, 0xb500, 0xb501, 0xb502,  // Offset: 5fb8 ~ 5fbf
0xb503, 0xb504, 0xb505, 0xb506, 0xb507, 0xb508, 0xb509, 0xb50a,  // Offset: 5fc0 ~ 5fc7
0xb50b, 0xb50c, 0xb50d, 0xb50e, 0xb50f, 0xb510, 0xb511, 0xb512,  // Offset: 5fc8 ~ 5fcf
0xb513, 0xb514, 0xb515, 0xb516, 0xb517, 0xb518, 0xb519, 0xb51a,  // Offset: 5fd0 ~ 5fd7
0xb51b, 0xb51c, 0xb51d, 0xb51e, 0xb51f, 0xb520, 0xb521, 0xb522,  // Offset: 5fd8 ~ 5fdf
0xb523, 0xb524, 0xb525, 0xb526, 0xb527, 0xb528, 0xb529, 0xb52a,  // Offset: 5fe0 ~ 5fe7
0xb52b, 0xb52c, 0xb52d, 0xb52e, 0xb52f, 0xb530, 0xb531, 0xb532,  // Offset: 5fe8 ~ 5fef
0xb533, 0xb534, 0xb535, 0xb536, 0xb537, 0xb538, 0xb539, 0xb53a,  // Offset: 5ff0 ~ 5ff7
0xb53b, 0xb53c, 0xb53d, 0xb53e, 0xb53f, 0xb540, 0xb541, 0xb542,  // Offset: 5ff8 ~ 5fff
0xb543, 0xb544, 0xb545, 0xb546, 0xb547, 0xb548, 0xb549, 0xb54a,  // Offset: 6000 ~ 6007
0xb54b, 0xb54c, 0xb54d, 0xb54e, 0xb54f, 0xb550, 0xb551, 0xb552,  // Offset: 6008 ~ 600f
0xb553, 0xb554, 0xb555, 0xb556, 0xb557, 0xb558, 0xb559, 0xb55a,  // Offset: 6010 ~ 6017
0xb55b, 0xb55c, 0xb55d, 0xb55e, 0xb55f, 0xb560, 0xb561, 0xb562,  // Offset: 6018 ~ 601f
0xb563, 0xb564, 0xb565, 0xb566, 0xb567, 0xb568, 0xb569, 0xb56a,  // Offset: 6020 ~ 6027
0xb56b, 0xb56c, 0xb56d, 0xb56e, 0xb56f, 0xb570, 0xb571, 0xb572,  // Offset: 6028 ~ 602f
0xb573, 0xb574, 0xb575, 0xb576, 0xb577, 0xb578, 0xb579, 0xb57a,  // Offset: 6030 ~ 6037
0xb57b, 0xb57c, 0xb57d, 0xb57e, 0xb57f, 0xb580, 0xb581, 0xb582,  // Offset: 6038 ~ 603f
0xb583, 0xb584, 0xb585, 0xb586, 0xb587, 0xb588, 0xb589, 0xb58a,  // Offset: 6040 ~ 6047
0xb58b, 0xb58c, 0xb58d, 0xb58e, 0xb58f, 0xb590, 0xb591, 0xb592,  // Offset: 6048 ~ 604f
0xb593, 0xb594, 0xb595, 0xb596, 0xb597, 0xb598, 0xb599, 0xb59a,  // Offset: 6050 ~ 6057
0xb59b, 0xb59c, 0xb59d, 0xb59e, 0xb59f, 0xb5a0, 0xb5a1, 0xb5a2,  // Offset: 6058 ~ 605f
0xb5a3, 0xb5a4, 0xb5a5, 0xb5a6, 0xb5a7, 0xb5a8, 0xb5a9, 0xb5aa,  // Offset: 6060 ~ 6067
0xb5ab, 0xb5ac, 0xb5ad, 0xb5ae, 0xb5af, 0xb5b0, 0xb5b1, 0xb5b2,  // Offset: 6068 ~ 606f
0xb5b3, 0xb5b4, 0xb5b5, 0xb5b6, 0xb5b7, 0xb5b8, 0xb5b9, 0xb5ba,  // Offset: 6070 ~ 6077
0xb5bb, 0xb5bc, 0xb5bd, 0xb5be, 0xb5bf, 0xb5c0, 0xb5c1, 0xb5c2,  // Offset: 6078 ~ 607f
0xb5c3, 0xb5c4, 0xb5c5, 0xb5c6, 0xb5c7, 0xb5c8, 0xb5c9, 0xb5ca,  // Offset: 6080 ~ 6087
0xb5cb, 0xb5cc, 0xb5cd, 0xb5ce, 0xb5cf, 0xb5d0, 0xb5d1, 0xb5d2,  // Offset: 6088 ~ 608f
0xb5d3, 0xb5d4, 0xb5d5, 0xb5d6, 0xb5d7, 0xb5d8, 0xb5d9, 0xb5da,  // Offset: 6090 ~ 6097
0xb5db, 0xb5dc, 0xb5dd, 0xb5de, 0xb5df, 0xb5e0, 0xb5e1, 0xb5e2,  // Offset: 6098 ~ 609f
0xb5e3, 0xb5e4, 0xb5e5, 0xb5e6, 0xb5e7, 0xb5e8, 0xb5e9, 0xb5ea,  // Offset: 60a0 ~ 60a7
0xb5eb, 0xb5ec, 0xb5ed, 0xb5ee, 0xb5ef, 0xb5f0, 0xb5f1, 0xb5f2,  // Offset: 60a8 ~ 60af
0xb5f3, 0xb5f4, 0xb5f5, 0xb5f6, 0xb5f7, 0xb5f8, 0xb5f9, 0xb5fa,  // Offset: 60b0 ~ 60b7
0xb5fb, 0xb5fc, 0xb5fd, 0xb5fe, 0xb5ff, 0xb600, 0xb601, 0xb602,  // Offset: 60b8 ~ 60bf
0xb603, 0xb604, 0xb605, 0xb606, 0xb607, 0xb608, 0xb609, 0xb60a,  // Offset: 60c0 ~ 60c7
0xb60b, 0xb60c, 0xb60d, 0xb60e, 0xb60f, 0xb610, 0xb611, 0xb612,  // Offset: 60c8 ~ 60cf
0xb613, 0xb614, 0xb615, 0xb616, 0xb617, 0xb618, 0xb619, 0xb61a,  // Offset: 60d0 ~ 60d7
0xb61b, 0xb61c, 0xb61d, 0xb61e, 0xb61f, 0xb620, 0xb621, 0xb622,  // Offset: 60d8 ~ 60df
0xb623, 0xb624, 0xb625, 0xb626, 0xb627, 0xb628, 0xb629, 0xb62a,  // Offset: 60e0 ~ 60e7
0xb62b, 0xb62c, 0xb62d, 0xb62e, 0xb62f, 0xb630, 0xb631, 0xb632,  // Offset: 60e8 ~ 60ef
0xb633, 0xb634, 0xb635, 0xb636, 0xb637, 0xb638, 0xb639, 0xb63a,  // Offset: 60f0 ~ 60f7
0xb63b, 0xb63c, 0xb63d, 0xb63e, 0xb63f, 0xb640, 0xb641, 0xb642,  // Offset: 60f8 ~ 60ff
0xb643, 0xb644, 0xb645, 0xb646, 0xb647, 0xb648, 0xb649, 0xb64a,  // Offset: 6100 ~ 6107
0xb64b, 0xb64c, 0xb64d, 0xb64e, 0xb64f, 0xb650, 0xb651, 0xb652,  // Offset: 6108 ~ 610f
0xb653, 0xb654, 0xb655, 0xb656, 0xb657, 0xb658, 0xb659, 0xb65a,  // Offset: 6110 ~ 6117
0xb65b, 0xb65c, 0xb65d, 0xb65e, 0xb65f, 0xb660, 0xb661, 0xb662,  // Offset: 6118 ~ 611f
0xb663, 0xb664, 0xb665, 0xb666, 0xb667, 0xb668, 0xb669, 0xb66a,  // Offset: 6120 ~ 6127
0xb66b, 0xb66c, 0xb66d, 0xb66e, 0xb66f, 0xb670, 0xb671, 0xb672,  // Offset: 6128 ~ 612f
0xb673, 0xb674, 0xb675, 0xb676, 0xb677, 0xb678, 0xb679, 0xb67a,  // Offset: 6130 ~ 6137
0xb67b, 0xb67c, 0xb67d, 0xb67e, 0xb67f, 0xb680, 0xb681, 0xb682,  // Offset: 6138 ~ 613f
0xb683, 0xb684, 0xb685, 0xb686, 0xb687, 0xb688, 0xb689, 0xb68a,  // Offset: 6140 ~ 6147
0xb68b, 0xb68c, 0xb68d, 0xb68e, 0xb68f, 0xb690, 0xb691, 0xb692,  // Offset: 6148 ~ 614f
0xb693, 0xb694, 0xb695, 0xb696, 0xb697, 0xb698, 0xb699, 0xb69a,  // Offset: 6150 ~ 6157
0xb69b, 0xb69c, 0xb69d, 0xb69e, 0xb69f, 0xb6a0, 0xb6a1, 0xb6a2,  // Offset: 6158 ~ 615f
0xb6a3, 0xb6a4, 0xb6a5, 0xb6a6, 0xb6a7, 0xb6a8, 0xb6a9, 0xb6aa,  // Offset: 6160 ~ 6167
0xb6ab, 0xb6ac, 0xb6ad, 0xb6ae, 0xb6af, 0xb6b0, 0xb6b1, 0xb6b2,  // Offset: 6168 ~ 616f
0xb6b3, 0xb6b4, 0xb6b5, 0xb6b6, 0xb6b7, 0xb6b8, 0xb6b9, 0xb6ba,  // Offset: 6170 ~ 6177
0xb6bb, 0xb6bc, 0xb6bd, 0xb6be, 0xb6bf, 0xb6c0, 0xb6c1, 0xb6c2,  // Offset: 6178 ~ 617f
0xb6c3, 0xb6c4, 0xb6c5, 0xb6c6, 0xb6c7, 0xb6c8, 0xb6c9, 0xb6ca,  // Offset: 6180 ~ 6187
0xb6cb, 0xb6cc, 0xb6cd, 0xb6ce, 0xb6cf, 0xb6d0, 0xb6d1, 0xb6d2,  // Offset: 6188 ~ 618f
0xb6d3, 0xb6d4, 0xb6d5, 0xb6d6, 0xb6d7, 0xb6d8, 0xb6d9, 0xb6da,  // Offset: 6190 ~ 6197
0xb6db, 0xb6dc, 0xb6dd, 0xb6de, 0xb6df, 0xb6e0, 0xb6e1, 0xb6e2,  // Offset: 6198 ~ 619f
0xb6e3, 0xb6e4, 0xb6e5, 0xb6e6, 0xb6e7, 0xb6e8, 0xb6e9, 0xb6ea,  // Offset: 61a0 ~ 61a7
0xb6eb, 0xb6ec, 0xb6ed, 0xb6ee, 0xb6ef, 0xb6f0, 0xb6f1, 0xb6f2,  // Offset: 61a8 ~ 61af
0xb6f3, 0xb6f4, 0xb6f5, 0xb6f6, 0xb6f7, 0xb6f8, 0xb6f9, 0xb6fa,  // Offset: 61b0 ~ 61b7
0xb6fb, 0xb6fc, 0xb6fd, 0xb6fe, 0xb6ff, 0xb700, 0xb701, 0xb702,  // Offset: 61b8 ~ 61bf
0xb703, 0xb704, 0xb705, 0xb706, 0xb707, 0xb708, 0xb709, 0xb70a,  // Offset: 61c0 ~ 61c7
0xb70b, 0xb70c, 0xb70d, 0xb70e, 0xb70f, 0xb710, 0xb711, 0xb712,  // Offset: 61c8 ~ 61cf
0xb713, 0xb714, 0xb715, 0xb716, 0xb717, 0xb718, 0xb719, 0xb71a,  // Offset: 61d0 ~ 61d7
0xb71b, 0xb71c, 0xb71d, 0xb71e, 0xb71f, 0xb720, 0xb721, 0xb722,  // Offset: 61d8 ~ 61df
0xb723, 0xb724, 0xb725, 0xb726, 0xb727, 0xb728, 0xb729, 0xb72a,  // Offset: 61e0 ~ 61e7
0xb72b, 0xb72c, 0xb72d, 0xb72e, 0xb72f, 0xb730, 0xb731, 0xb732,  // Offset: 61e8 ~ 61ef
0xb733, 0xb734, 0xb735, 0xb736, 0xb737, 0xb738, 0xb739, 0xb73a,  // Offset: 61f0 ~ 61f7
0xb73b, 0xb73c, 0xb73d, 0xb73e, 0xb73f, 0xb740, 0xb741, 0xb742,  // Offset: 61f8 ~ 61ff
0xb743, 0xb744, 0xb745, 0xb746, 0xb747, 0xb748, 0xb749, 0xb74a,  // Offset: 6200 ~ 6207
0xb74b, 0xb74c, 0xb74d, 0xb74e, 0xb74f, 0xb750, 0xb751, 0xb752,  // Offset: 6208 ~ 620f
0xb753, 0xb754, 0xb755, 0xb756, 0xb757, 0xb758, 0xb759, 0xb75a,  // Offset: 6210 ~ 6217
0xb75b, 0xb75c, 0xb75d, 0xb75e, 0xb75f, 0xb760, 0xb761, 0xb762,  // Offset: 6218 ~ 621f
0xb763, 0xb764, 0xb765, 0xb766, 0xb767, 0xb768, 0xb769, 0xb76a,  // Offset: 6220 ~ 6227
0xb76b, 0xb76c, 0xb76d, 0xb76e, 0xb76f, 0xb770, 0xb771, 0xb772,  // Offset: 6228 ~ 622f
0xb773, 0xb774, 0xb775, 0xb776, 0xb777, 0xb778, 0xb779, 0xb77a,  // Offset: 6230 ~ 6237
0xb77b, 0xb77c, 0xb77d, 0xb77e, 0xb77f, 0xb780, 0xb781, 0xb782,  // Offset: 6238 ~ 623f
0xb783, 0xb784, 0xb785, 0xb786, 0xb787, 0xb788, 0xb789, 0xb78a,  // Offset: 6240 ~ 6247
0xb78b, 0xb78c, 0xb78d, 0xb78e, 0xb78f, 0xb790, 0xb791, 0xb792,  // Offset: 6248 ~ 624f
0xb793, 0xb794, 0xb795, 0xb796, 0xb797, 0xb798, 0xb799, 0xb79a,  // Offset: 6250 ~ 6257
0xb79b, 0xb79c, 0xb79d, 0xb79e, 0xb79f, 0xb7a0, 0xb7a1, 0xb7a2,  // Offset: 6258 ~ 625f
0xb7a3, 0xb7a4, 0xb7a5, 0xb7a6, 0xb7a7, 0xb7a8, 0xb7a9, 0xb7aa,  // Offset: 6260 ~ 6267
0xb7ab, 0xb7ac, 0xb7ad, 0xb7ae, 0xb7af, 0xb7b0, 0xb7b1, 0xb7b2,  // Offset: 6268 ~ 626f
0xb7b3, 0xb7b4, 0xb7b5, 0xb7b6, 0xb7b7, 0xb7b8, 0xb7b9, 0xb7ba,  // Offset: 6270 ~ 6277
0xb7bb, 0xb7bc, 0xb7bd, 0xb7be, 0xb7bf, 0xb7c0, 0xb7c1, 0xb7c2,  // Offset: 6278 ~ 627f
0xb7c3, 0xb7c4, 0xb7c5, 0xb7c6, 0xb7c7, 0xb7c8, 0xb7c9, 0xb7ca,  // Offset: 6280 ~ 6287
0xb7cb, 0xb7cc, 0xb7cd, 0xb7ce, 0xb7cf, 0xb7d0, 0xb7d1, 0xb7d2,  // Offset: 6288 ~ 628f
0xb7d3, 0xb7d4, 0xb7d5, 0xb7d6, 0xb7d7, 0xb7d8, 0xb7d9, 0xb7da,  // Offset: 6290 ~ 6297
0xb7db, 0xb7dc, 0xb7dd, 0xb7de, 0xb7df, 0xb7e0, 0xb7e1, 0xb7e2,  // Offset: 6298 ~ 629f
0xb7e3, 0xb7e4, 0xb7e5, 0xb7e6, 0xb7e7, 0xb7e8, 0xb7e9, 0xb7ea,  // Offset: 62a0 ~ 62a7
0xb7eb, 0xb7ec, 0xb7ed, 0xb7ee, 0xb7ef, 0xb7f0, 0xb7f1, 0xb7f2,  // Offset: 62a8 ~ 62af
0xb7f3, 0xb7f4, 0xb7f5, 0xb7f6, 0xb7f7, 0xb7f8, 0xb7f9, 0xb7fa,  // Offset: 62b0 ~ 62b7
0xb7fb, 0xb7fc, 0xb7fd, 0xb7fe, 0xb7ff, 0xb800, 0xb801, 0xb802,  // Offset: 62b8 ~ 62bf
0xb803, 0xb804, 0xb805, 0xb806, 0xb807, 0xb808, 0xb809, 0xb80a,  // Offset: 62c0 ~ 62c7
0xb80b, 0xb80c, 0xb80d, 0xb80e, 0xb80f, 0xb810, 0xb811, 0xb812,  // Offset: 62c8 ~ 62cf
0xb813, 0xb814, 0xb815, 0xb816, 0xb817, 0xb818, 0xb819, 0xb81a,  // Offset: 62d0 ~ 62d7
0xb81b, 0xb81c, 0xb81d, 0xb81e, 0xb81f, 0xb820, 0xb821, 0xb822,  // Offset: 62d8 ~ 62df
0xb823, 0xb824, 0xb825, 0xb826, 0xb827, 0xb828, 0xb829, 0xb82a,  // Offset: 62e0 ~ 62e7
0xb82b, 0xb82c, 0xb82d, 0xb82e, 0xb82f, 0xb830, 0xb831, 0xb832,  // Offset: 62e8 ~ 62ef
0xb833, 0xb834, 0xb835, 0xb836, 0xb837, 0xb838, 0xb839, 0xb83a,  // Offset: 62f0 ~ 62f7
0xb83b, 0xb83c, 0xb83d, 0xb83e, 0xb83f, 0xb840, 0xb841, 0xb842,  // Offset: 62f8 ~ 62ff
0xb843, 0xb844, 0xb845, 0xb846, 0xb847, 0xb848, 0xb849, 0xb84a,  // Offset: 6300 ~ 6307
0xb84b, 0xb84c, 0xb84d, 0xb84e, 0xb84f, 0xb850, 0xb851, 0xb852,  // Offset: 6308 ~ 630f
0xb853, 0xb854, 0xb855, 0xb856, 0xb857, 0xb858, 0xb859, 0xb85a,  // Offset: 6310 ~ 6317
0xb85b, 0xb85c, 0xb85d, 0xb85e, 0xb85f, 0xb860, 0xb861, 0xb862,  // Offset: 6318 ~ 631f
0xb863, 0xb864, 0xb865, 0xb866, 0xb867, 0xb868, 0xb869, 0xb86a,  // Offset: 6320 ~ 6327
0xb86b, 0xb86c, 0xb86d, 0xb86e, 0xb86f, 0xb870, 0xb871, 0xb872,  // Offset: 6328 ~ 632f
0xb873, 0xb874, 0xb875, 0xb876, 0xb877, 0xb878, 0xb879, 0xb87a,  // Offset: 6330 ~ 6337
0xb87b, 0xb87c, 0xb87d, 0xb87e, 0xb87f, 0xb880, 0xb881, 0xb882,  // Offset: 6338 ~ 633f
0xb883, 0xb884, 0xb885, 0xb886, 0xb887, 0xb888, 0xb889, 0xb88a,  // Offset: 6340 ~ 6347
0xb88b, 0xb88c, 0xb88d, 0xb88e, 0xb88f, 0xb890, 0xb891, 0xb892,  // Offset: 6348 ~ 634f
0xb893, 0xb894, 0xb895, 0xb896, 0xb897, 0xb898, 0xb899, 0xb89a,  // Offset: 6350 ~ 6357
0xb89b, 0xb89c, 0xb89d, 0xb89e, 0xb89f, 0xb8a0, 0xb8a1, 0xb8a2,  // Offset: 6358 ~ 635f
0xb8a3, 0xb8a4, 0xb8a5, 0xb8a6, 0xb8a7, 0xb8a8, 0xb8a9, 0xb8aa,  // Offset: 6360 ~ 6367
0xb8ab, 0xb8ac, 0xb8ad, 0xb8ae, 0xb8af, 0xb8b0, 0xb8b1, 0xb8b2,  // Offset: 6368 ~ 636f
0xb8b3, 0xb8b4, 0xb8b5, 0xb8b6, 0xb8b7, 0xb8b8, 0xb8b9, 0xb8ba,  // Offset: 6370 ~ 6377
0xb8bb, 0xb8bc, 0xb8bd, 0xb8be, 0xb8bf, 0xb8c0, 0xb8c1, 0xb8c2,  // Offset: 6378 ~ 637f
0xb8c3, 0xb8c4, 0xb8c5, 0xb8c6, 0xb8c7, 0xb8c8, 0xb8c9, 0xb8ca,  // Offset: 6380 ~ 6387
0xb8cb, 0xb8cc, 0xb8cd, 0xb8ce, 0xb8cf, 0xb8d0, 0xb8d1, 0xb8d2,  // Offset: 6388 ~ 638f
0xb8d3, 0xb8d4, 0xb8d5, 0xb8d6, 0xb8d7, 0xb8d8, 0xb8d9, 0xb8da,  // Offset: 6390 ~ 6397
0xb8db, 0xb8dc, 0xb8dd, 0xb8de, 0xb8df, 0xb8e0, 0xb8e1, 0xb8e2,  // Offset: 6398 ~ 639f
0xb8e3, 0xb8e4, 0xb8e5, 0xb8e6, 0xb8e7, 0xb8e8, 0xb8e9, 0xb8ea,  // Offset: 63a0 ~ 63a7
0xb8eb, 0xb8ec, 0xb8ed, 0xb8ee, 0xb8ef, 0xb8f0, 0xb8f1, 0xb8f2,  // Offset: 63a8 ~ 63af
0xb8f3, 0xb8f4, 0xb8f5, 0xb8f6, 0xb8f7, 0xb8f8, 0xb8f9, 0xb8fa,  // Offset: 63b0 ~ 63b7
0xb8fb, 0xb8fc, 0xb8fd, 0xb8fe, 0xb8ff, 0xb900, 0xb901, 0xb902,  // Offset: 63b8 ~ 63bf
0xb903, 0xb904, 0xb905, 0xb906, 0xb907, 0xb908, 0xb909, 0xb90a,  // Offset: 63c0 ~ 63c7
0xb90b, 0xb90c, 0xb90d, 0xb90e, 0xb90f, 0xb910, 0xb911, 0xb912,  // Offset: 63c8 ~ 63cf
0xb913, 0xb914, 0xb915, 0xb916, 0xb917, 0xb918, 0xb919, 0xb91a,  // Offset: 63d0 ~ 63d7
0xb91b, 0xb91c, 0xb91d, 0xb91e, 0xb91f, 0xb920, 0xb921, 0xb922,  // Offset: 63d8 ~ 63df
0xb923, 0xb924, 0xb925, 0xb926, 0xb927, 0xb928, 0xb929, 0xb92a,  // Offset: 63e0 ~ 63e7
0xb92b, 0xb92c, 0xb92d, 0xb92e, 0xb92f, 0xb930, 0xb931, 0xb932,  // Offset: 63e8 ~ 63ef
0xb933, 0xb934, 0xb935, 0xb936, 0xb937, 0xb938, 0xb939, 0xb93a,  // Offset: 63f0 ~ 63f7
0xb93b, 0xb93c, 0xb93d, 0xb93e, 0xb93f, 0xb940, 0xb941, 0xb942,  // Offset: 63f8 ~ 63ff
0xb943, 0xb944, 0xb945, 0xb946, 0xb947, 0xb948, 0xb949, 0xb94a,  // Offset: 6400 ~ 6407
0xb94b, 0xb94c, 0xb94d, 0xb94e, 0xb94f, 0xb950, 0xb951, 0xb952,  // Offset: 6408 ~ 640f
0xb953, 0xb954, 0xb955, 0xb956, 0xb957, 0xb958, 0xb959, 0xb95a,  // Offset: 6410 ~ 6417
0xb95b, 0xb95c, 0xb95d, 0xb95e, 0xb95f, 0xb960, 0xb961, 0xb962,  // Offset: 6418 ~ 641f
0xb963, 0xb964, 0xb965, 0xb966, 0xb967, 0xb968, 0xb969, 0xb96a,  // Offset: 6420 ~ 6427
0xb96b, 0xb96c, 0xb96d, 0xb96e, 0xb96f, 0xb970, 0xb971, 0xb972,  // Offset: 6428 ~ 642f
0xb973, 0xb974, 0xb975, 0xb976, 0xb977, 0xb978, 0xb979, 0xb97a,  // Offset: 6430 ~ 6437
0xb97b, 0xb97c, 0xb97d, 0xb97e, 0xb97f, 0xb980, 0xb981, 0xb982,  // Offset: 6438 ~ 643f
0xb983, 0xb984, 0xb985, 0xb986, 0xb987, 0xb988, 0xb989, 0xb98a,  // Offset: 6440 ~ 6447
0xb98b, 0xb98c, 0xb98d, 0xb98e, 0xb98f, 0xb990, 0xb991, 0xb992,  // Offset: 6448 ~ 644f
0xb993, 0xb994, 0xb995, 0xb996, 0xb997, 0xb998, 0xb999, 0xb99a,  // Offset: 6450 ~ 6457
0xb99b, 0xb99c, 0xb99d, 0xb99e, 0xb99f, 0xb9a0, 0xb9a1, 0xb9a2,  // Offset: 6458 ~ 645f
0xb9a3, 0xb9a4, 0xb9a5, 0xb9a6, 0xb9a7, 0xb9a8, 0xb9a9, 0xb9aa,  // Offset: 6460 ~ 6467
0xb9ab, 0xb9ac, 0xb9ad, 0xb9ae, 0xb9af, 0xb9b0, 0xb9b1, 0xb9b2,  // Offset: 6468 ~ 646f
0xb9b3, 0xb9b4, 0xb9b5, 0xb9b6, 0xb9b7, 0xb9b8, 0xb9b9, 0xb9ba,  // Offset: 6470 ~ 6477
0xb9bb, 0xb9bc, 0xb9bd, 0xb9be, 0xb9bf, 0xb9c0, 0xb9c1, 0xb9c2,  // Offset: 6478 ~ 647f
0xb9c3, 0xb9c4, 0xb9c5, 0xb9c6, 0xb9c7, 0xb9c8, 0xb9c9, 0xb9ca,  // Offset: 6480 ~ 6487
0xb9cb, 0xb9cc, 0xb9cd, 0xb9ce, 0xb9cf, 0xb9d0, 0xb9d1, 0xb9d2,  // Offset: 6488 ~ 648f
0xb9d3, 0xb9d4, 0xb9d5, 0xb9d6, 0xb9d7, 0xb9d8, 0xb9d9, 0xb9da,  // Offset: 6490 ~ 6497
0xb9db, 0xb9dc, 0xb9dd, 0xb9de, 0xb9df, 0xb9e0, 0xb9e1, 0xb9e2,  // Offset: 6498 ~ 649f
0xb9e3, 0xb9e4, 0xb9e5, 0xb9e6, 0xb9e7, 0xb9e8, 0xb9e9, 0xb9ea,  // Offset: 64a0 ~ 64a7
0xb9eb, 0xb9ec, 0xb9ed, 0xb9ee, 0xb9ef, 0xb9f0, 0xb9f1, 0xb9f2,  // Offset: 64a8 ~ 64af
0xb9f3, 0xb9f4, 0xb9f5, 0xb9f6, 0xb9f7, 0xb9f8, 0xb9f9, 0xb9fa,  // Offset: 64b0 ~ 64b7
0xb9fb, 0xb9fc, 0xb9fd, 0xb9fe, 0xb9ff, 0xba00, 0xba01, 0xba02,  // Offset: 64b8 ~ 64bf
0xba03, 0xba04, 0xba05, 0xba06, 0xba07, 0xba08, 0xba09, 0xba0a,  // Offset: 64c0 ~ 64c7
0xba0b, 0xba0c, 0xba0d, 0xba0e, 0xba0f, 0xba10, 0xba11, 0xba12,  // Offset: 64c8 ~ 64cf
0xba13, 0xba14, 0xba15, 0xba16, 0xba17, 0xba18, 0xba19, 0xba1a,  // Offset: 64d0 ~ 64d7
0xba1b, 0xba1c, 0xba1d, 0xba1e, 0xba1f, 0xba20, 0xba21, 0xba22,  // Offset: 64d8 ~ 64df
0xba23, 0xba24, 0xba25, 0xba26, 0xba27, 0xba28, 0xba29, 0xba2a,  // Offset: 64e0 ~ 64e7
0xba2b, 0xba2c, 0xba2d, 0xba2e, 0xba2f, 0xba30, 0xba31, 0xba32,  // Offset: 64e8 ~ 64ef
0xba33, 0xba34, 0xba35, 0xba36, 0xba37, 0xba38, 0xba39, 0xba3a,  // Offset: 64f0 ~ 64f7
0xba3b, 0xba3c, 0xba3d, 0xba3e, 0xba3f, 0xba40, 0xba41, 0xba42,  // Offset: 64f8 ~ 64ff
0xba43, 0xba44, 0xba45, 0xba46, 0xba47, 0xba48, 0xba49, 0xba4a,  // Offset: 6500 ~ 6507
0xba4b, 0xba4c, 0xba4d, 0xba4e, 0xba4f, 0xba50, 0xba51, 0xba52,  // Offset: 6508 ~ 650f
0xba53, 0xba54, 0xba55, 0xba56, 0xba57, 0xba58, 0xba59, 0xba5a,  // Offset: 6510 ~ 6517
0xba5b, 0xba5c, 0xba5d, 0xba5e, 0xba5f, 0xba60, 0xba61, 0xba62,  // Offset: 6518 ~ 651f
0xba63, 0xba64, 0xba65, 0xba66, 0xba67, 0xba68, 0xba69, 0xba6a,  // Offset: 6520 ~ 6527
0xba6b, 0xba6c, 0xba6d, 0xba6e, 0xba6f, 0xba70, 0xba71, 0xba72,  // Offset: 6528 ~ 652f
0xba73, 0xba74, 0xba75, 0xba76, 0xba77, 0xba78, 0xba79, 0xba7a,  // Offset: 6530 ~ 6537
0xba7b, 0xba7c, 0xba7d, 0xba7e, 0xba7f, 0xba80, 0xba81, 0xba82,  // Offset: 6538 ~ 653f
0xba83, 0xba84, 0xba85, 0xba86, 0xba87, 0xba88, 0xba89, 0xba8a,  // Offset: 6540 ~ 6547
0xba8b, 0xba8c, 0xba8d, 0xba8e, 0xba8f, 0xba90, 0xba91, 0xba92,  // Offset: 6548 ~ 654f
0xba93, 0xba94, 0xba95, 0xba96, 0xba97, 0xba98, 0xba99, 0xba9a,  // Offset: 6550 ~ 6557
0xba9b, 0xba9c, 0xba9d, 0xba9e, 0xba9f, 0xbaa0, 0xbaa1, 0xbaa2,  // Offset: 6558 ~ 655f
0xbaa3, 0xbaa4, 0xbaa5, 0xbaa6, 0xbaa7, 0xbaa8, 0xbaa9, 0xbaaa,  // Offset: 6560 ~ 6567
0xbaab, 0xbaac, 0xbaad, 0xbaae, 0xbaaf, 0xbab0, 0xbab1, 0xbab2,  // Offset: 6568 ~ 656f
0xbab3, 0xbab4, 0xbab5, 0xbab6, 0xbab7, 0xbab8, 0xbab9, 0xbaba,  // Offset: 6570 ~ 6577
0xbabb, 0xbabc, 0xbabd, 0xbabe, 0xbabf, 0xbac0, 0xbac1, 0xbac2,  // Offset: 6578 ~ 657f
0xbac3, 0xbac4, 0xbac5, 0xbac6, 0xbac7, 0xbac8, 0xbac9, 0xbaca,  // Offset: 6580 ~ 6587
0xbacb, 0xbacc, 0xbacd, 0xbace, 0xbacf, 0xbad0, 0xbad1, 0xbad2,  // Offset: 6588 ~ 658f
0xbad3, 0xbad4, 0xbad5, 0xbad6, 0xbad7, 0xbad8, 0xbad9, 0xbada,  // Offset: 6590 ~ 6597
0xbadb, 0xbadc, 0xbadd, 0xbade, 0xbadf, 0xbae0, 0xbae1, 0xbae2,  // Offset: 6598 ~ 659f
0xbae3, 0xbae4, 0xbae5, 0xbae6, 0xbae7, 0xbae8, 0xbae9, 0xbaea,  // Offset: 65a0 ~ 65a7
0xbaeb, 0xbaec, 0xbaed, 0xbaee, 0xbaef, 0xbaf0, 0xbaf1, 0xbaf2,  // Offset: 65a8 ~ 65af
0xbaf3, 0xbaf4, 0xbaf5, 0xbaf6, 0xbaf7, 0xbaf8, 0xbaf9, 0xbafa,  // Offset: 65b0 ~ 65b7
0xbafb, 0xbafc, 0xbafd, 0xbafe, 0xbaff, 0xbb00, 0xbb01, 0xbb02,  // Offset: 65b8 ~ 65bf
0xbb03, 0xbb04, 0xbb05, 0xbb06, 0xbb07, 0xbb08, 0xbb09, 0xbb0a,  // Offset: 65c0 ~ 65c7
0xbb0b, 0xbb0c, 0xbb0d, 0xbb0e, 0xbb0f, 0xbb10, 0xbb11, 0xbb12,  // Offset: 65c8 ~ 65cf
0xbb13, 0xbb14, 0xbb15, 0xbb16, 0xbb17, 0xbb18, 0xbb19, 0xbb1a,  // Offset: 65d0 ~ 65d7
0xbb1b, 0xbb1c, 0xbb1d, 0xbb1e, 0xbb1f, 0xbb20, 0xbb21, 0xbb22,  // Offset: 65d8 ~ 65df
0xbb23, 0xbb24, 0xbb25, 0xbb26, 0xbb27, 0xbb28, 0xbb29, 0xbb2a,  // Offset: 65e0 ~ 65e7
0xbb2b, 0xbb2c, 0xbb2d, 0xbb2e, 0xbb2f, 0xbb30, 0xbb31, 0xbb32,  // Offset: 65e8 ~ 65ef
0xbb33, 0xbb34, 0xbb35, 0xbb36, 0xbb37, 0xbb38, 0xbb39, 0xbb3a,  // Offset: 65f0 ~ 65f7
0xbb3b, 0xbb3c, 0xbb3d, 0xbb3e, 0xbb3f, 0xbb40, 0xbb41, 0xbb42,  // Offset: 65f8 ~ 65ff
0xbb43, 0xbb44, 0xbb45, 0xbb46, 0xbb47, 0xbb48, 0xbb49, 0xbb4a,  // Offset: 6600 ~ 6607
0xbb4b, 0xbb4c, 0xbb4d, 0xbb4e, 0xbb4f, 0xbb50, 0xbb51, 0xbb52,  // Offset: 6608 ~ 660f
0xbb53, 0xbb54, 0xbb55, 0xbb56, 0xbb57, 0xbb58, 0xbb59, 0xbb5a,  // Offset: 6610 ~ 6617
0xbb5b, 0xbb5c, 0xbb5d, 0xbb5e, 0xbb5f, 0xbb60, 0xbb61, 0xbb62,  // Offset: 6618 ~ 661f
0xbb63, 0xbb64, 0xbb65, 0xbb66, 0xbb67, 0xbb68, 0xbb69, 0xbb6a,  // Offset: 6620 ~ 6627
0xbb6b, 0xbb6c, 0xbb6d, 0xbb6e, 0xbb6f, 0xbb70, 0xbb71, 0xbb72,  // Offset: 6628 ~ 662f
0xbb73, 0xbb74, 0xbb75, 0xbb76, 0xbb77, 0xbb78, 0xbb79, 0xbb7a,  // Offset: 6630 ~ 6637
0xbb7b, 0xbb7c, 0xbb7d, 0xbb7e, 0xbb7f, 0xbb80, 0xbb81, 0xbb82,  // Offset: 6638 ~ 663f
0xbb83, 0xbb84, 0xbb85, 0xbb86, 0xbb87, 0xbb88, 0xbb89, 0xbb8a,  // Offset: 6640 ~ 6647
0xbb8b, 0xbb8c, 0xbb8d, 0xbb8e, 0xbb8f, 0xbb90, 0xbb91, 0xbb92,  // Offset: 6648 ~ 664f
0xbb93, 0xbb94, 0xbb95, 0xbb96, 0xbb97, 0xbb98, 0xbb99, 0xbb9a,  // Offset: 6650 ~ 6657
0xbb9b, 0xbb9c, 0xbb9d, 0xbb9e, 0xbb9f, 0xbba0, 0xbba1, 0xbba2,  // Offset: 6658 ~ 665f
0xbba3, 0xbba4, 0xbba5, 0xbba6, 0xbba7, 0xbba8, 0xbba9, 0xbbaa,  // Offset: 6660 ~ 6667
0xbbab, 0xbbac, 0xbbad, 0xbbae, 0xbbaf, 0xbbb0, 0xbbb1, 0xbbb2,  // Offset: 6668 ~ 666f
0xbbb3, 0xbbb4, 0xbbb5, 0xbbb6, 0xbbb7, 0xbbb8, 0xbbb9, 0xbbba,  // Offset: 6670 ~ 6677
0xbbbb, 0xbbbc, 0xbbbd, 0xbbbe, 0xbbbf, 0xbbc0, 0xbbc1, 0xbbc2,  // Offset: 6678 ~ 667f
0xbbc3, 0xbbc4, 0xbbc5, 0xbbc6, 0xbbc7, 0xbbc8, 0xbbc9, 0xbbca,  // Offset: 6680 ~ 6687
0xbbcb, 0xbbcc, 0xbbcd, 0xbbce, 0xbbcf, 0xbbd0, 0xbbd1, 0xbbd2,  // Offset: 6688 ~ 668f
0xbbd3, 0xbbd4, 0xbbd5, 0xbbd6, 0xbbd7, 0xbbd8, 0xbbd9, 0xbbda,  // Offset: 6690 ~ 6697
0xbbdb, 0xbbdc, 0xbbdd, 0xbbde, 0xbbdf, 0xbbe0, 0xbbe1, 0xbbe2,  // Offset: 6698 ~ 669f
0xbbe3, 0xbbe4, 0xbbe5, 0xbbe6, 0xbbe7, 0xbbe8, 0xbbe9, 0xbbea,  // Offset: 66a0 ~ 66a7
0xbbeb, 0xbbec, 0xbbed, 0xbbee, 0xbbef, 0xbbf0, 0xbbf1, 0xbbf2,  // Offset: 66a8 ~ 66af
0xbbf3, 0xbbf4, 0xbbf5, 0xbbf6, 0xbbf7, 0xbbf8, 0xbbf9, 0xbbfa,  // Offset: 66b0 ~ 66b7
0xbbfb, 0xbbfc, 0xbbfd, 0xbbfe, 0xbbff, 0xbc00, 0xbc01, 0xbc02,  // Offset: 66b8 ~ 66bf
0xbc03, 0xbc04, 0xbc05, 0xbc06, 0xbc07, 0xbc08, 0xbc09, 0xbc0a,  // Offset: 66c0 ~ 66c7
0xbc0b, 0xbc0c, 0xbc0d, 0xbc0e, 0xbc0f, 0xbc10, 0xbc11, 0xbc12,  // Offset: 66c8 ~ 66cf
0xbc13, 0xbc14, 0xbc15, 0xbc16, 0xbc17, 0xbc18, 0xbc19, 0xbc1a,  // Offset: 66d0 ~ 66d7
0xbc1b, 0xbc1c, 0xbc1d, 0xbc1e, 0xbc1f, 0xbc20, 0xbc21, 0xbc22,  // Offset: 66d8 ~ 66df
0xbc23, 0xbc24, 0xbc25, 0xbc26, 0xbc27, 0xbc28, 0xbc29, 0xbc2a,  // Offset: 66e0 ~ 66e7
0xbc2b, 0xbc2c, 0xbc2d, 0xbc2e, 0xbc2f, 0xbc30, 0xbc31, 0xbc32,  // Offset: 66e8 ~ 66ef
0xbc33, 0xbc34, 0xbc35, 0xbc36, 0xbc37, 0xbc38, 0xbc39, 0xbc3a,  // Offset: 66f0 ~ 66f7
0xbc3b, 0xbc3c, 0xbc3d, 0xbc3e, 0xbc3f, 0xbc40, 0xbc41, 0xbc42,  // Offset: 66f8 ~ 66ff
0xbc43, 0xbc44, 0xbc45, 0xbc46, 0xbc47, 0xbc48, 0xbc49, 0xbc4a,  // Offset: 6700 ~ 6707
0xbc4b, 0xbc4c, 0xbc4d, 0xbc4e, 0xbc4f, 0xbc50, 0xbc51, 0xbc52,  // Offset: 6708 ~ 670f
0xbc53, 0xbc54, 0xbc55, 0xbc56, 0xbc57, 0xbc58, 0xbc59, 0xbc5a,  // Offset: 6710 ~ 6717
0xbc5b, 0xbc5c, 0xbc5d, 0xbc5e, 0xbc5f, 0xbc60, 0xbc61, 0xbc62,  // Offset: 6718 ~ 671f
0xbc63, 0xbc64, 0xbc65, 0xbc66, 0xbc67, 0xbc68, 0xbc69, 0xbc6a,  // Offset: 6720 ~ 6727
0xbc6b, 0xbc6c, 0xbc6d, 0xbc6e, 0xbc6f, 0xbc70, 0xbc71, 0xbc72,  // Offset: 6728 ~ 672f
0xbc73, 0xbc74, 0xbc75, 0xbc76, 0xbc77, 0xbc78, 0xbc79, 0xbc7a,  // Offset: 6730 ~ 6737
0xbc7b, 0xbc7c, 0xbc7d, 0xbc7e, 0xbc7f, 0xbc80, 0xbc81, 0xbc82,  // Offset: 6738 ~ 673f
0xbc83, 0xbc84, 0xbc85, 0xbc86, 0xbc87, 0xbc88, 0xbc89, 0xbc8a,  // Offset: 6740 ~ 6747
0xbc8b, 0xbc8c, 0xbc8d, 0xbc8e, 0xbc8f, 0xbc90, 0xbc91, 0xbc92,  // Offset: 6748 ~ 674f
0xbc93, 0xbc94, 0xbc95, 0xbc96, 0xbc97, 0xbc98, 0xbc99, 0xbc9a,  // Offset: 6750 ~ 6757
0xbc9b, 0xbc9c, 0xbc9d, 0xbc9e, 0xbc9f, 0xbca0, 0xbca1, 0xbca2,  // Offset: 6758 ~ 675f
0xbca3, 0xbca4, 0xbca5, 0xbca6, 0xbca7, 0xbca8, 0xbca9, 0xbcaa,  // Offset: 6760 ~ 6767
0xbcab, 0xbcac, 0xbcad, 0xbcae, 0xbcaf, 0xbcb0, 0xbcb1, 0xbcb2,  // Offset: 6768 ~ 676f
0xbcb3, 0xbcb4, 0xbcb5, 0xbcb6, 0xbcb7, 0xbcb8, 0xbcb9, 0xbcba,  // Offset: 6770 ~ 6777
0xbcbb, 0xbcbc, 0xbcbd, 0xbcbe, 0xbcbf, 0xbcc0, 0xbcc1, 0xbcc2,  // Offset: 6778 ~ 677f
0xbcc3, 0xbcc4, 0xbcc5, 0xbcc6, 0xbcc7, 0xbcc8, 0xbcc9, 0xbcca,  // Offset: 6780 ~ 6787
0xbccb, 0xbccc, 0xbccd, 0xbcce, 0xbccf, 0xbcd0, 0xbcd1, 0xbcd2,  // Offset: 6788 ~ 678f
0xbcd3, 0xbcd4, 0xbcd5, 0xbcd6, 0xbcd7, 0xbcd8, 0xbcd9, 0xbcda,  // Offset: 6790 ~ 6797
0xbcdb, 0xbcdc, 0xbcdd, 0xbcde, 0xbcdf, 0xbce0, 0xbce1, 0xbce2,  // Offset: 6798 ~ 679f
0xbce3, 0xbce4, 0xbce5, 0xbce6, 0xbce7, 0xbce8, 0xbce9, 0xbcea,  // Offset: 67a0 ~ 67a7
0xbceb, 0xbcec, 0xbced, 0xbcee, 0xbcef, 0xbcf0, 0xbcf1, 0xbcf2,  // Offset: 67a8 ~ 67af
0xbcf3, 0xbcf4, 0xbcf5, 0xbcf6, 0xbcf7, 0xbcf8, 0xbcf9, 0xbcfa,  // Offset: 67b0 ~ 67b7
0xbcfb, 0xbcfc, 0xbcfd, 0xbcfe, 0xbcff, 0xbd00, 0xbd01, 0xbd02,  // Offset: 67b8 ~ 67bf
0xbd03, 0xbd04, 0xbd05, 0xbd06, 0xbd07, 0xbd08, 0xbd09, 0xbd0a,  // Offset: 67c0 ~ 67c7
0xbd0b, 0xbd0c, 0xbd0d, 0xbd0e, 0xbd0f, 0xbd10, 0xbd11, 0xbd12,  // Offset: 67c8 ~ 67cf
0xbd13, 0xbd14, 0xbd15, 0xbd16, 0xbd17, 0xbd18, 0xbd19, 0xbd1a,  // Offset: 67d0 ~ 67d7
0xbd1b, 0xbd1c, 0xbd1d, 0xbd1e, 0xbd1f, 0xbd20, 0xbd21, 0xbd22,  // Offset: 67d8 ~ 67df
0xbd23, 0xbd24, 0xbd25, 0xbd26, 0xbd27, 0xbd28, 0xbd29, 0xbd2a,  // Offset: 67e0 ~ 67e7
0xbd2b, 0xbd2c, 0xbd2d, 0xbd2e, 0xbd2f, 0xbd30, 0xbd31, 0xbd32,  // Offset: 67e8 ~ 67ef
0xbd33, 0xbd34, 0xbd35, 0xbd36, 0xbd37, 0xbd38, 0xbd39, 0xbd3a,  // Offset: 67f0 ~ 67f7
0xbd3b, 0xbd3c, 0xbd3d, 0xbd3e, 0xbd3f, 0xbd40, 0xbd41, 0xbd42,  // Offset: 67f8 ~ 67ff
0xbd43, 0xbd44, 0xbd45, 0xbd46, 0xbd47, 0xbd48, 0xbd49, 0xbd4a,  // Offset: 6800 ~ 6807
0xbd4b, 0xbd4c, 0xbd4d, 0xbd4e, 0xbd4f, 0xbd50, 0xbd51, 0xbd52,  // Offset: 6808 ~ 680f
0xbd53, 0xbd54, 0xbd55, 0xbd56, 0xbd57, 0xbd58, 0xbd59, 0xbd5a,  // Offset: 6810 ~ 6817
0xbd5b, 0xbd5c, 0xbd5d, 0xbd5e, 0xbd5f, 0xbd60, 0xbd61, 0xbd62,  // Offset: 6818 ~ 681f
0xbd63, 0xbd64, 0xbd65, 0xbd66, 0xbd67, 0xbd68, 0xbd69, 0xbd6a,  // Offset: 6820 ~ 6827
0xbd6b, 0xbd6c, 0xbd6d, 0xbd6e, 0xbd6f, 0xbd70, 0xbd71, 0xbd72,  // Offset: 6828 ~ 682f
0xbd73, 0xbd74, 0xbd75, 0xbd76, 0xbd77, 0xbd78, 0xbd79, 0xbd7a,  // Offset: 6830 ~ 6837
0xbd7b, 0xbd7c, 0xbd7d, 0xbd7e, 0xbd7f, 0xbd80, 0xbd81, 0xbd82,  // Offset: 6838 ~ 683f
0xbd83, 0xbd84, 0xbd85, 0xbd86, 0xbd87, 0xbd88, 0xbd89, 0xbd8a,  // Offset: 6840 ~ 6847
0xbd8b, 0xbd8c, 0xbd8d, 0xbd8e, 0xbd8f, 0xbd90, 0xbd91, 0xbd92,  // Offset: 6848 ~ 684f
0xbd93, 0xbd94, 0xbd95, 0xbd96, 0xbd97, 0xbd98, 0xbd99, 0xbd9a,  // Offset: 6850 ~ 6857
0xbd9b, 0xbd9c, 0xbd9d, 0xbd9e, 0xbd9f, 0xbda0, 0xbda1, 0xbda2,  // Offset: 6858 ~ 685f
0xbda3, 0xbda4, 0xbda5, 0xbda6, 0xbda7, 0xbda8, 0xbda9, 0xbdaa,  // Offset: 6860 ~ 6867
0xbdab, 0xbdac, 0xbdad, 0xbdae, 0xbdaf, 0xbdb0, 0xbdb1, 0xbdb2,  // Offset: 6868 ~ 686f
0xbdb3, 0xbdb4, 0xbdb5, 0xbdb6, 0xbdb7, 0xbdb8, 0xbdb9, 0xbdba,  // Offset: 6870 ~ 6877
0xbdbb, 0xbdbc, 0xbdbd, 0xbdbe, 0xbdbf, 0xbdc0, 0xbdc1, 0xbdc2,  // Offset: 6878 ~ 687f
0xbdc3, 0xbdc4, 0xbdc5, 0xbdc6, 0xbdc7, 0xbdc8, 0xbdc9, 0xbdca,  // Offset: 6880 ~ 6887
0xbdcb, 0xbdcc, 0xbdcd, 0xbdce, 0xbdcf, 0xbdd0, 0xbdd1, 0xbdd2,  // Offset: 6888 ~ 688f
0xbdd3, 0xbdd4, 0xbdd5, 0xbdd6, 0xbdd7, 0xbdd8, 0xbdd9, 0xbdda,  // Offset: 6890 ~ 6897
0xbddb, 0xbddc, 0xbddd, 0xbdde, 0xbddf, 0xbde0, 0xbde1, 0xbde2,  // Offset: 6898 ~ 689f
0xbde3, 0xbde4, 0xbde5, 0xbde6, 0xbde7, 0xbde8, 0xbde9, 0xbdea,  // Offset: 68a0 ~ 68a7
0xbdeb, 0xbdec, 0xbded, 0xbdee, 0xbdef, 0xbdf0, 0xbdf1, 0xbdf2,  // Offset: 68a8 ~ 68af
0xbdf3, 0xbdf4, 0xbdf5, 0xbdf6, 0xbdf7, 0xbdf8, 0xbdf9, 0xbdfa,  // Offset: 68b0 ~ 68b7
0xbdfb, 0xbdfc, 0xbdfd, 0xbdfe, 0xbdff, 0xbe00, 0xbe01, 0xbe02,  // Offset: 68b8 ~ 68bf
0xbe03, 0xbe04, 0xbe05, 0xbe06, 0xbe07, 0xbe08, 0xbe09, 0xbe0a,  // Offset: 68c0 ~ 68c7
0xbe0b, 0xbe0c, 0xbe0d, 0xbe0e, 0xbe0f, 0xbe10, 0xbe11, 0xbe12,  // Offset: 68c8 ~ 68cf
0xbe13, 0xbe14, 0xbe15, 0xbe16, 0xbe17, 0xbe18, 0xbe19, 0xbe1a,  // Offset: 68d0 ~ 68d7
0xbe1b, 0xbe1c, 0xbe1d, 0xbe1e, 0xbe1f, 0xbe20, 0xbe21, 0xbe22,  // Offset: 68d8 ~ 68df
0xbe23, 0xbe24, 0xbe25, 0xbe26, 0xbe27, 0xbe28, 0xbe29, 0xbe2a,  // Offset: 68e0 ~ 68e7
0xbe2b, 0xbe2c, 0xbe2d, 0xbe2e, 0xbe2f, 0xbe30, 0xbe31, 0xbe32,  // Offset: 68e8 ~ 68ef
0xbe33, 0xbe34, 0xbe35, 0xbe36, 0xbe37, 0xbe38, 0xbe39, 0xbe3a,  // Offset: 68f0 ~ 68f7
0xbe3b, 0xbe3c, 0xbe3d, 0xbe3e, 0xbe3f, 0xbe40, 0xbe41, 0xbe42,  // Offset: 68f8 ~ 68ff
0xbe43, 0xbe44, 0xbe45, 0xbe46, 0xbe47, 0xbe48, 0xbe49, 0xbe4a,  // Offset: 6900 ~ 6907
0xbe4b, 0xbe4c, 0xbe4d, 0xbe4e, 0xbe4f, 0xbe50, 0xbe51, 0xbe52,  // Offset: 6908 ~ 690f
0xbe53, 0xbe54, 0xbe55, 0xbe56, 0xbe57, 0xbe58, 0xbe59, 0xbe5a,  // Offset: 6910 ~ 6917
0xbe5b, 0xbe5c, 0xbe5d, 0xbe5e, 0xbe5f, 0xbe60, 0xbe61, 0xbe62,  // Offset: 6918 ~ 691f
0xbe63, 0xbe64, 0xbe65, 0xbe66, 0xbe67, 0xbe68, 0xbe69, 0xbe6a,  // Offset: 6920 ~ 6927
0xbe6b, 0xbe6c, 0xbe6d, 0xbe6e, 0xbe6f, 0xbe70, 0xbe71, 0xbe72,  // Offset: 6928 ~ 692f
0xbe73, 0xbe74, 0xbe75, 0xbe76, 0xbe77, 0xbe78, 0xbe79, 0xbe7a,  // Offset: 6930 ~ 6937
0xbe7b, 0xbe7c, 0xbe7d, 0xbe7e, 0xbe7f, 0xbe80, 0xbe81, 0xbe82,  // Offset: 6938 ~ 693f
0xbe83, 0xbe84, 0xbe85, 0xbe86, 0xbe87, 0xbe88, 0xbe89, 0xbe8a,  // Offset: 6940 ~ 6947
0xbe8b, 0xbe8c, 0xbe8d, 0xbe8e, 0xbe8f, 0xbe90, 0xbe91, 0xbe92,  // Offset: 6948 ~ 694f
0xbe93, 0xbe94, 0xbe95, 0xbe96, 0xbe97, 0xbe98, 0xbe99, 0xbe9a,  // Offset: 6950 ~ 6957
0xbe9b, 0xbe9c, 0xbe9d, 0xbe9e, 0xbe9f, 0xbea0, 0xbea1, 0xbea2,  // Offset: 6958 ~ 695f
0xbea3, 0xbea4, 0xbea5, 0xbea6, 0xbea7, 0xbea8, 0xbea9, 0xbeaa,  // Offset: 6960 ~ 6967
0xbeab, 0xbeac, 0xbead, 0xbeae, 0xbeaf, 0xbeb0, 0xbeb1, 0xbeb2,  // Offset: 6968 ~ 696f
0xbeb3, 0xbeb4, 0xbeb5, 0xbeb6, 0xbeb7, 0xbeb8, 0xbeb9, 0xbeba,  // Offset: 6970 ~ 6977
0xbebb, 0xbebc, 0xbebd, 0xbebe, 0xbebf, 0xbec0, 0xbec1, 0xbec2,  // Offset: 6978 ~ 697f
0xbec3, 0xbec4, 0xbec5, 0xbec6, 0xbec7, 0xbec8, 0xbec9, 0xbeca,  // Offset: 6980 ~ 6987
0xbecb, 0xbecc, 0xbecd, 0xbece, 0xbecf, 0xbed0, 0xbed1, 0xbed2,  // Offset: 6988 ~ 698f
0xbed3, 0xbed4, 0xbed5, 0xbed6, 0xbed7, 0xbed8, 0xbed9, 0xbeda,  // Offset: 6990 ~ 6997
0xbedb, 0xbedc, 0xbedd, 0xbede, 0xbedf, 0xbee0, 0xbee1, 0xbee2,  // Offset: 6998 ~ 699f
0xbee3, 0xbee4, 0xbee5, 0xbee6, 0xbee7, 0xbee8, 0xbee9, 0xbeea,  // Offset: 69a0 ~ 69a7
0xbeeb, 0xbeec, 0xbeed, 0xbeee, 0xbeef, 0xbef0, 0xbef1, 0xbef2,  // Offset: 69a8 ~ 69af
0xbef3, 0xbef4, 0xbef5, 0xbef6, 0xbef7, 0xbef8, 0xbef9, 0xbefa,  // Offset: 69b0 ~ 69b7
0xbefb, 0xbefc, 0xbefd, 0xbefe, 0xbeff, 0xbf00, 0xbf01, 0xbf02,  // Offset: 69b8 ~ 69bf
0xbf03, 0xbf04, 0xbf05, 0xbf06, 0xbf07, 0xbf08, 0xbf09, 0xbf0a,  // Offset: 69c0 ~ 69c7
0xbf0b, 0xbf0c, 0xbf0d, 0xbf0e, 0xbf0f, 0xbf10, 0xbf11, 0xbf12,  // Offset: 69c8 ~ 69cf
0xbf13, 0xbf14, 0xbf15, 0xbf16, 0xbf17, 0xbf18, 0xbf19, 0xbf1a,  // Offset: 69d0 ~ 69d7
0xbf1b, 0xbf1c, 0xbf1d, 0xbf1e, 0xbf1f, 0xbf20, 0xbf21, 0xbf22,  // Offset: 69d8 ~ 69df
0xbf23, 0xbf24, 0xbf25, 0xbf26, 0xbf27, 0xbf28, 0xbf29, 0xbf2a,  // Offset: 69e0 ~ 69e7
0xbf2b, 0xbf2c, 0xbf2d, 0xbf2e, 0xbf2f, 0xbf30, 0xbf31, 0xbf32,  // Offset: 69e8 ~ 69ef
0xbf33, 0xbf34, 0xbf35, 0xbf36, 0xbf37, 0xbf38, 0xbf39, 0xbf3a,  // Offset: 69f0 ~ 69f7
0xbf3b, 0xbf3c, 0xbf3d, 0xbf3e, 0xbf3f, 0xbf40, 0xbf41, 0xbf42,  // Offset: 69f8 ~ 69ff
0xbf43, 0xbf44, 0xbf45, 0xbf46, 0xbf47, 0xbf48, 0xbf49, 0xbf4a,  // Offset: 6a00 ~ 6a07
0xbf4b, 0xbf4c, 0xbf4d, 0xbf4e, 0xbf4f, 0xbf50, 0xbf51, 0xbf52,  // Offset: 6a08 ~ 6a0f
0xbf53, 0xbf54, 0xbf55, 0xbf56, 0xbf57, 0xbf58, 0xbf59, 0xbf5a,  // Offset: 6a10 ~ 6a17
0xbf5b, 0xbf5c, 0xbf5d, 0xbf5e, 0xbf5f, 0xbf60, 0xbf61, 0xbf62,  // Offset: 6a18 ~ 6a1f
0xbf63, 0xbf64, 0xbf65, 0xbf66, 0xbf67, 0xbf68, 0xbf69, 0xbf6a,  // Offset: 6a20 ~ 6a27
0xbf6b, 0xbf6c, 0xbf6d, 0xbf6e, 0xbf6f, 0xbf70, 0xbf71, 0xbf72,  // Offset: 6a28 ~ 6a2f
0xbf73, 0xbf74, 0xbf75, 0xbf76, 0xbf77, 0xbf78, 0xbf79, 0xbf7a,  // Offset: 6a30 ~ 6a37
0xbf7b, 0xbf7c, 0xbf7d, 0xbf7e, 0xbf7f, 0xbf80, 0xbf81, 0xbf82,  // Offset: 6a38 ~ 6a3f
0xbf83, 0xbf84, 0xbf85, 0xbf86, 0xbf87, 0xbf88, 0xbf89, 0xbf8a,  // Offset: 6a40 ~ 6a47
0xbf8b, 0xbf8c, 0xbf8d, 0xbf8e, 0xbf8f, 0xbf90, 0xbf91, 0xbf92,  // Offset: 6a48 ~ 6a4f
0xbf93, 0xbf94, 0xbf95, 0xbf96, 0xbf97, 0xbf98, 0xbf99, 0xbf9a,  // Offset: 6a50 ~ 6a57
0xbf9b, 0xbf9c, 0xbf9d, 0xbf9e, 0xbf9f, 0xbfa0, 0xbfa1, 0xbfa2,  // Offset: 6a58 ~ 6a5f
0xbfa3, 0xbfa4, 0xbfa5, 0xbfa6, 0xbfa7, 0xbfa8, 0xbfa9, 0xbfaa,  // Offset: 6a60 ~ 6a67
0xbfab, 0xbfac, 0xbfad, 0xbfae, 0xbfaf, 0xbfb0, 0xbfb1, 0xbfb2,  // Offset: 6a68 ~ 6a6f
0xbfb3, 0xbfb4, 0xbfb5, 0xbfb6, 0xbfb7, 0xbfb8, 0xbfb9, 0xbfba,  // Offset: 6a70 ~ 6a77
0xbfbb, 0xbfbc, 0xbfbd, 0xbfbe, 0xbfbf, 0xbfc0, 0xbfc1, 0xbfc2,  // Offset: 6a78 ~ 6a7f
0xbfc3, 0xbfc4, 0xbfc5, 0xbfc6, 0xbfc7, 0xbfc8, 0xbfc9, 0xbfca,  // Offset: 6a80 ~ 6a87
0xbfcb, 0xbfcc, 0xbfcd, 0xbfce, 0xbfcf, 0xbfd0, 0xbfd1, 0xbfd2,  // Offset: 6a88 ~ 6a8f
0xbfd3, 0xbfd4, 0xbfd5, 0xbfd6, 0xbfd7, 0xbfd8, 0xbfd9, 0xbfda,  // Offset: 6a90 ~ 6a97
0xbfdb, 0xbfdc, 0xbfdd, 0xbfde, 0xbfdf, 0xbfe0, 0xbfe1, 0xbfe2,  // Offset: 6a98 ~ 6a9f
0xbfe3, 0xbfe4, 0xbfe5, 0xbfe6, 0xbfe7, 0xbfe8, 0xbfe9, 0xbfea,  // Offset: 6aa0 ~ 6aa7
0xbfeb, 0xbfec, 0xbfed, 0xbfee, 0xbfef, 0xbff0, 0xbff1, 0xbff2,  // Offset: 6aa8 ~ 6aaf
0xbff3, 0xbff4, 0xbff5, 0xbff6, 0xbff7, 0xbff8, 0xbff9, 0xbffa,  // Offset: 6ab0 ~ 6ab7
0xbffb, 0xbffc, 0xbffd, 0xbffe, 0xbfff, 0xc000, 0xc001, 0xc002,  // Offset: 6ab8 ~ 6abf
0xc003, 0xc004, 0xc005, 0xc006, 0xc007, 0xc008, 0xc009, 0xc00a,  // Offset: 6ac0 ~ 6ac7
0xc00b, 0xc00c, 0xc00d, 0xc00e, 0xc00f, 0xc010, 0xc011, 0xc012,  // Offset: 6ac8 ~ 6acf
0xc013, 0xc014, 0xc015, 0xc016, 0xc017, 0xc018, 0xc019, 0xc01a,  // Offset: 6ad0 ~ 6ad7
0xc01b, 0xc01c, 0xc01d, 0xc01e, 0xc01f, 0xc020, 0xc021, 0xc022,  // Offset: 6ad8 ~ 6adf
0xc023, 0xc024, 0xc025, 0xc026, 0xc027, 0xc028, 0xc029, 0xc02a,  // Offset: 6ae0 ~ 6ae7
0xc02b, 0xc02c, 0xc02d, 0xc02e, 0xc02f, 0xc030, 0xc031, 0xc032,  // Offset: 6ae8 ~ 6aef
0xc033, 0xc034, 0xc035, 0xc036, 0xc037, 0xc038, 0xc039, 0xc03a,  // Offset: 6af0 ~ 6af7
0xc03b, 0xc03c, 0xc03d, 0xc03e, 0xc03f, 0xc040, 0xc041, 0xc042,  // Offset: 6af8 ~ 6aff
0xc043, 0xc044, 0xc045, 0xc046, 0xc047, 0xc048, 0xc049, 0xc04a,  // Offset: 6b00 ~ 6b07
0xc04b, 0xc04c, 0xc04d, 0xc04e, 0xc04f, 0xc050, 0xc051, 0xc052,  // Offset: 6b08 ~ 6b0f
0xc053, 0xc054, 0xc055, 0xc056, 0xc057, 0xc058, 0xc059, 0xc05a,  // Offset: 6b10 ~ 6b17
0xc05b, 0xc05c, 0xc05d, 0xc05e, 0xc05f, 0xc060, 0xc061, 0xc062,  // Offset: 6b18 ~ 6b1f
0xc063, 0xc064, 0xc065, 0xc066, 0xc067, 0xc068, 0xc069, 0xc06a,  // Offset: 6b20 ~ 6b27
0xc06b, 0xc06c, 0xc06d, 0xc06e, 0xc06f, 0xc070, 0xc071, 0xc072,  // Offset: 6b28 ~ 6b2f
0xc073, 0xc074, 0xc075, 0xc076, 0xc077, 0xc078, 0xc079, 0xc07a,  // Offset: 6b30 ~ 6b37
0xc07b, 0xc07c, 0xc07d, 0xc07e, 0xc07f, 0xc080, 0xc081, 0xc082,  // Offset: 6b38 ~ 6b3f
0xc083, 0xc084, 0xc085, 0xc086, 0xc087, 0xc088, 0xc089, 0xc08a,  // Offset: 6b40 ~ 6b47
0xc08b, 0xc08c, 0xc08d, 0xc08e, 0xc08f, 0xc090, 0xc091, 0xc092,  // Offset: 6b48 ~ 6b4f
0xc093, 0xc094, 0xc095, 0xc096, 0xc097, 0xc098, 0xc099, 0xc09a,  // Offset: 6b50 ~ 6b57
0xc09b, 0xc09c, 0xc09d, 0xc09e, 0xc09f, 0xc0a0, 0xc0a1, 0xc0a2,  // Offset: 6b58 ~ 6b5f
0xc0a3, 0xc0a4, 0xc0a5, 0xc0a6, 0xc0a7, 0xc0a8, 0xc0a9, 0xc0aa,  // Offset: 6b60 ~ 6b67
0xc0ab, 0xc0ac, 0xc0ad, 0xc0ae, 0xc0af, 0xc0b0, 0xc0b1, 0xc0b2,  // Offset: 6b68 ~ 6b6f
0xc0b3, 0xc0b4, 0xc0b5, 0xc0b6, 0xc0b7, 0xc0b8, 0xc0b9, 0xc0ba,  // Offset: 6b70 ~ 6b77
0xc0bb, 0xc0bc, 0xc0bd, 0xc0be, 0xc0bf, 0xc0c0, 0xc0c1, 0xc0c2,  // Offset: 6b78 ~ 6b7f
0xc0c3, 0xc0c4, 0xc0c5, 0xc0c6, 0xc0c7, 0xc0c8, 0xc0c9, 0xc0ca,  // Offset: 6b80 ~ 6b87
0xc0cb, 0xc0cc, 0xc0cd, 0xc0ce, 0xc0cf, 0xc0d0, 0xc0d1, 0xc0d2,  // Offset: 6b88 ~ 6b8f
0xc0d3, 0xc0d4, 0xc0d5, 0xc0d6, 0xc0d7, 0xc0d8, 0xc0d9, 0xc0da,  // Offset: 6b90 ~ 6b97
0xc0db, 0xc0dc, 0xc0dd, 0xc0de, 0xc0df, 0xc0e0, 0xc0e1, 0xc0e2,  // Offset: 6b98 ~ 6b9f
0xc0e3, 0xc0e4, 0xc0e5, 0xc0e6, 0xc0e7, 0xc0e8, 0xc0e9, 0xc0ea,  // Offset: 6ba0 ~ 6ba7
0xc0eb, 0xc0ec, 0xc0ed, 0xc0ee, 0xc0ef, 0xc0f0, 0xc0f1, 0xc0f2,  // Offset: 6ba8 ~ 6baf
0xc0f3, 0xc0f4, 0xc0f5, 0xc0f6, 0xc0f7, 0xc0f8, 0xc0f9, 0xc0fa,  // Offset: 6bb0 ~ 6bb7
0xc0fb, 0xc0fc, 0xc0fd, 0xc0fe, 0xc0ff, 0xc100, 0xc101, 0xc102,  // Offset: 6bb8 ~ 6bbf
0xc103, 0xc104, 0xc105, 0xc106, 0xc107, 0xc108, 0xc109, 0xc10a,  // Offset: 6bc0 ~ 6bc7
0xc10b, 0xc10c, 0xc10d, 0xc10e, 0xc10f, 0xc110, 0xc111, 0xc112,  // Offset: 6bc8 ~ 6bcf
0xc113, 0xc114, 0xc115, 0xc116, 0xc117, 0xc118, 0xc119, 0xc11a,  // Offset: 6bd0 ~ 6bd7
0xc11b, 0xc11c, 0xc11d, 0xc11e, 0xc11f, 0xc120, 0xc121, 0xc122,  // Offset: 6bd8 ~ 6bdf
0xc123, 0xc124, 0xc125, 0xc126, 0xc127, 0xc128, 0xc129, 0xc12a,  // Offset: 6be0 ~ 6be7
0xc12b, 0xc12c, 0xc12d, 0xc12e, 0xc12f, 0xc130, 0xc131, 0xc132,  // Offset: 6be8 ~ 6bef
0xc133, 0xc134, 0xc135, 0xc136, 0xc137, 0xc138, 0xc139, 0xc13a,  // Offset: 6bf0 ~ 6bf7
0xc13b, 0xc13c, 0xc13d, 0xc13e, 0xc13f, 0xc140, 0xc141, 0xc142,  // Offset: 6bf8 ~ 6bff
0xc143, 0xc144, 0xc145, 0xc146, 0xc147, 0xc148, 0xc149, 0xc14a,  // Offset: 6c00 ~ 6c07
0xc14b, 0xc14c, 0xc14d, 0xc14e, 0xc14f, 0xc150, 0xc151, 0xc152,  // Offset: 6c08 ~ 6c0f
0xc153, 0xc154, 0xc155, 0xc156, 0xc157, 0xc158, 0xc159, 0xc15a,  // Offset: 6c10 ~ 6c17
0xc15b, 0xc15c, 0xc15d, 0xc15e, 0xc15f, 0xc160, 0xc161, 0xc162,  // Offset: 6c18 ~ 6c1f
0xc163, 0xc164, 0xc165, 0xc166, 0xc167, 0xc168, 0xc169, 0xc16a,  // Offset: 6c20 ~ 6c27
0xc16b, 0xc16c, 0xc16d, 0xc16e, 0xc16f, 0xc170, 0xc171, 0xc172,  // Offset: 6c28 ~ 6c2f
0xc173, 0xc174, 0xc175, 0xc176, 0xc177, 0xc178, 0xc179, 0xc17a,  // Offset: 6c30 ~ 6c37
0xc17b, 0xc17c, 0xc17d, 0xc17e, 0xc17f, 0xc180, 0xc181, 0xc182,  // Offset: 6c38 ~ 6c3f
0xc183, 0xc184, 0xc185, 0xc186, 0xc187, 0xc188, 0xc189, 0xc18a,  // Offset: 6c40 ~ 6c47
0xc18b, 0xc18c, 0xc18d, 0xc18e, 0xc18f, 0xc190, 0xc191, 0xc192,  // Offset: 6c48 ~ 6c4f
0xc193, 0xc194, 0xc195, 0xc196, 0xc197, 0xc198, 0xc199, 0xc19a,  // Offset: 6c50 ~ 6c57
0xc19b, 0xc19c, 0xc19d, 0xc19e, 0xc19f, 0xc1a0, 0xc1a1, 0xc1a2,  // Offset: 6c58 ~ 6c5f
0xc1a3, 0xc1a4, 0xc1a5, 0xc1a6, 0xc1a7, 0xc1a8, 0xc1a9, 0xc1aa,  // Offset: 6c60 ~ 6c67
0xc1ab, 0xc1ac, 0xc1ad, 0xc1ae, 0xc1af, 0xc1b0, 0xc1b1, 0xc1b2,  // Offset: 6c68 ~ 6c6f
0xc1b3, 0xc1b4, 0xc1b5, 0xc1b6, 0xc1b7, 0xc1b8, 0xc1b9, 0xc1ba,  // Offset: 6c70 ~ 6c77
0xc1bb, 0xc1bc, 0xc1bd, 0xc1be, 0xc1bf, 0xc1c0, 0xc1c1, 0xc1c2,  // Offset: 6c78 ~ 6c7f
0xc1c3, 0xc1c4, 0xc1c5, 0xc1c6, 0xc1c7, 0xc1c8, 0xc1c9, 0xc1ca,  // Offset: 6c80 ~ 6c87
0xc1cb, 0xc1cc, 0xc1cd, 0xc1ce, 0xc1cf, 0xc1d0, 0xc1d1, 0xc1d2,  // Offset: 6c88 ~ 6c8f
0xc1d3, 0xc1d4, 0xc1d5, 0xc1d6, 0xc1d7, 0xc1d8, 0xc1d9, 0xc1da,  // Offset: 6c90 ~ 6c97
0xc1db, 0xc1dc, 0xc1dd, 0xc1de, 0xc1df, 0xc1e0, 0xc1e1, 0xc1e2,  // Offset: 6c98 ~ 6c9f
0xc1e3, 0xc1e4, 0xc1e5, 0xc1e6, 0xc1e7, 0xc1e8, 0xc1e9, 0xc1ea,  // Offset: 6ca0 ~ 6ca7
0xc1eb, 0xc1ec, 0xc1ed, 0xc1ee, 0xc1ef, 0xc1f0, 0xc1f1, 0xc1f2,  // Offset: 6ca8 ~ 6caf
0xc1f3, 0xc1f4, 0xc1f5, 0xc1f6, 0xc1f7, 0xc1f8, 0xc1f9, 0xc1fa,  // Offset: 6cb0 ~ 6cb7
0xc1fb, 0xc1fc, 0xc1fd, 0xc1fe, 0xc1ff, 0xc200, 0xc201, 0xc202,  // Offset: 6cb8 ~ 6cbf
0xc203, 0xc204, 0xc205, 0xc206, 0xc207, 0xc208, 0xc209, 0xc20a,  // Offset: 6cc0 ~ 6cc7
0xc20b, 0xc20c, 0xc20d, 0xc20e, 0xc20f, 0xc210, 0xc211, 0xc212,  // Offset: 6cc8 ~ 6ccf
0xc213, 0xc214, 0xc215, 0xc216, 0xc217, 0xc218, 0xc219, 0xc21a,  // Offset: 6cd0 ~ 6cd7
0xc21b, 0xc21c, 0xc21d, 0xc21e, 0xc21f, 0xc220, 0xc221, 0xc222,  // Offset: 6cd8 ~ 6cdf
0xc223, 0xc224, 0xc225, 0xc226, 0xc227, 0xc228, 0xc229, 0xc22a,  // Offset: 6ce0 ~ 6ce7
0xc22b, 0xc22c, 0xc22d, 0xc22e, 0xc22f, 0xc230, 0xc231, 0xc232,  // Offset: 6ce8 ~ 6cef
0xc233, 0xc234, 0xc235, 0xc236, 0xc237, 0xc238, 0xc239, 0xc23a,  // Offset: 6cf0 ~ 6cf7
0xc23b, 0xc23c, 0xc23d, 0xc23e, 0xc23f, 0xc240, 0xc241, 0xc242,  // Offset: 6cf8 ~ 6cff
0xc243, 0xc244, 0xc245, 0xc246, 0xc247, 0xc248, 0xc249, 0xc24a,  // Offset: 6d00 ~ 6d07
0xc24b, 0xc24c, 0xc24d, 0xc24e, 0xc24f, 0xc250, 0xc251, 0xc252,  // Offset: 6d08 ~ 6d0f
0xc253, 0xc254, 0xc255, 0xc256, 0xc257, 0xc258, 0xc259, 0xc25a,  // Offset: 6d10 ~ 6d17
0xc25b, 0xc25c, 0xc25d, 0xc25e, 0xc25f, 0xc260, 0xc261, 0xc262,  // Offset: 6d18 ~ 6d1f
0xc263, 0xc264, 0xc265, 0xc266, 0xc267, 0xc268, 0xc269, 0xc26a,  // Offset: 6d20 ~ 6d27
0xc26b, 0xc26c, 0xc26d, 0xc26e, 0xc26f, 0xc270, 0xc271, 0xc272,  // Offset: 6d28 ~ 6d2f
0xc273, 0xc274, 0xc275, 0xc276, 0xc277, 0xc278, 0xc279, 0xc27a,  // Offset: 6d30 ~ 6d37
0xc27b, 0xc27c, 0xc27d, 0xc27e, 0xc27f, 0xc280, 0xc281, 0xc282,  // Offset: 6d38 ~ 6d3f
0xc283, 0xc284, 0xc285, 0xc286, 0xc287, 0xc288, 0xc289, 0xc28a,  // Offset: 6d40 ~ 6d47
0xc28b, 0xc28c, 0xc28d, 0xc28e, 0xc28f, 0xc290, 0xc291, 0xc292,  // Offset: 6d48 ~ 6d4f
0xc293, 0xc294, 0xc295, 0xc296, 0xc297, 0xc298, 0xc299, 0xc29a,  // Offset: 6d50 ~ 6d57
0xc29b, 0xc29c, 0xc29d, 0xc29e, 0xc29f, 0xc2a0, 0xc2a1, 0xc2a2,  // Offset: 6d58 ~ 6d5f
0xc2a3, 0xc2a4, 0xc2a5, 0xc2a6, 0xc2a7, 0xc2a8, 0xc2a9, 0xc2aa,  // Offset: 6d60 ~ 6d67
0xc2ab, 0xc2ac, 0xc2ad, 0xc2ae, 0xc2af, 0xc2b0, 0xc2b1, 0xc2b2,  // Offset: 6d68 ~ 6d6f
0xc2b3, 0xc2b4, 0xc2b5, 0xc2b6, 0xc2b7, 0xc2b8, 0xc2b9, 0xc2ba,  // Offset: 6d70 ~ 6d77
0xc2bb, 0xc2bc, 0xc2bd, 0xc2be, 0xc2bf, 0xc2c0, 0xc2c1, 0xc2c2,  // Offset: 6d78 ~ 6d7f
0xc2c3, 0xc2c4, 0xc2c5, 0xc2c6, 0xc2c7, 0xc2c8, 0xc2c9, 0xc2ca,  // Offset: 6d80 ~ 6d87
0xc2cb, 0xc2cc, 0xc2cd, 0xc2ce, 0xc2cf, 0xc2d0, 0xc2d1, 0xc2d2,  // Offset: 6d88 ~ 6d8f
0xc2d3, 0xc2d4, 0xc2d5, 0xc2d6, 0xc2d7, 0xc2d8, 0xc2d9, 0xc2da,  // Offset: 6d90 ~ 6d97
0xc2db, 0xc2dc, 0xc2dd, 0xc2de, 0xc2df, 0xc2e0, 0xc2e1, 0xc2e2,  // Offset: 6d98 ~ 6d9f
0xc2e3, 0xc2e4, 0xc2e5, 0xc2e6, 0xc2e7, 0xc2e8, 0xc2e9, 0xc2ea,  // Offset: 6da0 ~ 6da7
0xc2eb, 0xc2ec, 0xc2ed, 0xc2ee, 0xc2ef, 0xc2f0, 0xc2f1, 0xc2f2,  // Offset: 6da8 ~ 6daf
0xc2f3, 0xc2f4, 0xc2f5, 0xc2f6, 0xc2f7, 0xc2f8, 0xc2f9, 0xc2fa,  // Offset: 6db0 ~ 6db7
0xc2fb, 0xc2fc, 0xc2fd, 0xc2fe, 0xc2ff, 0xc300, 0xc301, 0xc302,  // Offset: 6db8 ~ 6dbf
0xc303, 0xc304, 0xc305, 0xc306, 0xc307, 0xc308, 0xc309, 0xc30a,  // Offset: 6dc0 ~ 6dc7
0xc30b, 0xc30c, 0xc30d, 0xc30e, 0xc30f, 0xc310, 0xc311, 0xc312,  // Offset: 6dc8 ~ 6dcf
0xc313, 0xc314, 0xc315, 0xc316, 0xc317, 0xc318, 0xc319, 0xc31a,  // Offset: 6dd0 ~ 6dd7
0xc31b, 0xc31c, 0xc31d, 0xc31e, 0xc31f, 0xc320, 0xc321, 0xc322,  // Offset: 6dd8 ~ 6ddf
0xc323, 0xc324, 0xc325, 0xc326, 0xc327, 0xc328, 0xc329, 0xc32a,  // Offset: 6de0 ~ 6de7
0xc32b, 0xc32c, 0xc32d, 0xc32e, 0xc32f, 0xc330, 0xc331, 0xc332,  // Offset: 6de8 ~ 6def
0xc333, 0xc334, 0xc335, 0xc336, 0xc337, 0xc338, 0xc339, 0xc33a,  // Offset: 6df0 ~ 6df7
0xc33b, 0xc33c, 0xc33d, 0xc33e, 0xc33f, 0xc340, 0xc341, 0xc342,  // Offset: 6df8 ~ 6dff
0xc343, 0xc344, 0xc345, 0xc346, 0xc347, 0xc348, 0xc349, 0xc34a,  // Offset: 6e00 ~ 6e07
0xc34b, 0xc34c, 0xc34d, 0xc34e, 0xc34f, 0xc350, 0xc351, 0xc352,  // Offset: 6e08 ~ 6e0f
0xc353, 0xc354, 0xc355, 0xc356, 0xc357, 0xc358, 0xc359, 0xc35a,  // Offset: 6e10 ~ 6e17
0xc35b, 0xc35c, 0xc35d, 0xc35e, 0xc35f, 0xc360, 0xc361, 0xc362,  // Offset: 6e18 ~ 6e1f
0xc363, 0xc364, 0xc365, 0xc366, 0xc367, 0xc368, 0xc369, 0xc36a,  // Offset: 6e20 ~ 6e27
0xc36b, 0xc36c, 0xc36d, 0xc36e, 0xc36f, 0xc370, 0xc371, 0xc372,  // Offset: 6e28 ~ 6e2f
0xc373, 0xc374, 0xc375, 0xc376, 0xc377, 0xc378, 0xc379, 0xc37a,  // Offset: 6e30 ~ 6e37
0xc37b, 0xc37c, 0xc37d, 0xc37e, 0xc37f, 0xc380, 0xc381, 0xc382,  // Offset: 6e38 ~ 6e3f
0xc383, 0xc384, 0xc385, 0xc386, 0xc387, 0xc388, 0xc389, 0xc38a,  // Offset: 6e40 ~ 6e47
0xc38b, 0xc38c, 0xc38d, 0xc38e, 0xc38f, 0xc390, 0xc391, 0xc392,  // Offset: 6e48 ~ 6e4f
0xc393, 0xc394, 0xc395, 0xc396, 0xc397, 0xc398, 0xc399, 0xc39a,  // Offset: 6e50 ~ 6e57
0xc39b, 0xc39c, 0xc39d, 0xc39e, 0xc39f, 0xc3a0, 0xc3a1, 0xc3a2,  // Offset: 6e58 ~ 6e5f
0xc3a3, 0xc3a4, 0xc3a5, 0xc3a6, 0xc3a7, 0xc3a8, 0xc3a9, 0xc3aa,  // Offset: 6e60 ~ 6e67
0xc3ab, 0xc3ac, 0xc3ad, 0xc3ae, 0xc3af, 0xc3b0, 0xc3b1, 0xc3b2,  // Offset: 6e68 ~ 6e6f
0xc3b3, 0xc3b4, 0xc3b5, 0xc3b6, 0xc3b7, 0xc3b8, 0xc3b9, 0xc3ba,  // Offset: 6e70 ~ 6e77
0xc3bb, 0xc3bc, 0xc3bd, 0xc3be, 0xc3bf, 0xc3c0, 0xc3c1, 0xc3c2,  // Offset: 6e78 ~ 6e7f
0xc3c3, 0xc3c4, 0xc3c5, 0xc3c6, 0xc3c7, 0xc3c8, 0xc3c9, 0xc3ca,  // Offset: 6e80 ~ 6e87
0xc3cb, 0xc3cc, 0xc3cd, 0xc3ce, 0xc3cf, 0xc3d0, 0xc3d1, 0xc3d2,  // Offset: 6e88 ~ 6e8f
0xc3d3, 0xc3d4, 0xc3d5, 0xc3d6, 0xc3d7, 0xc3d8, 0xc3d9, 0xc3da,  // Offset: 6e90 ~ 6e97
0xc3db, 0xc3dc, 0xc3dd, 0xc3de, 0xc3df, 0xc3e0, 0xc3e1, 0xc3e2,  // Offset: 6e98 ~ 6e9f
0xc3e3, 0xc3e4, 0xc3e5, 0xc3e6, 0xc3e7, 0xc3e8, 0xc3e9, 0xc3ea,  // Offset: 6ea0 ~ 6ea7
0xc3eb, 0xc3ec, 0xc3ed, 0xc3ee, 0xc3ef, 0xc3f0, 0xc3f1, 0xc3f2,  // Offset: 6ea8 ~ 6eaf
0xc3f3, 0xc3f4, 0xc3f5, 0xc3f6, 0xc3f7, 0xc3f8, 0xc3f9, 0xc3fa,  // Offset: 6eb0 ~ 6eb7
0xc3fb, 0xc3fc, 0xc3fd, 0xc3fe, 0xc3ff, 0xc400, 0xc401, 0xc402,  // Offset: 6eb8 ~ 6ebf
0xc403, 0xc404, 0xc405, 0xc406, 0xc407, 0xc408, 0xc409, 0xc40a,  // Offset: 6ec0 ~ 6ec7
0xc40b, 0xc40c, 0xc40d, 0xc40e, 0xc40f, 0xc410, 0xc411, 0xc412,  // Offset: 6ec8 ~ 6ecf
0xc413, 0xc414, 0xc415, 0xc416, 0xc417, 0xc418, 0xc419, 0xc41a,  // Offset: 6ed0 ~ 6ed7
0xc41b, 0xc41c, 0xc41d, 0xc41e, 0xc41f, 0xc420, 0xc421, 0xc422,  // Offset: 6ed8 ~ 6edf
0xc423, 0xc424, 0xc425, 0xc426, 0xc427, 0xc428, 0xc429, 0xc42a,  // Offset: 6ee0 ~ 6ee7
0xc42b, 0xc42c, 0xc42d, 0xc42e, 0xc42f, 0xc430, 0xc431, 0xc432,  // Offset: 6ee8 ~ 6eef
0xc433, 0xc434, 0xc435, 0xc436, 0xc437, 0xc438, 0xc439, 0xc43a,  // Offset: 6ef0 ~ 6ef7
0xc43b, 0xc43c, 0xc43d, 0xc43e, 0xc43f, 0xc440, 0xc441, 0xc442,  // Offset: 6ef8 ~ 6eff
0xc443, 0xc444, 0xc445, 0xc446, 0xc447, 0xc448, 0xc449, 0xc44a,  // Offset: 6f00 ~ 6f07
0xc44b, 0xc44c, 0xc44d, 0xc44e, 0xc44f, 0xc450, 0xc451, 0xc452,  // Offset: 6f08 ~ 6f0f
0xc453, 0xc454, 0xc455, 0xc456, 0xc457, 0xc458, 0xc459, 0xc45a,  // Offset: 6f10 ~ 6f17
0xc45b, 0xc45c, 0xc45d, 0xc45e, 0xc45f, 0xc460, 0xc461, 0xc462,  // Offset: 6f18 ~ 6f1f
0xc463, 0xc464, 0xc465, 0xc466, 0xc467, 0xc468, 0xc469, 0xc46a,  // Offset: 6f20 ~ 6f27
0xc46b, 0xc46c, 0xc46d, 0xc46e, 0xc46f, 0xc470, 0xc471, 0xc472,  // Offset: 6f28 ~ 6f2f
0xc473, 0xc474, 0xc475, 0xc476, 0xc477, 0xc478, 0xc479, 0xc47a,  // Offset: 6f30 ~ 6f37
0xc47b, 0xc47c, 0xc47d, 0xc47e, 0xc47f, 0xc480, 0xc481, 0xc482,  // Offset: 6f38 ~ 6f3f
0xc483, 0xc484, 0xc485, 0xc486, 0xc487, 0xc488, 0xc489, 0xc48a,  // Offset: 6f40 ~ 6f47
0xc48b, 0xc48c, 0xc48d, 0xc48e, 0xc48f, 0xc490, 0xc491, 0xc492,  // Offset: 6f48 ~ 6f4f
0xc493, 0xc494, 0xc495, 0xc496, 0xc497, 0xc498, 0xc499, 0xc49a,  // Offset: 6f50 ~ 6f57
0xc49b, 0xc49c, 0xc49d, 0xc49e, 0xc49f, 0xc4a0, 0xc4a1, 0xc4a2,  // Offset: 6f58 ~ 6f5f
0xc4a3, 0xc4a4, 0xc4a5, 0xc4a6, 0xc4a7, 0xc4a8, 0xc4a9, 0xc4aa,  // Offset: 6f60 ~ 6f67
0xc4ab, 0xc4ac, 0xc4ad, 0xc4ae, 0xc4af, 0xc4b0, 0xc4b1, 0xc4b2,  // Offset: 6f68 ~ 6f6f
0xc4b3, 0xc4b4, 0xc4b5, 0xc4b6, 0xc4b7, 0xc4b8, 0xc4b9, 0xc4ba,  // Offset: 6f70 ~ 6f77
0xc4bb, 0xc4bc, 0xc4bd, 0xc4be, 0xc4bf, 0xc4c0, 0xc4c1, 0xc4c2,  // Offset: 6f78 ~ 6f7f
0xc4c3, 0xc4c4, 0xc4c5, 0xc4c6, 0xc4c7, 0xc4c8, 0xc4c9, 0xc4ca,  // Offset: 6f80 ~ 6f87
0xc4cb, 0xc4cc, 0xc4cd, 0xc4ce, 0xc4cf, 0xc4d0, 0xc4d1, 0xc4d2,  // Offset: 6f88 ~ 6f8f
0xc4d3, 0xc4d4, 0xc4d5, 0xc4d6, 0xc4d7, 0xc4d8, 0xc4d9, 0xc4da,  // Offset: 6f90 ~ 6f97
0xc4db, 0xc4dc, 0xc4dd, 0xc4de, 0xc4df, 0xc4e0, 0xc4e1, 0xc4e2,  // Offset: 6f98 ~ 6f9f
0xc4e3, 0xc4e4, 0xc4e5, 0xc4e6, 0xc4e7, 0xc4e8, 0xc4e9, 0xc4ea,  // Offset: 6fa0 ~ 6fa7
0xc4eb, 0xc4ec, 0xc4ed, 0xc4ee, 0xc4ef, 0xc4f0, 0xc4f1, 0xc4f2,  // Offset: 6fa8 ~ 6faf
0xc4f3, 0xc4f4, 0xc4f5, 0xc4f6, 0xc4f7, 0xc4f8, 0xc4f9, 0xc4fa,  // Offset: 6fb0 ~ 6fb7
0xc4fb, 0xc4fc, 0xc4fd, 0xc4fe, 0xc4ff, 0xc500, 0xc501, 0xc502,  // Offset: 6fb8 ~ 6fbf
0xc503, 0xc504, 0xc505, 0xc506, 0xc507, 0xc508, 0xc509, 0xc50a,  // Offset: 6fc0 ~ 6fc7
0xc50b, 0xc50c, 0xc50d, 0xc50e, 0xc50f, 0xc510, 0xc511, 0xc512,  // Offset: 6fc8 ~ 6fcf
0xc513, 0xc514, 0xc515, 0xc516, 0xc517, 0xc518, 0xc519, 0xc51a,  // Offset: 6fd0 ~ 6fd7
0xc51b, 0xc51c, 0xc51d, 0xc51e, 0xc51f, 0xc520, 0xc521, 0xc522,  // Offset: 6fd8 ~ 6fdf
0xc523, 0xc524, 0xc525, 0xc526, 0xc527, 0xc528, 0xc529, 0xc52a,  // Offset: 6fe0 ~ 6fe7
0xc52b, 0xc52c, 0xc52d, 0xc52e, 0xc52f, 0xc530, 0xc531, 0xc532,  // Offset: 6fe8 ~ 6fef
0xc533, 0xc534, 0xc535, 0xc536, 0xc537, 0xc538, 0xc539, 0xc53a,  // Offset: 6ff0 ~ 6ff7
0xc53b, 0xc53c, 0xc53d, 0xc53e, 0xc53f, 0xc540, 0xc541, 0xc542,  // Offset: 6ff8 ~ 6fff
0xc543, 0xc544, 0xc545, 0xc546, 0xc547, 0xc548, 0xc549, 0xc54a,  // Offset: 7000 ~ 7007
0xc54b, 0xc54c, 0xc54d, 0xc54e, 0xc54f, 0xc550, 0xc551, 0xc552,  // Offset: 7008 ~ 700f
0xc553, 0xc554, 0xc555, 0xc556, 0xc557, 0xc558, 0xc559, 0xc55a,  // Offset: 7010 ~ 7017
0xc55b, 0xc55c, 0xc55d, 0xc55e, 0xc55f, 0xc560, 0xc561, 0xc562,  // Offset: 7018 ~ 701f
0xc563, 0xc564, 0xc565, 0xc566, 0xc567, 0xc568, 0xc569, 0xc56a,  // Offset: 7020 ~ 7027
0xc56b, 0xc56c, 0xc56d, 0xc56e, 0xc56f, 0xc570, 0xc571, 0xc572,  // Offset: 7028 ~ 702f
0xc573, 0xc574, 0xc575, 0xc576, 0xc577, 0xc578, 0xc579, 0xc57a,  // Offset: 7030 ~ 7037
0xc57b, 0xc57c, 0xc57d, 0xc57e, 0xc57f, 0xc580, 0xc581, 0xc582,  // Offset: 7038 ~ 703f
0xc583, 0xc584, 0xc585, 0xc586, 0xc587, 0xc588, 0xc589, 0xc58a,  // Offset: 7040 ~ 7047
0xc58b, 0xc58c, 0xc58d, 0xc58e, 0xc58f, 0xc590, 0xc591, 0xc592,  // Offset: 7048 ~ 704f
0xc593, 0xc594, 0xc595, 0xc596, 0xc597, 0xc598, 0xc599, 0xc59a,  // Offset: 7050 ~ 7057
0xc59b, 0xc59c, 0xc59d, 0xc59e, 0xc59f, 0xc5a0, 0xc5a1, 0xc5a2,  // Offset: 7058 ~ 705f
0xc5a3, 0xc5a4, 0xc5a5, 0xc5a6, 0xc5a7, 0xc5a8, 0xc5a9, 0xc5aa,  // Offset: 7060 ~ 7067
0xc5ab, 0xc5ac, 0xc5ad, 0xc5ae, 0xc5af, 0xc5b0, 0xc5b1, 0xc5b2,  // Offset: 7068 ~ 706f
0xc5b3, 0xc5b4, 0xc5b5, 0xc5b6, 0xc5b7, 0xc5b8, 0xc5b9, 0xc5ba,  // Offset: 7070 ~ 7077
0xc5bb, 0xc5bc, 0xc5bd, 0xc5be, 0xc5bf, 0xc5c0, 0xc5c1, 0xc5c2,  // Offset: 7078 ~ 707f
0xc5c3, 0xc5c4, 0xc5c5, 0xc5c6, 0xc5c7, 0xc5c8, 0xc5c9, 0xc5ca,  // Offset: 7080 ~ 7087
0xc5cb, 0xc5cc, 0xc5cd, 0xc5ce, 0xc5cf, 0xc5d0, 0xc5d1, 0xc5d2,  // Offset: 7088 ~ 708f
0xc5d3, 0xc5d4, 0xc5d5, 0xc5d6, 0xc5d7, 0xc5d8, 0xc5d9, 0xc5da,  // Offset: 7090 ~ 7097
0xc5db, 0xc5dc, 0xc5dd, 0xc5de, 0xc5df, 0xc5e0, 0xc5e1, 0xc5e2,  // Offset: 7098 ~ 709f
0xc5e3, 0xc5e4, 0xc5e5, 0xc5e6, 0xc5e7, 0xc5e8, 0xc5e9, 0xc5ea,  // Offset: 70a0 ~ 70a7
0xc5eb, 0xc5ec, 0xc5ed, 0xc5ee, 0xc5ef, 0xc5f0, 0xc5f1, 0xc5f2,  // Offset: 70a8 ~ 70af
0xc5f3, 0xc5f4, 0xc5f5, 0xc5f6, 0xc5f7, 0xc5f8, 0xc5f9, 0xc5fa,  // Offset: 70b0 ~ 70b7
0xc5fb, 0xc5fc, 0xc5fd, 0xc5fe, 0xc5ff, 0xc600, 0xc601, 0xc602,  // Offset: 70b8 ~ 70bf
0xc603, 0xc604, 0xc605, 0xc606, 0xc607, 0xc608, 0xc609, 0xc60a,  // Offset: 70c0 ~ 70c7
0xc60b, 0xc60c, 0xc60d, 0xc60e, 0xc60f, 0xc610, 0xc611, 0xc612,  // Offset: 70c8 ~ 70cf
0xc613, 0xc614, 0xc615, 0xc616, 0xc617, 0xc618, 0xc619, 0xc61a,  // Offset: 70d0 ~ 70d7
0xc61b, 0xc61c, 0xc61d, 0xc61e, 0xc61f, 0xc620, 0xc621, 0xc622,  // Offset: 70d8 ~ 70df
0xc623, 0xc624, 0xc625, 0xc626, 0xc627, 0xc628, 0xc629, 0xc62a,  // Offset: 70e0 ~ 70e7
0xc62b, 0xc62c, 0xc62d, 0xc62e, 0xc62f, 0xc630, 0xc631, 0xc632,  // Offset: 70e8 ~ 70ef
0xc633, 0xc634, 0xc635, 0xc636, 0xc637, 0xc638, 0xc639, 0xc63a,  // Offset: 70f0 ~ 70f7
0xc63b, 0xc63c, 0xc63d, 0xc63e, 0xc63f, 0xc640, 0xc641, 0xc642,  // Offset: 70f8 ~ 70ff
0xc643, 0xc644, 0xc645, 0xc646, 0xc647, 0xc648, 0xc649, 0xc64a,  // Offset: 7100 ~ 7107
0xc64b, 0xc64c, 0xc64d, 0xc64e, 0xc64f, 0xc650, 0xc651, 0xc652,  // Offset: 7108 ~ 710f
0xc653, 0xc654, 0xc655, 0xc656, 0xc657, 0xc658, 0xc659, 0xc65a,  // Offset: 7110 ~ 7117
0xc65b, 0xc65c, 0xc65d, 0xc65e, 0xc65f, 0xc660, 0xc661, 0xc662,  // Offset: 7118 ~ 711f
0xc663, 0xc664, 0xc665, 0xc666, 0xc667, 0xc668, 0xc669, 0xc66a,  // Offset: 7120 ~ 7127
0xc66b, 0xc66c, 0xc66d, 0xc66e, 0xc66f, 0xc670, 0xc671, 0xc672,  // Offset: 7128 ~ 712f
0xc673, 0xc674, 0xc675, 0xc676, 0xc677, 0xc678, 0xc679, 0xc67a,  // Offset: 7130 ~ 7137
0xc67b, 0xc67c, 0xc67d, 0xc67e, 0xc67f, 0xc680, 0xc681, 0xc682,  // Offset: 7138 ~ 713f
0xc683, 0xc684, 0xc685, 0xc686, 0xc687, 0xc688, 0xc689, 0xc68a,  // Offset: 7140 ~ 7147
0xc68b, 0xc68c, 0xc68d, 0xc68e, 0xc68f, 0xc690, 0xc691, 0xc692,  // Offset: 7148 ~ 714f
0xc693, 0xc694, 0xc695, 0xc696, 0xc697, 0xc698, 0xc699, 0xc69a,  // Offset: 7150 ~ 7157
0xc69b, 0xc69c, 0xc69d, 0xc69e, 0xc69f, 0xc6a0, 0xc6a1, 0xc6a2,  // Offset: 7158 ~ 715f
0xc6a3, 0xc6a4, 0xc6a5, 0xc6a6, 0xc6a7, 0xc6a8, 0xc6a9, 0xc6aa,  // Offset: 7160 ~ 7167
0xc6ab, 0xc6ac, 0xc6ad, 0xc6ae, 0xc6af, 0xc6b0, 0xc6b1, 0xc6b2,  // Offset: 7168 ~ 716f
0xc6b3, 0xc6b4, 0xc6b5, 0xc6b6, 0xc6b7, 0xc6b8, 0xc6b9, 0xc6ba,  // Offset: 7170 ~ 7177
0xc6bb, 0xc6bc, 0xc6bd, 0xc6be, 0xc6bf, 0xc6c0, 0xc6c1, 0xc6c2,  // Offset: 7178 ~ 717f
0xc6c3, 0xc6c4, 0xc6c5, 0xc6c6, 0xc6c7, 0xc6c8, 0xc6c9, 0xc6ca,  // Offset: 7180 ~ 7187
0xc6cb, 0xc6cc, 0xc6cd, 0xc6ce, 0xc6cf, 0xc6d0, 0xc6d1, 0xc6d2,  // Offset: 7188 ~ 718f
0xc6d3, 0xc6d4, 0xc6d5, 0xc6d6, 0xc6d7, 0xc6d8, 0xc6d9, 0xc6da,  // Offset: 7190 ~ 7197
0xc6db, 0xc6dc, 0xc6dd, 0xc6de, 0xc6df, 0xc6e0, 0xc6e1, 0xc6e2,  // Offset: 7198 ~ 719f
0xc6e3, 0xc6e4, 0xc6e5, 0xc6e6, 0xc6e7, 0xc6e8, 0xc6e9, 0xc6ea,  // Offset: 71a0 ~ 71a7
0xc6eb, 0xc6ec, 0xc6ed, 0xc6ee, 0xc6ef, 0xc6f0, 0xc6f1, 0xc6f2,  // Offset: 71a8 ~ 71af
0xc6f3, 0xc6f4, 0xc6f5, 0xc6f6, 0xc6f7, 0xc6f8, 0xc6f9, 0xc6fa,  // Offset: 71b0 ~ 71b7
0xc6fb, 0xc6fc, 0xc6fd, 0xc6fe, 0xc6ff, 0xc700, 0xc701, 0xc702,  // Offset: 71b8 ~ 71bf
0xc703, 0xc704, 0xc705, 0xc706, 0xc707, 0xc708, 0xc709, 0xc70a,  // Offset: 71c0 ~ 71c7
0xc70b, 0xc70c, 0xc70d, 0xc70e, 0xc70f, 0xc710, 0xc711, 0xc712,  // Offset: 71c8 ~ 71cf
0xc713, 0xc714, 0xc715, 0xc716, 0xc717, 0xc718, 0xc719, 0xc71a,  // Offset: 71d0 ~ 71d7
0xc71b, 0xc71c, 0xc71d, 0xc71e, 0xc71f, 0xc720, 0xc721, 0xc722,  // Offset: 71d8 ~ 71df
0xc723, 0xc724, 0xc725, 0xc726, 0xc727, 0xc728, 0xc729, 0xc72a,  // Offset: 71e0 ~ 71e7
0xc72b, 0xc72c, 0xc72d, 0xc72e, 0xc72f, 0xc730, 0xc731, 0xc732,  // Offset: 71e8 ~ 71ef
0xc733, 0xc734, 0xc735, 0xc736, 0xc737, 0xc738, 0xc739, 0xc73a,  // Offset: 71f0 ~ 71f7
0xc73b, 0xc73c, 0xc73d, 0xc73e, 0xc73f, 0xc740, 0xc741, 0xc742,  // Offset: 71f8 ~ 71ff
0xc743, 0xc744, 0xc745, 0xc746, 0xc747, 0xc748, 0xc749, 0xc74a,  // Offset: 7200 ~ 7207
0xc74b, 0xc74c, 0xc74d, 0xc74e, 0xc74f, 0xc750, 0xc751, 0xc752,  // Offset: 7208 ~ 720f
0xc753, 0xc754, 0xc755, 0xc756, 0xc757, 0xc758, 0xc759, 0xc75a,  // Offset: 7210 ~ 7217
0xc75b, 0xc75c, 0xc75d, 0xc75e, 0xc75f, 0xc760, 0xc761, 0xc762,  // Offset: 7218 ~ 721f
0xc763, 0xc764, 0xc765, 0xc766, 0xc767, 0xc768, 0xc769, 0xc76a,  // Offset: 7220 ~ 7227
0xc76b, 0xc76c, 0xc76d, 0xc76e, 0xc76f, 0xc770, 0xc771, 0xc772,  // Offset: 7228 ~ 722f
0xc773, 0xc774, 0xc775, 0xc776, 0xc777, 0xc778, 0xc779, 0xc77a,  // Offset: 7230 ~ 7237
0xc77b, 0xc77c, 0xc77d, 0xc77e, 0xc77f, 0xc780, 0xc781, 0xc782,  // Offset: 7238 ~ 723f
0xc783, 0xc784, 0xc785, 0xc786, 0xc787, 0xc788, 0xc789, 0xc78a,  // Offset: 7240 ~ 7247
0xc78b, 0xc78c, 0xc78d, 0xc78e, 0xc78f, 0xc790, 0xc791, 0xc792,  // Offset: 7248 ~ 724f
0xc793, 0xc794, 0xc795, 0xc796, 0xc797, 0xc798, 0xc799, 0xc79a,  // Offset: 7250 ~ 7257
0xc79b, 0xc79c, 0xc79d, 0xc79e, 0xc79f, 0xc7a0, 0xc7a1, 0xc7a2,  // Offset: 7258 ~ 725f
0xc7a3, 0xc7a4, 0xc7a5, 0xc7a6, 0xc7a7, 0xc7a8, 0xc7a9, 0xc7aa,  // Offset: 7260 ~ 7267
0xc7ab, 0xc7ac, 0xc7ad, 0xc7ae, 0xc7af, 0xc7b0, 0xc7b1, 0xc7b2,  // Offset: 7268 ~ 726f
0xc7b3, 0xc7b4, 0xc7b5, 0xc7b6, 0xc7b7, 0xc7b8, 0xc7b9, 0xc7ba,  // Offset: 7270 ~ 7277
0xc7bb, 0xc7bc, 0xc7bd, 0xc7be, 0xc7bf, 0xc7c0, 0xc7c1, 0xc7c2,  // Offset: 7278 ~ 727f
0xc7c3, 0xc7c4, 0xc7c5, 0xc7c6, 0xc7c7, 0xc7c8, 0xc7c9, 0xc7ca,  // Offset: 7280 ~ 7287
0xc7cb, 0xc7cc, 0xc7cd, 0xc7ce, 0xc7cf, 0xc7d0, 0xc7d1, 0xc7d2,  // Offset: 7288 ~ 728f
0xc7d3, 0xc7d4, 0xc7d5, 0xc7d6, 0xc7d7, 0xc7d8, 0xc7d9, 0xc7da,  // Offset: 7290 ~ 7297
0xc7db, 0xc7dc, 0xc7dd, 0xc7de, 0xc7df, 0xc7e0, 0xc7e1, 0xc7e2,  // Offset: 7298 ~ 729f
0xc7e3, 0xc7e4, 0xc7e5, 0xc7e6, 0xc7e7, 0xc7e8, 0xc7e9, 0xc7ea,  // Offset: 72a0 ~ 72a7
0xc7eb, 0xc7ec, 0xc7ed, 0xc7ee, 0xc7ef, 0xc7f0, 0xc7f1, 0xc7f2,  // Offset: 72a8 ~ 72af
0xc7f3, 0xc7f4, 0xc7f5, 0xc7f6, 0xc7f7, 0xc7f8, 0xc7f9, 0xc7fa,  // Offset: 72b0 ~ 72b7
0xc7fb, 0xc7fc, 0xc7fd, 0xc7fe, 0xc7ff, 0xc800, 0xc801, 0xc802,  // Offset: 72b8 ~ 72bf
0xc803, 0xc804, 0xc805, 0xc806, 0xc807, 0xc808, 0xc809, 0xc80a,  // Offset: 72c0 ~ 72c7
0xc80b, 0xc80c, 0xc80d, 0xc80e, 0xc80f, 0xc810, 0xc811, 0xc812,  // Offset: 72c8 ~ 72cf
0xc813, 0xc814, 0xc815, 0xc816, 0xc817, 0xc818, 0xc819, 0xc81a,  // Offset: 72d0 ~ 72d7
0xc81b, 0xc81c, 0xc81d, 0xc81e, 0xc81f, 0xc820, 0xc821, 0xc822,  // Offset: 72d8 ~ 72df
0xc823, 0xc824, 0xc825, 0xc826, 0xc827, 0xc828, 0xc829, 0xc82a,  // Offset: 72e0 ~ 72e7
0xc82b, 0xc82c, 0xc82d, 0xc82e, 0xc82f, 0xc830, 0xc831, 0xc832,  // Offset: 72e8 ~ 72ef
0xc833, 0xc834, 0xc835, 0xc836, 0xc837, 0xc838, 0xc839, 0xc83a,  // Offset: 72f0 ~ 72f7
0xc83b, 0xc83c, 0xc83d, 0xc83e, 0xc83f, 0xc840, 0xc841, 0xc842,  // Offset: 72f8 ~ 72ff
0xc843, 0xc844, 0xc845, 0xc846, 0xc847, 0xc848, 0xc849, 0xc84a,  // Offset: 7300 ~ 7307
0xc84b, 0xc84c, 0xc84d, 0xc84e, 0xc84f, 0xc850, 0xc851, 0xc852,  // Offset: 7308 ~ 730f
0xc853, 0xc854, 0xc855, 0xc856, 0xc857, 0xc858, 0xc859, 0xc85a,  // Offset: 7310 ~ 7317
0xc85b, 0xc85c, 0xc85d, 0xc85e, 0xc85f, 0xc860, 0xc861, 0xc862,  // Offset: 7318 ~ 731f
0xc863, 0xc864, 0xc865, 0xc866, 0xc867, 0xc868, 0xc869, 0xc86a,  // Offset: 7320 ~ 7327
0xc86b, 0xc86c, 0xc86d, 0xc86e, 0xc86f, 0xc870, 0xc871, 0xc872,  // Offset: 7328 ~ 732f
0xc873, 0xc874, 0xc875, 0xc876, 0xc877, 0xc878, 0xc879, 0xc87a,  // Offset: 7330 ~ 7337
0xc87b, 0xc87c, 0xc87d, 0xc87e, 0xc87f, 0xc880, 0xc881, 0xc882,  // Offset: 7338 ~ 733f
0xc883, 0xc884, 0xc885, 0xc886, 0xc887, 0xc888, 0xc889, 0xc88a,  // Offset: 7340 ~ 7347
0xc88b, 0xc88c, 0xc88d, 0xc88e, 0xc88f, 0xc890, 0xc891, 0xc892,  // Offset: 7348 ~ 734f
0xc893, 0xc894, 0xc895, 0xc896, 0xc897, 0xc898, 0xc899, 0xc89a,  // Offset: 7350 ~ 7357
0xc89b, 0xc89c, 0xc89d, 0xc89e, 0xc89f, 0xc8a0, 0xc8a1, 0xc8a2,  // Offset: 7358 ~ 735f
0xc8a3, 0xc8a4, 0xc8a5, 0xc8a6, 0xc8a7, 0xc8a8, 0xc8a9, 0xc8aa,  // Offset: 7360 ~ 7367
0xc8ab, 0xc8ac, 0xc8ad, 0xc8ae, 0xc8af, 0xc8b0, 0xc8b1, 0xc8b2,  // Offset: 7368 ~ 736f
0xc8b3, 0xc8b4, 0xc8b5, 0xc8b6, 0xc8b7, 0xc8b8, 0xc8b9, 0xc8ba,  // Offset: 7370 ~ 7377
0xc8bb, 0xc8bc, 0xc8bd, 0xc8be, 0xc8bf, 0xc8c0, 0xc8c1, 0xc8c2,  // Offset: 7378 ~ 737f
0xc8c3, 0xc8c4, 0xc8c5, 0xc8c6, 0xc8c7, 0xc8c8, 0xc8c9, 0xc8ca,  // Offset: 7380 ~ 7387
0xc8cb, 0xc8cc, 0xc8cd, 0xc8ce, 0xc8cf, 0xc8d0, 0xc8d1, 0xc8d2,  // Offset: 7388 ~ 738f
0xc8d3, 0xc8d4, 0xc8d5, 0xc8d6, 0xc8d7, 0xc8d8, 0xc8d9, 0xc8da,  // Offset: 7390 ~ 7397
0xc8db, 0xc8dc, 0xc8dd, 0xc8de, 0xc8df, 0xc8e0, 0xc8e1, 0xc8e2,  // Offset: 7398 ~ 739f
0xc8e3, 0xc8e4, 0xc8e5, 0xc8e6, 0xc8e7, 0xc8e8, 0xc8e9, 0xc8ea,  // Offset: 73a0 ~ 73a7
0xc8eb, 0xc8ec, 0xc8ed, 0xc8ee, 0xc8ef, 0xc8f0, 0xc8f1, 0xc8f2,  // Offset: 73a8 ~ 73af
0xc8f3, 0xc8f4, 0xc8f5, 0xc8f6, 0xc8f7, 0xc8f8, 0xc8f9, 0xc8fa,  // Offset: 73b0 ~ 73b7
0xc8fb, 0xc8fc, 0xc8fd, 0xc8fe, 0xc8ff, 0xc900, 0xc901, 0xc902,  // Offset: 73b8 ~ 73bf
0xc903, 0xc904, 0xc905, 0xc906, 0xc907, 0xc908, 0xc909, 0xc90a,  // Offset: 73c0 ~ 73c7
0xc90b, 0xc90c, 0xc90d, 0xc90e, 0xc90f, 0xc910, 0xc911, 0xc912,  // Offset: 73c8 ~ 73cf
0xc913, 0xc914, 0xc915, 0xc916, 0xc917, 0xc918, 0xc919, 0xc91a,  // Offset: 73d0 ~ 73d7
0xc91b, 0xc91c, 0xc91d, 0xc91e, 0xc91f, 0xc920, 0xc921, 0xc922,  // Offset: 73d8 ~ 73df
0xc923, 0xc924, 0xc925, 0xc926, 0xc927, 0xc928, 0xc929, 0xc92a,  // Offset: 73e0 ~ 73e7
0xc92b, 0xc92c, 0xc92d, 0xc92e, 0xc92f, 0xc930, 0xc931, 0xc932,  // Offset: 73e8 ~ 73ef
0xc933, 0xc934, 0xc935, 0xc936, 0xc937, 0xc938, 0xc939, 0xc93a,  // Offset: 73f0 ~ 73f7
0xc93b, 0xc93c, 0xc93d, 0xc93e, 0xc93f, 0xc940, 0xc941, 0xc942,  // Offset: 73f8 ~ 73ff
0xc943, 0xc944, 0xc945, 0xc946, 0xc947, 0xc948, 0xc949, 0xc94a,  // Offset: 7400 ~ 7407
0xc94b, 0xc94c, 0xc94d, 0xc94e, 0xc94f, 0xc950, 0xc951, 0xc952,  // Offset: 7408 ~ 740f
0xc953, 0xc954, 0xc955, 0xc956, 0xc957, 0xc958, 0xc959, 0xc95a,  // Offset: 7410 ~ 7417
0xc95b, 0xc95c, 0xc95d, 0xc95e, 0xc95f, 0xc960, 0xc961, 0xc962,  // Offset: 7418 ~ 741f
0xc963, 0xc964, 0xc965, 0xc966, 0xc967, 0xc968, 0xc969, 0xc96a,  // Offset: 7420 ~ 7427
0xc96b, 0xc96c, 0xc96d, 0xc96e, 0xc96f, 0xc970, 0xc971, 0xc972,  // Offset: 7428 ~ 742f
0xc973, 0xc974, 0xc975, 0xc976, 0xc977, 0xc978, 0xc979, 0xc97a,  // Offset: 7430 ~ 7437
0xc97b, 0xc97c, 0xc97d, 0xc97e, 0xc97f, 0xc980, 0xc981, 0xc982,  // Offset: 7438 ~ 743f
0xc983, 0xc984, 0xc985, 0xc986, 0xc987, 0xc988, 0xc989, 0xc98a,  // Offset: 7440 ~ 7447
0xc98b, 0xc98c, 0xc98d, 0xc98e, 0xc98f, 0xc990, 0xc991, 0xc992,  // Offset: 7448 ~ 744f
0xc993, 0xc994, 0xc995, 0xc996, 0xc997, 0xc998, 0xc999, 0xc99a,  // Offset: 7450 ~ 7457
0xc99b, 0xc99c, 0xc99d, 0xc99e, 0xc99f, 0xc9a0, 0xc9a1, 0xc9a2,  // Offset: 7458 ~ 745f
0xc9a3, 0xc9a4, 0xc9a5, 0xc9a6, 0xc9a7, 0xc9a8, 0xc9a9, 0xc9aa,  // Offset: 7460 ~ 7467
0xc9ab, 0xc9ac, 0xc9ad, 0xc9ae, 0xc9af, 0xc9b0, 0xc9b1, 0xc9b2,  // Offset: 7468 ~ 746f
0xc9b3, 0xc9b4, 0xc9b5, 0xc9b6, 0xc9b7, 0xc9b8, 0xc9b9, 0xc9ba,  // Offset: 7470 ~ 7477
0xc9bb, 0xc9bc, 0xc9bd, 0xc9be, 0xc9bf, 0xc9c0, 0xc9c1, 0xc9c2,  // Offset: 7478 ~ 747f
0xc9c3, 0xc9c4, 0xc9c5, 0xc9c6, 0xc9c7, 0xc9c8, 0xc9c9, 0xc9ca,  // Offset: 7480 ~ 7487
0xc9cb, 0xc9cc, 0xc9cd, 0xc9ce, 0xc9cf, 0xc9d0, 0xc9d1, 0xc9d2,  // Offset: 7488 ~ 748f
0xc9d3, 0xc9d4, 0xc9d5, 0xc9d6, 0xc9d7, 0xc9d8, 0xc9d9, 0xc9da,  // Offset: 7490 ~ 7497
0xc9db, 0xc9dc, 0xc9dd, 0xc9de, 0xc9df, 0xc9e0, 0xc9e1, 0xc9e2,  // Offset: 7498 ~ 749f
0xc9e3, 0xc9e4, 0xc9e5, 0xc9e6, 0xc9e7, 0xc9e8, 0xc9e9, 0xc9ea,  // Offset: 74a0 ~ 74a7
0xc9eb, 0xc9ec, 0xc9ed, 0xc9ee, 0xc9ef, 0xc9f0, 0xc9f1, 0xc9f2,  // Offset: 74a8 ~ 74af
0xc9f3, 0xc9f4, 0xc9f5, 0xc9f6, 0xc9f7, 0xc9f8, 0xc9f9, 0xc9fa,  // Offset: 74b0 ~ 74b7
0xc9fb, 0xc9fc, 0xc9fd, 0xc9fe, 0xc9ff, 0xca00, 0xca01, 0xca02,  // Offset: 74b8 ~ 74bf
0xca03, 0xca04, 0xca05, 0xca06, 0xca07, 0xca08, 0xca09, 0xca0a,  // Offset: 74c0 ~ 74c7
0xca0b, 0xca0c, 0xca0d, 0xca0e, 0xca0f, 0xca10, 0xca11, 0xca12,  // Offset: 74c8 ~ 74cf
0xca13, 0xca14, 0xca15, 0xca16, 0xca17, 0xca18, 0xca19, 0xca1a,  // Offset: 74d0 ~ 74d7
0xca1b, 0xca1c, 0xca1d, 0xca1e, 0xca1f, 0xca20, 0xca21, 0xca22,  // Offset: 74d8 ~ 74df
0xca23, 0xca24, 0xca25, 0xca26, 0xca27, 0xca28, 0xca29, 0xca2a,  // Offset: 74e0 ~ 74e7
0xca2b, 0xca2c, 0xca2d, 0xca2e, 0xca2f, 0xca30, 0xca31, 0xca32,  // Offset: 74e8 ~ 74ef
0xca33, 0xca34, 0xca35, 0xca36, 0xca37, 0xca38, 0xca39, 0xca3a,  // Offset: 74f0 ~ 74f7
0xca3b, 0xca3c, 0xca3d, 0xca3e, 0xca3f, 0xca40, 0xca41, 0xca42,  // Offset: 74f8 ~ 74ff
0xca43, 0xca44, 0xca45, 0xca46, 0xca47, 0xca48, 0xca49, 0xca4a,  // Offset: 7500 ~ 7507
0xca4b, 0xca4c, 0xca4d, 0xca4e, 0xca4f, 0xca50, 0xca51, 0xca52,  // Offset: 7508 ~ 750f
0xca53, 0xca54, 0xca55, 0xca56, 0xca57, 0xca58, 0xca59, 0xca5a,  // Offset: 7510 ~ 7517
0xca5b, 0xca5c, 0xca5d, 0xca5e, 0xca5f, 0xca60, 0xca61, 0xca62,  // Offset: 7518 ~ 751f
0xca63, 0xca64, 0xca65, 0xca66, 0xca67, 0xca68, 0xca69, 0xca6a,  // Offset: 7520 ~ 7527
0xca6b, 0xca6c, 0xca6d, 0xca6e, 0xca6f, 0xca70, 0xca71, 0xca72,  // Offset: 7528 ~ 752f
0xca73, 0xca74, 0xca75, 0xca76, 0xca77, 0xca78, 0xca79, 0xca7a,  // Offset: 7530 ~ 7537
0xca7b, 0xca7c, 0xca7d, 0xca7e, 0xca7f, 0xca80, 0xca81, 0xca82,  // Offset: 7538 ~ 753f
0xca83, 0xca84, 0xca85, 0xca86, 0xca87, 0xca88, 0xca89, 0xca8a,  // Offset: 7540 ~ 7547
0xca8b, 0xca8c, 0xca8d, 0xca8e, 0xca8f, 0xca90, 0xca91, 0xca92,  // Offset: 7548 ~ 754f
0xca93, 0xca94, 0xca95, 0xca96, 0xca97, 0xca98, 0xca99, 0xca9a,  // Offset: 7550 ~ 7557
0xca9b, 0xca9c, 0xca9d, 0xca9e, 0xca9f, 0xcaa0, 0xcaa1, 0xcaa2,  // Offset: 7558 ~ 755f
0xcaa3, 0xcaa4, 0xcaa5, 0xcaa6, 0xcaa7, 0xcaa8, 0xcaa9, 0xcaaa,  // Offset: 7560 ~ 7567
0xcaab, 0xcaac, 0xcaad, 0xcaae, 0xcaaf, 0xcab0, 0xcab1, 0xcab2,  // Offset: 7568 ~ 756f
0xcab3, 0xcab4, 0xcab5, 0xcab6, 0xcab7, 0xcab8, 0xcab9, 0xcaba,  // Offset: 7570 ~ 7577
0xcabb, 0xcabc, 0xcabd, 0xcabe, 0xcabf, 0xcac0, 0xcac1, 0xcac2,  // Offset: 7578 ~ 757f
0xcac3, 0xcac4, 0xcac5, 0xcac6, 0xcac7, 0xcac8, 0xcac9, 0xcaca,  // Offset: 7580 ~ 7587
0xcacb, 0xcacc, 0xcacd, 0xcace, 0xcacf, 0xcad0, 0xcad1, 0xcad2,  // Offset: 7588 ~ 758f
0xcad3, 0xcad4, 0xcad5, 0xcad6, 0xcad7, 0xcad8, 0xcad9, 0xcada,  // Offset: 7590 ~ 7597
0xcadb, 0xcadc, 0xcadd, 0xcade, 0xcadf, 0xcae0, 0xcae1, 0xcae2,  // Offset: 7598 ~ 759f
0xcae3, 0xcae4, 0xcae5, 0xcae6, 0xcae7, 0xcae8, 0xcae9, 0xcaea,  // Offset: 75a0 ~ 75a7
0xcaeb, 0xcaec, 0xcaed, 0xcaee, 0xcaef, 0xcaf0, 0xcaf1, 0xcaf2,  // Offset: 75a8 ~ 75af
0xcaf3, 0xcaf4, 0xcaf5, 0xcaf6, 0xcaf7, 0xcaf8, 0xcaf9, 0xcafa,  // Offset: 75b0 ~ 75b7
0xcafb, 0xcafc, 0xcafd, 0xcafe, 0xcaff, 0xcb00, 0xcb01, 0xcb02,  // Offset: 75b8 ~ 75bf
0xcb03, 0xcb04, 0xcb05, 0xcb06, 0xcb07, 0xcb08, 0xcb09, 0xcb0a,  // Offset: 75c0 ~ 75c7
0xcb0b, 0xcb0c, 0xcb0d, 0xcb0e, 0xcb0f, 0xcb10, 0xcb11, 0xcb12,  // Offset: 75c8 ~ 75cf
0xcb13, 0xcb14, 0xcb15, 0xcb16, 0xcb17, 0xcb18, 0xcb19, 0xcb1a,  // Offset: 75d0 ~ 75d7
0xcb1b, 0xcb1c, 0xcb1d, 0xcb1e, 0xcb1f, 0xcb20, 0xcb21, 0xcb22,  // Offset: 75d8 ~ 75df
0xcb23, 0xcb24, 0xcb25, 0xcb26, 0xcb27, 0xcb28, 0xcb29, 0xcb2a,  // Offset: 75e0 ~ 75e7
0xcb2b, 0xcb2c, 0xcb2d, 0xcb2e, 0xcb2f, 0xcb30, 0xcb31, 0xcb32,  // Offset: 75e8 ~ 75ef
0xcb33, 0xcb34, 0xcb35, 0xcb36, 0xcb37, 0xcb38, 0xcb39, 0xcb3a,  // Offset: 75f0 ~ 75f7
0xcb3b, 0xcb3c, 0xcb3d, 0xcb3e, 0xcb3f, 0xcb40, 0xcb41, 0xcb42,  // Offset: 75f8 ~ 75ff
0xcb43, 0xcb44, 0xcb45, 0xcb46, 0xcb47, 0xcb48, 0xcb49, 0xcb4a,  // Offset: 7600 ~ 7607
0xcb4b, 0xcb4c, 0xcb4d, 0xcb4e, 0xcb4f, 0xcb50, 0xcb51, 0xcb52,  // Offset: 7608 ~ 760f
0xcb53, 0xcb54, 0xcb55, 0xcb56, 0xcb57, 0xcb58, 0xcb59, 0xcb5a,  // Offset: 7610 ~ 7617
0xcb5b, 0xcb5c, 0xcb5d, 0xcb5e, 0xcb5f, 0xcb60, 0xcb61, 0xcb62,  // Offset: 7618 ~ 761f
0xcb63, 0xcb64, 0xcb65, 0xcb66, 0xcb67, 0xcb68, 0xcb69, 0xcb6a,  // Offset: 7620 ~ 7627
0xcb6b, 0xcb6c, 0xcb6d, 0xcb6e, 0xcb6f, 0xcb70, 0xcb71, 0xcb72,  // Offset: 7628 ~ 762f
0xcb73, 0xcb74, 0xcb75, 0xcb76, 0xcb77, 0xcb78, 0xcb79, 0xcb7a,  // Offset: 7630 ~ 7637
0xcb7b, 0xcb7c, 0xcb7d, 0xcb7e, 0xcb7f, 0xcb80, 0xcb81, 0xcb82,  // Offset: 7638 ~ 763f
0xcb83, 0xcb84, 0xcb85, 0xcb86, 0xcb87, 0xcb88, 0xcb89, 0xcb8a,  // Offset: 7640 ~ 7647
0xcb8b, 0xcb8c, 0xcb8d, 0xcb8e, 0xcb8f, 0xcb90, 0xcb91, 0xcb92,  // Offset: 7648 ~ 764f
0xcb93, 0xcb94, 0xcb95, 0xcb96, 0xcb97, 0xcb98, 0xcb99, 0xcb9a,  // Offset: 7650 ~ 7657
0xcb9b, 0xcb9c, 0xcb9d, 0xcb9e, 0xcb9f, 0xcba0, 0xcba1, 0xcba2,  // Offset: 7658 ~ 765f
0xcba3, 0xcba4, 0xcba5, 0xcba6, 0xcba7, 0xcba8, 0xcba9, 0xcbaa,  // Offset: 7660 ~ 7667
0xcbab, 0xcbac, 0xcbad, 0xcbae, 0xcbaf, 0xcbb0, 0xcbb1, 0xcbb2,  // Offset: 7668 ~ 766f
0xcbb3, 0xcbb4, 0xcbb5, 0xcbb6, 0xcbb7, 0xcbb8, 0xcbb9, 0xcbba,  // Offset: 7670 ~ 7677
0xcbbb, 0xcbbc, 0xcbbd, 0xcbbe, 0xcbbf, 0xcbc0, 0xcbc1, 0xcbc2,  // Offset: 7678 ~ 767f
0xcbc3, 0xcbc4, 0xcbc5, 0xcbc6, 0xcbc7, 0xcbc8, 0xcbc9, 0xcbca,  // Offset: 7680 ~ 7687
0xcbcb, 0xcbcc, 0xcbcd, 0xcbce, 0xcbcf, 0xcbd0, 0xcbd1, 0xcbd2,  // Offset: 7688 ~ 768f
0xcbd3, 0xcbd4, 0xcbd5, 0xcbd6, 0xcbd7, 0xcbd8, 0xcbd9, 0xcbda,  // Offset: 7690 ~ 7697
0xcbdb, 0xcbdc, 0xcbdd, 0xcbde, 0xcbdf, 0xcbe0, 0xcbe1, 0xcbe2,  // Offset: 7698 ~ 769f
0xcbe3, 0xcbe4, 0xcbe5, 0xcbe6, 0xcbe7, 0xcbe8, 0xcbe9, 0xcbea,  // Offset: 76a0 ~ 76a7
0xcbeb, 0xcbec, 0xcbed, 0xcbee, 0xcbef, 0xcbf0, 0xcbf1, 0xcbf2,  // Offset: 76a8 ~ 76af
0xcbf3, 0xcbf4, 0xcbf5, 0xcbf6, 0xcbf7, 0xcbf8, 0xcbf9, 0xcbfa,  // Offset: 76b0 ~ 76b7
0xcbfb, 0xcbfc, 0xcbfd, 0xcbfe, 0xcbff, 0xcc00, 0xcc01, 0xcc02,  // Offset: 76b8 ~ 76bf
0xcc03, 0xcc04, 0xcc05, 0xcc06, 0xcc07, 0xcc08, 0xcc09, 0xcc0a,  // Offset: 76c0 ~ 76c7
0xcc0b, 0xcc0c, 0xcc0d, 0xcc0e, 0xcc0f, 0xcc10, 0xcc11, 0xcc12,  // Offset: 76c8 ~ 76cf
0xcc13, 0xcc14, 0xcc15, 0xcc16, 0xcc17, 0xcc18, 0xcc19, 0xcc1a,  // Offset: 76d0 ~ 76d7
0xcc1b, 0xcc1c, 0xcc1d, 0xcc1e, 0xcc1f, 0xcc20, 0xcc21, 0xcc22,  // Offset: 76d8 ~ 76df
0xcc23, 0xcc24, 0xcc25, 0xcc26, 0xcc27, 0xcc28, 0xcc29, 0xcc2a,  // Offset: 76e0 ~ 76e7
0xcc2b, 0xcc2c, 0xcc2d, 0xcc2e, 0xcc2f, 0xcc30, 0xcc31, 0xcc32,  // Offset: 76e8 ~ 76ef
0xcc33, 0xcc34, 0xcc35, 0xcc36, 0xcc37, 0xcc38, 0xcc39, 0xcc3a,  // Offset: 76f0 ~ 76f7
0xcc3b, 0xcc3c, 0xcc3d, 0xcc3e, 0xcc3f, 0xcc40, 0xcc41, 0xcc42,  // Offset: 76f8 ~ 76ff
0xcc43, 0xcc44, 0xcc45, 0xcc46, 0xcc47, 0xcc48, 0xcc49, 0xcc4a,  // Offset: 7700 ~ 7707
0xcc4b, 0xcc4c, 0xcc4d, 0xcc4e, 0xcc4f, 0xcc50, 0xcc51, 0xcc52,  // Offset: 7708 ~ 770f
0xcc53, 0xcc54, 0xcc55, 0xcc56, 0xcc57, 0xcc58, 0xcc59, 0xcc5a,  // Offset: 7710 ~ 7717
0xcc5b, 0xcc5c, 0xcc5d, 0xcc5e, 0xcc5f, 0xcc60, 0xcc61, 0xcc62,  // Offset: 7718 ~ 771f
0xcc63, 0xcc64, 0xcc65, 0xcc66, 0xcc67, 0xcc68, 0xcc69, 0xcc6a,  // Offset: 7720 ~ 7727
0xcc6b, 0xcc6c, 0xcc6d, 0xcc6e, 0xcc6f, 0xcc70, 0xcc71, 0xcc72,  // Offset: 7728 ~ 772f
0xcc73, 0xcc74, 0xcc75, 0xcc76, 0xcc77, 0xcc78, 0xcc79, 0xcc7a,  // Offset: 7730 ~ 7737
0xcc7b, 0xcc7c, 0xcc7d, 0xcc7e, 0xcc7f, 0xcc80, 0xcc81, 0xcc82,  // Offset: 7738 ~ 773f
0xcc83, 0xcc84, 0xcc85, 0xcc86, 0xcc87, 0xcc88, 0xcc89, 0xcc8a,  // Offset: 7740 ~ 7747
0xcc8b, 0xcc8c, 0xcc8d, 0xcc8e, 0xcc8f, 0xcc90, 0xcc91, 0xcc92,  // Offset: 7748 ~ 774f
0xcc93, 0xcc94, 0xcc95, 0xcc96, 0xcc97, 0xcc98, 0xcc99, 0xcc9a,  // Offset: 7750 ~ 7757
0xcc9b, 0xcc9c, 0xcc9d, 0xcc9e, 0xcc9f, 0xcca0, 0xcca1, 0xcca2,  // Offset: 7758 ~ 775f
0xcca3, 0xcca4, 0xcca5, 0xcca6, 0xcca7, 0xcca8, 0xcca9, 0xccaa,  // Offset: 7760 ~ 7767
0xccab, 0xccac, 0xccad, 0xccae, 0xccaf, 0xccb0, 0xccb1, 0xccb2,  // Offset: 7768 ~ 776f
0xccb3, 0xccb4, 0xccb5, 0xccb6, 0xccb7, 0xccb8, 0xccb9, 0xccba,  // Offset: 7770 ~ 7777
0xccbb, 0xccbc, 0xccbd, 0xccbe, 0xccbf, 0xccc0, 0xccc1, 0xccc2,  // Offset: 7778 ~ 777f
0xccc3, 0xccc4, 0xccc5, 0xccc6, 0xccc7, 0xccc8, 0xccc9, 0xccca,  // Offset: 7780 ~ 7787
0xcccb, 0xcccc, 0xcccd, 0xccce, 0xcccf, 0xccd0, 0xccd1, 0xccd2,  // Offset: 7788 ~ 778f
0xccd3, 0xccd4, 0xccd5, 0xccd6, 0xccd7, 0xccd8, 0xccd9, 0xccda,  // Offset: 7790 ~ 7797
0xccdb, 0xccdc, 0xccdd, 0xccde, 0xccdf, 0xcce0, 0xcce1, 0xcce2,  // Offset: 7798 ~ 779f
0xcce3, 0xcce4, 0xcce5, 0xcce6, 0xcce7, 0xcce8, 0xcce9, 0xccea,  // Offset: 77a0 ~ 77a7
0xcceb, 0xccec, 0xcced, 0xccee, 0xccef, 0xccf0, 0xccf1, 0xccf2,  // Offset: 77a8 ~ 77af
0xccf3, 0xccf4, 0xccf5, 0xccf6, 0xccf7, 0xccf8, 0xccf9, 0xccfa,  // Offset: 77b0 ~ 77b7
0xccfb, 0xccfc, 0xccfd, 0xccfe, 0xccff, 0xcd00, 0xcd01, 0xcd02,  // Offset: 77b8 ~ 77bf
0xcd03, 0xcd04, 0xcd05, 0xcd06, 0xcd07, 0xcd08, 0xcd09, 0xcd0a,  // Offset: 77c0 ~ 77c7
0xcd0b, 0xcd0c, 0xcd0d, 0xcd0e, 0xcd0f, 0xcd10, 0xcd11, 0xcd12,  // Offset: 77c8 ~ 77cf
0xcd13, 0xcd14, 0xcd15, 0xcd16, 0xcd17, 0xcd18, 0xcd19, 0xcd1a,  // Offset: 77d0 ~ 77d7
0xcd1b, 0xcd1c, 0xcd1d, 0xcd1e, 0xcd1f, 0xcd20, 0xcd21, 0xcd22,  // Offset: 77d8 ~ 77df
0xcd23, 0xcd24, 0xcd25, 0xcd26, 0xcd27, 0xcd28, 0xcd29, 0xcd2a,  // Offset: 77e0 ~ 77e7
0xcd2b, 0xcd2c, 0xcd2d, 0xcd2e, 0xcd2f, 0xcd30, 0xcd31, 0xcd32,  // Offset: 77e8 ~ 77ef
0xcd33, 0xcd34, 0xcd35, 0xcd36, 0xcd37, 0xcd38, 0xcd39, 0xcd3a,  // Offset: 77f0 ~ 77f7
0xcd3b, 0xcd3c, 0xcd3d, 0xcd3e, 0xcd3f, 0xcd40, 0xcd41, 0xcd42,  // Offset: 77f8 ~ 77ff
0xcd43, 0xcd44, 0xcd45, 0xcd46, 0xcd47, 0xcd48, 0xcd49, 0xcd4a,  // Offset: 7800 ~ 7807
0xcd4b, 0xcd4c, 0xcd4d, 0xcd4e, 0xcd4f, 0xcd50, 0xcd51, 0xcd52,  // Offset: 7808 ~ 780f
0xcd53, 0xcd54, 0xcd55, 0xcd56, 0xcd57, 0xcd58, 0xcd59, 0xcd5a,  // Offset: 7810 ~ 7817
0xcd5b, 0xcd5c, 0xcd5d, 0xcd5e, 0xcd5f, 0xcd60, 0xcd61, 0xcd62,  // Offset: 7818 ~ 781f
0xcd63, 0xcd64, 0xcd65, 0xcd66, 0xcd67, 0xcd68, 0xcd69, 0xcd6a,  // Offset: 7820 ~ 7827
0xcd6b, 0xcd6c, 0xcd6d, 0xcd6e, 0xcd6f, 0xcd70, 0xcd71, 0xcd72,  // Offset: 7828 ~ 782f
0xcd73, 0xcd74, 0xcd75, 0xcd76, 0xcd77, 0xcd78, 0xcd79, 0xcd7a,  // Offset: 7830 ~ 7837
0xcd7b, 0xcd7c, 0xcd7d, 0xcd7e, 0xcd7f, 0xcd80, 0xcd81, 0xcd82,  // Offset: 7838 ~ 783f
0xcd83, 0xcd84, 0xcd85, 0xcd86, 0xcd87, 0xcd88, 0xcd89, 0xcd8a,  // Offset: 7840 ~ 7847
0xcd8b, 0xcd8c, 0xcd8d, 0xcd8e, 0xcd8f, 0xcd90, 0xcd91, 0xcd92,  // Offset: 7848 ~ 784f
0xcd93, 0xcd94, 0xcd95, 0xcd96, 0xcd97, 0xcd98, 0xcd99, 0xcd9a,  // Offset: 7850 ~ 7857
0xcd9b, 0xcd9c, 0xcd9d, 0xcd9e, 0xcd9f, 0xcda0, 0xcda1, 0xcda2,  // Offset: 7858 ~ 785f
0xcda3, 0xcda4, 0xcda5, 0xcda6, 0xcda7, 0xcda8, 0xcda9, 0xcdaa,  // Offset: 7860 ~ 7867
0xcdab, 0xcdac, 0xcdad, 0xcdae, 0xcdaf, 0xcdb0, 0xcdb1, 0xcdb2,  // Offset: 7868 ~ 786f
0xcdb3, 0xcdb4, 0xcdb5, 0xcdb6, 0xcdb7, 0xcdb8, 0xcdb9, 0xcdba,  // Offset: 7870 ~ 7877
0xcdbb, 0xcdbc, 0xcdbd, 0xcdbe, 0xcdbf, 0xcdc0, 0xcdc1, 0xcdc2,  // Offset: 7878 ~ 787f
0xcdc3, 0xcdc4, 0xcdc5, 0xcdc6, 0xcdc7, 0xcdc8, 0xcdc9, 0xcdca,  // Offset: 7880 ~ 7887
0xcdcb, 0xcdcc, 0xcdcd, 0xcdce, 0xcdcf, 0xcdd0, 0xcdd1, 0xcdd2,  // Offset: 7888 ~ 788f
0xcdd3, 0xcdd4, 0xcdd5, 0xcdd6, 0xcdd7, 0xcdd8, 0xcdd9, 0xcdda,  // Offset: 7890 ~ 7897
0xcddb, 0xcddc, 0xcddd, 0xcdde, 0xcddf, 0xcde0, 0xcde1, 0xcde2,  // Offset: 7898 ~ 789f
0xcde3, 0xcde4, 0xcde5, 0xcde6, 0xcde7, 0xcde8, 0xcde9, 0xcdea,  // Offset: 78a0 ~ 78a7
0xcdeb, 0xcdec, 0xcded, 0xcdee, 0xcdef, 0xcdf0, 0xcdf1, 0xcdf2,  // Offset: 78a8 ~ 78af
0xcdf3, 0xcdf4, 0xcdf5, 0xcdf6, 0xcdf7, 0xcdf8, 0xcdf9, 0xcdfa,  // Offset: 78b0 ~ 78b7
0xcdfb, 0xcdfc, 0xcdfd, 0xcdfe, 0xcdff, 0xce00, 0xce01, 0xce02,  // Offset: 78b8 ~ 78bf
0xce03, 0xce04, 0xce05, 0xce06, 0xce07, 0xce08, 0xce09, 0xce0a,  // Offset: 78c0 ~ 78c7
0xce0b, 0xce0c, 0xce0d, 0xce0e, 0xce0f, 0xce10, 0xce11, 0xce12,  // Offset: 78c8 ~ 78cf
0xce13, 0xce14, 0xce15, 0xce16, 0xce17, 0xce18, 0xce19, 0xce1a,  // Offset: 78d0 ~ 78d7
0xce1b, 0xce1c, 0xce1d, 0xce1e, 0xce1f, 0xce20, 0xce21, 0xce22,  // Offset: 78d8 ~ 78df
0xce23, 0xce24, 0xce25, 0xce26, 0xce27, 0xce28, 0xce29, 0xce2a,  // Offset: 78e0 ~ 78e7
0xce2b, 0xce2c, 0xce2d, 0xce2e, 0xce2f, 0xce30, 0xce31, 0xce32,  // Offset: 78e8 ~ 78ef
0xce33, 0xce34, 0xce35, 0xce36, 0xce37, 0xce38, 0xce39, 0xce3a,  // Offset: 78f0 ~ 78f7
0xce3b, 0xce3c, 0xce3d, 0xce3e, 0xce3f, 0xce40, 0xce41, 0xce42,  // Offset: 78f8 ~ 78ff
0xce43, 0xce44, 0xce45, 0xce46, 0xce47, 0xce48, 0xce49, 0xce4a,  // Offset: 7900 ~ 7907
0xce4b, 0xce4c, 0xce4d, 0xce4e, 0xce4f, 0xce50, 0xce51, 0xce52,  // Offset: 7908 ~ 790f
0xce53, 0xce54, 0xce55, 0xce56, 0xce57, 0xce58, 0xce59, 0xce5a,  // Offset: 7910 ~ 7917
0xce5b, 0xce5c, 0xce5d, 0xce5e, 0xce5f, 0xce60, 0xce61, 0xce62,  // Offset: 7918 ~ 791f
0xce63, 0xce64, 0xce65, 0xce66, 0xce67, 0xce68, 0xce69, 0xce6a,  // Offset: 7920 ~ 7927
0xce6b, 0xce6c, 0xce6d, 0xce6e, 0xce6f, 0xce70, 0xce71, 0xce72,  // Offset: 7928 ~ 792f
0xce73, 0xce74, 0xce75, 0xce76, 0xce77, 0xce78, 0xce79, 0xce7a,  // Offset: 7930 ~ 7937
0xce7b, 0xce7c, 0xce7d, 0xce7e, 0xce7f, 0xce80, 0xce81, 0xce82,  // Offset: 7938 ~ 793f
0xce83, 0xce84, 0xce85, 0xce86, 0xce87, 0xce88, 0xce89, 0xce8a,  // Offset: 7940 ~ 7947
0xce8b, 0xce8c, 0xce8d, 0xce8e, 0xce8f, 0xce90, 0xce91, 0xce92,  // Offset: 7948 ~ 794f
0xce93, 0xce94, 0xce95, 0xce96, 0xce97, 0xce98, 0xce99, 0xce9a,  // Offset: 7950 ~ 7957
0xce9b, 0xce9c, 0xce9d, 0xce9e, 0xce9f, 0xcea0, 0xcea1, 0xcea2,  // Offset: 7958 ~ 795f
0xcea3, 0xcea4, 0xcea5, 0xcea6, 0xcea7, 0xcea8, 0xcea9, 0xceaa,  // Offset: 7960 ~ 7967
0xceab, 0xceac, 0xcead, 0xceae, 0xceaf, 0xceb0, 0xceb1, 0xceb2,  // Offset: 7968 ~ 796f
0xceb3, 0xceb4, 0xceb5, 0xceb6, 0xceb7, 0xceb8, 0xceb9, 0xceba,  // Offset: 7970 ~ 7977
0xcebb, 0xcebc, 0xcebd, 0xcebe, 0xcebf, 0xcec0, 0xcec1, 0xcec2,  // Offset: 7978 ~ 797f
0xcec3, 0xcec4, 0xcec5, 0xcec6, 0xcec7, 0xcec8, 0xcec9, 0xceca,  // Offset: 7980 ~ 7987
0xcecb, 0xcecc, 0xcecd, 0xcece, 0xcecf, 0xced0, 0xced1, 0xced2,  // Offset: 7988 ~ 798f
0xced3, 0xced4, 0xced5, 0xced6, 0xced7, 0xced8, 0xced9, 0xceda,  // Offset: 7990 ~ 7997
0xcedb, 0xcedc, 0xcedd, 0xcede, 0xcedf, 0xcee0, 0xcee1, 0xcee2,  // Offset: 7998 ~ 799f
0xcee3, 0xcee4, 0xcee5, 0xcee6, 0xcee7, 0xcee8, 0xcee9, 0xceea,  // Offset: 79a0 ~ 79a7
0xceeb, 0xceec, 0xceed, 0xceee, 0xceef, 0xcef0, 0xcef1, 0xcef2,  // Offset: 79a8 ~ 79af
0xcef3, 0xcef4, 0xcef5, 0xcef6, 0xcef7, 0xcef8, 0xcef9, 0xcefa,  // Offset: 79b0 ~ 79b7
0xcefb, 0xcefc, 0xcefd, 0xcefe, 0xceff, 0xcf00, 0xcf01, 0xcf02,  // Offset: 79b8 ~ 79bf
0xcf03, 0xcf04, 0xcf05, 0xcf06, 0xcf07, 0xcf08, 0xcf09, 0xcf0a,  // Offset: 79c0 ~ 79c7
0xcf0b, 0xcf0c, 0xcf0d, 0xcf0e, 0xcf0f, 0xcf10, 0xcf11, 0xcf12,  // Offset: 79c8 ~ 79cf
0xcf13, 0xcf14, 0xcf15, 0xcf16, 0xcf17, 0xcf18, 0xcf19, 0xcf1a,  // Offset: 79d0 ~ 79d7
0xcf1b, 0xcf1c, 0xcf1d, 0xcf1e, 0xcf1f, 0xcf20, 0xcf21, 0xcf22,  // Offset: 79d8 ~ 79df
0xcf23, 0xcf24, 0xcf25, 0xcf26, 0xcf27, 0xcf28, 0xcf29, 0xcf2a,  // Offset: 79e0 ~ 79e7
0xcf2b, 0xcf2c, 0xcf2d, 0xcf2e, 0xcf2f, 0xcf30, 0xcf31, 0xcf32,  // Offset: 79e8 ~ 79ef
0xcf33, 0xcf34, 0xcf35, 0xcf36, 0xcf37, 0xcf38, 0xcf39, 0xcf3a,  // Offset: 79f0 ~ 79f7
0xcf3b, 0xcf3c, 0xcf3d, 0xcf3e, 0xcf3f, 0xcf40, 0xcf41, 0xcf42,  // Offset: 79f8 ~ 79ff
0xcf43, 0xcf44, 0xcf45, 0xcf46, 0xcf47, 0xcf48, 0xcf49, 0xcf4a,  // Offset: 7a00 ~ 7a07
0xcf4b, 0xcf4c, 0xcf4d, 0xcf4e, 0xcf4f, 0xcf50, 0xcf51, 0xcf52,  // Offset: 7a08 ~ 7a0f
0xcf53, 0xcf54, 0xcf55, 0xcf56, 0xcf57, 0xcf58, 0xcf59, 0xcf5a,  // Offset: 7a10 ~ 7a17
0xcf5b, 0xcf5c, 0xcf5d, 0xcf5e, 0xcf5f, 0xcf60, 0xcf61, 0xcf62,  // Offset: 7a18 ~ 7a1f
0xcf63, 0xcf64, 0xcf65, 0xcf66, 0xcf67, 0xcf68, 0xcf69, 0xcf6a,  // Offset: 7a20 ~ 7a27
0xcf6b, 0xcf6c, 0xcf6d, 0xcf6e, 0xcf6f, 0xcf70, 0xcf71, 0xcf72,  // Offset: 7a28 ~ 7a2f
0xcf73, 0xcf74, 0xcf75, 0xcf76, 0xcf77, 0xcf78, 0xcf79, 0xcf7a,  // Offset: 7a30 ~ 7a37
0xcf7b, 0xcf7c, 0xcf7d, 0xcf7e, 0xcf7f, 0xcf80, 0xcf81, 0xcf82,  // Offset: 7a38 ~ 7a3f
0xcf83, 0xcf84, 0xcf85, 0xcf86, 0xcf87, 0xcf88, 0xcf89, 0xcf8a,  // Offset: 7a40 ~ 7a47
0xcf8b, 0xcf8c, 0xcf8d, 0xcf8e, 0xcf8f, 0xcf90, 0xcf91, 0xcf92,  // Offset: 7a48 ~ 7a4f
0xcf93, 0xcf94, 0xcf95, 0xcf96, 0xcf97, 0xcf98, 0xcf99, 0xcf9a,  // Offset: 7a50 ~ 7a57
0xcf9b, 0xcf9c, 0xcf9d, 0xcf9e, 0xcf9f, 0xcfa0, 0xcfa1, 0xcfa2,  // Offset: 7a58 ~ 7a5f
0xcfa3, 0xcfa4, 0xcfa5, 0xcfa6, 0xcfa7, 0xcfa8, 0xcfa9, 0xcfaa,  // Offset: 7a60 ~ 7a67
0xcfab, 0xcfac, 0xcfad, 0xcfae, 0xcfaf, 0xcfb0, 0xcfb1, 0xcfb2,  // Offset: 7a68 ~ 7a6f
0xcfb3, 0xcfb4, 0xcfb5, 0xcfb6, 0xcfb7, 0xcfb8, 0xcfb9, 0xcfba,  // Offset: 7a70 ~ 7a77
0xcfbb, 0xcfbc, 0xcfbd, 0xcfbe, 0xcfbf, 0xcfc0, 0xcfc1, 0xcfc2,  // Offset: 7a78 ~ 7a7f
0xcfc3, 0xcfc4, 0xcfc5, 0xcfc6, 0xcfc7, 0xcfc8, 0xcfc9, 0xcfca,  // Offset: 7a80 ~ 7a87
0xcfcb, 0xcfcc, 0xcfcd, 0xcfce, 0xcfcf, 0xcfd0, 0xcfd1, 0xcfd2,  // Offset: 7a88 ~ 7a8f
0xcfd3, 0xcfd4, 0xcfd5, 0xcfd6, 0xcfd7, 0xcfd8, 0xcfd9, 0xcfda,  // Offset: 7a90 ~ 7a97
0xcfdb, 0xcfdc, 0xcfdd, 0xcfde, 0xcfdf, 0xcfe0, 0xcfe1, 0xcfe2,  // Offset: 7a98 ~ 7a9f
0xcfe3, 0xcfe4, 0xcfe5, 0xcfe6, 0xcfe7, 0xcfe8, 0xcfe9, 0xcfea,  // Offset: 7aa0 ~ 7aa7
0xcfeb, 0xcfec, 0xcfed, 0xcfee, 0xcfef, 0xcff0, 0xcff1, 0xcff2,  // Offset: 7aa8 ~ 7aaf
0xcff3, 0xcff4, 0xcff5, 0xcff6, 0xcff7, 0xcff8, 0xcff9, 0xcffa,  // Offset: 7ab0 ~ 7ab7
0xcffb, 0xcffc, 0xcffd, 0xcffe, 0xcfff, 0xd000, 0xd001, 0xd002,  // Offset: 7ab8 ~ 7abf
0xd003, 0xd004, 0xd005, 0xd006, 0xd007, 0xd008, 0xd009, 0xd00a,  // Offset: 7ac0 ~ 7ac7
0xd00b, 0xd00c, 0xd00d, 0xd00e, 0xd00f, 0xd010, 0xd011, 0xd012,  // Offset: 7ac8 ~ 7acf
0xd013, 0xd014, 0xd015, 0xd016, 0xd017, 0xd018, 0xd019, 0xd01a,  // Offset: 7ad0 ~ 7ad7
0xd01b, 0xd01c, 0xd01d, 0xd01e, 0xd01f, 0xd020, 0xd021, 0xd022,  // Offset: 7ad8 ~ 7adf
0xd023, 0xd024, 0xd025, 0xd026, 0xd027, 0xd028, 0xd029, 0xd02a,  // Offset: 7ae0 ~ 7ae7
0xd02b, 0xd02c, 0xd02d, 0xd02e, 0xd02f, 0xd030, 0xd031, 0xd032,  // Offset: 7ae8 ~ 7aef
0xd033, 0xd034, 0xd035, 0xd036, 0xd037, 0xd038, 0xd039, 0xd03a,  // Offset: 7af0 ~ 7af7
0xd03b, 0xd03c, 0xd03d, 0xd03e, 0xd03f, 0xd040, 0xd041, 0xd042,  // Offset: 7af8 ~ 7aff
0xd043, 0xd044, 0xd045, 0xd046, 0xd047, 0xd048, 0xd049, 0xd04a,  // Offset: 7b00 ~ 7b07
0xd04b, 0xd04c, 0xd04d, 0xd04e, 0xd04f, 0xd050, 0xd051, 0xd052,  // Offset: 7b08 ~ 7b0f
0xd053, 0xd054, 0xd055, 0xd056, 0xd057, 0xd058, 0xd059, 0xd05a,  // Offset: 7b10 ~ 7b17
0xd05b, 0xd05c, 0xd05d, 0xd05e, 0xd05f, 0xd060, 0xd061, 0xd062,  // Offset: 7b18 ~ 7b1f
0xd063, 0xd064, 0xd065, 0xd066, 0xd067, 0xd068, 0xd069, 0xd06a,  // Offset: 7b20 ~ 7b27
0xd06b, 0xd06c, 0xd06d, 0xd06e, 0xd06f, 0xd070, 0xd071, 0xd072,  // Offset: 7b28 ~ 7b2f
0xd073, 0xd074, 0xd075, 0xd076, 0xd077, 0xd078, 0xd079, 0xd07a,  // Offset: 7b30 ~ 7b37
0xd07b, 0xd07c, 0xd07d, 0xd07e, 0xd07f, 0xd080, 0xd081, 0xd082,  // Offset: 7b38 ~ 7b3f
0xd083, 0xd084, 0xd085, 0xd086, 0xd087, 0xd088, 0xd089, 0xd08a,  // Offset: 7b40 ~ 7b47
0xd08b, 0xd08c, 0xd08d, 0xd08e, 0xd08f, 0xd090, 0xd091, 0xd092,  // Offset: 7b48 ~ 7b4f
0xd093, 0xd094, 0xd095, 0xd096, 0xd097, 0xd098, 0xd099, 0xd09a,  // Offset: 7b50 ~ 7b57
0xd09b, 0xd09c, 0xd09d, 0xd09e, 0xd09f, 0xd0a0, 0xd0a1, 0xd0a2,  // Offset: 7b58 ~ 7b5f
0xd0a3, 0xd0a4, 0xd0a5, 0xd0a6, 0xd0a7, 0xd0a8, 0xd0a9, 0xd0aa,  // Offset: 7b60 ~ 7b67
0xd0ab, 0xd0ac, 0xd0ad, 0xd0ae, 0xd0af, 0xd0b0, 0xd0b1, 0xd0b2,  // Offset: 7b68 ~ 7b6f
0xd0b3, 0xd0b4, 0xd0b5, 0xd0b6, 0xd0b7, 0xd0b8, 0xd0b9, 0xd0ba,  // Offset: 7b70 ~ 7b77
0xd0bb, 0xd0bc, 0xd0bd, 0xd0be, 0xd0bf, 0xd0c0, 0xd0c1, 0xd0c2,  // Offset: 7b78 ~ 7b7f
0xd0c3, 0xd0c4, 0xd0c5, 0xd0c6, 0xd0c7, 0xd0c8, 0xd0c9, 0xd0ca,  // Offset: 7b80 ~ 7b87
0xd0cb, 0xd0cc, 0xd0cd, 0xd0ce, 0xd0cf, 0xd0d0, 0xd0d1, 0xd0d2,  // Offset: 7b88 ~ 7b8f
0xd0d3, 0xd0d4, 0xd0d5, 0xd0d6, 0xd0d7, 0xd0d8, 0xd0d9, 0xd0da,  // Offset: 7b90 ~ 7b97
0xd0db, 0xd0dc, 0xd0dd, 0xd0de, 0xd0df, 0xd0e0, 0xd0e1, 0xd0e2,  // Offset: 7b98 ~ 7b9f
0xd0e3, 0xd0e4, 0xd0e5, 0xd0e6, 0xd0e7, 0xd0e8, 0xd0e9, 0xd0ea,  // Offset: 7ba0 ~ 7ba7
0xd0eb, 0xd0ec, 0xd0ed, 0xd0ee, 0xd0ef, 0xd0f0, 0xd0f1, 0xd0f2,  // Offset: 7ba8 ~ 7baf
0xd0f3, 0xd0f4, 0xd0f5, 0xd0f6, 0xd0f7, 0xd0f8, 0xd0f9, 0xd0fa,  // Offset: 7bb0 ~ 7bb7
0xd0fb, 0xd0fc, 0xd0fd, 0xd0fe, 0xd0ff, 0xd100, 0xd101, 0xd102,  // Offset: 7bb8 ~ 7bbf
0xd103, 0xd104, 0xd105, 0xd106, 0xd107, 0xd108, 0xd109, 0xd10a,  // Offset: 7bc0 ~ 7bc7
0xd10b, 0xd10c, 0xd10d, 0xd10e, 0xd10f, 0xd110, 0xd111, 0xd112,  // Offset: 7bc8 ~ 7bcf
0xd113, 0xd114, 0xd115, 0xd116, 0xd117, 0xd118, 0xd119, 0xd11a,  // Offset: 7bd0 ~ 7bd7
0xd11b, 0xd11c, 0xd11d, 0xd11e, 0xd11f, 0xd120, 0xd121, 0xd122,  // Offset: 7bd8 ~ 7bdf
0xd123, 0xd124, 0xd125, 0xd126, 0xd127, 0xd128, 0xd129, 0xd12a,  // Offset: 7be0 ~ 7be7
0xd12b, 0xd12c, 0xd12d, 0xd12e, 0xd12f, 0xd130, 0xd131, 0xd132,  // Offset: 7be8 ~ 7bef
0xd133, 0xd134, 0xd135, 0xd136, 0xd137, 0xd138, 0xd139, 0xd13a,  // Offset: 7bf0 ~ 7bf7
0xd13b, 0xd13c, 0xd13d, 0xd13e, 0xd13f, 0xd140, 0xd141, 0xd142,  // Offset: 7bf8 ~ 7bff
0xd143, 0xd144, 0xd145, 0xd146, 0xd147, 0xd148, 0xd149, 0xd14a,  // Offset: 7c00 ~ 7c07
0xd14b, 0xd14c, 0xd14d, 0xd14e, 0xd14f, 0xd150, 0xd151, 0xd152,  // Offset: 7c08 ~ 7c0f
0xd153, 0xd154, 0xd155, 0xd156, 0xd157, 0xd158, 0xd159, 0xd15a,  // Offset: 7c10 ~ 7c17
0xd15b, 0xd15c, 0xd15d, 0xd15e, 0xd15f, 0xd160, 0xd161, 0xd162,  // Offset: 7c18 ~ 7c1f
0xd163, 0xd164, 0xd165, 0xd166, 0xd167, 0xd168, 0xd169, 0xd16a,  // Offset: 7c20 ~ 7c27
0xd16b, 0xd16c, 0xd16d, 0xd16e, 0xd16f, 0xd170, 0xd171, 0xd172,  // Offset: 7c28 ~ 7c2f
0xd173, 0xd174, 0xd175, 0xd176, 0xd177, 0xd178, 0xd179, 0xd17a,  // Offset: 7c30 ~ 7c37
0xd17b, 0xd17c, 0xd17d, 0xd17e, 0xd17f, 0xd180, 0xd181, 0xd182,  // Offset: 7c38 ~ 7c3f
0xd183, 0xd184, 0xd185, 0xd186, 0xd187, 0xd188, 0xd189, 0xd18a,  // Offset: 7c40 ~ 7c47
0xd18b, 0xd18c, 0xd18d, 0xd18e, 0xd18f, 0xd190, 0xd191, 0xd192,  // Offset: 7c48 ~ 7c4f
0xd193, 0xd194, 0xd195, 0xd196, 0xd197, 0xd198, 0xd199, 0xd19a,  // Offset: 7c50 ~ 7c57
0xd19b, 0xd19c, 0xd19d, 0xd19e, 0xd19f, 0xd1a0, 0xd1a1, 0xd1a2,  // Offset: 7c58 ~ 7c5f
0xd1a3, 0xd1a4, 0xd1a5, 0xd1a6, 0xd1a7, 0xd1a8, 0xd1a9, 0xd1aa,  // Offset: 7c60 ~ 7c67
0xd1ab, 0xd1ac, 0xd1ad, 0xd1ae, 0xd1af, 0xd1b0, 0xd1b1, 0xd1b2,  // Offset: 7c68 ~ 7c6f
0xd1b3, 0xd1b4, 0xd1b5, 0xd1b6, 0xd1b7, 0xd1b8, 0xd1b9, 0xd1ba,  // Offset: 7c70 ~ 7c77
0xd1bb, 0xd1bc, 0xd1bd, 0xd1be, 0xd1bf, 0xd1c0, 0xd1c1, 0xd1c2,  // Offset: 7c78 ~ 7c7f
0xd1c3, 0xd1c4, 0xd1c5, 0xd1c6, 0xd1c7, 0xd1c8, 0xd1c9, 0xd1ca,  // Offset: 7c80 ~ 7c87
0xd1cb, 0xd1cc, 0xd1cd, 0xd1ce, 0xd1cf, 0xd1d0, 0xd1d1, 0xd1d2,  // Offset: 7c88 ~ 7c8f
0xd1d3, 0xd1d4, 0xd1d5, 0xd1d6, 0xd1d7, 0xd1d8, 0xd1d9, 0xd1da,  // Offset: 7c90 ~ 7c97
0xd1db, 0xd1dc, 0xd1dd, 0xd1de, 0xd1df, 0xd1e0, 0xd1e1, 0xd1e2,  // Offset: 7c98 ~ 7c9f
0xd1e3, 0xd1e4, 0xd1e5, 0xd1e6, 0xd1e7, 0xd1e8, 0xd1e9, 0xd1ea,  // Offset: 7ca0 ~ 7ca7
0xd1eb, 0xd1ec, 0xd1ed, 0xd1ee, 0xd1ef, 0xd1f0, 0xd1f1, 0xd1f2,  // Offset: 7ca8 ~ 7caf
0xd1f3, 0xd1f4, 0xd1f5, 0xd1f6, 0xd1f7, 0xd1f8, 0xd1f9, 0xd1fa,  // Offset: 7cb0 ~ 7cb7
0xd1fb, 0xd1fc, 0xd1fd, 0xd1fe, 0xd1ff, 0xd200, 0xd201, 0xd202,  // Offset: 7cb8 ~ 7cbf
0xd203, 0xd204, 0xd205, 0xd206, 0xd207, 0xd208, 0xd209, 0xd20a,  // Offset: 7cc0 ~ 7cc7
0xd20b, 0xd20c, 0xd20d, 0xd20e, 0xd20f, 0xd210, 0xd211, 0xd212,  // Offset: 7cc8 ~ 7ccf
0xd213, 0xd214, 0xd215, 0xd216, 0xd217, 0xd218, 0xd219, 0xd21a,  // Offset: 7cd0 ~ 7cd7
0xd21b, 0xd21c, 0xd21d, 0xd21e, 0xd21f, 0xd220, 0xd221, 0xd222,  // Offset: 7cd8 ~ 7cdf
0xd223, 0xd224, 0xd225, 0xd226, 0xd227, 0xd228, 0xd229, 0xd22a,  // Offset: 7ce0 ~ 7ce7
0xd22b, 0xd22c, 0xd22d, 0xd22e, 0xd22f, 0xd230, 0xd231, 0xd232,  // Offset: 7ce8 ~ 7cef
0xd233, 0xd234, 0xd235, 0xd236, 0xd237, 0xd238, 0xd239, 0xd23a,  // Offset: 7cf0 ~ 7cf7
0xd23b, 0xd23c, 0xd23d, 0xd23e, 0xd23f, 0xd240, 0xd241, 0xd242,  // Offset: 7cf8 ~ 7cff
0xd243, 0xd244, 0xd245, 0xd246, 0xd247, 0xd248, 0xd249, 0xd24a,  // Offset: 7d00 ~ 7d07
0xd24b, 0xd24c, 0xd24d, 0xd24e, 0xd24f, 0xd250, 0xd251, 0xd252,  // Offset: 7d08 ~ 7d0f
0xd253, 0xd254, 0xd255, 0xd256, 0xd257, 0xd258, 0xd259, 0xd25a,  // Offset: 7d10 ~ 7d17
0xd25b, 0xd25c, 0xd25d, 0xd25e, 0xd25f, 0xd260, 0xd261, 0xd262,  // Offset: 7d18 ~ 7d1f
0xd263, 0xd264, 0xd265, 0xd266, 0xd267, 0xd268, 0xd269, 0xd26a,  // Offset: 7d20 ~ 7d27
0xd26b, 0xd26c, 0xd26d, 0xd26e, 0xd26f, 0xd270, 0xd271, 0xd272,  // Offset: 7d28 ~ 7d2f
0xd273, 0xd274, 0xd275, 0xd276, 0xd277, 0xd278, 0xd279, 0xd27a,  // Offset: 7d30 ~ 7d37
0xd27b, 0xd27c, 0xd27d, 0xd27e, 0xd27f, 0xd280, 0xd281, 0xd282,  // Offset: 7d38 ~ 7d3f
0xd283, 0xd284, 0xd285, 0xd286, 0xd287, 0xd288, 0xd289, 0xd28a,  // Offset: 7d40 ~ 7d47
0xd28b, 0xd28c, 0xd28d, 0xd28e, 0xd28f, 0xd290, 0xd291, 0xd292,  // Offset: 7d48 ~ 7d4f
0xd293, 0xd294, 0xd295, 0xd296, 0xd297, 0xd298, 0xd299, 0xd29a,  // Offset: 7d50 ~ 7d57
0xd29b, 0xd29c, 0xd29d, 0xd29e, 0xd29f, 0xd2a0, 0xd2a1, 0xd2a2,  // Offset: 7d58 ~ 7d5f
0xd2a3, 0xd2a4, 0xd2a5, 0xd2a6, 0xd2a7, 0xd2a8, 0xd2a9, 0xd2aa,  // Offset: 7d60 ~ 7d67
0xd2ab, 0xd2ac, 0xd2ad, 0xd2ae, 0xd2af, 0xd2b0, 0xd2b1, 0xd2b2,  // Offset: 7d68 ~ 7d6f
0xd2b3, 0xd2b4, 0xd2b5, 0xd2b6, 0xd2b7, 0xd2b8, 0xd2b9, 0xd2ba,  // Offset: 7d70 ~ 7d77
0xd2bb, 0xd2bc, 0xd2bd, 0xd2be, 0xd2bf, 0xd2c0, 0xd2c1, 0xd2c2,  // Offset: 7d78 ~ 7d7f
0xd2c3, 0xd2c4, 0xd2c5, 0xd2c6, 0xd2c7, 0xd2c8, 0xd2c9, 0xd2ca,  // Offset: 7d80 ~ 7d87
0xd2cb, 0xd2cc, 0xd2cd, 0xd2ce, 0xd2cf, 0xd2d0, 0xd2d1, 0xd2d2,  // Offset: 7d88 ~ 7d8f
0xd2d3, 0xd2d4, 0xd2d5, 0xd2d6, 0xd2d7, 0xd2d8, 0xd2d9, 0xd2da,  // Offset: 7d90 ~ 7d97
0xd2db, 0xd2dc, 0xd2dd, 0xd2de, 0xd2df, 0xd2e0, 0xd2e1, 0xd2e2,  // Offset: 7d98 ~ 7d9f
0xd2e3, 0xd2e4, 0xd2e5, 0xd2e6, 0xd2e7, 0xd2e8, 0xd2e9, 0xd2ea,  // Offset: 7da0 ~ 7da7
0xd2eb, 0xd2ec, 0xd2ed, 0xd2ee, 0xd2ef, 0xd2f0, 0xd2f1, 0xd2f2,  // Offset: 7da8 ~ 7daf
0xd2f3, 0xd2f4, 0xd2f5, 0xd2f6, 0xd2f7, 0xd2f8, 0xd2f9, 0xd2fa,  // Offset: 7db0 ~ 7db7
0xd2fb, 0xd2fc, 0xd2fd, 0xd2fe, 0xd2ff, 0xd300, 0xd301, 0xd302,  // Offset: 7db8 ~ 7dbf
0xd303, 0xd304, 0xd305, 0xd306, 0xd307, 0xd308, 0xd309, 0xd30a,  // Offset: 7dc0 ~ 7dc7
0xd30b, 0xd30c, 0xd30d, 0xd30e, 0xd30f, 0xd310, 0xd311, 0xd312,  // Offset: 7dc8 ~ 7dcf
0xd313, 0xd314, 0xd315, 0xd316, 0xd317, 0xd318, 0xd319, 0xd31a,  // Offset: 7dd0 ~ 7dd7
0xd31b, 0xd31c, 0xd31d, 0xd31e, 0xd31f, 0xd320, 0xd321, 0xd322,  // Offset: 7dd8 ~ 7ddf
0xd323, 0xd324, 0xd325, 0xd326, 0xd327, 0xd328, 0xd329, 0xd32a,  // Offset: 7de0 ~ 7de7
0xd32b, 0xd32c, 0xd32d, 0xd32e, 0xd32f, 0xd330, 0xd331, 0xd332,  // Offset: 7de8 ~ 7def
0xd333, 0xd334, 0xd335, 0xd336, 0xd337, 0xd338, 0xd339, 0xd33a,  // Offset: 7df0 ~ 7df7
0xd33b, 0xd33c, 0xd33d, 0xd33e, 0xd33f, 0xd340, 0xd341, 0xd342,  // Offset: 7df8 ~ 7dff
0xd343, 0xd344, 0xd345, 0xd346, 0xd347, 0xd348, 0xd349, 0xd34a,  // Offset: 7e00 ~ 7e07
0xd34b, 0xd34c, 0xd34d, 0xd34e, 0xd34f, 0xd350, 0xd351, 0xd352,  // Offset: 7e08 ~ 7e0f
0xd353, 0xd354, 0xd355, 0xd356, 0xd357, 0xd358, 0xd359, 0xd35a,  // Offset: 7e10 ~ 7e17
0xd35b, 0xd35c, 0xd35d, 0xd35e, 0xd35f, 0xd360, 0xd361, 0xd362,  // Offset: 7e18 ~ 7e1f
0xd363, 0xd364, 0xd365, 0xd366, 0xd367, 0xd368, 0xd369, 0xd36a,  // Offset: 7e20 ~ 7e27
0xd36b, 0xd36c, 0xd36d, 0xd36e, 0xd36f, 0xd370, 0xd371, 0xd372,  // Offset: 7e28 ~ 7e2f
0xd373, 0xd374, 0xd375, 0xd376, 0xd377, 0xd378, 0xd379, 0xd37a,  // Offset: 7e30 ~ 7e37
0xd37b, 0xd37c, 0xd37d, 0xd37e, 0xd37f, 0xd380, 0xd381, 0xd382,  // Offset: 7e38 ~ 7e3f
0xd383, 0xd384, 0xd385, 0xd386, 0xd387, 0xd388, 0xd389, 0xd38a,  // Offset: 7e40 ~ 7e47
0xd38b, 0xd38c, 0xd38d, 0xd38e, 0xd38f, 0xd390, 0xd391, 0xd392,  // Offset: 7e48 ~ 7e4f
0xd393, 0xd394, 0xd395, 0xd396, 0xd397, 0xd398, 0xd399, 0xd39a,  // Offset: 7e50 ~ 7e57
0xd39b, 0xd39c, 0xd39d, 0xd39e, 0xd39f, 0xd3a0, 0xd3a1, 0xd3a2,  // Offset: 7e58 ~ 7e5f
0xd3a3, 0xd3a4, 0xd3a5, 0xd3a6, 0xd3a7, 0xd3a8, 0xd3a9, 0xd3aa,  // Offset: 7e60 ~ 7e67
0xd3ab, 0xd3ac, 0xd3ad, 0xd3ae, 0xd3af, 0xd3b0, 0xd3b1, 0xd3b2,  // Offset: 7e68 ~ 7e6f
0xd3b3, 0xd3b4, 0xd3b5, 0xd3b6, 0xd3b7, 0xd3b8, 0xd3b9, 0xd3ba,  // Offset: 7e70 ~ 7e77
0xd3bb, 0xd3bc, 0xd3bd, 0xd3be, 0xd3bf, 0xd3c0, 0xd3c1, 0xd3c2,  // Offset: 7e78 ~ 7e7f
0xd3c3, 0xd3c4, 0xd3c5, 0xd3c6, 0xd3c7, 0xd3c8, 0xd3c9, 0xd3ca,  // Offset: 7e80 ~ 7e87
0xd3cb, 0xd3cc, 0xd3cd, 0xd3ce, 0xd3cf, 0xd3d0, 0xd3d1, 0xd3d2,  // Offset: 7e88 ~ 7e8f
0xd3d3, 0xd3d4, 0xd3d5, 0xd3d6, 0xd3d7, 0xd3d8, 0xd3d9, 0xd3da,  // Offset: 7e90 ~ 7e97
0xd3db, 0xd3dc, 0xd3dd, 0xd3de, 0xd3df, 0xd3e0, 0xd3e1, 0xd3e2,  // Offset: 7e98 ~ 7e9f
0xd3e3, 0xd3e4, 0xd3e5, 0xd3e6, 0xd3e7, 0xd3e8, 0xd3e9, 0xd3ea,  // Offset: 7ea0 ~ 7ea7
0xd3eb, 0xd3ec, 0xd3ed, 0xd3ee, 0xd3ef, 0xd3f0, 0xd3f1, 0xd3f2,  // Offset: 7ea8 ~ 7eaf
0xd3f3, 0xd3f4, 0xd3f5, 0xd3f6, 0xd3f7, 0xd3f8, 0xd3f9, 0xd3fa,  // Offset: 7eb0 ~ 7eb7
0xd3fb, 0xd3fc, 0xd3fd, 0xd3fe, 0xd3ff, 0xd400, 0xd401, 0xd402,  // Offset: 7eb8 ~ 7ebf
0xd403, 0xd404, 0xd405, 0xd406, 0xd407, 0xd408, 0xd409, 0xd40a,  // Offset: 7ec0 ~ 7ec7
0xd40b, 0xd40c, 0xd40d, 0xd40e, 0xd40f, 0xd410, 0xd411, 0xd412,  // Offset: 7ec8 ~ 7ecf
0xd413, 0xd414, 0xd415, 0xd416, 0xd417, 0xd418, 0xd419, 0xd41a,  // Offset: 7ed0 ~ 7ed7
0xd41b, 0xd41c, 0xd41d, 0xd41e, 0xd41f, 0xd420, 0xd421, 0xd422,  // Offset: 7ed8 ~ 7edf
0xd423, 0xd424, 0xd425, 0xd426, 0xd427, 0xd428, 0xd429, 0xd42a,  // Offset: 7ee0 ~ 7ee7
0xd42b, 0xd42c, 0xd42d, 0xd42e, 0xd42f, 0xd430, 0xd431, 0xd432,  // Offset: 7ee8 ~ 7eef
0xd433, 0xd434, 0xd435, 0xd436, 0xd437, 0xd438, 0xd439, 0xd43a,  // Offset: 7ef0 ~ 7ef7
0xd43b, 0xd43c, 0xd43d, 0xd43e, 0xd43f, 0xd440, 0xd441, 0xd442,  // Offset: 7ef8 ~ 7eff
0xd443, 0xd444, 0xd445, 0xd446, 0xd447, 0xd448, 0xd449, 0xd44a,  // Offset: 7f00 ~ 7f07
0xd44b, 0xd44c, 0xd44d, 0xd44e, 0xd44f, 0xd450, 0xd451, 0xd452,  // Offset: 7f08 ~ 7f0f
0xd453, 0xd454, 0xd455, 0xd456, 0xd457, 0xd458, 0xd459, 0xd45a,  // Offset: 7f10 ~ 7f17
0xd45b, 0xd45c, 0xd45d, 0xd45e, 0xd45f, 0xd460, 0xd461, 0xd462,  // Offset: 7f18 ~ 7f1f
0xd463, 0xd464, 0xd465, 0xd466, 0xd467, 0xd468, 0xd469, 0xd46a,  // Offset: 7f20 ~ 7f27
0xd46b, 0xd46c, 0xd46d, 0xd46e, 0xd46f, 0xd470, 0xd471, 0xd472,  // Offset: 7f28 ~ 7f2f
0xd473, 0xd474, 0xd475, 0xd476, 0xd477, 0xd478, 0xd479, 0xd47a,  // Offset: 7f30 ~ 7f37
0xd47b, 0xd47c, 0xd47d, 0xd47e, 0xd47f, 0xd480, 0xd481, 0xd482,  // Offset: 7f38 ~ 7f3f
0xd483, 0xd484, 0xd485, 0xd486, 0xd487, 0xd488, 0xd489, 0xd48a,  // Offset: 7f40 ~ 7f47
0xd48b, 0xd48c, 0xd48d, 0xd48e, 0xd48f, 0xd490, 0xd491, 0xd492,  // Offset: 7f48 ~ 7f4f
0xd493, 0xd494, 0xd495, 0xd496, 0xd497, 0xd498, 0xd499, 0xd49a,  // Offset: 7f50 ~ 7f57
0xd49b, 0xd49c, 0xd49d, 0xd49e, 0xd49f, 0xd4a0, 0xd4a1, 0xd4a2,  // Offset: 7f58 ~ 7f5f
0xd4a3, 0xd4a4, 0xd4a5, 0xd4a6, 0xd4a7, 0xd4a8, 0xd4a9, 0xd4aa,  // Offset: 7f60 ~ 7f67
0xd4ab, 0xd4ac, 0xd4ad, 0xd4ae, 0xd4af, 0xd4b0, 0xd4b1, 0xd4b2,  // Offset: 7f68 ~ 7f6f
0xd4b3, 0xd4b4, 0xd4b5, 0xd4b6, 0xd4b7, 0xd4b8, 0xd4b9, 0xd4ba,  // Offset: 7f70 ~ 7f77
0xd4bb, 0xd4bc, 0xd4bd, 0xd4be, 0xd4bf, 0xd4c0, 0xd4c1, 0xd4c2,  // Offset: 7f78 ~ 7f7f
0xd4c3, 0xd4c4, 0xd4c5, 0xd4c6, 0xd4c7, 0xd4c8, 0xd4c9, 0xd4ca,  // Offset: 7f80 ~ 7f87
0xd4cb, 0xd4cc, 0xd4cd, 0xd4ce, 0xd4cf, 0xd4d0, 0xd4d1, 0xd4d2,  // Offset: 7f88 ~ 7f8f
0xd4d3, 0xd4d4, 0xd4d5, 0xd4d6, 0xd4d7, 0xd4d8, 0xd4d9, 0xd4da,  // Offset: 7f90 ~ 7f97
0xd4db, 0xd4dc, 0xd4dd, 0xd4de, 0xd4df, 0xd4e0, 0xd4e1, 0xd4e2,  // Offset: 7f98 ~ 7f9f
0xd4e3, 0xd4e4, 0xd4e5, 0xd4e6, 0xd4e7, 0xd4e8, 0xd4e9, 0xd4ea,  // Offset: 7fa0 ~ 7fa7
0xd4eb, 0xd4ec, 0xd4ed, 0xd4ee, 0xd4ef, 0xd4f0, 0xd4f1, 0xd4f2,  // Offset: 7fa8 ~ 7faf
0xd4f3, 0xd4f4, 0xd4f5, 0xd4f6, 0xd4f7, 0xd4f8, 0xd4f9, 0xd4fa,  // Offset: 7fb0 ~ 7fb7
0xd4fb, 0xd4fc, 0xd4fd, 0xd4fe, 0xd4ff, 0xd500, 0xd501, 0xd502,  // Offset: 7fb8 ~ 7fbf
0xd503, 0xd504, 0xd505, 0xd506, 0xd507, 0xd508, 0xd509, 0xd50a,  // Offset: 7fc0 ~ 7fc7
0xd50b, 0xd50c, 0xd50d, 0xd50e, 0xd50f, 0xd510, 0xd511, 0xd512,  // Offset: 7fc8 ~ 7fcf
0xd513, 0xd514, 0xd515, 0xd516, 0xd517, 0xd518, 0xd519, 0xd51a,  // Offset: 7fd0 ~ 7fd7
0xd51b, 0xd51c, 0xd51d, 0xd51e, 0xd51f, 0xd520, 0xd521, 0xd522,  // Offset: 7fd8 ~ 7fdf
0xd523, 0xd524, 0xd525, 0xd526, 0xd527, 0xd528, 0xd529, 0xd52a,  // Offset: 7fe0 ~ 7fe7
0xd52b, 0xd52c, 0xd52d, 0xd52e, 0xd52f, 0xd530, 0xd531, 0xd532,  // Offset: 7fe8 ~ 7fef
0xd533, 0xd534, 0xd535, 0xd536, 0xd537, 0xd538, 0xd539, 0xd53a,  // Offset: 7ff0 ~ 7ff7
0xd53b, 0xd53c, 0xd53d, 0xd53e, 0xd53f, 0xd540, 0xd541, 0xd542,  // Offset: 7ff8 ~ 7fff
0xd543, 0xd544, 0xd545, 0xd546, 0xd547, 0xd548, 0xd549, 0xd54a,  // Offset: 8000 ~ 8007
0xd54b, 0xd54c, 0xd54d, 0xd54e, 0xd54f, 0xd550, 0xd551, 0xd552,  // Offset: 8008 ~ 800f
0xd553, 0xd554, 0xd555, 0xd556, 0xd557, 0xd558, 0xd559, 0xd55a,  // Offset: 8010 ~ 8017
0xd55b, 0xd55c, 0xd55d, 0xd55e, 0xd55f, 0xd560, 0xd561, 0xd562,  // Offset: 8018 ~ 801f
0xd563, 0xd564, 0xd565, 0xd566, 0xd567, 0xd568, 0xd569, 0xd56a,  // Offset: 8020 ~ 8027
0xd56b, 0xd56c, 0xd56d, 0xd56e, 0xd56f, 0xd570, 0xd571, 0xd572,  // Offset: 8028 ~ 802f
0xd573, 0xd574, 0xd575, 0xd576, 0xd577, 0xd578, 0xd579, 0xd57a,  // Offset: 8030 ~ 8037
0xd57b, 0xd57c, 0xd57d, 0xd57e, 0xd57f, 0xd580, 0xd581, 0xd582,  // Offset: 8038 ~ 803f
0xd583, 0xd584, 0xd585, 0xd586, 0xd587, 0xd588, 0xd589, 0xd58a,  // Offset: 8040 ~ 8047
0xd58b, 0xd58c, 0xd58d, 0xd58e, 0xd58f, 0xd590, 0xd591, 0xd592,  // Offset: 8048 ~ 804f
0xd593, 0xd594, 0xd595, 0xd596, 0xd597, 0xd598, 0xd599, 0xd59a,  // Offset: 8050 ~ 8057
0xd59b, 0xd59c, 0xd59d, 0xd59e, 0xd59f, 0xd5a0, 0xd5a1, 0xd5a2,  // Offset: 8058 ~ 805f
0xd5a3, 0xd5a4, 0xd5a5, 0xd5a6, 0xd5a7, 0xd5a8, 0xd5a9, 0xd5aa,  // Offset: 8060 ~ 8067
0xd5ab, 0xd5ac, 0xd5ad, 0xd5ae, 0xd5af, 0xd5b0, 0xd5b1, 0xd5b2,  // Offset: 8068 ~ 806f
0xd5b3, 0xd5b4, 0xd5b5, 0xd5b6, 0xd5b7, 0xd5b8, 0xd5b9, 0xd5ba,  // Offset: 8070 ~ 8077
0xd5bb, 0xd5bc, 0xd5bd, 0xd5be, 0xd5bf, 0xd5c0, 0xd5c1, 0xd5c2,  // Offset: 8078 ~ 807f
0xd5c3, 0xd5c4, 0xd5c5, 0xd5c6, 0xd5c7, 0xd5c8, 0xd5c9, 0xd5ca,  // Offset: 8080 ~ 8087
0xd5cb, 0xd5cc, 0xd5cd, 0xd5ce, 0xd5cf, 0xd5d0, 0xd5d1, 0xd5d2,  // Offset: 8088 ~ 808f
0xd5d3, 0xd5d4, 0xd5d5, 0xd5d6, 0xd5d7, 0xd5d8, 0xd5d9, 0xd5da,  // Offset: 8090 ~ 8097
0xd5db, 0xd5dc, 0xd5dd, 0xd5de, 0xd5df, 0xd5e0, 0xd5e1, 0xd5e2,  // Offset: 8098 ~ 809f
0xd5e3, 0xd5e4, 0xd5e5, 0xd5e6, 0xd5e7, 0xd5e8, 0xd5e9, 0xd5ea,  // Offset: 80a0 ~ 80a7
0xd5eb, 0xd5ec, 0xd5ed, 0xd5ee, 0xd5ef, 0xd5f0, 0xd5f1, 0xd5f2,  // Offset: 80a8 ~ 80af
0xd5f3, 0xd5f4, 0xd5f5, 0xd5f6, 0xd5f7, 0xd5f8, 0xd5f9, 0xd5fa,  // Offset: 80b0 ~ 80b7
0xd5fb, 0xd5fc, 0xd5fd, 0xd5fe, 0xd5ff, 0xd600, 0xd601, 0xd602,  // Offset: 80b8 ~ 80bf
0xd603, 0xd604, 0xd605, 0xd606, 0xd607, 0xd608, 0xd609, 0xd60a,  // Offset: 80c0 ~ 80c7
0xd60b, 0xd60c, 0xd60d, 0xd60e, 0xd60f, 0xd610, 0xd611, 0xd612,  // Offset: 80c8 ~ 80cf
0xd613, 0xd614, 0xd615, 0xd616, 0xd617, 0xd618, 0xd619, 0xd61a,  // Offset: 80d0 ~ 80d7
0xd61b, 0xd61c, 0xd61d, 0xd61e, 0xd61f, 0xd620, 0xd621, 0xd622,  // Offset: 80d8 ~ 80df
0xd623, 0xd624, 0xd625, 0xd626, 0xd627, 0xd628, 0xd629, 0xd62a,  // Offset: 80e0 ~ 80e7
0xd62b, 0xd62c, 0xd62d, 0xd62e, 0xd62f, 0xd630, 0xd631, 0xd632,  // Offset: 80e8 ~ 80ef
0xd633, 0xd634, 0xd635, 0xd636, 0xd637, 0xd638, 0xd639, 0xd63a,  // Offset: 80f0 ~ 80f7
0xd63b, 0xd63c, 0xd63d, 0xd63e, 0xd63f, 0xd640, 0xd641, 0xd642,  // Offset: 80f8 ~ 80ff
0xd643, 0xd644, 0xd645, 0xd646, 0xd647, 0xd648, 0xd649, 0xd64a,  // Offset: 8100 ~ 8107
0xd64b, 0xd64c, 0xd64d, 0xd64e, 0xd64f, 0xd650, 0xd651, 0xd652,  // Offset: 8108 ~ 810f
0xd653, 0xd654, 0xd655, 0xd656, 0xd657, 0xd658, 0xd659, 0xd65a,  // Offset: 8110 ~ 8117
0xd65b, 0xd65c, 0xd65d, 0xd65e, 0xd65f, 0xd660, 0xd661, 0xd662,  // Offset: 8118 ~ 811f
0xd663, 0xd664, 0xd665, 0xd666, 0xd667, 0xd668, 0xd669, 0xd66a,  // Offset: 8120 ~ 8127
0xd66b, 0xd66c, 0xd66d, 0xd66e, 0xd66f, 0xd670, 0xd671, 0xd672,  // Offset: 8128 ~ 812f
0xd673, 0xd674, 0xd675, 0xd676, 0xd677, 0xd678, 0xd679, 0xd67a,  // Offset: 8130 ~ 8137
0xd67b, 0xd67c, 0xd67d, 0xd67e, 0xd67f, 0xd680, 0xd681, 0xd682,  // Offset: 8138 ~ 813f
0xd683, 0xd684, 0xd685, 0xd686, 0xd687, 0xd688, 0xd689, 0xd68a,  // Offset: 8140 ~ 8147
0xd68b, 0xd68c, 0xd68d, 0xd68e, 0xd68f, 0xd690, 0xd691, 0xd692,  // Offset: 8148 ~ 814f
0xd693, 0xd694, 0xd695, 0xd696, 0xd697, 0xd698, 0xd699, 0xd69a,  // Offset: 8150 ~ 8157
0xd69b, 0xd69c, 0xd69d, 0xd69e, 0xd69f, 0xd6a0, 0xd6a1, 0xd6a2,  // Offset: 8158 ~ 815f
0xd6a3, 0xd6a4, 0xd6a5, 0xd6a6, 0xd6a7, 0xd6a8, 0xd6a9, 0xd6aa,  // Offset: 8160 ~ 8167
0xd6ab, 0xd6ac, 0xd6ad, 0xd6ae, 0xd6af, 0xd6b0, 0xd6b1, 0xd6b2,  // Offset: 8168 ~ 816f
0xd6b3, 0xd6b4, 0xd6b5, 0xd6b6, 0xd6b7, 0xd6b8, 0xd6b9, 0xd6ba,  // Offset: 8170 ~ 8177
0xd6bb, 0xd6bc, 0xd6bd, 0xd6be, 0xd6bf, 0xd6c0, 0xd6c1, 0xd6c2,  // Offset: 8178 ~ 817f
0xd6c3, 0xd6c4, 0xd6c5, 0xd6c6, 0xd6c7, 0xd6c8, 0xd6c9, 0xd6ca,  // Offset: 8180 ~ 8187
0xd6cb, 0xd6cc, 0xd6cd, 0xd6ce, 0xd6cf, 0xd6d0, 0xd6d1, 0xd6d2,  // Offset: 8188 ~ 818f
0xd6d3, 0xd6d4, 0xd6d5, 0xd6d6, 0xd6d7, 0xd6d8, 0xd6d9, 0xd6da,  // Offset: 8190 ~ 8197
0xd6db, 0xd6dc, 0xd6dd, 0xd6de, 0xd6df, 0xd6e0, 0xd6e1, 0xd6e2,  // Offset: 8198 ~ 819f
0xd6e3, 0xd6e4, 0xd6e5, 0xd6e6, 0xd6e7, 0xd6e8, 0xd6e9, 0xd6ea,  // Offset: 81a0 ~ 81a7
0xd6eb, 0xd6ec, 0xd6ed, 0xd6ee, 0xd6ef, 0xd6f0, 0xd6f1, 0xd6f2,  // Offset: 81a8 ~ 81af
0xd6f3, 0xd6f4, 0xd6f5, 0xd6f6, 0xd6f7, 0xd6f8, 0xd6f9, 0xd6fa,  // Offset: 81b0 ~ 81b7
0xd6fb, 0xd6fc, 0xd6fd, 0xd6fe, 0xd6ff, 0xd700, 0xd701, 0xd702,  // Offset: 81b8 ~ 81bf
0xd703, 0xd704, 0xd705, 0xd706, 0xd707, 0xd708, 0xd709, 0xd70a,  // Offset: 81c0 ~ 81c7
0xd70b, 0xd70c, 0xd70d, 0xd70e, 0xd70f, 0xd710, 0xd711, 0xd712,  // Offset: 81c8 ~ 81cf
0xd713, 0xd714, 0xd715, 0xd716, 0xd717, 0xd718, 0xd719, 0xd71a,  // Offset: 81d0 ~ 81d7
0xd71b, 0xd71c, 0xd71d, 0xd71e, 0xd71f, 0xd720, 0xd721, 0xd722,  // Offset: 81d8 ~ 81df
0xd723, 0xd724, 0xd725, 0xd726, 0xd727, 0xd728, 0xd729, 0xd72a,  // Offset: 81e0 ~ 81e7
0xd72b, 0xd72c, 0xd72d, 0xd72e, 0xd72f, 0xd730, 0xd731, 0xd732,  // Offset: 81e8 ~ 81ef
0xd733, 0xd734, 0xd735, 0xd736, 0xd737, 0xd738, 0xd739, 0xd73a,  // Offset: 81f0 ~ 81f7
0xd73b, 0xd73c, 0xd73d, 0xd73e, 0xd73f, 0xd740, 0xd741, 0xd742,  // Offset: 81f8 ~ 81ff
0xd743, 0xd744, 0xd745, 0xd746, 0xd747, 0xd748, 0xd749, 0xd74a,  // Offset: 8200 ~ 8207
0xd74b, 0xd74c, 0xd74d, 0xd74e, 0xd74f, 0xd750, 0xd751, 0xd752,  // Offset: 8208 ~ 820f
0xd753, 0xd754, 0xd755, 0xd756, 0xd757, 0xd758, 0xd759, 0xd75a,  // Offset: 8210 ~ 8217
0xd75b, 0xd75c, 0xd75d, 0xd75e, 0xd75f, 0xd760, 0xd761, 0xd762,  // Offset: 8218 ~ 821f
0xd763, 0xd764, 0xd765, 0xd766, 0xd767, 0xd768, 0xd769, 0xd76a,  // Offset: 8220 ~ 8227
0xd76b, 0xd76c, 0xd76d, 0xd76e, 0xd76f, 0xd770, 0xd771, 0xd772,  // Offset: 8228 ~ 822f
0xd773, 0xd774, 0xd775, 0xd776, 0xd777, 0xd778, 0xd779, 0xd77a,  // Offset: 8230 ~ 8237
0xd77b, 0xd77c, 0xd77d, 0xd77e, 0xd77f, 0xd780, 0xd781, 0xd782,  // Offset: 8238 ~ 823f
0xd783, 0xd784, 0xd785, 0xd786, 0xd787, 0xd788, 0xd789, 0xd78a,  // Offset: 8240 ~ 8247
0xd78b, 0xd78c, 0xd78d, 0xd78e, 0xd78f, 0xd790, 0xd791, 0xd792,  // Offset: 8248 ~ 824f
0xd793, 0xd794, 0xd795, 0xd796, 0xd797, 0xd798, 0xd799, 0xd79a,  // Offset: 8250 ~ 8257
0xd79b, 0xd79c, 0xd79d, 0xd79e, 0xd79f, 0xd7a0, 0xd7a1, 0xd7a2,  // Offset: 8258 ~ 825f
0xd7a3, 0xd7a4, 0xd7a5, 0xd7a6, 0xd7a7, 0xd7a8, 0xd7a9, 0xd7aa,  // Offset: 8260 ~ 8267
0xd7ab, 0xd7ac, 0xd7ad, 0xd7ae, 0xd7af, 0xd7b0, 0xd7b1, 0xd7b2,  // Offset: 8268 ~ 826f
0xd7b3, 0xd7b4, 0xd7b5, 0xd7b6, 0xd7b7, 0xd7b8, 0xd7b9, 0xd7ba,  // Offset: 8270 ~ 8277
0xd7bb, 0xd7bc, 0xd7bd, 0xd7be, 0xd7bf, 0xd7c0, 0xd7c1, 0xd7c2,  // Offset: 8278 ~ 827f
0xd7c3, 0xd7c4, 0xd7c5, 0xd7c6, 0xd7c7, 0xd7c8, 0xd7c9, 0xd7ca,  // Offset: 8280 ~ 8287
0xd7cb, 0xd7cc, 0xd7cd, 0xd7ce, 0xd7cf, 0xd7d0, 0xd7d1, 0xd7d2,  // Offset: 8288 ~ 828f
0xd7d3, 0xd7d4, 0xd7d5, 0xd7d6, 0xd7d7, 0xd7d8, 0xd7d9, 0xd7da,  // Offset: 8290 ~ 8297
0xd7db, 0xd7dc, 0xd7dd, 0xd7de, 0xd7df, 0xd7e0, 0xd7e1, 0xd7e2,  // Offset: 8298 ~ 829f
0xd7e3, 0xd7e4, 0xd7e5, 0xd7e6, 0xd7e7, 0xd7e8, 0xd7e9, 0xd7ea,  // Offset: 82a0 ~ 82a7
0xd7eb, 0xd7ec, 0xd7ed, 0xd7ee, 0xd7ef, 0xd7f0, 0xd7f1, 0xd7f2,  // Offset: 82a8 ~ 82af
0xd7f3, 0xd7f4, 0xd7f5, 0xd7f6, 0xd7f7, 0xd7f8, 0xd7f9, 0xd7fa,  // Offset: 82b0 ~ 82b7
0xd7fb, 0xd7fc, 0xd7fd, 0xd7fe, 0xd7ff, 0xe76c, 0xe7c8, 0xe7e7,  // Offset: 82b8 ~ 82bf
0xe7e8, 0xe7e9, 0xe7ea, 0xe7eb, 0xe7ec, 0xe7ed, 0xe7ee, 0xe7ef,  // Offset: 82c0 ~ 82c7
0xe7f0, 0xe7f1, 0xe7f2, 0xe7f3, 0xe815, 0xe819, 0xe81a, 0xe81b,  // Offset: 82c8 ~ 82cf
0xe81c, 0xe81d, 0xe81f, 0xe820, 0xe821, 0xe822, 0xe823, 0xe824,  // Offset: 82d0 ~ 82d7
0xe825, 0xe827, 0xe828, 0xe829, 0xe82a, 0xe82d, 0xe82e, 0xe82f,  // Offset: 82d8 ~ 82df
0xe830, 0xe833, 0xe834, 0xe835, 0xe836, 0xe837, 0xe838, 0xe839,  // Offset: 82e0 ~ 82e7
0xe83a, 0xe83c, 0xe83d, 0xe83e, 0xe83f, 0xe840, 0xe841, 0xe842,  // Offset: 82e8 ~ 82ef
0xe844, 0xe845, 0xe846, 0xe847, 0xe848, 0xe849, 0xe84a, 0xe84b,  // Offset: 82f0 ~ 82f7
0xe84c, 0xe84d, 0xe84e, 0xe84f, 0xe850, 0xe851, 0xe852, 0xe853,  // Offset: 82f8 ~ 82ff
0xe856, 0xe857, 0xe858, 0xe859, 0xe85a, 0xe85b, 0xe85c, 0xe85d,  // Offset: 8300 ~ 8307
0xe85e, 0xe85f, 0xe860, 0xe861, 0xe862, 0xe863, 0xe865, 0xe866,  // Offset: 8308 ~ 830f
0xe867, 0xe868, 0xe869, 0xe86a, 0xe86b, 0xe86c, 0xe86d, 0xe86e,  // Offset: 8310 ~ 8317
0xe86f, 0xe870, 0xe871, 0xe872, 0xe873, 0xe874, 0xe875, 0xe876,  // Offset: 8318 ~ 831f
0xe877, 0xe878, 0xe879, 0xe87a, 0xe87b, 0xe87c, 0xe87d, 0xe87e,  // Offset: 8320 ~ 8327
0xe87f, 0xe880, 0xe881, 0xe882, 0xe883, 0xe884, 0xe885, 0xe886,  // Offset: 8328 ~ 832f
0xe887, 0xe888, 0xe889, 0xe88a, 0xe88b, 0xe88c, 0xe88d, 0xe88e,  // Offset: 8330 ~ 8337
0xe88f, 0xe890, 0xe891, 0xe892, 0xe893, 0xe894, 0xe895, 0xe896,  // Offset: 8338 ~ 833f
0xe897, 0xe898, 0xe899, 0xe89a, 0xe89b, 0xe89c, 0xe89d, 0xe89e,  // Offset: 8340 ~ 8347
0xe89f, 0xe8a0, 0xe8a1, 0xe8a2, 0xe8a3, 0xe8a4, 0xe8a5, 0xe8a6,  // Offset: 8348 ~ 834f
0xe8a7, 0xe8a8, 0xe8a9, 0xe8aa, 0xe8ab, 0xe8ac, 0xe8ad, 0xe8ae,  // Offset: 8350 ~ 8357
0xe8af, 0xe8b0, 0xe8b1, 0xe8b2, 0xe8b3, 0xe8b4, 0xe8b5, 0xe8b6,  // Offset: 8358 ~ 835f
0xe8b7, 0xe8b8, 0xe8b9, 0xe8ba, 0xe8bb, 0xe8bc, 0xe8bd, 0xe8be,  // Offset: 8360 ~ 8367
0xe8bf, 0xe8c0, 0xe8c1, 0xe8c2, 0xe8c3, 0xe8c4, 0xe8c5, 0xe8c6,  // Offset: 8368 ~ 836f
0xe8c7, 0xe8c8, 0xe8c9, 0xe8ca, 0xe8cb, 0xe8cc, 0xe8cd, 0xe8ce,  // Offset: 8370 ~ 8377
0xe8cf, 0xe8d0, 0xe8d1, 0xe8d2, 0xe8d3, 0xe8d4, 0xe8d5, 0xe8d6,  // Offset: 8378 ~ 837f
0xe8d7, 0xe8d8, 0xe8d9, 0xe8da, 0xe8db, 0xe8dc, 0xe8dd, 0xe8de,  // Offset: 8380 ~ 8387
0xe8df, 0xe8e0, 0xe8e1, 0xe8e2, 0xe8e3, 0xe8e4, 0xe8e5, 0xe8e6,  // Offset: 8388 ~ 838f
0xe8e7, 0xe8e8, 0xe8e9, 0xe8ea, 0xe8eb, 0xe8ec, 0xe8ed, 0xe8ee,  // Offset: 8390 ~ 8397
0xe8ef, 0xe8f0, 0xe8f1, 0xe8f2, 0xe8f3, 0xe8f4, 0xe8f5, 0xe8f6,  // Offset: 8398 ~ 839f
0xe8f7, 0xe8f8, 0xe8f9, 0xe8fa, 0xe8fb, 0xe8fc, 0xe8fd, 0xe8fe,  // Offset: 83a0 ~ 83a7
0xe8ff, 0xe900, 0xe901, 0xe902, 0xe903, 0xe904, 0xe905, 0xe906,  // Offset: 83a8 ~ 83af
0xe907, 0xe908, 0xe909, 0xe90a, 0xe90b, 0xe90c, 0xe90d, 0xe90e,  // Offset: 83b0 ~ 83b7
0xe90f, 0xe910, 0xe911, 0xe912, 0xe913, 0xe914, 0xe915, 0xe916,  // Offset: 83b8 ~ 83bf
0xe917, 0xe918, 0xe919, 0xe91a, 0xe91b, 0xe91c, 0xe91d, 0xe91e,  // Offset: 83c0 ~ 83c7
0xe91f, 0xe920, 0xe921, 0xe922, 0xe923, 0xe924, 0xe925, 0xe926,  // Offset: 83c8 ~ 83cf
0xe927, 0xe928, 0xe929, 0xe92a, 0xe92b, 0xe92c, 0xe92d, 0xe92e,  // Offset: 83d0 ~ 83d7
0xe92f, 0xe930, 0xe931, 0xe932, 0xe933, 0xe934, 0xe935, 0xe936,  // Offset: 83d8 ~ 83df
0xe937, 0xe938, 0xe939, 0xe93a, 0xe93b, 0xe93c, 0xe93d, 0xe93e,  // Offset: 83e0 ~ 83e7
0xe93f, 0xe940, 0xe941, 0xe942, 0xe943, 0xe944, 0xe945, 0xe946,  // Offset: 83e8 ~ 83ef
0xe947, 0xe948, 0xe949, 0xe94a, 0xe94b, 0xe94c, 0xe94d, 0xe94e,  // Offset: 83f0 ~ 83f7
0xe94f, 0xe950, 0xe951, 0xe952, 0xe953, 0xe954, 0xe955, 0xe956,  // Offset: 83f8 ~ 83ff
0xe957, 0xe958, 0xe959, 0xe95a, 0xe95b, 0xe95c, 0xe95d, 0xe95e,  // Offset: 8400 ~ 8407
0xe95f, 0xe960, 0xe961, 0xe962, 0xe963, 0xe964, 0xe965, 0xe966,  // Offset: 8408 ~ 840f
0xe967, 0xe968, 0xe969, 0xe96a, 0xe96b, 0xe96c, 0xe96d, 0xe96e,  // Offset: 8410 ~ 8417
0xe96f, 0xe970, 0xe971, 0xe972, 0xe973, 0xe974, 0xe975, 0xe976,  // Offset: 8418 ~ 841f
0xe977, 0xe978, 0xe979, 0xe97a, 0xe97b, 0xe97c, 0xe97d, 0xe97e,  // Offset: 8420 ~ 8427
0xe97f, 0xe980, 0xe981, 0xe982, 0xe983, 0xe984, 0xe985, 0xe986,  // Offset: 8428 ~ 842f
0xe987, 0xe988, 0xe989, 0xe98a, 0xe98b, 0xe98c, 0xe98d, 0xe98e,  // Offset: 8430 ~ 8437
0xe98f, 0xe990, 0xe991, 0xe992, 0xe993, 0xe994, 0xe995, 0xe996,  // Offset: 8438 ~ 843f
0xe997, 0xe998, 0xe999, 0xe99a, 0xe99b, 0xe99c, 0xe99d, 0xe99e,  // Offset: 8440 ~ 8447
0xe99f, 0xe9a0, 0xe9a1, 0xe9a2, 0xe9a3, 0xe9a4, 0xe9a5, 0xe9a6,  // Offset: 8448 ~ 844f
0xe9a7, 0xe9a8, 0xe9a9, 0xe9aa, 0xe9ab, 0xe9ac, 0xe9ad, 0xe9ae,  // Offset: 8450 ~ 8457
0xe9af, 0xe9b0, 0xe9b1, 0xe9b2, 0xe9b3, 0xe9b4, 0xe9b5, 0xe9b6,  // Offset: 8458 ~ 845f
0xe9b7, 0xe9b8, 0xe9b9, 0xe9ba, 0xe9bb, 0xe9bc, 0xe9bd, 0xe9be,  // Offset: 8460 ~ 8467
0xe9bf, 0xe9c0, 0xe9c1, 0xe9c2, 0xe9c3, 0xe9c4, 0xe9c5, 0xe9c6,  // Offset: 8468 ~ 846f
0xe9c7, 0xe9c8, 0xe9c9, 0xe9ca, 0xe9cb, 0xe9cc, 0xe9cd, 0xe9ce,  // Offset: 8470 ~ 8477
0xe9cf, 0xe9d0, 0xe9d1, 0xe9d2, 0xe9d3, 0xe9d4, 0xe9d5, 0xe9d6,  // Offset: 8478 ~ 847f
0xe9d7, 0xe9d8, 0xe9d9, 0xe9da, 0xe9db, 0xe9dc, 0xe9dd, 0xe9de,  // Offset: 8480 ~ 8487
0xe9df, 0xe9e0, 0xe9e1, 0xe9e2, 0xe9e3, 0xe9e4, 0xe9e5, 0xe9e6,  // Offset: 8488 ~ 848f
0xe9e7, 0xe9e8, 0xe9e9, 0xe9ea, 0xe9eb, 0xe9ec, 0xe9ed, 0xe9ee,  // Offset: 8490 ~ 8497
0xe9ef, 0xe9f0, 0xe9f1, 0xe9f2, 0xe9f3, 0xe9f4, 0xe9f5, 0xe9f6,  // Offset: 8498 ~ 849f
0xe9f7, 0xe9f8, 0xe9f9, 0xe9fa, 0xe9fb, 0xe9fc, 0xe9fd, 0xe9fe,  // Offset: 84a0 ~ 84a7
0xe9ff, 0xea00, 0xea01, 0xea02, 0xea03, 0xea04, 0xea05, 0xea06,  // Offset: 84a8 ~ 84af
0xea07, 0xea08, 0xea09, 0xea0a, 0xea0b, 0xea0c, 0xea0d, 0xea0e,  // Offset: 84b0 ~ 84b7
0xea0f, 0xea10, 0xea11, 0xea12, 0xea13, 0xea14, 0xea15, 0xea16,  // Offset: 84b8 ~ 84bf
0xea17, 0xea18, 0xea19, 0xea1a, 0xea1b, 0xea1c, 0xea1d, 0xea1e,  // Offset: 84c0 ~ 84c7
0xea1f, 0xea20, 0xea21, 0xea22, 0xea23, 0xea24, 0xea25, 0xea26,  // Offset: 84c8 ~ 84cf
0xea27, 0xea28, 0xea29, 0xea2a, 0xea2b, 0xea2c, 0xea2d, 0xea2e,  // Offset: 84d0 ~ 84d7
0xea2f, 0xea30, 0xea31, 0xea32, 0xea33, 0xea34, 0xea35, 0xea36,  // Offset: 84d8 ~ 84df
0xea37, 0xea38, 0xea39, 0xea3a, 0xea3b, 0xea3c, 0xea3d, 0xea3e,  // Offset: 84e0 ~ 84e7
0xea3f, 0xea40, 0xea41, 0xea42, 0xea43, 0xea44, 0xea45, 0xea46,  // Offset: 84e8 ~ 84ef
0xea47, 0xea48, 0xea49, 0xea4a, 0xea4b, 0xea4c, 0xea4d, 0xea4e,  // Offset: 84f0 ~ 84f7
0xea4f, 0xea50, 0xea51, 0xea52, 0xea53, 0xea54, 0xea55, 0xea56,  // Offset: 84f8 ~ 84ff
0xea57, 0xea58, 0xea59, 0xea5a, 0xea5b, 0xea5c, 0xea5d, 0xea5e,  // Offset: 8500 ~ 8507
0xea5f, 0xea60, 0xea61, 0xea62, 0xea63, 0xea64, 0xea65, 0xea66,  // Offset: 8508 ~ 850f
0xea67, 0xea68, 0xea69, 0xea6a, 0xea6b, 0xea6c, 0xea6d, 0xea6e,  // Offset: 8510 ~ 8517
0xea6f, 0xea70, 0xea71, 0xea72, 0xea73, 0xea74, 0xea75, 0xea76,  // Offset: 8518 ~ 851f
0xea77, 0xea78, 0xea79, 0xea7a, 0xea7b, 0xea7c, 0xea7d, 0xea7e,  // Offset: 8520 ~ 8527
0xea7f, 0xea80, 0xea81, 0xea82, 0xea83, 0xea84, 0xea85, 0xea86,  // Offset: 8528 ~ 852f
0xea87, 0xea88, 0xea89, 0xea8a, 0xea8b, 0xea8c, 0xea8d, 0xea8e,  // Offset: 8530 ~ 8537
0xea8f, 0xea90, 0xea91, 0xea92, 0xea93, 0xea94, 0xea95, 0xea96,  // Offset: 8538 ~ 853f
0xea97, 0xea98, 0xea99, 0xea9a, 0xea9b, 0xea9c, 0xea9d, 0xea9e,  // Offset: 8540 ~ 8547
0xea9f, 0xeaa0, 0xeaa1, 0xeaa2, 0xeaa3, 0xeaa4, 0xeaa5, 0xeaa6,  // Offset: 8548 ~ 854f
0xeaa7, 0xeaa8, 0xeaa9, 0xeaaa, 0xeaab, 0xeaac, 0xeaad, 0xeaae,  // Offset: 8550 ~ 8557
0xeaaf, 0xeab0, 0xeab1, 0xeab2, 0xeab3, 0xeab4, 0xeab5, 0xeab6,  // Offset: 8558 ~ 855f
0xeab7, 0xeab8, 0xeab9, 0xeaba, 0xeabb, 0xeabc, 0xeabd, 0xeabe,  // Offset: 8560 ~ 8567
0xeabf, 0xeac0, 0xeac1, 0xeac2, 0xeac3, 0xeac4, 0xeac5, 0xeac6,  // Offset: 8568 ~ 856f
0xeac7, 0xeac8, 0xeac9, 0xeaca, 0xeacb, 0xeacc, 0xeacd, 0xeace,  // Offset: 8570 ~ 8577
0xeacf, 0xead0, 0xead1, 0xead2, 0xead3, 0xead4, 0xead5, 0xead6,  // Offset: 8578 ~ 857f
0xead7, 0xead8, 0xead9, 0xeada, 0xeadb, 0xeadc, 0xeadd, 0xeade,  // Offset: 8580 ~ 8587
0xeadf, 0xeae0, 0xeae1, 0xeae2, 0xeae3, 0xeae4, 0xeae5, 0xeae6,  // Offset: 8588 ~ 858f
0xeae7, 0xeae8, 0xeae9, 0xeaea, 0xeaeb, 0xeaec, 0xeaed, 0xeaee,  // Offset: 8590 ~ 8597
0xeaef, 0xeaf0, 0xeaf1, 0xeaf2, 0xeaf3, 0xeaf4, 0xeaf5, 0xeaf6,  // Offset: 8598 ~ 859f
0xeaf7, 0xeaf8, 0xeaf9, 0xeafa, 0xeafb, 0xeafc, 0xeafd, 0xeafe,  // Offset: 85a0 ~ 85a7
0xeaff, 0xeb00, 0xeb01, 0xeb02, 0xeb03, 0xeb04, 0xeb05, 0xeb06,  // Offset: 85a8 ~ 85af
0xeb07, 0xeb08, 0xeb09, 0xeb0a, 0xeb0b, 0xeb0c, 0xeb0d, 0xeb0e,  // Offset: 85b0 ~ 85b7
0xeb0f, 0xeb10, 0xeb11, 0xeb12, 0xeb13, 0xeb14, 0xeb15, 0xeb16,  // Offset: 85b8 ~ 85bf
0xeb17, 0xeb18, 0xeb19, 0xeb1a, 0xeb1b, 0xeb1c, 0xeb1d, 0xeb1e,  // Offset: 85c0 ~ 85c7
0xeb1f, 0xeb20, 0xeb21, 0xeb22, 0xeb23, 0xeb24, 0xeb25, 0xeb26,  // Offset: 85c8 ~ 85cf
0xeb27, 0xeb28, 0xeb29, 0xeb2a, 0xeb2b, 0xeb2c, 0xeb2d, 0xeb2e,  // Offset: 85d0 ~ 85d7
0xeb2f, 0xeb30, 0xeb31, 0xeb32, 0xeb33, 0xeb34, 0xeb35, 0xeb36,  // Offset: 85d8 ~ 85df
0xeb37, 0xeb38, 0xeb39, 0xeb3a, 0xeb3b, 0xeb3c, 0xeb3d, 0xeb3e,  // Offset: 85e0 ~ 85e7
0xeb3f, 0xeb40, 0xeb41, 0xeb42, 0xeb43, 0xeb44, 0xeb45, 0xeb46,  // Offset: 85e8 ~ 85ef
0xeb47, 0xeb48, 0xeb49, 0xeb4a, 0xeb4b, 0xeb4c, 0xeb4d, 0xeb4e,  // Offset: 85f0 ~ 85f7
0xeb4f, 0xeb50, 0xeb51, 0xeb52, 0xeb53, 0xeb54, 0xeb55, 0xeb56,  // Offset: 85f8 ~ 85ff
0xeb57, 0xeb58, 0xeb59, 0xeb5a, 0xeb5b, 0xeb5c, 0xeb5d, 0xeb5e,  // Offset: 8600 ~ 8607
0xeb5f, 0xeb60, 0xeb61, 0xeb62, 0xeb63, 0xeb64, 0xeb65, 0xeb66,  // Offset: 8608 ~ 860f
0xeb67, 0xeb68, 0xeb69, 0xeb6a, 0xeb6b, 0xeb6c, 0xeb6d, 0xeb6e,  // Offset: 8610 ~ 8617
0xeb6f, 0xeb70, 0xeb71, 0xeb72, 0xeb73, 0xeb74, 0xeb75, 0xeb76,  // Offset: 8618 ~ 861f
0xeb77, 0xeb78, 0xeb79, 0xeb7a, 0xeb7b, 0xeb7c, 0xeb7d, 0xeb7e,  // Offset: 8620 ~ 8627
0xeb7f, 0xeb80, 0xeb81, 0xeb82, 0xeb83, 0xeb84, 0xeb85, 0xeb86,  // Offset: 8628 ~ 862f
0xeb87, 0xeb88, 0xeb89, 0xeb8a, 0xeb8b, 0xeb8c, 0xeb8d, 0xeb8e,  // Offset: 8630 ~ 8637
0xeb8f, 0xeb90, 0xeb91, 0xeb92, 0xeb93, 0xeb94, 0xeb95, 0xeb96,  // Offset: 8638 ~ 863f
0xeb97, 0xeb98, 0xeb99, 0xeb9a, 0xeb9b, 0xeb9c, 0xeb9d, 0xeb9e,  // Offset: 8640 ~ 8647
0xeb9f, 0xeba0, 0xeba1, 0xeba2, 0xeba3, 0xeba4, 0xeba5, 0xeba6,  // Offset: 8648 ~ 864f
0xeba7, 0xeba8, 0xeba9, 0xebaa, 0xebab, 0xebac, 0xebad, 0xebae,  // Offset: 8650 ~ 8657
0xebaf, 0xebb0, 0xebb1, 0xebb2, 0xebb3, 0xebb4, 0xebb5, 0xebb6,  // Offset: 8658 ~ 865f
0xebb7, 0xebb8, 0xebb9, 0xebba, 0xebbb, 0xebbc, 0xebbd, 0xebbe,  // Offset: 8660 ~ 8667
0xebbf, 0xebc0, 0xebc1, 0xebc2, 0xebc3, 0xebc4, 0xebc5, 0xebc6,  // Offset: 8668 ~ 866f
0xebc7, 0xebc8, 0xebc9, 0xebca, 0xebcb, 0xebcc, 0xebcd, 0xebce,  // Offset: 8670 ~ 8677
0xebcf, 0xebd0, 0xebd1, 0xebd2, 0xebd3, 0xebd4, 0xebd5, 0xebd6,  // Offset: 8678 ~ 867f
0xebd7, 0xebd8, 0xebd9, 0xebda, 0xebdb, 0xebdc, 0xebdd, 0xebde,  // Offset: 8680 ~ 8687
0xebdf, 0xebe0, 0xebe1, 0xebe2, 0xebe3, 0xebe4, 0xebe5, 0xebe6,  // Offset: 8688 ~ 868f
0xebe7, 0xebe8, 0xebe9, 0xebea, 0xebeb, 0xebec, 0xebed, 0xebee,  // Offset: 8690 ~ 8697
0xebef, 0xebf0, 0xebf1, 0xebf2, 0xebf3, 0xebf4, 0xebf5, 0xebf6,  // Offset: 8698 ~ 869f
0xebf7, 0xebf8, 0xebf9, 0xebfa, 0xebfb, 0xebfc, 0xebfd, 0xebfe,  // Offset: 86a0 ~ 86a7
0xebff, 0xec00, 0xec01, 0xec02, 0xec03, 0xec04, 0xec05, 0xec06,  // Offset: 86a8 ~ 86af
0xec07, 0xec08, 0xec09, 0xec0a, 0xec0b, 0xec0c, 0xec0d, 0xec0e,  // Offset: 86b0 ~ 86b7
0xec0f, 0xec10, 0xec11, 0xec12, 0xec13, 0xec14, 0xec15, 0xec16,  // Offset: 86b8 ~ 86bf
0xec17, 0xec18, 0xec19, 0xec1a, 0xec1b, 0xec1c, 0xec1d, 0xec1e,  // Offset: 86c0 ~ 86c7
0xec1f, 0xec20, 0xec21, 0xec22, 0xec23, 0xec24, 0xec25, 0xec26,  // Offset: 86c8 ~ 86cf
0xec27, 0xec28, 0xec29, 0xec2a, 0xec2b, 0xec2c, 0xec2d, 0xec2e,  // Offset: 86d0 ~ 86d7
0xec2f, 0xec30, 0xec31, 0xec32, 0xec33, 0xec34, 0xec35, 0xec36,  // Offset: 86d8 ~ 86df
0xec37, 0xec38, 0xec39, 0xec3a, 0xec3b, 0xec3c, 0xec3d, 0xec3e,  // Offset: 86e0 ~ 86e7
0xec3f, 0xec40, 0xec41, 0xec42, 0xec43, 0xec44, 0xec45, 0xec46,  // Offset: 86e8 ~ 86ef
0xec47, 0xec48, 0xec49, 0xec4a, 0xec4b, 0xec4c, 0xec4d, 0xec4e,  // Offset: 86f0 ~ 86f7
0xec4f, 0xec50, 0xec51, 0xec52, 0xec53, 0xec54, 0xec55, 0xec56,  // Offset: 86f8 ~ 86ff
0xec57, 0xec58, 0xec59, 0xec5a, 0xec5b, 0xec5c, 0xec5d, 0xec5e,  // Offset: 8700 ~ 8707
0xec5f, 0xec60, 0xec61, 0xec62, 0xec63, 0xec64, 0xec65, 0xec66,  // Offset: 8708 ~ 870f
0xec67, 0xec68, 0xec69, 0xec6a, 0xec6b, 0xec6c, 0xec6d, 0xec6e,  // Offset: 8710 ~ 8717
0xec6f, 0xec70, 0xec71, 0xec72, 0xec73, 0xec74, 0xec75, 0xec76,  // Offset: 8718 ~ 871f
0xec77, 0xec78, 0xec79, 0xec7a, 0xec7b, 0xec7c, 0xec7d, 0xec7e,  // Offset: 8720 ~ 8727
0xec7f, 0xec80, 0xec81, 0xec82, 0xec83, 0xec84, 0xec85, 0xec86,  // Offset: 8728 ~ 872f
0xec87, 0xec88, 0xec89, 0xec8a, 0xec8b, 0xec8c, 0xec8d, 0xec8e,  // Offset: 8730 ~ 8737
0xec8f, 0xec90, 0xec91, 0xec92, 0xec93, 0xec94, 0xec95, 0xec96,  // Offset: 8738 ~ 873f
0xec97, 0xec98, 0xec99, 0xec9a, 0xec9b, 0xec9c, 0xec9d, 0xec9e,  // Offset: 8740 ~ 8747
0xec9f, 0xeca0, 0xeca1, 0xeca2, 0xeca3, 0xeca4, 0xeca5, 0xeca6,  // Offset: 8748 ~ 874f
0xeca7, 0xeca8, 0xeca9, 0xecaa, 0xecab, 0xecac, 0xecad, 0xecae,  // Offset: 8750 ~ 8757
0xecaf, 0xecb0, 0xecb1, 0xecb2, 0xecb3, 0xecb4, 0xecb5, 0xecb6,  // Offset: 8758 ~ 875f
0xecb7, 0xecb8, 0xecb9, 0xecba, 0xecbb, 0xecbc, 0xecbd, 0xecbe,  // Offset: 8760 ~ 8767
0xecbf, 0xecc0, 0xecc1, 0xecc2, 0xecc3, 0xecc4, 0xecc5, 0xecc6,  // Offset: 8768 ~ 876f
0xecc7, 0xecc8, 0xecc9, 0xecca, 0xeccb, 0xeccc, 0xeccd, 0xecce,  // Offset: 8770 ~ 8777
0xeccf, 0xecd0, 0xecd1, 0xecd2, 0xecd3, 0xecd4, 0xecd5, 0xecd6,  // Offset: 8778 ~ 877f
0xecd7, 0xecd8, 0xecd9, 0xecda, 0xecdb, 0xecdc, 0xecdd, 0xecde,  // Offset: 8780 ~ 8787
0xecdf, 0xece0, 0xece1, 0xece2, 0xece3, 0xece4, 0xece5, 0xece6,  // Offset: 8788 ~ 878f
0xece7, 0xece8, 0xece9, 0xecea, 0xeceb, 0xecec, 0xeced, 0xecee,  // Offset: 8790 ~ 8797
0xecef, 0xecf0, 0xecf1, 0xecf2, 0xecf3, 0xecf4, 0xecf5, 0xecf6,  // Offset: 8798 ~ 879f
0xecf7, 0xecf8, 0xecf9, 0xecfa, 0xecfb, 0xecfc, 0xecfd, 0xecfe,  // Offset: 87a0 ~ 87a7
0xecff, 0xed00, 0xed01, 0xed02, 0xed03, 0xed04, 0xed05, 0xed06,  // Offset: 87a8 ~ 87af
0xed07, 0xed08, 0xed09, 0xed0a, 0xed0b, 0xed0c, 0xed0d, 0xed0e,  // Offset: 87b0 ~ 87b7
0xed0f, 0xed10, 0xed11, 0xed12, 0xed13, 0xed14, 0xed15, 0xed16,  // Offset: 87b8 ~ 87bf
0xed17, 0xed18, 0xed19, 0xed1a, 0xed1b, 0xed1c, 0xed1d, 0xed1e,  // Offset: 87c0 ~ 87c7
0xed1f, 0xed20, 0xed21, 0xed22, 0xed23, 0xed24, 0xed25, 0xed26,  // Offset: 87c8 ~ 87cf
0xed27, 0xed28, 0xed29, 0xed2a, 0xed2b, 0xed2c, 0xed2d, 0xed2e,  // Offset: 87d0 ~ 87d7
0xed2f, 0xed30, 0xed31, 0xed32, 0xed33, 0xed34, 0xed35, 0xed36,  // Offset: 87d8 ~ 87df
0xed37, 0xed38, 0xed39, 0xed3a, 0xed3b, 0xed3c, 0xed3d, 0xed3e,  // Offset: 87e0 ~ 87e7
0xed3f, 0xed40, 0xed41, 0xed42, 0xed43, 0xed44, 0xed45, 0xed46,  // Offset: 87e8 ~ 87ef
0xed47, 0xed48, 0xed49, 0xed4a, 0xed4b, 0xed4c, 0xed4d, 0xed4e,  // Offset: 87f0 ~ 87f7
0xed4f, 0xed50, 0xed51, 0xed52, 0xed53, 0xed54, 0xed55, 0xed56,  // Offset: 87f8 ~ 87ff
0xed57, 0xed58, 0xed59, 0xed5a, 0xed5b, 0xed5c, 0xed5d, 0xed5e,  // Offset: 8800 ~ 8807
0xed5f, 0xed60, 0xed61, 0xed62, 0xed63, 0xed64, 0xed65, 0xed66,  // Offset: 8808 ~ 880f
0xed67, 0xed68, 0xed69, 0xed6a, 0xed6b, 0xed6c, 0xed6d, 0xed6e,  // Offset: 8810 ~ 8817
0xed6f, 0xed70, 0xed71, 0xed72, 0xed73, 0xed74, 0xed75, 0xed76,  // Offset: 8818 ~ 881f
0xed77, 0xed78, 0xed79, 0xed7a, 0xed7b, 0xed7c, 0xed7d, 0xed7e,  // Offset: 8820 ~ 8827
0xed7f, 0xed80, 0xed81, 0xed82, 0xed83, 0xed84, 0xed85, 0xed86,  // Offset: 8828 ~ 882f
0xed87, 0xed88, 0xed89, 0xed8a, 0xed8b, 0xed8c, 0xed8d, 0xed8e,  // Offset: 8830 ~ 8837
0xed8f, 0xed90, 0xed91, 0xed92, 0xed93, 0xed94, 0xed95, 0xed96,  // Offset: 8838 ~ 883f
0xed97, 0xed98, 0xed99, 0xed9a, 0xed9b, 0xed9c, 0xed9d, 0xed9e,  // Offset: 8840 ~ 8847
0xed9f, 0xeda0, 0xeda1, 0xeda2, 0xeda3, 0xeda4, 0xeda5, 0xeda6,  // Offset: 8848 ~ 884f
0xeda7, 0xeda8, 0xeda9, 0xedaa, 0xedab, 0xedac, 0xedad, 0xedae,  // Offset: 8850 ~ 8857
0xedaf, 0xedb0, 0xedb1, 0xedb2, 0xedb3, 0xedb4, 0xedb5, 0xedb6,  // Offset: 8858 ~ 885f
0xedb7, 0xedb8, 0xedb9, 0xedba, 0xedbb, 0xedbc, 0xedbd, 0xedbe,  // Offset: 8860 ~ 8867
0xedbf, 0xedc0, 0xedc1, 0xedc2, 0xedc3, 0xedc4, 0xedc5, 0xedc6,  // Offset: 8868 ~ 886f
0xedc7, 0xedc8, 0xedc9, 0xedca, 0xedcb, 0xedcc, 0xedcd, 0xedce,  // Offset: 8870 ~ 8877
0xedcf, 0xedd0, 0xedd1, 0xedd2, 0xedd3, 0xedd4, 0xedd5, 0xedd6,  // Offset: 8878 ~ 887f
0xedd7, 0xedd8, 0xedd9, 0xedda, 0xeddb, 0xeddc, 0xeddd, 0xedde,  // Offset: 8880 ~ 8887
0xeddf, 0xede0, 0xede1, 0xede2, 0xede3, 0xede4, 0xede5, 0xede6,  // Offset: 8888 ~ 888f
0xede7, 0xede8, 0xede9, 0xedea, 0xedeb, 0xedec, 0xeded, 0xedee,  // Offset: 8890 ~ 8897
0xedef, 0xedf0, 0xedf1, 0xedf2, 0xedf3, 0xedf4, 0xedf5, 0xedf6,  // Offset: 8898 ~ 889f
0xedf7, 0xedf8, 0xedf9, 0xedfa, 0xedfb, 0xedfc, 0xedfd, 0xedfe,  // Offset: 88a0 ~ 88a7
0xedff, 0xee00, 0xee01, 0xee02, 0xee03, 0xee04, 0xee05, 0xee06,  // Offset: 88a8 ~ 88af
0xee07, 0xee08, 0xee09, 0xee0a, 0xee0b, 0xee0c, 0xee0d, 0xee0e,  // Offset: 88b0 ~ 88b7
0xee0f, 0xee10, 0xee11, 0xee12, 0xee13, 0xee14, 0xee15, 0xee16,  // Offset: 88b8 ~ 88bf
0xee17, 0xee18, 0xee19, 0xee1a, 0xee1b, 0xee1c, 0xee1d, 0xee1e,  // Offset: 88c0 ~ 88c7
0xee1f, 0xee20, 0xee21, 0xee22, 0xee23, 0xee24, 0xee25, 0xee26,  // Offset: 88c8 ~ 88cf
0xee27, 0xee28, 0xee29, 0xee2a, 0xee2b, 0xee2c, 0xee2d, 0xee2e,  // Offset: 88d0 ~ 88d7
0xee2f, 0xee30, 0xee31, 0xee32, 0xee33, 0xee34, 0xee35, 0xee36,  // Offset: 88d8 ~ 88df
0xee37, 0xee38, 0xee39, 0xee3a, 0xee3b, 0xee3c, 0xee3d, 0xee3e,  // Offset: 88e0 ~ 88e7
0xee3f, 0xee40, 0xee41, 0xee42, 0xee43, 0xee44, 0xee45, 0xee46,  // Offset: 88e8 ~ 88ef
0xee47, 0xee48, 0xee49, 0xee4a, 0xee4b, 0xee4c, 0xee4d, 0xee4e,  // Offset: 88f0 ~ 88f7
0xee4f, 0xee50, 0xee51, 0xee52, 0xee53, 0xee54, 0xee55, 0xee56,  // Offset: 88f8 ~ 88ff
0xee57, 0xee58, 0xee59, 0xee5a, 0xee5b, 0xee5c, 0xee5d, 0xee5e,  // Offset: 8900 ~ 8907
0xee5f, 0xee60, 0xee61, 0xee62, 0xee63, 0xee64, 0xee65, 0xee66,  // Offset: 8908 ~ 890f
0xee67, 0xee68, 0xee69, 0xee6a, 0xee6b, 0xee6c, 0xee6d, 0xee6e,  // Offset: 8910 ~ 8917
0xee6f, 0xee70, 0xee71, 0xee72, 0xee73, 0xee74, 0xee75, 0xee76,  // Offset: 8918 ~ 891f
0xee77, 0xee78, 0xee79, 0xee7a, 0xee7b, 0xee7c, 0xee7d, 0xee7e,  // Offset: 8920 ~ 8927
0xee7f, 0xee80, 0xee81, 0xee82, 0xee83, 0xee84, 0xee85, 0xee86,  // Offset: 8928 ~ 892f
0xee87, 0xee88, 0xee89, 0xee8a, 0xee8b, 0xee8c, 0xee8d, 0xee8e,  // Offset: 8930 ~ 8937
0xee8f, 0xee90, 0xee91, 0xee92, 0xee93, 0xee94, 0xee95, 0xee96,  // Offset: 8938 ~ 893f
0xee97, 0xee98, 0xee99, 0xee9a, 0xee9b, 0xee9c, 0xee9d, 0xee9e,  // Offset: 8940 ~ 8947
0xee9f, 0xeea0, 0xeea1, 0xeea2, 0xeea3, 0xeea4, 0xeea5, 0xeea6,  // Offset: 8948 ~ 894f
0xeea7, 0xeea8, 0xeea9, 0xeeaa, 0xeeab, 0xeeac, 0xeead, 0xeeae,  // Offset: 8950 ~ 8957
0xeeaf, 0xeeb0, 0xeeb1, 0xeeb2, 0xeeb3, 0xeeb4, 0xeeb5, 0xeeb6,  // Offset: 8958 ~ 895f
0xeeb7, 0xeeb8, 0xeeb9, 0xeeba, 0xeebb, 0xeebc, 0xeebd, 0xeebe,  // Offset: 8960 ~ 8967
0xeebf, 0xeec0, 0xeec1, 0xeec2, 0xeec3, 0xeec4, 0xeec5, 0xeec6,  // Offset: 8968 ~ 896f
0xeec7, 0xeec8, 0xeec9, 0xeeca, 0xeecb, 0xeecc, 0xeecd, 0xeece,  // Offset: 8970 ~ 8977
0xeecf, 0xeed0, 0xeed1, 0xeed2, 0xeed3, 0xeed4, 0xeed5, 0xeed6,  // Offset: 8978 ~ 897f
0xeed7, 0xeed8, 0xeed9, 0xeeda, 0xeedb, 0xeedc, 0xeedd, 0xeede,  // Offset: 8980 ~ 8987
0xeedf, 0xeee0, 0xeee1, 0xeee2, 0xeee3, 0xeee4, 0xeee5, 0xeee6,  // Offset: 8988 ~ 898f
0xeee7, 0xeee8, 0xeee9, 0xeeea, 0xeeeb, 0xeeec, 0xeeed, 0xeeee,  // Offset: 8990 ~ 8997
0xeeef, 0xeef0, 0xeef1, 0xeef2, 0xeef3, 0xeef4, 0xeef5, 0xeef6,  // Offset: 8998 ~ 899f
0xeef7, 0xeef8, 0xeef9, 0xeefa, 0xeefb, 0xeefc, 0xeefd, 0xeefe,  // Offset: 89a0 ~ 89a7
0xeeff, 0xef00, 0xef01, 0xef02, 0xef03, 0xef04, 0xef05, 0xef06,  // Offset: 89a8 ~ 89af
0xef07, 0xef08, 0xef09, 0xef0a, 0xef0b, 0xef0c, 0xef0d, 0xef0e,  // Offset: 89b0 ~ 89b7
0xef0f, 0xef10, 0xef11, 0xef12, 0xef13, 0xef14, 0xef15, 0xef16,  // Offset: 89b8 ~ 89bf
0xef17, 0xef18, 0xef19, 0xef1a, 0xef1b, 0xef1c, 0xef1d, 0xef1e,  // Offset: 89c0 ~ 89c7
0xef1f, 0xef20, 0xef21, 0xef22, 0xef23, 0xef24, 0xef25, 0xef26,  // Offset: 89c8 ~ 89cf
0xef27, 0xef28, 0xef29, 0xef2a, 0xef2b, 0xef2c, 0xef2d, 0xef2e,  // Offset: 89d0 ~ 89d7
0xef2f, 0xef30, 0xef31, 0xef32, 0xef33, 0xef34, 0xef35, 0xef36,  // Offset: 89d8 ~ 89df
0xef37, 0xef38, 0xef39, 0xef3a, 0xef3b, 0xef3c, 0xef3d, 0xef3e,  // Offset: 89e0 ~ 89e7
0xef3f, 0xef40, 0xef41, 0xef42, 0xef43, 0xef44, 0xef45, 0xef46,  // Offset: 89e8 ~ 89ef
0xef47, 0xef48, 0xef49, 0xef4a, 0xef4b, 0xef4c, 0xef4d, 0xef4e,  // Offset: 89f0 ~ 89f7
0xef4f, 0xef50, 0xef51, 0xef52, 0xef53, 0xef54, 0xef55, 0xef56,  // Offset: 89f8 ~ 89ff
0xef57, 0xef58, 0xef59, 0xef5a, 0xef5b, 0xef5c, 0xef5d, 0xef5e,  // Offset: 8a00 ~ 8a07
0xef5f, 0xef60, 0xef61, 0xef62, 0xef63, 0xef64, 0xef65, 0xef66,  // Offset: 8a08 ~ 8a0f
0xef67, 0xef68, 0xef69, 0xef6a, 0xef6b, 0xef6c, 0xef6d, 0xef6e,  // Offset: 8a10 ~ 8a17
0xef6f, 0xef70, 0xef71, 0xef72, 0xef73, 0xef74, 0xef75, 0xef76,  // Offset: 8a18 ~ 8a1f
0xef77, 0xef78, 0xef79, 0xef7a, 0xef7b, 0xef7c, 0xef7d, 0xef7e,  // Offset: 8a20 ~ 8a27
0xef7f, 0xef80, 0xef81, 0xef82, 0xef83, 0xef84, 0xef85, 0xef86,  // Offset: 8a28 ~ 8a2f
0xef87, 0xef88, 0xef89, 0xef8a, 0xef8b, 0xef8c, 0xef8d, 0xef8e,  // Offset: 8a30 ~ 8a37
0xef8f, 0xef90, 0xef91, 0xef92, 0xef93, 0xef94, 0xef95, 0xef96,  // Offset: 8a38 ~ 8a3f
0xef97, 0xef98, 0xef99, 0xef9a, 0xef9b, 0xef9c, 0xef9d, 0xef9e,  // Offset: 8a40 ~ 8a47
0xef9f, 0xefa0, 0xefa1, 0xefa2, 0xefa3, 0xefa4, 0xefa5, 0xefa6,  // Offset: 8a48 ~ 8a4f
0xefa7, 0xefa8, 0xefa9, 0xefaa, 0xefab, 0xefac, 0xefad, 0xefae,  // Offset: 8a50 ~ 8a57
0xefaf, 0xefb0, 0xefb1, 0xefb2, 0xefb3, 0xefb4, 0xefb5, 0xefb6,  // Offset: 8a58 ~ 8a5f
0xefb7, 0xefb8, 0xefb9, 0xefba, 0xefbb, 0xefbc, 0xefbd, 0xefbe,  // Offset: 8a60 ~ 8a67
0xefbf, 0xefc0, 0xefc1, 0xefc2, 0xefc3, 0xefc4, 0xefc5, 0xefc6,  // Offset: 8a68 ~ 8a6f
0xefc7, 0xefc8, 0xefc9, 0xefca, 0xefcb, 0xefcc, 0xefcd, 0xefce,  // Offset: 8a70 ~ 8a77
0xefcf, 0xefd0, 0xefd1, 0xefd2, 0xefd3, 0xefd4, 0xefd5, 0xefd6,  // Offset: 8a78 ~ 8a7f
0xefd7, 0xefd8, 0xefd9, 0xefda, 0xefdb, 0xefdc, 0xefdd, 0xefde,  // Offset: 8a80 ~ 8a87
0xefdf, 0xefe0, 0xefe1, 0xefe2, 0xefe3, 0xefe4, 0xefe5, 0xefe6,  // Offset: 8a88 ~ 8a8f
0xefe7, 0xefe8, 0xefe9, 0xefea, 0xefeb, 0xefec, 0xefed, 0xefee,  // Offset: 8a90 ~ 8a97
0xefef, 0xeff0, 0xeff1, 0xeff2, 0xeff3, 0xeff4, 0xeff5, 0xeff6,  // Offset: 8a98 ~ 8a9f
0xeff7, 0xeff8, 0xeff9, 0xeffa, 0xeffb, 0xeffc, 0xeffd, 0xeffe,  // Offset: 8aa0 ~ 8aa7
0xefff, 0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006,  // Offset: 8aa8 ~ 8aaf
0xf007, 0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e,  // Offset: 8ab0 ~ 8ab7
0xf00f, 0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016,  // Offset: 8ab8 ~ 8abf
0xf017, 0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e,  // Offset: 8ac0 ~ 8ac7
0xf01f, 0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026,  // Offset: 8ac8 ~ 8acf
0xf027, 0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e,  // Offset: 8ad0 ~ 8ad7
0xf02f, 0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036,  // Offset: 8ad8 ~ 8adf
0xf037, 0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e,  // Offset: 8ae0 ~ 8ae7
0xf03f, 0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046,  // Offset: 8ae8 ~ 8aef
0xf047, 0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e,  // Offset: 8af0 ~ 8af7
0xf04f, 0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056,  // Offset: 8af8 ~ 8aff
0xf057, 0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e,  // Offset: 8b00 ~ 8b07
0xf05f, 0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066,  // Offset: 8b08 ~ 8b0f
0xf067, 0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e,  // Offset: 8b10 ~ 8b17
0xf06f, 0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076,  // Offset: 8b18 ~ 8b1f
0xf077, 0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e,  // Offset: 8b20 ~ 8b27
0xf07f, 0xf080, 0xf081, 0xf082, 0xf083, 0xf084, 0xf085, 0xf086,  // Offset: 8b28 ~ 8b2f
0xf087, 0xf088, 0xf089, 0xf08a, 0xf08b, 0xf08c, 0xf08d, 0xf08e,  // Offset: 8b30 ~ 8b37
0xf08f, 0xf090, 0xf091, 0xf092, 0xf093, 0xf094, 0xf095, 0xf096,  // Offset: 8b38 ~ 8b3f
0xf097, 0xf098, 0xf099, 0xf09a, 0xf09b, 0xf09c, 0xf09d, 0xf09e,  // Offset: 8b40 ~ 8b47
0xf09f, 0xf0a0, 0xf0a1, 0xf0a2, 0xf0a3, 0xf0a4, 0xf0a5, 0xf0a6,  // Offset: 8b48 ~ 8b4f
0xf0a7, 0xf0a8, 0xf0a9, 0xf0aa, 0xf0ab, 0xf0ac, 0xf0ad, 0xf0ae,  // Offset: 8b50 ~ 8b57
0xf0af, 0xf0b0, 0xf0b1, 0xf0b2, 0xf0b3, 0xf0b4, 0xf0b5, 0xf0b6,  // Offset: 8b58 ~ 8b5f
0xf0b7, 0xf0b8, 0xf0b9, 0xf0ba, 0xf0bb, 0xf0bc, 0xf0bd, 0xf0be,  // Offset: 8b60 ~ 8b67
0xf0bf, 0xf0c0, 0xf0c1, 0xf0c2, 0xf0c3, 0xf0c4, 0xf0c5, 0xf0c6,  // Offset: 8b68 ~ 8b6f
0xf0c7, 0xf0c8, 0xf0c9, 0xf0ca, 0xf0cb, 0xf0cc, 0xf0cd, 0xf0ce,  // Offset: 8b70 ~ 8b77
0xf0cf, 0xf0d0, 0xf0d1, 0xf0d2, 0xf0d3, 0xf0d4, 0xf0d5, 0xf0d6,  // Offset: 8b78 ~ 8b7f
0xf0d7, 0xf0d8, 0xf0d9, 0xf0da, 0xf0db, 0xf0dc, 0xf0dd, 0xf0de,  // Offset: 8b80 ~ 8b87
0xf0df, 0xf0e0, 0xf0e1, 0xf0e2, 0xf0e3, 0xf0e4, 0xf0e5, 0xf0e6,  // Offset: 8b88 ~ 8b8f
0xf0e7, 0xf0e8, 0xf0e9, 0xf0ea, 0xf0eb, 0xf0ec, 0xf0ed, 0xf0ee,  // Offset: 8b90 ~ 8b97
0xf0ef, 0xf0f0, 0xf0f1, 0xf0f2, 0xf0f3, 0xf0f4, 0xf0f5, 0xf0f6,  // Offset: 8b98 ~ 8b9f
0xf0f7, 0xf0f8, 0xf0f9, 0xf0fa, 0xf0fb, 0xf0fc, 0xf0fd, 0xf0fe,  // Offset: 8ba0 ~ 8ba7
0xf0ff, 0xf100, 0xf101, 0xf102, 0xf103, 0xf104, 0xf105, 0xf106,  // Offset: 8ba8 ~ 8baf
0xf107, 0xf108, 0xf109, 0xf10a, 0xf10b, 0xf10c, 0xf10d, 0xf10e,  // Offset: 8bb0 ~ 8bb7
0xf10f, 0xf110, 0xf111, 0xf112, 0xf113, 0xf114, 0xf115, 0xf116,  // Offset: 8bb8 ~ 8bbf
0xf117, 0xf118, 0xf119, 0xf11a, 0xf11b, 0xf11c, 0xf11d, 0xf11e,  // Offset: 8bc0 ~ 8bc7
0xf11f, 0xf120, 0xf121, 0xf122, 0xf123, 0xf124, 0xf125, 0xf126,  // Offset: 8bc8 ~ 8bcf
0xf127, 0xf128, 0xf129, 0xf12a, 0xf12b, 0xf12c, 0xf12d, 0xf12e,  // Offset: 8bd0 ~ 8bd7
0xf12f, 0xf130, 0xf131, 0xf132, 0xf133, 0xf134, 0xf135, 0xf136,  // Offset: 8bd8 ~ 8bdf
0xf137, 0xf138, 0xf139, 0xf13a, 0xf13b, 0xf13c, 0xf13d, 0xf13e,  // Offset: 8be0 ~ 8be7
0xf13f, 0xf140, 0xf141, 0xf142, 0xf143, 0xf144, 0xf145, 0xf146,  // Offset: 8be8 ~ 8bef
0xf147, 0xf148, 0xf149, 0xf14a, 0xf14b, 0xf14c, 0xf14d, 0xf14e,  // Offset: 8bf0 ~ 8bf7
0xf14f, 0xf150, 0xf151, 0xf152, 0xf153, 0xf154, 0xf155, 0xf156,  // Offset: 8bf8 ~ 8bff
0xf157, 0xf158, 0xf159, 0xf15a, 0xf15b, 0xf15c, 0xf15d, 0xf15e,  // Offset: 8c00 ~ 8c07
0xf15f, 0xf160, 0xf161, 0xf162, 0xf163, 0xf164, 0xf165, 0xf166,  // Offset: 8c08 ~ 8c0f
0xf167, 0xf168, 0xf169, 0xf16a, 0xf16b, 0xf16c, 0xf16d, 0xf16e,  // Offset: 8c10 ~ 8c17
0xf16f, 0xf170, 0xf171, 0xf172, 0xf173, 0xf174, 0xf175, 0xf176,  // Offset: 8c18 ~ 8c1f
0xf177, 0xf178, 0xf179, 0xf17a, 0xf17b, 0xf17c, 0xf17d, 0xf17e,  // Offset: 8c20 ~ 8c27
0xf17f, 0xf180, 0xf181, 0xf182, 0xf183, 0xf184, 0xf185, 0xf186,  // Offset: 8c28 ~ 8c2f
0xf187, 0xf188, 0xf189, 0xf18a, 0xf18b, 0xf18c, 0xf18d, 0xf18e,  // Offset: 8c30 ~ 8c37
0xf18f, 0xf190, 0xf191, 0xf192, 0xf193, 0xf194, 0xf195, 0xf196,  // Offset: 8c38 ~ 8c3f
0xf197, 0xf198, 0xf199, 0xf19a, 0xf19b, 0xf19c, 0xf19d, 0xf19e,  // Offset: 8c40 ~ 8c47
0xf19f, 0xf1a0, 0xf1a1, 0xf1a2, 0xf1a3, 0xf1a4, 0xf1a5, 0xf1a6,  // Offset: 8c48 ~ 8c4f
0xf1a7, 0xf1a8, 0xf1a9, 0xf1aa, 0xf1ab, 0xf1ac, 0xf1ad, 0xf1ae,  // Offset: 8c50 ~ 8c57
0xf1af, 0xf1b0, 0xf1b1, 0xf1b2, 0xf1b3, 0xf1b4, 0xf1b5, 0xf1b6,  // Offset: 8c58 ~ 8c5f
0xf1b7, 0xf1b8, 0xf1b9, 0xf1ba, 0xf1bb, 0xf1bc, 0xf1bd, 0xf1be,  // Offset: 8c60 ~ 8c67
0xf1bf, 0xf1c0, 0xf1c1, 0xf1c2, 0xf1c3, 0xf1c4, 0xf1c5, 0xf1c6,  // Offset: 8c68 ~ 8c6f
0xf1c7, 0xf1c8, 0xf1c9, 0xf1ca, 0xf1cb, 0xf1cc, 0xf1cd, 0xf1ce,  // Offset: 8c70 ~ 8c77
0xf1cf, 0xf1d0, 0xf1d1, 0xf1d2, 0xf1d3, 0xf1d4, 0xf1d5, 0xf1d6,  // Offset: 8c78 ~ 8c7f
0xf1d7, 0xf1d8, 0xf1d9, 0xf1da, 0xf1db, 0xf1dc, 0xf1dd, 0xf1de,  // Offset: 8c80 ~ 8c87
0xf1df, 0xf1e0, 0xf1e1, 0xf1e2, 0xf1e3, 0xf1e4, 0xf1e5, 0xf1e6,  // Offset: 8c88 ~ 8c8f
0xf1e7, 0xf1e8, 0xf1e9, 0xf1ea, 0xf1eb, 0xf1ec, 0xf1ed, 0xf1ee,  // Offset: 8c90 ~ 8c97
0xf1ef, 0xf1f0, 0xf1f1, 0xf1f2, 0xf1f3, 0xf1f4, 0xf1f5, 0xf1f6,  // Offset: 8c98 ~ 8c9f
0xf1f7, 0xf1f8, 0xf1f9, 0xf1fa, 0xf1fb, 0xf1fc, 0xf1fd, 0xf1fe,  // Offset: 8ca0 ~ 8ca7
0xf1ff, 0xf200, 0xf201, 0xf202, 0xf203, 0xf204, 0xf205, 0xf206,  // Offset: 8ca8 ~ 8caf
0xf207, 0xf208, 0xf209, 0xf20a, 0xf20b, 0xf20c, 0xf20d, 0xf20e,  // Offset: 8cb0 ~ 8cb7
0xf20f, 0xf210, 0xf211, 0xf212, 0xf213, 0xf214, 0xf215, 0xf216,  // Offset: 8cb8 ~ 8cbf
0xf217, 0xf218, 0xf219, 0xf21a, 0xf21b, 0xf21c, 0xf21d, 0xf21e,  // Offset: 8cc0 ~ 8cc7
0xf21f, 0xf220, 0xf221, 0xf222, 0xf223, 0xf224, 0xf225, 0xf226,  // Offset: 8cc8 ~ 8ccf
0xf227, 0xf228, 0xf229, 0xf22a, 0xf22b, 0xf22c, 0xf22d, 0xf22e,  // Offset: 8cd0 ~ 8cd7
0xf22f, 0xf230, 0xf231, 0xf232, 0xf233, 0xf234, 0xf235, 0xf236,  // Offset: 8cd8 ~ 8cdf
0xf237, 0xf238, 0xf239, 0xf23a, 0xf23b, 0xf23c, 0xf23d, 0xf23e,  // Offset: 8ce0 ~ 8ce7
0xf23f, 0xf240, 0xf241, 0xf242, 0xf243, 0xf244, 0xf245, 0xf246,  // Offset: 8ce8 ~ 8cef
0xf247, 0xf248, 0xf249, 0xf24a, 0xf24b, 0xf24c, 0xf24d, 0xf24e,  // Offset: 8cf0 ~ 8cf7
0xf24f, 0xf250, 0xf251, 0xf252, 0xf253, 0xf254, 0xf255, 0xf256,  // Offset: 8cf8 ~ 8cff
0xf257, 0xf258, 0xf259, 0xf25a, 0xf25b, 0xf25c, 0xf25d, 0xf25e,  // Offset: 8d00 ~ 8d07
0xf25f, 0xf260, 0xf261, 0xf262, 0xf263, 0xf264, 0xf265, 0xf266,  // Offset: 8d08 ~ 8d0f
0xf267, 0xf268, 0xf269, 0xf26a, 0xf26b, 0xf26c, 0xf26d, 0xf26e,  // Offset: 8d10 ~ 8d17
0xf26f, 0xf270, 0xf271, 0xf272, 0xf273, 0xf274, 0xf275, 0xf276,  // Offset: 8d18 ~ 8d1f
0xf277, 0xf278, 0xf279, 0xf27a, 0xf27b, 0xf27c, 0xf27d, 0xf27e,  // Offset: 8d20 ~ 8d27
0xf27f, 0xf280, 0xf281, 0xf282, 0xf283, 0xf284, 0xf285, 0xf286,  // Offset: 8d28 ~ 8d2f
0xf287, 0xf288, 0xf289, 0xf28a, 0xf28b, 0xf28c, 0xf28d, 0xf28e,  // Offset: 8d30 ~ 8d37
0xf28f, 0xf290, 0xf291, 0xf292, 0xf293, 0xf294, 0xf295, 0xf296,  // Offset: 8d38 ~ 8d3f
0xf297, 0xf298, 0xf299, 0xf29a, 0xf29b, 0xf29c, 0xf29d, 0xf29e,  // Offset: 8d40 ~ 8d47
0xf29f, 0xf2a0, 0xf2a1, 0xf2a2, 0xf2a3, 0xf2a4, 0xf2a5, 0xf2a6,  // Offset: 8d48 ~ 8d4f
0xf2a7, 0xf2a8, 0xf2a9, 0xf2aa, 0xf2ab, 0xf2ac, 0xf2ad, 0xf2ae,  // Offset: 8d50 ~ 8d57
0xf2af, 0xf2b0, 0xf2b1, 0xf2b2, 0xf2b3, 0xf2b4, 0xf2b5, 0xf2b6,  // Offset: 8d58 ~ 8d5f
0xf2b7, 0xf2b8, 0xf2b9, 0xf2ba, 0xf2bb, 0xf2bc, 0xf2bd, 0xf2be,  // Offset: 8d60 ~ 8d67
0xf2bf, 0xf2c0, 0xf2c1, 0xf2c2, 0xf2c3, 0xf2c4, 0xf2c5, 0xf2c6,  // Offset: 8d68 ~ 8d6f
0xf2c7, 0xf2c8, 0xf2c9, 0xf2ca, 0xf2cb, 0xf2cc, 0xf2cd, 0xf2ce,  // Offset: 8d70 ~ 8d77
0xf2cf, 0xf2d0, 0xf2d1, 0xf2d2, 0xf2d3, 0xf2d4, 0xf2d5, 0xf2d6,  // Offset: 8d78 ~ 8d7f
0xf2d7, 0xf2d8, 0xf2d9, 0xf2da, 0xf2db, 0xf2dc, 0xf2dd, 0xf2de,  // Offset: 8d80 ~ 8d87
0xf2df, 0xf2e0, 0xf2e1, 0xf2e2, 0xf2e3, 0xf2e4, 0xf2e5, 0xf2e6,  // Offset: 8d88 ~ 8d8f
0xf2e7, 0xf2e8, 0xf2e9, 0xf2ea, 0xf2eb, 0xf2ec, 0xf2ed, 0xf2ee,  // Offset: 8d90 ~ 8d97
0xf2ef, 0xf2f0, 0xf2f1, 0xf2f2, 0xf2f3, 0xf2f4, 0xf2f5, 0xf2f6,  // Offset: 8d98 ~ 8d9f
0xf2f7, 0xf2f8, 0xf2f9, 0xf2fa, 0xf2fb, 0xf2fc, 0xf2fd, 0xf2fe,  // Offset: 8da0 ~ 8da7
0xf2ff, 0xf300, 0xf301, 0xf302, 0xf303, 0xf304, 0xf305, 0xf306,  // Offset: 8da8 ~ 8daf
0xf307, 0xf308, 0xf309, 0xf30a, 0xf30b, 0xf30c, 0xf30d, 0xf30e,  // Offset: 8db0 ~ 8db7
0xf30f, 0xf310, 0xf311, 0xf312, 0xf313, 0xf314, 0xf315, 0xf316,  // Offset: 8db8 ~ 8dbf
0xf317, 0xf318, 0xf319, 0xf31a, 0xf31b, 0xf31c, 0xf31d, 0xf31e,  // Offset: 8dc0 ~ 8dc7
0xf31f, 0xf320, 0xf321, 0xf322, 0xf323, 0xf324, 0xf325, 0xf326,  // Offset: 8dc8 ~ 8dcf
0xf327, 0xf328, 0xf329, 0xf32a, 0xf32b, 0xf32c, 0xf32d, 0xf32e,  // Offset: 8dd0 ~ 8dd7
0xf32f, 0xf330, 0xf331, 0xf332, 0xf333, 0xf334, 0xf335, 0xf336,  // Offset: 8dd8 ~ 8ddf
0xf337, 0xf338, 0xf339, 0xf33a, 0xf33b, 0xf33c, 0xf33d, 0xf33e,  // Offset: 8de0 ~ 8de7
0xf33f, 0xf340, 0xf341, 0xf342, 0xf343, 0xf344, 0xf345, 0xf346,  // Offset: 8de8 ~ 8def
0xf347, 0xf348, 0xf349, 0xf34a, 0xf34b, 0xf34c, 0xf34d, 0xf34e,  // Offset: 8df0 ~ 8df7
0xf34f, 0xf350, 0xf351, 0xf352, 0xf353, 0xf354, 0xf355, 0xf356,  // Offset: 8df8 ~ 8dff
0xf357, 0xf358, 0xf359, 0xf35a, 0xf35b, 0xf35c, 0xf35d, 0xf35e,  // Offset: 8e00 ~ 8e07
0xf35f, 0xf360, 0xf361, 0xf362, 0xf363, 0xf364, 0xf365, 0xf366,  // Offset: 8e08 ~ 8e0f
0xf367, 0xf368, 0xf369, 0xf36a, 0xf36b, 0xf36c, 0xf36d, 0xf36e,  // Offset: 8e10 ~ 8e17
0xf36f, 0xf370, 0xf371, 0xf372, 0xf373, 0xf374, 0xf375, 0xf376,  // Offset: 8e18 ~ 8e1f
0xf377, 0xf378, 0xf379, 0xf37a, 0xf37b, 0xf37c, 0xf37d, 0xf37e,  // Offset: 8e20 ~ 8e27
0xf37f, 0xf380, 0xf381, 0xf382, 0xf383, 0xf384, 0xf385, 0xf386,  // Offset: 8e28 ~ 8e2f
0xf387, 0xf388, 0xf389, 0xf38a, 0xf38b, 0xf38c, 0xf38d, 0xf38e,  // Offset: 8e30 ~ 8e37
0xf38f, 0xf390, 0xf391, 0xf392, 0xf393, 0xf394, 0xf395, 0xf396,  // Offset: 8e38 ~ 8e3f
0xf397, 0xf398, 0xf399, 0xf39a, 0xf39b, 0xf39c, 0xf39d, 0xf39e,  // Offset: 8e40 ~ 8e47
0xf39f, 0xf3a0, 0xf3a1, 0xf3a2, 0xf3a3, 0xf3a4, 0xf3a5, 0xf3a6,  // Offset: 8e48 ~ 8e4f
0xf3a7, 0xf3a8, 0xf3a9, 0xf3aa, 0xf3ab, 0xf3ac, 0xf3ad, 0xf3ae,  // Offset: 8e50 ~ 8e57
0xf3af, 0xf3b0, 0xf3b1, 0xf3b2, 0xf3b3, 0xf3b4, 0xf3b5, 0xf3b6,  // Offset: 8e58 ~ 8e5f
0xf3b7, 0xf3b8, 0xf3b9, 0xf3ba, 0xf3bb, 0xf3bc, 0xf3bd, 0xf3be,  // Offset: 8e60 ~ 8e67
0xf3bf, 0xf3c0, 0xf3c1, 0xf3c2, 0xf3c3, 0xf3c4, 0xf3c5, 0xf3c6,  // Offset: 8e68 ~ 8e6f
0xf3c7, 0xf3c8, 0xf3c9, 0xf3ca, 0xf3cb, 0xf3cc, 0xf3cd, 0xf3ce,  // Offset: 8e70 ~ 8e77
0xf3cf, 0xf3d0, 0xf3d1, 0xf3d2, 0xf3d3, 0xf3d4, 0xf3d5, 0xf3d6,  // Offset: 8e78 ~ 8e7f
0xf3d7, 0xf3d8, 0xf3d9, 0xf3da, 0xf3db, 0xf3dc, 0xf3dd, 0xf3de,  // Offset: 8e80 ~ 8e87
0xf3df, 0xf3e0, 0xf3e1, 0xf3e2, 0xf3e3, 0xf3e4, 0xf3e5, 0xf3e6,  // Offset: 8e88 ~ 8e8f
0xf3e7, 0xf3e8, 0xf3e9, 0xf3ea, 0xf3eb, 0xf3ec, 0xf3ed, 0xf3ee,  // Offset: 8e90 ~ 8e97
0xf3ef, 0xf3f0, 0xf3f1, 0xf3f2, 0xf3f3, 0xf3f4, 0xf3f5, 0xf3f6,  // Offset: 8e98 ~ 8e9f
0xf3f7, 0xf3f8, 0xf3f9, 0xf3fa, 0xf3fb, 0xf3fc, 0xf3fd, 0xf3fe,  // Offset: 8ea0 ~ 8ea7
0xf3ff, 0xf400, 0xf401, 0xf402, 0xf403, 0xf404, 0xf405, 0xf406,  // Offset: 8ea8 ~ 8eaf
0xf407, 0xf408, 0xf409, 0xf40a, 0xf40b, 0xf40c, 0xf40d, 0xf40e,  // Offset: 8eb0 ~ 8eb7
0xf40f, 0xf410, 0xf411, 0xf412, 0xf413, 0xf414, 0xf415, 0xf416,  // Offset: 8eb8 ~ 8ebf
0xf417, 0xf418, 0xf419, 0xf41a, 0xf41b, 0xf41c, 0xf41d, 0xf41e,  // Offset: 8ec0 ~ 8ec7
0xf41f, 0xf420, 0xf421, 0xf422, 0xf423, 0xf424, 0xf425, 0xf426,  // Offset: 8ec8 ~ 8ecf
0xf427, 0xf428, 0xf429, 0xf42a, 0xf42b, 0xf42c, 0xf42d, 0xf42e,  // Offset: 8ed0 ~ 8ed7
0xf42f, 0xf430, 0xf431, 0xf432, 0xf433, 0xf434, 0xf435, 0xf436,  // Offset: 8ed8 ~ 8edf
0xf437, 0xf438, 0xf439, 0xf43a, 0xf43b, 0xf43c, 0xf43d, 0xf43e,  // Offset: 8ee0 ~ 8ee7
0xf43f, 0xf440, 0xf441, 0xf442, 0xf443, 0xf444, 0xf445, 0xf446,  // Offset: 8ee8 ~ 8eef
0xf447, 0xf448, 0xf449, 0xf44a, 0xf44b, 0xf44c, 0xf44d, 0xf44e,  // Offset: 8ef0 ~ 8ef7
0xf44f, 0xf450, 0xf451, 0xf452, 0xf453, 0xf454, 0xf455, 0xf456,  // Offset: 8ef8 ~ 8eff
0xf457, 0xf458, 0xf459, 0xf45a, 0xf45b, 0xf45c, 0xf45d, 0xf45e,  // Offset: 8f00 ~ 8f07
0xf45f, 0xf460, 0xf461, 0xf462, 0xf463, 0xf464, 0xf465, 0xf466,  // Offset: 8f08 ~ 8f0f
0xf467, 0xf468, 0xf469, 0xf46a, 0xf46b, 0xf46c, 0xf46d, 0xf46e,  // Offset: 8f10 ~ 8f17
0xf46f, 0xf470, 0xf471, 0xf472, 0xf473, 0xf474, 0xf475, 0xf476,  // Offset: 8f18 ~ 8f1f
0xf477, 0xf478, 0xf479, 0xf47a, 0xf47b, 0xf47c, 0xf47d, 0xf47e,  // Offset: 8f20 ~ 8f27
0xf47f, 0xf480, 0xf481, 0xf482, 0xf483, 0xf484, 0xf485, 0xf486,  // Offset: 8f28 ~ 8f2f
0xf487, 0xf488, 0xf489, 0xf48a, 0xf48b, 0xf48c, 0xf48d, 0xf48e,  // Offset: 8f30 ~ 8f37
0xf48f, 0xf490, 0xf491, 0xf492, 0xf493, 0xf494, 0xf495, 0xf496,  // Offset: 8f38 ~ 8f3f
0xf497, 0xf498, 0xf499, 0xf49a, 0xf49b, 0xf49c, 0xf49d, 0xf49e,  // Offset: 8f40 ~ 8f47
0xf49f, 0xf4a0, 0xf4a1, 0xf4a2, 0xf4a3, 0xf4a4, 0xf4a5, 0xf4a6,  // Offset: 8f48 ~ 8f4f
0xf4a7, 0xf4a8, 0xf4a9, 0xf4aa, 0xf4ab, 0xf4ac, 0xf4ad, 0xf4ae,  // Offset: 8f50 ~ 8f57
0xf4af, 0xf4b0, 0xf4b1, 0xf4b2, 0xf4b3, 0xf4b4, 0xf4b5, 0xf4b6,  // Offset: 8f58 ~ 8f5f
0xf4b7, 0xf4b8, 0xf4b9, 0xf4ba, 0xf4bb, 0xf4bc, 0xf4bd, 0xf4be,  // Offset: 8f60 ~ 8f67
0xf4bf, 0xf4c0, 0xf4c1, 0xf4c2, 0xf4c3, 0xf4c4, 0xf4c5, 0xf4c6,  // Offset: 8f68 ~ 8f6f
0xf4c7, 0xf4c8, 0xf4c9, 0xf4ca, 0xf4cb, 0xf4cc, 0xf4cd, 0xf4ce,  // Offset: 8f70 ~ 8f77
0xf4cf, 0xf4d0, 0xf4d1, 0xf4d2, 0xf4d3, 0xf4d4, 0xf4d5, 0xf4d6,  // Offset: 8f78 ~ 8f7f
0xf4d7, 0xf4d8, 0xf4d9, 0xf4da, 0xf4db, 0xf4dc, 0xf4dd, 0xf4de,  // Offset: 8f80 ~ 8f87
0xf4df, 0xf4e0, 0xf4e1, 0xf4e2, 0xf4e3, 0xf4e4, 0xf4e5, 0xf4e6,  // Offset: 8f88 ~ 8f8f
0xf4e7, 0xf4e8, 0xf4e9, 0xf4ea, 0xf4eb, 0xf4ec, 0xf4ed, 0xf4ee,  // Offset: 8f90 ~ 8f97
0xf4ef, 0xf4f0, 0xf4f1, 0xf4f2, 0xf4f3, 0xf4f4, 0xf4f5, 0xf4f6,  // Offset: 8f98 ~ 8f9f
0xf4f7, 0xf4f8, 0xf4f9, 0xf4fa, 0xf4fb, 0xf4fc, 0xf4fd, 0xf4fe,  // Offset: 8fa0 ~ 8fa7
0xf4ff, 0xf500, 0xf501, 0xf502, 0xf503, 0xf504, 0xf505, 0xf506,  // Offset: 8fa8 ~ 8faf
0xf507, 0xf508, 0xf509, 0xf50a, 0xf50b, 0xf50c, 0xf50d, 0xf50e,  // Offset: 8fb0 ~ 8fb7
0xf50f, 0xf510, 0xf511, 0xf512, 0xf513, 0xf514, 0xf515, 0xf516,  // Offset: 8fb8 ~ 8fbf
0xf517, 0xf518, 0xf519, 0xf51a, 0xf51b, 0xf51c, 0xf51d, 0xf51e,  // Offset: 8fc0 ~ 8fc7
0xf51f, 0xf520, 0xf521, 0xf522, 0xf523, 0xf524, 0xf525, 0xf526,  // Offset: 8fc8 ~ 8fcf
0xf527, 0xf528, 0xf529, 0xf52a, 0xf52b, 0xf52c, 0xf52d, 0xf52e,  // Offset: 8fd0 ~ 8fd7
0xf52f, 0xf530, 0xf531, 0xf532, 0xf533, 0xf534, 0xf535, 0xf536,  // Offset: 8fd8 ~ 8fdf
0xf537, 0xf538, 0xf539, 0xf53a, 0xf53b, 0xf53c, 0xf53d, 0xf53e,  // Offset: 8fe0 ~ 8fe7
0xf53f, 0xf540, 0xf541, 0xf542, 0xf543, 0xf544, 0xf545, 0xf546,  // Offset: 8fe8 ~ 8fef
0xf547, 0xf548, 0xf549, 0xf54a, 0xf54b, 0xf54c, 0xf54d, 0xf54e,  // Offset: 8ff0 ~ 8ff7
0xf54f, 0xf550, 0xf551, 0xf552, 0xf553, 0xf554, 0xf555, 0xf556,  // Offset: 8ff8 ~ 8fff
0xf557, 0xf558, 0xf559, 0xf55a, 0xf55b, 0xf55c, 0xf55d, 0xf55e,  // Offset: 9000 ~ 9007
0xf55f, 0xf560, 0xf561, 0xf562, 0xf563, 0xf564, 0xf565, 0xf566,  // Offset: 9008 ~ 900f
0xf567, 0xf568, 0xf569, 0xf56a, 0xf56b, 0xf56c, 0xf56d, 0xf56e,  // Offset: 9010 ~ 9017
0xf56f, 0xf570, 0xf571, 0xf572, 0xf573, 0xf574, 0xf575, 0xf576,  // Offset: 9018 ~ 901f
0xf577, 0xf578, 0xf579, 0xf57a, 0xf57b, 0xf57c, 0xf57d, 0xf57e,  // Offset: 9020 ~ 9027
0xf57f, 0xf580, 0xf581, 0xf582, 0xf583, 0xf584, 0xf585, 0xf586,  // Offset: 9028 ~ 902f
0xf587, 0xf588, 0xf589, 0xf58a, 0xf58b, 0xf58c, 0xf58d, 0xf58e,  // Offset: 9030 ~ 9037
0xf58f, 0xf590, 0xf591, 0xf592, 0xf593, 0xf594, 0xf595, 0xf596,  // Offset: 9038 ~ 903f
0xf597, 0xf598, 0xf599, 0xf59a, 0xf59b, 0xf59c, 0xf59d, 0xf59e,  // Offset: 9040 ~ 9047
0xf59f, 0xf5a0, 0xf5a1, 0xf5a2, 0xf5a3, 0xf5a4, 0xf5a5, 0xf5a6,  // Offset: 9048 ~ 904f
0xf5a7, 0xf5a8, 0xf5a9, 0xf5aa, 0xf5ab, 0xf5ac, 0xf5ad, 0xf5ae,  // Offset: 9050 ~ 9057
0xf5af, 0xf5b0, 0xf5b1, 0xf5b2, 0xf5b3, 0xf5b4, 0xf5b5, 0xf5b6,  // Offset: 9058 ~ 905f
0xf5b7, 0xf5b8, 0xf5b9, 0xf5ba, 0xf5bb, 0xf5bc, 0xf5bd, 0xf5be,  // Offset: 9060 ~ 9067
0xf5bf, 0xf5c0, 0xf5c1, 0xf5c2, 0xf5c3, 0xf5c4, 0xf5c5, 0xf5c6,  // Offset: 9068 ~ 906f
0xf5c7, 0xf5c8, 0xf5c9, 0xf5ca, 0xf5cb, 0xf5cc, 0xf5cd, 0xf5ce,  // Offset: 9070 ~ 9077
0xf5cf, 0xf5d0, 0xf5d1, 0xf5d2, 0xf5d3, 0xf5d4, 0xf5d5, 0xf5d6,  // Offset: 9078 ~ 907f
0xf5d7, 0xf5d8, 0xf5d9, 0xf5da, 0xf5db, 0xf5dc, 0xf5dd, 0xf5de,  // Offset: 9080 ~ 9087
0xf5df, 0xf5e0, 0xf5e1, 0xf5e2, 0xf5e3, 0xf5e4, 0xf5e5, 0xf5e6,  // Offset: 9088 ~ 908f
0xf5e7, 0xf5e8, 0xf5e9, 0xf5ea, 0xf5eb, 0xf5ec, 0xf5ed, 0xf5ee,  // Offset: 9090 ~ 9097
0xf5ef, 0xf5f0, 0xf5f1, 0xf5f2, 0xf5f3, 0xf5f4, 0xf5f5, 0xf5f6,  // Offset: 9098 ~ 909f
0xf5f7, 0xf5f8, 0xf5f9, 0xf5fa, 0xf5fb, 0xf5fc, 0xf5fd, 0xf5fe,  // Offset: 90a0 ~ 90a7
0xf5ff, 0xf600, 0xf601, 0xf602, 0xf603, 0xf604, 0xf605, 0xf606,  // Offset: 90a8 ~ 90af
0xf607, 0xf608, 0xf609, 0xf60a, 0xf60b, 0xf60c, 0xf60d, 0xf60e,  // Offset: 90b0 ~ 90b7
0xf60f, 0xf610, 0xf611, 0xf612, 0xf613, 0xf614, 0xf615, 0xf616,  // Offset: 90b8 ~ 90bf
0xf617, 0xf618, 0xf619, 0xf61a, 0xf61b, 0xf61c, 0xf61d, 0xf61e,  // Offset: 90c0 ~ 90c7
0xf61f, 0xf620, 0xf621, 0xf622, 0xf623, 0xf624, 0xf625, 0xf626,  // Offset: 90c8 ~ 90cf
0xf627, 0xf628, 0xf629, 0xf62a, 0xf62b, 0xf62c, 0xf62d, 0xf62e,  // Offset: 90d0 ~ 90d7
0xf62f, 0xf630, 0xf631, 0xf632, 0xf633, 0xf634, 0xf635, 0xf636,  // Offset: 90d8 ~ 90df
0xf637, 0xf638, 0xf639, 0xf63a, 0xf63b, 0xf63c, 0xf63d, 0xf63e,  // Offset: 90e0 ~ 90e7
0xf63f, 0xf640, 0xf641, 0xf642, 0xf643, 0xf644, 0xf645, 0xf646,  // Offset: 90e8 ~ 90ef
0xf647, 0xf648, 0xf649, 0xf64a, 0xf64b, 0xf64c, 0xf64d, 0xf64e,  // Offset: 90f0 ~ 90f7
0xf64f, 0xf650, 0xf651, 0xf652, 0xf653, 0xf654, 0xf655, 0xf656,  // Offset: 90f8 ~ 90ff
0xf657, 0xf658, 0xf659, 0xf65a, 0xf65b, 0xf65c, 0xf65d, 0xf65e,  // Offset: 9100 ~ 9107
0xf65f, 0xf660, 0xf661, 0xf662, 0xf663, 0xf664, 0xf665, 0xf666,  // Offset: 9108 ~ 910f
0xf667, 0xf668, 0xf669, 0xf66a, 0xf66b, 0xf66c, 0xf66d, 0xf66e,  // Offset: 9110 ~ 9117
0xf66f, 0xf670, 0xf671, 0xf672, 0xf673, 0xf674, 0xf675, 0xf676,  // Offset: 9118 ~ 911f
0xf677, 0xf678, 0xf679, 0xf67a, 0xf67b, 0xf67c, 0xf67d, 0xf67e,  // Offset: 9120 ~ 9127
0xf67f, 0xf680, 0xf681, 0xf682, 0xf683, 0xf684, 0xf685, 0xf686,  // Offset: 9128 ~ 912f
0xf687, 0xf688, 0xf689, 0xf68a, 0xf68b, 0xf68c, 0xf68d, 0xf68e,  // Offset: 9130 ~ 9137
0xf68f, 0xf690, 0xf691, 0xf692, 0xf693, 0xf694, 0xf695, 0xf696,  // Offset: 9138 ~ 913f
0xf697, 0xf698, 0xf699, 0xf69a, 0xf69b, 0xf69c, 0xf69d, 0xf69e,  // Offset: 9140 ~ 9147
0xf69f, 0xf6a0, 0xf6a1, 0xf6a2, 0xf6a3, 0xf6a4, 0xf6a5, 0xf6a6,  // Offset: 9148 ~ 914f
0xf6a7, 0xf6a8, 0xf6a9, 0xf6aa, 0xf6ab, 0xf6ac, 0xf6ad, 0xf6ae,  // Offset: 9150 ~ 9157
0xf6af, 0xf6b0, 0xf6b1, 0xf6b2, 0xf6b3, 0xf6b4, 0xf6b5, 0xf6b6,  // Offset: 9158 ~ 915f
0xf6b7, 0xf6b8, 0xf6b9, 0xf6ba, 0xf6bb, 0xf6bc, 0xf6bd, 0xf6be,  // Offset: 9160 ~ 9167
0xf6bf, 0xf6c0, 0xf6c1, 0xf6c2, 0xf6c3, 0xf6c4, 0xf6c5, 0xf6c6,  // Offset: 9168 ~ 916f
0xf6c7, 0xf6c8, 0xf6c9, 0xf6ca, 0xf6cb, 0xf6cc, 0xf6cd, 0xf6ce,  // Offset: 9170 ~ 9177
0xf6cf, 0xf6d0, 0xf6d1, 0xf6d2, 0xf6d3, 0xf6d4, 0xf6d5, 0xf6d6,  // Offset: 9178 ~ 917f
0xf6d7, 0xf6d8, 0xf6d9, 0xf6da, 0xf6db, 0xf6dc, 0xf6dd, 0xf6de,  // Offset: 9180 ~ 9187
0xf6df, 0xf6e0, 0xf6e1, 0xf6e2, 0xf6e3, 0xf6e4, 0xf6e5, 0xf6e6,  // Offset: 9188 ~ 918f
0xf6e7, 0xf6e8, 0xf6e9, 0xf6ea, 0xf6eb, 0xf6ec, 0xf6ed, 0xf6ee,  // Offset: 9190 ~ 9197
0xf6ef, 0xf6f0, 0xf6f1, 0xf6f2, 0xf6f3, 0xf6f4, 0xf6f5, 0xf6f6,  // Offset: 9198 ~ 919f
0xf6f7, 0xf6f8, 0xf6f9, 0xf6fa, 0xf6fb, 0xf6fc, 0xf6fd, 0xf6fe,  // Offset: 91a0 ~ 91a7
0xf6ff, 0xf700, 0xf701, 0xf702, 0xf703, 0xf704, 0xf705, 0xf706,  // Offset: 91a8 ~ 91af
0xf707, 0xf708, 0xf709, 0xf70a, 0xf70b, 0xf70c, 0xf70d, 0xf70e,  // Offset: 91b0 ~ 91b7
0xf70f, 0xf710, 0xf711, 0xf712, 0xf713, 0xf714, 0xf715, 0xf716,  // Offset: 91b8 ~ 91bf
0xf717, 0xf718, 0xf719, 0xf71a, 0xf71b, 0xf71c, 0xf71d, 0xf71e,  // Offset: 91c0 ~ 91c7
0xf71f, 0xf720, 0xf721, 0xf722, 0xf723, 0xf724, 0xf725, 0xf726,  // Offset: 91c8 ~ 91cf
0xf727, 0xf728, 0xf729, 0xf72a, 0xf72b, 0xf72c, 0xf72d, 0xf72e,  // Offset: 91d0 ~ 91d7
0xf72f, 0xf730, 0xf731, 0xf732, 0xf733, 0xf734, 0xf735, 0xf736,  // Offset: 91d8 ~ 91df
0xf737, 0xf738, 0xf739, 0xf73a, 0xf73b, 0xf73c, 0xf73d, 0xf73e,  // Offset: 91e0 ~ 91e7
0xf73f, 0xf740, 0xf741, 0xf742, 0xf743, 0xf744, 0xf745, 0xf746,  // Offset: 91e8 ~ 91ef
0xf747, 0xf748, 0xf749, 0xf74a, 0xf74b, 0xf74c, 0xf74d, 0xf74e,  // Offset: 91f0 ~ 91f7
0xf74f, 0xf750, 0xf751, 0xf752, 0xf753, 0xf754, 0xf755, 0xf756,  // Offset: 91f8 ~ 91ff
0xf757, 0xf758, 0xf759, 0xf75a, 0xf75b, 0xf75c, 0xf75d, 0xf75e,  // Offset: 9200 ~ 9207
0xf75f, 0xf760, 0xf761, 0xf762, 0xf763, 0xf764, 0xf765, 0xf766,  // Offset: 9208 ~ 920f
0xf767, 0xf768, 0xf769, 0xf76a, 0xf76b, 0xf76c, 0xf76d, 0xf76e,  // Offset: 9210 ~ 9217
0xf76f, 0xf770, 0xf771, 0xf772, 0xf773, 0xf774, 0xf775, 0xf776,  // Offset: 9218 ~ 921f
0xf777, 0xf778, 0xf779, 0xf77a, 0xf77b, 0xf77c, 0xf77d, 0xf77e,  // Offset: 9220 ~ 9227
0xf77f, 0xf780, 0xf781, 0xf782, 0xf783, 0xf784, 0xf785, 0xf786,  // Offset: 9228 ~ 922f
0xf787, 0xf788, 0xf789, 0xf78a, 0xf78b, 0xf78c, 0xf78d, 0xf78e,  // Offset: 9230 ~ 9237
0xf78f, 0xf790, 0xf791, 0xf792, 0xf793, 0xf794, 0xf795, 0xf796,  // Offset: 9238 ~ 923f
0xf797, 0xf798, 0xf799, 0xf79a, 0xf79b, 0xf79c, 0xf79d, 0xf79e,  // Offset: 9240 ~ 9247
0xf79f, 0xf7a0, 0xf7a1, 0xf7a2, 0xf7a3, 0xf7a4, 0xf7a5, 0xf7a6,  // Offset: 9248 ~ 924f
0xf7a7, 0xf7a8, 0xf7a9, 0xf7aa, 0xf7ab, 0xf7ac, 0xf7ad, 0xf7ae,  // Offset: 9250 ~ 9257
0xf7af, 0xf7b0, 0xf7b1, 0xf7b2, 0xf7b3, 0xf7b4, 0xf7b5, 0xf7b6,  // Offset: 9258 ~ 925f
0xf7b7, 0xf7b8, 0xf7b9, 0xf7ba, 0xf7bb, 0xf7bc, 0xf7bd, 0xf7be,  // Offset: 9260 ~ 9267
0xf7bf, 0xf7c0, 0xf7c1, 0xf7c2, 0xf7c3, 0xf7c4, 0xf7c5, 0xf7c6,  // Offset: 9268 ~ 926f
0xf7c7, 0xf7c8, 0xf7c9, 0xf7ca, 0xf7cb, 0xf7cc, 0xf7cd, 0xf7ce,  // Offset: 9270 ~ 9277
0xf7cf, 0xf7d0, 0xf7d1, 0xf7d2, 0xf7d3, 0xf7d4, 0xf7d5, 0xf7d6,  // Offset: 9278 ~ 927f
0xf7d7, 0xf7d8, 0xf7d9, 0xf7da, 0xf7db, 0xf7dc, 0xf7dd, 0xf7de,  // Offset: 9280 ~ 9287
0xf7df, 0xf7e0, 0xf7e1, 0xf7e2, 0xf7e3, 0xf7e4, 0xf7e5, 0xf7e6,  // Offset: 9288 ~ 928f
0xf7e7, 0xf7e8, 0xf7e9, 0xf7ea, 0xf7eb, 0xf7ec, 0xf7ed, 0xf7ee,  // Offset: 9290 ~ 9297
0xf7ef, 0xf7f0, 0xf7f1, 0xf7f2, 0xf7f3, 0xf7f4, 0xf7f5, 0xf7f6,  // Offset: 9298 ~ 929f
0xf7f7, 0xf7f8, 0xf7f9, 0xf7fa, 0xf7fb, 0xf7fc, 0xf7fd, 0xf7fe,  // Offset: 92a0 ~ 92a7
0xf7ff, 0xf800, 0xf801, 0xf802, 0xf803, 0xf804, 0xf805, 0xf806,  // Offset: 92a8 ~ 92af
0xf807, 0xf808, 0xf809, 0xf80a, 0xf80b, 0xf80c, 0xf80d, 0xf80e,  // Offset: 92b0 ~ 92b7
0xf80f, 0xf810, 0xf811, 0xf812, 0xf813, 0xf814, 0xf815, 0xf816,  // Offset: 92b8 ~ 92bf
0xf817, 0xf818, 0xf819, 0xf81a, 0xf81b, 0xf81c, 0xf81d, 0xf81e,  // Offset: 92c0 ~ 92c7
0xf81f, 0xf820, 0xf821, 0xf822, 0xf823, 0xf824, 0xf825, 0xf826,  // Offset: 92c8 ~ 92cf
0xf827, 0xf828, 0xf829, 0xf82a, 0xf82b, 0xf82c, 0xf82d, 0xf82e,  // Offset: 92d0 ~ 92d7
0xf82f, 0xf830, 0xf831, 0xf832, 0xf833, 0xf834, 0xf835, 0xf836,  // Offset: 92d8 ~ 92df
0xf837, 0xf838, 0xf839, 0xf83a, 0xf83b, 0xf83c, 0xf83d, 0xf83e,  // Offset: 92e0 ~ 92e7
0xf83f, 0xf840, 0xf841, 0xf842, 0xf843, 0xf844, 0xf845, 0xf846,  // Offset: 92e8 ~ 92ef
0xf847, 0xf848, 0xf849, 0xf84a, 0xf84b, 0xf84c, 0xf84d, 0xf84e,  // Offset: 92f0 ~ 92f7
0xf84f, 0xf850, 0xf851, 0xf852, 0xf853, 0xf854, 0xf855, 0xf856,  // Offset: 92f8 ~ 92ff
0xf857, 0xf858, 0xf859, 0xf85a, 0xf85b, 0xf85c, 0xf85d, 0xf85e,  // Offset: 9300 ~ 9307
0xf85f, 0xf860, 0xf861, 0xf862, 0xf863, 0xf864, 0xf865, 0xf866,  // Offset: 9308 ~ 930f
0xf867, 0xf868, 0xf869, 0xf86a, 0xf86b, 0xf86c, 0xf86d, 0xf86e,  // Offset: 9310 ~ 9317
0xf86f, 0xf870, 0xf871, 0xf872, 0xf873, 0xf874, 0xf875, 0xf876,  // Offset: 9318 ~ 931f
0xf877, 0xf878, 0xf879, 0xf87a, 0xf87b, 0xf87c, 0xf87d, 0xf87e,  // Offset: 9320 ~ 9327
0xf87f, 0xf880, 0xf881, 0xf882, 0xf883, 0xf884, 0xf885, 0xf886,  // Offset: 9328 ~ 932f
0xf887, 0xf888, 0xf889, 0xf88a, 0xf88b, 0xf88c, 0xf88d, 0xf88e,  // Offset: 9330 ~ 9337
0xf88f, 0xf890, 0xf891, 0xf892, 0xf893, 0xf894, 0xf895, 0xf896,  // Offset: 9338 ~ 933f
0xf897, 0xf898, 0xf899, 0xf89a, 0xf89b, 0xf89c, 0xf89d, 0xf89e,  // Offset: 9340 ~ 9347
0xf89f, 0xf8a0, 0xf8a1, 0xf8a2, 0xf8a3, 0xf8a4, 0xf8a5, 0xf8a6,  // Offset: 9348 ~ 934f
0xf8a7, 0xf8a8, 0xf8a9, 0xf8aa, 0xf8ab, 0xf8ac, 0xf8ad, 0xf8ae,  // Offset: 9350 ~ 9357
0xf8af, 0xf8b0, 0xf8b1, 0xf8b2, 0xf8b3, 0xf8b4, 0xf8b5, 0xf8b6,  // Offset: 9358 ~ 935f
0xf8b7, 0xf8b8, 0xf8b9, 0xf8ba, 0xf8bb, 0xf8bc, 0xf8bd, 0xf8be,  // Offset: 9360 ~ 9367
0xf8bf, 0xf8c0, 0xf8c1, 0xf8c2, 0xf8c3, 0xf8c4, 0xf8c5, 0xf8c6,  // Offset: 9368 ~ 936f
0xf8c7, 0xf8c8, 0xf8c9, 0xf8ca, 0xf8cb, 0xf8cc, 0xf8cd, 0xf8ce,  // Offset: 9370 ~ 9377
0xf8cf, 0xf8d0, 0xf8d1, 0xf8d2, 0xf8d3, 0xf8d4, 0xf8d5, 0xf8d6,  // Offset: 9378 ~ 937f
0xf8d7, 0xf8d8, 0xf8d9, 0xf8da, 0xf8db, 0xf8dc, 0xf8dd, 0xf8de,  // Offset: 9380 ~ 9387
0xf8df, 0xf8e0, 0xf8e1, 0xf8e2, 0xf8e3, 0xf8e4, 0xf8e5, 0xf8e6,  // Offset: 9388 ~ 938f
0xf8e7, 0xf8e8, 0xf8e9, 0xf8ea, 0xf8eb, 0xf8ec, 0xf8ed, 0xf8ee,  // Offset: 9390 ~ 9397
0xf8ef, 0xf8f0, 0xf8f1, 0xf8f2, 0xf8f3, 0xf8f4, 0xf8f5, 0xf8f6,  // Offset: 9398 ~ 939f
0xf8f7, 0xf8f8, 0xf8f9, 0xf8fa, 0xf8fb, 0xf8fc, 0xf8fd, 0xf8fe,  // Offset: 93a0 ~ 93a7
0xf8ff, 0xf900, 0xf901, 0xf902, 0xf903, 0xf904, 0xf905, 0xf906,  // Offset: 93a8 ~ 93af
0xf907, 0xf908, 0xf909, 0xf90a, 0xf90b, 0xf90c, 0xf90d, 0xf90e,  // Offset: 93b0 ~ 93b7
0xf90f, 0xf910, 0xf911, 0xf912, 0xf913, 0xf914, 0xf915, 0xf916,  // Offset: 93b8 ~ 93bf
0xf917, 0xf918, 0xf919, 0xf91a, 0xf91b, 0xf91c, 0xf91d, 0xf91e,  // Offset: 93c0 ~ 93c7
0xf91f, 0xf920, 0xf921, 0xf922, 0xf923, 0xf924, 0xf925, 0xf926,  // Offset: 93c8 ~ 93cf
0xf927, 0xf928, 0xf929, 0xf92a, 0xf92b, 0xf92d, 0xf92e, 0xf92f,  // Offset: 93d0 ~ 93d7
0xf930, 0xf931, 0xf932, 0xf933, 0xf934, 0xf935, 0xf936, 0xf937,  // Offset: 93d8 ~ 93df
0xf938, 0xf939, 0xf93a, 0xf93b, 0xf93c, 0xf93d, 0xf93e, 0xf93f,  // Offset: 93e0 ~ 93e7
0xf940, 0xf941, 0xf942, 0xf943, 0xf944, 0xf945, 0xf946, 0xf947,  // Offset: 93e8 ~ 93ef
0xf948, 0xf949, 0xf94a, 0xf94b, 0xf94c, 0xf94d, 0xf94e, 0xf94f,  // Offset: 93f0 ~ 93f7
0xf950, 0xf951, 0xf952, 0xf953, 0xf954, 0xf955, 0xf956, 0xf957,  // Offset: 93f8 ~ 93ff
0xf958, 0xf959, 0xf95a, 0xf95b, 0xf95c, 0xf95d, 0xf95e, 0xf95f,  // Offset: 9400 ~ 9407
0xf960, 0xf961, 0xf962, 0xf963, 0xf964, 0xf965, 0xf966, 0xf967,  // Offset: 9408 ~ 940f
0xf968, 0xf969, 0xf96a, 0xf96b, 0xf96c, 0xf96d, 0xf96e, 0xf96f,  // Offset: 9410 ~ 9417
0xf970, 0xf971, 0xf972, 0xf973, 0xf974, 0xf975, 0xf976, 0xf977,  // Offset: 9418 ~ 941f
0xf978, 0xf97a, 0xf97b, 0xf97c, 0xf97d, 0xf97e, 0xf97f, 0xf980,  // Offset: 9420 ~ 9427
0xf981, 0xf982, 0xf983, 0xf984, 0xf985, 0xf986, 0xf987, 0xf988,  // Offset: 9428 ~ 942f
0xf989, 0xf98a, 0xf98b, 0xf98c, 0xf98d, 0xf98e, 0xf98f, 0xf990,  // Offset: 9430 ~ 9437
0xf991, 0xf992, 0xf993, 0xf994, 0xf996, 0xf997, 0xf998, 0xf999,  // Offset: 9438 ~ 943f
0xf99a, 0xf99b, 0xf99c, 0xf99d, 0xf99e, 0xf99f, 0xf9a0, 0xf9a1,  // Offset: 9440 ~ 9447
0xf9a2, 0xf9a3, 0xf9a4, 0xf9a5, 0xf9a6, 0xf9a7, 0xf9a8, 0xf9a9,  // Offset: 9448 ~ 944f
0xf9aa, 0xf9ab, 0xf9ac, 0xf9ad, 0xf9ae, 0xf9af, 0xf9b0, 0xf9b1,  // Offset: 9450 ~ 9457
0xf9b2, 0xf9b3, 0xf9b4, 0xf9b5, 0xf9b6, 0xf9b7, 0xf9b8, 0xf9b9,  // Offset: 9458 ~ 945f
0xf9ba, 0xf9bb, 0xf9bc, 0xf9bd, 0xf9be, 0xf9bf, 0xf9c0, 0xf9c1,  // Offset: 9460 ~ 9467
0xf9c2, 0xf9c3, 0xf9c4, 0xf9c5, 0xf9c6, 0xf9c7, 0xf9c8, 0xf9c9,  // Offset: 9468 ~ 946f
0xf9ca, 0xf9cb, 0xf9cc, 0xf9cd, 0xf9ce, 0xf9cf, 0xf9d0, 0xf9d1,  // Offset: 9470 ~ 9477
0xf9d2, 0xf9d3, 0xf9d4, 0xf9d5, 0xf9d6, 0xf9d7, 0xf9d8, 0xf9d9,  // Offset: 9478 ~ 947f
0xf9da, 0xf9db, 0xf9dc, 0xf9dd, 0xf9de, 0xf9df, 0xf9e0, 0xf9e1,  // Offset: 9480 ~ 9487
0xf9e2, 0xf9e3, 0xf9e4, 0xf9e5, 0xf9e6, 0xf9e8, 0xf9e9, 0xf9ea,  // Offset: 9488 ~ 948f
0xf9eb, 0xf9ec, 0xf9ed, 0xf9ee, 0xf9ef, 0xf9f0, 0xf9f2, 0xf9f3,  // Offset: 9490 ~ 9497
0xf9f4, 0xf9f5, 0xf9f6, 0xf9f7, 0xf9f8, 0xf9f9, 0xf9fa, 0xf9fb,  // Offset: 9498 ~ 949f
0xf9fc, 0xf9fd, 0xf9fe, 0xf9ff, 0xfa00, 0xfa01, 0xfa02, 0xfa03,  // Offset: 94a0 ~ 94a7
0xfa04, 0xfa05, 0xfa06, 0xfa07, 0xfa08, 0xfa09, 0xfa0a, 0xfa0b,  // Offset: 94a8 ~ 94af
0xfa10, 0xfa12, 0xfa15, 0xfa16, 0xfa17, 0xfa19, 0xfa1a, 0xfa1b,  // Offset: 94b0 ~ 94b7
0xfa1c, 0xfa1d, 0xfa1e, 0xfa22, 0xfa25, 0xfa26, 0xfa2a, 0xfa2b,  // Offset: 94b8 ~ 94bf
0xfa2c, 0xfa2d, 0xfa2e, 0xfa2f, 0xfa30, 0xfa31, 0xfa32, 0xfa33,  // Offset: 94c0 ~ 94c7
0xfa34, 0xfa35, 0xfa36, 0xfa37, 0xfa38, 0xfa39, 0xfa3a, 0xfa3b,  // Offset: 94c8 ~ 94cf
0xfa3c, 0xfa3d, 0xfa3e, 0xfa3f, 0xfa40, 0xfa41, 0xfa42, 0xfa43,  // Offset: 94d0 ~ 94d7
0xfa44, 0xfa45, 0xfa46, 0xfa47, 0xfa48, 0xfa49, 0xfa4a, 0xfa4b,  // Offset: 94d8 ~ 94df
0xfa4c, 0xfa4d, 0xfa4e, 0xfa4f, 0xfa50, 0xfa51, 0xfa52, 0xfa53,  // Offset: 94e0 ~ 94e7
0xfa54, 0xfa55, 0xfa56, 0xfa57, 0xfa58, 0xfa59, 0xfa5a, 0xfa5b,  // Offset: 94e8 ~ 94ef
0xfa5c, 0xfa5d, 0xfa5e, 0xfa5f, 0xfa60, 0xfa61, 0xfa62, 0xfa63,  // Offset: 94f0 ~ 94f7
0xfa64, 0xfa65, 0xfa66, 0xfa67, 0xfa68, 0xfa69, 0xfa6a, 0xfa6b,  // Offset: 94f8 ~ 94ff
0xfa6c, 0xfa6d, 0xfa6e, 0xfa6f, 0xfa70, 0xfa71, 0xfa72, 0xfa73,  // Offset: 9500 ~ 9507
0xfa74, 0xfa75, 0xfa76, 0xfa77, 0xfa78, 0xfa79, 0xfa7a, 0xfa7b,  // Offset: 9508 ~ 950f
0xfa7c, 0xfa7d, 0xfa7e, 0xfa7f, 0xfa80, 0xfa81, 0xfa82, 0xfa83,  // Offset: 9510 ~ 9517
0xfa84, 0xfa85, 0xfa86, 0xfa87, 0xfa88, 0xfa89, 0xfa8a, 0xfa8b,  // Offset: 9518 ~ 951f
0xfa8c, 0xfa8d, 0xfa8e, 0xfa8f, 0xfa90, 0xfa91, 0xfa92, 0xfa93,  // Offset: 9520 ~ 9527
0xfa94, 0xfa95, 0xfa96, 0xfa97, 0xfa98, 0xfa99, 0xfa9a, 0xfa9b,  // Offset: 9528 ~ 952f
0xfa9c, 0xfa9d, 0xfa9e, 0xfa9f, 0xfaa0, 0xfaa1, 0xfaa2, 0xfaa3,  // Offset: 9530 ~ 9537
0xfaa4, 0xfaa5, 0xfaa6, 0xfaa7, 0xfaa8, 0xfaa9, 0xfaaa, 0xfaab,  // Offset: 9538 ~ 953f
0xfaac, 0xfaad, 0xfaae, 0xfaaf, 0xfab0, 0xfab1, 0xfab2, 0xfab3,  // Offset: 9540 ~ 9547
0xfab4, 0xfab5, 0xfab6, 0xfab7, 0xfab8, 0xfab9, 0xfaba, 0xfabb,  // Offset: 9548 ~ 954f
0xfabc, 0xfabd, 0xfabe, 0xfabf, 0xfac0, 0xfac1, 0xfac2, 0xfac3,  // Offset: 9550 ~ 9557
0xfac4, 0xfac5, 0xfac6, 0xfac7, 0xfac8, 0xfac9, 0xfaca, 0xfacb,  // Offset: 9558 ~ 955f
0xfacc, 0xfacd, 0xface, 0xfacf, 0xfad0, 0xfad1, 0xfad2, 0xfad3,  // Offset: 9560 ~ 9567
0xfad4, 0xfad5, 0xfad6, 0xfad7, 0xfad8, 0xfad9, 0xfada, 0xfadb,  // Offset: 9568 ~ 956f
0xfadc, 0xfadd, 0xfade, 0xfadf, 0xfae0, 0xfae1, 0xfae2, 0xfae3,  // Offset: 9570 ~ 9577
0xfae4, 0xfae5, 0xfae6, 0xfae7, 0xfae8, 0xfae9, 0xfaea, 0xfaeb,  // Offset: 9578 ~ 957f
0xfaec, 0xfaed, 0xfaee, 0xfaef, 0xfaf0, 0xfaf1, 0xfaf2, 0xfaf3,  // Offset: 9580 ~ 9587
0xfaf4, 0xfaf5, 0xfaf6, 0xfaf7, 0xfaf8, 0xfaf9, 0xfafa, 0xfafb,  // Offset: 9588 ~ 958f
0xfafc, 0xfafd, 0xfafe, 0xfaff, 0xfb00, 0xfb01, 0xfb02, 0xfb03,  // Offset: 9590 ~ 9597
0xfb04, 0xfb05, 0xfb06, 0xfb07, 0xfb08, 0xfb09, 0xfb0a, 0xfb0b,  // Offset: 9598 ~ 959f
0xfb0c, 0xfb0d, 0xfb0e, 0xfb0f, 0xfb10, 0xfb11, 0xfb12, 0xfb13,  // Offset: 95a0 ~ 95a7
0xfb14, 0xfb15, 0xfb16, 0xfb17, 0xfb18, 0xfb19, 0xfb1a, 0xfb1b,  // Offset: 95a8 ~ 95af
0xfb1c, 0xfb1d, 0xfb1e, 0xfb1f, 0xfb20, 0xfb21, 0xfb22, 0xfb23,  // Offset: 95b0 ~ 95b7
0xfb24, 0xfb25, 0xfb26, 0xfb27, 0xfb28, 0xfb29, 0xfb2a, 0xfb2b,  // Offset: 95b8 ~ 95bf
0xfb2c, 0xfb2d, 0xfb2e, 0xfb2f, 0xfb30, 0xfb31, 0xfb32, 0xfb33,  // Offset: 95c0 ~ 95c7
0xfb34, 0xfb35, 0xfb36, 0xfb37, 0xfb38, 0xfb39, 0xfb3a, 0xfb3b,  // Offset: 95c8 ~ 95cf
0xfb3c, 0xfb3d, 0xfb3e, 0xfb3f, 0xfb40, 0xfb41, 0xfb42, 0xfb43,  // Offset: 95d0 ~ 95d7
0xfb44, 0xfb45, 0xfb46, 0xfb47, 0xfb48, 0xfb49, 0xfb4a, 0xfb4b,  // Offset: 95d8 ~ 95df
0xfb4c, 0xfb4d, 0xfb4e, 0xfb4f, 0xfb50, 0xfb51, 0xfb52, 0xfb53,  // Offset: 95e0 ~ 95e7
0xfb54, 0xfb55, 0xfb56, 0xfb57, 0xfb58, 0xfb59, 0xfb5a, 0xfb5b,  // Offset: 95e8 ~ 95ef
0xfb5c, 0xfb5d, 0xfb5e, 0xfb5f, 0xfb60, 0xfb61, 0xfb62, 0xfb63,  // Offset: 95f0 ~ 95f7
0xfb64, 0xfb65, 0xfb66, 0xfb67, 0xfb68, 0xfb69, 0xfb6a, 0xfb6b,  // Offset: 95f8 ~ 95ff
0xfb6c, 0xfb6d, 0xfb6e, 0xfb6f, 0xfb70, 0xfb71, 0xfb72, 0xfb73,  // Offset: 9600 ~ 9607
0xfb74, 0xfb75, 0xfb76, 0xfb77, 0xfb78, 0xfb79, 0xfb7a, 0xfb7b,  // Offset: 9608 ~ 960f
0xfb7c, 0xfb7d, 0xfb7e, 0xfb7f, 0xfb80, 0xfb81, 0xfb82, 0xfb83,  // Offset: 9610 ~ 9617
0xfb84, 0xfb85, 0xfb86, 0xfb87, 0xfb88, 0xfb89, 0xfb8a, 0xfb8b,  // Offset: 9618 ~ 961f
0xfb8c, 0xfb8d, 0xfb8e, 0xfb8f, 0xfb90, 0xfb91, 0xfb92, 0xfb93,  // Offset: 9620 ~ 9627
0xfb94, 0xfb95, 0xfb96, 0xfb97, 0xfb98, 0xfb99, 0xfb9a, 0xfb9b,  // Offset: 9628 ~ 962f
0xfb9c, 0xfb9d, 0xfb9e, 0xfb9f, 0xfba0, 0xfba1, 0xfba2, 0xfba3,  // Offset: 9630 ~ 9637
0xfba4, 0xfba5, 0xfba6, 0xfba7, 0xfba8, 0xfba9, 0xfbaa, 0xfbab,  // Offset: 9638 ~ 963f
0xfbac, 0xfbad, 0xfbae, 0xfbaf, 0xfbb0, 0xfbb1, 0xfbb2, 0xfbb3,  // Offset: 9640 ~ 9647
0xfbb4, 0xfbb5, 0xfbb6, 0xfbb7, 0xfbb8, 0xfbb9, 0xfbba, 0xfbbb,  // Offset: 9648 ~ 964f
0xfbbc, 0xfbbd, 0xfbbe, 0xfbbf, 0xfbc0, 0xfbc1, 0xfbc2, 0xfbc3,  // Offset: 9650 ~ 9657
0xfbc4, 0xfbc5, 0xfbc6, 0xfbc7, 0xfbc8, 0xfbc9, 0xfbca, 0xfbcb,  // Offset: 9658 ~ 965f
0xfbcc, 0xfbcd, 0xfbce, 0xfbcf, 0xfbd0, 0xfbd1, 0xfbd2, 0xfbd3,  // Offset: 9660 ~ 9667
0xfbd4, 0xfbd5, 0xfbd6, 0xfbd7, 0xfbd8, 0xfbd9, 0xfbda, 0xfbdb,  // Offset: 9668 ~ 966f
0xfbdc, 0xfbdd, 0xfbde, 0xfbdf, 0xfbe0, 0xfbe1, 0xfbe2, 0xfbe3,  // Offset: 9670 ~ 9677
0xfbe4, 0xfbe5, 0xfbe6, 0xfbe7, 0xfbe8, 0xfbe9, 0xfbea, 0xfbeb,  // Offset: 9678 ~ 967f
0xfbec, 0xfbed, 0xfbee, 0xfbef, 0xfbf0, 0xfbf1, 0xfbf2, 0xfbf3,  // Offset: 9680 ~ 9687
0xfbf4, 0xfbf5, 0xfbf6, 0xfbf7, 0xfbf8, 0xfbf9, 0xfbfa, 0xfbfb,  // Offset: 9688 ~ 968f
0xfbfc, 0xfbfd, 0xfbfe, 0xfbff, 0xfc00, 0xfc01, 0xfc02, 0xfc03,  // Offset: 9690 ~ 9697
0xfc04, 0xfc05, 0xfc06, 0xfc07, 0xfc08, 0xfc09, 0xfc0a, 0xfc0b,  // Offset: 9698 ~ 969f
0xfc0c, 0xfc0d, 0xfc0e, 0xfc0f, 0xfc10, 0xfc11, 0xfc12, 0xfc13,  // Offset: 96a0 ~ 96a7
0xfc14, 0xfc15, 0xfc16, 0xfc17, 0xfc18, 0xfc19, 0xfc1a, 0xfc1b,  // Offset: 96a8 ~ 96af
0xfc1c, 0xfc1d, 0xfc1e, 0xfc1f, 0xfc20, 0xfc21, 0xfc22, 0xfc23,  // Offset: 96b0 ~ 96b7
0xfc24, 0xfc25, 0xfc26, 0xfc27, 0xfc28, 0xfc29, 0xfc2a, 0xfc2b,  // Offset: 96b8 ~ 96bf
0xfc2c, 0xfc2d, 0xfc2e, 0xfc2f, 0xfc30, 0xfc31, 0xfc32, 0xfc33,  // Offset: 96c0 ~ 96c7
0xfc34, 0xfc35, 0xfc36, 0xfc37, 0xfc38, 0xfc39, 0xfc3a, 0xfc3b,  // Offset: 96c8 ~ 96cf
0xfc3c, 0xfc3d, 0xfc3e, 0xfc3f, 0xfc40, 0xfc41, 0xfc42, 0xfc43,  // Offset: 96d0 ~ 96d7
0xfc44, 0xfc45, 0xfc46, 0xfc47, 0xfc48, 0xfc49, 0xfc4a, 0xfc4b,  // Offset: 96d8 ~ 96df
0xfc4c, 0xfc4d, 0xfc4e, 0xfc4f, 0xfc50, 0xfc51, 0xfc52, 0xfc53,  // Offset: 96e0 ~ 96e7
0xfc54, 0xfc55, 0xfc56, 0xfc57, 0xfc58, 0xfc59, 0xfc5a, 0xfc5b,  // Offset: 96e8 ~ 96ef
0xfc5c, 0xfc5d, 0xfc5e, 0xfc5f, 0xfc60, 0xfc61, 0xfc62, 0xfc63,  // Offset: 96f0 ~ 96f7
0xfc64, 0xfc65, 0xfc66, 0xfc67, 0xfc68, 0xfc69, 0xfc6a, 0xfc6b,  // Offset: 96f8 ~ 96ff
0xfc6c, 0xfc6d, 0xfc6e, 0xfc6f, 0xfc70, 0xfc71, 0xfc72, 0xfc73,  // Offset: 9700 ~ 9707
0xfc74, 0xfc75, 0xfc76, 0xfc77, 0xfc78, 0xfc79, 0xfc7a, 0xfc7b,  // Offset: 9708 ~ 970f
0xfc7c, 0xfc7d, 0xfc7e, 0xfc7f, 0xfc80, 0xfc81, 0xfc82, 0xfc83,  // Offset: 9710 ~ 9717
0xfc84, 0xfc85, 0xfc86, 0xfc87, 0xfc88, 0xfc89, 0xfc8a, 0xfc8b,  // Offset: 9718 ~ 971f
0xfc8c, 0xfc8d, 0xfc8e, 0xfc8f, 0xfc90, 0xfc91, 0xfc92, 0xfc93,  // Offset: 9720 ~ 9727
0xfc94, 0xfc95, 0xfc96, 0xfc97, 0xfc98, 0xfc99, 0xfc9a, 0xfc9b,  // Offset: 9728 ~ 972f
0xfc9c, 0xfc9d, 0xfc9e, 0xfc9f, 0xfca0, 0xfca1, 0xfca2, 0xfca3,  // Offset: 9730 ~ 9737
0xfca4, 0xfca5, 0xfca6, 0xfca7, 0xfca8, 0xfca9, 0xfcaa, 0xfcab,  // Offset: 9738 ~ 973f
0xfcac, 0xfcad, 0xfcae, 0xfcaf, 0xfcb0, 0xfcb1, 0xfcb2, 0xfcb3,  // Offset: 9740 ~ 9747
0xfcb4, 0xfcb5, 0xfcb6, 0xfcb7, 0xfcb8, 0xfcb9, 0xfcba, 0xfcbb,  // Offset: 9748 ~ 974f
0xfcbc, 0xfcbd, 0xfcbe, 0xfcbf, 0xfcc0, 0xfcc1, 0xfcc2, 0xfcc3,  // Offset: 9750 ~ 9757
0xfcc4, 0xfcc5, 0xfcc6, 0xfcc7, 0xfcc8, 0xfcc9, 0xfcca, 0xfccb,  // Offset: 9758 ~ 975f
0xfccc, 0xfccd, 0xfcce, 0xfccf, 0xfcd0, 0xfcd1, 0xfcd2, 0xfcd3,  // Offset: 9760 ~ 9767
0xfcd4, 0xfcd5, 0xfcd6, 0xfcd7, 0xfcd8, 0xfcd9, 0xfcda, 0xfcdb,  // Offset: 9768 ~ 976f
0xfcdc, 0xfcdd, 0xfcde, 0xfcdf, 0xfce0, 0xfce1, 0xfce2, 0xfce3,  // Offset: 9770 ~ 9777
0xfce4, 0xfce5, 0xfce6, 0xfce7, 0xfce8, 0xfce9, 0xfcea, 0xfceb,  // Offset: 9778 ~ 977f
0xfcec, 0xfced, 0xfcee, 0xfcef, 0xfcf0, 0xfcf1, 0xfcf2, 0xfcf3,  // Offset: 9780 ~ 9787
0xfcf4, 0xfcf5, 0xfcf6, 0xfcf7, 0xfcf8, 0xfcf9, 0xfcfa, 0xfcfb,  // Offset: 9788 ~ 978f
0xfcfc, 0xfcfd, 0xfcfe, 0xfcff, 0xfd00, 0xfd01, 0xfd02, 0xfd03,  // Offset: 9790 ~ 9797
0xfd04, 0xfd05, 0xfd06, 0xfd07, 0xfd08, 0xfd09, 0xfd0a, 0xfd0b,  // Offset: 9798 ~ 979f
0xfd0c, 0xfd0d, 0xfd0e, 0xfd0f, 0xfd10, 0xfd11, 0xfd12, 0xfd13,  // Offset: 97a0 ~ 97a7
0xfd14, 0xfd15, 0xfd16, 0xfd17, 0xfd18, 0xfd19, 0xfd1a, 0xfd1b,  // Offset: 97a8 ~ 97af
0xfd1c, 0xfd1d, 0xfd1e, 0xfd1f, 0xfd20, 0xfd21, 0xfd22, 0xfd23,  // Offset: 97b0 ~ 97b7
0xfd24, 0xfd25, 0xfd26, 0xfd27, 0xfd28, 0xfd29, 0xfd2a, 0xfd2b,  // Offset: 97b8 ~ 97bf
0xfd2c, 0xfd2d, 0xfd2e, 0xfd2f, 0xfd30, 0xfd31, 0xfd32, 0xfd33,  // Offset: 97c0 ~ 97c7
0xfd34, 0xfd35, 0xfd36, 0xfd37, 0xfd38, 0xfd39, 0xfd3a, 0xfd3b,  // Offset: 97c8 ~ 97cf
0xfd3c, 0xfd3d, 0xfd3e, 0xfd3f, 0xfd40, 0xfd41, 0xfd42, 0xfd43,  // Offset: 97d0 ~ 97d7
0xfd44, 0xfd45, 0xfd46, 0xfd47, 0xfd48, 0xfd49, 0xfd4a, 0xfd4b,  // Offset: 97d8 ~ 97df
0xfd4c, 0xfd4d, 0xfd4e, 0xfd4f, 0xfd50, 0xfd51, 0xfd52, 0xfd53,  // Offset: 97e0 ~ 97e7
0xfd54, 0xfd55, 0xfd56, 0xfd57, 0xfd58, 0xfd59, 0xfd5a, 0xfd5b,  // Offset: 97e8 ~ 97ef
0xfd5c, 0xfd5d, 0xfd5e, 0xfd5f, 0xfd60, 0xfd61, 0xfd62, 0xfd63,  // Offset: 97f0 ~ 97f7
0xfd64, 0xfd65, 0xfd66, 0xfd67, 0xfd68, 0xfd69, 0xfd6a, 0xfd6b,  // Offset: 97f8 ~ 97ff
0xfd6c, 0xfd6d, 0xfd6e, 0xfd6f, 0xfd70, 0xfd71, 0xfd72, 0xfd73,  // Offset: 9800 ~ 9807
0xfd74, 0xfd75, 0xfd76, 0xfd77, 0xfd78, 0xfd79, 0xfd7a, 0xfd7b,  // Offset: 9808 ~ 980f
0xfd7c, 0xfd7d, 0xfd7e, 0xfd7f, 0xfd80, 0xfd81, 0xfd82, 0xfd83,  // Offset: 9810 ~ 9817
0xfd84, 0xfd85, 0xfd86, 0xfd87, 0xfd88, 0xfd89, 0xfd8a, 0xfd8b,  // Offset: 9818 ~ 981f
0xfd8c, 0xfd8d, 0xfd8e, 0xfd8f, 0xfd90, 0xfd91, 0xfd92, 0xfd93,  // Offset: 9820 ~ 9827
0xfd94, 0xfd95, 0xfd96, 0xfd97, 0xfd98, 0xfd99, 0xfd9a, 0xfd9b,  // Offset: 9828 ~ 982f
0xfd9c, 0xfd9d, 0xfd9e, 0xfd9f, 0xfda0, 0xfda1, 0xfda2, 0xfda3,  // Offset: 9830 ~ 9837
0xfda4, 0xfda5, 0xfda6, 0xfda7, 0xfda8, 0xfda9, 0xfdaa, 0xfdab,  // Offset: 9838 ~ 983f
0xfdac, 0xfdad, 0xfdae, 0xfdaf, 0xfdb0, 0xfdb1, 0xfdb2, 0xfdb3,  // Offset: 9840 ~ 9847
0xfdb4, 0xfdb5, 0xfdb6, 0xfdb7, 0xfdb8, 0xfdb9, 0xfdba, 0xfdbb,  // Offset: 9848 ~ 984f
0xfdbc, 0xfdbd, 0xfdbe, 0xfdbf, 0xfdc0, 0xfdc1, 0xfdc2, 0xfdc3,  // Offset: 9850 ~ 9857
0xfdc4, 0xfdc5, 0xfdc6, 0xfdc7, 0xfdc8, 0xfdc9, 0xfdca, 0xfdcb,  // Offset: 9858 ~ 985f
0xfdcc, 0xfdcd, 0xfdce, 0xfdcf, 0xfdd0, 0xfdd1, 0xfdd2, 0xfdd3,  // Offset: 9860 ~ 9867
0xfdd4, 0xfdd5, 0xfdd6, 0xfdd7, 0xfdd8, 0xfdd9, 0xfdda, 0xfddb,  // Offset: 9868 ~ 986f
0xfddc, 0xfddd, 0xfdde, 0xfddf, 0xfde0, 0xfde1, 0xfde2, 0xfde3,  // Offset: 9870 ~ 9877
0xfde4, 0xfde5, 0xfde6, 0xfde7, 0xfde8, 0xfde9, 0xfdea, 0xfdeb,  // Offset: 9878 ~ 987f
0xfdec, 0xfded, 0xfdee, 0xfdef, 0xfdf0, 0xfdf1, 0xfdf2, 0xfdf3,  // Offset: 9880 ~ 9887
0xfdf4, 0xfdf5, 0xfdf6, 0xfdf7, 0xfdf8, 0xfdf9, 0xfdfa, 0xfdfb,  // Offset: 9888 ~ 988f
0xfdfc, 0xfdfd, 0xfdfe, 0xfdff, 0xfe00, 0xfe01, 0xfe02, 0xfe03,  // Offset: 9890 ~ 9897
0xfe04, 0xfe05, 0xfe06, 0xfe07, 0xfe08, 0xfe09, 0xfe0a, 0xfe0b,  // Offset: 9898 ~ 989f
0xfe0c, 0xfe0d, 0xfe0e, 0xfe0f, 0xfe10, 0xfe11, 0xfe12, 0xfe13,  // Offset: 98a0 ~ 98a7
0xfe14, 0xfe15, 0xfe16, 0xfe17, 0xfe18, 0xfe19, 0xfe1a, 0xfe1b,  // Offset: 98a8 ~ 98af
0xfe1c, 0xfe1d, 0xfe1e, 0xfe1f, 0xfe20, 0xfe21, 0xfe22, 0xfe23,  // Offset: 98b0 ~ 98b7
0xfe24, 0xfe25, 0xfe26, 0xfe27, 0xfe28, 0xfe29, 0xfe2a, 0xfe2b,  // Offset: 98b8 ~ 98bf
0xfe2c, 0xfe2d, 0xfe2e, 0xfe2f, 0xfe32, 0xfe45, 0xfe46, 0xfe47,  // Offset: 98c0 ~ 98c7
0xfe48, 0xfe53, 0xfe58, 0xfe67, 0xfe6c, 0xfe6d, 0xfe6e, 0xfe6f,  // Offset: 98c8 ~ 98cf
0xfe70, 0xfe71, 0xfe72, 0xfe73, 0xfe74, 0xfe75, 0xfe76, 0xfe77,  // Offset: 98d0 ~ 98d7
0xfe78, 0xfe79, 0xfe7a, 0xfe7b, 0xfe7c, 0xfe7d, 0xfe7e, 0xfe7f,  // Offset: 98d8 ~ 98df
0xfe80, 0xfe81, 0xfe82, 0xfe83, 0xfe84, 0xfe85, 0xfe86, 0xfe87,  // Offset: 98e0 ~ 98e7
0xfe88, 0xfe89, 0xfe8a, 0xfe8b, 0xfe8c, 0xfe8d, 0xfe8e, 0xfe8f,  // Offset: 98e8 ~ 98ef
0xfe90, 0xfe91, 0xfe92, 0xfe93, 0xfe94, 0xfe95, 0xfe96, 0xfe97,  // Offset: 98f0 ~ 98f7
0xfe98, 0xfe99, 0xfe9a, 0xfe9b, 0xfe9c, 0xfe9d, 0xfe9e, 0xfe9f,  // Offset: 98f8 ~ 98ff
0xfea0, 0xfea1, 0xfea2, 0xfea3, 0xfea4, 0xfea5, 0xfea6, 0xfea7,  // Offset: 9900 ~ 9907
0xfea8, 0xfea9, 0xfeaa, 0xfeab, 0xfeac, 0xfead, 0xfeae, 0xfeaf,  // Offset: 9908 ~ 990f
0xfeb0, 0xfeb1, 0xfeb2, 0xfeb3, 0xfeb4, 0xfeb5, 0xfeb6, 0xfeb7,  // Offset: 9910 ~ 9917
0xfeb8, 0xfeb9, 0xfeba, 0xfebb, 0xfebc, 0xfebd, 0xfebe, 0xfebf,  // Offset: 9918 ~ 991f
0xfec0, 0xfec1, 0xfec2, 0xfec3, 0xfec4, 0xfec5, 0xfec6, 0xfec7,  // Offset: 9920 ~ 9927
0xfec8, 0xfec9, 0xfeca, 0xfecb, 0xfecc, 0xfecd, 0xfece, 0xfecf,  // Offset: 9928 ~ 992f
0xfed0, 0xfed1, 0xfed2, 0xfed3, 0xfed4, 0xfed5, 0xfed6, 0xfed7,  // Offset: 9930 ~ 9937
0xfed8, 0xfed9, 0xfeda, 0xfedb, 0xfedc, 0xfedd, 0xfede, 0xfedf,  // Offset: 9938 ~ 993f
0xfee0, 0xfee1, 0xfee2, 0xfee3, 0xfee4, 0xfee5, 0xfee6, 0xfee7,  // Offset: 9940 ~ 9947
0xfee8, 0xfee9, 0xfeea, 0xfeeb, 0xfeec, 0xfeed, 0xfeee, 0xfeef,  // Offset: 9948 ~ 994f
0xfef0, 0xfef1, 0xfef2, 0xfef3, 0xfef4, 0xfef5, 0xfef6, 0xfef7,  // Offset: 9950 ~ 9957
0xfef8, 0xfef9, 0xfefa, 0xfefb, 0xfefc, 0xfefd, 0xfefe, 0xfeff,  // Offset: 9958 ~ 995f
0xff00, 0xff5f, 0xff60, 0xff61, 0xff62, 0xff63, 0xff64, 0xff65,  // Offset: 9960 ~ 9967
0xff66, 0xff67, 0xff68, 0xff69, 0xff6a, 0xff6b, 0xff6c, 0xff6d,  // Offset: 9968 ~ 996f
0xff6e, 0xff6f, 0xff70, 0xff71, 0xff72, 0xff73, 0xff74, 0xff75,  // Offset: 9970 ~ 9977
0xff76, 0xff77, 0xff78, 0xff79, 0xff7a, 0xff7b, 0xff7c, 0xff7d,  // Offset: 9978 ~ 997f
0xff7e, 0xff7f, 0xff80, 0xff81, 0xff82, 0xff83, 0xff84, 0xff85,  // Offset: 9980 ~ 9987
0xff86, 0xff87, 0xff88, 0xff89, 0xff8a, 0xff8b, 0xff8c, 0xff8d,  // Offset: 9988 ~ 998f
0xff8e, 0xff8f, 0xff90, 0xff91, 0xff92, 0xff93, 0xff94, 0xff95,  // Offset: 9990 ~ 9997
0xff96, 0xff97, 0xff98, 0xff99, 0xff9a, 0xff9b, 0xff9c, 0xff9d,  // Offset: 9998 ~ 999f
0xff9e, 0xff9f, 0xffa0, 0xffa1, 0xffa2, 0xffa3, 0xffa4, 0xffa5,  // Offset: 99a0 ~ 99a7
0xffa6, 0xffa7, 0xffa8, 0xffa9, 0xffaa, 0xffab, 0xffac, 0xffad,  // Offset: 99a8 ~ 99af
0xffae, 0xffaf, 0xffb0, 0xffb1, 0xffb2, 0xffb3, 0xffb4, 0xffb5,  // Offset: 99b0 ~ 99b7
0xffb6, 0xffb7, 0xffb8, 0xffb9, 0xffba, 0xffbb, 0xffbc, 0xffbd,  // Offset: 99b8 ~ 99bf
0xffbe, 0xffbf, 0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc4, 0xffc5,  // Offset: 99c0 ~ 99c7
0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd,  // Offset: 99c8 ~ 99cf
0xffce, 0xffcf, 0xffd0, 0xffd1, 0xffd2, 0xffd3, 0xffd4, 0xffd5,  // Offset: 99d0 ~ 99d7
0xffd6, 0xffd7, 0xffd8, 0xffd9, 0xffda, 0xffdb, 0xffdc, 0xffdd,  // Offset: 99d8 ~ 99df
0xffde, 0xffdf, 0xffe6, 0xffe7, 0xffe8, 0xffe9, 0xffea, 0xffeb,  // Offset: 99e0 ~ 99e7
0xffec, 0xffed, 0xffee, 0xffef, 0xfff0, 0xfff1, 0xfff2, 0xfff3,  // Offset: 99e8 ~ 99ef
0xfff4, 0xfff5, 0xfff6, 0xfff7, 0xfff8, 0xfff9, 0xfffa, 0xfffb,  // Offset: 99f0 ~ 99f7
0xfffc, 0xfffd, 0xfffe, 0xffff, 

};


// The following lead bytes will be converted to different Unicode values compared with GBK:
//    0xa2, 0xa8, 0xa9, 0xfe, 

const WORD g_wGBLeadByteOffset[] =
{

0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte 80 ~ 87
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte 88 ~ 8f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte 90 ~ 97
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte 98 ~ 9f
0x0000, 0x0000, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte a0 ~ a7
0x0200, 0x0300, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte a8 ~ af
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte b0 ~ b7
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte b8 ~ bf
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte c0 ~ c7
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte c8 ~ cf
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte d0 ~ d7
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte d8 ~ df
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte e0 ~ e7
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte e8 ~ ef
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Lead byte f0 ~ f7
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000,   // Lead byte f8 ~ ff
};

const WORD g_wUnicodeFromGBTwoBytes[] =
{

// Lead Byte: 0xa2
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 00 ~ 07
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 08 ~ 0f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 10 ~ 17
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 18 ~ 1f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 20 ~ 27
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 28 ~ 2f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 30 ~ 37
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 38 ~ 3f
0xe526, 0xe527, 0xe528, 0xe529, 0xe52a, 0xe52b, 0xe52c, 0xe52d,   // Trailing byte 40 ~ 47
0xe52e, 0xe52f, 0xe530, 0xe531, 0xe532, 0xe533, 0xe534, 0xe535,   // Trailing byte 48 ~ 4f
0xe536, 0xe537, 0xe538, 0xe539, 0xe53a, 0xe53b, 0xe53c, 0xe53d,   // Trailing byte 50 ~ 57
0xe53e, 0xe53f, 0xe540, 0xe541, 0xe542, 0xe543, 0xe544, 0xe545,   // Trailing byte 58 ~ 5f
0xe546, 0xe547, 0xe548, 0xe549, 0xe54a, 0xe54b, 0xe54c, 0xe54d,   // Trailing byte 60 ~ 67
0xe54e, 0xe54f, 0xe550, 0xe551, 0xe552, 0xe553, 0xe554, 0xe555,   // Trailing byte 68 ~ 6f
0xe556, 0xe557, 0xe558, 0xe559, 0xe55a, 0xe55b, 0xe55c, 0xe55d,   // Trailing byte 70 ~ 77
0xe55e, 0xe55f, 0xe560, 0xe561, 0xe562, 0xe563, 0xe564, 0x0000,   // Trailing byte 78 ~ 7f
0xe565, 0xe566, 0xe567, 0xe568, 0xe569, 0xe56a, 0xe56b, 0xe56c,   // Trailing byte 80 ~ 87
0xe56d, 0xe56e, 0xe56f, 0xe570, 0xe571, 0xe572, 0xe573, 0xe574,   // Trailing byte 88 ~ 8f
0xe575, 0xe576, 0xe577, 0xe578, 0xe579, 0xe57a, 0xe57b, 0xe57c,   // Trailing byte 90 ~ 97
0xe57d, 0xe57e, 0xe57f, 0xe580, 0xe581, 0xe582, 0xe583, 0xe584,   // Trailing byte 98 ~ 9f
0xe585, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176,   // Trailing byte a0 ~ a7
0x2177, 0x2178, 0x2179, 0xe766, 0xe767, 0xe768, 0xe769, 0xe76a,   // Trailing byte a8 ~ af
0xe76b, 0x2488, 0x2489, 0x248a, 0x248b, 0x248c, 0x248d, 0x248e,   // Trailing byte b0 ~ b7
0x248f, 0x2490, 0x2491, 0x2492, 0x2493, 0x2494, 0x2495, 0x2496,   // Trailing byte b8 ~ bf
0x2497, 0x2498, 0x2499, 0x249a, 0x249b, 0x2474, 0x2475, 0x2476,   // Trailing byte c0 ~ c7
0x2477, 0x2478, 0x2479, 0x247a, 0x247b, 0x247c, 0x247d, 0x247e,   // Trailing byte c8 ~ cf
0x247f, 0x2480, 0x2481, 0x2482, 0x2483, 0x2484, 0x2485, 0x2486,   // Trailing byte d0 ~ d7
0x2487, 0x2460, 0x2461, 0x2462, 0x2463, 0x2464, 0x2465, 0x2466,   // Trailing byte d8 ~ df
0x2467, 0x2468, 0x2469, 0x20ac, 0xe76d, 0x3220, 0x3221, 0x3222,   // Trailing byte e0 ~ e7
0x3223, 0x3224, 0x3225, 0x3226, 0x3227, 0x3228, 0x3229, 0xe76e,   // Trailing byte e8 ~ ef
0xe76f, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166,   // Trailing byte f0 ~ f7
0x2167, 0x2168, 0x2169, 0x216a, 0x216b, 0xe770, 0xe771, 0x0000,   // Trailing byte f8 ~ ff

// Lead Byte: 0xa8
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 00 ~ 07
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 08 ~ 0f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 10 ~ 17
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 18 ~ 1f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 20 ~ 27
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 28 ~ 2f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 30 ~ 37
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 38 ~ 3f
0x02ca, 0x02cb, 0x02d9, 0x2013, 0x2015, 0x2025, 0x2035, 0x2105,   // Trailing byte 40 ~ 47
0x2109, 0x2196, 0x2197, 0x2198, 0x2199, 0x2215, 0x221f, 0x2223,   // Trailing byte 48 ~ 4f
0x2252, 0x2266, 0x2267, 0x22bf, 0x2550, 0x2551, 0x2552, 0x2553,   // Trailing byte 50 ~ 57
0x2554, 0x2555, 0x2556, 0x2557, 0x2558, 0x2559, 0x255a, 0x255b,   // Trailing byte 58 ~ 5f
0x255c, 0x255d, 0x255e, 0x255f, 0x2560, 0x2561, 0x2562, 0x2563,   // Trailing byte 60 ~ 67
0x2564, 0x2565, 0x2566, 0x2567, 0x2568, 0x2569, 0x256a, 0x256b,   // Trailing byte 68 ~ 6f
0x256c, 0x256d, 0x256e, 0x256f, 0x2570, 0x2571, 0x2572, 0x2573,   // Trailing byte 70 ~ 77
0x2581, 0x2582, 0x2583, 0x2584, 0x2585, 0x2586, 0x2587, 0x0000,   // Trailing byte 78 ~ 7f
0x2588, 0x2589, 0x258a, 0x258b, 0x258c, 0x258d, 0x258e, 0x258f,   // Trailing byte 80 ~ 87
0x2593, 0x2594, 0x2595, 0x25bc, 0x25bd, 0x25e2, 0x25e3, 0x25e4,   // Trailing byte 88 ~ 8f
0x25e5, 0x2609, 0x2295, 0x3012, 0x301d, 0x301e, 0xe7bc, 0xe7bd,   // Trailing byte 90 ~ 97
0xe7be, 0xe7bf, 0xe7c0, 0xe7c1, 0xe7c2, 0xe7c3, 0xe7c4, 0xe7c5,   // Trailing byte 98 ~ 9f
0xe7c6, 0x0101, 0x00e1, 0x01ce, 0x00e0, 0x0113, 0x00e9, 0x011b,   // Trailing byte a0 ~ a7
0x00e8, 0x012b, 0x00ed, 0x01d0, 0x00ec, 0x014d, 0x00f3, 0x01d2,   // Trailing byte a8 ~ af
0x00f2, 0x016b, 0x00fa, 0x01d4, 0x00f9, 0x01d6, 0x01d8, 0x01da,   // Trailing byte b0 ~ b7
0x01dc, 0x00fc, 0x00ea, 0x0251, 0xe7c7, 0x0144, 0x0148, 0x01f9,   // Trailing byte b8 ~ bf
0x0261, 0xe7c9, 0xe7ca, 0xe7cb, 0xe7cc, 0x3105, 0x3106, 0x3107,   // Trailing byte c0 ~ c7
0x3108, 0x3109, 0x310a, 0x310b, 0x310c, 0x310d, 0x310e, 0x310f,   // Trailing byte c8 ~ cf
0x3110, 0x3111, 0x3112, 0x3113, 0x3114, 0x3115, 0x3116, 0x3117,   // Trailing byte d0 ~ d7
0x3118, 0x3119, 0x311a, 0x311b, 0x311c, 0x311d, 0x311e, 0x311f,   // Trailing byte d8 ~ df
0x3120, 0x3121, 0x3122, 0x3123, 0x3124, 0x3125, 0x3126, 0x3127,   // Trailing byte e0 ~ e7
0x3128, 0x3129, 0xe7cd, 0xe7ce, 0xe7cf, 0xe7d0, 0xe7d1, 0xe7d2,   // Trailing byte e8 ~ ef
0xe7d3, 0xe7d4, 0xe7d5, 0xe7d6, 0xe7d7, 0xe7d8, 0xe7d9, 0xe7da,   // Trailing byte f0 ~ f7
0xe7db, 0xe7dc, 0xe7dd, 0xe7de, 0xe7df, 0xe7e0, 0xe7e1, 0x0000,   // Trailing byte f8 ~ ff

// Lead Byte: 0xa9
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 00 ~ 07
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 08 ~ 0f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 10 ~ 17
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 18 ~ 1f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 20 ~ 27
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 28 ~ 2f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 30 ~ 37
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 38 ~ 3f
0x3021, 0x3022, 0x3023, 0x3024, 0x3025, 0x3026, 0x3027, 0x3028,   // Trailing byte 40 ~ 47
0x3029, 0x32a3, 0x338e, 0x338f, 0x339c, 0x339d, 0x339e, 0x33a1,   // Trailing byte 48 ~ 4f
0x33c4, 0x33ce, 0x33d1, 0x33d2, 0x33d5, 0xfe30, 0xffe2, 0xffe4,   // Trailing byte 50 ~ 57
0xe7e2, 0x2121, 0x3231, 0xe7e3, 0x2010, 0xe7e4, 0xe7e5, 0xe7e6,   // Trailing byte 58 ~ 5f
0x30fc, 0x309b, 0x309c, 0x30fd, 0x30fe, 0x3006, 0x309d, 0x309e,   // Trailing byte 60 ~ 67
0xfe49, 0xfe4a, 0xfe4b, 0xfe4c, 0xfe4d, 0xfe4e, 0xfe4f, 0xfe50,   // Trailing byte 68 ~ 6f
0xfe51, 0xfe52, 0xfe54, 0xfe55, 0xfe56, 0xfe57, 0xfe59, 0xfe5a,   // Trailing byte 70 ~ 77
0xfe5b, 0xfe5c, 0xfe5d, 0xfe5e, 0xfe5f, 0xfe60, 0xfe61, 0x0000,   // Trailing byte 78 ~ 7f
0xfe62, 0xfe63, 0xfe64, 0xfe65, 0xfe66, 0xfe68, 0xfe69, 0xfe6a,   // Trailing byte 80 ~ 87
0xfe6b, 0x303e, 0x2ff0, 0x2ff1, 0x2ff2, 0x2ff3, 0x2ff4, 0x2ff5,   // Trailing byte 88 ~ 8f
0x2ff6, 0x2ff7, 0x2ff8, 0x2ff9, 0x2ffa, 0x2ffb, 0x3007, 0xe7f4,   // Trailing byte 90 ~ 97
0xe7f5, 0xe7f6, 0xe7f7, 0xe7f8, 0xe7f9, 0xe7fa, 0xe7fb, 0xe7fc,   // Trailing byte 98 ~ 9f
0xe7fd, 0xe7fe, 0xe7ff, 0xe800, 0x2500, 0x2501, 0x2502, 0x2503,   // Trailing byte a0 ~ a7
0x2504, 0x2505, 0x2506, 0x2507, 0x2508, 0x2509, 0x250a, 0x250b,   // Trailing byte a8 ~ af
0x250c, 0x250d, 0x250e, 0x250f, 0x2510, 0x2511, 0x2512, 0x2513,   // Trailing byte b0 ~ b7
0x2514, 0x2515, 0x2516, 0x2517, 0x2518, 0x2519, 0x251a, 0x251b,   // Trailing byte b8 ~ bf
0x251c, 0x251d, 0x251e, 0x251f, 0x2520, 0x2521, 0x2522, 0x2523,   // Trailing byte c0 ~ c7
0x2524, 0x2525, 0x2526, 0x2527, 0x2528, 0x2529, 0x252a, 0x252b,   // Trailing byte c8 ~ cf
0x252c, 0x252d, 0x252e, 0x252f, 0x2530, 0x2531, 0x2532, 0x2533,   // Trailing byte d0 ~ d7
0x2534, 0x2535, 0x2536, 0x2537, 0x2538, 0x2539, 0x253a, 0x253b,   // Trailing byte d8 ~ df
0x253c, 0x253d, 0x253e, 0x253f, 0x2540, 0x2541, 0x2542, 0x2543,   // Trailing byte e0 ~ e7
0x2544, 0x2545, 0x2546, 0x2547, 0x2548, 0x2549, 0x254a, 0x254b,   // Trailing byte e8 ~ ef
0xe801, 0xe802, 0xe803, 0xe804, 0xe805, 0xe806, 0xe807, 0xe808,   // Trailing byte f0 ~ f7
0xe809, 0xe80a, 0xe80b, 0xe80c, 0xe80d, 0xe80e, 0xe80f, 0x0000,   // Trailing byte f8 ~ ff

// Lead Byte: 0xfe
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 00 ~ 07
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 08 ~ 0f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 10 ~ 17
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 18 ~ 1f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 20 ~ 27
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 28 ~ 2f
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 30 ~ 37
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,   // Trailing byte 38 ~ 3f
0xfa0c, 0xfa0d, 0xfa0e, 0xfa0f, 0xfa11, 0xfa13, 0xfa14, 0xfa18,   // Trailing byte 40 ~ 47
0xfa1f, 0xfa20, 0xfa21, 0xfa23, 0xfa24, 0xfa27, 0xfa28, 0xfa29,   // Trailing byte 48 ~ 4f
0x2e81, 0xe816, 0xe817, 0xe818, 0x2e84, 0x3473, 0x3447, 0x2e88,   // Trailing byte 50 ~ 57
0x2e8b, 0xe81e, 0x359e, 0x361a, 0x360e, 0x2e8c, 0x2e97, 0x396e,   // Trailing byte 58 ~ 5f
0x3918, 0xe826, 0x39cf, 0x39df, 0x3a73, 0x39d0, 0xe82b, 0xe82c,   // Trailing byte 60 ~ 67
0x3b4e, 0x3c6e, 0x3ce0, 0x2ea7, 0xe831, 0xe832, 0x2eaa, 0x4056,   // Trailing byte 68 ~ 6f
0x415f, 0x2eae, 0x4337, 0x2eb3, 0x2eb6, 0x2eb7, 0xe83b, 0x43b1,   // Trailing byte 70 ~ 77
0x43ac, 0x2ebb, 0x43dd, 0x44d6, 0x4661, 0x464c, 0xe843, 0x0000,   // Trailing byte 78 ~ 7f
0x4723, 0x4729, 0x477c, 0x478d, 0x2eca, 0x4947, 0x497a, 0x497d,   // Trailing byte 80 ~ 87
0x4982, 0x4983, 0x4985, 0x4986, 0x499f, 0x499b, 0x49b7, 0x49b6,   // Trailing byte 88 ~ 8f
0xe854, 0xe855, 0x4ca3, 0x4c9f, 0x4ca0, 0x4ca1, 0x4c77, 0x4ca2,   // Trailing byte 90 ~ 97
0x4d13, 0x4d14, 0x4d15, 0x4d16, 0x4d17, 0x4d18, 0x4d19, 0x4dae,   // Trailing byte 98 ~ 9f
0xe864, 0xe468, 0xe469, 0xe46a, 0xe46b, 0xe46c, 0xe46d, 0xe46e,   // Trailing byte a0 ~ a7
0xe46f, 0xe470, 0xe471, 0xe472, 0xe473, 0xe474, 0xe475, 0xe476,   // Trailing byte a8 ~ af
0xe477, 0xe478, 0xe479, 0xe47a, 0xe47b, 0xe47c, 0xe47d, 0xe47e,   // Trailing byte b0 ~ b7
0xe47f, 0xe480, 0xe481, 0xe482, 0xe483, 0xe484, 0xe485, 0xe486,   // Trailing byte b8 ~ bf
0xe487, 0xe488, 0xe489, 0xe48a, 0xe48b, 0xe48c, 0xe48d, 0xe48e,   // Trailing byte c0 ~ c7
0xe48f, 0xe490, 0xe491, 0xe492, 0xe493, 0xe494, 0xe495, 0xe496,   // Trailing byte c8 ~ cf
0xe497, 0xe498, 0xe499, 0xe49a, 0xe49b, 0xe49c, 0xe49d, 0xe49e,   // Trailing byte d0 ~ d7
0xe49f, 0xe4a0, 0xe4a1, 0xe4a2, 0xe4a3, 0xe4a4, 0xe4a5, 0xe4a6,   // Trailing byte d8 ~ df
0xe4a7, 0xe4a8, 0xe4a9, 0xe4aa, 0xe4ab, 0xe4ac, 0xe4ad, 0xe4ae,   // Trailing byte e0 ~ e7
0xe4af, 0xe4b0, 0xe4b1, 0xe4b2, 0xe4b3, 0xe4b4, 0xe4b5, 0xe4b6,   // Trailing byte e8 ~ ef
0xe4b7, 0xe4b8, 0xe4b9, 0xe4ba, 0xe4bb, 0xe4bc, 0xe4bd, 0xe4be,   // Trailing byte f0 ~ f7
0xe4bf, 0xe4c0, 0xe4c1, 0xe4c2, 0xe4c3, 0xe4c4, 0xe4c5, 0x0000,   // Trailing byte f8 ~ ff

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\iscii\c_iscii.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_iscii.c

Abstract:

    This file contains the main functions for this module.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Revision History:

      2-28-98    KChang    Created.

--*/



////////////////////////////////////////////////////////////////////////////
//
//  Conversions for Ten ISCII codepages
//
//     57002 : Devanagari
//     57003 : Bengali
//     57004 : Tamil
//     57005 : Telugu
//     57006 : Assamese (same as Bengali)
//     57007 : Oriya
//     57008 : Kannada
//     57009 : Malayalam
//     57010 : Gujarati
//     57011 : Punjabi (Gurmukhi)
//
////////////////////////////////////////////////////////////////////////////



//
//  Include Files.
//

#include <share.h>
#include "c_iscii.h"




//
//  Forward Declarations.
//

DWORD MBToWC(
    BYTE   CP,
    LPSTR  lpMultiByteStr,
    int    cchMultiByte,
    LPWSTR lpWideCharStr,
    int    cchWideChar);

DWORD WCToMB(
    BYTE   CP,
    LPWSTR lpWideCharStr,
    int    cchWideChar,
    LPSTR  lpMBStr,
    int    cchMultiByte);





//-------------------------------------------------------------------------//
//                             DLL ENTRY POINT                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  DllEntry
//
//  DLL Entry initialization procedure.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL DllEntry(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
    hModule;
    lpRes;
}





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
////////////////////////////////////////////////////////////////////////////

DWORD NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    BYTE  CP;

    if ((CodePage < 57002) || (CodePage > 57011))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    CP = (BYTE)(CodePage % 100);

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
           memset(lpCPInfo, 0, sizeof(CPINFO));

           lpCPInfo->MaxCharSize    = 4;
           lpCPInfo->DefaultChar[0] = SUB;

           //
           //  The lead-byte does not apply here, leave them all NULL.
           //
           return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            if (cchMultiByte == -1)
            {
                cchMultiByte = strlen(lpMultiByteStr) + 1;
            }

            return (MBToWC( CP,
                            lpMultiByteStr,
                            cchMultiByte,
                            lpWideCharStr,
                            cchWideChar ));
        }
        case ( NLS_CP_WCTOMB ) :
        {
            int cchMBCount;

            if (cchWideChar == -1)
            {
                cchWideChar = wcslen(lpWideCharStr) + 1;
            }

            cchMBCount = WCToMB( CP,
                                 lpWideCharStr,
                                 cchWideChar,
                                 lpMultiByteStr,
                                 cchMultiByte );

            return (cchMBCount);
        }
    }

    //
    //  This shouldn't happen since this function gets called by
    //  the NLS API routines.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}





//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  MBToWC
//
//  This routine does the translations from ISCII to Unicode.
//
////////////////////////////////////////////////////////////////////////////

DWORD MBToWC(
    BYTE   CP,
    LPSTR  lpMultiByteStr,
    int    cchMultiByte,
    LPWSTR lpWideCharStr,
    int    cchWideChar)
{
    BYTE CurCP = CP;
    int ctr;
    int cchWCCount = 0;
    LPWSTR lpWCTempStr;

    //
    //  Allocate a buffer of the appropriate size.
    //  Use sizeof(WCHAR) because size could potentially double if
    //  the buffer contains all halfwidth Katakanas
    //
    lpWCTempStr = (LPWSTR)NLS_ALLOC_MEM(cchMultiByte * sizeof(WCHAR));
    if (lpWCTempStr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }

    for (ctr = 0; ctr < cchMultiByte; ctr++)
    {
        BYTE mb = (BYTE)lpMultiByteStr[ctr];

        if (mb < MB_Beg)
        {
            lpWCTempStr[cchWCCount++] = (WCHAR)mb;
        }
        else if (mb == ATR)
        {
            if (ctr >= (cchMultiByte - 1))
            {
                //
                //  Incomplete ATR.
                //
                lpWCTempStr[cchWCCount++] = SUB;
            }
            else
            {
                BYTE mb1 = (BYTE)lpMultiByteStr[ctr + 1];

                if ((mb1 < 0x40) || (mb1 > 0x4B))
                {
                    lpWCTempStr[cchWCCount++] = SUB;
                }
                else
                {
                    //
                    // Bug #239926   10/29/00 WEIWU
                    // We don't support Roman script transliteration yet.
                    // To avoid invoking NULL table, we treat ATR code 0x41 as 0x40.
                    //
                    if (mb1 == 0x40 || mb1 == 0x41)
                    {
                        CurCP = CP;
                    }
                    else
                    {
                        CurCP = mb1 & 0x0F;
                    }
                    ctr++;
                }
            }
        }
        else
        {
            WCHAR U1  = UniChar(CurCP, mb);
            WCHAR U21 = TwoTo1U(CurCP, mb);

            if (U21 == 0)
            {
                lpWCTempStr[cchWCCount++] = U1;
            }
            else
            {
                //
                //  Possible two MBs to one Unicode.
                //
                if (ctr >= (cchMultiByte - 1))
                {
                    lpWCTempStr[cchWCCount++] = U1;
                }
                else
                {
                    BYTE mb1 = (BYTE)lpMultiByteStr[ctr + 1];

                    if (mb == VIRAMA)
                    {
                        lpWCTempStr[cchWCCount++] = U1;
                        if (mb1 == VIRAMA)
                        {
                            lpWCTempStr[cchWCCount++] = ZWNJ;    // ZWNJ = U+200C
                            ctr++;
                        }
                        else if (mb1 == NUKTA)
                        {
                            lpWCTempStr[cchWCCount++] = ZWJ;     // U+200D
                            ctr++;
                        }
                    }
                    else if ((U21 & 0xf000) == 0)
                    {
                        if (mb1 == SecondByte[1])
                        {
                            //
                            //  NextByte == 0xe9 ?
                            //
                            lpWCTempStr[cchWCCount++] = U21;
                            ctr++;
                        }
                        else
                        {
                            lpWCTempStr[cchWCCount++] = U1;
                        }
                    }
                    else
                    {
                        //
                        //  Devanagari EXT
                        //
                        if (mb1 == ExtMBList[0].mb)                        // 0xf0_0xb8
                        {
                            lpWCTempStr[cchWCCount++] = ExtMBList[0].wc;   // U+0952
                            ctr++;
                        }
                        else if (mb1 == ExtMBList[1].mb)                   // 0xf0_0xbf
                        {
                            lpWCTempStr[cchWCCount++] = ExtMBList[1].wc;   // U+0970
                            ctr++;
                        }
                        else
                        {
                            lpWCTempStr[cchWCCount++] = SUB;
                        }
                    }
                }
            }
        }
    }

    if (cchWideChar)
    {
        if (cchWCCount > cchWideChar)
        {
            //
            //  Output buffer is too small.
            //
            NLS_FREE_MEM(lpWCTempStr);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        wcsncpy(lpWideCharStr, lpWCTempStr, cchWCCount);
    }

    NLS_FREE_MEM(lpWCTempStr);
    return (cchWCCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  WCToMB
//
//  This routine does the translations from Unicode to ISCII.
//
////////////////////////////////////////////////////////////////////////////

DWORD WCToMB(
  BYTE   CP,
  LPWSTR lpWideCharStr,
  int    cchWideChar,
  LPSTR  lpMBStr,
  int    cchMultiByte)
{
    BYTE CurCP = CP;
    int ctr;
    int cchMBCount = 0;
    LPSTR lpMBTmpStr;

    lpMBTmpStr = (LPSTR)NLS_ALLOC_MEM(cchWideChar * 4);
    if (lpMBTmpStr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }

    for (ctr = 0; ctr < cchWideChar; ctr++)
    {
        WCHAR wc = lpWideCharStr[ctr];

        if (wc < (WCHAR)MB_Beg)
        {
            lpMBTmpStr[cchMBCount++] = (BYTE)wc;
        }
        else if ((wc < WC_Beg) || (wc > WC_End))
        {
            lpMBTmpStr[cchMBCount++] = SUB;
        }
        else
        {
            BYTE mb = MBChar(wc);

            if ((Script(wc) != 0) && (Script(wc) != CurCP))
            {
                lpMBTmpStr[cchMBCount++] = (BYTE)ATR;
                CurCP = Script(wc);
                lpMBTmpStr[cchMBCount++] = CurCP | 0x40;
            }

            lpMBTmpStr[cchMBCount++] = mb;

            if (mb == VIRAMA)
            {
                if (ctr < (cchMultiByte - 1))
                {
                    WCHAR wc1 = lpWideCharStr[ctr + 1];

                    if (wc1 == ZWNJ)
                    {
                        lpMBTmpStr[cchMBCount++] = VIRAMA;
                        ctr++;
                    }
                    else if (wc1 == ZWJ)
                    {
                        lpMBTmpStr[cchMBCount++] = NUKTA;
                        ctr++;
                    }
                }
            }
            else if (OneU_2M(wc) != 0)
            {
                lpMBTmpStr[cchMBCount++] = SecondByte[OneU_2M(wc) >> 12];
            }
        }
    }

    if (cchMultiByte)
    {
        if (cchMBCount > cchMultiByte)
        {
            //
            //  Output buffer is too small.
            //
            NLS_FREE_MEM(lpMBTmpStr);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return (0);
        }

        strncpy(lpMBStr, lpMBTmpStr, cchMBCount);
    }

    NLS_FREE_MEM(lpMBTmpStr);
    return (cchMBCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\iso_2022\c_is2022.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_is2022.c

Abstract:

    This file contains the main functions for this module.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Revision History:

    10-30-96    JulieB    Created.

--*/



////////////////////////////////////////////////////////////////////////////
//
//  50220  ISO-2022-JP Japanese JIS X 0202-1984 with no             halfwidth Katakana
//  50221  ISO-2022-JP Japanese JIS X 0202-1984 with <ESC>(I    for halfwidth Katakana
//  50222  ISO-2022-JP Japanese JIS X 0201-1989 with <ESC>(J+SO for halfwidth Katakana
//                                           ;RFC 1468
//
//  50225  ISO-2022-KR Korean KSC-5601-1987  ;RFC 1557
//
//  50227  ISO 2022-CN Traditional Chinese   ;RFC 1922:CNS-11643-1,CNS-11643-2
//  50229  ISO 2022-CN Simplified  Chinese   ;RFC 1922:GB-2312-80
//
//  52936  HZ-GB2312   Simplified  Chinese
//
////////////////////////////////////////////////////////////////////////////



//
//  Include Files.
//

#include <share.h>




//
//  Macro Definitions.
//

#define NLS_CODEPAGE(cp)         (NLS_CP[(cp) % 10])

#define SHIFT_OUT                ((BYTE)0x0E)
#define SHIFT_IN                 ((BYTE)0x0F)
#define ESCAPE                   ((BYTE)0x1B)

#define LEADBYTE_HALFWIDTH       ((BYTE)0x8E)

#define MODE_ASCII               11
#define MODE_HALFWIDTH_KATAKANA  0
#define MODE_JIS_0208            1
#define MODE_JIS_0212            2
#define MODE_KSC_5601            5
#define MODE_HZ                  6
#define MODE_GB_2312             7
#define MODE_CNS_11643_1         9
#define MODE_CNS_11643_2         10




//
//  Global Variables.
//

DWORD NLS_CP[] =
{
   20932,    // 50220  ISO-2022-JP, MODE_HALFWIDTH_KATAKANA
   20932,    // 50221  ISO-2022-JP, MODE_JIS_0208
   20932,    // 50222  ISO-2022-JP, MODE_JIS_0212
   0,
   0,
   20949,    // 50225  ISO-2022-KR, MODE_KSC_5601
   20936,    // 52936  HZ-GB2312,   MODE_HZ
   20936,    // 50227  ISO-2022-CN, MODE_GB_2312
   0,
   20000,    // 50229  ISO-2022-CN, MODE_CNS_11643_1
   20000,    // 50229  ISO-2022-CN, MODE_CNS_11643_2
   0         //                     MODE_ASCII
};




//
//  Forward Declarations.
//

DWORD
ParseMB_CP5022J(
    DWORD CodePage,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount);

DWORD
ParseMB_CP5022_579(
    DWORD CodePage,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount);

DWORD
ParseMB_CP52936(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount);

DWORD
MBToWC_CP5022X(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);

DWORD
MBToWC_CP52936(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar);





//-------------------------------------------------------------------------//
//                             DLL ENTRY POINT                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  DllEntry
//
//  DLL Entry initialization procedure.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL DllEntry(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
    hModule;
    lpRes;
}





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    DWORD NlsCodePage = NLS_CODEPAGE(CodePage);

    if (!IsValidCodePage(NlsCodePage))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
           memset(lpCPInfo, 0, sizeof(CPINFO));

           lpCPInfo->MaxCharSize    = 5;
           lpCPInfo->DefaultChar[0] = 0x3f;

           //
           //  The lead-byte does not apply here, leave them all NULL.
           //
           return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            if (cchMultiByte == -1)
            {
                cchMultiByte = strlen(lpMultiByteStr) + 1;
            }

            switch (CodePage)
            {
                case (50220) :
                case (50221) :
                case (50222) :
                case (50225) :
                case (50227) :
                case (50229) :
                {
                    return (MBToWC_CP5022X( lpMultiByteStr,
                                            cchMultiByte,
                                            lpWideCharStr,
                                            cchWideChar ));
                }
                case (52936) :
                {
                    return (MBToWC_CP52936( lpMultiByteStr,
                                            cchMultiByte,
                                            lpWideCharStr,
                                            cchWideChar ));
                }
            }
            break;
        }
        case ( NLS_CP_WCTOMB ) :
        {
            int cchMBCount;
            LPSTR lpMBNoEscStr;

            if (cchWideChar == -1)
            {
                cchWideChar = wcslen(lpWideCharStr) + 1;
            }

            lpMBNoEscStr = (LPSTR)NLS_ALLOC_MEM(cchWideChar * sizeof(WCHAR));
            if (lpMBNoEscStr == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }

            cchMBCount = WideCharToMultiByte( NlsCodePage,
                                              WC_NO_BEST_FIT_CHARS,
                                              lpWideCharStr,
                                              cchWideChar,
                                              lpMBNoEscStr,
                                              cchWideChar * sizeof(WCHAR),
                                              NULL,
                                              NULL );
            if (cchMBCount != 0)
            {
                switch (CodePage)
                {
                    case (50220) :
                    case (50221) :
                    case (50222) :
                    {
                        cchMBCount = ParseMB_CP5022J( CodePage,
                                                      lpMultiByteStr,
                                                      cchMultiByte,
                                                      lpMBNoEscStr,
                                                      cchMBCount );
                        break;
                    }
                    case (50225) :
                    case (50227) :
                    case (50229) :
                    {
                        cchMBCount = ParseMB_CP5022_579( CodePage,
                                                         lpMultiByteStr,
                                                         cchMultiByte,
                                                         lpMBNoEscStr,
                                                         cchMBCount );
                        break;
                    }
                    case (52936) :
                    {
                        cchMBCount = ParseMB_CP52936( lpMultiByteStr,
                                                      cchMultiByte,
                                                      lpMBNoEscStr,
                                                      cchMBCount );
                        break;
                    }
                }
            }

            NLS_FREE_MEM (lpMBNoEscStr);

            return (cchMBCount);
        }
    }

    //
    //  This shouldn't happen since this function gets called by
    //  the NLS API routines.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}





//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  MBToWC_CP5022X
//
//  This routine does the translations from ISO-2022 to Unicode.
//
////////////////////////////////////////////////////////////////////////////

DWORD MBToWC_CP5022X(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int ctr, cchMBTemp = 0, cchWCCount = 0;
    LPSTR lpMBTempStr, lpMBNoEscStr, lpMBStrStart;
    WORD wMode, wModePrev, wModeSO;
    LPWSTR lpWCTempStr;
    int rc;

    //
    //  Allocate a buffer of the appropriate size.
    //  Use sizeof(WCHAR) because size could potentially double if
    //  the buffer contains all halfwidth Katakanas.
    //
    lpMBStrStart = (LPSTR)NLS_ALLOC_MEM(cchMultiByte * sizeof(WCHAR));
    if (lpMBStrStart == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }

    lpWCTempStr = (LPWSTR)NLS_ALLOC_MEM(cchMultiByte  * sizeof(WCHAR));
    if (lpWCTempStr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }

    if (cchWideChar)
    {
        *lpWideCharStr = 0;
    }

    lpMBTempStr = lpMBNoEscStr = lpMBStrStart;
    wModePrev = wMode = wModeSO = MODE_ASCII;

    //
    //  Remove esc sequence, then convert to Unicode.
    //
    for (ctr = 0; ctr < cchMultiByte;)
    {
        if ((BYTE)lpMultiByteStr[ctr] == ESCAPE)
        {
            wMode = wModeSO = MODE_ASCII;
            if (ctr >= (cchMultiByte - 2))
            {
                //
                //  Incomplete escape sequence.
                //
            }
            else if ((BYTE)lpMultiByteStr[ctr + 1] == '(')
            {
                if ((BYTE)lpMultiByteStr[ctr + 2] == 'B')       // <esc>(B
                {
                    wMode = wModeSO = MODE_ASCII;
                    ctr += 3;
                }
                else if ((BYTE)lpMultiByteStr[ctr + 2] == 'J')  // <esc>(J
                {
                    wMode = MODE_ASCII;
                    wModeSO = MODE_HALFWIDTH_KATAKANA;
                    ctr += 3;
                }
                else if ((BYTE)lpMultiByteStr[ctr + 2] == 'I')  // <esc>(I
                {
                    wMode = wModeSO = MODE_HALFWIDTH_KATAKANA;
                    ctr += 3;
                }
            }
            else if ((BYTE)lpMultiByteStr[ctr + 1] == '$')
            {
                if (((BYTE)lpMultiByteStr[ctr + 2] == '@') ||   // <esc>$@
                    ((BYTE)lpMultiByteStr[ctr + 2] == 'B'))     // <esc>$B
                {
                    wMode = wModeSO = MODE_JIS_0208;
                    ctr += 3;
                }
                else
                {
                    if (ctr >= (cchMultiByte - 3))
                    {
                        //
                        //  Imcomplete escape sequence.
                        //
                    }
                    else if ((BYTE)lpMultiByteStr[ctr + 2] == '(')
                    {
                        if (((BYTE)lpMultiByteStr[ctr + 3] == '@') ||  // <esc>$(@
                            ((BYTE)lpMultiByteStr[ctr + 3] == 'B'))    // <esc>$(B
                        {
                            wMode = wModeSO = MODE_JIS_0208;
                            ctr += 4;
                        }
                        else if ((BYTE)lpMultiByteStr[ctr + 3] == 'D') // <esc>$(D
                        {
                            wMode = wModeSO = MODE_JIS_0212;
                            ctr += 4;
                        }
                    }
                    else if ((BYTE)lpMultiByteStr[ctr + 2] == ')')
                    {
                        if ((BYTE)lpMultiByteStr[ctr + 3] == 'C')      // <esc>$)C
                        {
                            wMode = wModeSO = MODE_KSC_5601;
                            ctr += 4;
                        }
                        else if ((BYTE)lpMultiByteStr[ctr + 3] == 'A') // <esc>$)A
                        {
                            wMode = wModeSO = MODE_GB_2312;
                            ctr += 4;
                        }
                        else if ((BYTE)lpMultiByteStr[ctr + 3] == 'G') // <esc>$)G
                        {
                            wMode = wModeSO = MODE_CNS_11643_1;
                            ctr += 4;
                        }
                    }
                    else if (((BYTE)lpMultiByteStr[ctr + 2] == '*') && // <esc>$*H
                             ((BYTE)lpMultiByteStr[ctr + 3] == 'H'))
                    {
                        wMode = wModeSO = MODE_CNS_11643_2;
                        ctr += 4;
                    }
                }
            }
            else if (lpMultiByteStr[ctr + 1] == '&')
            {
                if (ctr >= (cchMultiByte - 5))
                {
                    //
                    //  Incomplete escape sequence.
                    //
                }
                else if (((BYTE)lpMultiByteStr[ctr + 2] == '@')     &&
                         ((BYTE)lpMultiByteStr[ctr + 3] ==  ESCAPE) &&
                         ((BYTE)lpMultiByteStr[ctr + 4] == '$')     &&
                         ((BYTE)lpMultiByteStr[ctr + 5] == 'B'))
                {
                    wMode = wModeSO = MODE_JIS_0208;
                    ctr += 6;
                }
            }
        }
        else if ((BYTE)lpMultiByteStr[ctr] == SHIFT_OUT)
        {
           wMode = wModeSO;
           ctr++;
        }
        else if ((BYTE)lpMultiByteStr[ctr] == SHIFT_IN)
        {
           wMode = MODE_ASCII;
           ctr++;
        }

        switch (wMode)
        {
            case ( MODE_JIS_0208 ) :
            case ( MODE_KSC_5601 ) :
            case ( MODE_GB_2312 ) :
            case ( MODE_CNS_11643_1 ) :
            {
                //
                //  To handle errors, we need to check:
                //    1. if trailbyte is there
                //    2. if code is valid
                //
                while (lpMultiByteStr[ctr] == SHIFT_OUT)
                {
                    ctr++;
                }

                while ((ctr < (cchMultiByte - 1))      &&
                       (lpMultiByteStr[ctr] != ESCAPE) &&
                       (lpMultiByteStr[ctr] != SHIFT_IN))
                {
                    *lpMBTempStr++ = lpMultiByteStr[ctr++] | 0x80;
                    *lpMBTempStr++ = lpMultiByteStr[ctr++] | 0x80;
                    cchMBTemp += 2;
                }

                break;
            }
            case ( MODE_JIS_0212 ) :
            case ( MODE_CNS_11643_2 ) :
            {
                while (lpMultiByteStr[ctr] == SHIFT_OUT)
                {
                    ctr++;
                }

                while ((ctr < (cchMultiByte - 1))      &&
                       (lpMultiByteStr[ctr] != ESCAPE) &&
                       (lpMultiByteStr[ctr] != SHIFT_IN))
                {
                    *lpMBTempStr++ = lpMultiByteStr[ctr++] | 0x80;
                    *lpMBTempStr++ = lpMultiByteStr[ctr++];
                    cchMBTemp += 2;
                }

                break;
            }
            case ( MODE_HALFWIDTH_KATAKANA ) :
            {
                while (lpMultiByteStr[ctr] == SHIFT_OUT)
                {
                    ctr++;
                }

                while ((ctr < cchMultiByte)            &&
                       (lpMultiByteStr[ctr] != ESCAPE) &&
                       (lpMultiByteStr[ctr] != SHIFT_IN))
                {
                    *lpMBTempStr++ = (BYTE)0x8E;
                    *lpMBTempStr++ = lpMultiByteStr[ctr++] | 0x80;
                    cchMBTemp += 2;
                }

                break;
            }
            default :                  // MODE_ASCII
            {
                while (lpMultiByteStr[ctr] == SHIFT_IN)
                {
                    ctr++;
                }

                while ((ctr < cchMultiByte)            &&
                       (lpMultiByteStr[ctr] != ESCAPE) &&
                       (lpMultiByteStr[ctr] != SHIFT_OUT))
                {
                    *lpMBTempStr++ = lpMultiByteStr[ctr++];
                    cchMBTemp++;
                }
            }
        }

        if (cchMBTemp == 0)
        {
            break;
        }

        rc = MultiByteToWideChar( NLS_CP[wMode],
                                  0,
                                  lpMBNoEscStr,
                                  cchMBTemp,
                                  lpWCTempStr,
                                  cchMultiByte );
        if (cchWideChar)
        {
            if ((cchWCCount + rc) > cchWideChar)
            {
                //
                //  Output buffer is too small.
                //
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                cchWCCount = 0;
                break;
            }
            else
            {
                memcpy( lpWideCharStr + cchWCCount,
                         lpWCTempStr,
                         rc * sizeof(WCHAR) );
            }
        }
        cchWCCount += rc;
        lpMBNoEscStr += cchMBTemp;
        cchMBTemp = 0;
    }

    //
    //  Clean up memory allocations.
    //
    NLS_FREE_MEM(lpMBStrStart);
    NLS_FREE_MEM(lpWCTempStr);

    //
    //  Return the result.
    //
    return (cchWCCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMB_CP5022J
//
//  --> ISO-2022-JP
//
//  for 50220 : convert all halfwidth katakana to fullwidth
//      50221 : use <esc>(I     for halfwidth katakana
//      50222 : use <esc>(J<SO> for halfwidth katakana
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseMB_CP5022J(
    DWORD CodePage,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount)
{
    int ctr, cchMBTemp = 0;
    WORD wMode, wModeSO;
    LPSTR lpMBTempStr;

    static WORD HalfToFullWidthKanaTable[] =
    {
        0xa1a3, // 0x8ea1 : Halfwidth Ideographic Period
        0xa1d6, // 0x8ea2 : Halfwidth Opening Corner Bracket
        0xa1d7, // 0x8ea3 : Halfwidth Closing Corner Bracket
        0xa1a2, // 0x8ea4 : Halfwidth Ideographic Comma
        0xa1a6, // 0x8ea5 : Halfwidth Katakana Middle Dot
        0xa5f2, // 0x8ea6 : Halfwidth Katakana Wo
        0xa5a1, // 0x8ea7 : Halfwidth Katakana Small A
        0xa5a3, // 0x8ea8 : Halfwidth Katakana Small I
        0xa5a5, // 0x8ea9 : Halfwidth Katakana Small U
        0xa5a7, // 0x8eaa : Halfwidth Katakana Small E
        0xa5a9, // 0x8eab : Halfwidth Katakana Small O
        0xa5e3, // 0x8eac : Halfwidth Katakana Small Ya
        0xa5e5, // 0x8ead : Halfwidth Katakana Small Yu
        0xa5e7, // 0x8eae : Halfwidth Katakana Small Yo
        0xa5c3, // 0x8eaf : Halfwidth Katakana Small Tu
        0xa1bc, // 0x8eb0 : Halfwidth Katakana-Hiragana Prolonged Sound Mark
        0xa5a2, // 0x8eb1 : Halfwidth Katakana A
        0xa5a4, // 0x8eb2 : Halfwidth Katakana I
        0xa5a6, // 0x8eb3 : Halfwidth Katakana U
        0xa5a8, // 0x8eb4 : Halfwidth Katakana E
        0xa5aa, // 0x8eb5 : Halfwidth Katakana O
        0xa5ab, // 0x8eb6 : Halfwidth Katakana Ka
        0xa5ad, // 0x8eb7 : Halfwidth Katakana Ki
        0xa5af, // 0x8eb8 : Halfwidth Katakana Ku
        0xa5b1, // 0x8eb9 : Halfwidth Katakana Ke
        0xa5b3, // 0x8eba : Halfwidth Katakana Ko
        0xa5b5, // 0x8ebb : Halfwidth Katakana Sa
        0xa5b7, // 0x8ebc : Halfwidth Katakana Si
        0xa5b9, // 0x8ebd : Halfwidth Katakana Su
        0xa5bb, // 0x8ebe : Halfwidth Katakana Se
        0xa5bd, // 0x8ebf : Halfwidth Katakana So
        0xa5bf, // 0x8ec0 : Halfwidth Katakana Ta
        0xa5c1, // 0x8ec1 : Halfwidth Katakana Ti
        0xa5c4, // 0x8ec2 : Halfwidth Katakana Tu
        0xa5c6, // 0x8ec3 : Halfwidth Katakana Te
        0xa5c8, // 0x8ec4 : Halfwidth Katakana To
        0xa5ca, // 0x8ec5 : Halfwidth Katakana Na
        0xa5cb, // 0x8ec6 : Halfwidth Katakana Ni
        0xa5cc, // 0x8ec7 : Halfwidth Katakana Nu
        0xa5cd, // 0x8ec8 : Halfwidth Katakana Ne
        0xa5ce, // 0x8ec9 : Halfwidth Katakana No
        0xa5cf, // 0x8eca : Halfwidth Katakana Ha
        0xa5d2, // 0x8ecb : Halfwidth Katakana Hi
        0xa5d5, // 0x8ecc : Halfwidth Katakana Hu
        0xa5d8, // 0x8ecd : Halfwidth Katakana He
        0xa5db, // 0x8ece : Halfwidth Katakana Ho
        0xa5de, // 0x8ecf : Halfwidth Katakana Ma
        0xa5df, // 0x8ed0 : Halfwidth Katakana Mi
        0xa5e0, // 0x8ed1 : Halfwidth Katakana Mu
        0xa5e1, // 0x8ed2 : Halfwidth Katakana Me
        0xa5e2, // 0x8ed3 : Halfwidth Katakana Mo
        0xa5e4, // 0x8ed4 : Halfwidth Katakana Ya
        0xa5e6, // 0x8ed5 : Halfwidth Katakana Yu
        0xa5e8, // 0x8ed6 : Halfwidth Katakana Yo
        0xa5e9, // 0x8ed7 : Halfwidth Katakana Ra
        0xa5ea, // 0x8ed8 : Halfwidth Katakana Ri
        0xa5eb, // 0x8ed9 : Halfwidth Katakana Ru
        0xa5ec, // 0x8eda : Halfwidth Katakana Re
        0xa5ed, // 0x8edb : Halfwidth Katakana Ro
        0xa5ef, // 0x8edc : Halfwidth Katakana Wa
        0xa5f3, // 0x8edd : Halfwidth Katakana N
        0xa1ab, // 0x8ede : Halfwidth Katakana Voiced Sound Mark
        0xa1ac  // 0x8edf : Halfwidth Katakana Semi-Voiced Sound Mark
    };

    wMode = wModeSO = MODE_ASCII;

    //
    //  Code page 50220 does not use halfwidth Katakana.
    //  Convert to fullwidth.
    //
    if (CodePage == 50220)
    {
        for (ctr = 0; ctr < cchMBCount; ctr++)
        {
            WORD wFWKana;

            if ((BYTE)lpMBNoEscStr[ctr] == LEADBYTE_HALFWIDTH)
            {
                wFWKana = HalfToFullWidthKanaTable[(BYTE)lpMBNoEscStr[ctr + 1] - 0xA1];
                lpMBNoEscStr[ctr++] = HIBYTE(wFWKana);
                lpMBNoEscStr[ctr]   = LOBYTE(wFWKana);
            }
        }
    }

    lpMBTempStr = lpMultiByteStr;

    for (ctr = 0; ctr < cchMBCount; ctr++)
    {
        if ((BYTE)lpMBNoEscStr[ctr] == LEADBYTE_HALFWIDTH)
        {
            //
            //  It's halfwidth Katakana.
            //
            ctr++;
            if (CodePage == 50222)
            {
                if (wMode != MODE_HALFWIDTH_KATAKANA)
                {
                    if (wModeSO != MODE_HALFWIDTH_KATAKANA)
                    {
                        if (cchMultiByte)
                        {
                            if (cchMBTemp < (cchMultiByte - 2))
                            {
                                *lpMBTempStr++ = ESCAPE;
                                *lpMBTempStr++ = '(';
                                *lpMBTempStr++ = 'J';
                            }
                            else
                            {
                                //
                                //  Output buffer is too small.
                                //
                                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                                return (0);
                            }
                        }
                       cchMBTemp += 3;
                       wModeSO = MODE_HALFWIDTH_KATAKANA;
                    }

                    if (cchMultiByte)
                    {
                        if (cchMBTemp < cchMultiByte)
                        {
                            *lpMBTempStr++ = SHIFT_OUT;
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp++;
                    wMode = MODE_HALFWIDTH_KATAKANA;
                }
            }
            else                  // CodePage = 50221
            {
                if (wMode != MODE_HALFWIDTH_KATAKANA)
                {
                    if (cchMultiByte)
                    {
                        if (cchMBTemp < (cchMultiByte - 2))
                        {
                            *lpMBTempStr++ = ESCAPE;
                            *lpMBTempStr++ = '(';
                            *lpMBTempStr++ = 'I';
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp += 3;
                    wMode = MODE_HALFWIDTH_KATAKANA;
                }
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < cchMultiByte)
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr] & 0x7F;
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            cchMBTemp++;
        }
        else if (IsDBCSLeadByteEx(20932, lpMBNoEscStr[ctr]))
        {
            //
            //  It's a double byte character.
            //
            if (lpMBNoEscStr[ctr + 1] & 0x80)  // JIS X 0208
            {
                if (wMode != MODE_JIS_0208)
                {
                    if (cchMultiByte)
                    {
                        if (cchMBTemp < (cchMultiByte - 2))
                        {
                            *lpMBTempStr++ = ESCAPE;
                            *lpMBTempStr++ = '$';
                            *lpMBTempStr++ = 'B';
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp += 3;
                    wMode = MODE_JIS_0208;
                }
            }
            else                              // JIS X 0212
            {
                if (wMode != MODE_JIS_0212)
                {
                    if (cchMultiByte)
                    {
                        if (cchMBTemp < (cchMultiByte - 3))
                        {
                            *lpMBTempStr++ = ESCAPE;
                            *lpMBTempStr++ = '$';
                            *lpMBTempStr++ = '(';
                            *lpMBTempStr++ = 'D';
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp += 4;
                    wMode = MODE_JIS_0212;
                }
            }

            if (ctr >= (cchMBCount - 1))
            {
                //
                //  Missing trail byte.
                //
                break;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < (cchMultiByte - 1))
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr]     & 0x7F;
                    *lpMBTempStr++ = lpMBNoEscStr[ctr + 1] & 0x7F;
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            ctr++;
            cchMBTemp += 2;
        }
        else                      // Single byte Char
        {
            if (wMode != MODE_ASCII)
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < (cchMultiByte - 2))
                    {
                        *lpMBTempStr++ = ESCAPE;
                        *lpMBTempStr++ = '(';
                        *lpMBTempStr++ = 'B';
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                cchMBTemp += 3;
                wMode = MODE_ASCII;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < cchMultiByte)
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr];
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            cchMBTemp++;
        }
    }

    if (cchMultiByte && (cchMBTemp > cchMultiByte))
    {
        //
        //  Output buffer is too small.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    return (cchMBTemp);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMB_CP5022_579
//
//  KSC --> ISO-2022-KR (CP-50225)
//  GB  --> ISO-2022-CN (CP-50227)
//  CNS --> ISO-2022-CN (CP-50229)
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseMB_CP5022_579(
    DWORD CodePage,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount)
{
    int ctr, cchMBTemp = 0;
    WORD wMode, wModeSO, wModeCP;
    char EscChar;
    LPSTR lpMBTempStr;

    lpMBTempStr = lpMultiByteStr;
    wMode = wModeSO = MODE_ASCII;
    wModeCP = (WORD)(CodePage % 10);
    EscChar = ( wModeCP == MODE_KSC_5601 ? 'C' :
               (wModeCP == MODE_GB_2312  ? 'A' : 'G'));

    for (ctr = 0; ctr < cchMBCount; ctr++)
    {
        if (IsDBCSLeadByteEx(NLS_CODEPAGE(CodePage), lpMBNoEscStr[ctr]))
        {
            //
            //  It's a double byte character.
            //
            if (lpMBNoEscStr[ctr + 1] & 0x80)         // KSC, GB or CNS-1
            {
                if (wModeSO != wModeCP)
                {
                    if (cchMultiByte)
                    {
                        if (cchMBTemp < (cchMultiByte - 3))
                        {
                            *lpMBTempStr++ = ESCAPE;
                            *lpMBTempStr++ = '$';
                            *lpMBTempStr++ = ')';
                            *lpMBTempStr++ = EscChar;
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp += 4;
                    wModeSO = wModeCP;
                }
            }
            else
            {
                //
                //  lpMBNoEscStr[ctr + 1] & 0x80 == 0 indicates CNS-2
                //
                if (wModeSO != MODE_CNS_11643_2)
                {
                    if (cchMultiByte)
                    {
                        if (cchMBTemp < (cchMultiByte - 3))
                        {
                            *lpMBTempStr++ = ESCAPE;
                            *lpMBTempStr++ = '$';
                            *lpMBTempStr++ = '*';
                            *lpMBTempStr++ = 'H';
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            SetLastError(ERROR_INSUFFICIENT_BUFFER);
                            return (0);
                        }
                    }
                    cchMBTemp += 4;
                    wModeSO = MODE_CNS_11643_2;
                }
            }

            if (wMode == MODE_ASCII)
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < cchMultiByte)
                    {
                        *lpMBTempStr++ = SHIFT_OUT;
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                cchMBTemp++;
                wMode = wModeSO;
            }

            if (ctr >= (cchMBCount - 1))
            {
                //
                //  Missing trail byte.
                //
                break;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < (cchMultiByte - 1))
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr]     & 0x7F;
                    *lpMBTempStr++ = lpMBNoEscStr[ctr + 1] & 0x7F;
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            ctr++;
            cchMBTemp += 2;
        }
        else
        {
            //
            //  It's a single byte character.
            //
            if (wMode != MODE_ASCII)
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < cchMultiByte)
                    {
                        *lpMBTempStr++ = SHIFT_IN;
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                cchMBTemp++;
                wMode = MODE_ASCII;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < cchMultiByte)
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr];
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            cchMBTemp++;
        }
    }

    if (cchMultiByte && (cchMBTemp > cchMultiByte))
    {
        //
        //  Output buffer is too small.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    return (cchMBTemp);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMB_CP52936
//
//  GB-2312 --> HZ (CP-52936)
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseMB_CP52936(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPSTR lpMBNoEscStr,
    int cchMBCount)
{
    int ctr, cchMBTemp = 0;
    WORD wMode;
    LPSTR lpMBTempStr;

    lpMBTempStr = lpMultiByteStr;
    wMode = MODE_ASCII;

    for (ctr = 0; ctr < cchMBCount; ctr++)
    {
        if (lpMBNoEscStr[ctr] & 0x80)
        {
            if (wMode != MODE_HZ)
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < (cchMultiByte - 1))
                    {
                        *lpMBTempStr++ = '~';
                        *lpMBTempStr++ = '{';
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                wMode = MODE_HZ;
                cchMBTemp += 2;
            }

            if (ctr >= (cchMBCount - 1))
            {
                //
                //  Missing trail byte.
                //
                break;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < (cchMultiByte - 1))
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr]     & 0x7F;
                    *lpMBTempStr++ = lpMBNoEscStr[ctr + 1] & 0x7F;
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            ctr++;
            cchMBTemp += 2;
        }
        else
        {
            if (wMode != MODE_ASCII)
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < (cchMultiByte - 1))
                    {
                        *lpMBTempStr++ = '~';
                        *lpMBTempStr++ = '}';
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                wMode = MODE_ASCII;
                cchMBTemp += 2;
            }

            if ((BYTE)lpMBNoEscStr[ctr] == '~')
            {
                if (cchMultiByte)
                {
                    if (cchMBTemp < cchMultiByte)
                    {
                        *lpMBTempStr++ = '~';
                    }
                    else
                    {
                        //
                        //  Output buffer is too small.
                        //
                        SetLastError(ERROR_INSUFFICIENT_BUFFER);
                        return (0);
                    }
                }
                cchMBTemp++;
            }

            if (cchMultiByte)
            {
                if (cchMBTemp < cchMultiByte)
                {
                    *lpMBTempStr++ = lpMBNoEscStr[ctr];
                }
                else
                {
                    //
                    //  Output buffer is too small.
                    //
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return (0);
                }
            }
            cchMBTemp++;
        }
    }

    if (cchMultiByte && (cchMBTemp > cchMultiByte))
    {
        //
        //  Output buffer is too small.
        //
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    return (cchMBTemp);
}


////////////////////////////////////////////////////////////////////////////
//
//  MBToWC_CP52936
//
//  HZ (CP-52936) --> Unicode
//
////////////////////////////////////////////////////////////////////////////

DWORD MBToWC_CP52936(
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar)
{
    int ctr, cchMBTemp, cchWCCount;
    WORD wMode;
    LPSTR lpMBNoEscStr;

    lpMBNoEscStr = (LPSTR)NLS_ALLOC_MEM(cchMultiByte * sizeof(WCHAR));
    if (lpMBNoEscStr == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return (0);
    }

    cchMBTemp = 0;
    wMode = MODE_ASCII;

    for (ctr = 0; ctr < cchMultiByte; ctr++)
    {
        if (((BYTE)lpMultiByteStr[ctr] == '~') && (ctr < (cchMultiByte - 1)))
        {
            if ((BYTE)lpMultiByteStr[ctr + 1] == '{')
            {
                wMode = MODE_HZ;
                ctr += 2;
            }
            else if ((BYTE)lpMultiByteStr[ctr + 1] == '}')
            {
                wMode = MODE_ASCII;
                ctr += 2;
            }
            else if ((BYTE)lpMultiByteStr[ctr + 1] == '~')
            {
                ctr++;
            }
            else if (((BYTE)lpMultiByteStr[ctr + 1] == '\\') &&
                     (ctr < (cchMultiByte - 2))              &&
                     (((BYTE)lpMultiByteStr[ctr + 2] == 'n')  ||
                      ((BYTE)lpMultiByteStr[ctr + 2] == 'N' )))
            {
                ctr += 2;
            }
        }

        if (wMode == MODE_HZ)
        {
            if (ctr < (cchMultiByte - 1))
            {
                lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr++] | 0x80;
                lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr]   | 0x80;
            }
        }
        else
        {
            if (ctr < cchMultiByte)
            {
                lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr];
            }
        }
    }

    cchWCCount = MultiByteToWideChar ( 20936,
                                       0,
                                       lpMBNoEscStr,
                                       cchMBTemp,
                                       lpWideCharStr,
                                       cchWideChar );
    NLS_FREE_MEM(lpMBNoEscStr);

    return (cchWCCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\sna_db\c_snadb.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_snadb.c

Abstract:

    This file contains the main functions for this module.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Revision History:

    10-30-96    JulieB    Created.

--*/



////////////////////////////////////////////////////////////////////////////
//
// IBM EBCDIC DBCS from/to Unicode conversions for SNA
//
//  CP#   = Single Byte              + Double Byte
//  ----- = -----------              + -----------
//  50930 =  290 (Katakana Extended) + 300 (Japanese)            calls 20930
//  50931 =  037 (US/Canada)         + 300 (Japanese)            calls 20931
//  50933 =  833 (Korean Extended)   + 834 (Korean)              calls 20933
//  50935 =  836 (Simp-Chinese Ext.) + 837 (Simplified  Chinese) calls 20935
//  50937 =  037 (US/Canada)         + 835 (Traditional Chinese) calls 20937
//  50939 = 1027 (Latin Extended)    + 300 (Japanese)            calls 20939
//
////////////////////////////////////////////////////////////////////////////



//
//  Include Files.
//

#include <share.h>




//
//  Constant Declarations.
//

#define SHIFTOUT       0x0e       // from SBCS to DBCS
#define SHIFTIN        0x0f       // from DBCS to SBCS

#define BOGUSLEADBYTE  0x3f       // prefix SBC to make it DBC

#define INTERNAL_CODEPAGE(cp)  ((cp) - 30000)





//-------------------------------------------------------------------------//
//                             DLL ENTRY POINT                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  DllEntry
//
//  DLL Entry initialization procedure.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL DllEntry(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
    hModule;
    lpRes;
}





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    LPSTR lpMBNoEscStr;
    int cchMBEscStr = 0;
    int ctr, cchMBTemp, cchMBCount, cchWCCount;
    BOOL IsDBCS = FALSE;

    //
    //  Error out if internally needed c_*.nls file is not installed.
    //
    if (!IsValidCodePage(INTERNAL_CODEPAGE(CodePage)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
            memset(lpCPInfo, 0, sizeof(CPINFO));

            lpCPInfo->MaxCharSize    = 3;
            lpCPInfo->DefaultChar[0] = 0x3f;

            //
            //  Lead byte does not apply here, leave them all NULL.
            //
            return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            if (cchMultiByte == -1)
            {
                cchMultiByte = strlen(lpMultiByteStr) + 1;
            }

            //
            //  Each single byte char becomes 2 bytes, so we need a
            //  temporary buffer twice as big.
            //
            if ((lpMBNoEscStr = (LPSTR)NLS_ALLOC_MEM(cchMultiByte << 1)) == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }

            //
            //  Remove all Shift-In & Shift-Out.
            //
            for (ctr = 0, cchMBTemp = 0; ctr < cchMultiByte; ctr++)
            {
                if (lpMultiByteStr[ctr] == SHIFTOUT)
                {
                    IsDBCS = TRUE;
                }
                else if (lpMultiByteStr[ctr] == SHIFTIN)
                {
                    IsDBCS = FALSE;
                }
                else
                {
                    if (IsDBCS)
                    {
                        //
                        //  Double byte char.
                        //
                        if (ctr < (cchMultiByte - 1))
                        {
                            lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr++];
                            lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr];
                        }
                        else
                        {
                            //
                            //  Last char is a lead-byte with no trail-byte,
                            //  so let MultiByteToWideChar take care of it.
                            //
                            break;
                        }
                    }
                    else
                    {
                        //
                        //  Single byte char.
                        //  Prefix it with a bogus lead byte to make it a
                        //  double byte char.  The internal table has been
                        //  arranged accordingly.
                        //
                        lpMBNoEscStr[cchMBTemp++] = BOGUSLEADBYTE;
                        lpMBNoEscStr[cchMBTemp++] = lpMultiByteStr[ctr];
                    }
                }
            }

            cchWCCount = MultiByteToWideChar( INTERNAL_CODEPAGE(CodePage),
                                              0,
                                              lpMBNoEscStr,
                                              cchMBTemp,
                                              lpWideCharStr,
                                              cchWideChar );
            if (cchWCCount == 0)
            {
                SetLastError(ERROR_NO_UNICODE_TRANSLATION);
            }

            NLS_FREE_MEM(lpMBNoEscStr);

            return (cchWCCount);
        }
        case ( NLS_CP_WCTOMB ) :
        {
            if (cchWideChar == -1)
            {
                cchWideChar = wcslen(lpWideCharStr) + 1;
            }

            cchMBTemp = cchWideChar * sizeof(WCHAR);
            lpMBNoEscStr = (LPSTR)NLS_ALLOC_MEM(cchMBTemp);
            if (lpMBNoEscStr == NULL)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return (0);
            }

            //
            //  Convert to an MB string without Shift-In/Out first.
            //
            cchMBCount = WideCharToMultiByte( INTERNAL_CODEPAGE(CodePage),
                                              WC_NO_BEST_FIT_CHARS,
                                              lpWideCharStr,
                                              cchWideChar,
                                              lpMBNoEscStr,
                                              cchMBTemp,
                                              NULL,
                                              NULL );

            /*
               what if (cchMBCount == 0) ?
               might need to add error checking later
            */

            //
            //  Insert Shift-In and Shift-Out as needed and
            //  remove BOGUSLEADBYTE.
            //
            ctr = 0;
            while (ctr < cchMBCount)
            {
                //
                //  See if it's a single byte char.
                //
                if (lpMBNoEscStr[ctr] == BOGUSLEADBYTE)
                {
                    //
                    //  It's a single byte char.
                    //
                    ctr++;
                    if (IsDBCS)
                    {
                        if (cchMultiByte)
                        {
                            if (cchMBEscStr < cchMultiByte)
                            {
                                lpMultiByteStr[cchMBEscStr] = SHIFTIN;
                            }
                            else
                            {
                                //
                                //  Output buffer is too small.
                                //
                                break;
                            }
                        }
                        cchMBEscStr++;
                        IsDBCS = FALSE;
                    }

                    if (cchMultiByte)
                    {
                        if (cchMBEscStr < cchMultiByte)
                        {
                            lpMultiByteStr[cchMBEscStr] = lpMBNoEscStr[ctr];
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            break;
                        }
                    }
                    cchMBEscStr++;
                    ctr++;
                }
                else
                {
                    //
                    //  It's a double byte char.
                    //
                    if (!IsDBCS)
                    {
                        if (cchMultiByte)
                        {
                            if (cchMBEscStr < cchMultiByte)
                            {
                                lpMultiByteStr[cchMBEscStr] = SHIFTOUT;
                            }
                            else
                            {
                                //
                                //  Output buffer is too small.
                                //
                                break;
                            }
                        }
                        cchMBEscStr++;
                        IsDBCS = TRUE;
                    }

                    if (ctr >= (cchMBCount - 1))
                    {
                        //
                        //  Missing trail byte.
                        //
                        break;
                    }

                    if (cchMultiByte)
                    {
                        if (cchMBEscStr < (cchMultiByte - 1))
                        {
                            lpMultiByteStr[cchMBEscStr]     = lpMBNoEscStr[ctr];
                            lpMultiByteStr[cchMBEscStr + 1] = lpMBNoEscStr[ctr + 1];
                        }
                        else
                        {
                            //
                            //  Output buffer is too small.
                            //
                            break;
                        }
                    }
                    cchMBEscStr += 2;
                    ctr += 2;
                }
            }

            NLS_FREE_MEM(lpMBNoEscStr);

            //
            //  See if the output buffer is too small.
            //
            if ((cchMultiByte > 0) && (cchMBEscStr > cchMultiByte))
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return (0);
            }

            return (cchMBEscStr);
        }
    }

    //
    //  This shouldn't happen since this is called by the NLS APIs.
    //
    SetLastError(ERROR_INVALID_PARAMETER);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\template\c_other.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    c_other.c

Abstract:

    This file contains the main functions for this module.

    External Routines in this file:
      DllEntry
      NlsDllCodePageTranslation

Revision History:

    10-30-96    JulieB    Created.

--*/



//
//  Include Files.
//

#include <share.h>




//
//  Global Variables.
//




//
//  Forward Declarations.
//

DWORD
TranslateCP_50000(
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo);





//-------------------------------------------------------------------------//
//                             DLL ENTRY POINT                             //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  DllEntry
//
//  DLL Entry initialization procedure.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL DllEntry(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
    hModule;
    lpRes;
}





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  NlsDllCodePageTranslation
//
//  This routine is the main exported procedure for the functionality in
//  this DLL.  All calls to this DLL must go through this function.
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD NlsDllCodePageTranslation(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    switch (CodePage)
    {
        case ( 50000 ) :
        {
            return ( TranslateCP_50000( dwFlags,
                                        lpMultiByteStr,
                                        cchMultiByte,
                                        lpWideCharStr,
                                        cchWideChar,
                                        lpCPInfo ) );
        }
        default :
        {
            //
            //  Invalid code page value.
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
}





//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  TranslateCP_50000
//
//  This routine does the translations for code page 50000.
//
//      ****  This is a BOGUS routine - for testing purposes only.  ****
//
//  10-30-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

DWORD TranslateCP_50000(
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo)
{
    int ctr;

    switch (dwFlags)
    {
        case ( NLS_CP_CPINFO ) :
        {
            lpCPInfo->MaxCharSize = 1;

            lpCPInfo->DefaultChar[0] = '?';
            lpCPInfo->DefaultChar[1] = (BYTE)0;

            for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
            {
                lpCPInfo->LeadByte[ctr] = 0;
            }

            return (TRUE);
        }
        case ( NLS_CP_MBTOWC ) :
        {
            if (cchWideChar == 0)
            {
                return (cchMultiByte);
            }

            for (ctr = 0; (ctr < cchMultiByte) && (ctr < cchWideChar); ctr++)
            {
                lpWideCharStr[ctr] = (WORD)(lpMultiByteStr[ctr]);
            }

            return (ctr);
        }
        case ( NLS_CP_WCTOMB ) :
        {
            if (cchMultiByte == 0)
            {
                return (cchWideChar);
            }

            for (ctr = 0; (ctr < cchWideChar) && (ctr < cchMultiByte); ctr++)
            {
                lpMultiByteStr[ctr] = LOBYTE(lpWideCharStr[ctr]);
            }

            return (ctr);
        }
        default :
        {
            //
            //  This shouldn't happen since this function gets called by
            //  the NLS API routines.
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return (0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\convert.cpp ===
// convert.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "tchar.h"
#include "stdio.h"

#include "convert.h"
#include "convertDlg.h"
#include "FileConv.h"
#include "Msg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL CConvertApp::CommandLineHandle()
{
    // GBTOUNIC.EXE [/U] [/G] [/?] [/H] Filename1 [Filename2]
    //  If Filename2 is not provided, the tool should create a file named 
    //  Filename1.old as the copy of Filename1, and perform the appropriate 
    //  conversion from Filename1.old to Filename1, 
    //  Filename1 as the final converted destination file.
    //
    //  /U or /u performing GB18030 to Unicode conversion
    //  /G or /g performing Unicode to GB18030 conversion
    //  /H or /? Displaying help message.

    TCHAR* tszFlag = NULL;

    TCHAR* tszSrc = NULL;
    CString strTar;
    BOOL fAnsiToUnicode;
    BOOL fRet = FALSE;
    FILE* pFile = NULL;

    if (__argc > 4 || __argc < 3) {
        MsgUsage();
        goto Exit;
    }
    
    tszFlag = __targv[1];
    
    if (*tszFlag != TEXT('-') && *tszFlag != TEXT('/')) {
        MsgUsage();
        goto Exit;
    }
    if (lstrlen(tszFlag) != 2) {
        MsgUsage();
        goto Exit;
    }
    
    // Convert direct
    if (tszFlag[1] == TEXT('U') || tszFlag[1] == TEXT('u')) {
        fAnsiToUnicode = TRUE;
    } else if (tszFlag[1] == TEXT('G') || tszFlag[1] == TEXT('g')) {
        fAnsiToUnicode = FALSE;
    } else {
        MsgUsage();
        goto Exit;
    }

    tszSrc = __targv[2];
/*
    pFile = _tfopen(tszSrc, TEXT("r"));
    if (!pFile) {
        MsgOpenSourceFileError(tszSrc);
        return FALSE;
    }
    fclose(pFile);
*/
    // Source and Target file name
    if (__argc == 3) {  
/*
        // Hasn't give target file name
        //  Save source file set target file name
        tszBuf = new TCHAR[lstrlen(tszSrc) + 5];   // 5, sizeof(TEXT(".old"))/sizeof(TCHAR)
        lstrcpy(tszBuf, tszSrc);
        lstrcat(tszBuf, TEXT(".old"));
        
        BOOL f = CopyFile (tszSrc, tszBuf, TRUE);
        if (f) {
            tszTar = tszSrc;
            tszSrc = tszBuf;
        } else {
            MsgFailToBackupFile(tszSrc, tszBuf);
            goto Exit;
        }
*/
        GenerateTargetFileName(tszSrc, &strTar, fAnsiToUnicode);
    } else if (__argc == 4) {
        strTar = __targv[3];
    } else {
        ASSERT(FALSE);
    }
    
    fRet = Convert(tszSrc, strTar, fAnsiToUnicode);

Exit:
/*
    if (tszBuf) {
        delete tszBuf;
        tszBuf = NULL;
    }
*/
    return fRet;
}


/////////////////////////////////////////////////////////////////////////////
// CConvertApp

BEGIN_MESSAGE_MAP(CConvertApp, CWinApp)
	//{{AFX_MSG_MAP(CConvertApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertApp construction

CConvertApp::CConvertApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CConvertApp object

CConvertApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CConvertApp initialization

BOOL CConvertApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    if (__argc >= 2) {
        CommandLineHandle();
        return FALSE;
    }

    CConvertDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\conveng.cpp ===
#include "stdafx.h"
#include "conveng.h"

#include "convdata.tbl"

// These file contain 3 parts:
//  First part, Some basic service functions for Ansi char format convert,
//      Distance/Advance calculate and Binary search algorithm copied from STL
//  Second part, Unicode to Ansi
//  Third part, Ansi to Unicode


// ****************************************************************************
// Frist part, Ansi char convert functions
//
//  This part not use any data base in .tbl file 
// ****************************************************************************

// Binary search algorithm
//  Copy from STL, only very little modify
template <class RandomAccessIterator, class T>
RandomAccessIterator __lower_bound(RandomAccessIterator first,
				   RandomAccessIterator last, const T& value) {
    INT_PTR len = last - first;
    INT_PTR half;
    RandomAccessIterator middle;

    while (len > 0) {
	    half = len / 2;

        middle = first + half;
	    if (*middle < value) {
	        first = middle + 1;
	        len = len - half - 1;
	    } else {
	        len = half;
        }
    }
    return first;
}

template <class RandomAccessIterator, class T>
RandomAccessIterator __upper_bound(RandomAccessIterator first,
				   RandomAccessIterator last, const T& value) {
    DWORD len = last - first;
    DWORD half;
    RandomAccessIterator middle;

    while (len > 0) {
	    half = len / 2;

        middle = first + half;
	    if (!(value < *middle)) {
	        first = middle + 1;
	        len = len - half - 1;
	    } else {
	        len = half;
        }
    }
    return first;
}

template<class T>
inline ValueIn(
    T Value,
    T Low,
    T High)
{
    return (Value >= Low && Value < High);
}

inline BOOL IsValidSurrogateLeadWord(
    WCHAR wchUnicode)
{
    return ValueIn(wchUnicode, cg_wchSurrogateLeadWordLow, cg_wchSurrogateLeadWordHigh);
}

inline BOOL IsValidSurrogateTailWord(
    WCHAR wchUnicode)
{
    return ValueIn(wchUnicode, cg_wchSurrogateTailWordLow, cg_wchSurrogateTailWordHigh);
}

inline BOOL IsValidQByteAnsiLeadByte(
    BYTE byAnsi)
{
    return ValueIn(byAnsi, cg_byQByteAnsiLeadByteLow, cg_byQByteAnsiLeadByteHigh);
}

inline BOOL IsValidQByteAnsiTailByte(
    BYTE byAnsi)
{
    return ValueIn(byAnsi, cg_byQByteAnsiTailByteLow, cg_byQByteAnsiTailByteHigh);
}

// Generate QByte Ansi. The Ansi char is in DWORD format, 
//  in another word, it's in reverse order of GB18030 standard
DWORD QByteAnsiBaseAddOffset(
    DWORD dwBaseAnsi,   // In reverse order
    int   nOffset)
{
    DWORD dwAnsi = dwBaseAnsi;
    PBYTE pByte = (PBYTE)&dwAnsi;
    
    // dwOffset should less than 1M
    ASSERT (nOffset < 0x100000);

    nOffset += pByte[0] - 0x30;
    pByte[0] = 0x30 + nOffset % 10;
    nOffset /= 10;

    nOffset += pByte[1] - 0x81;
    pByte[1] = 0x81 + nOffset % 126;
    nOffset /= 126;

    nOffset += pByte[2] - 0x30;
    pByte[2] = 0x30 + nOffset % 10;
    nOffset /= 10;

    nOffset += pByte[3] - 0x81;
    pByte[3] = 0x81 + nOffset % 126;
    nOffset /= 126;
    ASSERT(nOffset == 0);

    return dwAnsi;
}

// Get "distance" of 2 QByte Ansi
int CalcuDistanceOfQByteAnsi(
    DWORD dwAnsi1,  // In reverse order
    DWORD dwAnsi2)  // In reverse order
{
    signed char* pschAnsi1 = (signed char*)&dwAnsi1;
    signed char* pschAnsi2 = (signed char*)&dwAnsi2;
    
    int nDistance = 0;

    nDistance += (pschAnsi1[0] - pschAnsi2[0]);
    nDistance += (pschAnsi1[1] - pschAnsi2[1])*10;
    nDistance += (pschAnsi1[2] - pschAnsi2[2])*1260;
    nDistance += (pschAnsi1[3] - pschAnsi2[3])*12600;

    return nDistance;
}

// Reverse 4 Bytes order, from DWORD format to GB format,
//  or GB to DWORD
void ReverseQBytesOrder(
    PBYTE pByte)
{
    BYTE by;

    by = pByte[0];
    pByte[0] = pByte[3];
    pByte[3] = by;

    by = pByte[1];
    pByte[1] = pByte[2];
    pByte[2] = by;

    return;
}



// ****************************************************************************
// Second part, Unicode to Ansi
// ****************************************************************************

// ------------------------------------------------
// Two helper function for UnicodeToAnsi
//  return Ansi char code 
//  the Ansi is in GB standard order (not Word value order)
//  

// Unicode to double bytes Ansi char
WORD UnicodeToDByteAnsi(
    WCHAR wchUnicode)
{
    char achAnsiBuf[4];
    WORD wAnsi;
    int cLen;

    // Code changed from GBK to GB18030, or code not compatible
    //  from CP936 to CP54936
    for (int i = 0; i < sizeof(asAnsiCodeChanged)/sizeof(SAnsiCodeChanged); i++) {
        if (wchUnicode == asAnsiCodeChanged[i].wchUnicode) {
            wAnsi = asAnsiCodeChanged[i].wchAnsiNew;
            goto Exit;
        }
    }
    
    // Not in Changed code list, that is same with GBK, or CP936
    //  (Most DByte Ansi char code should compatible from GBK to GB18030)
    cLen = WideCharToMultiByte(936,
        WC_COMPOSITECHECK, &wchUnicode, 1,
        achAnsiBuf, sizeof(achAnsiBuf), NULL, NULL);
    ASSERT(cLen == 2);
    wAnsi = *(PWORD)achAnsiBuf;

Exit:
    return wAnsi;
}

// Unicode to quad bytes Ansi char
DWORD UnicodeToQByteAnsi(
    int nSection,
    int nOffset)
{
    DWORD dwBaseAnsi = adwAnsiQBytesAreaStartValue[nSection];

    // Check adwAnsiQByteAreaStartValue array is correctly
#ifdef _DEBUG
    int ncQByteAnsiNum = 0;
    for (int i = 0; i < nSection; i++) {
        // Calcu QByte Ansi char numbers
        ncQByteAnsiNum += awchAnsiDQByteBound[2*i+1] - awchAnsiDQByteBound[2*i];
    }
    ASSERT(dwBaseAnsi == QByteAnsiBaseAddOffset(cg_dwQByteAnsiStart, ncQByteAnsiNum));
#endif
    
    DWORD dwAnsi = QByteAnsiBaseAddOffset(dwBaseAnsi, nOffset);
    // Value order to standard order
    ReverseQBytesOrder((PBYTE)(&dwAnsi));

    return dwAnsi;
}


// ---------------------------------------------------------
// Two function support 2 bytes Unicode (BMP) 
//  and 4 bytes Unicode (Surrogate) translate to Ansi

// 2 bytes Unicode (BMP)
int UnicodeToAnsi(
    WCHAR wchUnicode,
    char* pchAnsi)
{
    // Classic Unicode, not support surrogate in this function
    ASSERT(!IsValidSurrogateLeadWord(wchUnicode) 
        && !IsValidSurrogateTailWord(wchUnicode));

    DWORD  lAnsiLen;
    const WORD* p;
    INT_PTR i;

    // ASCII, 0 - 0x7f
    if (wchUnicode <= 0x7f) {
        *pchAnsi = (char)wchUnicode;
        lAnsiLen = 1;
        goto Exit;
    }

    // BMP, 4 byte or 2 byte
    p = __lower_bound(awchAnsiDQByteBound, awchAnsiDQByteBound 
        + sizeof(awchAnsiDQByteBound)/sizeof(WCHAR), wchUnicode);
    
    if (p == awchAnsiDQByteBound 
        + sizeof(awchAnsiDQByteBound)/sizeof(WCHAR)) {
        p --;
    } else if (wchUnicode < *p) {
        p --;
    } else if (wchUnicode == *p) {
    } else {
        ASSERT(FALSE);
    }

    i = p - awchAnsiDQByteBound;
    ASSERT(i >= 0);
  
    // Stop when >= *(((PWORD)asAnsi2ByteArea) + i);
    if (i%2) { // Odd, in 2 bytes area
        *(UNALIGNED WORD*)pchAnsi = (WORD)UnicodeToDByteAnsi(wchUnicode);
        lAnsiLen = 2;
    } else {   // Duel, in 4 bytes area
        *(UNALIGNED DWORD*)pchAnsi = UnicodeToQByteAnsi
            ((int)i/2, wchUnicode - awchAnsiDQByteBound[i]);
        lAnsiLen = 4;
    }

Exit:
    return lAnsiLen;

}

// 4 bytes Unicode (Surrogate)
int SurrogateToAnsi(
    PCWCH pwchUnicode,
    PCHAR pchAnsi)
{
    ASSERT(IsValidSurrogateLeadWord(pwchUnicode[0]));
    ASSERT(IsValidSurrogateLeadWord(pwchUnicode[1]));

    // dwOffset is ISO char code - 0x10000
    DWORD dwOffset = ((pwchUnicode[0] - cg_wchSurrogateLeadWordLow)<<10) 
        + (pwchUnicode[1] - cg_wchSurrogateTailWordLow)
        + 0x10000 - 0x10000;

    *(UNALIGNED DWORD*)pchAnsi = QByteAnsiBaseAddOffset
        (cg_dwQByteAnsiToSurrogateStart, dwOffset);
    ReverseQBytesOrder((PBYTE)pchAnsi);

    return 4;
}

// API: high level service for Unicode to Ansi
//  return result Ansi str length (in byte)
int UnicodeStrToAnsiStr(
    PCWCH pwchUnicodeStr,
    int   ncUnicodeStr,     // in WCHAR
    PCHAR pchAnsiStrBuf,
    int   ncAnsiStrBufSize) // in BYTE
{
    int ncAnsiStr = 0;
    int ncAnsiCharSize;

    for (int i = 0; i < ncUnicodeStr && ncAnsiStr < (ncAnsiStrBufSize-4); 
         i++, pwchUnicodeStr++) {
        if (IsValidSurrogateLeadWord(pwchUnicodeStr[0])) {
            if ((i+1 < ncUnicodeStr)
                && (IsValidSurrogateTailWord(pwchUnicodeStr[1]))) {
                ncAnsiCharSize = SurrogateToAnsi(pwchUnicodeStr, pchAnsiStrBuf);
                ASSERT(ncAnsiCharSize == 4);
                ncAnsiStr += ncAnsiCharSize;
                pchAnsiStrBuf += ncAnsiCharSize;
                pwchUnicodeStr++;
                i++;
            } else {
                // Invalide Uncode char, skip
            }
        } else {
            ncAnsiCharSize = UnicodeToAnsi(*pwchUnicodeStr, pchAnsiStrBuf);
            pchAnsiStrBuf += ncAnsiCharSize;
            ncAnsiStr += ncAnsiCharSize;
        }
    }

    *pchAnsiStrBuf = NULL;

    if (i < ncUnicodeStr) { return -1; }
    return ncAnsiStr;
}



// ****************************************************************************
// Third part, Ansi to Unicode
// ****************************************************************************


// Return Unicode number (number always 1 when success)
//  return 0 if can't find corresponding Unicode
int QByteAnsiToSingleUnicode(
    DWORD dwAnsi,
    PWCH  pwchUnicode)
{
    const DWORD* p;
    INT_PTR i;
 
    // 0x8431a439(cg_dwQByteAnsiToBMPLast) to 0x85308130 haven't Unicode corresponding
    // 0x85308130 to 0x90308130(cg_dwQByteAnsiToSurrogateStart) are reserved zone, 
    //  haven't Unicode corresponding
    if (dwAnsi > cg_dwQByteAnsiToBMPLast) {
        return 0;
    }

    p = __lower_bound(adwAnsiQBytesAreaStartValue, 
        adwAnsiQBytesAreaStartValue + sizeof(adwAnsiQBytesAreaStartValue)/sizeof(DWORD),
        dwAnsi);

    if (p == adwAnsiQBytesAreaStartValue 
        + sizeof(adwAnsiQBytesAreaStartValue)/sizeof(DWORD)) {
        p --;
    } else if (dwAnsi < *p) {
        p --;
    } else if (dwAnsi == *p) {
    } else {
        ASSERT(FALSE);
    }

    i = p - adwAnsiQBytesAreaStartValue;
    ASSERT(i >= 0);

    *pwchUnicode = awchAnsiDQByteBound[2*i] + CalcuDistanceOfQByteAnsi(dwAnsi, *p);
#ifdef _DEBUG
    {

    int nAnsiCharDistance = CalcuDistanceOfQByteAnsi(dwAnsi, *p);
    ASSERT(nAnsiCharDistance >= 0);
    
    WCHAR wchUnicodeDbg;
    if ((p+1) < adwAnsiQBytesAreaStartValue 
        + sizeof(adwAnsiQBytesAreaStartValue)/sizeof(DWORD)) {
        nAnsiCharDistance = CalcuDistanceOfQByteAnsi(dwAnsi, *(p+1));
        wchUnicodeDbg = awchAnsiDQByteBound[2*i+1] + nAnsiCharDistance;
    } else if ((p+1) == adwAnsiQBytesAreaStartValue 
        + sizeof(adwAnsiQBytesAreaStartValue)/sizeof(DWORD)) {
        nAnsiCharDistance = CalcuDistanceOfQByteAnsi(dwAnsi, 0x8431A530);
        wchUnicodeDbg = 0x10000 + nAnsiCharDistance;
    } else {
        ASSERT(FALSE);
    }
    ASSERT(nAnsiCharDistance < 0);
    ASSERT(wchUnicodeDbg == *pwchUnicode);

    }
#endif

    return 1;
}

// Return Unicode number (number always 2 when success)
//  return 0 if can't find corresponding Unicode
int QByteAnsiToDoubleUnicode(
    DWORD dwAnsi,
    PWCH  pwchUnicode)
{
    int nDistance = CalcuDistanceOfQByteAnsi(dwAnsi, cg_dwQByteAnsiToSurrogateStart);
    ASSERT (nDistance >= 0);
    
    if (nDistance >= 0x100000) {
        return 0;
    }

    pwchUnicode[1] = nDistance % 0x400 + 0xDC00;
    pwchUnicode[0] = nDistance / 0x400 + 0xD800;

    return 2;
}

// Return Unicode number (1 or 2 when success)
//  return 0 if can't find corresponding Unicode
//  return -1 if it's a invalid GB char code
int QByteAnsiToUnicode(
    const BYTE* pbyAnsiChar,
    PWCH pwchUnicode)
{
    DWORD dwAnsi;
    int   nLen;
    
    if (   IsValidQByteAnsiLeadByte(pbyAnsiChar[0])
        && IsValidQByteAnsiTailByte(pbyAnsiChar[1])
        && IsValidQByteAnsiLeadByte(pbyAnsiChar[2])
        && IsValidQByteAnsiTailByte(pbyAnsiChar[3])) {
        
    } else {
        return -1;   // Invalid char
    }

    dwAnsi = *(UNALIGNED DWORD*)pbyAnsiChar;
    ReverseQBytesOrder((PBYTE)(&dwAnsi));
    
    if (dwAnsi >= cg_dwQByteAnsiToSurrogateStart) {
        nLen = QByteAnsiToDoubleUnicode(dwAnsi, pwchUnicode);
    } else {
        nLen = QByteAnsiToSingleUnicode(dwAnsi, pwchUnicode);
    }

    return nLen;
}

// Unicode to double bytes Ansi char
//  Return: 1, Success, one Unicode generate;
//          0, Fail
int DByteAnsiToUnicode(
    const BYTE* pbyAnsi,
    PWCH pwchUnicode)
{
    WORD wAnsi = *(UNALIGNED WORD*)pbyAnsi;
    int cLen = 1;

    // Code changed from GBK to GB18030, or code not compatible
    //  from CP936 to CP54936
    for (int i = 0; i < sizeof(asAnsiCodeChanged)/sizeof(SAnsiCodeChanged); i++) {
        if (wAnsi == asAnsiCodeChanged[i].wchAnsiNew) {
            *pwchUnicode = asAnsiCodeChanged[i].wchUnicode;
            goto Exit;
        }
    }
    
    // Not in Changed code list, that is same with GBK, or CP936
    //  (Most DByte Ansi char code should compatible from GBK to GB18030)
    cLen = MultiByteToWideChar(936, MB_PRECOMPOSED,
        (PCCH)pbyAnsi, 2, pwchUnicode, 1);

Exit:
    return cLen;
}

// API: High level service for Ansi to Unicode
//  return Unicode str length (in WCHAR)
int AnsiStrToUnicodeStr(
    const BYTE* pbyAnsiStr,
    int   ncAnsiStrSize,    // In char
    PWCH  pwchUnicodeBuf,
    int   )     // In WCHAR
{
    int nCharLen;
    int ncUnicodeBuf = 0;

    for (int i = 0; i < ncAnsiStrSize; ) {
        // 1 byte Ansi char
        if (*pbyAnsiStr < 0x80) {
            *pwchUnicodeBuf = (WCHAR)*pbyAnsiStr;
            pwchUnicodeBuf ++;
            ncUnicodeBuf ++;
            i++;
            pbyAnsiStr++;
        // 2 byte Ansi char
        } else if ((i+1 < ncAnsiStrSize) && pbyAnsiStr[1] >= 0x40) {
            nCharLen = DByteAnsiToUnicode(pbyAnsiStr, pwchUnicodeBuf);
            if (nCharLen) {
                ASSERT(nCharLen == 1);
            } else {
                *pwchUnicodeBuf = '?';
            }
            pwchUnicodeBuf ++;
            ncUnicodeBuf ++;
            i += 2;
            pbyAnsiStr += 2;
        // 4 byte Ansi char
        } else if ((i+3 < ncAnsiStrSize) 
            && IsValidQByteAnsiLeadByte(pbyAnsiStr[0])
            && IsValidQByteAnsiTailByte(pbyAnsiStr[1])
            && IsValidQByteAnsiLeadByte(pbyAnsiStr[2])
            && IsValidQByteAnsiTailByte(pbyAnsiStr[3])) {
            // QByte GB char
            nCharLen = QByteAnsiToUnicode(pbyAnsiStr, pwchUnicodeBuf);
            ASSERT(nCharLen != -1); // Should not invalid GB char
            if (nCharLen == 0) {    // hasn't corresponding Unicode Char
                *pwchUnicodeBuf = '?';
                pwchUnicodeBuf ++;
                ncUnicodeBuf ++;
            } else if (nCharLen > 0) {
                ASSERT(nCharLen <= 2);
                pwchUnicodeBuf += nCharLen;
                ncUnicodeBuf += nCharLen;
            } else {
                ASSERT(FALSE);
            }
            i += 4;
            pbyAnsiStr += 4;
        // Invalid Ansi char
        } else {
            // Invalid
            i++;
            pbyAnsiStr++;
        }
    }
    return ncUnicodeBuf;
}


// ******************************************************
//  Testing program
// ******************************************************

/*
"\u0080",	<0x81;0x30;0x81;0x30>
"\u00A3",	<0x81;0x30;0x84;0x35>
"\u00A4",	<0xA1;0xE8>
"\u00A5",	<0x81;0x30;0x84;0x36>
"\u00A6",	<0x81;0x30;0x84;0x37>
"\u00A7",	<0xA1;0xEC>
"\u00A8",	<0xA1;0xA7>
"\u00A9",	<0x81;0x30;0x84;0x38>
"\u00AF",	<0x81;0x30;0x85;0x34>
"\u00B0",	<0xA1;0xE3>
"\u00B1",	<0xA1;0xC0>
"\u00B2",	<0x81;0x30;0x85;0x35>

    {0x20AC, 0xe3a2},
    {0x01f9, 0xbfa8},
    {0x303e, 0x89a9},
    {0x2ff0, 0x8aa9},
    {0x2ff1, 0x8ba9},

50EF	836A
50F0	836B
50F1	836C
50F2	836D

*/
#if 0
int test (void)
{
    const WCHAR awchUnicodeStr[] = {0x01, 0x7f, 0x80, 0x81, 0x82,
        0xa2, 
        0xa3, // 0x81;0x30;0x84;0x35
        0xa4, // 0xA1;0xE8
        0xa5, // 0x81;0x30;0x84;0x36
        0xa6, // 0x81;0x30;0x84;0x37
        0xaf, // 0x81;0x30;0x85;0x34
        0xb0, // 0xA1;0xE3
        0xb1, // 0xA1;0xC0
        0xb6, // 0x81;0x30;0x85;0x39
        0xb7, // 0xA1;0xA4
        
        // Some normal DByte Ansi char
        0x50ef, // 0x83, 0x6A
        0x50f2, // 0x83, 0x6D
        
        // Some ansi char code changed in new standard
        0x20ac, // 0xa2, 0xe3
        0xE76C, // not (0xa2, 0xe3), should some QByte char
        0x2ff0, // 0xa9, 0x8A 
        0x2ff1, // 0xa9, 0x8B 
        0x4723, // 0xFE, 0x80

        // Ansi char arround DC00 to E000
        0xd7ff, // 0x83, 0x36, 0xC7, 0x38
        0xe76c, // 0x83, 0x36, 0xC7, 0x39
        0xE76B, // 0xA2, 0xB0

        0xffff, // 0x84, 0x31, 0xa4, 0x39,
        0x00};

    char* pchAnsiStr = new char[sizeof(awchUnicodeStr)*2+5];
    
    UnicodeStrToAnsiStr(awchUnicodeStr, sizeof(awchUnicodeStr)/sizeof(WCHAR), 
        pchAnsiStr, sizeof(awchUnicodeStr)*2+5);

    delete pchAnsiStr;


    BYTE abyAnsiStr2[] = {
        0x81, 0x30, 0x81, 0x30, 
        0x81, 0x30, 0x84, 0x35, 
        0xA1, 0xE8, 
        0x81, 0x30, 0x84, 0x36, 
        0x81, 0x30, 0x84, 0x37, 
        0xA1, 0xEC, 
        0xA1, 0xA7, 
        0x81, 0x30, 0x84, 0x38, 
        0x81, 0x30, 0x85, 0x34, 
        0xA1, 0xE3, 
        0xA1, 0xC0, 
        0x81, 0x30, 0x85, 0x35,
        
        // Testing D800 to DE00
        0x82, 0x35, 0x8f, 0x33, // 0x9FA6
        0x83, 0x36, 0xC7, 0x38, // 0xD7FF	
        0xA2, 0xB0,             // 0xE76B
        0x83, 0x36, 0xC7, 0x39, // 0xE76C
        
        // Testing last char in BMP
        0x84, 0x31, 0xa4, 0x39, // 0xFFFF
        
        // Some char code changed in new GB standard
        0xa2, 0xe3, // 0x20AC,
        0xa8, 0xbf, // 0x01f9,
        0xa9, 0x89, // 0x303e,
        0xa9, 0x8a, // 0x2ff0,
        0xa9, 0x8b, // 0x2ff1,
        0xFE, 0x9F, // 0x4dae 

	    0x83, 0x6A,   // 50EF
	    0x83, 0x6B,   // 50F0
	    0x83, 0x6C,   // 50F1
	    0x83, 0x6D    // 50F2
        };

    WCHAR* pwchUnicodeStr2 = new WCHAR[sizeof(abyAnsiStr2)+3];
    
    AnsiStrToUnicodeStr(abyAnsiStr2, sizeof(abyAnsiStr2), 
        pwchUnicodeStr2, sizeof(abyAnsiStr2)+3);

    delete pwchUnicodeStr2;


    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\conveng.h ===
// API: high level service for Unicode to Ansi
//  return result Ansi str length (in byte)
int UnicodeStrToAnsiStr(
    PCWCH pwchUnicodeStr,
    int   ncUnicodeStr,     // in WCHAR
    PCHAR pchAnsiStrBuf,
    int   ncAnsiStrBufSize);// in BYTE


// API: High level service for Ansi to Unicode
//  return Unicode str length (in WCHAR)
int AnsiStrToUnicodeStr(
    const BYTE* pbyAnsiStr,
    int   ncAnsiStrSize,    // In char
    PWCH  pwchUnicodeBuf,
    int   ncUnicodeBuf);    // In WCHAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\convert.h ===
// convert.h : main header file for the CONVERT application
//

#if !defined(AFX_CONVERT_H__BA686E65_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
#define AFX_CONVERT_H__BA686E65_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CConvertApp:
// See convert.cpp for the implementation of this class
//

class CConvertApp : public CWinApp
{
public:
	CConvertApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConvertApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CConvertApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	BOOL CommandLineHandle(void);
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONVERT_H__BA686E65_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\convertdlg.cpp ===
// convertDlg.cpp : implementation file
//

#include "stdafx.h"
#include "convert.h"
#include "convertDlg.h"
#include "FileConv.h"
#include "Msg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertDlg dialog

CConvertDlg::CConvertDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConvertDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConvertDlg)
	m_strSourceFileName = _T("");
	m_strTargetFileName = _T("");
	m_ToUnicodeOrAnsi = 0;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CConvertDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvertDlg)
	DDX_Control(pDX, IDC_CONVERT, m_cBtnConvert);
	DDX_Text(pDX, IDC_SOURCEFILENAME, m_strSourceFileName);
	DDX_Text(pDX, IDC_TARGETFILENAME, m_strTargetFileName);
	DDX_Radio(pDX, IDC_GBTOUNICODE, m_ToUnicodeOrAnsi);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CConvertDlg, CDialog)
	//{{AFX_MSG_MAP(CConvertDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_OPENSOURCEFILE, OnOpensourcefile)
	ON_BN_CLICKED(IDC_ABOUT, OnAbout)
	ON_EN_CHANGE(IDC_TARGETFILENAME, OnChangeTargetfilename)
	ON_BN_CLICKED(IDC_GBTOUNICODE, OnGbtounicode)
	ON_BN_CLICKED(IDC_UNICODETOGB, OnUnicodetogb)
	ON_BN_CLICKED(IDC_CONVERT, OnConvert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertDlg message handlers

BOOL CConvertDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
    m_fTargetFileNameChanged = TRUE;

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CConvertDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CConvertDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CConvertDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CConvertDlg::OnOpensourcefile() 
{
//    BOOL fRet = FALSE;
    OPENFILENAME ofn;

//    TCHAR* tszFileName = new TCHAR[MAX_PATH];
//    if (tszFileName) {
//        goto Exit;
//    }
        
#ifdef RTF_SUPPORT
    TCHAR tszFilter[] = _T("Text file (.txt)|*.txt|"\
        "Rich text format file (.rtf)|*.rtf|"\
        "Html file (.html;.htm)|*.html;*.htm|All files (*.*)|*.*|");
#else
    TCHAR tszFilter[] = _T("Text file (.txt)|*.txt|"\
        "Html file (.html;.htm)|*.html;*.htm|All files (*.*)|*.*|");
#endif
    TCHAR tszFileName[MAX_PATH];
    *tszFileName = NULL;

    int nLen = lstrlen (tszFilter);
    for (int i = 0; i < nLen; i++) {
        if (tszFilter[i] == '|') { tszFilter[i] = 0; }
    }

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = m_hWnd;
    ofn.lpstrFilter         = tszFilter;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = tszFileName;
    ofn.nMaxFile            = MAX_PATH;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = NULL;
    ofn.lpstrTitle          = NULL;
    ofn.Flags               = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY|OFN_PATHMUSTEXIST|OFN_LONGNAMES;
    ofn.lpstrDefExt         = NULL;//TEXT("txt");

    if (GetOpenFileName(&ofn)) {
        UpdateData(TRUE);
        m_strSourceFileName = tszFileName;
        GenerateTargetFileName(tszFileName, &m_strTargetFileName,
            m_ToUnicodeOrAnsi == 0 ? TRUE:FALSE);
        m_fTargetFileNameChanged = FALSE;

        UpdateData(FALSE);
    }

    return;
}

void CConvertDlg::OnConvert() 
{
    UpdateData(TRUE);

    m_cBtnConvert.EnableWindow(FALSE);
    
    BOOL fOk = Convert((PCTCH)m_strSourceFileName, (PCTCH)m_strTargetFileName, 
        m_ToUnicodeOrAnsi == 0 ? TRUE:FALSE);
    
    if (fOk) {
        MsgConvertFinish();
    }

    m_cBtnConvert.EnableWindow(TRUE);
    
}

void CConvertDlg::OnAbout() 
{
	// TODO: Add your control notification handler code here
    CAboutDlg dlgAbout;
    dlgAbout.DoModal();
	
}

void CConvertDlg::OnChangeTargetfilename() 
{
    m_fTargetFileNameChanged = TRUE;	
}

void CConvertDlg::OnGbtounicode() 
{
	// TODO: Add your control notification handler code here
    if (!m_fTargetFileNameChanged) {
        UpdateData(TRUE);
        GenerateTargetFileName(m_strSourceFileName, &m_strTargetFileName,
            m_ToUnicodeOrAnsi == 0 ? TRUE:FALSE);
        UpdateData(FALSE);
    }
}

void CConvertDlg::OnUnicodetogb() 
{
	// TODO: Add your control notification handler code here
    if (!m_fTargetFileNameChanged) {
        UpdateData(TRUE);
        GenerateTargetFileName(m_strSourceFileName, &m_strTargetFileName,
            m_ToUnicodeOrAnsi == 0 ? TRUE:FALSE);
        UpdateData(FALSE);
    }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\fileconv.cpp ===
#include <stdafx.h>

#include "ConvEng.h"
#include "Msg.h"
#include "TextFile.h"
#include "FileConv.h"
#include "RtfParser.h"

static HANDLE g_hFile = INVALID_HANDLE_VALUE;
static HANDLE g_hMapping = NULL;
static BYTE* g_pbyData = NULL;

PSECURITY_ATTRIBUTES CreateSecurityAttributes()
{
    return NULL;
}

void DestroySecurityAttributes(
    PSECURITY_ATTRIBUTES pSa)
{
    ASSERT(!pSa);
    return;
}

BOOL OpenFile(
    PCTCH ptszFileName)
{
    BYTE* pbyAnsiData = NULL;
    PSECURITY_ATTRIBUTES pSa = NULL;

    pSa = CreateSecurityAttributes();

    g_hFile = CreateFile(ptszFileName, GENERIC_READ,
        FILE_SHARE_READ, pSa, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, (HANDLE)NULL);

    DWORD dw = GetLastError();
    if (g_hFile == INVALID_HANDLE_VALUE) {
        DestroySecurityAttributes(pSa);
        goto ErrorFile;
    }

    g_hMapping = CreateFileMapping(g_hFile, (PSECURITY_ATTRIBUTES)pSa,
        PAGE_READONLY, 0, 0, NULL);

    DestroySecurityAttributes(pSa);

    if (g_hMapping == NULL) { goto ErrorFileMapping; }

    g_pbyData = (PBYTE)MapViewOfFileEx(g_hMapping, FILE_MAP_READ, 0, 0, 0,
        NULL);

    if (!g_pbyData) { goto ErrorMapView; }

    return TRUE;

ErrorMapView:
    CloseHandle(g_hMapping);
    g_hMapping = NULL;
ErrorFileMapping:
    CloseHandle(g_hFile);
    g_hFile = INVALID_HANDLE_VALUE;
ErrorFile:
    // error message here

    return FALSE;
}

void CloseFile(void)
{
    if (g_pbyData) {
        UnmapViewOfFile(g_pbyData);
        g_pbyData = NULL;
    }

    if (g_hMapping) {
        CloseHandle(g_hMapping);
        g_hMapping = NULL;
    }

    if (g_hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
    }
}

BOOL Convert(
    PCTCH tszSourceFileName,
    PCTCH tszTargetFileName,
    BOOL  fAnsiToUnicode)
{
    enum {
        FILETYPE_TEXT,
        FILETYPE_RTF,
        FILETYPE_HTML,
    } eFileType;

    BOOL fRet = FALSE;
    DWORD dwFileSize;
    int nTargetFileSize;
    BYTE* pbyTarget = NULL;
    FILE* pFile = NULL;

    // File format
        // Find last '.'
    PCTCH tszExt = tszSourceFileName + lstrlen(tszSourceFileName);
    for (;  tszExt >= tszSourceFileName && *tszExt != TEXT('.'); tszExt--);
    if (tszExt < tszSourceFileName) {   
        // not find '.', no ext
        tszExt = tszSourceFileName + lstrlen(tszSourceFileName);
    } else {
        // find '.', skip dot
        tszExt ++;
    }
    TCHAR* tszExtBuf = new TCHAR
        [tszSourceFileName + lstrlen(tszSourceFileName) - tszExt + 1];
    if (!tszExtBuf) { 
        MsgOverflow();
        goto Exit; 
    }
    lstrcpy(tszExtBuf, tszExt);
    _strlwr(tszExtBuf);

    if (_tcscmp(tszExtBuf, TEXT("txt")) == 0) {
        eFileType = FILETYPE_TEXT;
#ifdef RTF_SUPPORT
    } else if (_tcscmp(tszExtBuf, TEXT("rtf")) == 0) {
        eFileType = FILETYPE_RTF;
#endif
    } else if (_tcscmp(tszExtBuf, TEXT("htm")) == 0
            || _tcscmp(tszExtBuf, TEXT("html")) == 0) { 
        eFileType = FILETYPE_HTML;
    } else {
        MsgUnrecognizedFileType(tszSourceFileName);
        goto Exit;
    }

    if (!OpenFile(tszSourceFileName)) {
        MsgOpenSourceFileError(tszSourceFileName);
        goto Exit;
    }

    dwFileSize = GetFileSize(g_hFile, NULL);
    if (dwFileSize == 0 || dwFileSize == (DWORD)(-1)) {
        MsgOpenSourceFileError(tszSourceFileName);
        goto Exit;
    }

    pbyTarget = new BYTE[dwFileSize*3 + 32];
    if (!pbyTarget) {
        MsgOverflow();
        goto Exit;
    }
    
    pFile = _tfopen(tszTargetFileName, TEXT("r"));
    if (pFile) {
        MsgTargetFileExist(tszTargetFileName);
        fclose(pFile);
        goto Exit;
    }

    // Convert
    switch(eFileType) {
    case FILETYPE_TEXT:
        if (!ConvertTextFile(g_pbyData, dwFileSize, pbyTarget, 
            fAnsiToUnicode, &nTargetFileSize)) {
            goto Exit;
        }
        break;
    case FILETYPE_RTF:
        if (!ConvertRtfFile(g_pbyData, dwFileSize, pbyTarget, 
            fAnsiToUnicode, &nTargetFileSize)) {
            goto Exit;
        }
        break;
    case FILETYPE_HTML:
        if (!ConvertHtmlFile(g_pbyData, dwFileSize, pbyTarget, 
            fAnsiToUnicode, &nTargetFileSize)) {
            goto Exit;
        }
        break;
    default:
        break;
    }

    pFile = _tfopen(tszTargetFileName, TEXT("wb"));
    if (!pFile) {
        goto Exit;
    }

    dwFileSize = fwrite(pbyTarget, nTargetFileSize, 1, pFile);
    if (dwFileSize < 1) {
        MsgWriteFileError();
        goto Exit;
    }

    fRet = TRUE;

Exit:
    if (tszExtBuf) {
        delete tszExtBuf;
        tszExtBuf = NULL;
    }
    if (pbyTarget) {
        delete pbyTarget;
        pbyTarget = NULL;
    }
    if (pFile) {
        fclose(pFile);
        pFile = NULL;
    }
    CloseFile();

    return fRet;
    
}

void GenerateTargetFileName(
    PCTCH    tszSrc,
    CString* pstrTar,
    BOOL     fAnsiToUnicode)
{
        // Find last '.'
    PCTCH tszExt = tszSrc + lstrlen(tszSrc);
    for (;  tszExt >= tszSrc && *tszExt != TEXT('.'); tszExt--);

    if (tszExt < tszSrc) {
        // not find '.', no ext
        tszExt = tszSrc + lstrlen(tszSrc);
    } else {
        // find '.'
    }

    *pstrTar = tszSrc;
    *pstrTar = pstrTar->Left((int)(tszExt - tszSrc));
    *pstrTar += fAnsiToUnicode ? TEXT(".Unicode") : TEXT(".GB");
    *pstrTar += tszExt;

    

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\msg.cpp ===
#include "stdafx.h"
#include "Msg.h"
#include "resource.h"

BOOL Msg2(
    UINT nIDPrompt,
    PCTCH tsz2)
{
    BOOL fRet = FALSE;
    CString str1;
    str1.LoadString(nIDPrompt);
        // -1, %s to null-terminal, length decrease 1
    PTCH tszOutput = new TCHAR[str1.GetLength()+lstrlen(tsz2)-1];
    if (!tszOutput) {
        MsgOverflow();
        goto Exit;
    }
    
    wsprintf(tszOutput, str1, tsz2);

    fRet = AfxMessageBox(tszOutput);

Exit:
    if (tszOutput) {
        delete tszOutput;
        tszOutput = NULL;
    }
    return fRet;
}

BOOL Msg3(
    UINT nIDPrompt,
    PCTCH tsz2,
    PCTCH tsz3)
{
    BOOL fRet = FALSE;
    CString str1;
    str1.LoadString(nIDPrompt);
        // -1, %s to null-terminal, length decrease 1
    PTCH tszOutput = new TCHAR[str1.GetLength()+lstrlen(tsz2)+lstrlen(tsz3)-1];
    if (!tszOutput) {
        MsgOverflow();
        goto Exit;
    }

    wsprintf(tszOutput, str1, tsz2, tsz3);
    
    fRet = AfxMessageBox(tszOutput);

Exit:
    if (tszOutput) {
        delete tszOutput;
        tszOutput = NULL;
    }

    return fRet;
}

BOOL MsgOverflow(void)
{
    return AfxMessageBox(IDS_MEMOVERFLOW);
}

BOOL MsgUnrecognizedFileType(
    PCTCH tszSrc)
{
    return Msg2(IDS_UNRECFILETYPE, tszSrc);
}

BOOL MsgUsage(void) 
{
    return AfxMessageBox(IDS_USEAGE);
}

BOOL MsgFailToBackupFile(
    PCTCH tszSrc,
    PCTCH tszBack)
{
    return Msg3(IDS_COPYFAIL, tszSrc, tszBack);
}

BOOL MsgOpenSourceFileError(
    PCTCH tszSrc)
{
    return Msg2(IDS_OPENSOURCEFILEFAIL, tszSrc);
}

BOOL MsgTargetFileExist(
    PCTCH tszTar)
{
    return Msg2(IDS_TARGETFILEEXIST, tszTar);
}

BOOL MsgWriteFileError(void)
{
    return AfxMessageBox(IDS_WRITEFILEERROR);
}

BOOL MsgNotUnicodeTextSourceFile(void)
{
    return AfxMessageBox(IDS_NOTUNICODETEXTFILE);
}

BOOL MsgNotRtfSourceFile(void)
{
    return AfxMessageBox(IDS_NOTRTFFILE);
}

BOOL MsgConvertFinish(void)
{
    return AfxMessageBox(IDS_CONVERTFINISH, MB_OK|MB_ICONINFORMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\convertdlg.h ===
// convertDlg.h : header file
//

#if !defined(AFX_CONVERTDLG_H__BA686E67_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
#define AFX_CONVERTDLG_H__BA686E67_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConvertDlg dialog

class CConvertDlg : public CDialog
{
// Construction
public:
	CConvertDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CConvertDlg)
	enum { IDD = IDD_CONVERT_DIALOG };
	CButton	m_cBtnConvert;
	CString	m_strSourceFileName;
	CString	m_strTargetFileName;
	int		m_ToUnicodeOrAnsi;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConvertDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;
    BOOL  m_fTargetFileNameChanged;

	// Generated message map functions
	//{{AFX_MSG(CConvertDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnOpensourcefile();
	afx_msg void OnAbout();
	afx_msg void OnChangeTargetfilename();
	afx_msg void OnGbtounicode();
	afx_msg void OnUnicodetogb();
	afx_msg void OnConvert();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONVERTDLG_H__BA686E67_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\fileconv.h ===
BOOL Convert(
    PCTCH tszSourceFileName,
    PCTCH tszTargetFileName,
    BOOL  fAnsiToUnicode);

void GenerateTargetFileName(
    PCTCH    tszSrc,
    CString* pstrTar,
    BOOL     fAnsiToUnicode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\msg.h ===
BOOL MsgOverflow(void);

BOOL MsgUnrecognizedFileType(PCTCH tszSrc);

BOOL MsgUsage(void);

BOOL MsgFailToBackupFile(PCTCH tszSrc, PCTCH tszBack);

BOOL MsgOpenSourceFileError(PCTCH tszSrc);

BOOL MsgTargetFileExist(PCTCH tszTar);

BOOL MsgWriteFileError(void);

BOOL MsgNotUnicodeTextSourceFile(void);

BOOL MsgNotRtfSourceFile(void);

BOOL MsgConvertFinish(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by convert.rc
//
#define IDM_ABOUTBOX                    0x0010

#define IDD_ABOUTBOX                    100
#define IDD_CONVERT_DIALOG              102

#define IDS_ABOUTBOX                    101
#define IDS_MEMOVERFLOW                 102 
#define IDS_UNRECFILETYPE               103
#define IDS_USEAGE                      104
#define IDS_COPYFAIL                    105
#define IDS_OPENSOURCEFILEFAIL          106
#define IDS_TARGETFILEEXIST             107
#define IDS_WRITEFILEERROR              108
#define IDS_NOTUNICODETEXTFILE          109
#define IDS_NOTRTFFILE                  110
#define IDS_CONVERTFINISH               111

#define IDR_MAINFRAME                   128

#define IDC_SOURCEFILENAME              1001
#define IDC_TARGETFILENAME              1002
#define IDC_UNICODETOGB                 1003
#define IDC_GBTOUNICODE                 1004
#define IDC_OPENSOURCEFILE              1005
#define IDC_ABOUT                       1006
#define IDC_CONVERT                     1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	convert.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BA686E69_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
#define AFX_STDAFX_H__BA686E69_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define PCTCH LPCTSTR

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BA686E69_1D0D_11D5_B8EB_0080C8E09118__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\rtffile.cpp ===
#include "stdafx.h"
#include "RtfParser.h"
#include "Msg.h"

BOOL MsgNotRtfFile()
{
    return TRUE;
}

BOOL ConvertRtfFile(
    PBYTE pBuf,     // Read buf
    DWORD dwSize,   // File size
    PBYTE pWrite,   // Write buf
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize)
{
    CRtfParser* pcParser;
    DWORD dwVersion;
    DWORD dwCodepage;
    BOOL  fRet = FALSE;

    pcParser = new CRtfParser(pBuf, dwSize, pWrite, dwSize*2);
    if (!pcParser) {
        MsgOverflow();
        goto gotoExit;
    }

    if (!pcParser->fRTFFile()) {
        MsgNotRtfFile();
        goto gotoExit;
    }

    if (ecOK != pcParser->GetVersion(&dwVersion) ||
        dwVersion != 1) {
        MsgNotRtfFile();
        goto gotoExit;
    }
    
    if (ecOK != pcParser->GetCodepage(&dwCodepage) ||
        dwCodepage != 936) {
        MsgNotRtfFile();
        goto gotoExit;
    }

    // Explain WordID by corresponding word text
    if (ecOK != pcParser->Do()) {
        MsgNotRtfFile();
        goto gotoExit;
    }

    pcParser->GetResult((PDWORD)pnTargetFileSize);
    fRet = TRUE;

gotoExit:
    if (pcParser) {
        delete pcParser;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\textfile.h ===
BOOL ConvertTextFile(
    PBYTE pbySource,
    DWORD dwFileSize,
    PBYTE pbyTarget,
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize);

BOOL ConvertHtmlFile(
    PBYTE pbySource,
    DWORD dwFileSize,
    PBYTE pbyTarget,
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize);

BOOL ConvertRtfFile(
    PBYTE pbySource,
    DWORD dwFileSize,
    PBYTE pbyTarget,
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\rtfparser.h ===
// rtfparser.h
// Define parser class

#ifndef _RTFPARSER_H_
#define _RTFPARSER_H_

// Error Code
#define ecOK                0       // Everything's fine!
#define ecStackUnderflow    1       // Unmatched '}'
#define ecStackOverflow     2       // Too many '{' -- memory exhausted
#define ecUnmatchedBrace    3       // RTF ended during an open group.
#define ecInvalidHex        4       // invalid hex character found in data
#define ecBadTable          5       // RTF table (sym or prop) invalid
#define ecAssertion         6       // Assertion failure
#define ecEndOfFile         7       // End of file reached while reading RTF
#define ecOutOfMemory       8       // Memery allocate failed...
#define ecBufTooSmall       9       // Write buffer too small

// Rtf Destination State
typedef enum { rdsNorm, rdsSkip } RDS;

// Rtf Internal State
typedef enum { risNorm, risBin, risHex } RIS;

// special process
typedef enum { ipfnBin, ipfnHex, ipfnSkipDest } IPFN;

typedef enum { idestPict, idestSkip } IDEST;

// keyword type
typedef enum { kwdChar, kwdDest, kwdProp, kwdSpec } KWD;

// save buffer status
typedef enum { bsDefault, bsText, bsHex } BSTATUS;

// keyword table
typedef struct tagSymbol
{
    char *szKeyword;        // RTF keyword
    KWD  kwd;               // base action to take
    int  idx;               // index into property table if kwd == kwdProp
                            // index into destination table if kwd == kwdDest
                            // character to print if kwd == kwdChar
} SYM;

// save stack
typedef struct tagSave             // property save structure
{
    struct tagSave *pNext;         // next save
    RDS rds;
    RIS ris;
} SAVE;

typedef struct tagKeyword
{
    WORD wStatus;
    char szKeyword[30];
    char szParameter[20];
} SKeyword;

// tagKeyword status
enum { KW_ENABLE = 0x0001,  // enable searching
       KW_PARAM  = 0x0002,  // found keyword, if have parameter
       KW_FOUND  = 0x0004   // if found keyword
};


// parser class def
class CRtfParser
{
    public:
        // ctor
        CRtfParser(BYTE* pchInput, UINT cchInput, 
               BYTE* pchOutput, UINT cchOutput);
        // dtor
        ~CRtfParser() {};

        // Check signature
        BOOL fRTFFile();

        // Get RTF version
        int GetVersion(PDWORD pdwMajor);

        // Get codepage
        int GetCodepage(PDWORD pdwCodepage);

        // start
        int Do();

        // return result buffer size
        int GetResult(PDWORD pdwSize) { 
            *pdwSize =  m_uOutPos; 
            return ecOK;
        }

    private:
        // clear internal status
        void Reset(void);

        // PushRtfState
        // Save relevant info on a linked list of SAVE structures.
        int PushRtfState(void);

        // PopRtfState
        int PopRtfState(void);
        
        // ReleaseRtfState
        int ReleaseRtfState(void);

        // ParseChar
        // Route the character to the appropriate destination stream.
        int ParseChar(BYTE ch, BSTATUS bsStatus);
        
        // ParseRtfKeyword
        // get a control word (and its associated value) and
        // call TranslateKeyword to dispatch the control.
        int ParseRtfKeyword();
        
        // TranslateKeyword.
        int TranslateKeyword(char *szKeyword, char* szParameter);
        
        // ParseSpecialKeyword
        // Evaluate an RTF control that needs special processing.
        int ParseSpecialKeyword(IPFN ipfn, char* szParameter);
        
        // ChangeDest
        // Change to the destination specified by idest.
        // There's usually more to do here than this...
        int ChangeDest(IDEST idest);

        // Buffer funcs

        // GetByte
        // Get one char from input buffer
        int GetByte(BYTE* pch);
        
        // unGetByte
        // adjust the cursor, return one char
        int unGetByte(BYTE ch);
        
        // SaveByte
        // Save one char to output buffer
        int SaveByte(BYTE ch);
        
        // SetStatus
        // set the buffer status, if buffer status changed then start convert
        int SetStatus(BSTATUS bsStatus);
        
        // Hex2Char
        // convert hex string to char string
        int Hex2Char(BYTE* pchSrc, UINT cchSrc, BYTE* pchDes, UINT cchDes, UINT* pcchLen);
        
        // Char2Hex
        // convert char string to hex string
        int Char2Hex(BYTE* pchSrc, UINT cchSrc, BYTE* pchDes, UINT cchDes, UINT* pcchLen);

        // GetUnicodeDestination
        // convert unicode string to unicode destination in RTF
        int GetUnicodeDestination(BYTE* pchUniDes, LPWSTR pwchStr, UINT wchLen, UINT* pcchLen);
        
        // WideCharToKeyword
        // map one wide char to \u keyword
        int WideCharToKeyword(WCHAR wch, BYTE* pch, UINT* pcchLen);


    private:
        //
        BOOL        m_fInit;

        // member for parser
        INT         m_cGroup; // count of '{' and '}' pair
        UINT        m_cbBin;  // length of data block if \BIN
        RIS         m_ris;    // internal status
        RDS         m_rds;    // destination status
        BOOL        m_fSkipDestIfUnk; // indicate how to process "\*"

        SAVE*       m_psave; // status stack

        // member for IO buffer
        BYTE*       m_pchInput;   // input buffer
        UINT        m_cchInput;
        UINT        m_uCursor;    // current position when read buffer

        BYTE*       m_pchOutput;  // output buffer
        UINT        m_cchOutput;  // output buffer size
        UINT        m_uOutPos;    // current position of write buffer

        BSTATUS     m_bsStatus;   // buffer status to control conversion
        UINT        m_uConvStart; // start point of buffer when convert
        UINT        m_cchConvLen; // length of buffer to convert

        // member when get specific keyword
        SKeyword    m_sKeyword;
};


#endif // _RTFPARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\rtfparser.cpp ===
// ==========================================================================================
//  RtfParser.cpp
//
//  Impl RTF parser
//
//  History:
//      first created   
// ==========================================================================================
//#include <windows.h>

#include "stdafx.h"
#include <stdio.h>
#include <assert.h>

#include "rtfparser.h"
#include "ConvEng.h"

//extern BOOL MapFunc(PBYTE, UINT, PBYTE, UINT*);

const char szRTFSignature[] = "{\\rtf";

// Keyword descriptions
SYM g_rgSymRtf[] = {
//  keyword     kwd         idx
    "*",        kwdSpec,    ipfnSkipDest,
    "'",        kwdSpec,    ipfnHex,
    "bin",      kwdSpec,    ipfnBin,
    "upr",      kwdDest,    idestSkip,
    "fonttbl",  kwdDest,    idestSkip,
/*
// we will search through following destinations
    "author",   kwdDest,    idestSkip,
    "buptim",   kwdDest,    idestSkip,
    "colortbl", kwdDest,    idestSkip,
    "comment",  kwdDest,    idestSkip,
    "creatim",  kwdDest,    idestSkip,
    "doccomm",  kwdDest,    idestSkip,
    "fonttbl",  kwdDest,    idestSkip,
    "footer",   kwdDest,    idestSkip,
    "footerf",  kwdDest,    idestSkip,
    "footerl",  kwdDest,    idestSkip,
    "footerr",  kwdDest,    idestSkip,
    "footnote", kwdDest,    idestSkip,
    "ftncn",    kwdDest,    idestSkip,
    "ftnsep",   kwdDest,    idestSkip,
    "ftnsepc",  kwdDest,    idestSkip,
    "header",   kwdDest,    idestSkip,
    "headerf",  kwdDest,    idestSkip,
    "headerl",  kwdDest,    idestSkip,
    "headerr",  kwdDest,    idestSkip,
    "info",     kwdDest,    idestSkip,
    "keywords", kwdDest,    idestSkip,
    "operator", kwdDest,    idestSkip,
    "pict",     kwdDest,    idestSkip,
    "printim",  kwdDest,    idestSkip,
    "private1", kwdDest,    idestSkip,
    "revtim",   kwdDest,    idestSkip,
    "rxe",      kwdDest,    idestSkip,
    "stylesheet",    kwdDest,    idestSkip,
    "subject",  kwdDest,    idestSkip,
    "tc",       kwdDest,    idestSkip,
    "title",    kwdDest,    idestSkip,
    "txe",      kwdDest,    idestSkip,
    "xe",       kwdDest,    idestSkip,
*/
    };
int g_iSymMax = sizeof(g_rgSymRtf) / sizeof(SYM);

// ctor
CRtfParser::CRtfParser( BYTE* pchInput, UINT cchInput, 
                        BYTE* pchOutput, UINT cchOutput)
{
    m_fInit = FALSE;

    m_pchInput = pchInput;
    m_cchInput = cchInput;
    m_pchOutput = pchOutput;
    m_cchOutput = cchOutput;

    Reset();

    if (pchInput && pchOutput && cchInput && cchOutput) {
        m_fInit = TRUE;
    } 
}

// Reset
// clean internal status before start the parser
void CRtfParser::Reset(void)
{
    m_cGroup = 0;
    m_cbBin = 0;
    m_fSkipDestIfUnk = FALSE;
    m_ris = risNorm;
    m_rds = rdsNorm;

    m_psave = NULL;
    m_uCursor = 0;
    m_uOutPos = 0;
    m_bsStatus = bsDefault;
    m_uConvStart = 0; 
    m_cchConvLen = 0; 

    memset(&m_sKeyword,0, sizeof(SKeyword));
} 

// check signature
BOOL CRtfParser::fRTFFile()
{
    if (m_fInit &&
        0 == memcmp(m_pchInput, szRTFSignature, strlen(szRTFSignature))) 
    {
        return TRUE;
    }

    return FALSE;
}

// Get major version
int
CRtfParser::GetVersion(PDWORD pdwVersion)
{
    int ec;

    *pdwVersion = 1;

    // set keyword to get
    m_sKeyword.wStatus |= KW_ENABLE;
    strcpy(m_sKeyword.szKeyword, "rtf");
    
    ec = Do();

    if (ec == ecOK && 
        (m_sKeyword.wStatus & KW_FOUND) && 
        (m_sKeyword.wStatus & KW_PARAM)) 
    {
        *pdwVersion = (DWORD) atoi(m_sKeyword.szParameter);
    }

    Reset();

    return ec;
}

// GetCodepage
int
CRtfParser::GetCodepage(PDWORD pdwCodepage)
{
    int ec;
    
    *pdwCodepage = 0;

    // set keyword to get
    m_sKeyword.wStatus |= KW_ENABLE;
    strcpy(m_sKeyword.szKeyword, "ansicpg");
    
    ec = Do();

    if (ec == ecOK && 
        (m_sKeyword.wStatus & KW_FOUND) && 
        (m_sKeyword.wStatus & KW_PARAM)) 
    {
        *pdwCodepage = atoi(m_sKeyword.szParameter);
    }

    Reset();

    return ec;
}

// do
// main parser function
int 
CRtfParser::Do()
{
    int ec;
    int cNibble = 2;
    BYTE ch;

    BSTATUS bsStatus;

    while ((ec = GetByte(&ch)) == ecOK)
    {
        if (m_cGroup < 0)
            return ecStackUnderflow;

        // check if search specific keyword
        if (m_sKeyword.wStatus & KW_ENABLE) {
            if (m_sKeyword.wStatus & KW_FOUND) {
                ReleaseRtfState();
                break;
            }
        }
        // set buf status
        bsStatus = bsDefault;

        if (m_ris == risBin)                      // if we're parsing binary data, handle it directly
        {
            // fall through
        }
        else
        {   
            switch (ch)
            {
            case '{':
                if ((ec = PushRtfState()) != ecOK)
                    return ec;
                break;
            case '}':
                if ((ec = PopRtfState()) != ecOK)
                    return ec;
                break;
            case '\\':
                if ((ec = ParseRtfKeyword()) != ecOK)
                    return ec;
                continue;  // all keyword is processed in ParseRtfKeyword
            case 0x0d:
            case 0x0a:          // cr and lf are noise characters...
                break;
            default:
                if (m_ris == risNorm )
                {
                    bsStatus = bsText;
                } else if (m_ris == risHex)
                {
                    cNibble--;
                    if (!cNibble) {
                        cNibble = 2;
                        m_ris = risNorm;
                    }
                    bsStatus = bsHex;
                } else {
                    return ecAssertion;
                }
                break;
            }       // switch
        }           // else (ris != risBin)

        if ((ec = ParseChar(ch, bsStatus)) != ecOK)
            return ec;
    }               // while
    if (m_cGroup < 0)
        return ecStackUnderflow;
    if (m_cGroup > 0)
        return ecUnmatchedBrace;
    return ecOK;
}



//
// PushRtfState
//
// Save relevant info on a linked list of SAVE structures.
//

int
CRtfParser::PushRtfState(void)
{
    SAVE *psaveNew = new SAVE;
    if (!psaveNew)
        return ecStackOverflow;

    psaveNew -> pNext = m_psave;
    psaveNew -> rds = m_rds;
    psaveNew -> ris = m_ris;
    m_ris = risNorm;
    // do not save rds, rds status spread to sub destination until this destination
    //  terminated
    m_psave = psaveNew;
    m_cGroup++;
    return ecOK;
}

//
// PopRtfState
//
// If we're ending a destination (that is, the destination is changing),
// call ecEndGroupAction.
// Always restore relevant info from the top of the SAVE list.
//

int
CRtfParser::PopRtfState(void)
{
    SAVE *psaveOld;

    if (!m_psave)
        return ecStackUnderflow;

    if (m_rds != m_psave->rds)
    {  // todo:
//        if ((ec = EndGroupAction(rds)) != ecOK)
//            return ec;
    }

    m_rds = m_psave->rds;
    m_ris = m_psave->ris;

    psaveOld = m_psave;
    m_psave = m_psave->pNext;
    m_cGroup--;
    delete psaveOld;
    return ecOK;
}

//
// ReleaseRtfState
// when find specific keyword and want to abort the parser abnormally
// call this function to flash the state stack
//

int CRtfParser::ReleaseRtfState(void)
{
    SAVE *psaveOld;

    while(psaveOld = m_psave)
    {
        assert(m_cGroup);
        m_psave = m_psave->pNext;
        m_cGroup--;
        delete psaveOld;
    }

    return ecOK;
}


//
// ParseChar
//
// Route the character to the appropriate destination stream.
//

int
CRtfParser::ParseChar(BYTE ch, BSTATUS bsStatus)
{
    int ec;

    if (m_ris == risBin && --m_cbBin <= 0)
        m_ris = risNorm;

    switch (m_rds)
    {
        case rdsSkip:
            // Toss this character.
            bsStatus = bsDefault;
            break;
        case rdsNorm:
            // Output a character. Properties are valid at this point.
            break;
        default:
        // handle other destinations....
            break;
    }
    
    // set status, trigger the conversion if any
    if ((ec = SetStatus(bsStatus)) != ecOK) {
        return ec;
    }

    // save the char
    if ((ec = SaveByte(ch)) != ecOK) {
        return ec;
    }

    return ec;
}

//
// ParseRtfKeyword
//
// get a control word (and its associated value) and
// call TranslateKeyword to dispatch the control.
//

int
CRtfParser::ParseRtfKeyword()
{
    BOOL fNeg = FALSE;
    char *pch;
    char szKeyword[30];
    char szParameter[20];
    BYTE ch;

    szKeyword[0] = '\0';
    szParameter[0] = '\0';

    if (GetByte(&ch) != ecOK)
        return ecEndOfFile;

    if (!isalpha(ch))           // a control symbol; no delimiter.
    {
        szKeyword[0] = (char) ch;
        szKeyword[1] = '\0';
        return TranslateKeyword(szKeyword, szParameter);
    }
    for (pch = szKeyword; isalpha(ch); GetByte(&ch))
        *pch++ = (char) ch;
    *pch = '\0';
    if (ch == '-')
    {
        fNeg  = TRUE;
        if (GetByte(&ch) != ecOK)
            return ecEndOfFile;
    }
    if (isdigit(ch))
    {
        pch = szParameter;
        if (fNeg) *pch++ = '-';
        for (; isdigit(ch); GetByte(&ch))
            *pch++ = (char) ch;
        *pch = '\0';
    }
    if (ch != ' ') {
        unGetByte(ch);
    } else {
        strcat(szParameter, " ");  // append the space to keyword
    }

    return TranslateKeyword(szKeyword, szParameter);
}

//
// TranslateKeyword.
// Inputs:
// szKeyword:   The RTF control to evaluate.

int
CRtfParser::TranslateKeyword(char *szKeyword, char* szParameter)
{
    BSTATUS bsStatus;
    int     isym;
    int     ec;
    BYTE    ch;

    // check specific keyword first
    if (m_sKeyword.wStatus & KW_ENABLE) 
    {
        if (strcmp(szKeyword, m_sKeyword.szKeyword) == 0) 
        {
            strcpy(m_sKeyword.szParameter, szParameter);
            if (szParameter[0] != '\0' && szParameter[0] != ' ')
                m_sKeyword.wStatus |= KW_PARAM;
            m_sKeyword.wStatus |= KW_FOUND;
            return ecOK;
        }
    }

    // search for szKeyword in rgsymRtf
    for (isym = 0; isym < g_iSymMax; isym++) {
        if (strcmp(szKeyword, g_rgSymRtf[isym].szKeyword) == 0)
            break;
    }

    if (isym == g_iSymMax)            // control word not found
    {
        if (m_fSkipDestIfUnk)         // if this is a new destination
            m_rds = rdsSkip;          // skip the destination
                                    // else just discard it
        m_fSkipDestIfUnk = FALSE;
        ec =  ecOK;
        goto gotoExit;
    }

    // found it!  use kwd and idx to determine what to do with it.

    m_fSkipDestIfUnk = FALSE;
    switch (g_rgSymRtf[isym].kwd)
    {
        case kwdChar:
            break;
        case kwdDest:
            ec = ChangeDest((IDEST)g_rgSymRtf[isym].idx);
            break;
        case kwdSpec:
            ec = ParseSpecialKeyword((IPFN)g_rgSymRtf[isym].idx, szParameter);
            break;
        default:
            ec = ecBadTable;
    }

gotoExit:
    // save keyword and parameter
    if (m_ris == risHex) {
        bsStatus = bsHex;
    } else {
        bsStatus =bsDefault;
    }
    ParseChar('\\', bsStatus);
    while (ch = *szKeyword++) ParseChar(ch, bsStatus);
    while (ch = *szParameter++) ParseChar(ch, bsStatus);

    return ec;
}

//
// ParseSpecialKeyword
//
// Evaluate an RTF control that needs special processing.
//

int
CRtfParser::ParseSpecialKeyword(IPFN ipfn, char* szParameter)
{
    if (m_rds == rdsSkip && ipfn != ipfnBin)  // if we're skipping, and it's not
        return ecOK;                        // the \bin keyword, ignore it.
    
    switch (ipfn)
    {
        case ipfnBin:
            m_ris = risBin;
            m_cbBin = atol(szParameter);
            break;
        case ipfnSkipDest:
            m_fSkipDestIfUnk = TRUE;
            break;
        case ipfnHex:
            m_ris = risHex;
            break;
        default:
            return ecBadTable;
    }
    return ecOK;
}

//
// ChangeDest
//
// Change to the destination specified by idest.
// There's usually more to do here than this...
//

int
CRtfParser::ChangeDest(IDEST idest)
{
    if (m_rds == rdsSkip)             // if we're skipping text,
        return ecOK;                // don't do anything

    switch (idest)
    {
        case idestPict:
        case idestSkip:
        default:
            m_rds = rdsSkip;              // when in doubt, skip it...
            break;
    }
    return ecOK;
}


//
// GetByte
//
// Get one char from input buffer
//

int
CRtfParser::GetByte(BYTE* pch)
{
    if (m_uCursor >= m_cchInput) {
        return ecEndOfFile;
    }

    *pch = *(m_pchInput + m_uCursor);
    m_uCursor ++;

    return ecOK;
}

//
// unGetByte
//
// adjust the cursor, return one char
//

int
CRtfParser::unGetByte(BYTE ch)
{
    if (m_uCursor) {
        m_uCursor--;
    }
    return ecOK;
}


//
// SaveByte
//
// Save one char to output buffer
//

int
CRtfParser::SaveByte(BYTE ch)
{
    if (m_uOutPos >= m_cchOutput) {
        return ecBufTooSmall;
    }

    *(m_pchOutput + m_uOutPos) = ch;
    m_uOutPos++;  // output buffer ++
    m_cchConvLen++;   // mapping range also ++

    return ecOK;
}


//
// SetStatus
//
// set the buffer status, if buffer status changed then start convert
//

int
CRtfParser::SetStatus(BSTATUS bsStatus)
{
    PBYTE pchDBCS, pchWCHAR, pchUniDes;
    UINT  i, cchLen;

    assert(m_uOutPos == m_uConvStart + m_cchConvLen);

    if (bsStatus != m_bsStatus) 
    {
        switch(m_bsStatus) 
        {
            case bsDefault:
                // control symbol, keyword, group char...
                break;

            case bsText:
                // here we got Ansi text
                // we do not do conversion for ansi text

                /*
                pchWCHAR = new BYTE[m_cchConvLen*2 + 8];
                if (!pchWCHAR) return ecOutOfMemory;

                MapFunc(m_pchOutput + m_uConvStart, m_cchConvLen, 
                    pchWCHAR, &cchLen);

                // replace old buffer with mapped buffer 
                for (i=0; i<cchLen; i++, m_uConvStart++) {
                    *(m_pchOutput + m_uConvStart) = *(pchWCHAR + i);
                }
                // set new output buffer position
                m_uOutPos = m_uConvStart;
                //
                delete [] pchWCHAR;
                */
                break;

            case bsHex:
                // when we are here, 
                // the rtf contains DBCS chars like "\'xx\'xx"
                // we only need to do DBCS->Unicode conversion, since we can not get
                // \upr keyword here (\upr is skipped, see keyword table)
                // so the MapFunc can be only (ANSI->Unicode) converter

                // we will map DBCS string "\'xx\'xx" to
                // "{\upr{"\'xx\'xx"}{\*\ud{\uc0 "Unicode string"}}}
                // in which Unicode string is like this:
                // \u12345\u-12345....
                // rtf treat unicode value as signed 16-bit decimal
                // so we don't distinquish 16-bit or 32-bit wide char, all
                // processed as 2-byte WCHAR

                if (m_cchConvLen == 0) {
                    break;
                }

                pchDBCS = new BYTE[m_cchConvLen * 3 + 8];
                if (!pchDBCS) return ecOutOfMemory;
                
                pchWCHAR = pchDBCS + m_cchConvLen; 
                // length: pchDBCS = m_cchConvLen
                //         pchWCHAR = m_cchConvLen * 2 + 8

                // map Hex string to DBCS string
                // return cchLen in Byte
                Hex2Char(m_pchOutput + m_uConvStart, m_cchConvLen, pchDBCS, m_cchConvLen, &cchLen);
                
                // map DBCS string to Unicode string
                // return cchLen in WCHAR
                cchLen = AnsiStrToUnicodeStr(pchDBCS, cchLen, (PWCH)pchWCHAR, cchLen+4);

//                MapFunc(pchDBCS, cchLen, pchWCHAR, &cchLen);

                // allocate a buffer for unicode destination
                // since one WCHAR map to max \u-xxxxx, that's 8 bytes
                // adding other 20 bytes for surrounding keywords and group chars
                // adding DBCS strings
                pchUniDes = new BYTE[cchLen * 8 + 32 + m_cchConvLen];
                if (!pchUniDes) {
                    delete pchDBCS;
                    return ecOutOfMemory;
                }

                // map to unicode destination
                GetUnicodeDestination(pchUniDes, (LPWSTR)pchWCHAR, cchLen, &cchLen);

                // replace old hex with new hex
                for (i=0; i<cchLen; i++, m_uConvStart++) {
                    *(m_pchOutput + m_uConvStart) = *(pchUniDes + i);
                }

                // set new output position
                m_uOutPos = m_uConvStart;

                // 
                delete [] pchDBCS;
                delete [] pchUniDes;
                break;

            default:
                assert(0);
                return ecAssertion;
        }

        // clean map buffer
        m_uConvStart = m_uOutPos;
        m_cchConvLen = 0;

        // set status
        m_bsStatus = bsStatus;
    }

    return ecOK;
}

//
// Hex2Char
//
// convert hex string to char string
//

int
CRtfParser::Hex2Char(BYTE* pchSrc, UINT cchSrc, BYTE* pchDes, UINT cchDes, UINT* pcchLen)
{
    BYTE* pchTmp = pchDes;
    BYTE ch;
    BYTE b = 0;
    BYTE cNibble = 2;

    // should be \'xx\'xx\'xx
    assert (cchSrc % 4 == 0);
    *pcchLen = 0;
    if (cchDes < cchSrc/4) {
        goto gotoError;
    }

    while (cchSrc--) 
    {
        ch = *pchSrc++;
        if (ch == '\\') {
            if (*pchSrc != '\'') {
                goto gotoError;
            }
        } else if (ch == '\'') { 
        } 
        else 
        {
            b = b << 4;
            if (isdigit(ch))
                b += (char) ch - '0';
            else
            {
                if (islower(ch))
                {
                    if (ch < 'a' || ch > 'f')
                        goto gotoError;
                    b += (char) ch - 'a' + 10;
                }
                else
                {
                    if (ch < 'A' || ch > 'F')
                        goto gotoError;
                    b += (char) ch - 'A' + 10;
                }
            }
            cNibble--;
            if (!cNibble)
            {
                *pchDes++ = b;
                cNibble = 2;
                b = 0;
            }
        }
    }

    *pcchLen = (UINT)(pchDes - pchTmp);
    return ecOK;

gotoError:
    assert(0);
    return ecInvalidHex;
}


#define LONIBBLE(c) (c&0x0f)
#define HINIBBLE(c) ((c&0xf0)>>4)

//
// Char2Hex
//
// convert char string to hex string
//

int  
CRtfParser::Char2Hex(BYTE* pchSrc, UINT cchSrc, BYTE* pchDes, UINT cchDes, UINT* pcchLen)
{
    BYTE* pchTmp = pchDes;
    BYTE ch,c;
    
    *pcchLen = 0;
    if (cchDes < cchSrc * 4) {
        goto gotoError;
    }

    while(cchSrc--)
    {
        *pchDes++ = '\\';
        *pchDes++ = '\'';
        ch = *pchSrc++;
        c = HINIBBLE(ch);
        if(c>9 && c<=0xF) {
            c += 'a'-10;
        } else if (c<=9) {
            c += '0';
        } else {
            goto gotoError;
        }
        *pchDes++ = c;

        c = LONIBBLE(ch);
        if(c>9 && c<=0xF) {
            c += 'a'-10;
        } else if (c<=9) {
            c += '0';
        } else {
            goto gotoError;
        }
        *pchDes++ = c;
    }

    *pcchLen = (UINT)(pchDes - pchTmp);
    return ecOK;

gotoError:
    assert(0);
    return ecInvalidHex;
}


//
// GetUnicodeDestination
//
// convert unicode string to unicode destination in RTF
// the format is:
//     "{\upr{\'xx\'xx}{\*\ud{\uc0 \u12345\u-12345}}
//

int
CRtfParser::GetUnicodeDestination(BYTE* pchUniDes, LPWSTR pwchStr, UINT wchLen, UINT* pcchLen)
{

    static char pch1[] = "{\\upr{";
    static char pch2[] = "}{\\*\\ud{\\uc0 ";
    static char pch3[] = "}}}";

    UINT  cchLen, cchDone;

    // copy \upr
    cchLen = strlen(pch1);
    memcpy(pchUniDes, pch1, cchLen);

    // copy DBCS string
    memcpy(pchUniDes + cchLen, m_pchOutput+m_uConvStart, m_cchConvLen);
    cchLen += m_cchConvLen;

    // copy middle part
    memcpy(pchUniDes + cchLen, pch2, strlen(pch2));
    cchLen += strlen(pch2);

    // copy unicode string
    for (UINT i=0; i<wchLen; i++)
    {
        WideCharToKeyword(pwchStr[i], pchUniDes + cchLen, &cchDone);

        cchLen += cchDone;
    }

    // copy last part
    memcpy(pchUniDes + cchLen, pch3, strlen(pch3));
    cchLen += strlen(pch3);

    // return
    *pcchLen = cchLen;

    return ecOK;
}


//
// WideCharToKeyword
//
// map one wide char to \u keyword
//

int 
CRtfParser::WideCharToKeyword(WCHAR wch, BYTE* pchDes, UINT* pcchLen)
{
    short num = (short) wch;
    char* pch = (char*) pchDes;

    sprintf(pch,"\\u%d", num);

    *pcchLen = strlen(pch);

    return ecOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\dlls\tools\gb18030\gbunicnv\textfile.cpp ===
#include "stdafx.h"
#include "Msg.h"
#include "ConvEng.h"
#include "RtfParser.h"
#include "TextFile.h"

BOOL ConvertTextFile(
    PBYTE pbySource,
    DWORD dwFileSize,
    PBYTE pbyTarget,
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize)
{
    BOOL  fRet = FALSE;

    if (!fAnsiToUnicode && *((PWORD)pbySource) != 0xFEFF) {
        MsgNotUnicodeTextSourceFile();
        goto Exit;
    }

    if (fAnsiToUnicode) {
        PWCH pwchTarget = (PWCH)pbyTarget;
        // Put Unicode text file flag
        *pwchTarget = 0xFEFF;
        *pnTargetFileSize = 1;

        // Convert
        *pnTargetFileSize += AnsiStrToUnicodeStr(pbySource, dwFileSize, 
            pwchTarget+1, dwFileSize+4);
        
        *pnTargetFileSize *= sizeof(WCHAR);
    } else {
        // Check and skip Uncode text file flag
        PWCH pwchData = (PWCH)pbySource;
        if (*pwchData != 0xFEFF) { return FALSE; }
        pwchData++;

        // Convert
        *pnTargetFileSize = UnicodeStrToAnsiStr(pwchData, 
            dwFileSize/sizeof(WCHAR) - 1, (PCHAR)pbyTarget, 2*(dwFileSize+4));

    }
    fRet = TRUE;

Exit:
    return fRet;
}

BOOL ConvertHtmlFile(
    PBYTE pbySource,
    DWORD dwFileSize,
    PBYTE pbyTarget,
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize)
{
    BOOL fRet = FALSE;
    WCHAR *pwch1, *pwch2;
    int nLengthIncrease;

    const WCHAR* const wszUnicodeCharset = L"charset=unicode";
    const WCHAR* const wszGBCharset = L"charset=gb2312";
    const WCHAR* wszReplaceTo;

    if (!ConvertTextFile(pbySource, dwFileSize, pbyTarget, 
        fAnsiToUnicode, pnTargetFileSize)) {
        goto Exit;
    }
    if (fAnsiToUnicode) {
        wszReplaceTo = wszUnicodeCharset;
    } else {
        wszReplaceTo = wszGBCharset;
    }
    
    *((PWCH)(pbyTarget+*pnTargetFileSize)) = 0;
    pwch1 = wcsstr((PWCH)pbyTarget, L"charset=");
    
    if (!pwch1) {
        goto Exit;
    }

    pwch2 = wcschr(pwch1, L'\"');
    if (!pwch2 || (pwch2 - pwch1 >= 20)) {
        goto Exit;
    }

    nLengthIncrease = wcslen(wszReplaceTo) - (pwch2 - pwch1);
    MoveMemory(pwch2 + nLengthIncrease, pwch2, 
        pbyTarget + *pnTargetFileSize - (PBYTE)pwch2);
    CopyMemory(pwch1, wszReplaceTo, wcslen(wszReplaceTo)*sizeof(WCHAR));
    *pnTargetFileSize += nLengthIncrease*sizeof(WCHAR);

    fRet = TRUE;

Exit:
    return fRet;
}

BOOL ConvertRtfFile(
    PBYTE pBuf,     // Read buf
    DWORD dwSize,   // File size
    PBYTE pWrite,   // Write buf
    BOOL  fAnsiToUnicode,
    PINT  pnTargetFileSize)
{
    CRtfParser* pcParser;
    DWORD dwVersion;
    DWORD dwCodepage;
    BOOL  fRet = FALSE;

    pcParser = new CRtfParser(pBuf, dwSize, pWrite, dwSize*3);
    if (!pcParser) {
        MsgOverflow();
        goto gotoExit;
    }

    if (!pcParser->fRTFFile()) {
        MsgNotRtfSourceFile();
        goto gotoExit;
    }

    if (ecOK != pcParser->GetVersion(&dwVersion) ||
        dwVersion != 1) {
        MsgNotRtfSourceFile();
        goto gotoExit;
    }
    
    if (ecOK != pcParser->GetCodepage(&dwCodepage) ||
        dwCodepage != 936) {
        MsgNotRtfSourceFile();
        goto gotoExit;
    }

    // Explain WordID by corresponding word text
    if (ecOK != pcParser->Do()) {
        MsgNotRtfSourceFile();
        goto gotoExit;
    }

    pcParser->GetResult((PDWORD)pnTargetFileSize);
    fRet = TRUE;

gotoExit:
    if (pcParser) {
        delete pcParser;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\tools\nlsplus\encodingtable\fromurt.h ===
#ifndef __FROMURT_H
#define __FROMURT_H

struct CodePageDataItem {
    int    codePage;
    int    uiFamilyCodePage;
    WCHAR  webName[64];
    WCHAR  headerName[64];
    WCHAR  bodyName[64];
    WCHAR  description[256];
    DWORD  dwFlags;
};

extern BOOL CaseInsensitiveCompHelper(WCHAR *strAChars, WCHAR *strBChars, INT32 aLength, INT32 bLength, INT32 *result);
extern CodePageDataItem ExtraCodePageData[];
extern int g_nExtraCodePageDataItems;

extern CodePageDataItem g_ReplacedCodePageData[];
extern int g_nReplacedCodePageDataItems;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\tools\nlsplus\encodingtable\frommlang.cpp ===
#include <objbase.h>
#include <mlang.h>
#include "FromMLang.h"

// --------------------------------------------------------------
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
// KEEP THIS TABLE IN SYNC WITH MLANG!!!
//
// NOTENOTE YSLin:
//   This table is from mimedb.cpp from MLang.
//   There is no interface exposed to get this data structre.  So
//   we have to copy/paste it in here.
// --------------------------------------------------------------


// Table pre-sorted by charset for binary search !!!
MIMECHARSET MimeCharSet[] =
{
//  { Charset, CodePage, InternetEncoding, Flags }
    { L"_autodetect", 50932, 50932, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"_autodetect_all", 50001, 50001, MIMECONTF_MIME_LATEST},
    { L"_autodetect_kr", 50949, 50949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$ESC", 932, 50221, MIMECONTF_MIME_IE4 },
    { L"_iso-2022-jp$SIO", 932, 50222, MIMECONTF_MIME_IE4 },
    { L"437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1968", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ANSI_X3.4-1986", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ANSI_X3.4-1986", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"arabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"arabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"ASMO-708", 1256, 708, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"Big5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"Big5-HKSCS", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CCSID00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CCSID00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CCSID01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CCSID01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CCSID01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CCSID01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CCSID01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CCSID01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CCSID01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CCSID01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CCSID01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CCSID01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"chinese", 936, 936, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"cn-big5", 950, 950, MIMECONTF_MIME_LATEST},
    { L"CN-GB", 936, 936, MIMECONTF_MIME_LATEST },
    { L"CP00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"CP00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"CP01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"CP01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"CP01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"CP01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"CP01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"CP01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"CP01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"CP01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"CP01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"CP01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"cp037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"cp1025", 1251, 21025, MIMECONTF_MIME_LATEST },
    { L"CP1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"cp1256", 1256, 1256, MIMECONTF_MIME_LATEST },
    { L"cp20001", 1252, 20001, MIMECONTF_MIME_LATEST },
    { L"cp20003", 1252, 20003, MIMECONTF_MIME_LATEST },
    { L"cp20004", 1252, 20004, MIMECONTF_MIME_LATEST },
    { L"cp20005", 1252, 20005, MIMECONTF_MIME_LATEST },
    { L"cp20261", 1252, 20261, MIMECONTF_MIME_LATEST },
    { L"cp20269", 1252, 20269, MIMECONTF_MIME_LATEST },
    { L"cp20936", 1252, 20936, MIMECONTF_MIME_LATEST },
    { L"cp20949", 1252, 20949, MIMECONTF_MIME_LATEST },
    { L"cp21027", 1252, 21027, MIMECONTF_MIME_LATEST },
    { L"CP273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"CP278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"CP280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"CP284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"CP285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"cp290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"cp297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"cp367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"cp367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"cp423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"cp424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"cp437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"CP500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"cp50227", 1252, 50227, MIMECONTF_MIME_LATEST },
    { L"cp50229", 1252, 50229, MIMECONTF_MIME_LATEST },    
    { L"cp819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"cp819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"cp850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"cp852", 1250, 852, MIMECONTF_MIME_LATEST},
    { L"cp852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"cp855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"cp857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"cp858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"cp860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"cp861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"cp862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"cp863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"cp864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"cp865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"cp866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"cp866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"cp869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"CP870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"CP871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"cp875", 1253, 875, MIMECONTF_MIME_LATEST },
    { L"cp880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"CP905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"cp930", 932, 50930, MIMECONTF_MIME_LATEST },
    { L"cp933", 949, 50933, MIMECONTF_MIME_LATEST },
    { L"cp935", 936, 50935, MIMECONTF_MIME_LATEST },
    { L"cp937", 950, 50937, MIMECONTF_MIME_LATEST },
    { L"cp939", 932, 50939, MIMECONTF_MIME_LATEST },
    { L"csASCII", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"csASCII", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"csbig5", 950, 950, MIMECONTF_MIME_LATEST | MIMECONTF_MIME_IE4 },
    { L"csEUCKR", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"csEUCPkdFmtJapanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csGB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csIBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"csIBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"csIBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"csIBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"csIBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"csIBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"csIBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"csIBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"csIBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"csIBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"csIBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"csIBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"csIBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"csIBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"csIBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"csIBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"csIBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"csIBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"csIBMThai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"csISO2022JP", 932, 50221, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO2022KR", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISO58GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"csISOLatin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"csISOLatin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatin5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"csISOLatin5", 1251, 28595, MIMECONTF_MIME_IE4},
    { L"csISOLatin9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"csISOLatinArabic", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"csISOLatinArabic", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"csISOLatinCyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinGreek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csISOLatinHebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKOI8R", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csKSC56011987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csPC8CodePage437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"csShiftJIS", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csUnicode11UTF7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"csWindows31J", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"cyrillic", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"DIN_66003", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"DOS-720", 1256, 720, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-862", 1255, 862, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"DOS-874", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ebcdic-cp-ar1", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-be", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ca", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-ch", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-DK", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-es", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fi", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-fr", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gb", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-gr", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-he", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-is", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-it", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-nl", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-CP-NO", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-roece", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-se", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-tr", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-us", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-wt", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"ebcdic-cp-yu", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-Cyrillic", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"ebcdic-de-273+euro", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"ebcdic-dk-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-es-284+euro", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fi-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-fr-297+euro", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"ebcdic-gb-285+euro", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"ebcdic-international-500+euro", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"ebcdic-is-871+euro", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"ebcdic-it-280+euro", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"EBCDIC-JP-kana", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"ebcdic-Latin9--euro", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"ebcdic-no-277+euro", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"ebcdic-se-278+euro", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"ebcdic-us-37+euro", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"ECMA-114", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ECMA-114", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ECMA-118", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ELOT_928", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"euc-kr", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"euc-kr", 949, 949, MIMECONTF_MIME_IE4 },
    { L"Extended_UNIX_Code_Packed_Format_for_Japanese", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"gb18030", 54936, 54936, MIMECONTF_MIME_LATEST },
    { L"GB_2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"GB2312", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB2312-80", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GB231280", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"GBK", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"greek", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"greek8", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hebrew", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"hz-gb-2312", 936, 52936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"IBM00858", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"IBM00924", 1252, 20924, MIMECONTF_MIME_LATEST },
    { L"IBM01047", 1252, 1047, MIMECONTF_MIME_LATEST },
    { L"IBM01140", 1252, 1140, MIMECONTF_MIME_LATEST },
    { L"IBM01141", 1252, 1141, MIMECONTF_MIME_LATEST },
    { L"IBM01142", 1252, 1142, MIMECONTF_MIME_LATEST },
    { L"IBM01143", 1252, 1143, MIMECONTF_MIME_LATEST },
    { L"IBM01144", 1252, 1144, MIMECONTF_MIME_LATEST },
    { L"IBM01145", 1252, 1145, MIMECONTF_MIME_LATEST },
    { L"IBM01146", 1252, 1146, MIMECONTF_MIME_LATEST },
    { L"IBM01147", 1252, 1147, MIMECONTF_MIME_LATEST },
    { L"IBM01148", 1252, 1148, MIMECONTF_MIME_LATEST },
    { L"IBM01149", 1252, 1149, MIMECONTF_MIME_LATEST },
    { L"IBM037", 1252, 37, MIMECONTF_MIME_LATEST },
    { L"IBM1026", 1254, 1026, MIMECONTF_MIME_LATEST },
    { L"IBM273", 1252, 20273, MIMECONTF_MIME_LATEST },
    { L"IBM277", 1252, 20277, MIMECONTF_MIME_LATEST },
    { L"IBM278", 1252, 20278, MIMECONTF_MIME_LATEST },
    { L"IBM280", 1252, 20280, MIMECONTF_MIME_LATEST },
    { L"IBM284", 1252, 20284, MIMECONTF_MIME_LATEST },
    { L"IBM285", 1252, 20285, MIMECONTF_MIME_LATEST },
    { L"IBM290", 932, 20290, MIMECONTF_MIME_LATEST },
    { L"IBM297", 1252, 20297, MIMECONTF_MIME_LATEST },
    { L"IBM367", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"IBM367", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM420", 1256, 20420, MIMECONTF_MIME_LATEST },
    { L"IBM423", 1253, 20423, MIMECONTF_MIME_LATEST },
    { L"IBM424", 1255, 20424, MIMECONTF_MIME_LATEST },
    { L"IBM437", 1252, 437, MIMECONTF_MIME_LATEST},
    { L"IBM500", 1252, 500, MIMECONTF_MIME_LATEST },
    { L"ibm737", 1252, 737, MIMECONTF_MIME_LATEST},
    { L"ibm775", 1257, 775, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"ibm819", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"IBM850", 1252, 850, MIMECONTF_MIME_LATEST },
    { L"IBM852", 1250, 852, MIMECONTF_MIME_LATEST },
    { L"IBM852", 852, 852, MIMECONTF_MIME_IE4 },
    { L"IBM855", 1250, 855, MIMECONTF_MIME_LATEST },
    { L"IBM857", 1254, 857, MIMECONTF_MIME_LATEST },
    { L"IBM860", 1252, 860, MIMECONTF_MIME_LATEST },
    { L"IBM861", 1252, 861, MIMECONTF_MIME_LATEST },
    { L"IBM862", 1255, 862, MIMECONTF_MIME_LATEST },
    { L"IBM863", 1252, 863, MIMECONTF_MIME_LATEST },
    { L"IBM864", 1256, 864, MIMECONTF_MIME_LATEST },
    { L"IBM865", 1252, 865, MIMECONTF_MIME_LATEST },
    { L"IBM866", 1251, 866, MIMECONTF_MIME_LATEST },
    { L"IBM866", 866, 866, MIMECONTF_MIME_IE4 },
    { L"IBM869", 1253, 869, MIMECONTF_MIME_LATEST },
    { L"IBM870", 1250, 870, MIMECONTF_MIME_LATEST },
    { L"IBM871", 1252, 20871, MIMECONTF_MIME_LATEST },
    { L"IBM880", 1251, 20880, MIMECONTF_MIME_LATEST },
    { L"IBM905", 1254, 20905, MIMECONTF_MIME_LATEST },
    { L"IBM-Thai", 874, 20838, MIMECONTF_MIME_LATEST },
    { L"irv", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"ISO-10646-UCS-2", 1200, 1200, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"ISO_646.irv:1991", 1252, 1252,  MIMECONTF_MIME_IE4},
    { L"iso_8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso_8859-1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"iso_8859-1:1987", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso_8859-1:1987", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso_8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso_8859-2:1987", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-3:1988", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-4:1988", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-5:1988", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-6", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-6:1987", 1256, 28596, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-6:1987", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"ISO_8859-7",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-7:1987",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8:1988", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ISO_8859-8-I", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"ISO_8859-9:1989", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"ISO_8859-9:1989", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-2022-jp", 932, 50220, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-jpeuc", 932, 51932, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr", 949, 50225, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-2022-kr-7", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-7bit", 949, 50225, MIMECONTF_MIME_LATEST},
    { L"iso-2022-kr-8", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"iso-2022-kr-8bit", 949, 51949, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 20127, MIMECONTF_MIME_LATEST },
    { L"ISO646-US", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso8859-1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"iso8859-1", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-8859-1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-8859-1", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"iso-8859-11", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-13", 1257, 28603, MIMECONTF_MIME_LATEST},
    { L"iso-8859-15", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"iso8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-8859-2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-3", 1254, 28593, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-5", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-6", 1256, 28596, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-7", 1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-8", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ISO-8859-8 Visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"ISO-8859-8 Visual", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"iso-8859-8-i", 1255, 38598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"iso-8859-9", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-8859-9", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-100", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"iso-ir-100", 1252, 1252, MIMECONTF_MIME_IE4 },
    { L"iso-ir-101", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-109", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"iso-ir-110", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-126",  1253, 28597, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-127", 1256, 28596, MIMECONTF_MIME_LATEST },
    { L"iso-ir-127", 1256, 1256, MIMECONTF_MIME_IE4},
    { L"iso-ir-138", 1255, 28598, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-144", 1251, 28595, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-148", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"iso-ir-148", 1254, 1254, MIMECONTF_MIME_IE4 },
    { L"iso-ir-149", 949, 949, MIMECONTF_MIME_LATEST},
    { L"iso-ir-58", 936, 936, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"iso-ir-6", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"iso-ir-6", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"Johab", 1361, 1361, MIMECONTF_MIME_LATEST},
    { L"koi", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"koi8", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8r", 1251, 20866, MIMECONTF_MIME_LATEST},
    { L"koi8-r", 1251, 20866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-ru", 1251, 21866, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"koi8-u", 1251, 21866, MIMECONTF_MIME_LATEST},
    { L"korean", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks_c_5601_1987", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks_c_5601-1987", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"ks_c_5601-1989", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC_5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"KSC5601", 949, 949, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"ks-c5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"ks-c-5601", 949, 949, MIMECONTF_MIME_LATEST},
    { L"l1", 1252, 28591, MIMECONTF_MIME_LATEST},
    { L"l2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"l4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"l5", 1254, 28599, MIMECONTF_MIME_LATEST },
    { L"l5", 1251, 28595, MIMECONTF_MIME_IE4 },
    { L"l9", 1252, 28605, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 28591, MIMECONTF_MIME_LATEST },
    { L"latin1", 1252, 1252,  MIMECONTF_MIME_IE4 },
    { L"latin2", 1250, 28592, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin3", 1254, 28593, MIMECONTF_MIME_LATEST},
    { L"latin4", 1257, 28594, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"latin5", 1254, 28599, MIMECONTF_MIME_LATEST},
    { L"latin5", 1254, 1254, MIMECONTF_MIME_IE4},
    { L"latin9", 1252, 28605, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"logical", 1255, 1255, MIMECONTF_MIME_IE4},
    { L"macintosh", 1252, 10000, MIMECONTF_MIME_LATEST},
    { L"ms_Kanji", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"NS_4551-1", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"PC-Multilingual-850+euro", 1252, 858, MIMECONTF_MIME_LATEST },
    { L"SEN_850200_B", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"shift_jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"shift-jis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"sjis", 932, 932, MIMECONTF_MIME_LATEST},
    { L"Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"TIS-620", 874, 874, MIMECONTF_MIME_LATEST},
    { L"ucs-2", 1200, 1200, MIMECONTF_MIME_LATEST},
    { L"unicode", 1200, 1200, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"unicode-2-0-utf-8",1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"unicodeFFFE", 1200, 1201, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"us", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"us-ascii", 1252, 20127, MIMECONTF_MIME_LATEST},
    { L"us-ascii", 1252, 1252, MIMECONTF_MIME_IE4},
    { L"utf-16", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"UTF-16BE", 1200, 1201, MIMECONTF_MIME_LATEST },
    { L"UTF-16LE", 1200, 1200, MIMECONTF_MIME_LATEST },
    { L"utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"visual", 1255, 28598, MIMECONTF_MIME_LATEST},
    { L"visual", 1255, 1255, MIMECONTF_MIME_IE4 },
    { L"windows-1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1252", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1253", 1253, 1253, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"Windows-1254", 1254, 1254, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1255", 1255, 1255, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1256", 1256, 1256, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1257", 1257, 1257, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-1258", 1258, 1258, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"windows-20932-2000", 932, 20932, MIMECONTF_MIME_LATEST },
    { L"windows-874", 874, 874, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-ansi", 1252, 1252, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Chinese-CNS", 950, 20000, MIMECONTF_MIME_LATEST},
    { L"x-Chinese-Eten", 950, 20002, MIMECONTF_MIME_LATEST},
    { L"x-cp1250", 1250, 1250, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-cp1251", 1251, 1251, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"X-EBCDIC-JapaneseAndUSCanada", 932, 50931, MIMECONTF_MIME_LATEST },
    { L"X-EBCDIC-KoreanExtended", 949, 20833, MIMECONTF_MIME_LATEST },
    { L"x-euc", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-euc-cn", 936, 51936, MIMECONTF_MIME_LATEST},
    { L"x-euc-jp", 932, 51932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-Europa", 1252, 29001, MIMECONTF_MIME_LATEST},
    { L"x-IA5", 1252, 20105, MIMECONTF_MIME_LATEST},
    { L"x-IA5-German", 1252, 20106, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Norwegian", 1252, 20108, MIMECONTF_MIME_LATEST},
    { L"x-IA5-Swedish", 1252, 20107, MIMECONTF_MIME_LATEST},
    { L"x-iscii-as", 57006, 57006, MIMECONTF_MIME_LATEST},
    { L"x-iscii-be", 57003, 57003, MIMECONTF_MIME_LATEST},
    { L"x-iscii-de", 57002, 57002, MIMECONTF_MIME_LATEST},
    { L"x-iscii-gu", 57010, 57010, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ka", 57008, 57008, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ma", 57009, 57009, MIMECONTF_MIME_LATEST},
    { L"x-iscii-or", 57007, 57007, MIMECONTF_MIME_LATEST},
    { L"x-iscii-pa", 57011, 57011, MIMECONTF_MIME_LATEST},
    { L"x-iscii-ta", 57004, 57004, MIMECONTF_MIME_LATEST},
    { L"x-iscii-te", 57005, 57005, MIMECONTF_MIME_LATEST},
    { L"x-mac-arabic", 1256, 10004, MIMECONTF_MIME_LATEST},
    { L"x-mac-ce", 1250, 10029, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesesimp", 936, 10008, MIMECONTF_MIME_LATEST},
    { L"x-mac-chinesetrad", 950, 10002, MIMECONTF_MIME_LATEST},
    { L"x-mac-croatian", 1250, 10082, MIMECONTF_MIME_LATEST}, 
    { L"x-mac-cyrillic", 1251, 10007, MIMECONTF_MIME_LATEST},
    { L"x-mac-greek", 1253, 10006, MIMECONTF_MIME_LATEST},
    { L"x-mac-hebrew", 1255, 10005, MIMECONTF_MIME_LATEST},
    { L"x-mac-icelandic", 1252, 10079, MIMECONTF_MIME_LATEST},
    { L"x-mac-japanese", 932, 10001, MIMECONTF_MIME_LATEST},
    { L"x-mac-korean", 949, 10003, MIMECONTF_MIME_LATEST},
    { L"x-mac-romanian", 1250, 10010, MIMECONTF_MIME_LATEST},
    { L"x-mac-thai", 874, 10021, MIMECONTF_MIME_LATEST},
    { L"x-mac-turkish", 1254, 10081, MIMECONTF_MIME_LATEST},
    { L"x-mac-ukrainian", 1251, 10017, MIMECONTF_MIME_LATEST},
    { L"x-ms-cp932", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-sjis", 932, 932, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4 },
    { L"x-unicode-1-1-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST},
    { L"x-unicode-1-1-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST},
    { L"x-unicode-2-0-utf-7", 1200, 65000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-unicode-2-0-utf-8", 1200, 65001, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-user-defined", 50000, 50000, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},
    { L"x-x-big5", 950, 950, MIMECONTF_MIME_LATEST| MIMECONTF_MIME_IE4},

//  { Charset, CodePage, InternetEncoding, Flags }
};

const int g_nMIMECharsets = sizeof(MimeCharSet)/sizeof(MIMECHARSET);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\tools\nlsplus\encodingtable\frommlang.h ===
#ifndef __FROMMLANG_H
#define __FROMMLANG_H

typedef struct tagMIMEREGCHARSET
{
    LPCWSTR szCharset;
    UINT uiCodePage;
    UINT uiInternetEncoding;
    DWORD   dwFlags;
}   MIMECHARSET;

//
// Forward declaration
//
extern MIMECHARSET MimeCharSet[];
extern const int g_nMIMECharsets;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\tools\nlsplus\encodingtable\fromurt.cpp ===
#include <windows.h>
#include <objbase.h>
#include <mlang.h>
#include "FromURT.h"

//
// These are extra CodePageDataItems for which MLang doesn't contain information.
//
//


CodePageDataItem ExtraCodePageData[1];
/*
{
    { 20932, 932, L"windows-20932-2000", L"windows-20932-2000", L"windows-20932-2000", L"Japanese EUC:ASCii,Halfwidth Katakana,JIS X 0208-1990 & 0212-1990", MIMECONTF_MIME_LATEST },
    { 54936, 936, L"gb18030", L"gb18030", L"gb18030", L"GB 18030-2000 Simplified Chinese", MIMECONTF_MIME_LATEST},
};
*/

//int g_nExtraCodePageDataItems = sizeof(ExtraCodePageData)/sizeof(ExtraCodePageData[0]);
int g_nExtraCodePageDataItems = 0;


//
// Although MLang contains the following codepage, we replace MLang information with the
// information below.
//
CodePageDataItem g_ReplacedCodePageData[] =
{
    { 1200,  1200, L"utf-16", L"utf-16", L"utf-16", L"Unicode", MIMECONTF_MIME_LATEST | MIMECONTF_SAVABLE_BROWSER },
};

int g_nReplacedCodePageDataItems = sizeof(g_ReplacedCodePageData)/sizeof(g_ReplacedCodePageData[0]);

//
// The code here is from COMString.cpp.
//
BOOL CaseInsensitiveCompHelper(WCHAR *strAChars, WCHAR *strBChars, INT32 aLength, INT32 bLength, INT32 *result) 
{
    WCHAR charA;
    WCHAR charB;
    WCHAR *strAStart;
        
    strAStart = strAChars;

    *result = 0;

    //setup the pointers so that we can always increment them.
    //We never access these pointers at the negative offset.
    strAChars--;
    strBChars--;

    do {
        strAChars++; strBChars++;

        charA = *strAChars;
        charB = *strBChars;
            
        //Case-insensitive comparison on chars greater than 0x80 
        //requires a locale-aware casing operation and we're not going there.
        if (charA>=0x80 || charB>=0x80) {
            return FALSE;
        }
          
        //Do the right thing if they differ in case only.
        //We depend on the fact that the uppercase and lowercase letters in the
        //range which we care about (A-Z,a-z) differ only by the 0x20 bit. 
        //The check below takes the xor of the two characters and determines if this bit
        //is only set on one of them.
        //If they're different cases, we know that we need to execute only
        //one of the conditions within block.
        if ((charA^charB)&0x20) {
            if (charA>='A' && charA<='Z') {
                charA |=0x20;
            } else if (charB>='A' && charB<='Z') {
                charB |=0x20;
            }
        }
    } while (charA==charB && charA!=0);
        
    //Return the (case-insensitive) difference between them.
    if (charA!=charB) {
        *result = (int)(charA-charB);
        return TRUE;
    }

    //The length of b was unknown because it was just a pointer to a null-terminated string.
    //If we get here, we know that both A and B are pointing at a null.  However, A can have
    //an embedded null.  Check the number of characters that we've walked in A against the 
    //expected length.
    if (bLength==-1) {
        if ((strAChars - strAStart)!=aLength) {
            *result = 1;
            return TRUE;
        }
        *result=0;
        return TRUE;
    }

    *result = (aLength - bLength);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\alloc.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    alloc.c

Abstract:

    This file contains functions that will allocate the necessary memory
    blocks.

    External Routines in this file:
      AllocateMB
      AllocateGlyph
      AllocateTopDBCS
      AllocateDBCS
      AllocateWCTable
      Allocate8
      Insert844
      Insert844Map
      AllocateTemp844
      AllocateCTMap
      AllocateGrid
      AllocateLangException
      AllocateLangExceptionNodes
      AllocateSortDefault
      AllocateReverseDW
      AllocateDoubleCompression
      AllocateIdeographLcid
      AllocateExpansion
      AllocateCompression
      AllocateCompression2Nodes
      AllocateCompression3Nodes
      AllocateException
      AllocateExceptionNodes
      AllocateMultipleWeights
      AllocateIdeographExceptions
      Free844
      FreeCTMap

Revision History:

    07-30-91    JulieB    Created.
    03-10-00    lguindon  Add explicit typecast to remove build errors
--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

CT_MAP_VALUE
MapTrioToByte(
    PCT_MAP pMap,
    WORD Value1,
    WORD Value2,
    WORD Value3);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  AllocateMB
//
//  This routine allocates all structures needed for the MB table.
//  If an error is encountered while allocating, an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int AllocateMB(
    PCODEPAGE pCP)
{
    //
    //  Allocate MB Table buffer.
    //  Set all entries in MB Table to zero.
    //
    if ((pCP->pMB = (PMB_TBL)malloc(MB_TABLE_SIZE * sizeof(WORD))) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(pCP->pMB, 0, MB_TABLE_SIZE * sizeof(WORD));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateGlyph
//
//  This routine allocates all structures needed for the Glyph table.
//  If an error is encountered while allocating, an error is returned.
//  All entries in the glyph table are set equal to the entries in the
//  MB table.  If the MB table has not been read in yet, then an error
//  is returned.
//
//  06-02-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateGlyph(
    PCODEPAGE pCP)
{
    int ctr;                 // loop counter


    //
    //  Allocate Glyph Table buffer.
    //
    if ((pCP->pGlyph = (PGLYPH_TBL)malloc( GLYPH_TABLE_SIZE *
                                           sizeof(WORD) )) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }

    //
    //  Make sure the MB table has already been read in at this point.
    //
    if ((!(pCP->WriteFlags & F_MB)) || (pCP->pMB == NULL))
    {
        printf("Parse Error: MBTABLE must be BEFORE GLYPHTABLE in file.\n");
        return (1);
    }

    //
    //  Set all entries in the Glyph Table to the MB Table entries.
    //  All new glyph values will overwrite the appropriate MB entries
    //  in the glyph table.
    //
    for (ctr = 0; ((ctr < GLYPH_TABLE_SIZE) && (ctr < MB_TABLE_SIZE)); ctr++)
    {
        (pCP->pGlyph)[ctr] = (pCP->pMB)[ctr];
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateTopDBCS
//
//  This routine allocates the initial DBCS array structure.  If an error
//  is encountered while allocating, an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int AllocateTopDBCS(
    PCODEPAGE pCP,
    int Size)
{
    //
    //  Allocate initial DBCS array structure.
    //
    if ((pCP->pDBCS = (PDBCS_ARRAY)malloc( Size *
                                           sizeof(PDBCS_RANGE) )) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(pCP->pDBCS, 0, Size * sizeof(PDBCS_RANGE));

    //
    //  Allocate offset area.
    //
    if ((pCP->pDBCSOff = (PDBCS_OFFSETS)malloc( DBCS_OFFSET_SIZE *
                                                sizeof(WORD) )) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(pCP->pDBCSOff, 0, DBCS_OFFSET_SIZE * sizeof(WORD));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateDBCS
//
//  This routine allocates all structures needed for the DBCS tables and
//  ranges.  If an error is encountered while allocating, an error is
//  returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int AllocateDBCS(
    PCODEPAGE pCP,
    int Low,
    int High,
    int Index)
{
    PDBCS_RANGE pRange;                // ptr to DBCS range
    PDBCS_TBL_ARRAY pTblArray;         // ptr to DBCS table array
    int Ctr, Ctr2;                     // loop counters
    int NumTables = High - Low + 1;    // number of tables for range
    WORD *pWordPtr;                    // ptr to dbcs buffer


    //
    //  Allocate Range Structure.
    //
    if ((pRange = (PDBCS_RANGE)malloc(sizeof(DBCS_RANGE))) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(pRange, 0, sizeof(DBCS_RANGE));

    //
    //  Allocate Table Array.
    //
    if ((pTblArray = (PDBCS_TBL_ARRAY)malloc( NumTables *
                                              sizeof(PDBCS_TBL) )) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(pTblArray, 0, NumTables * sizeof(PDBCS_TBL));

    //
    //  Allocate All Tables.
    //
    for (Ctr = 0; Ctr < NumTables; Ctr++)
    {
        //
        //  Allocate table.
        //
        if ((pTblArray[Ctr] = (PDBCS_TBL)malloc( DBCS_TABLE_SIZE *
                                                 sizeof(WORD) )) == NULL)
        {
            printf("Error: Can't allocate buffer.\n");
            return (1);
        }

        //
        //  Set all entries to the Unicode default character.
        //
        pWordPtr = (WORD *)(pTblArray[Ctr]);
        for (Ctr2 = 0; Ctr2 < DBCS_TABLE_SIZE; Ctr2++)
        {
            pWordPtr[Ctr2] = (WORD)(pCP->UniDefaultChar);
        }
    }

    //
    //  Attach the tables to each other.
    //
    pRange->pDBCSTbls = pTblArray;
    (pCP->pDBCS)[Index] = pRange;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateWCTable
//
//  This routine allocates the buffer for the Unicode to ANSI translation
//  table.  The buffer is (64K //  Size) bytes in length.
//
//  05-28-92    JulieB      Created.
////////////////////////////////////////////////////////////////////////////

int AllocateWCTable(
    PCODEPAGE pCP,
    int Size)
{
    int Ctr;                      // loop counter
    WORD *pWordPtr;               // ptr to wide character buffer


    //
    //  Allocate translation table buffer.
    //
    if ((pCP->pWC = (PWC_ARRAY)malloc(WC_TABLE_SIZE * Size)) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }

    //
    //  Set all entries to the default character.
    //
    if (Size == sizeof(BYTE))
    {
        memset(pCP->pWC, (BYTE)(pCP->DefaultChar), WC_TABLE_SIZE);
    }
    else if (Size == sizeof(WORD))
    {
        pWordPtr = pCP->pWC;
        for (Ctr = 0; Ctr < WC_TABLE_SIZE; Ctr++)
        {
            pWordPtr[Ctr] = pCP->DefaultChar;
        }
    }
    else
    {
        printf("Code Error: Bad 'Size' parameter for AllocateWCTable.\n");
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Allocate8
//
//  This routine allocates the top buffer for the 8:4:4 table.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Allocate8(
    P844_ARRAY *pArr)
{
    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if ((*pArr = (P844_ARRAY)malloc( TABLE_SIZE_8 *
                                     sizeof(P844_ARRAY) )) == NULL)
    {
        printf("Error: Can't allocate top 8:4:4 buffer.\n");
        return (1);
    }
    memset(*pArr, 0, TABLE_SIZE_8 * sizeof(P844_ARRAY));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Insert844
//
//  This routine inserts a WORD or DWORD value into an 8:4:4 table based on
//  the Size parameter.  It does so by allocating the appropriate buffers
//  and filling in the third buffers with the appropriate WORD or DWORD value.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Insert844(
    P844_ARRAY pArr,
    WORD WChar,
    DWORD Value,
    int *cbBuf2,
    int *cbBuf3,
    int Size)
{
    register int Index;           // index into array
    P844_ARRAY pTbl2;             // pointer to second array
    P844_ARRAY pTbl3;             // pointer to third array


    //
    //  Use the "8" index to get to the second table.
    //  Allocate it if necessary.
    //
    Index = GET8(WChar);
    if ((pTbl2 = (P844_ARRAY)(pArr[Index])) == NULL)
    {
        //
        //  Allocate second table - 16 pointers.
        //
        if ((pTbl2 = (P844_ARRAY)malloc( TABLE_SIZE_4 *
                                         sizeof(P844_ARRAY) )) == NULL)
        {
            printf("Error: Can't allocate second 8:4:4 buffer.\n");
            return (1);
        }
        memset(pTbl2, 0, TABLE_SIZE_4 * sizeof(P844_ARRAY));
        pArr[Index] = pTbl2;

        //
        //  Keep track of how many "second buffer" allocations were made.
        //
        (*cbBuf2)++;
    }

    //
    //  Use the "high 4" index to get to the third table.
    //  Allocate it if necessary.
    //
    Index = GETHI4(WChar);
    if ((pTbl3 = pTbl2[Index]) == NULL)
    {
        //
        //  Allocate third table - 16 words.
        //
        if ((pTbl3 = (P844_ARRAY)malloc(TABLE_SIZE_4 * Size)) == NULL)
        {
            printf("Error: Can't allocate third 8:4:4 buffer.\n");
            return (1);
        }
        memset(pTbl3, 0, TABLE_SIZE_4 * Size);
        pTbl2[Index] = pTbl3;

        //
        //  Keep track of how many "third buffer" allocations were made.
        //
        (*cbBuf3)++;
    }

    //
    //  Use the "low 4" value to index into the third table.
    //  Save the value at this spot.
    //
    Index = GETLO4(WChar);

    if (Size == sizeof(WORD))
    {
        ((WORD *)pTbl3)[Index] = (WORD)Value;
    }
    else if (Size == sizeof(DWORD))
    {
        ((DWORD *)pTbl3)[Index] = (DWORD)Value;
    }
    else
    {
        printf("Code Error: Bad 'Size' parameter for Insert844 Table.\n");
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Insert844Map
//
//  This routine inserts 3 WORD values into an 8:4:4 table.  It does so by
//  allocating the appropriate buffers and filling in the third buffers
//  with a 1 BYTE value that is the mapping of the given 3 WORD trio.
//
//  10-29-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Insert844Map(
    P844_ARRAY pArr,
    PCT_MAP pMap,
    WORD WChar,
    WORD Value1,
    WORD Value2,
    WORD Value3,
    int *cbBuf2,
    int *cbBuf3)
{
    register int Index;           // index into array
    P844_ARRAY pTbl2;             // pointer to second array
    PCT_MAP_VALUE pTbl3;          // pointer to third array


    //
    //  Use the "8" index to get to the second table.
    //  Allocate it if necessary.
    //
    Index = GET8(WChar);
    if ((pTbl2 = (P844_ARRAY)(pArr[Index])) == NULL)
    {
        //
        //  Allocate second table - 16 pointers + 1 word.
        //  The additional 1 word will be used when writing this table
        //  to avoid duplicates of the same table.
        //
        if ((pTbl2 = (P844_ARRAY)malloc( (TABLE_SIZE_4 + 1) *
                                         sizeof(P844_ARRAY) )) == NULL)
        {
            printf("Error: Can't allocate second 8:4:4 buffer.\n");
            return (1);
        }
        memset(pTbl2, 0, (TABLE_SIZE_4 + 1) * sizeof(P844_ARRAY));
        pArr[Index] = pTbl2;

        //
        //  Keep track of how many "second buffer" allocations were made.
        //
        (*cbBuf2)++;
    }

    //
    //  Use the "high 4" index to get to the third table.
    //  Allocate it if necessary.
    //
    Index = GETHI4(WChar);
    if ((pTbl3 = pTbl2[Index]) == NULL)
    {
        //
        //  Allocate third table - 16 + 2 bytes.
        //  The 2 extra bytes will be used when writing the table.
        //
        if ((pTbl3 = (PCT_MAP_VALUE)malloc( (TABLE_SIZE_4 + 2) *
                                            (sizeof(CT_MAP_VALUE)) )) == NULL)
        {
            printf("Error: Can't allocate third 8:4:4 buffer.\n");
            return (1);
        }

        //
        //  The last field of the third table is used when writing to the
        //  data file to ensure that each table is written only ONCE
        //  (with muliple pointers to it).  This field takes 1 WORD
        //  (2 bytes) and is initialized to 0.
        //
        memset(pTbl3, 0, (TABLE_SIZE_4 + 2) * (sizeof(CT_MAP_VALUE)));
        pTbl2[Index] = pTbl3;

        //
        //  Keep track of how many "third buffer" allocations were made.
        //
        (*cbBuf3)++;
    }

    //
    //  Use the "low 4" value to index into the third table.
    //  Save the values at this spot.
    //
    Index = GETLO4(WChar);

    //
    //  Map 3 WORD CType trio to 1 BYTE value.
    //
    pTbl3[Index] = MapTrioToByte( pMap,
                                  Value1,
                                  Value2,
                                  Value3 );

    //
    //  Make sure the number of entries in the mapping table is
    //  not greater than MAX_CT_MAP_TBL_SIZE.
    //
    if (pMap->Length >= MAX_CT_MAP_TBL_SIZE)
    {
        printf("Error: CTYPE Mapping Table Too Large.\n");
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateTemp844
//
//  This routine allocates the temporary storage buffer for the 8:4:4
//  table.  This temporary buffer is used when writing to the output file.
//  The size of the buffer is (TblSize * Size) bytes in length.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateTemp844(
    PVOID *ppArr,
    int TblSize,
    int Size)
{
    //
    //  Allocate buffer of size TblSize.
    //
    if ((*ppArr = (PVOID)malloc(TblSize * Size)) == NULL)
    {
        printf("Error: Can't allocate temp 8:4:4 buffer.\n");
        return (1);
    }
    memset(*ppArr, 0, TblSize * Size);

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateCTMap
//
//  This routine allocates all structures needed for the ctype mapping table.
//  If an error is encountered while allocating, an error is returned.
//
////////////////////////////////////////////////////////////////////////////

int AllocateCTMap(
    PCT_MAP *pMap)
{
    //
    //  Allocate buffer mapping table.
    //
    if ((*pMap = (PCT_MAP)malloc(sizeof(CT_MAP))) == NULL)
    {
        printf("Error: Can't allocate buffer for CType Mapping table.\n");
        return (1);
    }
    memset(*pMap, 0, sizeof(CT_MAP));

    //
    //  Allocate mapping table entries.
    //
    if (((*pMap)->pCTValues = (PCT_VALUES)malloc( MAX_CT_MAP_TBL_SIZE *
                                                  sizeof(CT_VALUES) )) == NULL)
    {
        printf("Error: Can't allocate CType mapping table with %d entries.\n",
               MAX_CT_MAP_TBL_SIZE);
        return (1);
    }

    //
    //  Set the first entry to 0 so that any third level table that maps
    //  to 0 will be C1 = 0, C2 = 0, and C3 = 0.
    //
    memset((*pMap)->pCTValues, 0, sizeof(CT_VALUES));
    (*pMap)->Length = 1;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateGrid
//
//  This routine allocates the 2D grid for the composite table.
//  The size passed in is the number of precomposed entries that need to
//  go into the table.  Since the exact size of the array is not known yet,
//  the maximum possible size is allocated (size squared).
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateGrid(
    PCOMP_GRID *pCompGrid,
    int TblSize)
{
    //
    //  Allocate 2D grid.
    //  The size of the grid is the TblSize squared plus one to save the
    //  size of the grid.
    //
    if ((*pCompGrid = (PCOMP_GRID)malloc( (TblSize * TblSize + 1) *
                                          sizeof(WORD) )) == NULL)
    {
        printf("Error: Can't allocate buffer.\n");
        return (1);
    }
    memset(*pCompGrid, 0, (TblSize * TblSize + 1) * sizeof(WORD));

    //
    //  Save the size of the grid in the first spot.
    //
    (*pCompGrid)[0] = (WORD)TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateLangException
//
//  This routine allocates the exception header and the exception table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the header and the table are stored in the language
//  structure.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateLangException(
    PLANG_EXCEPT pLangExcept,
    int TblSize)
{
    //
    //  Set the number of Exception entries in table.
    //
    pLangExcept->NumException = TblSize;

    //
    //  Allocate buffer of size TblSize for Exception header.
    //
    if ((pLangExcept->pExceptHdr =
            (PL_EXCEPT_HDR)malloc(TblSize * sizeof(L_EXCEPT_HDR))) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception Header.\n");
        return (1);
    }
    memset(pLangExcept->pExceptHdr, 0, TblSize * sizeof(L_EXCEPT_HDR));

    //
    //  Allocate buffer of size TblSize for Exception table.
    //
    if ((pLangExcept->pExceptTbl =
            (PL_EXCEPT_TBL)malloc(TblSize * sizeof(PL_EXCEPT_NODE))) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception table.\n");
        return (1);
    }
    memset(pLangExcept->pExceptTbl, 0, TblSize * sizeof(PL_EXCEPT_NODE));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateLangExceptionNodes
//
//  This routine allocates the exception nodes for the exception table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the nodes is stored in the exception table at the Index
//  given.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateLangExceptionNodes(
    PLANG_EXCEPT pLangExcept,
    int TblSize,
    int Index)
{
    PL_EXCEPT_NODE pExcNode;      // ptr to exception node


    //
    //  Allocate buffer of size TblSize for Exception nodes.
    //
    if ((pExcNode = (PL_EXCEPT_NODE)malloc( TblSize *
                                            sizeof(L_EXCEPT_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception Nodes.\n");
        return (1);
    }
    memset(pExcNode, 0, TblSize * sizeof(L_EXCEPT_NODE));

    //
    //  Set pointer in exception table.
    //
    (pLangExcept->pExceptTbl)[Index] = pExcNode;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateSortDefault
//
//  This routine allocates the sort default table - 64K DWORDS.  The pointer
//  to the new table is stored in the sortkey structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateSortDefault(
    PSORTKEY pSKey)
{
    //
    //  Allocate buffer of size 64K DWORDS for sort default table.
    //
    if ((pSKey->pDefault = (PSKEY)malloc( SKEY_TBL_SIZE *
                                          sizeof(SKEY) )) == NULL)
    {
        printf("Error: Can't allocate buffer for sortkey default table.\n");
        return (1);
    }
    memset(pSKey->pDefault, 0, SKEY_TBL_SIZE * sizeof(SKEY));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateReverseDW
//
//  This routine allocates the reverse diacritic weight table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the sorttables structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateReverseDW(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Allocate buffer of size TblSize for RevrseDW table.
    //
    if ((pSTbl->pReverseDW = (PREV_DW)malloc( TblSize *
                                              sizeof(REV_DW) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Reverse DW table.\n");
        return (1);
    }
    memset(pSTbl->pReverseDW, 0, TblSize * sizeof(REV_DW));

    //
    //  Set the number of ReverseDW entries in table.
    //
    pSTbl->NumReverseDW = TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateDoubleCompression
//
//  This routine allocates the double compression table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the sorttables structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateDoubleCompression(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Allocate buffer of size TblSize for Double Compression table.
    //
    if ((pSTbl->pDblCompression =
        (PDBL_COMPRESS)malloc(TblSize * sizeof(DBL_COMPRESS))) == NULL)
    {
        printf("Error: Can't allocate buffer for Double Compression table.\n");
        return (1);
    }
    memset(pSTbl->pDblCompression, 0, TblSize * sizeof(DBL_COMPRESS));

    //
    //  Set the number of Double Compression entries in table.
    //
    pSTbl->NumDblCompression = TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateIdeographLcid
//
//  This routine allocates the ideograph lcid table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the sorttables structure.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateIdeographLcid(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Allocate buffer of size TblSize for IdeographLcid table.
    //
    if ((pSTbl->pIdeographLcid =
           (PIDEOGRAPH_LCID)malloc(TblSize * sizeof(IDEOGRAPH_LCID))) == NULL)
    {
        printf("Error: Can't allocate buffer for Ideograph Lcid table.\n");
        return (1);
    }
    memset(pSTbl->pIdeographLcid, 0, TblSize * sizeof(IDEOGRAPH_LCID));

    //
    //  Set the number of Ideograph Lcid entries in table.
    //
    pSTbl->NumIdeographLcid = TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateExpansion
//
//  This routine allocates the expansion table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the sorttables structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateExpansion(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Allocate buffer of size TblSize for Expansion table.
    //
    if ((pSTbl->pExpansion = (PEXPAND)malloc( TblSize *
                                              sizeof(EXPAND) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Expansion table.\n");
        return (1);
    }
    memset(pSTbl->pExpansion, 0, TblSize * sizeof(EXPAND));

    //
    //  Set the number of Expansion entries in table.
    //
    pSTbl->NumExpansion = TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateCompression
//
//  This routine allocates the compression header and the compression table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the header and the table are stored in the sorttables
//  structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateCompression(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Set the number of Compression entries in table.
    //
    pSTbl->NumCompression = TblSize;

    //
    //  Allocate buffer of size TblSize for Compression header.
    //
    if ((pSTbl->pCompressHdr =
            (PCOMPRESS_HDR)malloc(TblSize * sizeof(COMPRESS_HDR))) == NULL)
    {
        printf("Error: Can't allocate buffer for Compression Header.\n");
        return (1);
    }
    memset(pSTbl->pCompressHdr, 0, TblSize * sizeof(COMPRESS_HDR));

    //
    //  Allocate buffer of size TblSize for Compression 2 table.
    //
    if ((pSTbl->pCompress2Tbl =
            (PCOMPRESS_2_TBL)malloc( TblSize *
                                     sizeof(PCOMPRESS_2_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Compression 2 table.\n");
        return (1);
    }
    memset(pSTbl->pCompress2Tbl, 0, TblSize * sizeof(PCOMPRESS_2_NODE));

    //
    //  Allocate buffer of size TblSize for Compression 3 table.
    //
    if ((pSTbl->pCompress3Tbl =
            (PCOMPRESS_3_TBL)malloc( TblSize *
                                     sizeof(PCOMPRESS_3_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Compression 3 table.\n");
        return (1);
    }
    memset(pSTbl->pCompress3Tbl, 0, TblSize * sizeof(PCOMPRESS_3_NODE));

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateCompression2Nodes
//
//  This routine allocates the compression 2 nodes for the compression table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the nodes is stored in the compression table at the Index
//  given.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateCompression2Nodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index)
{
    PCOMPRESS_2_NODE pCompNode;          // ptr to compression 2 node


    //
    //  Allocate buffer of size TblSize for Compression nodes.
    //
    if ((pCompNode =
            (PCOMPRESS_2_NODE)malloc( TblSize *
                                      sizeof(COMPRESS_2_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Compression 2 Nodes.\n");
        return (1);
    }
    memset(pCompNode, 0, TblSize * sizeof(COMPRESS_2_NODE));

    //
    //  Set pointer in compression 2 table.
    //
    (pSTbl->pCompress2Tbl)[Index] = pCompNode;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateCompression3Nodes
//
//  This routine allocates the compression 3 nodes for the compression table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the nodes is stored in the compression table at the Index
//  given.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateCompression3Nodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index)
{
    PCOMPRESS_3_NODE pCompNode;          // ptr to compression 3 node


    //
    //  Allocate buffer of size TblSize for Compression nodes.
    //
    if ((pCompNode =
            (PCOMPRESS_3_NODE)malloc( TblSize *
                                      sizeof(COMPRESS_3_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Compression 3 Nodes.\n");
        return (1);
    }
    memset(pCompNode, 0, TblSize * sizeof(COMPRESS_3_NODE));

    //
    //  Set pointer in compression 3 table.
    //
    (pSTbl->pCompress3Tbl)[Index] = pCompNode;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateException
//
//  This routine allocates the exception header and the exception table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the header and the table are stored in the sorttables
//  structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateException(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Set the number of Exception entries in table.
    //
    pSTbl->NumException = TblSize;

    //
    //  Allocate buffer of size TblSize for Exception header.
    //
    if ((pSTbl->pExceptHdr =
            (PEXCEPT_HDR)malloc(TblSize * sizeof(EXCEPT_HDR))) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception Header.\n");
        return (1);
    }
    memset(pSTbl->pExceptHdr, 0, TblSize * sizeof(EXCEPT_HDR));

    //
    //  Allocate buffer of size TblSize for Exception table.
    //
    if ((pSTbl->pExceptTbl =
            (PEXCEPT_TBL)malloc(TblSize * sizeof(PEXCEPT_NODE))) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception table.\n");
        return (1);
    }
    memset(pSTbl->pExceptTbl, 0, TblSize * sizeof(PEXCEPT_NODE));

    //
    //  Return success.
    //
    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  AllocateException
//
//  This routine allocates the Jamo Table and Jamo Composition table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the tables are stored in the sorttables
//  structure.
//
//  06-26-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateJamoTables(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    // Set the number of Jamo Index entries in table
    //
    pSTbl->NumJamoIndex = JAMO_INDEX_SIZE;

    //
    // Allocate buffer for Jamo Index table.
    //
    if ((pSTbl->pJamoIndexTbl =
        (PJAMO_TABLE)malloc(JAMO_INDEX_SIZE * sizeof(JAMO_TABLE))) == NULL)
    {
        printf("Error: Can't allocate buffer for Jamo Index.\n");
        return (1);
    }
    memset(pSTbl->pJamoIndexTbl, 0, JAMO_INDEX_SIZE * sizeof(WORD));
    
    //
    //  Set the number of Jamo Composition entries in table.
    //  Add one for the dummy entry.
    //
    pSTbl->NumJamoComposition = TblSize - JAMO_INDEX_SIZE + 1;

    //
    //  Allocate buffer for Jamo Composition table.
    //
    if ((pSTbl->pJamoComposeTbl =
            (PJAMO_COMPOSE_STATE)malloc(pSTbl->NumJamoComposition * sizeof(JAMO_COMPOSE_STATE))) == NULL)
    {
        printf("Error: Can't allocate buffer for Jamo Composition.\n");
        return (1);
    }
    memset(pSTbl->pJamoComposeTbl, 0, pSTbl->NumJamoComposition * sizeof(JAMO_COMPOSE_STATE));

    //
    //  Return success.
    //
    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  AllocateExceptionNodes
//
//  This routine allocates the exception nodes for the exception table.
//  The size of the table is determined by the TblSize parameter.  The
//  pointer to the nodes is stored in the exception table at the Index
//  given.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateExceptionNodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index)
{
    PEXCEPT_NODE pExcNode;        // ptr to exception node


    //
    //  Allocate buffer of size TblSize for Exception nodes.
    //
    if ((pExcNode = (PEXCEPT_NODE)malloc( TblSize *
                                          sizeof(EXCEPT_NODE) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Exception Nodes.\n");
        return (1);
    }
    memset(pExcNode, 0, TblSize * sizeof(EXCEPT_NODE));

    //
    //  Set pointer in exception table.
    //
    (pSTbl->pExceptTbl)[Index] = pExcNode;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateMultipleWeights
//
//  This routine allocates the multiple weights table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the sorttables structure.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateMultipleWeights(
    PSORT_TABLES pSTbl,
    int TblSize)
{
    //
    //  Allocate buffer of size TblSize for Multiple Weights table.
    //
    if ((pSTbl->pMultiWeight = (PMULTI_WT)malloc( TblSize *
                                                  sizeof(MULTI_WT) )) == NULL)
    {
        printf("Error: Can't allocate buffer for Multiple Weight table.\n");
        return (1);
    }
    memset(pSTbl->pMultiWeight, 0, TblSize * sizeof(MULTI_WT));

    //
    //  Set the number of Multiple Weight entries in table.
    //
    pSTbl->NumMultiWeight = TblSize;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateIdeographExceptions
//
//  This routine allocates the ideograph exception table.  The size of
//  the table is determined by the TblSize parameter.  The pointer to the
//  new table is stored in the ideograph exception structure.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int AllocateIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeograph,
    int TblSize,
    int NumColumns)
{
    //
    //  Allocate buffer of size TblSize for Ideograph Exception table.
    //
    if (NumColumns == 2)
    {
        if ((pIdeograph->pExcept =
                (PIDEOGRAPH_NODE)malloc( TblSize *
                                         sizeof(IDEOGRAPH_NODE) )) == NULL)
        {
            printf("Error: Can't allocate buffer for Ideograph Exception table.\n");
            return (1);
        }
        memset(pIdeograph->pExcept, 0, TblSize * sizeof(IDEOGRAPH_NODE));

        pIdeograph->pExceptEx = NULL;
    }
    else if (NumColumns == 4)
    {
        if ((pIdeograph->pExceptEx =
                (PIDEOGRAPH_NODE_EX)malloc( TblSize *
                                          sizeof(IDEOGRAPH_NODE_EX) )) == NULL)
        {
            printf("Error: Can't allocate buffer for Ideograph Exception table.\n");
            return (1);
        }
        memset(pIdeograph->pExceptEx, 0, TblSize * sizeof(IDEOGRAPH_NODE_EX));

        pIdeograph->pExcept = NULL;
    }
    else
    {
        printf("Parse Error: The Number of Columns must be either 2 or 4.\n");
        return (1);
    }

    //
    //  Set the number of ideograph exception entries in table.
    //
    pIdeograph->NumEntries = TblSize;
    pIdeograph->NumColumns = NumColumns;

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Free844
//
//  This routine frees the memory used by an 8:4:4 table pointed to by pArr.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void Free844(
    P844_ARRAY pArr)
{
    int Ctr1, Ctr2;               // loop counters
    P844_ARRAY pArr2;             // ptr to second arrays


    if (pArr != NULL)
    {
        for (Ctr1 = 0; Ctr1 < TABLE_SIZE_8; Ctr1++)
        {
            if ((pArr2 = (P844_ARRAY)(pArr[Ctr1])) != NULL)
            {
                for (Ctr2 = 0; Ctr2 < TABLE_SIZE_4; Ctr2++)
                {
                    if (pArr2[Ctr2] != NULL)
                    {
                        free(pArr2[Ctr2]);
                    }
                }
                free(pArr2);
            }
        }
        free(pArr);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeCTMap
//
//  This routine frees the memory used by the ctype mapping table pointed
//  to by pMap.
//
////////////////////////////////////////////////////////////////////////////

void FreeCTMap(
    PCT_MAP pMap)
{
    if (pMap != NULL)
    {
        free(pMap->pCTValues);
        free(pMap);
    }
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  MapTrioToByte
//
//  This routine searches through the mapping table for the given CType trio.
//  If it already exists, the entry value is returned.  Otherwise, it adds
//  the new trio to the mapping table and returns the new entry value.
//
////////////////////////////////////////////////////////////////////////////

CT_MAP_VALUE MapTrioToByte(
    PCT_MAP pMap,
    WORD Value1,
    WORD Value2,
    WORD Value3)
{
    PCT_VALUES pEntry;            // ptr to entry
    CT_MAP_VALUE EntryNum;        // entry number
    int Ctr;                      // loop counter


    //
    //  Search through the current entries to see if the ctype trio
    //  already exists.
    //
    for (Ctr = 0; Ctr < pMap->Length; Ctr++)
    {
        //
        //  Check the entry.
        //
        if ( ((pMap->pCTValues[Ctr]).CType1 == Value1) &&
             ((pMap->pCTValues[Ctr]).CType2 == Value2) &&
             ((pMap->pCTValues[Ctr]).CType3 == Value3) )
        {
            //
            //  Entry already exists.  Return the entry number.
            //
            if (Verbose)
                printf("Mapping Entry %d:\tCT1 = %x\tCT2 = %x\tCT3 = %x\n",
                        Ctr, Value1, Value2, Value3);

            return ((BYTE)Ctr);
        }
    }

    //
    //  The given CType trio does not yet exist in the table.
    //  Add the new trio entry to the table and increment the
    //  total number of entries.
    //
    pEntry = &(pMap->pCTValues[pMap->Length]);
    pEntry->CType1 = Value1;
    pEntry->CType2 = Value2;
    pEntry->CType3 = Value3;

    EntryNum = (CT_MAP_VALUE)(pMap->Length);

    pMap->Length++;

    if (Verbose)
        printf("Mapping New Entry %d:\tCT1 = %x\tCT2 = %x\tCT3 = %x\n",
                EntryNum, Value1, Value2, Value3);

    //
    //  Return the new entry number.
    //
    return (EntryNum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\geo.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    geo.c

Abstract:

    This file contains functions necessary to parse amd write the GEO
    specific tables to a data file.

    External Routines in this file:
       ParseWriteGEO

Revision History:

    11-02-99    WeiWu     Created.
    03-10-00    lguindon  Began GEO API port.
    09-12-00    JulieB    Fixed buffer sizes and other problems.

--*/



//
//  Include Files.
//

#include "nlstrans.h"





////////////////////////////////////////////////////////////////////////////
//
//  ParseWriteGEO
//
//  This routine parses the input file for the GEO specific tables, and
//  then writes the data to the output file.
//
////////////////////////////////////////////////////////////////////////////

int
ParseWriteGEO(
    PSZ pszKeyWord)
{
    int nSize = 0;
    int Ctr;
    FILE *pOutputFile;
    GEOTABLEHDR GeoTableHdr;


    if ((pOutputFile = fopen(GEOFILE, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", GEOFILE);
        return (1);
    }

    //
    //  Prepare GEO table header.
    //
    wcscpy(GeoTableHdr.szSig, L"geo");

    //
    //  Write GEO table header place holder.
    //
    if (FileWrite(pOutputFile, &GeoTableHdr, sizeof(GEOTABLEHDR), 1, "GEOHEADER"))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Scan GEO text file.
    //
    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        //
        //  GEOINFO table.
        //
        if (_stricmp(pszKeyWord, "GEOINFO") == 0)
        {
            PGEODATA pGeoData = NULL;

            if (Verbose)
            {
                printf("\n\nFound GEOINFO keyword.\n");
            }

            GetSize(&nSize);

            if (nSize)
            {
                pGeoData = (PGEODATA)malloc(sizeof(GEODATA) * nSize);
            }

            if (pGeoData)
            {
                for (Ctr = 0; Ctr < nSize; Ctr++)
                {
                    CHAR szLatitude[MAX_LATITUDE];
                    CHAR szLongitude[MAX_LONGITUDE];
                    CHAR szISO3166Abbrev2[MAX_ISO_ABBREV];
                    CHAR szISO3166Abbrev3[MAX_ISO_ABBREV];

                    //
                    //  Scan Values
                    //
                    int NumItems = 0;
                    NumItems = fscanf( pInputFile,
                                       "%ld %s %s %lu %ld %s %s %lu ;%*[^\n]",
                                       &pGeoData[Ctr].GeoId,
                                       szLatitude,
                                       szLongitude,
                                       &pGeoData[Ctr].GeoClass,
                                       &pGeoData[Ctr].ParentGeoId,
                                       szISO3166Abbrev2,
                                       szISO3166Abbrev3,
                                       &pGeoData[Ctr].wISO3166 );

                    //
                    //  Convert value to UNICODE
                    //
                    if (MultiByteToWideChar( CP_ACP,
                                             0,
                                             szLatitude,
                                             -1,
                                             pGeoData[Ctr].szLatitude,
                                             MAX_LATITUDE ) == 0)
                    {
                        printf("Error converting latitude string in file %s.\n", GEOFILE);
                        fclose(pOutputFile);
                        free(pGeoData);
                        return (1);
                    }
                    if (MultiByteToWideChar( CP_ACP,
                                             0,
                                             szLongitude,
                                             -1,
                                             pGeoData[Ctr].szLongitude,
                                             MAX_LONGITUDE ) == 0)
                    {
                        printf("Error converting longitude string in file %s.\n", GEOFILE);
                        fclose(pOutputFile);
                        free(pGeoData);
                        return (1);
                    }
                    if (MultiByteToWideChar( CP_ACP,
                                             0,
                                             szISO3166Abbrev2,
                                             -1,
                                             pGeoData[Ctr].szISO3166Abbrev2,
                                             MAX_ISO_ABBREV ) == 0)
                    {
                        printf("Error converting 2-char abbreviated name in file %s.\n", GEOFILE);
                        fclose(pOutputFile);
                        free(pGeoData);
                        return (1);
                    }
                    if (MultiByteToWideChar( CP_ACP,
                                             0,
                                             szISO3166Abbrev3,
                                             -1,
                                             pGeoData[Ctr].szISO3166Abbrev3,
                                             MAX_ISO_ABBREV ) == 0)
                    {
                        printf("Error converting 3-char abbreviated name in file %s.\n", GEOFILE);
                        fclose(pOutputFile);
                        free(pGeoData);
                        return (1);
                    }

                    //
                    //  Print if in verbose mode
                    //
                    if (Verbose)
                    {
                        printf("ID:%ld, LAT:%s, LON:%s, CLASS:%lu, PARENT:%ld, ISO3166-2:%s, IS03166-3:%s, ISO3166:%lu \n",
                               pGeoData[Ctr].GeoId,
                               szLatitude,
                               szLongitude,
                               pGeoData[Ctr].GeoClass,
                               pGeoData[Ctr].ParentGeoId,
                               szISO3166Abbrev2,
                               szISO3166Abbrev3,
                               pGeoData[Ctr].wISO3166 );
                    }
                }

                //
                //  Update GEO table header.
                //
                GeoTableHdr.dwOffsetGeoInfo = ftell(pOutputFile);
                GeoTableHdr.nGeoInfo = nSize;

                //
                //  Write GEOINFO.
                //
                if (FileWrite(pOutputFile, pGeoData, sizeof(GEODATA), nSize, "GEOINFO"))
                {
                    fclose(pOutputFile);
                    free(pGeoData);
                    return (1);
                }

                free(pGeoData);
            }
        }

        //
        //  GEOLCID table.
        //
        else if (_stricmp(pszKeyWord, "GEOLCID") == 0)
        {
            PGEOLCID pGeoLCID = NULL;

            if (Verbose)
                printf("\n\nFound GEOLCID keyword.\n");

            GetSize(&nSize);

            if (nSize)
            {
                pGeoLCID = (PGEOLCID)malloc(sizeof(GEOLCID) * nSize);
            }

            if (pGeoLCID)
            {
                for (Ctr = 0; Ctr < nSize; Ctr++)
                {
                    //
                    //  Scan values
                    //
                    fscanf( pInputFile,
                            "%ld %x %lx ;%*[^\n]",
                            &pGeoLCID[Ctr].GeoId,
                            &pGeoLCID[Ctr].LangId,
                            &pGeoLCID[Ctr].lcid);

                    //
                    //  Print the values if in Verbose Mode
                    //
                    if (Verbose)
                    {
                        printf("ID:%ld, LANGID:0x%04x, LCID:0x%08x\n",
                               pGeoLCID[Ctr].GeoId,
                               pGeoLCID[Ctr].LangId,
                               pGeoLCID[Ctr].lcid);
                    }
                }

                GeoTableHdr.dwOffsetGeoLCID = ftell(pOutputFile);
                GeoTableHdr.nGeoLCID = nSize;

                if (FileWrite(pOutputFile, pGeoLCID, sizeof(GEOLCID), nSize, "GEOLCID"))
                {
                    fclose(pOutputFile);
                    free(pGeoLCID);
                    return (1);
                }

                free(pGeoLCID);
            }
        }
    }

    //
    //  Get file size.
    //
    GeoTableHdr.nFileSize = ftell(pOutputFile);

    //
    //  Rewind Output file.
    //
    fseek(pOutputFile, 0, SEEK_SET);

    //
    //  Update GEO table header.
    //
    if (FileWrite(pOutputFile, &GeoTableHdr, sizeof(GEOTABLEHDR), 1, "GEOHEADER"))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", GEOFILE);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\locale.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    locale.c

Abstract:

    This file contains functions necessary to parse and write the locale
    specific tables to a data file.

    External Routines in this file:
      ParseWriteLocale

Revision History:

    12-10-91    JulieB    Created.
    03-10-00    lguindon  Add explicit typecast to remove build errors
--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Constant Declarations.
//

#define OPT_CAL_FLAG    1
#define ERA_RANGE_FLAG  2




//
//  Forward Declarations.
//

int
ParseLocaleInfo(
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PLOCALE_HEADER pLocCnt,
    PSZ pszKeyWord);

int
ParseLine(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    BOOL fConvert);

int
ParseMultiLine(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize);

int ParseMultiLineSize(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    WORD *pNum,
    int Flag);

int
GetLocaleInfoSize(
    int *pSize);

int
ScanBuffer(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    BYTE *pszKey,
    BOOL fConvert);

int
WriteLocaleInit(
    FILE **ppOutputFile,
    int NumLoc,
    int OffLoc);

int
WriteLocaleInfo(
    DWORD Locale,
    int *pOffHdr,
    int *pOffLoc,
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PLOCALE_HEADER pLocCnt,
    FILE *pOutputFile);

int
WriteVariableLength(
    PLOCALE_HEADER pLocCnt,
    PLOCALE_VARIABLE pLocVar,
    int *pTotalSize,
    FILE *pOutputFile);

int
ParseWriteCalendar(
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PSZ pszKeyWord,
    FILE *pOutputFile,
    int OffHdr);

int
ParseCalendarInfo(
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PCALENDAR_HEADER pCalCnt,
    PSZ pszKeyWord);

int
WriteCalendarInit(
    FILE *pOutputFile,
    int NumCal,
    int OffCalHdr);

int
WriteCalendarInfo(
    DWORD Calendar,
    int *pOffHdr,
    int *pOffCal,
    int OffCalBegin,
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PCALENDAR_HEADER pCalCnt,
    FILE *pOutputFile);

int
WriteCalendarVariableLength(
    PCALENDAR_HEADER pCalCnt,
    PCALENDAR_VARIABLE pCalVar,
    int *pTotalSize,
    FILE *pOutputFile);

int
ConvertUnicodeToWord(
    WORD *pString,
    WORD *pValue);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseWriteLocale
//
//  This routine parses the input file for the locale specific tables, and
//  then writes the data to the output file.  This routine is only entered
//  when the LOCALE keyword is found.  The parsing continues until the
//  ENDLOCALE keyword is found.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseWriteLocale(
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PSZ pszKeyWord)
{
    int Num;                      // number of locales
    int OffHdr;                   // file offset to header info
    int OffLoc;                   // file offset to locale info
    DWORD LocId;                  // locale id
    FILE *pOutputFile;            // ptr to output file
    LOCALE_HEADER LocCnt;         // locale character counts
    CALENDAR_HEADER CalHdr;       // calendar header structure
    CALENDAR_VARIABLE CalVar;     // calendar variable structure


    //
    //  Get size parameter.
    //
    if (GetSize(&Num))
        return (1);

    //
    //  Set up initial file pointer offsets.
    //
    //      OffHdr = header size
    //      OffLoc = header size + (Number of locales * header entry size)
    //
    OffHdr = LOC_CAL_HDR_WORDS;
    OffLoc = LOC_CAL_HDR_WORDS + (Num * LOCALE_HDR_WORDS);

    //
    //  Initialize the output file and write the number of locales to
    //  the file.  Also, in order to allow for the seek, write zeros
    //  in the file up to the first locale field.
    //
    if (WriteLocaleInit( &pOutputFile,
                         Num,
                         OffLoc ))
    {
        return (1);
    }

    //
    //  Parse all of the locales one by one.  Write each one to the file
    //  separately to conserve memory.
    //
    for (; Num > 0; Num--)
    {
        //
        //  Initialize all Locale structures each time.
        //
        memset(pLocHdr, 0, sizeof(LOCALE_HEADER));
        memset(pLocStat, 0, sizeof(LOCALE_STATIC));
        memset(pLocVar, 0, sizeof(LOCALE_VARIABLE));
        memset(&LocCnt, 0, sizeof(LOCALE_HEADER));

        //
        //  Get the BEGINLOCALE keyword and locale id.
        //
        if (fscanf( pInputFile,
                    "%s %lx ;%*[^\n]",
                    pszKeyWord,
                    &LocId ) == 2)
        {
            if (_stricmp(pszKeyWord, "BEGINLOCALE") == 0)
            {
                if (Verbose)
                    printf("\n\nFound BEGINLOCALE keyword, LocaleID = %x\n\n",
                           LocId);
            }
            else
            {
                printf("Parse Error: Error reading BEGINLOCALE and Locale ID.\n");
                fclose(pOutputFile);
                return (1);
            }
        }
        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            printf("             Expecting BEGINLOCALE keyword and Locale ID.\n");
            fclose(pOutputFile);
            return (1);
        }

        //
        //  Parse the locale information.
        //
        if (ParseLocaleInfo( pLocHdr,
                             pLocStat,
                             pLocVar,
                             &LocCnt,
                             pszKeyWord ))
        {
            printf("Parse Error: Language == %ws.\n", pLocStat->szILanguage);
            fclose(pOutputFile);
            return (1);
        }

        //
        //  Write the locale id, offset, and locale information to
        //  the output file.
        //
        if (WriteLocaleInfo( LocId,
                             &OffHdr,
                             &OffLoc,
                             pLocHdr,
                             pLocStat,
                             pLocVar,
                             &LocCnt,
                             pOutputFile ))
        {
            printf("Write Error: Language == %ws.\n", pLocStat->szILanguage);
            fclose(pOutputFile);
            return (1);
        }
    }

    //
    //  Look for ENDLOCALE keyword.
    //
    if (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "ENDLOCALE") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDLOCALE keyword.\n");
        }
        else
        {
            //
            //  The ENDLOCALE keyword was not found.  Return failure.
            //
            printf("Parse Error: Expecting ENDLOCALE keyword.\n");
            fclose(pOutputFile);
            return (1);
        }
    }
    else
    {
        //
        //  The ENDLOCALE keyword was not found.  Return failure.
        //
        printf("Parse Error: Expecting ENDLOCALE keyword.\n");
        fclose(pOutputFile);
        return (1);
    }


    //
    //  Look for CALENDAR keyword.
    //
    if (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "CALENDAR") == 0)
        {
            if (Verbose)
                printf("\n\nFound CALENDAR keyword.\n");
        }
        else
        {
            //
            //  The CALENDAR keyword was not found.  Return failure.
            //
            printf("Parse Error: Expecting CALENDAR keyword.\n");
            fclose(pOutputFile);
            return (1);
        }
    }
    else
    {
        //
        //  The CALENDAR keyword was not found.  Return failure.
        //
        printf("Parse Error: Expecting CALENDAR keyword.\n");
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Get the valid keywords for CALENDAR.
    //  Write the CALENDAR information to an output file.
    //
    if (ParseWriteCalendar( &CalHdr,
                            &CalVar,
                            pszKeyWord,
                            pOutputFile,
                            OffLoc ))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", LOCALE_FILE);
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseLocaleInfo
//
//  This routine parses the locale information from the input file.  If an
//  error is encountered, a 1 is returned.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseLocaleInfo(
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PLOCALE_HEADER pLocCnt,
    PSZ pszKeyWord)
{
    int Count;               // number of characters written
    WORD Tmp;                // tmp place holder


    //
    //  Read in the information associated with the language of a locale
    //  and store it in the locale structure.
    //
    if (!ParseLine( pszKeyWord,
                    pLocStat->szILanguage,
                    5,
                    TRUE ))
    {
        return (1);
    }

    pLocHdr->SLanguage = (sizeof(LOCALE_HEADER) + sizeof(LOCALE_STATIC)) /
                         sizeof(WORD);
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSLanguage,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SLanguage = (WORD)Count;

    pLocHdr->SAbbrevLang = pLocHdr->SLanguage + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevLang,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevLang = (WORD)Count;

    pLocHdr->SAbbrevLangISO = pLocHdr->SAbbrevLang + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevLangISO,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevLangISO = (WORD)Count;

    pLocHdr->SNativeLang = pLocHdr->SAbbrevLangISO + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSNativeLang,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SNativeLang = (WORD)Count;

    //
    //  Read in the information associated with the country of a locale
    //  and store it in the locale structure.
    //
    if (!ParseLine( pszKeyWord,
                    pLocStat->szICountry,
                    6,
                    TRUE ))
    {
        return (1);
    }

    pLocHdr->SCountry = pLocHdr->SNativeLang + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSCountry,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SCountry = (WORD)Count;

    pLocHdr->SAbbrevCtry = pLocHdr->SCountry + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevCtry,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevCtry = (WORD)Count;

    pLocHdr->SAbbrevCtryISO = pLocHdr->SAbbrevCtry + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevCtryISO,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevCtryISO = (WORD)Count;

    pLocHdr->SNativeCtry = pLocHdr->SAbbrevCtryISO + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSNativeCtry,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SNativeCtry = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIGeoId,
                    8,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the default language, country, and code pages of a locale
    //  and store it in the locale structure.
    //
    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultLang,
                    5,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultCtry,
                    6,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultACP,
                    6,
                    TRUE ))
    {
        return (1);
    }
    if (!ConvertUnicodeToWord( pLocStat->szIDefaultACP,
                               &(pLocStat->DefaultACP) ))
    {
        printf("Parse Error: Invalid IDEFAULTACP value  %s\n",
               pLocStat->szIDefaultACP);
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultOCP,
                    6,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultMACCP,
                    6,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDefaultEBCDICCP,
                    6,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the list separator, measurement info, and default paper size
    //  of a locale and store it in the locale structure.
    //
    pLocHdr->SList = pLocHdr->SNativeCtry + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSList,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SList = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIMeasure,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIPaperSize,
                    2,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the digits information of a locale and store it in the
    //  locale structure.
    //
    pLocHdr->SDecimal = pLocHdr->SList + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDecimal,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDecimal = (WORD)Count;

    pLocHdr->SThousand = pLocHdr->SDecimal + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSThousand,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SThousand = (WORD)Count;

    pLocHdr->SGrouping = pLocHdr->SThousand + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSGrouping,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SGrouping = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDigits,
                    3,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szILZero,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szINegNumber,
                    2,
                    TRUE ))
    {
        return (1);
    }

    pLocHdr->SNativeDigits = pLocHdr->SGrouping + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSNativeDigits,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SNativeDigits = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDigitSubstitution,
                    2,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the monetary information of a locale and store it in the
    //  locale structure.
    //
    pLocHdr->SCurrency = pLocHdr->SNativeDigits + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSCurrency,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SCurrency = (WORD)Count;

    pLocHdr->SIntlSymbol = pLocHdr->SCurrency + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSIntlSymbol,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SIntlSymbol = (WORD)Count;

    pLocHdr->SEngCurrName = pLocHdr->SIntlSymbol + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSEngCurrName,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SEngCurrName = (WORD)Count;

    pLocHdr->SNativeCurrName = pLocHdr->SEngCurrName + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSNativeCurrName,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SNativeCurrName = (WORD)Count;

    pLocHdr->SMonDecSep = pLocHdr->SNativeCurrName + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonDecSep,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonDecSep = (WORD)Count;

    pLocHdr->SMonThousSep = pLocHdr->SMonDecSep + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonThousSep,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonThousSep = (WORD)Count;

    pLocHdr->SMonGrouping = pLocHdr->SMonThousSep + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonGrouping,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonGrouping = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szICurrDigits,
                    3,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIIntlCurrDigits,
                    3,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szICurrency,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szINegCurr,
                    3,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the positive and negative sign information of a locale
    //  and store it in the locale structure.
    //
    pLocHdr->SPositiveSign = pLocHdr->SMonGrouping + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSPositiveSign,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SPositiveSign = (WORD)Count;

    pLocHdr->SNegativeSign = pLocHdr->SPositiveSign + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSNegativeSign,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SNegativeSign = (WORD)Count;

    //
    //  Read in the time information of a locale and store it
    //  in the locale structure.
    //
    pLocHdr->STimeFormat = pLocHdr->SNegativeSign + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pLocVar->szSTimeFormat,
                                  MAX )))
    {
        return (1);
    }
    pLocCnt->STimeFormat = (WORD)Count;

    pLocHdr->STime = pLocHdr->STimeFormat + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSTime,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->STime = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szITime,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szITLZero,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szITimeMarkPosn,
                    2,
                    TRUE ))
    {
        return (1);
    }

    pLocHdr->S1159 = pLocHdr->STime + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szS1159,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->S1159 = (WORD)Count;

    pLocHdr->S2359 = pLocHdr->S1159 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szS2359,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->S2359 = (WORD)Count;

    //
    //  Read in the short date information of a locale and store it
    //  in the locale structure.
    //
    pLocHdr->SShortDate = pLocHdr->S2359 + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pLocVar->szSShortDate,
                                  MAX )))
    {
        return (1);
    }
    pLocCnt->SShortDate = (WORD)Count;

    pLocHdr->SDate = pLocHdr->SShortDate + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDate,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDate = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDate,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szICentury,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIDayLZero,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIMonLZero,
                    2,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the long date information of a locale and store it
    //  in the locale structure.
    //
    pLocHdr->SYearMonth = pLocHdr->SDate + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pLocVar->szSYearMonth,
                                  MAX )))
    {
        return (1);
    }
    pLocCnt->SYearMonth = (WORD)Count;

    pLocHdr->SLongDate = pLocHdr->SYearMonth + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pLocVar->szSLongDate,
                                  MAX )))
    {
        return (1);
    }
    pLocCnt->SLongDate = (WORD)Count;

    if (!ParseLine( pszKeyWord,
                    pLocStat->szILDate,
                    2,
                    TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szICalendarType,
                    3,
                    TRUE ))
    {
        return (1);
    }

    pLocHdr->IOptionalCalendar = pLocHdr->SLongDate + Count;
    if (!(Count = ParseMultiLineSize( pszKeyWord,
                                      pLocVar->szIOptionalCalendar,
                                      MAX,
                                      &Tmp,
                                      OPT_CAL_FLAG )))
    {
        return (1);
    }
    pLocCnt->IOptionalCalendar = (WORD)Count;

    if (!ParseLine(pszKeyWord,
                   pLocStat->szIFirstDayOfWeek,
                   2,
                   TRUE ))
    {
        return (1);
    }

    if (!ParseLine( pszKeyWord,
                    pLocStat->szIFirstWeekOfYear,
                    2,
                    TRUE ))
    {
        return (1);
    }

    //
    //  Read in the day information of a locale and store it in the
    //  locale structure.
    //
    pLocHdr->SDayName1 = pLocHdr->IOptionalCalendar + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName1 = (WORD)Count;

    pLocHdr->SDayName2 = pLocHdr->SDayName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName2 = (WORD)Count;

    pLocHdr->SDayName3 = pLocHdr->SDayName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName3 = (WORD)Count;

    pLocHdr->SDayName4 = pLocHdr->SDayName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName4 = (WORD)Count;

    pLocHdr->SDayName5 = pLocHdr->SDayName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName5 = (WORD)Count;

    pLocHdr->SDayName6 = pLocHdr->SDayName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName6 = (WORD)Count;

    pLocHdr->SDayName7 = pLocHdr->SDayName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSDayName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SDayName7 = (WORD)Count;

    pLocHdr->SAbbrevDayName1 = pLocHdr->SDayName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName1 = (WORD)Count;

    pLocHdr->SAbbrevDayName2 = pLocHdr->SAbbrevDayName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName2 = (WORD)Count;

    pLocHdr->SAbbrevDayName3 = pLocHdr->SAbbrevDayName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName3 = (WORD)Count;

    pLocHdr->SAbbrevDayName4 = pLocHdr->SAbbrevDayName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName4 = (WORD)Count;

    pLocHdr->SAbbrevDayName5 = pLocHdr->SAbbrevDayName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName5 = (WORD)Count;

    pLocHdr->SAbbrevDayName6 = pLocHdr->SAbbrevDayName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName6 = (WORD)Count;

    pLocHdr->SAbbrevDayName7 = pLocHdr->SAbbrevDayName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevDayName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevDayName7 = (WORD)Count;

    //
    //  Read in the month information of a locale and store it in the
    //  locale structure.
    //
    pLocHdr->SMonthName1 = pLocHdr->SAbbrevDayName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName1 = (WORD)Count;

    pLocHdr->SMonthName2 = pLocHdr->SMonthName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName2 = (WORD)Count;

    pLocHdr->SMonthName3 = pLocHdr->SMonthName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName3 = (WORD)Count;

    pLocHdr->SMonthName4 = pLocHdr->SMonthName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName4 = (WORD)Count;

    pLocHdr->SMonthName5 = pLocHdr->SMonthName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName5 = (WORD)Count;

    pLocHdr->SMonthName6 = pLocHdr->SMonthName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName6 = (WORD)Count;

    pLocHdr->SMonthName7 = pLocHdr->SMonthName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName7 = (WORD)Count;

    pLocHdr->SMonthName8 = pLocHdr->SMonthName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName8,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName8 = (WORD)Count;

    pLocHdr->SMonthName9 = pLocHdr->SMonthName8 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName9,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName9 = (WORD)Count;

    pLocHdr->SMonthName10 = pLocHdr->SMonthName9 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName10,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName10 = (WORD)Count;

    pLocHdr->SMonthName11 = pLocHdr->SMonthName10 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName11,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName11 = (WORD)Count;

    pLocHdr->SMonthName12 = pLocHdr->SMonthName11 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName12,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName12 = (WORD)Count;

    pLocHdr->SMonthName13 = pLocHdr->SMonthName12 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSMonthName13,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SMonthName13 = (WORD)Count;

    pLocHdr->SAbbrevMonthName1 = pLocHdr->SMonthName13 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName1 = (WORD)Count;

    pLocHdr->SAbbrevMonthName2 = pLocHdr->SAbbrevMonthName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName2 = (WORD)Count;

    pLocHdr->SAbbrevMonthName3 = pLocHdr->SAbbrevMonthName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName3 = (WORD)Count;

    pLocHdr->SAbbrevMonthName4 = pLocHdr->SAbbrevMonthName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName4 = (WORD)Count;

    pLocHdr->SAbbrevMonthName5 = pLocHdr->SAbbrevMonthName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName5 = (WORD)Count;

    pLocHdr->SAbbrevMonthName6 = pLocHdr->SAbbrevMonthName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName6 = (WORD)Count;

    pLocHdr->SAbbrevMonthName7 = pLocHdr->SAbbrevMonthName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName7 = (WORD)Count;

    pLocHdr->SAbbrevMonthName8 = pLocHdr->SAbbrevMonthName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName8,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName8 = (WORD)Count;

    pLocHdr->SAbbrevMonthName9 = pLocHdr->SAbbrevMonthName8 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName9,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName9 = (WORD)Count;

    pLocHdr->SAbbrevMonthName10 = pLocHdr->SAbbrevMonthName9 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName10,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName10 = (WORD)Count;

    pLocHdr->SAbbrevMonthName11 = pLocHdr->SAbbrevMonthName10 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName11,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName11 = (WORD)Count;

    pLocHdr->SAbbrevMonthName12 = pLocHdr->SAbbrevMonthName11 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName12,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName12 = (WORD)Count;

    pLocHdr->SAbbrevMonthName13 = pLocHdr->SAbbrevMonthName12 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pLocVar->szSAbbrevMonthName13,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pLocCnt->SAbbrevMonthName13 = (WORD)Count;

    pLocHdr->SEndOfLocale = pLocHdr->SAbbrevMonthName13 + Count;


    //
    //  Read in the font signature information of a locale and store it in
    //  the locale structure.
    //
    //  NOTE: Don't want the null terminator on this string, so tell
    //        the parse routine that there is one more space in the buffer.
    //        This works because the buffer is filled with 0 initially, so
    //        no null terminator is added onto the end of the string.
    //        Instead, it will simply fill in the buffer with the
    //        MAX_FONTSIGNATURE amount of values.
    //
    if (!ParseLine( pszKeyWord,
                    pLocStat->szFontSignature,
                    MAX_FONTSIGNATURE + 1,         // don't want null term
                    FALSE ))
    {
        return (1);
    }



    //
    //  Get szIPosSymPrecedes and szIPosSepBySpace from the szICurrency
    //  value.
    //
    //  NOTE:  All buffers initialized to 0, so no need to zero terminate.
    //
    switch (*(pLocStat->szICurrency))
    {
        case ( '0' ) :
        {
            *(pLocStat->szIPosSymPrecedes) = L'1';
            *(pLocStat->szIPosSepBySpace) = L'0';
            break;
        }

        case ( '1' ) :
        {
            *(pLocStat->szIPosSymPrecedes) = L'0';
            *(pLocStat->szIPosSepBySpace) = L'0';
            break;
        }

        case ( '2' ) :
        {
            *(pLocStat->szIPosSymPrecedes) = L'1';
            *(pLocStat->szIPosSepBySpace) = L'1';
            break;
        }

        case ( '3' ) :
        {
            *(pLocStat->szIPosSymPrecedes) = L'0';
            *(pLocStat->szIPosSepBySpace) = L'1';
            break;
        }

        default :
        {
            printf("Parse Error: Invalid ICURRENCY value.\n");
            return (1);
        }
    }

    //
    //  Get szIPosSignPosn, szINegSignPosn, szINegSymPrecedes, and
    //  szINegSepBySpace from the szINegCurr value.
    //
    //  NOTE:  All buffers initialized to 0, so no need to zero terminate.
    //
    switch (*(pLocStat->szINegCurr))
    {
        case ( '0' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'3';
            *(pLocStat->szINegSignPosn) = L'0';
            *(pLocStat->szINegSymPrecedes) = L'1';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '1' ) :
        {
            switch (*((pLocStat->szINegCurr) + 1))
            {
                case ( 0 ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'3';
                    *(pLocStat->szINegSignPosn) = L'3';
                    *(pLocStat->szINegSymPrecedes) = L'1';
                    *(pLocStat->szINegSepBySpace) = L'0';
                    break;
                }
                case ( '0' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'4';
                    *(pLocStat->szINegSignPosn) = L'4';
                    *(pLocStat->szINegSymPrecedes) = L'0';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                case ( '1' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'2';
                    *(pLocStat->szINegSignPosn) = L'2';
                    *(pLocStat->szINegSymPrecedes) = L'1';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                case ( '2' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'4';
                    *(pLocStat->szINegSignPosn) = L'4';
                    *(pLocStat->szINegSymPrecedes) = L'1';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                case ( '3' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'3';
                    *(pLocStat->szINegSignPosn) = L'3';
                    *(pLocStat->szINegSymPrecedes) = L'0';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                case ( '4' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'3';
                    *(pLocStat->szINegSignPosn) = L'0';
                    *(pLocStat->szINegSymPrecedes) = L'1';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                case ( '5' ) :
                {
                    *(pLocStat->szIPosSignPosn) = L'1';
                    *(pLocStat->szINegSignPosn) = L'0';
                    *(pLocStat->szINegSymPrecedes) = L'0';
                    *(pLocStat->szINegSepBySpace) = L'1';
                    break;
                }
                default :
                {
                    printf("Parse Error: Invalid INEGCURR value.\n");
                    return (1);
                }
            }

            break;
        }

        case ( '2' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'4';
            *(pLocStat->szINegSignPosn) = L'4';
            *(pLocStat->szINegSymPrecedes) = L'1';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '3' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'2';
            *(pLocStat->szINegSignPosn) = L'2';
            *(pLocStat->szINegSymPrecedes) = L'1';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '4' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'1';
            *(pLocStat->szINegSignPosn) = L'0';
            *(pLocStat->szINegSymPrecedes) = L'0';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '5' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'1';
            *(pLocStat->szINegSignPosn) = L'1';
            *(pLocStat->szINegSymPrecedes) = L'0';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '6' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'3';
            *(pLocStat->szINegSignPosn) = L'3';
            *(pLocStat->szINegSymPrecedes) = L'0';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '7' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'4';
            *(pLocStat->szINegSignPosn) = L'4';
            *(pLocStat->szINegSymPrecedes) = L'0';
            *(pLocStat->szINegSepBySpace) = L'0';
            break;
        }

        case ( '8' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'1';
            *(pLocStat->szINegSignPosn) = L'1';
            *(pLocStat->szINegSymPrecedes) = L'0';
            *(pLocStat->szINegSepBySpace) = L'1';
            break;
        }

        case ( '9' ) :
        {
            *(pLocStat->szIPosSignPosn) = L'3';
            *(pLocStat->szINegSignPosn) = L'3';
            *(pLocStat->szINegSymPrecedes) = L'1';
            *(pLocStat->szINegSepBySpace) = L'1';
            break;
        }

        default :
        {
            printf("Parse Error: Invalid INEGCURR value.\n");
            return (1);
        }
    }


    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseLine
//
//  This routine parses one line of the input file.  This routine is only
//  called to parse a line within the LOCALE keyword section.
//  Returns the number of characters written to the buffer (0 means error).
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseLine(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    BOOL fConvert)
{
    int Num = 0;                  // number of strings read in
    BYTE pszKey[MAX];             // keyword - ignored


    //
    //  Get to next line of information.
    //  If no more strings could be read in, return an error.
    //
    if (fscanf(pInputFile, "%s", pszKey) == 0)
    {
        printf("Parse Error: Incomplete LOCALE information.\n");
        return (0);
    }

    //
    //  Read in the rest of the line.
    //
    if (fgets(pszLine, MAX, pInputFile) == NULL)
    {
        *pInfo = 0;
        return (1);
    }

    //
    //  Return the count of characters put in the buffer.
    //
    return (ScanBuffer( pszLine,
                        pInfo,
                        BufSize,
                        pszKey,
                        fConvert ));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMultiLine
//
//  This routine parses multiple lines of the input file.  This routine is only
//  called to parse a set of lines within the LOCALE keyword section.
//  Returns the number of characters written to the buffer (0 means error).
//  This should only be called to parse multiple lines for ONE locale item.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseMultiLine(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize)
{
    int Num = 0;                  // number of strings read in
    BYTE pszKey[MAX];             // keyword - ignored
    int Count = 0;                // count of characters
    int TmpCt;                    // ScanBuffer return count
    WORD *pInfoPtr;               // tmp ptr to pInfo buffer


    //
    //  Get to next line of information.
    //  If no more strings could be read in, return an error.
    //
    if (fscanf(pInputFile, "%s", pszKey) == 0)
    {
        printf("Parse Error: Incomplete LOCALE information.\n");
        return (0);
    }

    //
    //  Get size parameter.
    //
    if (GetLocaleInfoSize(&Num))
    {
        return (0);
    }

    //
    //  Check for num == 0.
    //
    if (Num == 0)
    {
        *pInfo = 0;
        return (1);
    }

    //
    //  Read in the appropriate number of lines.
    //
    pInfoPtr = pInfo;
    while (Num > 0)
    {
        //
        //  Read in the rest of the line.  If nothing on the current line,
        //  go to the next line and try again.
        //
        if (fgets(pszLine, MAX, pInputFile) != NULL)
        {
            TmpCt = ScanBuffer( pszLine,
                                pInfoPtr,
                                BufSize - Count,
                                pszKey,
                                TRUE );
            Num--;
            pInfoPtr += TmpCt;
            Count += TmpCt;
        }
    }

    //
    //  Return the count of characters put in the buffer.
    //
    return (Count);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMultiLineSize
//
//  This routine parses the IOPTIONALCALENDAR line and the SERARANGES line
//  of the calendar input file.  It stores the value as both a WORD and a
//  string.  It also stores the size of the information read in, including
//  the 2 words for the value and the size.
//
//  Returns the number of characters written to the buffer (0 means error).
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseMultiLineSize(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    WORD *pNum,
    int Flag)
{
    int Num = 0;                  // number of strings read in
    BYTE pszKey[MAX];             // keyword - ignored
    int Count = 0;                // count of characters
    int TmpCt;                    // ScanBuffer return count
    int Value;                    // value for sscanf
    WORD *pInfoPtr;               // tmp ptr to pInfo buffer
    int Incr;                     // increment amount for buffer


    //
    //  Get to next line of information.
    //  If no more strings could be read in, return an error.
    //
    if (fscanf(pInputFile, "%s", pszKey) == 0)
    {
        printf("Parse Error: Incomplete LOCALE information.\n");
        return (0);
    }

    //
    //  Get size parameter.
    //
    if (GetLocaleInfoSize(&Num))
    {
        return (0);
    }

    //
    //  Save the number of ranges.
    //
    *pNum = (WORD)Num;

    //
    //  Check for num == 0.
    //
    if (Num == 0)
    {
        *pInfo = 0;
        return (1);
    }

    //
    //  Set the increment amount based on the Flag parameter.
    //
    Incr = (Flag == ERA_RANGE_FLAG) ? 4 : 2;

    //
    //  Read in the appropriate number of lines.
    //
    pInfoPtr = pInfo;
    while (Num > 0)
    {
        //
        //  If we're getting the era ranges, then we need to read in the
        //  month and day of the era before we read in the year.
        //
        //  Ordering in Buffer:
        //      Month, Day, Year, Offset, Year String, Era Name String
        //
        if (Flag == ERA_RANGE_FLAG)
        {
            //
            //  Get the Month.
            //
            if (GetLocaleInfoSize(&Value))
            {
                return (0);
            }
            pInfoPtr[0] = (WORD)Value;

            //
            //  Get the Day.
            //
            if (GetLocaleInfoSize(&Value))
            {
                return (0);
            }
            pInfoPtr[1] = (WORD)Value;
        }

        //
        //  Read in the rest of the line.  If nothing on the current line,
        //  go to the next line and try again.
        //
        if (fgets(pszLine, MAX, pInputFile) != NULL)
        {
            TmpCt = ScanBuffer( pszLine,
                                pInfoPtr + Incr,
                                BufSize - Count - Incr,
                                pszKey,
                                TRUE );

            TmpCt += Incr;

            swscanf(pInfoPtr + Incr, L"%d", &Value);
            pInfoPtr[Incr - 2] = (WORD)Value;
            pInfoPtr[Incr - 1] = (WORD)TmpCt;

            Num--;
            pInfoPtr += TmpCt;
            Count += TmpCt;
        }
    }

    //
    //  Return the count of characters put in the buffer.
    //
    return (Count);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocaleInfoSize
//
//  This routine gets the size of the table from the input file.  If the
//  size is not there, then an error is returned.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetLocaleInfoSize(
    int *pSize)
{
    int NumItems;                 // number of items returned from fscanf


    //
    //  Read the size from the input file.
    //
    NumItems = fscanf(pInputFile, "%d", pSize);
    if (NumItems != 1)
    {
        printf("Parse Error: Error reading size value.\n");
        return (1);
    }

    if (*pSize < 0)
    {
        printf("Parse Error: Invalid size value  %d\n", *pSize);
        return (1);
    }

    if (Verbose)
        printf("  SIZE = %d\n", *pSize);

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ScanBuffer
//
//  This routine converts the given ansi buffer to a wide character buffer,
//  removes leading and trailing white space, and then scans it for escape
//  characters.  The final buffer and the number of characters written to
//  the buffer (0 means error) are returned.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ScanBuffer(
    PSZ pszLine,
    WORD *pInfo,
    int BufSize,
    BYTE *pszKey,
    BOOL fConvert)
{
    int Num = 0;                  // number of strings read in
    WORD pwszTemp[MAX];           // first string of information
    WORD *pwszInfoPtr;            // ptr to string of information to store
    int Count = 0;                // count of characters


    //
    //  Convert the ansi buffer to a wide char buffer and skip over any
    //  leading white space.
    //
    if (sscanf(pszLine, "%*[\t ]%255w[^\n]", pwszTemp) == 0)
    {
        //
        //  This should only happen if there is only white space on the line.
        //
        *pInfo = 0;
        return (1);
    }

    //
    //  Remove trailing spaces.
    //
    //  NOTE: Subtract 1 from the end of the string to skip over the
    //  null terminator.  The line feed was already filtered out above.
    //
    pwszInfoPtr = pwszTemp + wcslen(pwszTemp) - 1;
    while ((pwszInfoPtr != pwszTemp) &&
           ((*pwszInfoPtr == L' ') || (*pwszInfoPtr == L'\t')))
    {
        pwszInfoPtr--;
    }
    *(pwszInfoPtr + 1) = 0;

    if (Verbose)
        printf("  %s\t%ws\n", pszKey, pwszTemp);

    //
    //  Buffer should be initialized to zero, so no need to
    //  zero terminate the string.
    //
    pwszInfoPtr = pwszTemp;
    while ((*pwszInfoPtr != L'\n') && (*pwszInfoPtr != 0))
    {
        //
        //  Check output buffer size.
        //
        if (Count >= (BufSize - 1))
        {
            printf("WARNING: String is too long - truncating  %s\n",
                   pszKey);
            break;
        }

        //
        //  Check for escape sequence.
        //
        if (*pwszInfoPtr == L'\\')
        {
            pwszInfoPtr++;

            if ((*pwszInfoPtr == L'x') || (*pwszInfoPtr == L'X'))
            {
                //
                //  Read in hex value.
                //
                //  NOTE:  All hex values MUST be 4 digits long -
                //         character may be ignored or hex values may be
                //         incorrect.
                //
                if (swscanf(pwszInfoPtr + 1, L"%4x", &Num) != 1)
                {
                    printf("Parse Error: No number following \\x for %s.\n", pszKey);
                    return (0);
                }

                //
                //  Check for special character - 0xffff.  Change it to a
                //  null terminator.
                //  This means that there is more than one string for one
                //  LCTYPE information.
                //
                if ((fConvert) && (Num == 0xffff))
                {
                    *pInfo = (WORD)0;
                }
                else
                {
                    *pInfo = (WORD)Num;
                }
                pInfo++;
                pwszInfoPtr += 5;
                Count++;
            }
            else if (*pwszInfoPtr == L'\\')
            {
                //
                //  Want to print out backslash, so do it.
                //
                *pInfo = *pwszInfoPtr;
                pInfo++;
                pwszInfoPtr++;
                Count++;
            }
            else
            {
                //
                //  Escape character not followed by valid character.
                //
                printf("Parse Error: Invalid escape sequence for %s.\n",
                       pszKey);
                return (0);
            }
        }
        else
        {
            //
            //  Simply copy character.  No special casing required.
            //
            *pInfo = *pwszInfoPtr;
            pInfo++;
            pwszInfoPtr++;
            Count++;
        }
    }

    //
    //  Return the count of characters put in the buffer.
    //
    return (Count + 1);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLocaleInit
//
//  This routine opens the output file for writing and writes the number
//  of locales as the first piece of data to the file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLocaleInit(
    FILE **ppOutputFile,
    int NumLoc,
    int OffLoc)
{
    WORD pDummy[MAX];             // dummy storage
    DWORD dwValue;                // temp storage value


    //
    //  Make sure output file can be opened for writing.
    //
    if ((*ppOutputFile = fopen(LOCALE_FILE, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", LOCALE_FILE);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", LOCALE_FILE);

    //
    //  Write the number of locales to the file.
    //
    dwValue = (DWORD)NumLoc;
    if (FileWrite( *ppOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Number of Locales" ))
    {
        fclose(*ppOutputFile);
        return (1);
    }

    //
    //  Write zeros in the file to allow the seek to work.
    //
    memset(pDummy, 0, MAX * sizeof(WORD));
    if (FileWrite( *ppOutputFile,
                   pDummy,
                   sizeof(WORD),
                   OffLoc,
                   "Locale File Header" ))
    {
        fclose(*ppOutputFile);
        return (1);
    }

    //
    //  Seek back to the beginning of the locale header.
    //
    if (fseek( *ppOutputFile,
               LOC_CAL_HDR_WORDS * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }


    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLocaleInfo
//
//  This routine writes the locale id, offset, and locale information to
//  the output file.  It needs to seek ahead to the correct position for the
//  locale information, and then seeks back to the header position.  The
//  file positions are updated to reflect the next offsets.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLocaleInfo(
    DWORD Locale,
    int *pOffHdr,
    int *pOffLoc,
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PLOCALE_HEADER pLocCnt,
    FILE *pOutputFile)
{
    int Size;                     // size of locale information
    int TotalSize = 0;            // total size of the locale information
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting Locale Information for %x...\n", Locale);

    //
    //  Write the locale id and offset to the locale information in
    //  the header area of the output file.
    //
    dwValue = (DWORD)(*pOffLoc);
    if (FileWrite( pOutputFile,
                   &Locale,
                   sizeof(DWORD),
                   1,
                   "Locale ID" ) ||
        FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Locale Info Offset" ))
    {
        return (1);
    }

    //
    //  Seek forward to locale info offset.
    //
    if (fseek( pOutputFile,
               (*pOffLoc) * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Write the locale information to the output file.
    //        Header Info
    //        Static Length Info
    //        Variable Length Info
    //
    TotalSize = Size = sizeof(LOCALE_HEADER) / sizeof(WORD);
    if (FileWrite( pOutputFile,
                   pLocHdr,
                   sizeof(WORD),
                   Size,
                   "Locale Header" ))
    {
        return (1);
    }

    TotalSize += (Size = sizeof(LOCALE_STATIC) / sizeof(WORD));
    if (FileWrite( pOutputFile,
                   pLocStat,
                   sizeof(WORD),
                   Size,
                   "Locale Static Info" ))
    {
        return (1);
    }

    if (WriteVariableLength( pLocCnt,
                             pLocVar,
                             &TotalSize,
                             pOutputFile ))
    {
        return (1);
    }

    //
    //  Set the offsets to their new values.
    //
    Size = *pOffLoc;
    (*pOffHdr) += LOCALE_HDR_WORDS;
    (*pOffLoc) += TotalSize;

    //
    //  Make sure the size is not wrapping - can't be greater than
    //  a DWORD.
    //
    if (Size > *pOffLoc)
    {
        printf("Size Error: Offset is greater than a DWORD for locale %x.\n", Locale);
        return (1);
    }

    //
    //  Seek back to the header offset.
    //
    if (fseek( pOutputFile,
               (*pOffHdr) * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteVariableLength
//
//  This routine writes the variable length locale information to the output
//  file.  It adds on to the total size of the locale information as it adds
//  the variable length information.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteVariableLength(
    PLOCALE_HEADER pLocCnt,
    PLOCALE_VARIABLE pLocVar,
    int *pTotalSize,
    FILE *pOutputFile)
{
    int Size;                     // size of string


    *pTotalSize += (Size = pLocCnt->SLanguage);
    if (FileWrite( pOutputFile,
                   pLocVar->szSLanguage,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevLang);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevLang,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevLangISO);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevLangISO,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SNativeLang);
    if (FileWrite( pOutputFile,
                   pLocVar->szSNativeLang,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SCountry);
    if (FileWrite( pOutputFile,
                   pLocVar->szSCountry,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevCtry);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevCtry,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevCtryISO);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevCtryISO,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SNativeCtry);
    if (FileWrite( pOutputFile,
                   pLocVar->szSNativeCtry,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SList);
    if (FileWrite( pOutputFile,
                   pLocVar->szSList,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDecimal);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDecimal,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SThousand);
    if (FileWrite( pOutputFile,
                   pLocVar->szSThousand,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SGrouping);
    if (FileWrite( pOutputFile,
                   pLocVar->szSGrouping,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SNativeDigits);
    if (FileWrite( pOutputFile,
                   pLocVar->szSNativeDigits,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SCurrency);
    if (FileWrite( pOutputFile,
                   pLocVar->szSCurrency,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SIntlSymbol);
    if (FileWrite( pOutputFile,
                   pLocVar->szSIntlSymbol,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SEngCurrName);
    if (FileWrite( pOutputFile,
                   pLocVar->szSEngCurrName,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SNativeCurrName);
    if (FileWrite( pOutputFile,
                   pLocVar->szSNativeCurrName,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonDecSep);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonDecSep,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonThousSep);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonThousSep,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonGrouping);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonGrouping,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SPositiveSign);
    if (FileWrite( pOutputFile,
                   pLocVar->szSPositiveSign,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SNegativeSign);
    if (FileWrite( pOutputFile,
                   pLocVar->szSNegativeSign,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->STimeFormat);
    if (FileWrite( pOutputFile,
                   pLocVar->szSTimeFormat,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->STime);
    if (FileWrite( pOutputFile,
                   pLocVar->szSTime,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->S1159);
    if (FileWrite( pOutputFile,
                   pLocVar->szS1159,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->S2359);
    if (FileWrite( pOutputFile,
                   pLocVar->szS2359,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SShortDate);
    if (FileWrite( pOutputFile,
                   pLocVar->szSShortDate,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDate);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDate,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SYearMonth);
    if (FileWrite( pOutputFile,
                   pLocVar->szSYearMonth,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SLongDate);
    if (FileWrite( pOutputFile,
                   pLocVar->szSLongDate,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->IOptionalCalendar);
    if (FileWrite( pOutputFile,
                   pLocVar->szIOptionalCalendar,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName1);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName1,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName2);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName2,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName3);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName3,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName4);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName4,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName5);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName5,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName6);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName6,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SDayName7);
    if (FileWrite( pOutputFile,
                   pLocVar->szSDayName7,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName1);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName1,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName2);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName2,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName3);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName3,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName4);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName4,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName5);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName5,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName6);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName6,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevDayName7);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevDayName7,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName1);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName1,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName2);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName2,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName3);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName3,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName4);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName4,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName5);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName5,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName6);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName6,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName7);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName7,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName8);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName8,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName9);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName9,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName10);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName10,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName11);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName11,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName12);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName12,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SMonthName13);
    if (FileWrite( pOutputFile,
                   pLocVar->szSMonthName13,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName1);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName1,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName2);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName2,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName3);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName3,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName4);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName4,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName5);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName5,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName6);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName6,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName7);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName7,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName8);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName8,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName9);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName9,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName10);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName10,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName11);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName11,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName12);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName12,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pLocCnt->SAbbrevMonthName13);
    if (FileWrite( pOutputFile,
                   pLocVar->szSAbbrevMonthName13,
                   sizeof(WORD),
                   Size,
                   "Locale Variable Info" ))
    {
        return (1);
    }


    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseWriteCalendar
//
//  This routine parses the input file for the calendar specific tables, and
//  then writes the data to the output file.  This routine is only entered
//  when the CALENDAR keyword is found.  The parsing continues until the
//  ENDCALENDAR keyword is found.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseWriteCalendar(
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PSZ pszKeyWord,
    FILE *pOutputFile,
    int OffHdr)
{
    int Num;                      // number of calendars
    int OffCal;                   // file offset to calendar info
    int OffCalBegin;              // file offset to beginning of calendar info
    DWORD CalId;                  // calendar id
    CALENDAR_HEADER CalCnt;       // calendar character counts


    //
    //  Get size parameter.
    //
    if (GetSize(&Num))
        return (1);

    //
    //  Set up initial file pointer offsets.
    //
    //      OffCal = (Number of calendars * header entry size)
    //
    OffCalBegin = OffHdr;
    OffCal = Num * CALENDAR_HDR_WORDS;

    //
    //  Initialize the output file and write the number of calendars to
    //  the file.  Also, in order to allow for the seek, write zeros
    //  in the file up to the first calendar field.
    //
    if (WriteCalendarInit( pOutputFile,
                           Num,
                           OffHdr ))
    {
        return (1);
    }

    //
    //  Parse all of the calendars one by one.  Write each one to the file
    //  separately to conserve memory.
    //
    for (; Num > 0; Num--)
    {
        //
        //  Initialize all Calendar structures each time.
        //
        memset(pCalHdr, 0, sizeof(CALENDAR_HEADER));
        memset(pCalVar, 0, sizeof(CALENDAR_VARIABLE));
        memset(&CalCnt, 0, sizeof(CALENDAR_HEADER));

        //
        //  Get the BEGINCALENDAR keyword and calendar id.
        //
        if (fscanf( pInputFile,
                    "%s %ld ;%*[^\n]",
                    pszKeyWord,
                    &CalId ) == 2)
        {
            if (_stricmp(pszKeyWord, "BEGINCALENDAR") == 0)
            {
                if (Verbose)
                    printf("\n\nFound BEGINCALENDAR keyword, CalendarID = %d\n\n",
                           CalId);
            }
            else
            {
                printf("Parse Error: Error reading BEGINCALENDAR and Calendar ID.\n");
                return (1);
            }
        }
        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            printf("             Expecting BEGINCALENDAR keyword and Calendar ID.\n");
            return (1);
        }

        //
        //  Parse the calendar information.
        //
        if (ParseCalendarInfo( pCalHdr,
                               pCalVar,
                               &CalCnt,
                               pszKeyWord ))
        {
            printf("Parse Error: Calendar == %d.\n", CalId);
            return (1);
        }

        //
        //  Write the calendar id, offset, and calendar information to
        //  the output file.
        //
        if (WriteCalendarInfo( CalId,
                               &OffHdr,
                               &OffCal,
                               OffCalBegin,
                               pCalHdr,
                               pCalVar,
                               &CalCnt,
                               pOutputFile ))
        {
            printf("Write Error: Calendar == %d.\n", CalId);
            return (1);
        }
    }

    //
    //  Look for ENDCALENDAR keyword.
    //
    if (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "ENDCALENDAR") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDCALENDAR keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }
    }

    //
    //  If this point is reached, then the ENDCALENDAR keyword was not
    //  found.  Return failure.
    //
    printf("Parse Error: Expecting ENDCALENDAR keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseCalendarInfo
//
//  This routine parses the calendar information from the input file.  If an
//  error is encountered, a 1 is returned.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseCalendarInfo(
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PCALENDAR_HEADER pCalCnt,
    PSZ pszKeyWord)
{
    int Count;               // number of characters written
    int Value;               // hex value returned


    //
    //  Read in the calendar id and store it in the calendar structure.
    //
    pCalHdr->SCalendar = sizeof(CALENDAR_HEADER) / sizeof(WORD);
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSCalendar,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SCalendar = (WORD)Count;


    //
    //  Read in the two digit year max and store it in the calendar
    //  structure.
    //
    pCalHdr->STwoDigitYearMax = pCalHdr->SCalendar + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSTwoDigitYearMax,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->STwoDigitYearMax = (WORD)Count;


    //
    //  Read in the range offsets and store them in the calendar structure.
    //
    pCalHdr->SEraRanges = pCalHdr->STwoDigitYearMax + Count;
    if (!(Count = ParseMultiLineSize( pszKeyWord,
                                      pCalVar->szSEraRanges,
                                      MAX,
                                      &(pCalHdr->NumRanges),
                                      ERA_RANGE_FLAG )))
    {
        return (1);
    }
    pCalCnt->SEraRanges = (WORD)Count;
    pCalCnt->NumRanges = pCalHdr->NumRanges;


    //
    //  Read in the short date information and store it in the
    //  calendar structure.
    //
    pCalHdr->SShortDate = pCalHdr->SEraRanges + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pCalVar->szSShortDate,
                                  MAX )))
    {
        return (1);
    }
    pCalCnt->SShortDate = (WORD)Count;


    //
    //  Read in the year month information and store it in the
    //  calendar structure.
    //
    pCalHdr->SYearMonth = pCalHdr->SShortDate + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pCalVar->szSYearMonth,
                                  MAX )))
    {
        return (1);
    }
    pCalCnt->SYearMonth = (WORD)Count;


    //
    //  Read in the long date information and store it in the
    //  calendar structure.
    //
    pCalHdr->SLongDate = pCalHdr->SYearMonth + Count;
    if (!(Count = ParseMultiLine( pszKeyWord,
                                  pCalVar->szSLongDate,
                                  MAX )))
    {
        return (1);
    }
    pCalCnt->SLongDate = (WORD)Count;

    pCalHdr->SDayName1 = pCalHdr->SLongDate + Count;


    //
    //  See if any day or month names exist.
    //
    if (fscanf(pInputFile, "%s", pszKeyWord) != 1)
    {
        printf("Parse Error: Error reading ERA keyword.\n");
        return (1);
    }
    if (GetLocaleInfoSize(&Value))
        return (1);

    pCalHdr->IfNames = (WORD)Value;
    pCalCnt->IfNames = (WORD)Value;
    if (!Value)
    {
        pCalHdr->SCalendar         -=  CAL_NAME_HDR_SIZE;
        pCalHdr->STwoDigitYearMax  -=  CAL_NAME_HDR_SIZE;
        pCalHdr->SEraRanges        -=  CAL_NAME_HDR_SIZE;
        pCalHdr->SShortDate        -=  CAL_NAME_HDR_SIZE;
        pCalHdr->SYearMonth        -=  CAL_NAME_HDR_SIZE;
        pCalHdr->SLongDate         -=  CAL_NAME_HDR_SIZE;
        pCalHdr->SDayName1         -=  CAL_NAME_HDR_SIZE;

        //
        //  Return success.  Don't read any more values for this
        //  calendar.
        //
        return (0);
    }


    //
    //  Read in the day information and store it in the
    //  calendar structure.
    //
    pCalHdr->SDayName1 = pCalHdr->SLongDate + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName1 = (WORD)Count;

    pCalHdr->SDayName2 = pCalHdr->SDayName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName2 = (WORD)Count;

    pCalHdr->SDayName3 = pCalHdr->SDayName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName3 = (WORD)Count;

    pCalHdr->SDayName4 = pCalHdr->SDayName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName4 = (WORD)Count;

    pCalHdr->SDayName5 = pCalHdr->SDayName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName5 = (WORD)Count;

    pCalHdr->SDayName6 = pCalHdr->SDayName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName6 = (WORD)Count;

    pCalHdr->SDayName7 = pCalHdr->SDayName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSDayName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SDayName7 = (WORD)Count;

    pCalHdr->SAbbrevDayName1 = pCalHdr->SDayName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName1 = (WORD)Count;

    pCalHdr->SAbbrevDayName2 = pCalHdr->SAbbrevDayName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName2 = (WORD)Count;

    pCalHdr->SAbbrevDayName3 = pCalHdr->SAbbrevDayName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName3 = (WORD)Count;

    pCalHdr->SAbbrevDayName4 = pCalHdr->SAbbrevDayName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName4 = (WORD)Count;

    pCalHdr->SAbbrevDayName5 = pCalHdr->SAbbrevDayName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName5 = (WORD)Count;

    pCalHdr->SAbbrevDayName6 = pCalHdr->SAbbrevDayName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName6 = (WORD)Count;

    pCalHdr->SAbbrevDayName7 = pCalHdr->SAbbrevDayName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevDayName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevDayName7 = (WORD)Count;


    //
    //  Read in the month information of a locale and store it in the
    //  locale structure.
    //
    pCalHdr->SMonthName1 = pCalHdr->SAbbrevDayName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName1 = (WORD)Count;

    pCalHdr->SMonthName2 = pCalHdr->SMonthName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName2 = (WORD)Count;

    pCalHdr->SMonthName3 = pCalHdr->SMonthName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName3 = (WORD)Count;

    pCalHdr->SMonthName4 = pCalHdr->SMonthName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName4 = (WORD)Count;

    pCalHdr->SMonthName5 = pCalHdr->SMonthName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName5 = (WORD)Count;

    pCalHdr->SMonthName6 = pCalHdr->SMonthName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName6 = (WORD)Count;

    pCalHdr->SMonthName7 = pCalHdr->SMonthName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName7 = (WORD)Count;

    pCalHdr->SMonthName8 = pCalHdr->SMonthName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName8,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName8 = (WORD)Count;

    pCalHdr->SMonthName9 = pCalHdr->SMonthName8 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName9,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName9 = (WORD)Count;

    pCalHdr->SMonthName10 = pCalHdr->SMonthName9 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName10,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName10 = (WORD)Count;

    pCalHdr->SMonthName11 = pCalHdr->SMonthName10 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName11,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName11 = (WORD)Count;

    pCalHdr->SMonthName12 = pCalHdr->SMonthName11 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName12,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName12 = (WORD)Count;

    pCalHdr->SMonthName13 = pCalHdr->SMonthName12 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSMonthName13,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SMonthName13 = (WORD)Count;

    pCalHdr->SAbbrevMonthName1 = pCalHdr->SMonthName13 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName1,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName1 = (WORD)Count;

    pCalHdr->SAbbrevMonthName2 = pCalHdr->SAbbrevMonthName1 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName2,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName2 = (WORD)Count;

    pCalHdr->SAbbrevMonthName3 = pCalHdr->SAbbrevMonthName2 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName3,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName3 = (WORD)Count;

    pCalHdr->SAbbrevMonthName4 = pCalHdr->SAbbrevMonthName3 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName4,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName4 = (WORD)Count;

    pCalHdr->SAbbrevMonthName5 = pCalHdr->SAbbrevMonthName4 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName5,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName5 = (WORD)Count;

    pCalHdr->SAbbrevMonthName6 = pCalHdr->SAbbrevMonthName5 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName6,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName6 = (WORD)Count;

    pCalHdr->SAbbrevMonthName7 = pCalHdr->SAbbrevMonthName6 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName7,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName7 = (WORD)Count;

    pCalHdr->SAbbrevMonthName8 = pCalHdr->SAbbrevMonthName7 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName8,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName8 = (WORD)Count;

    pCalHdr->SAbbrevMonthName9 = pCalHdr->SAbbrevMonthName8 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName9,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName9 = (WORD)Count;

    pCalHdr->SAbbrevMonthName10 = pCalHdr->SAbbrevMonthName9 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName10,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName10 = (WORD)Count;

    pCalHdr->SAbbrevMonthName11 = pCalHdr->SAbbrevMonthName10 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName11,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName11 = (WORD)Count;

    pCalHdr->SAbbrevMonthName12 = pCalHdr->SAbbrevMonthName11 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName12,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName12 = (WORD)Count;

    pCalHdr->SAbbrevMonthName13 = pCalHdr->SAbbrevMonthName12 + Count;
    if (!(Count = ParseLine( pszKeyWord,
                             pCalVar->szSAbbrevMonthName13,
                             MAX,
                             TRUE )))
    {
        return (1);
    }
    pCalCnt->SAbbrevMonthName13 = (WORD)Count;

    pCalHdr->SEndOfCalendar = pCalHdr->SAbbrevMonthName13 + Count;


    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCalendarInit
//
//  This routine writes the number of calendars and the offset to the
//  calendar information in the data file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCalendarInit(
    FILE *pOutputFile,
    int NumCal,
    int OffCalHdr)
{
    WORD pDummy[MAX];             // dummy storage
    DWORD dwValue;                // temp storage value


    //
    //  Write the number of calendars to the file.
    //
    //
    //  Seek to NumCalendar offset.
    //
    if (fseek( pOutputFile,
               LOC_NUM_CAL_WORDS * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Write the number of calendars to the file.
    //
    dwValue = (DWORD)NumCal;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Number of Calendars" ))
    {
        return (1);
    }

    //
    //  Write the offset of calendar info to the file.
    //
    dwValue = (DWORD)OffCalHdr;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Offset of Calendar Info" ))
    {
        return (1);
    }

    //
    //  Seek to calendar header.
    //
    if (fseek( pOutputFile,
               OffCalHdr * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Write zeros in the file to allow the seek to work.
    //
    memset(pDummy, 0, MAX * sizeof(WORD));
    if (FileWrite( pOutputFile,
                   pDummy,
                   sizeof(WORD),
                   NumCal * CALENDAR_HDR_WORDS,
                   "Calendar Header" ))
    {
        return (1);
    }

    //
    //  Seek back to the beginning of the calendar header.
    //
    if (fseek( pOutputFile,
               OffCalHdr * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCalendarInfo
//
//  This routine writes the calendar id, offset, and calendar information to
//  the output file.  It needs to seek ahead to the correct position for the
//  calendar information, and then seeks back to the header position.  The
//  file positions are updated to reflect the next offsets.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCalendarInfo(
    DWORD Calendar,
    int *pOffHdr,
    int *pOffCal,
    int OffCalBegin,
    PCALENDAR_HEADER pCalHdr,
    PCALENDAR_VARIABLE pCalVar,
    PCALENDAR_HEADER pCalCnt,
    FILE *pOutputFile)
{
    int Size;                     // size of locale information
    int TotalSize = 0;            // total size of the locale information
    int NameSize;                 // size of name space to subtract
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Calendar Information for %x...\n", Calendar);

    //
    //  Write the calendar id and offset to the calendar information in
    //  the calendar header area of the output file.
    //
    wValue = (WORD)Calendar;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Calendar ID" ))
    {
        return (1);
    }

    wValue = (WORD)(*pOffCal);
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Calendar Info Offset" ))
    {
        return (1);
    }

    //
    //  Seek forward to calendar info offset.
    //
    if (fseek( pOutputFile,
               (OffCalBegin + (*pOffCal)) * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Write the calendar information to the output file.
    //        Header Info
    //        Variable Length Info
    //
    NameSize = (pCalHdr->IfNames) ? 0 : CAL_NAME_HDR_SIZE;
    TotalSize = Size = (sizeof(CALENDAR_HEADER) / sizeof(WORD)) - NameSize;
    if (FileWrite( pOutputFile,
                   pCalHdr,
                   sizeof(WORD),
                   Size,
                   "Calendar Header" ))
    {
        return (1);
    }

    if (WriteCalendarVariableLength( pCalCnt,
                                     pCalVar,
                                     &TotalSize,
                                     pOutputFile ))
    {
        return (1);
    }

    //
    //  Set the offsets to their new values.
    //
    (*pOffHdr) += CALENDAR_HDR_WORDS;
    (*pOffCal) += TotalSize;

    //
    //  Make sure the size is not wrapping - can't be greater than
    //  a DWORD.
    //
    if (*pOffCal > 0xffff)
    {
        printf("Size Error: Offset is greater than a WORD for calendar %d.\n", Calendar);
        return (1);
    }


    //
    //  Seek back to the calendar header offset.
    //
    if (fseek( pOutputFile,
               (*pOffHdr) * sizeof(WORD),
               0 ))
    {
        printf("Seek Error: Can't seek in file %s.\n", LOCALE_FILE);
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCalendarVariableLength
//
//  This routine writes the variable length calendar information to the output
//  file.  It adds on to the total size of the calendar information as it adds
//  the variable length information.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCalendarVariableLength(
    PCALENDAR_HEADER pCalCnt,
    PCALENDAR_VARIABLE pCalVar,
    int *pTotalSize,
    FILE *pOutputFile)
{
    int Size;                     // size of string


    *pTotalSize += (Size = pCalCnt->SCalendar);
    if (FileWrite( pOutputFile,
                   pCalVar->szSCalendar,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->STwoDigitYearMax);
    if (FileWrite( pOutputFile,
                   pCalVar->szSTwoDigitYearMax,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SEraRanges);
    if (FileWrite( pOutputFile,
                   pCalVar->szSEraRanges,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SShortDate);
    if (FileWrite( pOutputFile,
                   pCalVar->szSShortDate,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SYearMonth);
    if (FileWrite( pOutputFile,
                   pCalVar->szSYearMonth,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SLongDate);
    if (FileWrite( pOutputFile,
                   pCalVar->szSLongDate,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }


    //
    //  See if any of the day or month names exist.
    //
    if (pCalCnt->IfNames == 0)
    {
        //
        //  Return success.  Don't write any of the day or month names.
        //
        return (0);
    }


    *pTotalSize += (Size = pCalCnt->SDayName1);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName1,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName2);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName2,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName3);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName3,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName4);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName4,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName5);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName5,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName6);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName6,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SDayName7);
    if (FileWrite( pOutputFile,
                   pCalVar->szSDayName7,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName1);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName1,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName2);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName2,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName3);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName3,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName4);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName4,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName5);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName5,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName6);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName6,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevDayName7);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevDayName7,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName1);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName1,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName2);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName2,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName3);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName3,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName4);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName4,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName5);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName5,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName6);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName6,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName7);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName7,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName8);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName8,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName9);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName9,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName10);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName10,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName11);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName11,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName12);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName12,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SMonthName13);
    if (FileWrite( pOutputFile,
                   pCalVar->szSMonthName13,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName1);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName1,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName2);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName2,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName3);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName3,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName4);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName4,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName5);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName5,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName6);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName6,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName7);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName7,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName8);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName8,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName9);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName9,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName10);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName10,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName11);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName11,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName12);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName12,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }

    *pTotalSize += (Size = pCalCnt->SAbbrevMonthName13);
    if (FileWrite( pOutputFile,
                   pCalVar->szSAbbrevMonthName13,
                   sizeof(WORD),
                   Size,
                   "Calendar Variable Info" ))
    {
        return (1);
    }


    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertUnicodeToWord
//
//  This routine converts a Unicode string to a WORD value.
//
//  08-21-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

#define ISDIGIT(c)      ((c) >= L'0' && (c) <= L'9')

int ConvertUnicodeToWord(
    WORD *pString,
    WORD *pValue)
{
    UINT Val = 0;

    while (*pString)
    {
        if (ISDIGIT(*pString))
        {
            Val *= 10;
            Val += *pString - L'0';
            pString++;
        }
        else
        {
            //
            //  Error.
            //
            return (0);
        }
    }

    if (Val > 0xffff)
    {
        //
        //  Code page cannot be greater than a WORD value.
        //
        return (0);
    }

    *pValue = (WORD)Val;

    return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\codepage.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    codepage.c

Abstract:

    This file contains functions necessary to parse and write the code page
    specific tables to a data file.

    External Routines in this file:
      ParseCodePage
      WriteCodePage

Revision History:

    12-10-91    JulieB    Created.
    03-10-00    lguindon  Add explicit typecast to remove build errors

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

int
GetMBTable(
    PCODEPAGE pCP,
    int Size);

int
GetGlyphTable(
    PCODEPAGE pCP,
    int Size);

int
GetDBCSRanges(
    PCODEPAGE pCP,
    int Size);

int
GetAllDBCSTables(
    int NumTables,
    PDBCS_TBL_ARRAY pArray);

int
GetDBCSTable(
    int Size,
    PDBCS_TBL pTable);

int
GetWCTable(
    PCODEPAGE pCP,
    int Size,
    BOOL IsMBCodePage);

int
WriteCPInfo(
    PCODEPAGE pCP,
    FILE *pOutputFile);

int
WriteMB(
    PCODEPAGE pCP,
    FILE *pOutputFile);

int
WriteWC(
    PCODEPAGE pCP,
    BOOL IsMBCodePage,
    FILE *pOutputFile);

void
FreeMB(
    PCODEPAGE pCP);

int
GetTransDefaultChars(
    PCODEPAGE pCP);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseCodePage
//
//  This routine parses the input file for the code page specific tables.
//  This routine is only entered when the CODEPAGE keyword is found.
//  The parsing continues until the ENDCODEPAGE keyword is found.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseCodePage(
    PCODEPAGE pCP,
    PSZ pszKeyWord)
{
    int size;                     // size of table to follow
    int DefChar;                  // default character
    int UniDefChar;               // unicode default char
    int NumItems;                 // number of items returned from fscanf


    //
    //  Get CodePageValue parameter.
    //
    pCP->CodePageValue = atoi(pCP->pszName);

    //
    //  Read in the rest of the code page information.
    //
    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "CPINFO") == 0)
        {
            if (Verbose)
                printf("\n\nFound CPINFO keyword.\n");

            //
            //  Get MaxCharSize parameter.
            //  Get DefaultChar parameter.
            //  Get Unicode Translation of default char parameter.
            //
            NumItems = fscanf( pInputFile,
                               "%d %x %x ;%*[^\n]",
                               &size,
                               &DefChar,
                               &UniDefChar );
            if ((NumItems != 3) || ((size != 1) && (size != 2)))
            {
                return (1);
            }

            pCP->MaxCharSize = size;
            pCP->DefaultChar = (WORD)DefChar;
            pCP->UniDefaultChar = (WORD)UniDefChar;

            if (Verbose)
            {
                printf("  MAXCHARSIZE = %d\n", size);
                printf("  DEFAULTCHAR = %x\n\n", DefChar);
                printf("  UNICODE DEFAULT CHAR = %x\n\n", UniDefChar);
            }

            //
            //  Set WriteFlags for CPINFO Table.
            //
            pCP->WriteFlags |= F_CPINFO;
        }

        else if (_stricmp(pszKeyWord, "MBTABLE") == 0)
        {
            if (Verbose)
                printf("\n\nFound MBTABLE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get MB table.
            //
            if (GetMBTable(pCP, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for MB Table.
            //
            pCP->WriteFlags |= F_MB;
        }

        else if (_stricmp(pszKeyWord, "GLYPHTABLE") == 0)
        {
            if (Verbose)
                printf("\n\nFound GLYPHTABLE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get GLYPH table.
            //
            if (GetGlyphTable(pCP, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for GLYPH Table.
            //
            pCP->WriteFlags |= F_GLYPH;
        }

        else if (_stricmp(pszKeyWord, "DBCSRANGE") == 0)
        {
            if (Verbose)
                printf("\n\nFound DBCSRANGE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get DBCS ranges and tables.
            //
            if (GetDBCSRanges(pCP, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for DBCS Table.
            //
            pCP->WriteFlags |= F_DBCS;
        }

        else if (_stricmp(pszKeyWord, "WCTABLE") == 0)
        {
            if (Verbose)
                printf("\n\nFound WCTABLE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get WC Table.
            //
            if (GetWCTable( pCP,
                            size,
                            (pCP->MaxCharSize - 1) ))
            {
                return (1);
            }

            //
            //  Set WriteFlags for WC Table.
            //
            pCP->WriteFlags |= F_WC;
        }

        else if (_stricmp(pszKeyWord, "ENDCODEPAGE") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDCODEPAGE keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }

        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  If this point is reached, then the ENDCODEPAGE keyword was
    //  not found.  Return an error.
    //
    printf("Parse Error: Expecting ENDCODEPAGE keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCodePage
//
//  This routine writes the code page specific tables to an output file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCodePage(
    PCODEPAGE pCP)
{
    char pszFile[FILE_NAME_LEN];       // file name storage
    FILE *pOutputFile;                 // ptr to output file


    //
    //  Make sure all tables are present.
    //
    if (!((pCP->WriteFlags & F_CPINFO) &&
          (pCP->WriteFlags & F_MB) &&
          (pCP->WriteFlags & F_WC)))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             CPInfo, MultiByte, and WideChar Translation Tables.\n");
        return (1);
    }

    //
    //  Get the name of the output file.
    //
    memset(pszFile, 0, FILE_NAME_LEN * sizeof(char));
    strcpy(pszFile, CP_PREFIX);
    strcat(pszFile, pCP->pszName);
    strcat(pszFile, DATA_FILE_SUFFIX);

    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(pszFile, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", pszFile);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", pszFile);

    //
    //  Write the CPINFO.
    //
    if (WriteCPInfo(pCP, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }


    //
    //  Write MB Table, Glyph Table (if any) and DBCS Table (if any) to
    //  output file.
    //
    if (WriteMB(pCP, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free MB table structures.
    //
    FreeMB(pCP);


    //
    //  Write WC Table to output file.
    //
    if (WriteWC( pCP,
                 (pCP->WriteFlags & F_DBCS),
                 pOutputFile ))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free WC table structures.
    //
    free(pCP->pWC);


    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", pszFile);
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetMBTable
//
//  This routine gets the multibyte table from the input file.  It uses the
//  size parameter to know when to stop reading from the file.  If an error
//  is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetMBTable(
    PCODEPAGE pCP,
    int Size)
{
    int Ctr;                      // loop counter
    int Index;                    // index into array - single byte char
    int Value;                    // value - WC translation
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate MB table.
    //
    if (AllocateMB(pCP))
    {
        return (1);
    }

    //
    //  For each table entry, read the MB char and the wide char
    //  from the input file and store the wide char in the array.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Get the index and the value to store from the file.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Index,
                           &Value );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading MBTABLE values.\n");
            return (1);
        }

        if (Index > MB_TABLE_SIZE)
        {
            printf("Parse Error: Multibyte char value too large.\n");
            printf("             Value must be less than 0x%x.\n", MB_TABLE_SIZE);
            return (1);
        }

        //
        //  Store the wide character value in the array.
        //
        (pCP->pMB)[Index] = (WORD)Value;

        if (Verbose)
            printf("  MB = %x\tWC = %x\n", Index, Value);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetGlyphTable
//
//  This routine gets the glyph table from the input file.  It uses the
//  size parameter to know when to stop reading from the file.  If an error
//  is encountered, a message is printed and an error is returned.
//
//  06-02-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetGlyphTable(
    PCODEPAGE pCP,
    int Size)
{
    int Ctr;                      // loop counter
    int Index;                    // index into array - single byte char
    int Value;                    // value - WC translation
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate Glyph table.
    //
    if (AllocateGlyph(pCP))
    {
        return (1);
    }

    //
    //  For each table entry, read the MB char and the wide char
    //  from the input file and store the wide char in the array.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Get the index and the value to store from the file.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Index,
                           &Value );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading GLYPHTABLE values.\n");
            return (1);
        }

        if (Index > GLYPH_TABLE_SIZE)
        {
            printf("Parse Error: Multibyte char value too large.\n");
            printf("             Value must be less than 0x%x.\n", GLYPH_TABLE_SIZE);
            return (1);
        }

        //
        //  Store the wide character value in the array.
        //
        (pCP->pGlyph)[Index] = (WORD)Value;

        if (Verbose)
            printf("  MB = %x\tWC = %x\n", Index, Value);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDBCSRanges
//
//  This routine gets the DBCS ranges from the input file.  It uses the
//  size parameter to know when to stop reading from the file.  If an error
//  is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetDBCSRanges(
    PCODEPAGE pCP,
    int Size)
{
    int Ctr;                           // loop counter
    int Ctr2;                          // loop counter
    int Low;                           // low end range value
    int High;                          // high end range value
    int Offset = DBCS_OFFSET_SIZE;     // offset to DBCS table
    int NumItems;                      // # of items returned from fscanf


    //
    //  Save the number of ranges for later.
    //
    if ((Size < 1) || (Size > 5))
    {
        printf("Parse Error: Number of DBCS Ranges must be between 1 and 5.\n");
        return (1);
    }
    pCP->NumDBCSRanges = Size;


    //
    //  Allocate initial DBCS array structure.
    //
    if (AllocateTopDBCS(pCP, Size))
    {
        return (1);
    }

    //
    //  For each range, read the low range, the high range, and the
    //  DBCS tables for these ranges.  DBCS tables MUST be in the
    //  correct order (low range to high range).
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read low and high range.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Low,
                           &High );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading DBCS Range values.\n");
            return (1);
        }
        if (High < Low)
        {
            printf("Parse Error: High Range must be greater than Low Range.\n");
            return (1);
        }

        //
        //  Allocate DBCS structures.
        //
        if (AllocateDBCS(pCP, Low, High, Ctr))
        {
            return (1);
        }

        //
        //  Set the range in the structure.
        //
        (pCP->pDBCS)[Ctr]->LowRange = (WORD)Low;
        (pCP->pDBCS)[Ctr]->HighRange = (WORD)High;

        if (Verbose)
            printf("  LOW = %x\tHIGH = %x\n", Low, High);

        //
        //  Get Tables for this range.
        //
        if (GetAllDBCSTables( High - Low + 1,
                              (pCP->pDBCS)[Ctr]->pDBCSTbls ))
        {
            return (1);
        }

        //
        //  Set the offsets for the range.
        //  Offsets are in WORDS.
        //
        for (Ctr2 = Low; Ctr2 <= High; Ctr2++)
        {
            pCP->pDBCSOff[Ctr2] = (WORD)Offset;
            Offset += DBCS_TABLE_SIZE;

            //
            //  This shouldn't happen, but check it just in case.
            //       ( 254 tables max - (65536/256) - 2 )
            //
            if (Offset > 65536)
            {
                printf("FATAL Error: Too many DBCS tables - 254 max allowed.\n");
                return (1);
            }
        }

        //
        //  Save the LeadByte values in pCP structure again for easy
        //  writing to file.
        //
        (pCP->LeadBytes)[Ctr * 2]       = (BYTE)Low;
        (pCP->LeadBytes)[(Ctr * 2) + 1] = (BYTE)High;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAllDBCSTables
//
//  This routine gets the DBCS tables (for one range) from the input file
//  and places them in the appropriate structures.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetAllDBCSTables(
    int NumTables,
    PDBCS_TBL_ARRAY pArray)
{
    int Ctr;                      // loop counter
    char pszKeyWord[MAX];         // input token
    int size;                     // size of table to follow


    //
    //  Read each table.
    //
    for (Ctr = 0; Ctr < NumTables; Ctr++)
    {
        //
        //  Get DBCSTABLE keyword.
        //
        if ((fscanf(pInputFile, "%s", pszKeyWord) != 1) ||
            (_stricmp(pszKeyWord, "DBCSTABLE") != 0))
        {
            printf("Parse Error: Error reading DBCSTABLE keyword.\n");
            return (1);
        }

        if (Verbose)
            printf("\n  Found DBCSTABLE keyword.\n");

        //
        //  Get size parameter.
        //
        if (GetSize(&size))
            return (1);

        //
        //  Get DBCS Table.
        //
        if (GetDBCSTable(size, pArray[Ctr]))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDBCSTable
//
//  This routine gets the DBCS table from the input file.  It uses the
//  size parameter to know when to stop reading from the file.  If an error
//  is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetDBCSTable(
    int Size,
    PDBCS_TBL pTable)
{
    int Ctr;                      // loop counter
    int Index;                    // index into array - single byte char
    int Value;                    // value - WC translation
    int NumItems;                 // number of items returned from fscanf


    //
    //  For each table entry, read the MB char and the wide char
    //  from the input file and store the wide char in the array.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Get the index and the value to store from the file.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Index,
                           &Value );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading DBCSTABLE values.\n");
            return (1);
        }

        if (Index > DBCS_TABLE_SIZE)
        {
            printf("Parse Error: DBCS character value too large.\n");
            printf("             Value must be less than 0x%x.\n", DBCS_TABLE_SIZE);
            return (1);
        }

        //
        //  Store the wide character value in the array.
        //
        pTable[Index] = (WORD)Value;

        if (Verbose)
            printf("  MB = %x\tWC = %x\n", Index, Value);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWCTable
//
//  This routine gets the wide character table from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetWCTable(
    PCODEPAGE pCP,
    int Size,
    BOOL IsMBCodePage)
{
    int WChar;                    // wide character value
    int MBChar;                   // multibyte character value
    register int Ctr;             // loop counter
    BYTE *pBytePtr;               // ptr to byte table
    WORD *pWordPtr;               // ptr to word table
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate buffer for 1-to-1 mapping table.
    //
    if (IsMBCodePage)
    {
        if (AllocateWCTable(pCP, sizeof(WORD)))
        {
            return (1);
        }
        pWordPtr = (WORD *)(pCP->pWC);
    }
    else
    {
        if (AllocateWCTable(pCP, sizeof(BYTE)))
        {
            return (1);
        }
        pBytePtr = (BYTE *)(pCP->pWC);
    }

    //
    //  For each entry in table, read in wide character and multibyte
    //  character from input file.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in wide character and multibyte character.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &WChar,
                           &MBChar );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading WCTABLE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  WC = %x\tMB = %x\n", WChar, MBChar);

        //
        //  Insert MBChar into the appropriate translation table buffer.
        //
        if (IsMBCodePage)
        {
            pWordPtr[WChar] = (WORD)MBChar;
        }
        else
        {
            pBytePtr[WChar] = (BYTE)MBChar;
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCPInfo
//
//  This routine writes the CP information to the output file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCPInfo(
    PCODEPAGE pCP,
    FILE *pOutputFile)
{
    int Size = CP_INFO_SIZE;      // size of CPINFO information
    WORD wValue;                  // temp storage value


    //
    //  Get the translation of the MB default char and the
    //  Unicode default char.
    //
    if (GetTransDefaultChars(pCP))
    {
        return (1);
    }

    if (Verbose)
        printf("\nWriting CP Info...\n");

    //
    //  Write size of CPInfo to file.
    //
    wValue = (WORD)Size;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "CPINFO Table Size" ))
    {
        return (1);
    }

    //
    //  Write CodePageValue to file.
    //
    wValue = (WORD)(pCP->CodePageValue);
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "CPINFO Code Page Value" ))
    {
        return (1);
    }

    //
    //  Write MaxCharSize to file.
    //
    wValue = (WORD)(pCP->MaxCharSize);
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "CPINFO Max Char Size" ))
    {
        return (1);
    }

    //
    //  Write Default Char to file.
    //
    if (FileWrite( pOutputFile,
                   &(pCP->DefaultChar),
                   sizeof(WORD),
                   1,
                   "CPINFO Default Char" ))
    {
        return (1);
    }

    //
    //  Write Unicode Default Char to file.
    //
    if (FileWrite( pOutputFile,
                   &(pCP->UniDefaultChar),
                   sizeof(WORD),
                   1,
                   "CPINFO Unicode Default Char" ))
    {
        return (1);
    }

    //
    //  Write Translation of Default Char to file.
    //
    if (FileWrite( pOutputFile,
                   &(pCP->TransDefChar),
                   sizeof(WORD),
                   1,
                   "CPINFO Translation of Default Char" ))
    {
        return (1);
    }

    //
    //  Write Translation of Unicode Default Char to file.
    //
    if (FileWrite( pOutputFile,
                   &(pCP->TransUniDefChar),
                   sizeof(WORD),
                   1,
                   "CPINFO Translation of Unicode Default Char" ))
    {
        return (1);
    }

    //
    //  Write DBCS LeadByte Ranges to file.
    //
    if (FileWrite( pOutputFile,
                   &(pCP->LeadBytes),
                   sizeof(BYTE),
                   MAX_NUM_LEADBYTE,
                   "CPINFO LeadBytes" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteMB
//
//  This routine writes the MB table, GLYPH table (if it exists), and
//  DBCS table (if it exists) to the output file.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteMB(
    PCODEPAGE pCP,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    int Ctr;                      // loop counter
    int Ctr2;                     // loop counter
    PDBCS_ARRAY pDBCSArray;       // ptr to DBCS array
    PDBCS_RANGE pRange;           // ptr to range structure
    register int NumRanges;       // number of DBCS ranges
    register int NumTables;       // number of tables for range
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting MB Table...\n");

    //
    //  Compute size of table and write it to the output file.
    //
    TblSize = ComputeMBSize(pCP);

    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "MB size" ))
    {
        return (1);
    }

    //
    //  Write MB Table to output file.
    //
    if (FileWrite( pOutputFile,
                   pCP->pMB,
                   sizeof(WORD),
                   MB_TABLE_SIZE,
                   "MB table" ))
    {
        return (1);
    }

    //
    //  Write Glyph Table to output file (if it exists).
    //
    if (pCP->WriteFlags & F_GLYPH)
    {
        wValue = GLYPH_TABLE_SIZE;
        if (FileWrite( pOutputFile,
                       &wValue,
                       sizeof(WORD),
                       1,
                       "GLYPH table size" ))
        {
            return (1);
        }

        if (FileWrite( pOutputFile,
                       pCP->pGlyph,
                       sizeof(WORD),
                       GLYPH_TABLE_SIZE,
                       "GLYPH table" ))
        {
            return (1);
        }
    }
    else
    {
        wValue = 0;
        if (FileWrite( pOutputFile,
                       &wValue,
                       sizeof(WORD),
                       1,
                       "GLYPH table size" ))
        {
            return (1);
        }
    }

    //
    //  Write number of DBCS ranges to output file.
    //
    wValue = (WORD)(pCP->NumDBCSRanges);
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "DBCS Ranges" ))
    {
        return (1);
    }

    //
    //  Write the DBCS tables to the file (if any exist).
    //
    NumRanges = pCP->NumDBCSRanges;
    if ((NumRanges > 0) && (pCP->WriteFlags & F_DBCS))
    {
        if (Verbose)
            printf("\n  Writing DBCS Table...\n");

        //
        //  Write the offsets.
        //
        if (FileWrite( pOutputFile,
                       pCP->pDBCSOff,
                       sizeof(WORD),
                       DBCS_OFFSET_SIZE,
                       "DBCS Offsets" ))
        {
            return (1);
        }

        //
        //  Write the tables.
        //
        pDBCSArray = pCP->pDBCS;
        for (Ctr = 0; Ctr < NumRanges; Ctr++)
        {
            pRange = pDBCSArray[Ctr];

            if (Verbose)
                printf("    Writing DBCS range %x to %x\n",
                            pRange->LowRange, pRange->HighRange);

            NumTables = pRange->HighRange - pRange->LowRange + 1;
            for (Ctr2 = 0; Ctr2 < NumTables; Ctr2++)
            {
                if (FileWrite( pOutputFile,
                               pRange->pDBCSTbls[Ctr2],
                               sizeof(WORD),
                               DBCS_TABLE_SIZE,
                               "DBCS Table" ))
                {
                    return (1);
                }

                if (Verbose)
                    printf("      Writing DBCS table %d\n", Ctr2 + 1);
            }
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteWC
//
//  This routine writes the WC information to the output file.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteWC(
    PCODEPAGE pCP,
    BOOL IsMBCodePage,
    FILE *pOutputFile)
{
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting WC Table...\n");

    //
    //  Write 0 for SB or 1 for DB code page to the output file.
    //
    wValue = (WORD)IsMBCodePage;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "SB or DB flag" ))
    {
        return (1);
    }

    //
    //  Write WC translation table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pCP->pWC,
                   (IsMBCodePage) ? sizeof(WORD) : sizeof(BYTE),
                   WC_TABLE_SIZE,
                   "WC Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeMB
//
//  This routine frees the memory used to build the MB table and the DBCS
//  table.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void FreeMB(
    PCODEPAGE pCP)
{
    int Ctr;                      // loop counter
    int Ctr2;                     // loop counter
    PDBCS_ARRAY pDBCSArray;       // ptr to DBCS array
    PDBCS_RANGE pRange;           // ptr to DBCS Range structure
    PDBCS_TBL_ARRAY pTbls;        // ptr to DBCS table array
    register int NumRanges;       // number of DBCS ranges
    register int NumTables;       // number of tables in range


    //
    //  Free Multibyte Table structures.
    //
    if (pCP->pMB != NULL)
    {
        free(pCP->pMB);
    }

    //
    //  Free Glyph Table structures.
    //
    if (pCP->pGlyph != NULL)
    {
        free(pCP->pGlyph);
    }

    //
    //  Free DBCS Table structures.
    //
    if ((pDBCSArray = pCP->pDBCS) != NULL)
    {
        NumRanges = pCP->NumDBCSRanges;
        for (Ctr = 0; Ctr < NumRanges; Ctr++)
        {
            if ((pRange = pDBCSArray[Ctr]) != NULL)
            {
                if ((pTbls = pRange->pDBCSTbls) != NULL)
                {
                    NumTables = pRange->HighRange - pRange->LowRange + 1;
                    for (Ctr2 = 0; Ctr2 < NumTables; Ctr2++)
                    {
                        if (pTbls[Ctr2] != NULL)
                        {
                            free(pTbls[Ctr2]);
                        }
                    }
                    free(pTbls);
                }
                free(pRange);
            }
        }
        free(pDBCSArray);
    }

    if (pCP->pDBCSOff != NULL)
    {
        free(pCP->pDBCSOff);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTransDefaultChars
//
//  Gets the MB translation for the Unicode default char and
//  the Unicode translation for the MB default char.
//
//  This allows the multi byte default char and the Unicode default char
//  to be different in the data file.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetTransDefaultChars(
    PCODEPAGE pCP)
{
    WORD wDefChar;           // default char to translate
    WORD Lead;               // lead byte of DBCS char
    WORD Low;                // low part of DBCS range
    WORD High;               // high part of DBCS range
    int ctr;                 // loop counter
    PDBCS_TBL pDBCSTable;    // ptr to appropriate DBCS table


    //
    //  Get the MB translation for the Unicode Default Char.
    //
    wDefChar = pCP->UniDefaultChar;
    if (pCP->MaxCharSize == 1)
    {
        //
        //  Single byte code page.
        //
        pCP->TransUniDefChar = ((WORD)(((BYTE *)(pCP->pWC))[wDefChar]));
    }
    else
    {
        //
        //  Double byte code page.
        //
        pCP->TransUniDefChar =  ((WORD)(((WORD *)(pCP->pWC))[wDefChar]));
    }

    //
    //  Get the Unicode translation for the MB Default Char.
    //
    wDefChar = pCP->DefaultChar;
    if (Lead = (WORD)HIBYTE(wDefChar))
    {
        //
        //  Make sure the DBCS tables exist.
        //
        if (!(pCP->pDBCS))
        {
            printf("Parse Error: Invalid default char '%x'.\n", wDefChar);
            return (1);
        }

        //
        //  Search for the correct range.
        //
        for (ctr = 0; ctr < pCP->NumDBCSRanges; ctr++)
        {
            Low  = ((pCP->pDBCS)[ctr])->LowRange;
            High = ((pCP->pDBCS)[ctr])->HighRange;

            if ((Lead >= Low) && (Lead <= High))
            {
                break;
            }
        }

        //
        //  Make sure the lead byte is valid.
        //
        if (ctr == pCP->NumDBCSRanges)
        {
            printf("Parse Error: Invalid default char '%x'.\n", wDefChar);
            return (1);
        }

        //
        //  Get the Unicode translation of the DBCS char.
        //
        pDBCSTable = (((pCP->pDBCS)[ctr])->pDBCSTbls)[Lead - Low];
        pCP->TransDefChar = ((WORD)(pDBCSTable[LOBYTE(wDefChar)]));

        //
        //  Make sure the trail byte is valid.
        //
        if ((pCP->TransDefChar == pCP->UniDefaultChar) &&
            (wDefChar != pCP->TransUniDefChar))
        {
            printf("Parse Error: Invalid default char '%x'.\n", wDefChar);
            return (1);
        }
    }
    else
    {
        pCP->TransDefChar = ((WORD)((pCP->pMB)[LOBYTE(wDefChar)]));
    }

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\nlstrans.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    nlstrans.c

Abstract:

    This file contains the main function, the main parsing functions, and
    all helper functions used by the various modules.

    External Routines in this file:
      MAIN
      GetSize

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include <stdio.h>
#include "nlstrans.h"




//
//  Global Variables.
//

FILE    *pInputFile;                   // pointer to Input File
BOOL    Verbose = 0;                   // verbose flag
BOOL    NLSPlus = 0;                   // To indicate the file should be generated in NLS+ format.
WCHAR   FileExtension[32];              // The file extension for generated files. It can be ".nls" or ".nlp"


//
//  Forward Declarations.
//

int
ParseCmdLine(
    int argc,
    char *argv[]);

void InitGlobals();

int
ParseInputFile(void);

int
GetKeyParam(
    PSZ pszParam);



//-------------------------------------------------------------------------//
//                              MAIN ROUTINE                               //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  MAIN
//
//  Main Routine.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int __cdecl main(
    int argc,
    char *argv[])
{
    //
    //  Parse the command line.
    //  Open input file.
    //
    if (ParseCmdLine(argc, argv))
    {
        return (1);
    }

    InitGlobals();

    //
    //  Parse the input file.
    //  Close the input file.
    //
    if (ParseInputFile())
    {
        fclose(pInputFile);
        return (1);
    }
    fclose(pInputFile);

    //
    //  Return success.
    //
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseCmdLine
//
//  This routine parses the command line.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int ParseCmdLine(
    int argc,
    char *argv[])
{
    int Pos = 1;                  // position of argument


    //
    //  Check for correct number of arguments.
    //
    if (argc < 2)
    {
        printf("Usage: nlstrans [-v] [-nlp] <inputfile>\n");
        printf("    -v: Verbose output.\n");
        printf("    -nlp: NLS+ format. This will only affect sortkey and sorttabl generation.\n");
        return (1);
    }

    //
    // Parse switches.
    //
    for (Pos = 1; Pos < argc - 1; Pos++)
    {
        if (argv[Pos][0] == '-' || argv[Pos][0] == '/')
        {
            //
            //  Check for verbose switch.
            //
            if (_stricmp(argv[Pos]+1, "v") == 0)
            {
                Verbose = 1;
                Pos++;
            } else if (_stricmp(argv[Pos]+1, "nlp") == 0)
            {
                NLSPlus = 1;
                Pos++;
            } else
            {
                printf("Invalid switch.\n");
                return (1);
            }
        } else
        {
            printf("Invalid switch.\n");
            return (1);
        }
    }

    //
    //  The last argument is the file name.
    //  Check input file exists and can be open as read only.
    //
    if ((pInputFile = fopen(argv[argc-1], "r")) == 0)
    {
        printf("Error opening input file.\n");
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  InitGlobals
//
//  Initialize global variables.
//
////////////////////////////////////////////////////////////////////////////

void InitGlobals()
{
    if (NLSPlus)
    {
        wcscpy(FileExtension, NLP_FILE_SUFFIX_W);
    } else
    {
        wcscpy(FileExtension, DATA_FILE_SUFFIX_W);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  ParseInputFile
//
//  This routine parses the input file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int ParseInputFile()
{
    char pszKeyWord[MAX];              // input token
    char pszParam[MAX];                // parameter for keyword
    CODEPAGE CP;                       // codepage structure
    LANGUAGE Lang;                     // language structure
    LANG_EXCEPT LangExcept;            // language exception structure
    LOCALE_HEADER LocHdr;              // header locale structure
    LOCALE_STATIC LocStat;             // static length locale structure
    LOCALE_VARIABLE LocVar;            // variable length locale structure
    UNICODE Unic;                      // unicode structure
    CTYPES CTypes;                     // ctypes structure
    SORTKEY Sortkey;                   // sortkey structure - sorting
    SORT_TABLES SortTbls;              // sort tables structure - sorting
    IDEOGRAPH_EXCEPT IdeographExcept;  // ideograph exception structure - sorting

    char SortKeyFileName[MAX_PATH];    // The output file name for sortkey table.
    char SortTblsFileName[MAX_PATH];   // The output file name for sorttbls table.



    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "CODEPAGE") == 0)
        {
            if (Verbose)
                printf("\n\nFound CODEPAGE keyword.\n");

            //
            //  Initialize CodePage structure.
            //
            memset(&CP, 0, sizeof(CODEPAGE));
            memset(pszParam, 0, MAX * sizeof(char));
            CP.pszName = pszParam;

            //
            //  Get CODEPAGE parameter string.
            //
            if (GetKeyParam(pszParam))
            {
                return (1);
            }

            //
            //  Get the valid keywords for CODEPAGE.
            //
            if (ParseCodePage(&CP, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the CODEPAGE tables to an output file.
            //
            if (WriteCodePage(&CP))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "LANGUAGE") == 0)
        {
            if (Verbose)
                printf("\n\nFound LANGUAGE keyword.\n");

            //
            //  Initialize Language structure.
            //
            memset(&Lang, 0, sizeof(LANGUAGE));

            //
            //  Get LANGUAGE parameter string.
            //
            if (GetKeyParam(pszParam))
            {
                return (1);
            }

            //
            //  Get the valid keywords for LANGUAGE.
            //
            if (ParseLanguage(&Lang, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the LANGUAGE tables to an output file.
            //
            if (WriteLanguage(&Lang))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "LANGUAGE_EXCEPTION") == 0)
        {
            if (Verbose)
                printf("\n\nFound LANGUAGE_EXCEPTION keyword.\n");

            //
            //  Initialize Language structure.
            //
            memset(&LangExcept, 0, sizeof(LANG_EXCEPT));

            //
            //  Get the valid keywords for LANGUAGE_EXCEPTION.
            //
            if (ParseLangException(&LangExcept, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the LANGUAGE_EXCEPTION tables to an output file.
            //
            if (WriteLangException(&LangExcept))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "LOCALE") == 0)
        {
            if (Verbose)
                printf("\n\nFound LOCALE keyword.\n");

            //
            //  Get the valid keywords for LOCALE.
            //  Write the LOCALE information to an output file.
            //
            if (ParseWriteLocale( &LocHdr,
                                  &LocStat,
                                  &LocVar,
                                  pszKeyWord ))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "UNICODE") == 0)
        {
            if (Verbose)
                printf("\n\nFound UNICODE keyword.\n");

            //
            //  Initialize Unicode structure.
            //
            memset(&Unic, 0, sizeof(UNICODE));

            //
            //  Get the valid keywords for UNICODE.
            //
            if (ParseUnicode(&Unic, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the UNICODE tables to an output file.
            //
            if (WriteUnicode(&Unic))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "GEO") == 0)
        {
            if (Verbose)
                printf("\n\nFound GEO keyword.\n");

            //
            //  Get the valid keywords for GEO.
            //  Write the GEO information to an output file.
            //
            if (ParseWriteGEO(pszKeyWord))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "CTYPES") == 0)
        {
            if (Verbose)
                printf("\n\nFound CTYPES keyword.\n");

            //
            //  Initialize CTypes structure.
            //
            memset(&CTypes, 0, sizeof(CTYPES));

            //
            //  Get the valid keywords for CTYPES.
            //
            if (ParseCTypes(&CTypes))
            {
                return (1);
            }

            //
            //  Write the CTYPES tables to different output files.
            //
            if (WriteCTypes(&CTypes))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "SORTKEY") == 0)
        {
            if (Verbose)
                printf("\n\nFound SORTKEY keyword.\n");

            if (NLSPlus)
            {
                strcpy(SortKeyFileName, SORTKEY_NLP_FILE);
            } else
            {
                strcpy(SortKeyFileName, SORTKEY_FILE);
            }

            //
            //  Initialize Sortkey structure.
            //
            memset(&Sortkey, 0, sizeof(SORTKEY));

            //
            //  Get the valid keywords for SORTKEY.
            //
            if (ParseSortkey(&Sortkey, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the SORTKEY tables to an output file.
            //
            if (WriteSortkey(&Sortkey, SortKeyFileName))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "SORTTABLES") == 0)
        {
            if (Verbose)
                printf("\n\nFound SORTTABLES keyword.\n");

            if (NLSPlus)
            {
                strcpy(SortTblsFileName, SORTTBLS_NLP_FILE);
            } else
            {
                strcpy(SortTblsFileName, SORTTBLS_FILE);
            }

            //
            //  Initialize Sort Tables structure.
            //
            memset(&SortTbls, 0, sizeof(SORT_TABLES));

            //
            //  Get the valid keywords for SORTTABLES.
            //
            if (ParseSortTables(&SortTbls, pszKeyWord))
            {
                return (1);
            }

            //
            //  Write the Sort Tables to an output file.
            //
            if (WriteSortTables(&SortTbls, SortTblsFileName))
            {
                return (1);
            }
        }

        else if (_stricmp(pszKeyWord, "IDEOGRAPH_EXCEPTION") == 0)
        {
            if (Verbose)
                printf("\n\nFound IDEOGRAPH_EXCEPTION keyword.\n");

            //
            //  Initialize Ideograph Exception structure.
            //
            memset(&IdeographExcept, 0, sizeof(IDEOGRAPH_EXCEPT));

            //
            //  Get the valid keywords for IDEOGRAPH_EXCEPTION.
            //
            if (ParseIdeographExceptions(&IdeographExcept))
            {
                return (1);
            }

            //
            //  Write the Ideograph Exceptions to the given output file.
            //
            if (WriteIdeographExceptions(&IdeographExcept))
            {
                return (1);
            }
        }

        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetKeyParam
//
//  This routine gets the parameter for the keyword from the input file.  If
//  the parameter is not there, then an error is returned.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetKeyParam(
    PSZ pszParam)
{
    //
    //  Read the parameter from the input file.
    //
    if (fscanf( pInputFile,
                "%s ;%*[^\n]",
                pszParam ) != 1)
    {
        printf("Parse Error: Error reading parameter value.\n");
        return (1);
    }

    if (Verbose)
        printf("  PARAMETER = %s\n\n", pszParam);

    //
    //  Return success.
    //
    return (0);
}




//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetSize
//
//  This routine gets the size of the table from the input file.  If the
//  size is not there, then an error is returned.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetSize(
    int *pSize)
{
    int NumItems;                 // number of items returned from fscanf


    //
    //  Read the size from the input file.
    //
    NumItems = fscanf( pInputFile,
                       "%d ;%*[^\n]",
                       pSize );
    if (NumItems != 1)
    {
        printf("Parse Error: Error reading size value.\n");
        return (1);
    }

    if (*pSize < 0)
    {
        printf("Parse Error: Invalid size value  %d\n", *pSize);
        return (1);
    }

    if (Verbose)
        printf("  SIZE = %d\n\n", *pSize);

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\ctype.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    ctype.c

Abstract:

    This file contains functions necessary to parse and write the ctype
    specific tables to a data file.

    External Routines in this file:
      ParseCTypes
      WriteCTypes

Revision History:

    12-10-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

int
GetCTypeTables(
    PCTYPES pCType,
    int Size);

int
WriteCTypeFile(
    PCT_ARRAY pCT,
    PCT_MAP pMap,
    int CTBuf2,
    int CTBuf3,
    PSZ pszFileName);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseCTypes
//
//  This routine parses the input file for the ctype tables.
//  This routine is only entered when the CTYPES keyword is found.
//  The parsing continues until the correct number of entries is read
//  in from the file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseCTypes(
    PCTYPES pCType)
{
    int size;                          // size of table to follow


    //
    //  Get size parameter.
    //
    if (GetSize(&size))
        return (1);

    //
    //  Get CTYPE Tables.
    //
    if (GetCTypeTables(pCType, size))
    {
        return (1);
    }

    //
    //  Remove any duplicate tables from the 8:4:4 table.
    //
    RemoveDuplicate844Levels( (P844_ARRAY)(pCType->pCType),
                              &(pCType->CTBuf2),
                              &(pCType->CTBuf3),
                              sizeof(BYTE) );

    //
    //  Set WriteFlags for all CTYPE Tables.
    //
    pCType->WriteFlags |= (F_CTYPE_1 | F_CTYPE_2 | F_CTYPE_3);

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCTypes
//
//  This routine writes the ctype tables to their appropriate output files.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCTypes(
    PCTYPES pCType)
{
    //
    //  Make sure all tables are present.
    //
    if (!((pCType->WriteFlags & F_CTYPE_1) &&
          (pCType->WriteFlags & F_CTYPE_2) &&
          (pCType->WriteFlags & F_CTYPE_3)))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             CType 1, CType 2, and CType 3 Tables.\n");
        return (1);
    }

    //
    //  Write CTYPE Table to output file.
    //
    if (WriteCTypeFile( pCType->pCType,
                        pCType->pMap,
                        pCType->CTBuf2,
                        pCType->CTBuf3,
                        CTYPE_FILE ))
    {
        return (1);
    }

    //
    //  Free CType table structures.
    //
    Free844(pCType->pCType);
    FreeCTMap(pCType->pMap);

    //
    //  Return success.
    //
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetCTypeTables
//
//  This routine gets the character type tables from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetCTypeTables(
    PCTYPES pCType,
    int Size)
{
    int WChar;                    // wide character value
    int CType1;                   // ctype1 value
    int CType2;                   // ctype2 value
    int CType3;                   // ctype3 value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 tables - 256 pointers.
    //
    if (Allocate8(&pCType->pCType))
    {
        return (1);
    }

    //
    //  Allocate buffer for mapping table.
    //
    if (AllocateCTMap(&pCType->pMap))
    {
        return (1);
    }

    //
    //  For each entry in table, read in wide character, ctype1, ctype2,
    //  and ctype3 from input file, allocate necessary buffers based on
    //  wide character value, and store mapped ctype information in the
    //  appropriate table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in wide character, ctype1, ctype2, and ctype3.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x %x %x ;%*[^\n]",
                           &WChar,
                           &CType1,
                           &CType2,
                           &CType3 );
        if (NumItems != 4)
        {
            printf("Parse Error: Error reading CTYPE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  WC = %x\tCT1 = %x\tCT2 = %x\tCT3 = %x\n",
                      WChar, CType1, CType2, CType3);

        //
        //  Insert CTYPE information into the 8:4:4 table.
        //
        if (Insert844Map( pCType->pCType,
                          pCType->pMap,
                          (WORD)WChar,
                          (WORD)CType1,
                          (WORD)CType2,
                          (WORD)CType3,
                          &pCType->CTBuf2,
                          &pCType->CTBuf3 ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCTypeFile
//
//  This routine writes the given CTYPE information to the output file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCTypeFile(
    PCT_ARRAY pCT,
    PCT_MAP pMap,
    int CTBuf2,
    int CTBuf3,
    PSZ pszFileName)
{
    DWORD TblSize844;             // size of 8:4:4 table
    DWORD TblSizeMap;             // size of mapping table
    DWORD TblSize;                // size of entire table
    FILE *pOutputFile;            // ptr to output file
    WORD wValue;                  // temp storage value


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(pszFileName, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", pszFileName);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", pszFileName);

    //
    //  Compute size of ctype table (in bytes).
    //
    TblSizeMap = ComputeCTMapSize(pMap);
    TblSize844 = Compute844Size( CTBuf2,
                                 CTBuf3,
                                 sizeof(BYTE) ) * sizeof(WORD);
    TblSize = TblSize844 + TblSizeMap + sizeof(WORD);

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of CType table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size of the ctype table to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "CType size" ))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Write CTYPE Mapping table and 8:4:4 table to file.
    //
    if (WriteCTMapTable( pOutputFile,
                         pMap,
                         (WORD)TblSizeMap ))
    {
        fclose(pOutputFile);
        return (1);
    }
    if (Write844TableMap( pOutputFile,
                          pCT,
                          (WORD)TblSize844 ))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Print out successful write.
    //
    printf("\nSuccessfully wrote output file %s\n", pszFileName);

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\language.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    language.c

Abstract:

    This file contains functions necessary to parse and write the language
    specific tables to a data file.

    External Routines in this file:
      ParseLanguage
      WriteLanguage
      ParseLangException
      WriteLangException

Revision History:

    12-10-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

int
GetUpperTable(
    PLANGUAGE pLang,
    int Size);

int
GetLowerTable(
    PLANGUAGE pLang,
    int Size);

int
GetLangExceptionTable(
    PLANG_EXCEPT pLangExcept,
    int Size);
int
WriteUpper(
    PLANGUAGE pLang,
    FILE *pOutputFile);

int
WriteLower(
    PLANGUAGE pLang,
    FILE *pOutputFile);

int
WriteLangExceptionTable(
    PLANG_EXCEPT pLangExcept,
    FILE *pOutputFile);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseLanguage
//
//  This routine parses the input file for the language specific tables.
//  This routine is only entered when the LANGUAGE keyword is found.
//  The parsing continues until the ENDLANGUAGE keyword is found.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseLanguage(
    PLANGUAGE pLang,
    PSZ pszKeyWord)
{
    int size;                          // size of table to follow


    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "UPPERCASE") == 0)
        {
            if (Verbose)
                printf("\n\nFound UPPERCASE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get UPPERCASE Table.
            //
            if (GetUpperTable(pLang, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for UPPERCASE Table.
            //
            pLang->WriteFlags |= F_UPPER;
        }

        else if (_stricmp(pszKeyWord, "LOWERCASE") == 0)
        {
            if (Verbose)
                printf("\n\nFound LOWERCASE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get LOWERCASE Table.
            //
            if (GetLowerTable(pLang, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for LOWERCASE Table.
            //
            pLang->WriteFlags |= F_LOWER;
        }

        else if (_stricmp(pszKeyWord, "ENDLANGUAGE") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDLANGUAGE keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }

        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  If this point is reached, then the ENDLANGUAGE keyword was
    //  not found.  Return an error.
    //
    printf("Parse Error: Expecting ENDLANGUAGE keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLanguage
//
//  This routine writes the language specific tables to an output file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLanguage(
    PLANGUAGE pLang)
{
    FILE *pOutputFile;            // ptr to output file
    WORD wValue;                  // temp storage value


    //
    //  Make sure all tables are present.
    //
    if (!((pLang->WriteFlags & F_UPPER) && (pLang->WriteFlags & F_LOWER)))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             Uppercase and Lowercase Tables.\n");
        return (1);
    }


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(LANGUAGE_FILE, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", LANGUAGE_FILE);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", LANGUAGE_FILE);

    //
    //  Write IfDefault value to file.
    //
    pLang->IfDefault = 1;
    wValue = (WORD)(pLang->IfDefault);
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "IfDefault" ))
    {
        return (1);
    }

    //
    //  Write UPPERCASE Table to output file.
    //
    if (WriteUpper(pLang, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free UPPERCASE table structures.
    //
    Free844(pLang->pUpper);


    //
    //  Write LOWERCASE Table to output file.
    //
    if (WriteLower(pLang, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free LOWERCASE table structures.
    //
    Free844(pLang->pLower);


    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", LANGUAGE_FILE);
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseLangException
//
//  This routine parses the input file for the language exception specific
//  tables.  This routine is only entered when the LANGUAGE_EXCEPTION keyword
//  is found.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseLangException(
    PLANG_EXCEPT pLangExcept,
    PSZ pszKeyWord)
{
    int size;                          // size of table to follow


    //
    //  Get size parameter.
    //
    if (GetSize(&size))
        return (1);

    //
    //  Get EXCEPTION Table.
    //
    if (GetLangExceptionTable(pLangExcept, size))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLangException
//
//  This routine writes the language excpetion specific tables to an output
//  file.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLangException(
    PLANG_EXCEPT pLangExcept)
{
    FILE *pOutputFile;                 // ptr to output file
    int ctr;                           // loop counter


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(LANG_EXCEPT_FILE, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", LANG_EXCEPT_FILE);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", LANG_EXCEPT_FILE);


    //
    //  Write EXCEPTION Table to output file.
    //
    if (WriteLangExceptionTable(pLangExcept, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free EXCEPTION header and table structures.
    //
    for (ctr = 0; ctr < pLangExcept->NumException; ctr++)
    {
        if ((pLangExcept->pExceptTbl)[ctr])
        {
            free((pLangExcept->pExceptTbl)[ctr]);
        }
    }
    free(pLangExcept->pExceptTbl);
    free(pLangExcept->pExceptHdr);


    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", LANG_EXCEPT_FILE);
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetUpperTable
//
//  This routine gets the upper case table from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetUpperTable(
    PLANGUAGE pLang,
    int Size)
{
    int LoChar;                   // lower case value
    int UpChar;                   // upper case value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pLang->pUpper))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the upper case and lower case
    //  character from input file, allocate necessary 16 word buffers
    //  based on upper case value, and store difference to lower case
    //  character.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in lower case and upper case characters.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &LoChar,
                           &UpChar );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading UPPERCASE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Lower = %x\tUpper = %x\n", LoChar, UpChar);

        //
        //  Insert difference (UpChar - LoChar) into 8:4:4 table.
        //
        if (Insert844( pLang->pUpper,
                       (WORD)LoChar,
                       (WORD)(UpChar - LoChar),
                       &pLang->UPBuf2,
                       &pLang->UPBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLowerTable
//
//  This routine gets the lower case table from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetLowerTable(
    PLANGUAGE pLang,
    int Size)
{
    int UpChar;                   // upper case value
    int LoChar;                   // lower case value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pLang->pLower))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the upper case and lower case
    //  character from input file, allocate necessary 16 word buffers
    //  based on lower case value, and store difference to upper case
    //  character.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in lower case and upper case characters.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &UpChar,
                           &LoChar );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading LOWERCASE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Upper = %x\tLower = %x\n", UpChar, LoChar);

        //
        //  Insert difference (LoChar - UpChar) into 8:4:4 table.
        //
        if (Insert844( pLang->pLower,
                       (WORD)UpChar,
                       (WORD)(LoChar - UpChar),
                       &pLang->LOBuf2,
                       &pLang->LOBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLangExceptionTable
//
//  This routine gets the exception table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetLangExceptionTable(
    PLANG_EXCEPT pLangExcept,
    int Size)
{
    DWORD Locale;                 // locale id
    int NumUp;                    // number of entries for upper case
    int NumLo;                    // number of entries for lower case
    int TotalNum;                 // total number of exceptions for locale
    int UCP1;                     // exception code point 1
    int UCP2;                     // exception code point 2
    int Offset = 0;               // offset to store
    int Ctr;                      // loop counter
    int Ctr2;                     // loop counter
    int LcidCtr;                  // loop counter
    int NumItems;                 // number of items returned from fscanf
    int Num;                      // temp value
    char pszTemp[MAX];            // temp buffer for string


    //
    //  Allocate exception header and exception table and set size of
    //  table in language exception tables structure.
    //
    if (AllocateLangException(pLangExcept, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the LCID keyword, locale id,
    //  the number of upper case entries for that locale id, and the
    //  number of lower case entries for that locale id.  Then, for all
    //  entries for the locale id, read in the exception code point and
    //  the upper/lower case code point.  Store all values in the
    //  exception header and the exception table.
    //
    Ctr = 0;
    while (Ctr < Size)
    {
        //
        //  Read in the LCID keyword, locale id, and the number of
        //  entries for the locale id.
        //
        NumItems = fscanf( pInputFile,
                           " LCID %i %i %i ;%*[^\n]",
                           &Locale,
                           &NumUp,
                           &NumLo );
        if (NumItems != 3)
        {
            printf("Parse Error: Error reading EXCEPTION LCID values.\n");
            return (1);
        }

        if (Verbose)
            printf("\n  LCID = %lx\tNumUpper = %d\tNumLower = %d\n\n",
                   Locale, NumUp, NumLo);

        //
        //  Store the locale id and the number of entries in the header.
        //
        ((pLangExcept->pExceptHdr)[Ctr]).Locale = (DWORD)Locale;
        ((pLangExcept->pExceptHdr)[Ctr]).Offset = (DWORD)Offset;
        ((pLangExcept->pExceptHdr)[Ctr]).NumUpEntries = (DWORD)NumUp;
        ((pLangExcept->pExceptHdr)[Ctr]).NumLoEntries = (DWORD)NumLo;

        //
        //  See if there are any other LCIDs for this exception table.
        //
        LcidCtr = 1;
        while (NumItems = fscanf( pInputFile,
                                  " LCID %i ;%*[^\n]",
                                  &Locale ))
        {
            if (NumItems > 2)
            {
                printf("Parse Error: Error reading secondary EXCEPTION LCID values.\n");
                return (1);
            }

            if (Verbose)
                printf("\n  LCID = %lx\tNumUpper = %d\tNumLower = %d\n\n",
                       Locale, NumUp, NumLo);

            //
            //  Store the locale id and the number of entries in the header.
            //
            ((pLangExcept->pExceptHdr)[Ctr + LcidCtr]).Locale = (DWORD)Locale;
            ((pLangExcept->pExceptHdr)[Ctr + LcidCtr]).Offset = (DWORD)Offset;
            ((pLangExcept->pExceptHdr)[Ctr + LcidCtr]).NumUpEntries = (DWORD)NumUp;
            ((pLangExcept->pExceptHdr)[Ctr + LcidCtr]).NumLoEntries = (DWORD)NumLo;

            LcidCtr++;
        }

        //
        //  Add (Num times number of words in exception node) to Offset
        //  to get the offset of the next LCID entries.
        //
        TotalNum = NumUp + NumLo;
        Offset += (TotalNum * NUM_L_EXCEPT_WORDS);

        //
        //  Allocate exception nodes for current LCID.
        //
        if (AllocateLangExceptionNodes(pLangExcept, TotalNum, Ctr))
        {
            return (1);
        }

        //
        //  Read in the UPPERCASE keyword.
        //
        NumItems = fscanf(pInputFile, "%s", pszTemp);
        if ((NumItems != 1) ||
            (_stricmp(pszTemp, "UPPERCASE") != 0))
        {
            printf("Parse Error: Error reading UPPERCASE keyword for LCID %lx.\n",
                    Locale);
            return (1);
        }
        else
        {
            if (Verbose)
                printf("\n\nFound UPPERCASE keyword.\n");
        }

        //
        //  For each entry for the locale id, read in the exception code
        //  point and the upper/lower case code point.  Store the values
        //  in the exception table nodes.
        //
        for (Ctr2 = 0; Ctr2 < TotalNum; Ctr2++)
        {
            if (Ctr2 == NumUp)
            {
                //
                //  Read in the LOWERCASE keyword.
                //
                NumItems = fscanf(pInputFile, "%s", pszTemp);
                if ((NumItems != 1) ||
                    (_stricmp(pszTemp, "LOWERCASE") != 0))
                {
                    printf("Parse Error: Error reading LOWERCASE keyword for LCID %lx.\n",
                            Locale);
                    return (1);
                }
                else
                {
                    if (Verbose)
                        printf("\n\nFound LOWERCASE keyword.\n");
                }
            }

            //
            //  Read in code point and the upper/lower case code point.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i ;%*[^\n]",
                               &UCP1,
                               &UCP2 );
            if (NumItems != 2)
            {
                printf("Parse Error: Error reading EXCEPTION values for LCID %lx.\n",
                        Locale);
                return (1);
            }

            if (Verbose)
                printf("    UCP1 = %x\tUCP2 = %x\n", UCP1, UCP2);

            //
            //  Store the weights in the exception table.
            //
            (((pLangExcept->pExceptTbl)[Ctr])[Ctr2]).UCP       = (WORD)UCP1;
            (((pLangExcept->pExceptTbl)[Ctr])[Ctr2]).AddAmount = (WORD)(UCP2 - UCP1);
        }

        Ctr += LcidCtr;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteUpper
//
//  This routine writes the UPPERCASE information to the output file.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteUpper(
    PLANGUAGE pLang,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting UPPERCASE Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pLang->UPBuf2,
                              pLang->UPBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of UPPER table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "UPPER size" ))
    {
        return (1);
    }

    //
    //  Write UPPERCASE 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pLang->pUpper,
                       pLang->UPBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLower
//
//  This routine writes the LOWERCASE information to the output file.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLower(
    PLANGUAGE pLang,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting LOWERCASE Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pLang->LOBuf2,
                              pLang->LOBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of LOWER table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "LOWER size" ))
    {
        return (1);
    }

    //
    //  Write LOWERCASE 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pLang->pLower,
                       pLang->LOBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteLangExceptionTable
//
//  This routine writes the EXCEPTION information to the output file.
//
//  08-30-95    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteLangExceptionTable(
    PLANG_EXCEPT pLangExcept,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    int Ctr;                      // loop counter
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting EXCEPTION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pLangExcept->NumException;

    //
    //  Write the number of exception locales to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(DWORD),
                   1,
                   "Exception Size" ))
    {
        return (1);
    }

    //
    //  Write the exception header to the output file.
    //
    if (FileWrite( pOutputFile,
                   pLangExcept->pExceptHdr,
                   sizeof(L_EXCEPT_HDR),
                   TblSize,
                   "Exception Header" ))
    {
        return (1);
    }

    //
    //  Write the exception table to the output file.
    //
    for (Ctr = 0; Ctr < TblSize; Ctr++)
    {
        if ((pLangExcept->pExceptTbl)[Ctr])
        {
            if (FileWrite( pOutputFile,
                           (pLangExcept->pExceptTbl)[Ctr],
                           sizeof(L_EXCEPT_NODE),
                           ( ((pLangExcept->pExceptHdr)[Ctr]).NumUpEntries +
                             ((pLangExcept->pExceptHdr)[Ctr]).NumLoEntries ),
                           "Exception Table" ))
            {
                return (1);
            }
        }
    }

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\data\tools\nlsplus\encodingtable\genencodingcpp.cpp ===
//
// GenEncodingCpp.cpp
//
// Generate the EncodingDate.cpp in the URT source.
//
// FromMLang.cpp contains data which maps an encoding name into a specific codepage.
// To add extra encoding name -> codepage mapping, add them in the end of
// MimeCharSet.


#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <mlang.h>
#include "FromMLang.h"
#include "FromURT.h"

const CLSID CLSID_CMultiLanguage = {0x275c23e2,0x3747,0x11d0,{0x9f,0xea,0x00,0xaa,0x00,0x3f,0x86,0x46}};
const IID IID_IMultiLanguage2 = {0xDCCFC164,0x2B38,0x11d2,{0xb7,0xec,0x00,0xc0,0x4f,0x8f,0x5d,0x9a}};

FILE* m_ResourceFile;
CHAR m_szResourceFileName[] = "EncodingResource.txt";

FILE* m_EncodingCPP;
CHAR m_szCPPFileName[] = "EncodingData.cpp";

IMultiLanguage2* m_pIMultiLanguage2;
IEnumCodePage*  m_pIEnumCodePages;

UINT m_nCodePageItems;
CodePageDataItem* m_pCodePageDataItems;


BOOL InitGlobals()
{
    if (CoCreateInstance(
        CLSID_CMultiLanguage, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_IMultiLanguage2, 
        (LPVOID*)&m_pIMultiLanguage2) != S_OK) 
    {
        printf("Failed in getting IMultiLanguage2 from MLang.\n");
        return(FALSE);
    }

    if (FAILED(m_pIMultiLanguage2->EnumCodePages(MIMECONTF_MIME_LATEST, 0x0409, &m_pIEnumCodePages))) 
    {
        printf("Failed in getting IEnumCodePages from MLang.\n");
        return(FALSE);
    }

    if (!(m_EncodingCPP = fopen(m_szCPPFileName, "w"))) 
    {
        printf("Failed in create %s.\n", m_szCPPFileName);
        return (FALSE);
    }

    if (!(m_ResourceFile = fopen(m_szResourceFileName, "w"))) 
    {
        printf("Failed in create %s.\n", m_szResourceFileName);
        return (FALSE);
    }
    
    return (TRUE);
}

int GetCodePageItem(int nCodePage) 
{
    for (UINT i = 0; i < m_nCodePageItems; i++) 
    {
        if (nCodePage == m_pCodePageDataItems[i].codePage) {
            return (i);
        }
    }
    printf("WARNING: data for codepage %d can not be found.\n", nCodePage);
    return (-1);
}
void GenerateHeader()
{
    fprintf(m_EncodingCPP, "#include \"common.h\"\n");
    fprintf(m_EncodingCPP, "#include <mlang.h>\n");    
    fprintf(m_EncodingCPP, "#include \"COMNlsInfo.h\"\n\n");
}

//
// Generate EncodingDataTable, which maps an encoding name into a specific
// codepage.
//
void GenerateEncodingDataTable()
{
    int i;
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Encoding data tables\n");
    fprintf(m_EncodingCPP, "//\n\n");
    
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Index an encoding name into an codepage in CodePageDataTable.\n");
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "const EncodingDataItem COMNlsInfo::EncodingDataTable[] = {\n");
    
    fprintf(m_EncodingCPP, "// Total Items: %d\n", g_nMIMECharsets);
    fprintf(m_EncodingCPP, "// encoding name, codepage.\n");
    for (i = 0; i < g_nMIMECharsets; i++) 
    {
        if (MimeCharSet[i].dwFlags & MIMECONTF_MIME_LATEST) 
        {
            int codePage = MimeCharSet[i].uiInternetEncoding;
            int nItem = GetCodePageItem(codePage);
            if (nItem == -1)
            {
                fwprintf(m_EncodingCPP, L"// ");
            }
            fwprintf(m_EncodingCPP, L"{L\"%s\", %d}, \n", 
                MimeCharSet[i].szCharset, codePage);
        }
    }
    fprintf(m_EncodingCPP, "};\n\n");
    fwprintf(m_EncodingCPP, L"const COMNlsInfo::m_nEncodingDataTableItems = \n");
    fwprintf(m_EncodingCPP, L"    sizeof(COMNlsInfo::EncodingDataTable)/sizeof(EncodingDataItem);\n\n");
    
}

void GenerateCodePageDataTable()
{
    int i;
    //
    // Generate CodePageDataTable.
    //
    fprintf(m_EncodingCPP, "//\n");
    fprintf(m_EncodingCPP, "// Information about codepages.\n");
    fprintf(m_EncodingCPP, "//\n");
    
    fprintf(m_EncodingCPP, "const CodePageDataItem COMNlsInfo::CodePageDataTable[] = {\n");
    fprintf(m_EncodingCPP, "// Total Items: %d\n", m_nCodePageItems);
    fprintf(m_EncodingCPP, "// code page, family code page, web name, header name, body name, flags\n");

    fprintf(m_EncodingCPP, "\n\n");
    for (i = 0; i < (int)m_nCodePageItems; i++) 
    {
        fwprintf(m_EncodingCPP, L"{ %5d, %5d, L\"%s\", L\"%s\", L\"%s\", ", 
            m_pCodePageDataItems[i].codePage, 
            m_pCodePageDataItems[i].uiFamilyCodePage,
            m_pCodePageDataItems[i].webName,
            m_pCodePageDataItems[i].headerName,
            m_pCodePageDataItems[i].bodyName
        );
        DWORD dwFlags = m_pCodePageDataItems[i].dwFlags;
        if (dwFlags & MIMECONTF_MAILNEWS) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_MAILNEWS | ");
        }
        if (dwFlags & MIMECONTF_BROWSER) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_BROWSER | ");
        }
        if (dwFlags & MIMECONTF_SAVABLE_MAILNEWS) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_SAVABLE_MAILNEWS | ");
        }
        if (dwFlags & MIMECONTF_SAVABLE_BROWSER) 
        {
            fwprintf(m_EncodingCPP, L"MIMECONTF_SAVABLE_BROWSER | ");
        }
        fwprintf(m_EncodingCPP, L"0");
        fwprintf(m_EncodingCPP, L"}, // \"%s\"\n", m_pCodePageDataItems[i].description);
        
    }
    fwprintf(m_EncodingCPP, L"// End of data.\n");
    fwprintf(m_EncodingCPP, L"{ 0, 0, NULL, NULL, NULL, 0 },\n");
    
    fwprintf(m_EncodingCPP, L"};\n\n");
    fwprintf(m_EncodingCPP, L"const COMNlsInfo::m_nCodePageTableItems = \n");
    fwprintf(m_EncodingCPP, L"    sizeof(COMNlsInfo::CodePageDataTable)/sizeof(CodePageDataItem);\n\n");
}

void GenerateResourceTxt()
{
    fwprintf(m_ResourceFile, L"; Encoding names:\n");
    fwprintf(m_ResourceFile, L";\n");
    fwprintf(m_ResourceFile, L";Total items: %d\n", m_nCodePageItems);
    fwprintf(m_ResourceFile, L";\n");

    for (UINT i = 0; i < m_nCodePageItems; i++) 
    {
        fwprintf(m_ResourceFile, L"Globalization.cp_%d = %s\n", m_pCodePageDataItems[i].codePage, m_pCodePageDataItems[i].description);
    }
}
int __cdecl StringOrdinalCompare(const void *arg1, const void *arg2);
int __cdecl SortCodePage(const void *arg1, const void *arg2);

//
// Retrieve codepage info by calling MLang.
//
BOOL CollectCodePageInfo()
{
    if (FAILED(m_pIMultiLanguage2->GetNumberOfCodePageInfo(&m_nCodePageItems))) 
    {
        printf("Error in calling GetNumberOfCodePageInfo()\n");
        return (FALSE);
    }
    
    m_pCodePageDataItems = new CodePageDataItem[m_nCodePageItems+g_nExtraCodePageDataItems];
    if (!m_pCodePageDataItems) 
    {
        return (FALSE);
    }
    MIMECPINFO cpInfo;
    ULONG nCPInfoFetched;

    int i = 0;
    while (m_pIEnumCodePages->Next(1, &cpInfo, &nCPInfoFetched) == S_OK) 
    {
        if (wcsstr(cpInfo.wszWebCharset, L"detect") == 0 && wcsstr(cpInfo.wszHeaderCharset, L"detect") == 0) 
        {
            m_pCodePageDataItems[i].codePage = cpInfo.uiCodePage;
            m_pCodePageDataItems[i].uiFamilyCodePage = cpInfo.uiFamilyCodePage;
            wcscpy(m_pCodePageDataItems[i].webName, cpInfo.wszWebCharset);
            wcscpy(m_pCodePageDataItems[i].headerName, cpInfo.wszHeaderCharset);
            wcscpy(m_pCodePageDataItems[i].bodyName, cpInfo.wszBodyCharset);
            wcscpy(m_pCodePageDataItems[i].description, cpInfo.wszDescription);
            m_pCodePageDataItems[i].dwFlags = cpInfo.dwFlags;
            i++;
        } else 
        {
            // Exclude autodetect codepages.
            wprintf(L"NOTE: codepage %d \"%s\" is excluded.\n", cpInfo.uiCodePage, cpInfo.wszDescription); 
        }
    }
    
    // Update the code page item number;
    m_nCodePageItems = i;

    return (TRUE);
}

BOOL ReplaceCodePageInfo()
{
    int i;
    UINT j;
    //
    // For some of the CodePageDataItem, URT uses different data.
    // The following loops replace the MLang version with URT version.
    //
    for (i = 0; i < g_nReplacedCodePageDataItems; i++) 
    {
        for (j = 0; j < m_nCodePageItems; j++) 
        {
            if (g_ReplacedCodePageData[i].codePage == m_pCodePageDataItems[j].codePage)
            {
                m_pCodePageDataItems[j].codePage = g_ReplacedCodePageData[i].codePage;
                wcscpy(m_pCodePageDataItems[j].webName, g_ReplacedCodePageData[i].webName);
                wcscpy(m_pCodePageDataItems[j].headerName, g_ReplacedCodePageData[i].headerName);
                wcscpy(m_pCodePageDataItems[j].bodyName, g_ReplacedCodePageData[i].bodyName);
                wcscpy(m_pCodePageDataItems[j].description, g_ReplacedCodePageData[i].description);
                m_pCodePageDataItems[j].dwFlags = g_ReplacedCodePageData[i].dwFlags;

                printf("NOTE: Codepage %d data is replaced with URT data.\n", g_ReplacedCodePageData[i].codePage);
            }
        }
    }

    return (TRUE);
}

BOOL AddExtraCodePageInfo()
{
    //
    // Add extra CodePageDataItems which are not contained in MLang.
    //
    for (int i = 0; i < g_nExtraCodePageDataItems; i++) 
    {
        m_pCodePageDataItems[m_nCodePageItems].codePage = ExtraCodePageData[i].codePage;
        m_pCodePageDataItems[m_nCodePageItems].uiFamilyCodePage = ExtraCodePageData[i].uiFamilyCodePage;
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].webName, ExtraCodePageData[i].webName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].headerName, ExtraCodePageData[i].headerName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].bodyName, ExtraCodePageData[i].bodyName);
        wcscpy(m_pCodePageDataItems[m_nCodePageItems].description, ExtraCodePageData[i].description);
        m_pCodePageDataItems[m_nCodePageItems].dwFlags = ExtraCodePageData[i].dwFlags;
        m_nCodePageItems++;
    }

    return (TRUE);
}

int __cdecl main(int argc, char* argv[])
{
    int i;
    UINT j;
    
    CoInitialize(NULL);
    if (!InitGlobals()) 
    {
        exit(1);
    }

    //
    // Sort MimeCharSet table using ordinal string sorting.
    //
    qsort((void*)MimeCharSet, g_nMIMECharsets, sizeof(MIMECHARSET), StringOrdinalCompare);

    if (!CollectCodePageInfo())
    {
        goto exit;
    }

    ReplaceCodePageInfo();
    AddExtraCodePageInfo();
    //
    // Sort m_pCodePageDataItems by codePage
    //
    qsort((void*)m_pCodePageDataItems, m_nCodePageItems, sizeof(CodePageDataItem), SortCodePage);

    GenerateHeader();
    GenerateEncodingDataTable();
    GenerateCodePageDataTable();
    GenerateResourceTxt();

    delete [] m_pCodePageDataItems;

    printf("\n\n%s is genereated correctly.\n", m_szCPPFileName);
    printf("%s is genereated correctly.\n", m_szResourceFileName);
    
exit:    
    m_pIEnumCodePages->Release();
    m_pIMultiLanguage2->Release();
    fclose(m_ResourceFile);
    CoUninitialize();
    return 0;
}

int __cdecl StringOrdinalCompare(const void *arg1, const void *arg2)
{
    MIMECHARSET* pMimeCharSet1 = (MIMECHARSET*)arg1;
    MIMECHARSET* pMimeCharSet2 = (MIMECHARSET*)arg2;
    //wprintf(L"[%s]", pMimeCharSet1->szCharset);
    int result;
    if (!CaseInsensitiveCompHelper(
        (WCHAR*)pMimeCharSet1->szCharset, (WCHAR*)pMimeCharSet2->szCharset,
        wcslen(pMimeCharSet1->szCharset),wcslen(pMimeCharSet2->szCharset),
        &result))
    {
        printf("FAILED in CaseInsensitiveCompHelper()\n");
        exit(1);
    }
    return (result);            
}

int __cdecl SortCodePage(const void *arg1, const void *arg2)
{
    CodePageDataItem* pItem1 = (CodePageDataItem*)arg1;
    CodePageDataItem* pItem2 = (CodePageDataItem*)arg2;

    return (pItem1->codePage - pItem2->codePage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\table.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    table.c

Abstract:

    This file contains functions necessary to manipulate the various
    table structures.

    External Routines in this file:
      ComputeMBSize
      Compute844Size
      ComputeCTMapSize
      Write844Table
      Write844TableMap
      WriteCTMapTable
      WriteWords
      FileWrite
      RemoveDuplicate844Levels

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Constant Declarations.
//

#define HASH_SIZE  65521          // size of hash table (prime #)




//
//  Typedef Declarations.
//

typedef struct hash_object_s
{
    PVOID pTable;                      // ptr to table
    struct hash_object_s *pNext;       // ptr to next hash node
} CT_HASH_OBJECT, *PCT_HASH_OBJECT;




//
//  Forward Declarations.
//

void
RemoveDuplicate844Level2(
    P844_ARRAY pArr,
    int *pBuf2);

void
RemoveDuplicate844Level3(
    P844_ARRAY pArr,
    int *pBuf3,
    int Size);

PVOID
FindHashTable(
    PVOID pTbl,
    PCT_HASH_OBJECT *pHashTbl,
    int Size);

DWORD
GetHashVal(
    PVOID pTbl,
    int Size);

void
FreeHashTable(
    PCT_HASH_OBJECT *pHashTbl);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ComputeMBSize
//
//  This routine returns the size (in words) of the MB, Glyph, and DBCS
//  tables.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int ComputeMBSize(
    PCODEPAGE pCP)
{
    int TblSize;                  // size of table
    int Ctr;                      // loop counter
    register int NumRanges;       // number of DBCS ranges
    PDBCS_ARRAY pArray;           // ptr to DBCS array


    //
    //  Compute static size of table.
    //
    if (pCP->WriteFlags & F_GLYPH)
    {
        TblSize = 1 + MB_TABLE_SIZE + (1 + GLYPH_TABLE_SIZE) + 1;
    }
    else
    {
        TblSize = 1 + MB_TABLE_SIZE + (1) + 1;
    }

    //
    //  Compute size with DBCS tables (if any).
    //
    NumRanges = pCP->NumDBCSRanges;
    if ((NumRanges > 0) && (pCP->WriteFlags & F_DBCS))
    {
        TblSize += DBCS_OFFSET_SIZE;

        pArray = pCP->pDBCS;
        for (Ctr = 0; Ctr < NumRanges; Ctr++)
        {
             TblSize += ((pArray[Ctr]->HighRange -
                          pArray[Ctr]->LowRange + 1) * DBCS_TABLE_SIZE);
        }
    }

    if (Verbose)
        printf("  Complete MB Table Size = %d\n", TblSize);

    //
    //  Return the table size.
    //
    return (TblSize);
}


////////////////////////////////////////////////////////////////////////////
//
//  Compute844Size
//
//  This routine returns the size (in words) of the 8:4:4 WORD or DWORD
//  table.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Compute844Size(
    int cbBuf2,
    int cbBuf3,
    int Size)
{
    int TblSize;                  // size of table


    //
    //  Adjust size of cbBuf2 and cbBuf3 for the two empty levels.
    //
    cbBuf2++;
    cbBuf3++;

    //
    //  Compute size of table.
    //
    TblSize = TABLE_SIZE_8 +
              (TABLE_SIZE_4 * cbBuf2) +
              (TABLE_SIZE_4 * cbBuf3 * Size / sizeof(WORD));

    if (Verbose)
        printf("  844 Table Size = %d\t\tBuf2 = %d\tBuf3 = %d\n",
                TblSize, cbBuf2, cbBuf3);

    //
    //  Return the table size.
    //
    return (TblSize);
}


////////////////////////////////////////////////////////////////////////////
//
//  ComputeCTMapSize
//
//  This routine returns the size of the ctype mapping table.
//
////////////////////////////////////////////////////////////////////////////

DWORD ComputeCTMapSize(
    PCT_MAP pMap)
{
    DWORD TblSize;                // size of table


    //
    //  Compute size of table.
    //
    TblSize = sizeof(WORD) + (pMap->Length * sizeof(CT_VALUES));

    if (Verbose)
        printf("  Mapping Table Size = %d\n", TblSize);

    //
    //  Return the table size.
    //
    return (TblSize);
}


////////////////////////////////////////////////////////////////////////////
//
//  Write844Table
//
//  This routine writes the 8:4:4 WORD table to the output file.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Write844Table(
    FILE *pOutputFile,
    P844_ARRAY pArr,
    int cbBuf2,
    int TblSize,
    int Size)
{
    WORD EmptyLevel2Offset;            // empty level 2 offset
    WORD EmptyLevel3Offset;            // empty level 3 offset
    WORD Pos2;                         // position array 2
    WORD Pos3;                         // position array 3
    WORD PosTemp2 = TABLE_SIZE_4;      // position in pTemp2
    WORD *pTemp;                       // temporary storage
    PVOID pTemp2;                      // temporary storage
    DWORD Ctr, Ctr2, Ctr3;             // loop counters
    P844_ARRAY ptr2;                   // ptr to second array
    P844_ARRAY ptr3;                   // ptr to third array


    //
    //  Need to adjust cbBuf2 for the empty level 2 table.
    //  TblSize was already adjusted for the empty level tables
    //  in Compute844Size.
    //
    cbBuf2++;

    //
    //  Set up the position offsets and the empty second and third level
    //  table offsets.  All Unicode characters that have no mappings will
    //  point to the empty tables.  Grab the first table in the second
    //  level tables (offset TABLE_SIZE_8 in pTemp) and the first table in
    //  the third level tables (offset TABLE_SIZE_8 + (cbBuf2 * TABLE_SIZE_4))
    //  for the empty tables.
    //
    EmptyLevel2Offset = TABLE_SIZE_8;
    Pos2 = EmptyLevel2Offset + TABLE_SIZE_4;
    EmptyLevel3Offset = TABLE_SIZE_8 + (cbBuf2 * TABLE_SIZE_4);
    Pos3 = EmptyLevel3Offset + (TABLE_SIZE_4 * Size / sizeof(WORD));

    //
    //  Allocate temporary storage buffers.
    //
    if (AllocateTemp844( &pTemp,
                         EmptyLevel3Offset,
                         sizeof(WORD) ))
    {
        return (1);
    }
    if (AllocateTemp844( &pTemp2,
                         TblSize - EmptyLevel3Offset,
                         Size ))
    {
        return (1);
    }

    //
    //  Set up the empty second level table to point to the empty third
    //  level table.
    //
    for (Ctr2 = 0; Ctr2 < TABLE_SIZE_4; Ctr2++)
    {
        pTemp[EmptyLevel2Offset + Ctr2] = EmptyLevel3Offset;
    }

    //
    //  For each entry in the array, copy the appropriate offsets
    //  to the storage buffer.
    //
    for (Ctr = 0; Ctr < TABLE_SIZE_8; Ctr++)
    {
        if ((ptr2 = (P844_ARRAY)(pArr[Ctr])) != NULL)
        {
            pTemp[Ctr] = Pos2;
            for (Ctr2 = 0; Ctr2 < TABLE_SIZE_4; Ctr2++)
            {
                if ((ptr3 = ptr2[Ctr2]) != NULL)
                {
                    pTemp[Pos2 + Ctr2] = Pos3;
                    for (Ctr3 = 0; Ctr3 < TABLE_SIZE_4; Ctr3++)
                    {
                        memcpy( ((BYTE *)pTemp2) + ((PosTemp2 + Ctr3) * Size),
                                ((BYTE *)ptr3) + (Ctr3 * Size),
                                Size );
                    }

                    //
                    //  When advancing the Pos3 counter, must compensate
                    //  for the Size (multiply by 2 for DWORD).
                    //
                    Pos3 += (TABLE_SIZE_4 * Size / sizeof(WORD));
                    PosTemp2 += TABLE_SIZE_4;
                }
                else
                {
                    pTemp[Pos2 + Ctr2] = EmptyLevel3Offset;
                }
            }
            Pos2 += TABLE_SIZE_4;
        }
        else
        {
            pTemp[Ctr] = EmptyLevel2Offset;
        }
    }

    //
    //  Write temp storage buffers to output file.
    //
    if (FileWrite( pOutputFile,
                   pTemp,
                   sizeof(WORD),
                   Pos2,
                   "8:4:4 buffer" ))
    {
        return (1);
    }

    if (FileWrite( pOutputFile,
                   pTemp2,
                   Size,
                   PosTemp2,
                   "8:4:4 buffer" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Write844TableMap
//
//  This routine writes the 8:4:4 BYTE "mapped" table to the output file.
//
//  10-29-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int Write844TableMap(
    FILE *pOutputFile,
    P844_ARRAY pArr,
    WORD TblSize)
{
    WORD EmptyLevel2Offset;            // empty level 2 offset
    WORD EmptyLevel3Offset;            // empty level 3 offset
    WORD Pos;                          // position level 2 & 3
    WORD *pTemp2;                      // temporary storage - level 2
    BYTE *pTempTbl;                    // temporary storage - entire table
    DWORD Ctr, Ctr2, Ctr3;             // loop counters
    P844_ARRAY ptr2;                   // ptr to second array
    PCT_MAP_VALUE ptr3;                // ptr to third array


    //
    //  Set up the second and third level empty tables.
    //
    EmptyLevel3Offset = (TABLE_SIZE_8 * sizeof(WORD));
    EmptyLevel2Offset = EmptyLevel3Offset + (TABLE_SIZE_4 * sizeof(BYTE));

    //
    //  Set up position offset for the regular second and third level
    //  tables.
    //
    Pos = EmptyLevel2Offset + (TABLE_SIZE_4 * sizeof(WORD));

    //
    //  Allocate temporary storage buffers.
    //
    if (AllocateTemp844( &pTemp2,
                         TABLE_SIZE_4,
                         sizeof(WORD) ))
    {
        return (1);
    }
    if (AllocateTemp844( &pTempTbl,
                         TblSize,
                         sizeof(BYTE) ))
    {
        return (1);
    }

    //
    //  Set up the empty second level table to point to the empty third
    //  level table.
    //
    for (Ctr = 0; Ctr < TABLE_SIZE_4; Ctr++)
    {
        pTemp2[Ctr] = EmptyLevel3Offset;
    }
    memcpy( &pTempTbl[EmptyLevel2Offset],
            pTemp2,
            TABLE_SIZE_4 * sizeof(WORD) );

    //
    //  For each entry in the array, copy the appropriate offsets
    //  to the storage buffers.
    //
    for (Ctr = 0; Ctr < TABLE_SIZE_8; Ctr++)
    {
        if ((ptr2 = (P844_ARRAY)(pArr[Ctr])) != NULL)
        {
            //
            //  See if the table is a duplicate.
            //
            if (ptr2[DUPLICATE_OFFSET] != 0)
            {
                //
                //  Table IS a duplicate, so just save the offset.
                //
                ((WORD *)pTempTbl)[Ctr] = (WORD)(ptr2[DUPLICATE_OFFSET]);

                //
                //  Set the duplicate pointer to null in the previous level,
                //  so that freeing of the 844 table is simpler.
                //
                pArr[Ctr] = NULL;
            }
            else
            {
                //
                //  Table is NOT a duplicate.
                //  Copy it and save the position for use later if
                //  it's a duplicate.
                //
                for (Ctr2 = 0; Ctr2 < TABLE_SIZE_4; Ctr2++)
                {
                    if ((ptr3 = ptr2[Ctr2]) != NULL)
                    {
                        //
                        //  See if the table is a duplicate.
                        //
                        if (*(WORD *)(ptr3 + DUPLICATE_OFFSET) != 0)
                        {
                            //
                            //  Table IS a duplicate, so just save the
                            //  offset.
                            //
                            pTemp2[Ctr2] = *(WORD *)(ptr3 + DUPLICATE_OFFSET);

                            //
                            //  Set the duplicate pointer to null in the
                            //  previous level, so that freeing of the
                            //  844 table is simpler.
                            //
                            ptr2[Ctr2] = NULL;
                        }
                        else
                        {
                            //
                            //  Table is NOT yet a duplicate.
                            //  Save the position in case this third
                            //  level table is used again.
                            //
                            *(WORD *)(ptr3 + DUPLICATE_OFFSET) = Pos;
                            pTemp2[Ctr2] = Pos;

                            //
                            //  Copy the third level table to the buffer
                            //  and update the position counter.
                            //
                            for (Ctr3 = 0; Ctr3 < TABLE_SIZE_4; Ctr3++)
                            {
                                pTempTbl[Pos + Ctr3] = ptr3[Ctr3];
                            }

                            Pos += TABLE_SIZE_4;
                        }
                    }
                    else
                    {
                        pTemp2[Ctr2] = EmptyLevel3Offset;
                    }
                }

                //
                //  Save the position in case this second level table is
                //  used again.
                //
                (WORD)ptr2[DUPLICATE_OFFSET] = Pos;

                //
                //  Copy the second level table to the buffer,
                //  update the first level table with the position of
                //  the second level table, and update the position
                //  counter.
                //
                memcpy( &pTempTbl[Pos],
                        pTemp2,
                        TABLE_SIZE_4 * sizeof(WORD) );

                ((WORD *)pTempTbl)[Ctr] = Pos;

                Pos += (TABLE_SIZE_4 * sizeof(WORD));
            }
        }
        else
        {
            ((WORD *)pTempTbl)[Ctr] = EmptyLevel2Offset;
        }
    }

    //
    //  Write temp storage buffers to output file.
    //
    if (FileWrite( pOutputFile,
                   pTempTbl,
                   sizeof(BYTE),
                   TblSize,
                   "8:4:4 buffer" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCTMapTable
//
//  This routine writes the ctype mapping table to the output file.
//
////////////////////////////////////////////////////////////////////////////

int WriteCTMapTable(
    FILE *pOutputFile,
    PCT_MAP pMap,
    WORD MapSize)
{
    //
    //  Write the size of the mapping table.
    //
    if (FileWrite( pOutputFile,
                   &MapSize,
                   sizeof(WORD),
                   1,
                   "Mapping Table size" ))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Write mapping table to output file.
    //
    if (FileWrite( pOutputFile,
                   pMap->pCTValues,
                   MapSize - sizeof(WORD),
                   1,
                   "Mapping Table buffer" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteWords
//
//  This routine writes multiple words of the same value to the output file.
//  The number of values written is determined by the Num parameter.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WriteWords(
    FILE *pOutputFile,
    WORD Value,
    int Num)
{
    //
    //  Write the given 'Value' as a WORD 'Num' times to the output file.
    //
    if (FileWrite( pOutputFile,
                   &Value,
                   sizeof(WORD),
                   Num,
                   "WRITE WORDS" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileWrite
//
//  This routine writes the given buffer to the output file.  If an error is
//  encountered, then it is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int FileWrite(
    FILE *pOutputFile,
    void *Buffer,
    int Size,
    int Count,
    char *ErrStr)
{
    //
    //  Write information to output file.
    //
    if (fwrite( Buffer,
                Size,
                Count,
                pOutputFile ) != (unsigned int)Count)
    {
        printf("Write Error: Can't write %s to file.\n", ErrStr);
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveDuplicate844Levels
//
//  This routine removes all duplicate second levels and all duplicate
//  third levels from an 8:4:4 table.
//
////////////////////////////////////////////////////////////////////////////

void RemoveDuplicate844Levels(
    P844_ARRAY pArr,
    int *pBuf2,
    int *pBuf3,
    int Size)
{
    //
    //  Remove the duplicates from the third level of the 8:4:4 table
    //  first.
    //
    RemoveDuplicate844Level3( pArr,
                              pBuf3,
                              Size );

    //
    //  Remove the duplicates from the second level of the 8:4:4 table.
    //
    RemoveDuplicate844Level2( pArr,
                              pBuf2 );
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  RemoveDuplicate844Level2
//
//  This routine removes all duplicate second levels from the given 8:4:4
//  table.
//
////////////////////////////////////////////////////////////////////////////

void RemoveDuplicate844Level2(
    P844_ARRAY pArr,
    int *pBuf2)
{
    P844_ARRAY pTbl2;             // ptr to second array
    P844_ARRAY pCmp;              // ptr to second array to compare
    int Ctr, Ctr2, Ctr3;          // loop counters


    //
    //  Search through all second level tables.  If there is a duplicate,
    //  fix the affected pointers in the first level table and free the
    //  duplicate table.
    //
    for (Ctr = 1; Ctr < TABLE_SIZE_8; Ctr++)
    {
        if ((pTbl2 = (P844_ARRAY)(pArr[Ctr])) != NULL)
        {
            //
            //  See if any of the previous second level tables are the
            //  same as the current one.
            //
            for (Ctr2 = Ctr - 1; Ctr2 >= 0; Ctr2--)
            {
                if ((pCmp = (P844_ARRAY)(pArr[Ctr2])) != NULL)
                {
                    //
                    //  Compare each entry in both tables to see if
                    //  the tables are the same.
                    //
                    for (Ctr3 = 0; Ctr3 < TABLE_SIZE_4; Ctr3++)
                    {
                        if (pTbl2[Ctr3] != pCmp[Ctr3])
                        {
                            break;
                        }
                    }
                    if (Ctr3 == TABLE_SIZE_4)
                    {
                        //
                        //  Tables are the same.  Fix the pointer
                        //  in the first level table.
                        //
                        pArr[Ctr] = pCmp;

                        //
                        //  Free the duplicate second level table.
                        //
                        free(pTbl2);

                        //
                        //  Decrement the number of second level tables.
                        //
                        (*pBuf2)--;

                        //
                        //  Found the duplicate, so break out of the
                        //  comparison loop.
                        //
                        break;
                    }
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveDuplicate844Level3
//
//  This routine removes all duplicate third levels from the given 8:4:4
//  table.
//
////////////////////////////////////////////////////////////////////////////

void RemoveDuplicate844Level3(
    P844_ARRAY pArr,
    int *pBuf3,
    int Size)
{
    P844_ARRAY pTbl2;             // ptr to second array
    PVOID pTbl3;                  // ptr to third array
    PVOID pCmp;                   // ptr to third array to compare
    PCT_HASH_OBJECT *pHashTbl;    // hash table
    int Ctr, Ctr2;                // loop counters


    //
    //  Allocate the hash table.
    //
    pHashTbl = (PCT_HASH_OBJECT *)malloc(HASH_SIZE * sizeof(PCT_HASH_OBJECT));
    memset( pHashTbl,
            0,
            (HASH_SIZE * sizeof(PCT_HASH_OBJECT)) );

    //
    //  Search through all third level tables.  If there is a duplicate,
    //  fix the affected pointers in the second level tables and free the
    //  duplicate table.
    //
    for (Ctr = 0; Ctr < TABLE_SIZE_8; Ctr++)
    {
        if ((pTbl2 = (P844_ARRAY)(pArr[Ctr])) != NULL)
        {
            //
            //  See if any of the previous third level tables are the
            //  same as the current one.
            //
            for (Ctr2 = 0; Ctr2 < TABLE_SIZE_4; Ctr2++)
            {
                if ((pTbl3 = pTbl2[Ctr2]) != NULL)
                {
                    //
                    //  Compare each entry in the table to see if
                    //  the table is the same as any of the previous
                    //  tables.
                    //
                    pCmp = FindHashTable( pTbl3,
                                          pHashTbl,
                                          Size );

                    if (pCmp != NULL)
                    {
                        //
                        //  Tables are the same.  Fix the pointer
                        //  in the second level table.
                        //
                        pTbl2[Ctr2] = pCmp;

                        //
                        //  Free the duplicate third level table.
                        //
                        free(pTbl3);

                        //
                        //  Decrement the number of second level tables.
                        //
                        (*pBuf3)--;
                    }
                }
            }
        }
    }

    //
    //  Free the hash table.
    //
    FreeHashTable(pHashTbl);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindHashTable
//
//  This routine searches the hash table for the given third level table.
//  If a matching table is found, the pointer to the table is returned.
//  Otherwise, it returns NULL.
//
////////////////////////////////////////////////////////////////////////////

PVOID FindHashTable(
    PVOID pTbl,
    PCT_HASH_OBJECT *pHashTbl,
    int Size)
{
    DWORD HashVal;                // hash value
    PCT_HASH_OBJECT pHashN;       // ptr to hash node
    PCT_HASH_OBJECT pNewHash;     // ptr to new hash node
    int Ctr;                      // loop counter


    //
    //  Get hash value of the given table.
    //
    HashVal = GetHashVal(pTbl, Size);

    //
    //  Search through all hash tables.
    //
    for (pHashN = pHashTbl[HashVal]; pHashN != NULL; pHashN = pHashN->pNext)
    {
        //
        //  See if the two tables are the same.  If they are, return the
        //  pointer to the table.
        //
        for (Ctr = 0; Ctr < TABLE_SIZE_4; Ctr++)
        {
            if (memcmp( ((BYTE *)(pHashN->pTable)) + (Ctr * Size),
                        ((BYTE *)pTbl) + (Ctr * Size),
                        Size ))
            {
                break;
            }
        }
        if (Ctr == TABLE_SIZE_4)
        {
            //
            //  Tables are the same.  Return the pointer to the table.
            //
            return (pHashN->pTable);
        }
    }

    //
    //  Could not find a table that matched the given table.
    //  Create a new hash node and insert it in the hash table.
    //
    pNewHash = (PCT_HASH_OBJECT)malloc(sizeof(CT_HASH_OBJECT));
    pNewHash->pTable = pTbl;
    pNewHash->pNext = pHashTbl[HashVal];
    pHashTbl[HashVal] = pNewHash;

    //
    //  Return NULL to indicate that an identical table could not be found.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetHashVal
//
//  This routine calculates the hash value of a table.
//
////////////////////////////////////////////////////////////////////////////

DWORD GetHashVal(
    PVOID pTbl,
    int Size)
{
    DWORD HashVal = 0;            // hash value
    DWORD Multiplier = 1;         // multiplier for each entry
    int Ctr;                      // loop counter


    for (Ctr = 0; Ctr < TABLE_SIZE_4; Ctr++)
    {
        HashVal += ((*(((BYTE *)pTbl) + (Ctr * Size))) * Multiplier);
        Multiplier *= 2;
    }

    return ((DWORD)(HashVal / HASH_SIZE));
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeHashTable
//
//  This routine frees the hash table.
//
////////////////////////////////////////////////////////////////////////////

void FreeHashTable(
    PCT_HASH_OBJECT *pHashTbl)
{
    PCT_HASH_OBJECT pHashN;       // ptr to hash node
    PCT_HASH_OBJECT pNext;        // ptr to next hash node
    int Ctr = 0;                  // loop counter


    //
    //  Search through each entry in the hash table and free each node.
    //
    for (Ctr = 0; Ctr < HASH_SIZE; Ctr++)
    {
        pHashN = pHashTbl[Ctr];
        while (pHashN != NULL)
        {
            pNext = pHashN->pNext;
            free(pHashN);
            pHashN = pNext;
        }
    }

    //
    //  Free the hash table array.
    //
    free(pHashTbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\nlstrans.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    nlstrans.h

Abstract:

    This file contains the header information shared by all of the modules
    of the NLSTRANS utility.

Revision History:

    07-30-91    JulieB    Created.
    03-10-00    lguindon  Began GEO API port.
    09-12-00    JulieB    Fixed buffer sizes from GEO port.

--*/



////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winnls.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>




////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Define boolean constants.
//
#define FALSE                0
#define TRUE                 1


//
//  Table Sizes.
//
#define MAX                  256            // max buffer size
#define MB_TABLE_SIZE        256            // size of MB table
#define GLYPH_TABLE_SIZE     MB_TABLE_SIZE  // size of Glyph table
#define DBCS_TABLE_SIZE      256            // size of DBCS table
#define DBCS_OFFSET_SIZE     256            // size of DBCS offset area
#define WC_TABLE_SIZE        (64 * 1024)    // size of WC table (char cnt)
#define TABLE_SIZE_8         256            // size for 8:4:4 array (8)
#define TABLE_SIZE_4          16            // size for 8:4:4 array (4)
#define MAX_844_TBL_SIZE     (64 * 1024)    // max size of 8:4:4 table
#define FILE_NAME_LEN         10            // max length of a file name
#define MAX_NUM_LEADBYTE      12            // max number of DBCS lead bytes
#define SKEY_TBL_SIZE        (64 * 1024)    // size of SORTKEY default table
#define MAX_CT_MAP_TBL_SIZE  256            // max size of CTYPE Mapping table

#define MAX_FONTSIGNATURE     16            // max size of font signature


//
//  Geo Table Sizes.
//
#define MAX_SIGNATURE          4            // max size of signature
#define MAX_LATITUDE          12            // max size of latitude
#define MAX_LONGITUDE         12            // max size of longitude
#define MAX_ISO_ABBREV         4            // max size of iso abbreviations


//
//  Special Flags.
//
#define DUPLICATE_OFFSET     TABLE_SIZE_4   // offset to duplicate flag (ctype)
#define CP_ACP               0              // default to ANSI code page


//
//  String Constants for Data Files.
//
#define CP_PREFIX            "c_"
#define DATA_FILE_SUFFIX     ".nls"
#define NLP_FILE_SUFFIX      ".nlp"

#define DATA_FILE_SUFFIX_W   L".nls"
#define NLP_FILE_SUFFIX_W    L".nlp"

#define LANGUAGE_FILE        "l_intl.nls"
#define LANG_EXCEPT_FILE     "l_except.nls"
#define LOCALE_FILE          "locale.nls"
#define UNICODE_FILE         "unicode.nls"
#define CTYPE_FILE           "ctype.nls"
#define SORTKEY_FILE         "sortkey.nls"
#define SORTTBLS_FILE        "sorttbls.nls"

#define SORTKEY_NLP_FILE     "sortkey.nlp"
#define SORTTBLS_NLP_FILE    "sorttbls.nlp"

#define GEOFILE              "geo.nls"


//
//  Flags denoting which tables to write to the output files.
//
#define F_CPINFO             0x80000000
#define F_MB                 0x00000001
#define F_GLYPH              0x00000002
#define F_DBCS               0x00000004
#define F_WC                 0x00000008

#define F_UPPER              0x00000010
#define F_LOWER              0x00000020

#define F_ADIGIT             0x00000100
#define F_CZONE              0x00000200
#define F_COMP               0x00000400
#define F_HIRAGANA           0x00001000
#define F_KATAKANA           0x00002000
#define F_HALFWIDTH          0x00004000
#define F_FULLWIDTH          0x00008000
#define F_TRADITIONAL        0x00010000
#define F_SIMPLIFIED         0x00020000

#define F_CTYPE_1            0x00010000
#define F_CTYPE_2            0x00020000
#define F_CTYPE_3            0x00040000

#define F_DEFAULT_SORTKEY    0x00100000
#define F_REVERSE_DW         0x00200000
#define F_DOUBLE_COMPRESS    0x00400000
#define F_MULTIPLE_WEIGHTS   0x00800000
#define F_EXPANSION          0x01000000
#define F_EXCEPTION          0x02000000
#define F_COMPRESSION        0x04000000
#define F_IDEOGRAPH_LCID     0x08000000
#define F_JAMOSORT           0x10000000

#define JAMO_INDEX_SIZE      0x100
#define JAMO_INDEX_RANGE     0xffff
#define FIRST_JAMO           0x1100
#define LAST_JAMO            0x11ff




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////

typedef unsigned long   DWORD;
typedef unsigned short  WORD;
typedef unsigned char   BYTE;
typedef int             BOOL;
typedef void           *PVOID;
typedef unsigned int    UINT;
typedef char           *PSZ;
typedef DWORD           LCID;
typedef unsigned short  WCHAR;
typedef char            CHAR;

typedef WORD           *PMB_TBL;
typedef WORD           *PGLYPH_TBL;
typedef PVOID          *PDBCS_TBL_ARRAY;
typedef WORD           *PDBCS_TBL;
typedef WORD           *PDBCS_OFFSETS;

typedef struct dbcs_range_s
{
    WORD                LowRange;
    WORD                HighRange;
    PDBCS_TBL_ARRAY     pDBCSTbls;
} DBCS_RANGE, *PDBCS_RANGE;

typedef PDBCS_RANGE    *PDBCS_ARRAY;

typedef PVOID          *P844_ARRAY;
typedef PVOID           PWC_ARRAY;
typedef P844_ARRAY      PCT_ARRAY;
typedef P844_ARRAY      PUP_ARRAY;
typedef P844_ARRAY      PLO_ARRAY;
typedef P844_ARRAY      PAD_ARRAY;
typedef P844_ARRAY      PCZ_ARRAY;
typedef P844_ARRAY      PHG_ARRAY;
typedef P844_ARRAY      PKK_ARRAY;
typedef P844_ARRAY      PHW_ARRAY;
typedef P844_ARRAY      PFW_ARRAY;
typedef P844_ARRAY      PTR_ARRAY;
typedef P844_ARRAY      PSP_ARRAY;
typedef P844_ARRAY      PPCOMP_ARRAY;
typedef P844_ARRAY      PCOMP_ARRAY;
typedef WORD           *PCOMP_GRID;



////////////////////////////////////////
//
//  CODEPAGE File Structures.
//
////////////////////////////////////////

typedef struct codepage_s
{
    PMB_TBL        pMB;                // ptr to MB array (1:1)
    PGLYPH_TBL     pGlyph;             // ptr to Glyph array (1:1)
    PDBCS_ARRAY    pDBCS;              // ptr to DBCS info
    PDBCS_OFFSETS  pDBCSOff;           // ptr to DBCS offset area
    PWC_ARRAY      pWC;                // ptr to WC 8:4:4 info
    DWORD          WriteFlags;         // which tables to write
    int            NumDBCSRanges;      // number of DBCS Ranges
    PSZ            pszName;            // ptr to codepage name (value)
    int            CodePageValue;      // code page value
    int            MaxCharSize;        // max character length
    WORD           DefaultChar;        // default character (mbcs)
    WORD           UniDefaultChar;     // unicode default char
    WORD           TransDefChar;       // translation of default char (unicode)
    WORD           TransUniDefChar;    // translation of uni def char (mbcs)
    BYTE           LeadBytes[MAX_NUM_LEADBYTE];
} CODEPAGE, *PCODEPAGE;

#define  CP_INFO_SIZE  13              // size of CPINFO + 1 (in words)



////////////////////////////////////////
//
//  LANGUAGE File Structures.
//
////////////////////////////////////////

typedef struct language_s
{
    PUP_ARRAY      pUpper;             // ptr to UPPERCASE 8:4:4 info
    PLO_ARRAY      pLower;             // ptr to LOWERCASE 8:4:4 info
    DWORD          WriteFlags;         // tables to write
    int            IfDefault;          // 1 for default file, 0 otherwise
    int            UPBuf2;             // number UPPERCASE Buffer 2
    int            UPBuf3;             // number UPPERCASE Buffer 3
    int            LOBuf2;             // number LOWERCASE Buffer 2
    int            LOBuf3;             // number LOWERCASE Buffer 3
} LANGUAGE, *PLANGUAGE;


typedef struct l_except_hdr_s
{
    DWORD          Locale;             // locale id
    DWORD          Offset;             // offset to exception nodes
    DWORD          NumUpEntries;       // number of upper case entries
    DWORD          NumLoEntries;       // number of lower case entries
} L_EXCEPT_HDR, *PL_EXCEPT_HDR;

typedef struct l_except_node_s
{
    WORD           UCP;                // unicode code point
    WORD           AddAmount;          // amount to add to initial code point
} L_EXCEPT_NODE, *PL_EXCEPT_NODE;

typedef PL_EXCEPT_NODE *PL_EXCEPT_TBL; // ptr to array of exception nodes

#define NUM_L_EXCEPT_WORDS        (sizeof(L_EXCEPT_NODE) / sizeof(WORD))

typedef struct lang_except_s
{
    int            NumException;       // number of EXCEPTION locales
    PL_EXCEPT_HDR  pExceptHdr;         // ptr to language exception header
    PL_EXCEPT_TBL  pExceptTbl;         // ptr to language exception table
} LANG_EXCEPT, *PLANG_EXCEPT;



////////////////////////////////////////
//
//  UNICODE File Structures.
//
////////////////////////////////////////

typedef struct unicode_s
{
    PAD_ARRAY      pADigit;            // ptr to ASCIIDIGITS 8:4:4 info
    PCZ_ARRAY      pCZone;             // ptr to FOLDCZONE 8:4:4 info
    PHG_ARRAY      pHiragana;          // ptr to HIRAGANA 8:4:4 info
    PKK_ARRAY      pKatakana;          // ptr to KATAKANA 8:4:4 info
    PHW_ARRAY      pHalfWidth;         // ptr to HALFWIDTH 8:4:4 info
    PFW_ARRAY      pFullWidth;         // ptr to FULLWIDTH 8:4:4 info
    PTR_ARRAY      pTraditional;       // ptr to TRADITIONAL 8:4:4 info
    PSP_ARRAY      pSimplified;        // ptr to SIMPLIFIED 8:4:4 info
    PPCOMP_ARRAY   pPreComp;           // ptr to PRECOMPOSED 8:4:4 info
    PCOMP_ARRAY    pBase;              // ptr to COMPOSITE Base 8:4:4
    PCOMP_ARRAY    pNonSp;             // ptr to COMPOSITE NonSpace 8:4:4
    PCOMP_GRID     pCompGrid;          // ptr to COMPOSITE 2D Grid
    int            NumBase;            // total number of BASE characters
    int            NumNonSp;           // total number of NONSPACE characters
    DWORD          WriteFlags;         // tables to write
    int            ADBuf2;             // number ASCIIDIGITS Buffer 2
    int            ADBuf3;             // number ASCIIDIGITS Buffer 3
    int            CZBuf2;             // number FOLDCZONE Buffer 2
    int            CZBuf3;             // number FOLDCZONE Buffer 3
    int            HGBuf2;             // number HIRAGANA Buffer 2
    int            HGBuf3;             // number HIRAGANA Buffer 3
    int            KKBuf2;             // number KATAKANA Buffer 2
    int            KKBuf3;             // number KATAKANA Buffer 3
    int            HWBuf2;             // number HALFWIDTH Buffer 2
    int            HWBuf3;             // number HALFWIDTH Buffer 3
    int            FWBuf2;             // number FULLWIDTH Buffer 2
    int            FWBuf3;             // number FULLWIDTH Buffer 3
    int            TRBuf2;             // number TRADITIONAL Buffer 2
    int            TRBuf3;             // number TRADITIONAL Buffer 3
    int            SPBuf2;             // number SIMPLIFIED Buffer 2
    int            SPBuf3;             // number SIMPLIFIED Buffer 3
    int            PCBuf2;             // number PRECOMPOSED Buffer 2
    int            PCBuf3;             // number PRECOMPOSED Buffer 3
    int            BSBuf2;             // number COMPOSITE BASE Buffer 2
    int            BSBuf3;             // number COMPOSITE BASE Buffer 3
    int            NSBuf2;             // number COMPOSITE NONSPACE Buffer 2
    int            NSBuf3;             // number COMPOSITE NONSPACE Buffer 3
} UNICODE, *PUNICODE;



////////////////////////////////////////
//
//  CTYPE File Structures.
//
////////////////////////////////////////

typedef struct ct_values_s
{
    WORD           CType1;             // ctype 1 value
    WORD           CType2;             // ctype 2 value
    WORD           CType3;             // ctype 3 value
} CT_VALUES, *PCT_VALUES;

typedef BYTE CT_MAP_VALUE, *PCT_MAP_VALUE;

typedef struct ct_map_s
{
    int            Length;             // length of mapping table
    PCT_VALUES     pCTValues;          // table of CTYPE values
} CT_MAP, *PCT_MAP;

typedef struct ctypes_s
{
    PCT_ARRAY      pCType;             // ptr to CTYPE 8:4:4 info
    PCT_MAP        pMap;               // ptr to mapping table
    DWORD          WriteFlags;         // tables to write
    int            CTBuf2;             // number CTYPE Buffer 2
    int            CTBuf3;             // number CTYPE Buffer 3
} CTYPES, *PCTYPES;



////////////////////////////////////////
//
//  SORTKEY & SORTTBLS File Structures.
//
////////////////////////////////////////

typedef struct skey_s
{
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
    BYTE           Diacritic;          // diacritic weight
    BYTE           Case;               // case weight (incl. compression)
} SKEY, *PSKEY;

typedef struct sortkey_s
{
    PSKEY          pDefault;           // ptr to DEFAULT SORTKEY info
    DWORD          WriteFlags;         // tables to write
} SORTKEY, *PSORTKEY;


typedef DWORD           REV_DW;
typedef REV_DW         *PREV_DW;

typedef DWORD           DBL_COMPRESS;
typedef DBL_COMPRESS   *PDBL_COMPRESS;

typedef struct ideograph_lcid_s
{
    DWORD          Locale;             // locale id
    WORD           pFileName[14];      // ptr to file name
} IDEOGRAPH_LCID, *PIDEOGRAPH_LCID;

typedef struct expand_s
{
    WORD           CP1;                // code point 1 - expansion
    WORD           CP2;                // code point 2 - expansion
} EXPAND, *PEXPAND;

typedef struct compress_hdr_s
{
    DWORD          Locale;             // locale id
    DWORD          Offset;             // offset to compression nodes
    WORD           Num2;               // number of 2 entries for lang id
    WORD           Num3;               // number of 3 entries for lang id
} COMPRESS_HDR, *PCOMPRESS_HDR;

typedef struct compress_2_node_s
{
    WORD           UCP1;               // unicode code point 1
    WORD           UCP2;               // unicode code point 2
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
    BYTE           Diacritic;          // diacritic weight
    BYTE           Case;               // case weight
} COMPRESS_2_NODE, *PCOMPRESS_2_NODE;

typedef struct compress_3_node_s
{
    WORD           UCP1;               // unicode code point 1
    WORD           UCP2;               // unicode code point 2
    WORD           UCP3;               // unicode code point 3
    WORD           Reserved;           // dword alignment of structure
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
    BYTE           Diacritic;          // diacritic weight
    BYTE           Case;               // case weight
} COMPRESS_3_NODE, *PCOMPRESS_3_NODE;

typedef PCOMPRESS_2_NODE *PCOMPRESS_2_TBL; // ptr to array of compression 2 nodes
typedef PCOMPRESS_3_NODE *PCOMPRESS_3_TBL; // ptr to array of compression 3 nodes

#define NUM_COMPRESS_2_WORDS      (sizeof(COMPRESS_2_NODE) / sizeof(WORD))
#define NUM_COMPRESS_3_WORDS      (sizeof(COMPRESS_3_NODE) / sizeof(WORD))

typedef struct except_hdr_s
{
    DWORD          Locale;             // locale id
    DWORD          Offset;             // offset to exception nodes
    DWORD          NumEntries;         // number of entries for locale id
} EXCEPT_HDR, *PEXCEPT_HDR;

typedef struct except_node_s
{
    WORD           UCP;                // unicode code point
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
    BYTE           Diacritic;          // diacritic weight
    BYTE           Case;               // case weight
} EXCEPT_NODE, *PEXCEPT_NODE;

typedef PEXCEPT_NODE *PEXCEPT_TBL;       // ptr to array of exception nodes

#define NUM_EXCEPT_WORDS          (sizeof(EXCEPT_NODE) / sizeof(WORD))

typedef struct multi_wt_s
{
    BYTE           FirstSM;            // value of first script member
    BYTE           NumSM;              // number of script members in range
} MULTI_WT, *PMULTI_WT;

// Jamo Sequence Sorting Info:
typedef struct {
    BYTE IsOldHangul;                        // Sequence occurs only in old Hangul flag
    BYTE LeadingIndex;              // Indices used to locate the prior modern Hangul syllable
    BYTE VowelIndex;
    BYTE TrailingIndex;
    BYTE ExtraWeight;              // Extra weights that distinguish this from other old Hangul syllables,
                                       // depending on the jamo, this can be a weight for leading jamo,
                                       // vowel jamo, or trailing jamo.
} JAMO_SORT_INFO, *PJAMO_SORT_INFO;

// Jamo Index Table Entry:
typedef struct {
    JAMO_SORT_INFO SortInfo;               // Sequence sorting info
    BYTE Index;                     // Index into the composition array.
    BYTE TransitionCount;            // Number of possible transitions from this state
    BYTE Reserved;                  // Reserved byte.  To make this structure aligned with WORD.
} JAMO_TABLE, *PJAMO_TABLE;

// Jamo Composition Table Entry:
typedef struct {
    WCHAR CodePoint;                // Code point value that enters this state
    JAMO_SORT_INFO SortInfo;               // Sequence sorting info
    BYTE TransitionCount;            // Number of possible transitions from this state
} JAMO_COMPOSE_STATE, *PJAMO_COMPOSE_STATE;

typedef struct sort_tables_s
{
    int             NumReverseDW;      // number of REVERSE DIACRITICS
    int             NumDblCompression; // number of DOUBLE COMPRESSION locales
    int             NumIdeographLcid;  // number of IDEOGRAPH LCIDs
    int             NumExpansion;      // number of EXPANSIONS
    int             NumException;      // number of EXCEPTION locales
    int             NumCompression;    // number of COMPRESSION locales
    int             NumMultiWeight;    // number of MULTIPLE WEIGHTS
    int             NumJamoIndex;       // number of Jamo Index table
    int             NumJamoComposition; // number of Jamo Composition table
    PREV_DW         pReverseDW;        // ptr to REVERSE DIACRITICS info
    PDBL_COMPRESS   pDblCompression;   // ptr to DOUBLE COMPRESSION info
    PIDEOGRAPH_LCID pIdeographLcid;    // ptr to ideograph lcid table
    PEXPAND         pExpansion;        // ptr to EXPANSION info
    PEXCEPT_HDR     pExceptHdr;        // ptr to exception header
    PEXCEPT_TBL     pExceptTbl;        // ptr to exception table
    PCOMPRESS_HDR   pCompressHdr;      // ptr to compression header
    PCOMPRESS_2_TBL pCompress2Tbl;     // ptr to compression 2 table
    PCOMPRESS_3_TBL pCompress3Tbl;     // ptr to compression 3 table
    PMULTI_WT       pMultiWeight;      // ptr to MULTIPLE WEIGHTS info
    PJAMO_TABLE     pJamoIndexTbl;      // ptr to Jamo Index table
    PJAMO_COMPOSE_STATE           pJamoComposeTbl;     // ptr to Jamo Composition table
    DWORD           WriteFlags;        // tables to write
} SORT_TABLES, *PSORT_TABLES;


typedef struct ideograph_node_s
{
    WORD           UCP;                // unicode code point
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
} IDEOGRAPH_NODE, *PIDEOGRAPH_NODE;

typedef struct ideograph_node_ex_s
{
    WORD           UCP;                // unicode code point
    BYTE           Alpha;              // alphanumeric weight
    BYTE           Script;             // script member
    BYTE           Diacritic;          // diacritic weight
    BYTE           Case;               // case weight
} IDEOGRAPH_NODE_EX, *PIDEOGRAPH_NODE_EX;

typedef struct ideograph_except_s
{
    DWORD              NumEntries;        // number of entries
    DWORD              NumColumns;        // number of columns in table
    BYTE               pFileName[14];     // ptr to file name - ANSI
    PIDEOGRAPH_NODE    pExcept;           // ptr to except nodes
    PIDEOGRAPH_NODE_EX pExceptEx;         // ptr to except nodes ex
} IDEOGRAPH_EXCEPT, *PIDEOGRAPH_EXCEPT;


typedef struct loc_cal_hdr_s
{
    DWORD  NumLocales;                 // number of locales
    DWORD  NumCalendars;               // number of calendars
    DWORD  CalOffset;                  // offset to calendar info (words)
} LOC_CAL_HDR, *PLOC_CAL_HDR;

#define LOC_NUM_CAL_WORDS    2         // number of words to NumCalendars

#define LOC_CAL_HDR_WORDS         (sizeof(LOC_CAL_HDR) / sizeof(WORD))



////////////////////////////////////////
//
//  LOCALE File Structures.
//
////////////////////////////////////////

typedef struct locale_hdr_s
{
    DWORD  Locale;                     // locale id
    DWORD  Offset;                     // offset to locale info (words)
} LOCALE_HDR, *PLOCALE_HDR;

#define LOCALE_HDR_WORDS          (sizeof(LOCALE_HDR) / sizeof(WORD))

typedef struct locale_header_s
{
    WORD   SLanguage;                  // language name in English
    WORD   SAbbrevLang;                // abbreviated language name
    WORD   SAbbrevLangISO;             // ISO abbreviated language name
    WORD   SNativeLang;                // native language name
    WORD   SCountry;                   // country name in English
    WORD   SAbbrevCtry;                // abbreviated country name
    WORD   SAbbrevCtryISO;             // ISO abbreviated country name
    WORD   SNativeCtry;                // native country name
    WORD   SList;                      // list separator
    WORD   SDecimal;                   // decimal separator
    WORD   SThousand;                  // thousands separator
    WORD   SGrouping;                  // grouping of digits
    WORD   SNativeDigits;              // native digits 0-9
    WORD   SCurrency;                  // local monetary symbol
    WORD   SIntlSymbol;                // international monetary symbol
    WORD   SEngCurrName;               // currency name in English
    WORD   SNativeCurrName;            // native currency name
    WORD   SMonDecSep;                 // monetary decimal separator
    WORD   SMonThousSep;               // monetary thousands separator
    WORD   SMonGrouping;               // monetary grouping of digits
    WORD   SPositiveSign;              // positive sign
    WORD   SNegativeSign;              // negative sign
    WORD   STimeFormat;                // time format
    WORD   STime;                      // time separator
    WORD   S1159;                      // AM designator
    WORD   S2359;                      // PM designator
    WORD   SShortDate;                 // short date format
    WORD   SDate;                      // date separator
    WORD   SYearMonth;                 // year month format
    WORD   SLongDate;                  // long date format
    WORD   IOptionalCalendar;          // additional calendar type(s)
    WORD   SDayName1;                  // day name 1
    WORD   SDayName2;                  // day name 2
    WORD   SDayName3;                  // day name 3
    WORD   SDayName4;                  // day name 4
    WORD   SDayName5;                  // day name 5
    WORD   SDayName6;                  // day name 6
    WORD   SDayName7;                  // day name 7
    WORD   SAbbrevDayName1;            // abbreviated day name 1
    WORD   SAbbrevDayName2;            // abbreviated day name 2
    WORD   SAbbrevDayName3;            // abbreviated day name 3
    WORD   SAbbrevDayName4;            // abbreviated day name 4
    WORD   SAbbrevDayName5;            // abbreviated day name 5
    WORD   SAbbrevDayName6;            // abbreviated day name 6
    WORD   SAbbrevDayName7;            // abbreviated day name 7
    WORD   SMonthName1;                // month name 1
    WORD   SMonthName2;                // month name 2
    WORD   SMonthName3;                // month name 3
    WORD   SMonthName4;                // month name 4
    WORD   SMonthName5;                // month name 5
    WORD   SMonthName6;                // month name 6
    WORD   SMonthName7;                // month name 7
    WORD   SMonthName8;                // month name 8
    WORD   SMonthName9;                // month name 9
    WORD   SMonthName10;               // month name 10
    WORD   SMonthName11;               // month name 11
    WORD   SMonthName12;               // month name 12
    WORD   SMonthName13;               // month name 13
    WORD   SAbbrevMonthName1;          // abbreviated month name 1
    WORD   SAbbrevMonthName2;          // abbreviated month name 2
    WORD   SAbbrevMonthName3;          // abbreviated month name 3
    WORD   SAbbrevMonthName4;          // abbreviated month name 4
    WORD   SAbbrevMonthName5;          // abbreviated month name 5
    WORD   SAbbrevMonthName6;          // abbreviated month name 6
    WORD   SAbbrevMonthName7;          // abbreviated month name 7
    WORD   SAbbrevMonthName8;          // abbreviated month name 8
    WORD   SAbbrevMonthName9;          // abbreviated month name 9
    WORD   SAbbrevMonthName10;         // abbreviated month name 10
    WORD   SAbbrevMonthName11;         // abbreviated month name 11
    WORD   SAbbrevMonthName12;         // abbreviated month name 12
    WORD   SAbbrevMonthName13;         // abbreviated month name 13
    WORD   SEndOfLocale;               // end of the locale info
} LOCALE_HEADER, *PLOCALE_HEADER;

typedef struct locale_static_s
{
    WORD   DefaultACP;                 // default ACP - integer format
    WORD   szILanguage[5];             // language id
    WORD   szICountry[6];              // country id
    WORD   szIGeoId[8];               // Geographical Location Identifier
    WORD   szIDefaultLang[5];          // default language ID
    WORD   szIDefaultCtry[6];          // default country ID
    WORD   szIDefaultACP[6];           // default ansi code page ID
    WORD   szIDefaultOCP[6];           // default oem code page ID
    WORD   szIDefaultMACCP[6];         // default mac code page ID
    WORD   szIDefaultEBCDICCP[6];      // default ebcdic code page ID
    WORD   szIMeasure[2];              // system of measurement
    WORD   szIPaperSize[2];            // default paper size
    WORD   szIDigits[3];               // number of fractional digits
    WORD   szILZero[2];                // leading zeros for decimal
    WORD   szINegNumber[2];            // negative number format
    WORD   szIDigitSubstitution[2];    // digit substitution
    WORD   szICurrDigits[3];           // # local monetary fractional digits
    WORD   szIIntlCurrDigits[3];       // # intl monetary fractional digits
    WORD   szICurrency[2];             // positive currency format
    WORD   szINegCurr[3];              // negative currency format
    WORD   szIPosSignPosn[2];          // format of positive sign
    WORD   szIPosSymPrecedes[2];       // if mon symbol precedes positive
    WORD   szIPosSepBySpace[2];        // if mon symbol separated by space
    WORD   szINegSignPosn[2];          // format of negative sign
    WORD   szINegSymPrecedes[2];       // if mon symbol precedes negative
    WORD   szINegSepBySpace[2];        // if mon symbol separated by space
    WORD   szITime[2];                 // time format
    WORD   szITLZero[2];               // leading zeros for time field
    WORD   szITimeMarkPosn[2];         // time marker position
    WORD   szIDate[2];                 // short date order
    WORD   szICentury[2];              // century format (short date)
    WORD   szIDayLZero[2];             // leading zeros for day field (short date)
    WORD   szIMonLZero[2];             // leading zeros for month field (short date)
    WORD   szILDate[2];                // long date order
    WORD   szICalendarType[3];         // type of calendar to use
    WORD   szIFirstDayOfWeek[2];       // which day is first in week
    WORD   szIFirstWeekOfYear[2];      // which week is first in year
    WORD   szFontSignature[MAX_FONTSIGNATURE];  // font signature
} LOCALE_STATIC, *PLOCALE_STATIC;

typedef struct locale_variable_s
{
    WORD   szSLanguage[MAX];           // language name in English
    WORD   szSAbbrevLang[MAX];         // abbreviated language name
    WORD   szSAbbrevLangISO[MAX];      // ISO abbreviated language name
    WORD   szSNativeLang[MAX];         // native language name
    WORD   szSCountry[MAX];            // country name in English
    WORD   szSAbbrevCtry[MAX];         // abbreviated country name
    WORD   szSAbbrevCtryISO[MAX];      // ISO abbreviated country name
    WORD   szSNativeCtry[MAX];         // native country name
    WORD   szSList[MAX];               // list separator
    WORD   szSDecimal[MAX];            // decimal separator
    WORD   szSThousand[MAX];           // thousands separator
    WORD   szSGrouping[MAX];           // grouping of digits
    WORD   szSNativeDigits[MAX];       // native digits 0-9
    WORD   szSCurrency[MAX];           // local monetary symbol
    WORD   szSIntlSymbol[MAX];         // international monetary symbol
    WORD   szSEngCurrName[MAX];        // currency name in English
    WORD   szSNativeCurrName[MAX];     // native currency name
    WORD   szSMonDecSep[MAX];          // monetary decimal separator
    WORD   szSMonThousSep[MAX];        // monetary thousands separator
    WORD   szSMonGrouping[MAX];        // monetary grouping of digits
    WORD   szSPositiveSign[MAX];       // positive sign
    WORD   szSNegativeSign[MAX];       // negative sign
    WORD   szSTimeFormat[MAX];         // time format
    WORD   szSTime[MAX];               // time separator
    WORD   szS1159[MAX];               // AM designator
    WORD   szS2359[MAX];               // PM designator
    WORD   szSShortDate[MAX];          // short date format
    WORD   szSDate[MAX];               // short date separator
    WORD   szSYearMonth[MAX];          // year month format
    WORD   szSLongDate[MAX];           // long date format
    WORD   szIOptionalCalendar[MAX];   // additional calendar type(s)
    WORD   szSDayName1[MAX];           // day name 1
    WORD   szSDayName2[MAX];           // day name 2
    WORD   szSDayName3[MAX];           // day name 3
    WORD   szSDayName4[MAX];           // day name 4
    WORD   szSDayName5[MAX];           // day name 5
    WORD   szSDayName6[MAX];           // day name 6
    WORD   szSDayName7[MAX];           // day name 7
    WORD   szSAbbrevDayName1[MAX];     // abbreviated day name 1
    WORD   szSAbbrevDayName2[MAX];     // abbreviated day name 2
    WORD   szSAbbrevDayName3[MAX];     // abbreviated day name 3
    WORD   szSAbbrevDayName4[MAX];     // abbreviated day name 4
    WORD   szSAbbrevDayName5[MAX];     // abbreviated day name 5
    WORD   szSAbbrevDayName6[MAX];     // abbreviated day name 6
    WORD   szSAbbrevDayName7[MAX];     // abbreviated day name 7
    WORD   szSMonthName1[MAX];         // month name 1
    WORD   szSMonthName2[MAX];         // month name 2
    WORD   szSMonthName3[MAX];         // month name 3
    WORD   szSMonthName4[MAX];         // month name 4
    WORD   szSMonthName5[MAX];         // month name 5
    WORD   szSMonthName6[MAX];         // month name 6
    WORD   szSMonthName7[MAX];         // month name 7
    WORD   szSMonthName8[MAX];         // month name 8
    WORD   szSMonthName9[MAX];         // month name 9
    WORD   szSMonthName10[MAX];        // month name 10
    WORD   szSMonthName11[MAX];        // month name 11
    WORD   szSMonthName12[MAX];        // month name 12
    WORD   szSMonthName13[MAX];        // month name 13
    WORD   szSAbbrevMonthName1[MAX];   // abbreviated month name 1
    WORD   szSAbbrevMonthName2[MAX];   // abbreviated month name 2
    WORD   szSAbbrevMonthName3[MAX];   // abbreviated month name 3
    WORD   szSAbbrevMonthName4[MAX];   // abbreviated month name 4
    WORD   szSAbbrevMonthName5[MAX];   // abbreviated month name 5
    WORD   szSAbbrevMonthName6[MAX];   // abbreviated month name 6
    WORD   szSAbbrevMonthName7[MAX];   // abbreviated month name 7
    WORD   szSAbbrevMonthName8[MAX];   // abbreviated month name 8
    WORD   szSAbbrevMonthName9[MAX];   // abbreviated month name 9
    WORD   szSAbbrevMonthName10[MAX];  // abbreviated month name 10
    WORD   szSAbbrevMonthName11[MAX];  // abbreviated month name 11
    WORD   szSAbbrevMonthName12[MAX];  // abbreviated month name 12
    WORD   szSAbbrevMonthName13[MAX];  // abbreviated month name 13
} LOCALE_VARIABLE, *PLOCALE_VARIABLE;


typedef struct calendar_hdr_s
{
    WORD  Calendar;                    // calendar id
    WORD  Offset;                      // offset to calendar info (words)
} CALENDAR_HDR, *PCALENDAR_HDR;

#define CALENDAR_HDR_WORDS        (sizeof(CALENDAR_HDR) / sizeof(WORD))


typedef struct calendar_header_s
{
    WORD   NumRanges;                  // number of era ranges
    WORD   IfNames;                    // if any day or month names exist
    WORD   SCalendar;                  // calendar id
    WORD   STwoDigitYearMax;           // two digit year max
    WORD   SEraRanges;                 // era ranges
    WORD   SShortDate;                 // short date format
    WORD   SYearMonth;                 // year month format
    WORD   SLongDate;                  // long date format
    WORD   SDayName1;                  // day name 1
    WORD   SDayName2;                  // day name 2
    WORD   SDayName3;                  // day name 3
    WORD   SDayName4;                  // day name 4
    WORD   SDayName5;                  // day name 5
    WORD   SDayName6;                  // day name 6
    WORD   SDayName7;                  // day name 7
    WORD   SAbbrevDayName1;            // abbreviated day name 1
    WORD   SAbbrevDayName2;            // abbreviated day name 2
    WORD   SAbbrevDayName3;            // abbreviated day name 3
    WORD   SAbbrevDayName4;            // abbreviated day name 4
    WORD   SAbbrevDayName5;            // abbreviated day name 5
    WORD   SAbbrevDayName6;            // abbreviated day name 6
    WORD   SAbbrevDayName7;            // abbreviated day name 7
    WORD   SMonthName1;                // month name 1
    WORD   SMonthName2;                // month name 2
    WORD   SMonthName3;                // month name 3
    WORD   SMonthName4;                // month name 4
    WORD   SMonthName5;                // month name 5
    WORD   SMonthName6;                // month name 6
    WORD   SMonthName7;                // month name 7
    WORD   SMonthName8;                // month name 8
    WORD   SMonthName9;                // month name 9
    WORD   SMonthName10;               // month name 10
    WORD   SMonthName11;               // month name 11
    WORD   SMonthName12;               // month name 12
    WORD   SMonthName13;               // month name 13
    WORD   SAbbrevMonthName1;          // abbreviated month name 1
    WORD   SAbbrevMonthName2;          // abbreviated month name 2
    WORD   SAbbrevMonthName3;          // abbreviated month name 3
    WORD   SAbbrevMonthName4;          // abbreviated month name 4
    WORD   SAbbrevMonthName5;          // abbreviated month name 5
    WORD   SAbbrevMonthName6;          // abbreviated month name 6
    WORD   SAbbrevMonthName7;          // abbreviated month name 7
    WORD   SAbbrevMonthName8;          // abbreviated month name 8
    WORD   SAbbrevMonthName9;          // abbreviated month name 9
    WORD   SAbbrevMonthName10;         // abbreviated month name 10
    WORD   SAbbrevMonthName11;         // abbreviated month name 11
    WORD   SAbbrevMonthName12;         // abbreviated month name 12
    WORD   SAbbrevMonthName13;         // abbreviated month name 13
    WORD   SEndOfCalendar;             // end of the calendar info
} CALENDAR_HEADER, *PCALENDAR_HEADER;


// size of the name header portion
#define CAL_NAME_HDR_SIZE   ((sizeof(CALENDAR_HEADER) -                     \
                              FIELD_OFFSET(CALENDAR_HEADER, SDayName2)) /   \
                              sizeof(WORD))


typedef struct calendar_variable_s
{
    WORD   szSCalendar[MAX];           // calendar id
    WORD   szSTwoDigitYearMax[MAX];    // two digit year max
    WORD   szSEraRanges[MAX];          // era ranges
    WORD   szSShortDate[MAX];          // short date format
    WORD   szSYearMonth[MAX];          // year month format
    WORD   szSLongDate[MAX];           // long date format
    WORD   szSDayName1[MAX];           // day name 1
    WORD   szSDayName2[MAX];           // day name 2
    WORD   szSDayName3[MAX];           // day name 3
    WORD   szSDayName4[MAX];           // day name 4
    WORD   szSDayName5[MAX];           // day name 5
    WORD   szSDayName6[MAX];           // day name 6
    WORD   szSDayName7[MAX];           // day name 7
    WORD   szSAbbrevDayName1[MAX];     // abbreviated day name 1
    WORD   szSAbbrevDayName2[MAX];     // abbreviated day name 2
    WORD   szSAbbrevDayName3[MAX];     // abbreviated day name 3
    WORD   szSAbbrevDayName4[MAX];     // abbreviated day name 4
    WORD   szSAbbrevDayName5[MAX];     // abbreviated day name 5
    WORD   szSAbbrevDayName6[MAX];     // abbreviated day name 6
    WORD   szSAbbrevDayName7[MAX];     // abbreviated day name 7
    WORD   szSMonthName1[MAX];         // month name 1
    WORD   szSMonthName2[MAX];         // month name 2
    WORD   szSMonthName3[MAX];         // month name 3
    WORD   szSMonthName4[MAX];         // month name 4
    WORD   szSMonthName5[MAX];         // month name 5
    WORD   szSMonthName6[MAX];         // month name 6
    WORD   szSMonthName7[MAX];         // month name 7
    WORD   szSMonthName8[MAX];         // month name 8
    WORD   szSMonthName9[MAX];         // month name 9
    WORD   szSMonthName10[MAX];        // month name 10
    WORD   szSMonthName11[MAX];        // month name 11
    WORD   szSMonthName12[MAX];        // month name 12
    WORD   szSMonthName13[MAX];        // month name 13
    WORD   szSAbbrevMonthName1[MAX];   // abbreviated month name 1
    WORD   szSAbbrevMonthName2[MAX];   // abbreviated month name 2
    WORD   szSAbbrevMonthName3[MAX];   // abbreviated month name 3
    WORD   szSAbbrevMonthName4[MAX];   // abbreviated month name 4
    WORD   szSAbbrevMonthName5[MAX];   // abbreviated month name 5
    WORD   szSAbbrevMonthName6[MAX];   // abbreviated month name 6
    WORD   szSAbbrevMonthName7[MAX];   // abbreviated month name 7
    WORD   szSAbbrevMonthName8[MAX];   // abbreviated month name 8
    WORD   szSAbbrevMonthName9[MAX];   // abbreviated month name 9
    WORD   szSAbbrevMonthName10[MAX];  // abbreviated month name 10
    WORD   szSAbbrevMonthName11[MAX];  // abbreviated month name 11
    WORD   szSAbbrevMonthName12[MAX];  // abbreviated month name 12
    WORD   szSAbbrevMonthName13[MAX];  // abbreviated month name 13
} CALENDAR_VARIABLE, *PCALENDAR_VARIABLE;



////////////////////////////////////////
//
//  GEO File Structures.
//
////////////////////////////////////////

typedef struct tagGeoData{
    long        GeoId;
    WCHAR       szLatitude[MAX_LATITUDE];
    WCHAR       szLongitude[MAX_LONGITUDE];
    DWORD       GeoClass;
    long        ParentGeoId;
    WCHAR       szISO3166Abbrev2[MAX_ISO_ABBREV];
    WCHAR       szISO3166Abbrev3[MAX_ISO_ABBREV];
    WORD        wISO3166;
    WORD        Reserved;                   // dword alignment
} GEODATA, *PGEODATA;

typedef struct tagGEOIDLCID{
    LCID    lcid;
    long    GeoId;
    WORD    LangId;
    WORD    Reserved;                       // dword alignment
} GEOLCID, *PGEOLCID;

typedef struct tagGeoTableHdr{
    WCHAR           szSig[MAX_SIGNATURE];
    unsigned long   nFileSize;
    DWORD           dwOffsetGeoInfo;
    unsigned long   nGeoInfo;
    DWORD           dwOffsetGeoLCID;
    unsigned long   nGeoLCID;
} GEOTABLEHDR;





////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

//
//  Macro to make a DWORD from two WORDS.
//
#define MAKE_DWORD(a, b)     ((long)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))

//
//  Macros For High and Low Nibbles of a BYTE.
//
#define LONIBBLE(b)               ((BYTE)((BYTE)(b) & 0xF))
#define HINIBBLE(b)               ((BYTE)(((BYTE)(b) >> 4) & 0xF))

//
//  Macros for Extracting the 8:4:4 Index Values.
//
#define GET8(w)                   (HIBYTE(w))
#define GETHI4(w)                 (HINIBBLE(LOBYTE(w)))
#define GETLO4(w)                 (LONIBBLE(LOBYTE(w)))


//
//  Macro for getting the case weight and compression value byte.
//
#define MAKE_CASE_WT(cw, comp)    ((BYTE)(((BYTE)(comp) << 6) | ((BYTE)(cw))))




////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes.
//
////////////////////////////////////////////////////////////////////////////

//
//  CodePage Routines.
//
int
ParseCodePage(
    PCODEPAGE pCP,
    PSZ pszKeyWord);

int
WriteCodePage(
    PCODEPAGE pCP);


//
//  Language Routines.
//
int
ParseLanguage(
    PLANGUAGE pLang,
    PSZ pszKeyWord);

int
WriteLanguage(
    PLANGUAGE pLang);

int
ParseLangException(
    PLANG_EXCEPT pLangExcept,
    PSZ pszKeyWord);

int
WriteLangException(
    PLANG_EXCEPT pLangExcept);


//
//  Locale Routines.
//
int
ParseWriteLocale(
    PLOCALE_HEADER pLocHdr,
    PLOCALE_STATIC pLocStat,
    PLOCALE_VARIABLE pLocVar,
    PSZ pszKeyWord);


//
//  Locale Independent (Unicode) Routines.
//
int
ParseUnicode(
    PUNICODE pUnic,
    PSZ pszKeyWord);

int
WriteUnicode(
    PUNICODE pUnic);


//
//  GEO Routines.
//
int
ParseWriteGEO(
    PSZ pszKeyWord);


//
//  Character Type Routines.
//
int
ParseCTypes(
    PCTYPES pCType);

int
WriteCTypes(
    PCTYPES pCType);


//
//  Sorting Routines.
//
int
ParseSortkey(
    PSORTKEY pSortkey,
    PSZ pszKeyWord);

int
ParseSortTables(
    PSORT_TABLES pSortTbls,
    PSZ pszKeyWord);

int
ParseIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeographExcept);

int
WriteSortkey(
    PSORTKEY pSortkey, char* SortKeyFileName);

int
WriteSortTables(
    PSORT_TABLES pSortTbls, char* SortTblsFileName);

int
WriteIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeographExcept);


//
//  Allocation and Free Routines.
//
int
AllocateMB(
    PCODEPAGE pCP);

int
AllocateGlyph(
    PCODEPAGE pCP);

int
AllocateTopDBCS(
    PCODEPAGE pCP,
    int Size);

int
AllocateDBCS(
    PCODEPAGE pCP,
    int Low,
    int High,
    int Index);

int
AllocateWCTable(
    PCODEPAGE pCP,
    int Size);

int
Allocate8(
    P844_ARRAY *pArr);

int
Insert844(
    P844_ARRAY pArr,
    WORD WChar,
    DWORD Value,
    int *cbBuf2,
    int *cbBuf3,
    int Size);

int
Insert844Map(
    P844_ARRAY pArr,
    PCT_MAP pMap,
    WORD WChar,
    WORD Value1,
    WORD Value2,
    WORD Value3,
    int *cbBuf2,
    int *cbBuf3);

int
AllocateTemp844(
    PVOID *ppArr,
    int TblSize,
    int Size);

int
AllocateCTMap(
    PCT_MAP *pMap);

int
AllocateGrid(
    PCOMP_GRID *pCompGrid,
    int TblSize);

int
AllocateLangException(
    PLANG_EXCEPT pLangExcept,
    int TblSize);

int
AllocateLangExceptionNodes(
    PLANG_EXCEPT pLangExcept,
    int TblSize,
    int Index);

int
AllocateSortDefault(
    PSORTKEY pSKey);

int
AllocateReverseDW(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateDoubleCompression(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateIdeographLcid(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateExpansion(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateCompression(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateCompression2Nodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index);

int
AllocateCompression3Nodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index);
int
AllocateException(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateExceptionNodes(
    PSORT_TABLES pSTbl,
    int TblSize,
    int Index);

int
AllocateMultipleWeights(
    PSORT_TABLES pSTbl,
    int TblSize);

int
AllocateIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeographExcept,
    int TblSize,
    int NumColumns);

int AllocateJamoTables(
    PSORT_TABLES pSTbl,
    int TblSize);

void
Free844(
    P844_ARRAY pArr);

void
FreeCTMap(
    PCT_MAP pMap);


//
//  Table Routines.
//
int
ComputeMBSize(
    PCODEPAGE pCP);

int
Compute844Size(
    int cbBuf2,
    int cbBuf3,
    int Size);

DWORD
ComputeCTMapSize(
    PCT_MAP pMap);

int
Write844Table(
    FILE *pOutputFile,
    P844_ARRAY pArr,
    int cbBuf2,
    int TblSize,
    int Size);

int
Write844TableMap(
    FILE *pOutputFile,
    P844_ARRAY pArr,
    WORD TblSize);

int
WriteCTMapTable(
    FILE *pOutputFile,
    PCT_MAP pMap,
    WORD MapSize);

int
WriteWords(
    FILE *pOutputFile,
    WORD Value,
    int Num);

int
FileWrite(
    FILE *pOutputFile,
    void *Buffer,
    int Size,
    int Count,
    char *ErrStr);

void
RemoveDuplicate844Levels(
    P844_ARRAY pArr,
    int *pBuf2,
    int *pBuf3,
    int Size);


//
//  Utility Routines.
//
int
GetSize(
    int *pSize);




////////////////////////////////////////////////////////////////////////////
//
//  Global Variables.
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////

extern FILE        *pInputFile;        // pointer to Input File
extern BOOL        Verbose;            // verbose flag
extern WCHAR       FileExtension[];    // The file extension for generated files. It can be ".nls" or ".nlp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\sorting.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    sorting.c

Abstract:

    This file contains functions necessary to parse and write the sorting
    specific tables to a data file.

    External Routines in this file:
      ParseSortkey
      ParseSortTables
      ParseIdeographExceptions
      WriteSortkey
      WriteSortTables
      WriteIdeographExceptions

Revision History:

    11-04-92    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

int
GetDefaultSortkeyTable(
    PSORTKEY pSortkey,
    int Size);

int
GetReverseDWTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetDoubleCompressionTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetIdeographLcidExceptionTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetExpansionTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetCompressionTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetExceptionTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetMultipleWeightsTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
GetIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeograph,
    int Size);

int GetJamoSortTable(
    PSORT_TABLES pSortTbls,
    int Size);

int
WriteDefaultSortkey(
    PSORTKEY pSortkey,
    FILE *pOutputFile);

int
WriteReverseDW(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteDoubleCompression(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteIdeographLcidException(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteExpansion(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteCompressionTable(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteExceptionTable(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteMultipleWeights(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);

int
WriteIdeographExceptionTable(
    PIDEOGRAPH_EXCEPT pIdeograph,
    FILE *pOutputFile);


int
WriteJamoTables(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile);


//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseSortkey
//
//  This routine parses the input file for the sortkey specific tables.
//  This routine is only entered when the SORTKEY keyword is found.
//  The parsing continues until the ENDSORTKEY keyword is found.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseSortkey(
    PSORTKEY pSortkey,
    PSZ pszKeyWord)
{
    int size;                          // size of table to follow


    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "DEFAULT") == 0)
        {
            if (Verbose)
                printf("\n\nFound DEFAULT keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get DEFAULT SORTKEY Table.
            //
            if (GetDefaultSortkeyTable(pSortkey, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for DEFAULT SORTKEY Table.
            //
            pSortkey->WriteFlags |= F_DEFAULT_SORTKEY;
        }

        else if (_stricmp(pszKeyWord, "ENDSORTKEY") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDSORTKEY keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }

        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  If this point is reached, then the ENDSORTKEY keyword was
    //  not found.  Return an error.
    //
    printf("Parse Error: Expecting ENDSORTKEY keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseSortTables
//
//  This routine parses the input file for the "sort tables" specific tables.
//  This routine is only entered when the SORTTABLES keyword is found.
//  The parsing continues until the ENDSORTTABLES keyword is found.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseSortTables(
    PSORT_TABLES pSortTbls,
    PSZ pszKeyWord)
{
    int size;                          // size of table to follow


    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "REVERSEDIACRITICS") == 0)
        {
            if (Verbose)
                printf("\n\nFound REVERSEDIACRITICS keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get REVERSE DIACRITICS Table.
            //
            if (GetReverseDWTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for REVERSE DIACRITICS Table.
            //
            pSortTbls->WriteFlags |= F_REVERSE_DW;
        }

        else if (_stricmp(pszKeyWord, "DOUBLECOMPRESSION") == 0)
        {
            if (Verbose)
                printf("\n\nFound DOUBLECOMPRESSION keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get DOUBLE COMPRESSION Table.
            //
            if (GetDoubleCompressionTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for DOUBLE COMPRESSION Table.
            //
            pSortTbls->WriteFlags |= F_DOUBLE_COMPRESS;
        }

        else if (_stricmp(pszKeyWord, "IDEOGRAPH_LCID_EXCEPTION") == 0)
        {
            if (Verbose)
                printf("\n\nFound IDEOGRAPH_LCID_EXCEPTION keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get EXCEPTION Table.
            //
            if (GetIdeographLcidExceptionTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for EXCEPTION Table.
            //
            pSortTbls->WriteFlags |= F_IDEOGRAPH_LCID;
        }

        else if (_stricmp(pszKeyWord, "EXPANSION") == 0)
        {
            if (Verbose)
                printf("\n\nFound EXPANSION keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get EXPANSION Table.
            //
            if (GetExpansionTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for EXPANSION Table.
            //
            pSortTbls->WriteFlags |= F_EXPANSION;
        }

        else if (_stricmp(pszKeyWord, "COMPRESSION") == 0)
        {
            if (Verbose)
                printf("\n\nFound COMPRESSION keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get COMPRESSION Table.
            //
            if (GetCompressionTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for COMPRESSION Table.
            //
            pSortTbls->WriteFlags |= F_COMPRESSION;
        }

        else if (_stricmp(pszKeyWord, "EXCEPTION") == 0)
        {
            if (Verbose)
                printf("\n\nFound EXCEPTION keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get EXCEPTION Table.
            //
            if (GetExceptionTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for EXCEPTION Table.
            //
            pSortTbls->WriteFlags |= F_EXCEPTION;
        }

        else if (_stricmp(pszKeyWord, "MULTIPLEWEIGHTS") == 0)
        {
            if (Verbose)
                printf("\n\nFound MULTIPLEWEIGHTS keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get MULTIPLE WEIGHTS Table.
            //
            if (GetMultipleWeightsTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for MULTIPLE WEIGHTS Table.
            //
            pSortTbls->WriteFlags |= F_MULTIPLE_WEIGHTS;
        }

        else if (_stricmp(pszKeyWord, "JAMOSORT") == 0)
        {
            if (Verbose)
                printf("\n\nFound JAMOSORT keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get Jamo Sorting Table.
            //
            if (GetJamoSortTable(pSortTbls, size))
            {
                return (1);
            }

            //
            //  Set WriteFlags for COMPRESSION Table.
            //
            pSortTbls->WriteFlags |= F_JAMOSORT;

        }

        else if (_stricmp(pszKeyWord, "ENDSORTTABLES") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDSORTTABLES keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }

        else
        {
            printf("* Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  If this point is reached, then the ENDSORTTABLES keyword was
    //  not found.  Return an error.
    //
    printf("Parse Error: Expecting ENDSORTTABLES keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseIdeographExceptions
//
//  This routine parses the input file for the ideograph exception table.
//  This routine is only entered when the IDEOGRAPH_EXCEPTION keyword is found.
//  The parsing continues until the correct number of entries is read
//  in from the file.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeographExcept)
{
    int size;                          // size of table to follow


    //
    //  Get size parameter.
    //
    if (GetSize(&size))
        return (1);

    //
    //  Get IDEOGRAPH Exceptions.
    //
    if (GetIdeographExceptions(pIdeographExcept, size))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteSortkey
//
//  This routine writes the sortkey specific tables to an output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteSortkey(
    PSORTKEY pSortkey, char* SortKeyFileName)
{
    FILE *pOutputFile;                 // ptr to output file


    //
    //  Make sure all tables are present.
    //
    if (!(pSortkey->WriteFlags & F_DEFAULT_SORTKEY))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             Default Sortkey Table\n");
        return (1);
    }


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(SortKeyFileName, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", SortKeyFileName);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", SortKeyFileName);

    //
    //  Write the DWORD semaphore - set to zero.
    //
    WriteWords(pOutputFile, 0, 2);

    //
    //  Write DEFAULT SORTKEY Table to output file.
    //
    if (WriteDefaultSortkey(pSortkey, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free DEFAULT SORTKEY table structure.
    //
    free(pSortkey->pDefault);

    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", SortKeyFileName);
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteSortTables
//
//  This routine writes the sort tables to an output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteSortTables(
    PSORT_TABLES pSortTbls, char* SortTblsFileName)
{
    FILE *pOutputFile;                 // ptr to output file
    int ctr;                           // loop counter


    //
    //  Make sure all tables are present.
    //
    if (!((pSortTbls->WriteFlags & F_REVERSE_DW) &&
          (pSortTbls->WriteFlags & F_DOUBLE_COMPRESS) &&
          (pSortTbls->WriteFlags & F_EXPANSION) &&
          (pSortTbls->WriteFlags & F_COMPRESSION) &&
          (pSortTbls->WriteFlags & F_EXCEPTION) &&
          (pSortTbls->WriteFlags & F_MULTIPLE_WEIGHTS) &&
          (pSortTbls->WriteFlags & F_JAMOSORT)))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             Reverse DW, Double Compression, Expansion,\n");
        printf("             Compression, Exception, Multiple Weights, and Jamo Sorting.\n");
        return (1);
    }


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(SortTblsFileName, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", SortTblsFileName);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", SortTblsFileName);

    //
    //  Write REVERSE DIACRITIC Table to output file.
    //
    if (WriteReverseDW(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free REVERSE DIACRITIC table structure.
    //
    free(pSortTbls->pReverseDW);


    //
    //  Write DOUBLE COMPRESSION Table to output file.
    //
    if (WriteDoubleCompression(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free DOUBLE COMPRESSION table structure.
    //
    free(pSortTbls->pDblCompression);


    //
    //  Write IDEOGRAPH LCID EXCEPTION Table to output file.
    //
    if (WriteIdeographLcidException(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free IDEOGRAPH LCID EXCEPTION table structure.
    //
    free(pSortTbls->pIdeographLcid);


    //
    //  Write EXPANSION Table to output file.
    //
    if (WriteExpansion(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free EXPANSION table structure.
    //
    free(pSortTbls->pExpansion);


    //
    //  Write COMPRESSION Table to output file.
    //
    if (WriteCompressionTable(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free COMPRESSION table structure.
    //
    for (ctr = 0; ctr < pSortTbls->NumCompression; ctr++)
    {
        if ((pSortTbls->pCompress2Tbl)[ctr])
        {
            free((pSortTbls->pCompress2Tbl)[ctr]);
        }
        if ((pSortTbls->pCompress3Tbl)[ctr])
        {
            free((pSortTbls->pCompress3Tbl)[ctr]);
        }
    }
    free(pSortTbls->pCompress2Tbl);
    free(pSortTbls->pCompress3Tbl);
    free(pSortTbls->pCompressHdr);


    //
    //  Write EXCEPTION Table to output file.
    //
    if (WriteExceptionTable(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free EXCEPTION header and table structures.
    //
    for (ctr = 0; ctr < pSortTbls->NumException; ctr++)
    {
        if ((pSortTbls->pExceptTbl)[ctr])
        {
            free((pSortTbls->pExceptTbl)[ctr]);
        }
    }
    free(pSortTbls->pExceptTbl);
    free(pSortTbls->pExceptHdr);


    //
    //  Write MULTIPLE WEIGHTS Table to output file.
    //
    if (WriteMultipleWeights(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free MULTIPLE WEIGHTS table structure.
    //
    free(pSortTbls->pMultiWeight);

    //
    //  Write MULTIPLE WEIGHTS Table to output file.
    //
    if (WriteJamoTables(pSortTbls, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Jamo tables.
    //
    free(pSortTbls->pJamoIndexTbl);
    free(pSortTbls->pJamoComposeTbl);


    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", SortTblsFileName);
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteIdeographExceptions
//
//  This routine writes the ideograph exception table to the specified
//  output file.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeographExcept)
{
    FILE *pOutputFile;                 // ptr to output file


    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(pIdeographExcept->pFileName, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", pIdeographExcept->pFileName);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", pIdeographExcept->pFileName);

    //
    //  Write Ideograph Exception Table to output file.
    //
    if (WriteIdeographExceptionTable(pIdeographExcept, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Ideograph Exception table structure.
    //
    if (pIdeographExcept->pExcept)
    {
        free(pIdeographExcept->pExcept);
    }
    else if (pIdeographExcept->pExceptEx)
    {
        free(pIdeographExcept->pExceptEx);
    }

    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", pIdeographExcept->pFileName);
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetDefaultSortkeyTable
//
//  This routine gets the default sortkey table from the input file.  It
//  uses the size parameter to know when to stop reading from the file.  If
//  an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetDefaultSortkeyTable(
    PSORTKEY pSortkey,
    int Size)
{
    int UCP;                      // unicode code point
    int SM;                       // script member
    int AW;                       // alphanumeric weight
    int DW;                       // diacritic weight
    int CW;                       // case weight
    int Comp;                     // compression value

    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate default sortkey table - 64K DWORDS.
    //
    if (AllocateSortDefault(pSortkey))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the code point, the script member,
    //  the alphanumeric weight, the diacritic weight, the case weight, and
    //  the compression value from the input file.  Then store each of the
    //  weights in the default sortkey table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in code point, script member, alphanumeric weight,
        //  diacritic weight, case weight, and compression value.
        //
        NumItems = fscanf( pInputFile,
                           "%i %i %i %i %i %i ;%*[^\n]",
                           &UCP,
                           &SM,
                           &AW,
                           &DW,
                           &CW,
                           &Comp );
        if (NumItems != 6)
        {
            printf("Parse Error: Error reading SORTKEY DEFAULT values.\n");
            return (1);
        }

        if (Verbose)
            printf("  UCP = %x\tSM = %d\tAW = %d\tDW = %d\tCW = %d\tComp = %d\n",
                    UCP, SM, AW, DW, CW, Comp);

        //
        //  Store the weights in the default sortkey table.
        //
        ((pSortkey->pDefault)[UCP]).Alpha     = (BYTE)AW;
        ((pSortkey->pDefault)[UCP]).Script    = (BYTE)SM;
        ((pSortkey->pDefault)[UCP]).Diacritic = (BYTE)DW;
        ((pSortkey->pDefault)[UCP]).Case      = (BYTE)MAKE_CASE_WT(CW, Comp);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetReverseDWTable
//
//  This routine gets the reverse diacritic weight table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetReverseDWTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD Locale;                 // locale id
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate reverse diacritic weight table and set size of table
    //  in sorttables structure.
    //
    if (AllocateReverseDW(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the locale id from the input
    //  file and store it in the reverse DW table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in the locale id.
        //
        NumItems = fscanf( pInputFile,
                           "%i ;%*[^\n]",
                           &Locale );
        if (NumItems != 1)
        {
            printf("Parse Error: Error reading REVERSE DIACRITIC values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Locale ID = %lx\n", Locale);

        //
        //  Store the locale id in the reverse DW table.
        //
        (pSortTbls->pReverseDW)[Ctr] = Locale;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDoubleCompressionTable
//
//  This routine gets the double compression table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetDoubleCompressionTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD Locale;                 // locale id
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate double compression table and set size of table
    //  in sorttables structure.
    //
    if (AllocateDoubleCompression(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the locale id from the input
    //  file and store it in the double compression table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in the locale id.
        //
        NumItems = fscanf( pInputFile,
                           "%i ;%*[^\n]",
                           &Locale );
        if (NumItems != 1)
        {
            printf("Parse Error: Error reading DOUBLE COMPRESSION values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Locale ID = %lx\n", Locale);

        //
        //  Store the locale id in the double compression table.
        //
        (pSortTbls->pDblCompression)[Ctr] = Locale;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetIdeographLcidExceptionTable
//
//  This routine gets the ideograph lcid exception table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetIdeographLcidExceptionTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD Locale;                 // locale id
    WORD *pFileName;              // ptr to file name string
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate ideograph lcid exception table and set size of table
    //  in sorttables structure.
    //
    if (AllocateIdeographLcid(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the locale id and the file name
    //  from the input file and store it in the ideograph lcid table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in the locale id and file name.
        //
        pFileName = ((pSortTbls->pIdeographLcid)[Ctr]).pFileName;
        NumItems = fscanf( pInputFile,
                           "%i %8ws ;%*[^\n]",
                           &Locale,
                           pFileName );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading IDEOGRAPH LCID values.\n");
            return (1);
        }

        //
        //  Add the .nls extension to the file name.
        //
        wcscat(pFileName, FileExtension);

        if (Verbose)
            printf("  Locale ID = %lx\tFile Name = %s\n", Locale, pFileName);

        //
        //  Store the locale id in the ideograph lcid table.
        //
        ((pSortTbls->pIdeographLcid)[Ctr]).Locale = Locale;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetExpansionTable
//
//  This routine gets the expansion table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetExpansionTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    int ECP;                      // expansion code point
    int CP1;                      // code point 1
    int CP2;                      // code point 2
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate expansion table and set size of table in
    //  sorttables structure.
    //
    if (AllocateExpansion(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the expansion code point, code
    //  point 1, and code point 2 from the input file.  Store the values
    //  in the expansion table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in the expansion code point, code point 1, and
        //  code point 2.
        //
        NumItems = fscanf( pInputFile,
                           "%i %i %i ;%*[^\n]",
                           &ECP,
                           &CP1,
                           &CP2 );
        if (NumItems != 3)
        {
            printf("Parse Error: Error reading EXPANSION values.\n");
            return (1);
        }

        if (Verbose)
            printf("  ECP = %x\tCP1 = %x\tCP2 = %x\n", ECP, CP1, CP2);

        //
        //  Store code point 1 and code point2 in the Expansion table.
        //  The expansion code point is not stored.
        //
        ((pSortTbls->pExpansion)[Ctr]).CP1 = (WORD)CP1;
        ((pSortTbls->pExpansion)[Ctr]).CP2 = (WORD)CP2;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCompressionTable
//
//  This routine gets the compression table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetCompressionTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD Locale;                 // locale id
    int Num;                      // number of entries for locale id
    int UCP1;                     // compression code point 1
    int UCP2;                     // compression code point 2
    int UCP3;                     // compression code point 3
    int SM;                       // script member
    int AW;                       // alphanumeric weight
    int DW;                       // diacritic weight
    int CW;                       // case weight
    int Offset = 0;               // offset to store
    register int Ctr;             // loop counter
    register int Ctr2;            // loop counter
    register int LcidCtr;         // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate compression header and compression table and set size of
    //  table in sort tables structure.
    //
    if (AllocateCompression(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the LCID keyword and the locale
    //  id. Then, read in either the TWO or THREE keyword and the number
    //  of entries.  Then, for all entries, read in the compression code
    //  points (2 or 3) and all weights associated with the compression.
    //  Store all values in the compression header and the appropriate
    //  compression table.
    //
    Ctr = 0;
    while (Ctr < Size)
    {
        //
        //  Read in the locale id and the number of entries for the
        //  locale id.
        //
        NumItems = fscanf( pInputFile,
                           " LCID %i ;%*[^\n]",
                           &Locale );
        if (NumItems != 1)
        {
            printf("Parse Error: Error reading COMPRESSION LCID values.\n");
            return (1);
        }

        LcidCtr = 0;
        do
        {
            if (Verbose)
                printf("\n  LCID = %lx\n", Locale);

            //
            //  Store the locale id and the offset in the header.
            //
            ((pSortTbls->pCompressHdr)[Ctr + LcidCtr]).Locale = (DWORD)Locale;
            ((pSortTbls->pCompressHdr)[Ctr + LcidCtr]).Offset = (DWORD)Offset;

            LcidCtr++;

        } while (NumItems = fscanf( pInputFile,
                                    " LCID %i ;%*[^\n]",
                                    &Locale ));

        //
        //  Read in the TWO keyword and the number of TWO entries.
        //
        NumItems = fscanf( pInputFile,
                           " TWO %i ;%*[^\n]",
                           &Num );
        if (NumItems != 1)
        {
            printf("Parse Error: Error reading COMPRESSION TWO values.\n");
            return (1);
        }

        if (Verbose)
            printf("\n    TWO Num = %d\n\n", Num);

        //
        //  Store the number of 2 compressions in the header.
        //
        for (Ctr2 = 0; Ctr2 < LcidCtr; Ctr2++)
        {
            ((pSortTbls->pCompressHdr)[Ctr + Ctr2]).Num2 = (WORD)Num;
        }

        //
        //  Allocate compression 2 nodes for current LCID.
        //
        if (AllocateCompression2Nodes(pSortTbls, Num, Ctr))
        {
            return (1);
        }

        //
        //  For each entry, read in the 2 compression code points, the
        //  script member, the alphanumeric weight, the diacritic
        //  weight, the case weight, and the compression value.  Store
        //  the values in the compression 2 table nodes.
        //
        for (Ctr2 = 0; Ctr2 < Num; Ctr2++)
        {
            //
            //  Read in 2 code points, script member, alphanumeric weight,
            //  diacritic weight, and case weight.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i %i %i %i %i ;%*[^\n]",
                               &UCP1,
                               &UCP2,
                               &SM,
                               &AW,
                               &DW,
                               &CW );
            if (NumItems != 6)
            {
                printf("Parse Error: Error reading COMPRESSION TWO values for LCID %lx.\n",
                        Locale);
                return (1);
            }

            if (Verbose)
                printf("      UCP1 = %x\tUCP2 = %x\tSM = %d\tAW = %d\tDW = %d\tCW = %d\n",
                        UCP1, UCP2, SM, AW, DW, CW);

            //
            //  Store the weights in the compression 2 table.
            //
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).UCP1      = (WORD)UCP1;
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).UCP2      = (WORD)UCP2;
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).Alpha     = (BYTE)AW;
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).Script    = (BYTE)SM;
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).Diacritic = (BYTE)DW;
            (((pSortTbls->pCompress2Tbl)[Ctr])[Ctr2]).Case      = (BYTE)MAKE_CASE_WT(CW, 0);
        }

        //
        //  Increment Offset amount by Num times the number of words
        //  in the compression 2 node.
        //
        Offset += (Num * NUM_COMPRESS_2_WORDS);

        //
        //  Read in the THREE keyword and the number of THREE entries.
        //
        NumItems = fscanf( pInputFile,
                           " THREE %i ;%*[^\n]",
                           &Num );
        if (NumItems != 1)
        {
            printf("Parse Error: Error reading COMPRESSION THREE values.\n");
            return (1);
        }

        if (Verbose)
            printf("\n    THREE Num = %d\n\n", Num);

        //
        //  Store the number of 3 compressions in the header.
        //
        for (Ctr2 = 0; Ctr2 < LcidCtr; Ctr2++)
        {
            ((pSortTbls->pCompressHdr)[Ctr + Ctr2]).Num3 = (WORD)Num;
        }

        //
        //  Allocate compression 3 nodes for current LCID.
        //
        if (AllocateCompression3Nodes(pSortTbls, Num, Ctr))
        {
            return (1);
        }

        //
        //  For each entry, read in the 3 compression code points, the
        //  script member, the alphanumeric weight, the diacritic
        //  weight, the case weight, and the compression value.  Store
        //  the values in the compression 3 table nodes.
        //
        for (Ctr2 = 0; Ctr2 < Num; Ctr2++)
        {
            //
            //  Read in 3 code points, script member, alphanumeric weight,
            //  diacritic weight, and case weight.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i %i %i %i %i %i ;%*[^\n]",
                               &UCP1,
                               &UCP2,
                               &UCP3,
                               &SM,
                               &AW,
                               &DW,
                               &CW );
            if (NumItems != 7)
            {
                printf("Parse Error: Error reading COMPRESSION THREE values for LCID %lx.\n",
                        Locale);
                return (1);
            }

            if (Verbose)
                printf("      UCP1 = %x\tUCP2 = %x\tUCP3 = %x\tSM = %d\tAW = %d\tDW = %d\tCW = %d\n",
                        UCP1, UCP2, UCP3, SM, AW, DW, CW);

            //
            //  Store the weights in the compression 3 table.
            //
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).UCP1      = (WORD)UCP1;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).UCP2      = (WORD)UCP2;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).UCP3      = (WORD)UCP3;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).Reserved  = (WORD)0;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).Alpha     = (BYTE)AW;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).Script    = (BYTE)SM;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).Diacritic = (BYTE)DW;
            (((pSortTbls->pCompress3Tbl)[Ctr])[Ctr2]).Case      = (BYTE)MAKE_CASE_WT(CW, 0);
        }

        //
        //  Increment Offset amount by Num times the number of words
        //  in the compression 3 node.
        //
        Offset += (Num * NUM_COMPRESS_3_WORDS);

        Ctr += LcidCtr;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetExceptionTable
//
//  This routine gets the exception table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetExceptionTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD Locale;                 // locale id
    int Num;                      // number of entries for locale id
    int UCP;                      // exception code point
    int SM;                       // script member
    int AW;                       // alphanumeric weight
    int DW;                       // diacritic weight
    int CW;                       // case weight
    int Comp;                     // compression value
    int Offset = 0;               // offset to store
    int Ctr;                      // loop counter
    int Ctr2;                     // loop counter
    int LcidCtr;                  // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate exception header and exception table and set size of
    //  table in sort tables structure.
    //
    if (AllocateException(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the LCID keyword, locale id,
    //  and the number of entries for that locale id.  Then, for all
    //  entries for the locale id, read in the exception code point and
    //  all weights associated with that code point.  Store all values
    //  in the exception header and the exception table.
    //
    Ctr = 0;
    while (Ctr < Size)
    {
        //
        //  Read in the LCID keyword, locale id, and the number of
        //  entries for the locale id.
        //
        NumItems = fscanf( pInputFile,
                           " LCID %i %i ;%*[^\n]",
                           &Locale,
                           &Num );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading EXCEPTION LCID values.\n");
            return (1);
        }

        if (Verbose)
            printf("\n  LCID = %lx\tNumEntries = %d\n\n", Locale, Num);

        //
        //  Store the locale id and the number of entries in the header.
        //
        ((pSortTbls->pExceptHdr)[Ctr]).Locale = (DWORD)Locale;
        ((pSortTbls->pExceptHdr)[Ctr]).Offset = (DWORD)Offset;
        ((pSortTbls->pExceptHdr)[Ctr]).NumEntries = (DWORD)Num;

        //
        //  See if there are any other LCIDs for this exception table.
        //
        LcidCtr = 1;
        while (NumItems = fscanf( pInputFile,
                                  " LCID %i ;%*[^\n]",
                                  &Locale ))
        {
            if (NumItems > 2)
            {
                printf("Parse Error: Error reading secondary EXCEPTION LCID values.\n");
                return (1);
            }

            if (Verbose)
                printf("\n  LCID = %lx\tNumEntries = %d\n\n", Locale, Num);

            //
            //  Store the locale id and the number of entries in the header.
            //
            ((pSortTbls->pExceptHdr)[Ctr + LcidCtr]).Locale = (DWORD)Locale;
            ((pSortTbls->pExceptHdr)[Ctr + LcidCtr]).Offset = (DWORD)Offset;
            ((pSortTbls->pExceptHdr)[Ctr + LcidCtr]).NumEntries = (DWORD)Num;

            LcidCtr++;
        }

        //
        //  Add (Num times number of words in exception node) to Offset
        //  to get the offset of the next LCID entries.
        //
        Offset += (Num * NUM_EXCEPT_WORDS);

        //
        //  Allocate exception nodes for current LCID.
        //
        if (AllocateExceptionNodes(pSortTbls, Num, Ctr))
        {
            return (1);
        }

        //
        //  For each entry for the locale id, read in the exception code
        //  point, the script member, the alphanumeric weight, the diacritic
        //  weight, the case weight, and the compression value.  Store the
        //  values in the exception table nodes.
        //
        for (Ctr2 = 0; Ctr2 < Num; Ctr2++)
        {
            //
            //  Read in code point, script member, alphanumeric weight,
            //  diacritic weight, case weight, and compression value.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i %i %i %i %i ;%*[^\n]",
                               &UCP,
                               &SM,
                               &AW,
                               &DW,
                               &CW,
                               &Comp );
            if (NumItems != 6)
            {
                printf("Parse Error: Error reading EXCEPTION values for LCID %lx.\n",
                        Locale);
                return (1);
            }

            if (Verbose)
                printf("    UCP = %x\tSM = %d\tAW = %d\tDW = %d\tCW = %d\tComp = %d\n",
                        UCP, SM, AW, DW, CW, Comp);

            //
            //  Store the weights in the exception table.
            //
            (((pSortTbls->pExceptTbl)[Ctr])[Ctr2]).UCP       = (WORD)UCP;
            (((pSortTbls->pExceptTbl)[Ctr])[Ctr2]).Alpha     = (BYTE)AW;
            (((pSortTbls->pExceptTbl)[Ctr])[Ctr2]).Script    = (BYTE)SM;
            (((pSortTbls->pExceptTbl)[Ctr])[Ctr2]).Diacritic = (BYTE)DW;
            (((pSortTbls->pExceptTbl)[Ctr])[Ctr2]).Case      = (BYTE)MAKE_CASE_WT(CW, Comp);
        }

        Ctr += LcidCtr;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMultipleWeightsTable
//
//  This routine gets the multiple weights table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetMultipleWeightsTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    int FirstSM;                  // first SM in range
    int NumSM;                    // number of SMs in range
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate multiple weights table and set size of table in
    //  sorttables structure.
    //
    if (AllocateMultipleWeights(pSortTbls, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the first SM in range and the
    //  number of SMs in the range from the input file.  Store the values
    //  in the multiple weights table.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in the first SM in range and the number of SMs in the
        //  range.
        //
        NumItems = fscanf( pInputFile,
                           "%i %i ;%*[^\n]",
                           &FirstSM,
                           &NumSM );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading MULTIPLE WEIGHTS values.\n");
            return (1);
        }

        if (Verbose)
            printf("  FirstSM = %d\tNumSM = %d\n", FirstSM, NumSM);

        //
        //  Store the first SM and the number of SMs in the range
        //  in the Multiple Weights table.
        //
        ((pSortTbls->pMultiWeight)[Ctr]).FirstSM = (BYTE)FirstSM;
        ((pSortTbls->pMultiWeight)[Ctr]).NumSM = (BYTE)NumSM;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetIdeographExceptions
//
//  This routine gets the ideograph exceptions from the input file.  It
//  uses the size parameter to know when to stop reading from the file.  If
//  an error is encountered, a message is printed and an error is returned.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetIdeographExceptions(
    PIDEOGRAPH_EXCEPT pIdeograph,
    int Size)
{
    int NumColumns;               // number of columns in table
    int UCP;                      // unicode code point
    int SM;                       // script member
    int AW;                       // alphanumeric weight
    int DW;                       // diacritic weight
    int CW;                       // case weight
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Get the file name and add the ".nls" extension.
    //  This file should be read in as ANSI, not Unicode.
    //
    //  Also, get the number of columns to be read in.
    //
    NumItems = fscanf( pInputFile,
                       "%i %8s ;%*[^\n]",
                       &NumColumns,
                       pIdeograph->pFileName );
    if (NumItems != 2)
    {
        printf("Parse Error: Error reading IDEOGRAPH FILE NAME string.\n");
        return (1);
    }
    strcat(pIdeograph->pFileName, ".nls");
    pIdeograph->NumColumns = NumColumns;

    if (Verbose)
        printf("  NumColumns = %d\tFileName = %s\n",
                NumColumns, pIdeograph->pFileName);

    //
    //  Allocate default ideograph exceptions table.
    //
    if (AllocateIdeographExceptions(pIdeograph, Size, NumColumns))
    {
        return (1);
    }

    //
    //  For each entry in table, read in the code point, the script member,
    //  and the alphanumeric weight from the input file.  Then store each
    //  of the weights in the ideograph exception table.
    //
    if (NumColumns == 2)
    {
        for (Ctr = 0; Ctr < Size; Ctr++)
        {
            //
            //  Read in code point, script member, and alphanumeric weight.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i %i ;%*[^\n]",
                               &UCP,
                               &SM,
                               &AW );
            if (NumItems != 3)
            {
                printf("Parse Error: Error reading IDEOGRAPH EXCEPTION values.\n");
                return (1);
            }

            if (Verbose)
                printf("  UCP = %x\tSM = %d\tAW = %d\n", UCP, SM, AW);

            //
            //  Store the weights in the ideograph exception table.
            //
            ((pIdeograph->pExcept)[Ctr]).UCP     = (WORD)UCP;
            ((pIdeograph->pExcept)[Ctr]).Alpha   = (BYTE)AW;
            ((pIdeograph->pExcept)[Ctr]).Script  = (BYTE)SM;
        }
    }
    else if (NumColumns == 4)
    {
        for (Ctr = 0; Ctr < Size; Ctr++)
        {
            //
            //  Read in code point, script member, alphanumeric weight,
            //  diacritic weight, and case weight.
            //
            NumItems = fscanf( pInputFile,
                               "%i %i %i %i %i ;%*[^\n]",
                               &UCP,
                               &SM,
                               &AW,
                               &DW,
                               &CW );
            if (NumItems != 5)
            {
                printf("Parse Error: Error reading IDEOGRAPH EXCEPTION values.\n");
                return (1);
            }

            if (Verbose)
                printf("  UCP = %x\tSM = %d\tAW = %d\tDW = %d\tCW = %d\n",
                        UCP, SM, AW, DW, CW);

            //
            //  Store the weights in the ideograph exception table.
            //
            ((pIdeograph->pExceptEx)[Ctr]).UCP       = (WORD)UCP;
            ((pIdeograph->pExceptEx)[Ctr]).Alpha     = (BYTE)AW;
            ((pIdeograph->pExceptEx)[Ctr]).Script    = (BYTE)SM;
            ((pIdeograph->pExceptEx)[Ctr]).Diacritic = (BYTE)DW;
            ((pIdeograph->pExceptEx)[Ctr]).Case      = (BYTE)CW;
        }
    }
    else
    {
        printf("Parse Error: The Number of columns must be either 2 or 4.\n");
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetJamoSortTable
//
//  This routine gets the Jamo sort table from the input file.
//  It uses the size parameter to know when to stop reading from the file.
//  If an error is encountered, a message is printed and an error is returned.
//
//  06-26-2000    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int GetJamoSortTable(
    PSORT_TABLES pSortTbls,
    int Size)
{
    DWORD IndexJamo;                 // Index Jamo code point
    int Num;                      // number of entries for the index Jamo code point

    DWORD Jamo;
    DWORD IsOldHangul;
    DWORD LeadingIndex;
    DWORD VowelIndex;
    DWORD TrailingIndex;
    DWORD ExtraWeight;
    DWORD TransitionCount;


    int JamoTableOffset = 0;               // Jamo Table Offset
    int Offset = 1;               // offset to store
    int Ctr;                      // loop counter
    int Ctr2;                     // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate Jamo table/Jamo Composition table and set size of
    //  table in sort tables structure.
    //
    if (AllocateJamoTables(pSortTbls, Size))
    {
        return (1);
    }


    //
    //  For each entry in table, read in Jamo
    //  and the number of entries for that jamo.  Then, for all
    //  entries for the Jamo, read in the code point and
    //  all SortInfo and transition count with that code point.
    //
    Ctr = 0;
    while (Ctr < Size)
    {
        NumItems = fscanf( pInputFile,
                           "%i %i ;%*[^\n]",
                           &IndexJamo,
                           &Num );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading JAMOSORT Index Jamo values.\n");
            printf("    Total item expected : %d\n", Size);
            printf("    Number of item read: %d\n", Ctr);
            return (1);
        }

        if (Verbose)
            printf("\n  Index Jamo = %lx\tNumEntries = %d\n\n", IndexJamo, Num);

        for (Ctr2 = 0; Ctr2 < Num; Ctr2++)
        {
            NumItems = fscanf( pInputFile,
                               "%i %i %i %i %i %i %i ;%*[^\n]",
                               &Jamo,
                               &IsOldHangul,
                               &LeadingIndex,
                               &VowelIndex,
                               &TrailingIndex,
                               &ExtraWeight,
                               &TransitionCount);
            if (NumItems != 7)
            {
                printf("Parse Error: Error reading JAMOSORT values for Jamo %lx.\n",
                        IndexJamo);
                printf("    Total item expected : %d\n", Size);
                printf("    Number of item read: %d\n", Ctr);
                return (1);
            }

            if (Verbose)
            {
                printf("    Jamo = 0x%04x\tIsOldHangul = 0x%02x\tLeadingIndex = 0x%02x\tVowelIndex = 0x%02x\tTrailingIndex = 0x%02x\tExtraWeight = 0x%02x\tTransitionCount = 0x%02x\n",
                        Jamo, IsOldHangul, LeadingIndex, VowelIndex, TrailingIndex, ExtraWeight, TransitionCount);
            }

            // Check Jamo range (Jamo can be zero for the dummy entry).
            if ((Jamo < FIRST_JAMO || Jamo > LAST_JAMO) && (Jamo != 0))
            {
                printf("Data Error: Invalid Jamo value: 0x%04x.\n", Jamo);
                return (1);
            }
            if (IsOldHangul != 0 && IsOldHangul != 1)
            {
                printf("Data Error: Invalid IsOldHangul value: 0x%04x for Jamo 0x%04x.\n", IsOldHangul, Jamo);
                return (1);
            }
            if (LeadingIndex > 0xff)
            {
                printf("Data Error: Invalid LeadingIndex value: 0x%04x for Jamo 0x%04x.\n", LeadingIndex, Jamo);
                return (1);
            }
            if (VowelIndex > 0xff)
            {
                printf("Data Error: Invalid LeadingIndex value: 0x%04x for Jamo 0x%04x.\n", VowelIndex, Jamo);
                return (1);
            }
            if (TrailingIndex > 0xff)
            {
                printf("Data Error: Invalid LeadingIndex value: 0x%04x for Jamo 0x%04x.\n", TrailingIndex, Jamo);
                return (1);
            }
            if (ExtraWeight > 0xff)
            {
                printf("Data Error: Invalid LeadingIndex value: 0x%04x for Jamo 0x%04x.\n", ExtraWeight, Jamo);
                return (1);
            }
            if (TransitionCount >= (DWORD)Num)
            {
                printf("Data Error: Invalid LeadingIndex value: 0x%04x for Jamo 0x%04x.\n", TransitionCount, Jamo);
                return (1);
            }


            if (Ctr2 == 0)
            {
                //
                //  Store the info in the Jamo Table
                //
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].SortInfo.IsOldHangul     = (BYTE)IsOldHangul;
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].SortInfo.LeadingIndex    = (BYTE)LeadingIndex;
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].SortInfo.VowelIndex = (BYTE)VowelIndex;
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].SortInfo.TrailingIndex      = (BYTE)TrailingIndex;
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].SortInfo.ExtraWeight      = (BYTE)ExtraWeight;
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].Index      = (TransitionCount > 0 ? (BYTE)Offset : 0);
                (pSortTbls->pJamoIndexTbl)[JamoTableOffset].TransitionCount      = (BYTE)TransitionCount;
                JamoTableOffset++;
            }
            else
            {
                //
                //  Store the info in the Jamo Composition Table.
                //
                (pSortTbls->pJamoComposeTbl)[Offset].CodePoint       = (WCHAR)Jamo;
                (pSortTbls->pJamoComposeTbl)[Offset].SortInfo.IsOldHangul     = (BYTE)IsOldHangul;
                (pSortTbls->pJamoComposeTbl)[Offset].SortInfo.LeadingIndex    = (BYTE)LeadingIndex;
                (pSortTbls->pJamoComposeTbl)[Offset].SortInfo.VowelIndex = (BYTE)VowelIndex;
                (pSortTbls->pJamoComposeTbl)[Offset].SortInfo.TrailingIndex      = (BYTE)TrailingIndex;
                (pSortTbls->pJamoComposeTbl)[Offset].SortInfo.ExtraWeight      = (BYTE)ExtraWeight;
                (pSortTbls->pJamoComposeTbl)[Offset].TransitionCount      = (BYTE)TransitionCount;

                Offset++;
            }
            if (Offset > JAMO_INDEX_RANGE)
            {
                printf("Data Error: the index has exceed the designed range.  You have to expand from BYTE to WORD for Jamo Table.");
                return (1);
            }
        }
        Ctr += Num;
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteDefaultSortkey
//
//  This routine writes the DEFAULT SORTKEY information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteDefaultSortkey(
    PSORTKEY pSortkey,
    FILE *pOutputFile)
{
    if (Verbose)
        printf("\nWriting DEFAULT SORTKEY Table...\n");

    //
    //  Write the default table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortkey->pDefault,
                   sizeof(DWORD),
                   SKEY_TBL_SIZE,
                   "Default Sortkey Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteReverseDW
//
//  This routine writes the REVERSE DIACRITIC information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteReverseDW(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting REVERSE DIACRITIC Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumReverseDW;

    //
    //  Write the number of reverse diacritics to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Reverse DW Size" ))
    {
        return (1);
    }

    //
    //  Write the reverse diacritic table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pReverseDW,
                   sizeof(REV_DW),
                   TblSize,
                   "Reverse Diacritics Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteDoubleCompression
//
//  This routine writes the DOUBLE COMPRESSION information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteDoubleCompression(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting DOUBLE COMPRESSION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumDblCompression;

    //
    //  Write the number of double compression to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Double Compression Size" ))
    {
        return (1);
    }

    //
    //  Write the double compression table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pDblCompression,
                   sizeof(DBL_COMPRESS),
                   TblSize,
                   "Double Compression Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteIdeographLcidException
//
//  This routine writes the IDEOGRAPH LCID EXCEPTION information to the
//  output file.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteIdeographLcidException(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting IDEOGRAPH LCID EXCEPTION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumIdeographLcid;

    //
    //  Write the number of ideograph lcids to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Ideograph Lcid Size" ))
    {
        return (1);
    }

    //
    //  Write the ideograph lcid table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pIdeographLcid,
                   sizeof(IDEOGRAPH_LCID),
                   TblSize,
                   "Ideograph Lcid Exception Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteExpansion
//
//  This routine writes the EXPANSION information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteExpansion(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting EXPANSION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumExpansion;

    //
    //  Write the number of expansion ranges to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Expansion Size" ))
    {
        return (1);
    }

    //
    //  Write the expansion table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pExpansion,
                   sizeof(EXPAND),
                   TblSize,
                   "Expansion Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteCompressionTable
//
//  This routine writes the COMPRESSION information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteCompressionTable(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    int Ctr;                      // loop counter
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting COMPRESSION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumCompression;

    //
    //  Write the number of compression locales to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Compression Size" ))
    {
        return (1);
    }

    //
    //  Write the compression header to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pCompressHdr,
                   sizeof(COMPRESS_HDR),
                   TblSize,
                   "Compression Header" ))
    {
        return (1);
    }

    //
    //  Write the compression 2 and compression 3 tables to the output file.
    //
    for (Ctr = 0; Ctr < TblSize; Ctr++)
    {
        //
        //  Write the compression 2 table.
        //
        if ((pSortTbls->pCompress2Tbl)[Ctr])
        {
            if (FileWrite( pOutputFile,
                           (pSortTbls->pCompress2Tbl)[Ctr],
                           sizeof(COMPRESS_2_NODE),
                           ((pSortTbls->pCompressHdr)[Ctr]).Num2,
                           "Compression 2 Table" ))
            {
                return (1);
            }
        }

        //
        //  Write the compression 3 table.
        //
        if ((pSortTbls->pCompress3Tbl)[Ctr])
        {
            if (FileWrite( pOutputFile,
                           (pSortTbls->pCompress3Tbl)[Ctr],
                           sizeof(COMPRESS_3_NODE),
                           ((pSortTbls->pCompressHdr)[Ctr]).Num3,
                           "Compression 3 Table" ))
            {
                return (1);
            }
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteExceptionTable
//
//  This routine writes the EXCEPTION information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteExceptionTable(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    int Ctr;                      // loop counter
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting EXCEPTION Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumException;

    //
    //  Write the number of exception locales to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Exception Size" ))
    {
        return (1);
    }

    //
    //  Write the exception header to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pExceptHdr,
                   sizeof(EXCEPT_HDR),
                   TblSize,
                   "Exception Header" ))
    {
        return (1);
    }

    //
    //  Write the exception table to the output file.
    //
    for (Ctr = 0; Ctr < TblSize; Ctr++)
    {
        if ((pSortTbls->pExceptTbl)[Ctr])
        {
            if (FileWrite( pOutputFile,
                           (pSortTbls->pExceptTbl)[Ctr],
                           sizeof(EXCEPT_NODE),
                           ((pSortTbls->pExceptHdr)[Ctr]).NumEntries,
                           "Exception Table" ))
            {
                return (1);
            }
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteMultiWeights
//
//  This routine writes the MULTIPLE WEIGHTS information to the output file.
//
//  11-04-92    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteMultipleWeights(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting MULTIPLE WEIGHTS Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = pSortTbls->NumMultiWeight;

    //
    //  Write the number of multiple weights ranges to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Multi Weight Size" ))
    {
        return (1);
    }

    //
    //  Write the multiple weights table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pMultiWeight,
                   sizeof(BYTE),
                   TblSize * 2,
                   "Multiple Weights Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteIdeographExceptionTable
//
//  This routine writes the IDEOGRAPH EXCEPTION information to the
//  specified output file.
//
//  09-01-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteIdeographExceptionTable(
    PIDEOGRAPH_EXCEPT pIdeograph,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    int NumColumns;               // number of columns in table
    DWORD dwValue;                // temp storage value


    if (Verbose)
        printf("\nWriting IDEOGRAPH EXCEPTION Table...\n");

    //
    //  Get the size of the table and the number of columns.
    //
    TblSize = pIdeograph->NumEntries;
    NumColumns = pIdeograph->NumColumns;

    //
    //  Write the number of ideograph exceptions to the output file.
    //
    dwValue = (DWORD)TblSize;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Ideograph Exception Size" ))
    {
        return (1);
    }

    //
    //  Write the number of columns of ideograph exceptions to the output
    //  file.
    //
    dwValue = (DWORD)NumColumns;
    if (FileWrite( pOutputFile,
                   &dwValue,
                   sizeof(DWORD),
                   1,
                   "Ideograph Exception Columns" ))
    {
        return (1);
    }

    //
    //  Write the ideograph exceptions table to the output file.
    //
    if (pIdeograph->pExcept)
    {
        if (FileWrite( pOutputFile,
                       pIdeograph->pExcept,
                       sizeof(IDEOGRAPH_NODE),
                       TblSize,
                       "Ideograph Exception Table" ))
        {
            return (1);
        }
    }
    else if (pIdeograph->pExceptEx)
    {
        if (FileWrite( pOutputFile,
                       pIdeograph->pExceptEx,
                       sizeof(IDEOGRAPH_NODE_EX),
                       TblSize,
                       "Ideograph Exception Table" ))
        {
            return (1);
        }
    }
    else
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}

////////////////////////////////////////////////////////////////////////////
//
//  WriteJamoTables
//
//  This routine writes the Jamo Tables information to the output file.
//
//  06-26-2000 YSLin created
////////////////////////////////////////////////////////////////////////////

int WriteJamoTables(
    PSORT_TABLES pSortTbls,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Jamo Table...\n");

    //
    //  Get the size of the table.
    //
    TblSize = JAMO_INDEX_SIZE;

    //
    //  Write the number of Jamo table entires to the output file.
    //
    wValue = (WORD)pSortTbls->NumJamoIndex;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Jamo Size" ))
    {
        return (1);
    }

    //
    //  Write the Jamo table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pJamoIndexTbl,
                   sizeof(JAMO_TABLE),
                   TblSize,
                   "Jamo Table" ))
    {
        return (1);
    }

    //
    //  Write the number of Jamo Composition entires to the output file.
    //
    wValue = (WORD)pSortTbls->NumJamoComposition;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Jamo Composition Size" ))
    {
        return (1);
    }

    //
    //  Write the Jamo Composition table to the output file.
    //
    if (FileWrite( pOutputFile,
                   pSortTbls->pJamoComposeTbl,
                   sizeof(JAMO_COMPOSE_STATE),
                   TblSize,
                   "Jamo Composition Table" ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\gb18030\gb18030regressions.cpp ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    GB18030Regressions.c

Abstract:

    GB18030 (codepage 54936) smoke test and bug regressions.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    02-22-02    YSLin    Created.

--*/

#include <windows.h>
#include <stdio.h>

#define NLS_CP_CPINFO             0x10000000                    
#define NLS_CP_CPINFOEX           0x20000000                    
#define NLS_CP_MBTOWC             0x40000000                    
#define NLS_CP_WCTOMB             0x80000000                    

CHAR g_szBuffer[512];
WCHAR g_wszBuffer[512];

HMODULE g_hLangModule;
WCHAR g_wszDllName[] = L".\\c_g18030.dll";
typedef DWORD (__stdcall *NlsDllCodePageTranslation)(
    DWORD CodePage,
    DWORD dwFlags,
    LPSTR lpMultiByteStr,
    int cchMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar,
    LPCPINFO lpCPInfo);

NlsDllCodePageTranslation g_pGBFunc = NULL;    

void PrintBytes(BYTE* lpMultiByteStr, DWORD size)
{
    for (DWORD i = 0; i < size; i++)
    {
        printf("\\x%02x", lpMultiByteStr[i]);
    }
}

void PrintWords(WORD* lpWideCharStr, int size)
{
    if (size == -1)
    {
        size = wcslen(lpWideCharStr);
    }
    for (int i = 0; i < size; i++)
    {
        printf("\\x%04x", lpWideCharStr[i]);
    }   
}

BOOL TestIsValidCodePage(int codepage)
{
    BOOL bResult = IsValidCodePage(codepage);
    printf("IsValidCodePage(%d) = %d\n", codepage, bResult);
    return (bResult);
}

BOOL VerifyResult(int result, int expect)
{
    printf("    Result: [%d]\n", result);
    if (result != expect)
    {
        printf(">>  Expect: [%d]\n", expect);
        return (FALSE);
    }
    return (TRUE);
}

BOOL VerifyResult(BYTE* result, int nResultLen, BYTE* expect, int nExpectLen)
{
    BOOL bEqual = (nResultLen == nExpectLen);
    if (bEqual)
    {
        for (int i = 0; i < nResultLen; i++)
        {
            if (result[i] != expect[i])
            {
                bEqual = FALSE;
                break;
            }
        }
    }

    printf("    Result: [");
    PrintBytes(result, nResultLen);
    printf("]\n");
    if (!bEqual)
    {
        printf(">>  Expect: [");
        PrintBytes(expect, nExpectLen);
        printf("]\n");
    }

    return (bEqual);
}

BOOL VerifyResult(WORD* result, int nResultLen, WORD* expect, int nExpectLen)
{
    BOOL bEqual = (nResultLen == nExpectLen);
    if (bEqual)
    {
        for (int i = 0; i < nResultLen; i++)
        {
            if (result[i] != expect[i])
            {
                bEqual = FALSE;
                break;
            }
        }
    }

    printf("    Result: [");
    PrintWords(result, nResultLen);
    printf("]\n");
    if (!bEqual)
    {
        printf(">>  Expect: [");
        PrintWords(expect, nExpectLen);
        printf("]\n");
    }

    return (bEqual);
}

BOOL DoGetCPInfoExTest(int codepage)
{
    CPINFOEX cpInfoEx;
    if (!GetCPInfoEx(codepage, 0, &cpInfoEx))
    {
        return (FALSE);
    }

    printf("    MaxCharSize = %d\n", cpInfoEx.MaxCharSize);
    printf("    DefaultChar = [%02x][%02x]\n", cpInfoEx.DefaultChar[0], cpInfoEx.DefaultChar[1]);
    printf("    LeadByte = [%s]\n", cpInfoEx.LeadByte);
    wprintf(L"    UnicodeDefaultChar = %c\n", cpInfoEx.UnicodeDefaultChar);
    printf("    CodePage = %d\n", cpInfoEx.CodePage);
    wprintf(L"    CodePageName = [%s]\n", cpInfoEx.CodePageName);
    return (TRUE);
}

BOOL DoWCToMBTest(
    int codepage, 
    LPWSTR lpWideCharStr, int cchWideChar,
    LPSTR expect, int nExpectLen,
    BOOL bTestRoundtrip)
{
    BOOL bPassed = TRUE;

    int nResult = 0;

    printf("    WideCharToMultiByte(%d, 0, \"", codepage);
    PrintWords(lpWideCharStr, cchWideChar);
    printf("\", %d)\n", cchWideChar);
    if (g_pGBFunc)
    {
        nExpectLen--; 
    }
    
    //
    // First test if the byte count is correct.
    //
    printf("    --- Test byte count ---\n");
    if (g_pGBFunc)
    {
        nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
            NULL, 0, lpWideCharStr, cchWideChar, NULL);
    } else {
        nResult = WideCharToMultiByte(codepage, 0, 
            lpWideCharStr, cchWideChar, NULL, 0, NULL, NULL);
    }            
    bPassed &= VerifyResult(nResult, nExpectLen);

    printf("    --- Test conversion ---\n");
    //
    // Test the actual wide-char to multi-byte conversion is correct.
    //
    BOOL bUseDefault;
    if (g_pGBFunc)
    {
        nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
            g_szBuffer, sizeof(g_szBuffer), lpWideCharStr, cchWideChar, NULL);
    } else {
        nResult = WideCharToMultiByte(codepage, 0, 
            lpWideCharStr, cchWideChar, g_szBuffer, sizeof(g_szBuffer), NULL, NULL);
    }            

    bPassed &= VerifyResult(nResult, nExpectLen);
    bPassed &= VerifyResult((BYTE*)g_szBuffer, nResult, (BYTE*)expect, nExpectLen);

    if (!g_pGBFunc) 
    {
        nResult = WideCharToMultiByte(codepage, 0, 
            lpWideCharStr, cchWideChar, g_szBuffer, nExpectLen, NULL, NULL);
    }
    bPassed &= VerifyResult(nResult, nExpectLen);
    bPassed &= VerifyResult((BYTE*)g_szBuffer, nResult, (BYTE*)expect, nExpectLen);
    
    if (bTestRoundtrip)
    {
        printf("    --- Test roundtrip ---\n");
        if (cchWideChar == -1)
        {
            cchWideChar = wcslen(lpWideCharStr) + 1;
        }
        if (g_pGBFunc)
        {
            nResult = g_pGBFunc(codepage, NLS_CP_MBTOWC, g_szBuffer, nResult, g_wszBuffer, sizeof(g_szBuffer), NULL);
            cchWideChar--;
        } else
        {
            nResult = MultiByteToWideChar(codepage, 0, g_szBuffer, nResult, g_wszBuffer, sizeof(g_szBuffer));
        }            

        bPassed &= VerifyResult(nResult, cchWideChar);
        bPassed &= VerifyResult((WORD*)g_wszBuffer, nResult, (WORD*)lpWideCharStr, cchWideChar);
    }

    printf("    --- Test insuffient buffer ---\n");
    for (int i = nExpectLen - 1; i >= 1; i--)
    {
        if (g_pGBFunc)
        {
            nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
                g_szBuffer, i, lpWideCharStr, cchWideChar, NULL);
        } else {
            nResult = WideCharToMultiByte(codepage, 0, 
                lpWideCharStr, cchWideChar, g_szBuffer, i, NULL, NULL);
        }
        bPassed &= VerifyResult(nResult, 0);
        bPassed &= VerifyResult(GetLastError(), ERROR_INSUFFICIENT_BUFFER);
    }
    
    return (bPassed);
}


BOOL DoMBToWCTest(
    int codepage, 
    LPSTR lpMultiByteStr, int cchMulitByteChar,
    LPWSTR expect, int nExpectLen)
{
    BOOL bPassed = TRUE;

    int nResult = 0;

    printf("    MultiByteToWideChar(%d, 0, \"", codepage);
    PrintBytes((BYTE*)lpMultiByteStr, cchMulitByteChar);
    printf("\", %d)\n", cchMulitByteChar);

    /*
    if (g_pGBFunc)
    {
        nExpectLen--; 
    }
    */
    
    //
    // First test if the byte count is correct.
    //
    printf("    --- Test byte count ---\n");
    //if (g_pGBFunc)
    //{
       // nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
       //     NULL, 0, lpWideCharStr, cchWideChar, NULL);
    //} else 
    {
        nResult = MultiByteToWideChar(codepage, 0, 
            lpMultiByteStr, cchMulitByteChar, NULL, 0);
    }            
    bPassed &= VerifyResult(nResult, nExpectLen);

    printf("    --- Test conversion ---\n");
    //
    // Test the actual wide-char to multi-byte conversion is correct.
    //
    BOOL bUseDefault;
    //if (g_pGBFunc)
    //{
       // nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
           // g_szBuffer, sizeof(g_szBuffer), lpWideCharStr, cchWideChar, NULL);
    //} else 
    {
        nResult = MultiByteToWideChar(codepage, 0, 
            lpMultiByteStr, cchMulitByteChar, g_wszBuffer, sizeof(g_wszBuffer));
    }            

    bPassed &= VerifyResult(nResult, nExpectLen);
    bPassed &= VerifyResult((WORD*)g_wszBuffer, nResult, (WORD*)expect, nExpectLen);

    //if (!g_pGBFunc) 
    {
        nResult = MultiByteToWideChar(codepage, 0, 
            lpMultiByteStr, cchMulitByteChar, g_wszBuffer, nExpectLen);
    }
    bPassed &= VerifyResult(nResult, nExpectLen);
    bPassed &= VerifyResult((WORD*)g_wszBuffer, nResult, (WORD*)expect, nExpectLen);
    
    printf("    --- Test insuffient buffer ---\n");
    for (int i = nExpectLen - 1; i >= 1; i--)
    {
        //if (g_pGBFunc)
        //{
           // nResult = g_pGBFunc(codepage, NLS_CP_WCTOMB, 
                //g_szBuffer, i, lpWideCharStr, cchWideChar, NULL);
        //} else 
        {
            nResult = MultiByteToWideChar(codepage, 0, 
                lpMultiByteStr, cchMulitByteChar, g_wszBuffer, i);
        }
        bPassed &= VerifyResult(nResult, 0);
        bPassed &= VerifyResult(GetLastError(), ERROR_INSUFFICIENT_BUFFER);
    }
    
    return (bPassed);
}

BOOL TryLoadGB18030DLL()
{
    g_hLangModule = ::LoadLibrary(g_wszDllName);

    if (g_hLangModule == NULL)
    {
        wprintf(L"Error in loading %s DLL.", g_wszDllName);
        return (FALSE);
    }

    g_pGBFunc = (NlsDllCodePageTranslation)GetProcAddress(g_hLangModule, "NlsDllCodePageTranslation");

    if (g_pGBFunc == NULL)
    {
        wprintf(L"Error in loading function.\n");
        return (FALSE);
    }
    wprintf(L"%s is loaded.\n", g_wszDllName);
    return (TRUE);
}

BOOL DoSmokeTest()
{
    BOOL bPassed = TRUE;

    printf("\n--- DoSmokeTest---\n");
    //
    // Some general tests.
    //

    
    // U+0000 ~ U+007F
    bPassed &= DoWCToMBTest(54936, L"ABC", -1,                        "ABC\x00", 4, TRUE);
    
    // Unicode to GB18030 two-bytes, compatible with GBK.    
    bPassed &= DoWCToMBTest(54936, L"\x00a4", -1,                     "\xa1\xe8\x00", 3, TRUE);
    bPassed &= DoWCToMBTest(54936, L"\x3011", -1,                     "\xa1\xbf\x00", 3, TRUE);    
    bPassed &= DoWCToMBTest(54936, L"\x3011", -1,                     "\xa1\xbf\x00", 3, TRUE);    

    bPassed &= DoWCToMBTest(54936, L"\x00a4", 1,                     "\xa1\xe8", 2, TRUE);
    
    // Unicode to GB18030 two-bytes, NOT compatible with GBK.    
    bPassed &= DoWCToMBTest(54936, L"\x01f9", -1,                     "\xa8\xbf\x00", 3, TRUE);    
    bPassed &= DoWCToMBTest(54936, L"\x4dae", -1,                     "\xfe\x9f\x00", 3, TRUE);
    bPassed &= DoWCToMBTest(54936, L"\xffe5", -1,                     "\xA3\xA4\x00", 3, TRUE);
    
    // Unicode to GB18030 four-byte.
    bPassed &= DoWCToMBTest(54936, L"\x0081", -1,                     "\x81\x30\x81\x31\x00", 5, TRUE);
    bPassed &= DoWCToMBTest(54936, L"\xfeff", -1,                     "\x84\x31\x95\x33\x00", 5, TRUE);
    bPassed &= DoWCToMBTest(54936, L"\xffff", -1,                     "\x84\x31\xA4\x39\x00", 5, TRUE);

    // Surrogate to GB18030 four-byte
    bPassed &= DoWCToMBTest(54936, L"\xd800\xdc00", -1,               "\x90\x30\x81\x30\x00", 5, TRUE);
    // The last surrogate pair to GB18030 four-byte
    bPassed &= DoWCToMBTest(54936, L"\xdbff\xdfff", -1,               "\xe3\x32\x9a\x35\x00", 5, TRUE);
    
    // Mixed cases.
    bPassed &= DoWCToMBTest(54936, L"\x0081\x00a8", -1,               "\x81\x30\x81\x31\xA1\xA7\x00", 7, TRUE);
    bPassed &= DoWCToMBTest(54936, L"A\x0081\x0042\x0043\x00a8", -1,  "A\x81\x30\x81\x31\x42\x43\xA1\xA7\x00", 10, TRUE);        

    //
    // Some exception cases.
    //

    // High surrogate without low surrogate
    bPassed &= DoWCToMBTest(54936, L"\xd800", -1,                     "?\x00", 2, FALSE);
    // High surrogate without low surrogate
    bPassed &= DoWCToMBTest(54936, L"\xd800\x0041", -1,               "?\x41\x00", 3, FALSE);
    // High surrogate without low surrogate
    bPassed &= DoWCToMBTest(54936, L"\x0042\xd800\x0041", -1,         "\x42?\x41\x00", 4, FALSE);

    // Low surrogate without high surrogate
    bPassed &= DoWCToMBTest(54936, L"\xdc00", -1,                     "?\x00", 2, FALSE);
    // Low surrogate without high surrogate
    bPassed &= DoWCToMBTest(54936, L"\xdc00\xd800", -1,               "??\x00", 3, FALSE);
    // Low surrogate without high surrogate
    bPassed &= DoWCToMBTest(54936, L"A\xdc00", -1,                    "A?\x00", 3, FALSE);
    // Low surrogate without high surrogate
    bPassed &= DoWCToMBTest(54936, L"A\xdc00\x42", -1,                "A?B\x00", 4, FALSE);    

    // 1-byte GB18030
    bPassed &= DoMBToWCTest(54936, "ABC", 3, L"ABC", 3);
    bPassed &= DoMBToWCTest(54936, "\x7d\x7e\x7f", 3, L"\x007d\x007e\x007f", 3);

    // 2-byte GB18030
    bPassed &= DoMBToWCTest(54936, "\xa1\xe3", 2, L"\x00b0", 1);
    bPassed &= DoMBToWCTest(54936, "\xd2\xbb", 2, L"\x4e00", 1);

    // 4-byte GB18030
    bPassed &= DoMBToWCTest(54936, "\x81\x30\x86\x30", 4, L"\x00b8", 1);
    bPassed &= DoMBToWCTest(54936, "\x84\x31\xA4\x39", 4, L"\xffff", 1);
    
    return (bPassed);
}


BOOL Regress352949() {
    BOOL bPassed = true;
    printf("\n--- Bug 352949 ---\n");

    bPassed &= DoWCToMBTest(932, L"\x3000\x0045",  -1, "\x81\x40\x45", 4, FALSE) ;    
    bPassed &= DoWCToMBTest(54936, L"\x3094", -1, "\x81\x39\xA6\x36", 5, FALSE) ;
    
    printf("\n");
    return (bPassed);
}

BOOL Regress401919() {
    BOOL bPassed = true;
    printf("\n--- Bug 401919 ---\n");

    // Invalid 4-byte sequence.

    bPassed &= DoMBToWCTest(54936, "\x81\x30\x81\x20", 4, L"?\x30?\x20", 4);
    bPassed &= DoMBToWCTest(54936, "\x81\x20\x81\x30", 4, L"?\x20?\x30", 4);
    bPassed &= DoMBToWCTest(54936, "\x81\x30\x80\x30", 4, L"?\x30?\x30", 4);
    bPassed &= DoMBToWCTest(54936, "\x81\x30\xff\x30", 4, L"?\x30?\x30", 4);
    bPassed &= DoMBToWCTest(54936, "\xff\x30\x81\x30", 4, L"?\x30?\x30", 4);
    bPassed &= DoMBToWCTest(54936, "\x81\x20", 2, L"?\x20", 2);

    // Invalid 2-byte sequence
    bPassed &= DoMBToWCTest(54936, "\x81\x7f", 2, L"?\x7f", 2);
    bPassed &= DoMBToWCTest(54936, "\xff\x40", 2, L"?\x40", 2);

    // Invalid 1-byte sequence
    bPassed &= DoMBToWCTest(54936, "\x80", 1, L"?", 1);
    bPassed &= DoMBToWCTest(54936, "\xfe", 1, L"?", 1);
    bPassed &= DoMBToWCTest(54936, "\x81", 1, L"?", 1);
    bPassed &= DoMBToWCTest(54936, "\xff", 1, L"?", 1);
    
    return (bPassed);
}

int _cdecl main(int argc, char* argv[])
{
    BOOL bPassed = TRUE;
    if (argc > 2) 
    {
        if (!TryLoadGB18030DLL())
        {
            return(1);
        }
    } else 
    {
        if (!TestIsValidCodePage(54936))
        {
            printf("54936 is not a installed codepage.\n");
            return (1);
        } 
    }
    
    bPassed &= DoGetCPInfoExTest(54936);    
    bPassed &= DoSmokeTest();
    bPassed &= Regress352949();
    bPassed &= Regress401919();
    
    if (!bPassed)
    {
        printf("FAIL");
        return(1);
    }

    if (g_hLangModule != NULL)
    {
        FreeLibrary(g_hLangModule);
    }
    printf("pass");
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\nlstrans\unicode.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    unicode.c

Abstract:

    This file contains functions necessary to parse and write the locale
    independent (Unicode) tables to a data file.

    External Routines in this file:
      ParseUnicode
      WriteUnicode

Revision History:

    12-10-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstrans.h"




//
//  Forward Declarations.
//

int
GetAsciiDigits(
    PUNICODE pUnic,
    int Size);

int
GetFoldCZone(
    PUNICODE pUnic,
    int Size);

int
GetHiragana(
    PUNICODE pUnic,
    int Size);

int
GetKatakana(
    PUNICODE pUnic,
    int Size);

int
GetHalfWidth(
    PUNICODE pUnic,
    int Size);

int
GetFullWidth(
    PUNICODE pUnic,
    int Size);

int
GetTraditional(
    PUNICODE pUnic,
    int Size);

int
GetSimplified(
    PUNICODE pUnic,
    int Size);

int
GetCompTable(
    PUNICODE pUnic,
    int Size);

void
Get844Value(
    P844_ARRAY pArr,
    WORD WChar,
    WORD *Value);

void
InsertCompGrid(
    PCOMP_GRID pCompGrid,
    WORD PreComp,
    WORD BaseOff,
    WORD NonSpOff);

int
WriteAsciiDigits(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteFoldCZone(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteHiragana(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteKatakana(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteHalfWidth(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteFullWidth(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteTraditional(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteSimplified(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WritePrecomposed(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteComposite(
    PUNICODE pUnic,
    FILE *pOutputFile);

int
WriteGrid(
    PUNICODE pUnic,
    FILE *pOutputFile);





//-------------------------------------------------------------------------//
//                            EXTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  ParseUnicode
//
//  This routine parses the input file for the locale independent (Unicode)
//  tables.  This routine is only entered when the UNICODE keyword is found.
//  The parsing continues until the ENDUNICODE keyword is found.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ParseUnicode(
    PUNICODE pUnic,
    PSZ pszKeyWord)
{
    int size;                          // size of table to follow


    while (fscanf(pInputFile, "%s", pszKeyWord) == 1)
    {
        if (_stricmp(pszKeyWord, "ASCIIDIGITS") == 0)
        {
            if (Verbose)
                printf("\n\nFound ASCIIDIGITS keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get ASCIIDIGITS Table.
            //
            if (GetAsciiDigits(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for ASCIIDIGITS Table.
            //
            pUnic->WriteFlags |= F_ADIGIT;
        }

        else if (_stricmp(pszKeyWord, "FOLDCZONE") == 0)
        {
            if (Verbose)
                printf("\n\nFound FOLDCZONE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get FOLDCZONE Table.
            //
            if (GetFoldCZone(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for FOLDCZONE Table.
            //
            pUnic->WriteFlags |= F_CZONE;
        }

        else if (_stricmp(pszKeyWord, "HIRAGANA") == 0)
        {
            if (Verbose)
                printf("\n\nFound HIRAGANA keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get HIRAGANA Table.
            //
            if (GetHiragana(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for HIRAGANA Table.
            //
            pUnic->WriteFlags |= F_HIRAGANA;
        }

        else if (_stricmp(pszKeyWord, "KATAKANA") == 0)
        {
            if (Verbose)
                printf("\n\nFound KATAKANA keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get KATAKANA Table.
            //
            if (GetKatakana(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for KATAKANA Table.
            //
            pUnic->WriteFlags |= F_KATAKANA;
        }

        else if (_stricmp(pszKeyWord, "HALFWIDTH") == 0)
        {
            if (Verbose)
                printf("\n\nFound HALFWIDTH keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get HALFWIDTH Table.
            //
            if (GetHalfWidth(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for HALFWIDTH Table.
            //
            pUnic->WriteFlags |= F_HALFWIDTH;
        }

        else if (_stricmp(pszKeyWord, "FULLWIDTH") == 0)
        {
            if (Verbose)
                printf("\n\nFound FULLWIDTH keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get FULLWIDTH Table.
            //
            if (GetFullWidth(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for FULLWIDTH Table.
            //
            pUnic->WriteFlags |= F_FULLWIDTH;
        }

        else if (_stricmp(pszKeyWord, "TRADITIONAL_CHINESE") == 0)
        {
            if (Verbose)
                printf("\n\nFound TRADITIONAL_CHINESE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get TRADITIONAL_CHINESE Table.
            //
            if (GetTraditional(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for TRADITIONAL_CHINESE Table.
            //
            pUnic->WriteFlags |= F_TRADITIONAL;
        }

        else if (_stricmp(pszKeyWord, "SIMPLIFIED_CHINESE") == 0)
        {
            if (Verbose)
                printf("\n\nFound SIMPLIFIED_CHINESE keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get SIMPLIFIED_CHINESE Table.
            //
            if (GetSimplified(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for SIMPLIFIED_CHINESE Table.
            //
            pUnic->WriteFlags |= F_SIMPLIFIED;
        }

        else if (_stricmp(pszKeyWord, "COMP") == 0)
        {
            if (Verbose)
                printf("\n\nFound COMP keyword.\n");

            //
            //  Get size parameter.
            //
            if (GetSize(&size))
                return (1);

            //
            //  Get Precomposed and Composite Tables.
            //
            if (GetCompTable(pUnic, size))
                return (1);

            //
            //  Set WriteFlags for COMP Tables.
            //
            pUnic->WriteFlags |= F_COMP;
        }

        else if (_stricmp(pszKeyWord, "ENDUNICODE") == 0)
        {
            if (Verbose)
                printf("\n\nFound ENDUNICODE keyword.\n");

            //
            //  Return success.
            //
            return (0);
        }

        else
        {
            printf("Parse Error: Invalid Instruction '%s'.\n", pszKeyWord);
            return (1);
        }
    }

    //
    //  If this point is reached, then the ENDUNICODE keyword was
    //  not found.  Return an error.
    //
    printf("Parse Error: Expecting ENDUNICODE keyword.\n");
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteUnicode
//
//  This routine writes the locale independent (Unicode) tables to an
//  output file.
//
//  12-10-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteUnicode(
    PUNICODE pUnic)
{
    FILE *pOutputFile;                 // ptr to output file


    //
    //  Make sure all tables are present.
    //
    if (!((pUnic->WriteFlags & F_ADIGIT) &&
          (pUnic->WriteFlags & F_CZONE) &&
          (pUnic->WriteFlags & F_COMP) &&
          (pUnic->WriteFlags & F_HIRAGANA) &&
          (pUnic->WriteFlags & F_KATAKANA) &&
          (pUnic->WriteFlags & F_HALFWIDTH) &&
          (pUnic->WriteFlags & F_FULLWIDTH) &&
          (pUnic->WriteFlags & F_TRADITIONAL) &&
          (pUnic->WriteFlags & F_SIMPLIFIED)))
    {
        printf("Write Error: All tables must be present -\n");
        printf("             Ascii Digits, Compatibility Zone, Composite Tables,\n");
        printf("             Hiragana, Katakana, Half Width, Full Width,\n");
        printf("             Traditional Chinese, and Simplified Chinese.\n");
        return (1);
    }

    //
    //  Make sure output file can be opened for writing.
    //
    if ((pOutputFile = fopen(UNICODE_FILE, "w+b")) == 0)
    {
        printf("Error opening output file %s.\n", UNICODE_FILE);
        return (1);
    }

    if (Verbose)
        printf("\n\nWriting output file %s...\n", UNICODE_FILE);

    //
    //  Write Ascii Digits Table to output file.
    //
    if (WriteAsciiDigits(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Ascii Digits table structures.
    //
    Free844(pUnic->pADigit);


    //
    //  Write Fold Compatibility Zone Table to output file.
    //
    if (WriteFoldCZone(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Fold Compatibility Zone table structures.
    //
    Free844(pUnic->pCZone);


    //
    //  Write Hiragana Table to output file.
    //
    if (WriteHiragana(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Hiragana table structures.
    //
    Free844(pUnic->pHiragana);


    //
    //  Write Katakana Table to output file.
    //
    if (WriteKatakana(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Katakana table structures.
    //
    Free844(pUnic->pKatakana);


    //
    //  Write Half Width Table to output file.
    //
    if (WriteHalfWidth(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Half Width table structures.
    //
    Free844(pUnic->pHalfWidth);


    //
    //  Write Full Width Table to output file.
    //
    if (WriteFullWidth(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Full Width table structures.
    //
    Free844(pUnic->pFullWidth);


    //
    //  Write Traditional Chinese Table to output file.
    //
    if (WriteTraditional(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Traditional Chinese table structures.
    //
    Free844(pUnic->pTraditional);


    //
    //  Write Simplified Chinese Table to output file.
    //
    if (WriteSimplified(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Simplified Chinese table structures.
    //
    Free844(pUnic->pSimplified);


    //
    //  Write Precomposed Table to output file.
    //
    if (WritePrecomposed(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Write Composite Table to output file.
    //
    if (WriteComposite(pUnic, pOutputFile))
    {
        fclose(pOutputFile);
        return (1);
    }

    //
    //  Free Comp table structures.
    //
    Free844(pUnic->pPreComp);
    Free844(pUnic->pBase);
    Free844(pUnic->pNonSp);
    if (pUnic->pCompGrid != NULL)
    {
        free(pUnic->pCompGrid);
    }


    //
    //  Close the output file.
    //
    fclose(pOutputFile);

    //
    //  Return success.
    //
    printf("\nSuccessfully wrote output file %s\n", UNICODE_FILE);
    return (0);
}




//-------------------------------------------------------------------------//
//                            INTERNAL ROUTINES                            //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  GetAsciiDigits
//
//  This routine gets the ascii digits table from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetAsciiDigits(
    PUNICODE pUnic,
    int Size)
{
    int Digit;                    // digit value
    int Ascii;                    // ascii digit value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pADigit))
    {
        return (1);
    }

    //
    //  For each entry in table, read in digit value and ascii digit
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference
    //  to ascii digit.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in digit and ascii digit values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Digit,
                           &Ascii );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading ASCIIDIGITS values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Digit = %x\tAscii = %x\n", Digit, Ascii);

        //
        //  Insert difference (Ascii - Digit) into 8:4:4 table.
        //
        if (Insert844( pUnic->pADigit,
                       (WORD)Digit,
                       (WORD)(Ascii - Digit),
                       &pUnic->ADBuf2,
                       &pUnic->ADBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFoldCZone
//
//  This routine gets the FOLDCZONE table from the input file.  It uses
//  the size parameter to know when to stop reading from the file.  If an
//  error is encountered, a message is printed and an error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetFoldCZone(
    PUNICODE pUnic,
    int Size)
{
    int CZone;                    // compatibility zone value
    int Ascii;                    // ascii value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pCZone))
    {
        return (1);
    }

    //
    //  For each entry in table, read in czone value and ascii
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  ascii value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in CZone and Ascii values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &CZone,
                           &Ascii );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading FOLDCZONE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  CZone = %x\tAscii = %x\n", CZone, Ascii);

        //
        //  Insert difference (Ascii - CZone) into 8:4:4 table.
        //
        if (Insert844( pUnic->pCZone,
                       (WORD)CZone,
                       (WORD)(Ascii - CZone),
                       &pUnic->CZBuf2,
                       &pUnic->CZBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetHiragana
//
//  This routine gets the Hiragana table (Katakana to Hiragana) from the
//  input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetHiragana(
    PUNICODE pUnic,
    int Size)
{
    int Kata;                     // Katakana value
    int Hira;                     // Hiragana value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pHiragana))
    {
        return (1);
    }

    //
    //  For each entry in table, read in katakana value and hiragana
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  hiragana value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in katakana and hiragana values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Kata,
                           &Hira );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading HIRAGANA values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Katakana = %x\tHiragana = %x\n", Kata, Hira);

        //
        //  Insert difference (Kata - Hira) into 8:4:4 table.
        //
        if (Insert844( pUnic->pHiragana,
                       (WORD)Kata,
                       (WORD)(Hira - Kata),
                       &pUnic->HGBuf2,
                       &pUnic->HGBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetKatakana
//
//  This routine gets the Katakana table (Hiragana to Katakana) from the
//  input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetKatakana(
    PUNICODE pUnic,
    int Size)
{
    int Hira;                     // Hiragana value
    int Kata;                     // Katakana value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pKatakana))
    {
        return (1);
    }

    //
    //  For each entry in table, read in hiragana value and katakana
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  katakana value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in hiragana and katakana values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Hira,
                           &Kata );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading KATAKANA values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Hiragana = %x\tKatakana = %x\n", Hira, Kata);

        //
        //  Insert difference (Hira - Kata) into 8:4:4 table.
        //
        if (Insert844( pUnic->pKatakana,
                       (WORD)Hira,
                       (WORD)(Kata - Hira),
                       &pUnic->KKBuf2,
                       &pUnic->KKBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetHalfWidth
//
//  This routine gets the Half Width table (Full Width to Half Width) from
//  the input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetHalfWidth(
    PUNICODE pUnic,
    int Size)
{
    int Full;                     // Full Width value
    int Half;                     // Half Width value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pHalfWidth))
    {
        return (1);
    }

    //
    //  For each entry in table, read in full width value and half width
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  half width value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in full width and half width values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Full,
                           &Half );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading HALFWIDTH values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Full Width = %x\tHalf Width = %x\n", Full, Half);

        //
        //  Insert difference (Full - Half) into 8:4:4 table.
        //
        if (Insert844( pUnic->pHalfWidth,
                       (WORD)Full,
                       (WORD)(Half - Full),
                       &pUnic->HWBuf2,
                       &pUnic->HWBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFullWidth
//
//  This routine gets the Full Width table (Half Width to Full Width) from
//  the input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetFullWidth(
    PUNICODE pUnic,
    int Size)
{
    int Half;                     // Half Width value
    int Full;                     // Full Width value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pFullWidth))
    {
        return (1);
    }

    //
    //  For each entry in table, read in half width value and full width
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  full width value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in half width and full width values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Half,
                           &Full );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading FULLWIDTH values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Half Width = %x\tFull Width = %x\n", Half, Full);

        //
        //  Insert difference (Half - Full) into 8:4:4 table.
        //
        if (Insert844( pUnic->pFullWidth,
                       (WORD)Half,
                       (WORD)(Full - Half),
                       &pUnic->FWBuf2,
                       &pUnic->FWBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTraditional
//
//  This routine gets the Traditional table (Simplified to Traditional) from
//  the input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetTraditional(
    PUNICODE pUnic,
    int Size)
{
    int Simplified;               // Simplified value
    int Traditional;              // Traditional value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pTraditional))
    {
        return (1);
    }

    //
    //  For each entry in table, read in simplified value and traditional
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  traditional value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in simplified and traditional values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Simplified,
                           &Traditional );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading TRADITIONAL_CHINESE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Simplified = %x\tTraditional = %x\n",
                    Simplified, Traditional);

        //
        //  Insert difference (Simplified - Traditional) into 8:4:4 table.
        //
        if (Insert844( pUnic->pTraditional,
                       (WORD)Simplified,
                       (WORD)(Traditional - Simplified),
                       &pUnic->TRBuf2,
                       &pUnic->TRBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSimplified
//
//  This routine gets the Simplified table (Traditional to Simplified) from
//  the input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and
//  an error is returned.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetSimplified(
    PUNICODE pUnic,
    int Size)
{
    int Traditional;              // Traditional value
    int Simplified;               // Simplified value
    register int Ctr;             // loop counter
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffer for 8:4:4 table - 256 pointers.
    //
    if (Allocate8(&pUnic->pSimplified))
    {
        return (1);
    }

    //
    //  For each entry in table, read in traditional value and simplified
    //  translation value from input file, allocate necessary 16 word
    //  buffers based on wide character value, and store difference to
    //  simplified value.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in traditional and simplified values.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x ;%*[^\n]",
                           &Traditional,
                           &Simplified );
        if (NumItems != 2)
        {
            printf("Parse Error: Error reading SIMPLIFIED_CHINESE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  Traditional = %x\tSimplified = %x\n",
                    Traditional, Simplified);

        //
        //  Insert difference (Traditional - Simplified) into 8:4:4 table.
        //
        if (Insert844( pUnic->pSimplified,
                       (WORD)Traditional,
                       (WORD)(Simplified - Traditional),
                       &pUnic->SPBuf2,
                       &pUnic->SPBuf3,
                       sizeof(WORD) ))
        {
            return (1);
        }
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCompTable
//
//  This routine gets the precomposed table and the composite table from
//  the input file.  It uses the size parameter to know when to stop reading
//  from the file.  If an error is encountered, a message is printed and an
//  error is returned.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int GetCompTable(
    PUNICODE pUnic,
    int Size)
{
    int  PreComp;                 // precomposed character
    int  Base;                    // base character
    int  NonSp;                   // nonspace character
    DWORD Combo;                  // combined base and nonspace
    register int Ctr;             // loop counter
    WORD BOff, NOff;              // offsets for Base and NonSpace chars
    int NumItems;                 // number of items returned from fscanf


    //
    //  Allocate top buffers for 8:4:4 tables - 256 pointers.
    //
    if (Allocate8(&pUnic->pPreComp))
    {
        return (1);
    }
    if (Allocate8(&pUnic->pBase))
    {
        return (1);
    }
    if (Allocate8(&pUnic->pNonSp))
    {
        return (1);
    }

    //
    //  Allocate 2D grid for Composite table and save Size
    //  in the first position of the grid.
    //
    if (AllocateGrid(&pUnic->pCompGrid, Size))
    {
        return (1);
    }

    //
    //  For each entry in table, read in precomposed, base, and nonspace
    //  characters from input file and build the necessary tables.
    //
    for (Ctr = 0; Ctr < Size; Ctr++)
    {
        //
        //  Read in precomposed, base, and nonspace characters.
        //
        NumItems = fscanf( pInputFile,
                           "%x %x %x ;%*[^\n]",
                           &PreComp,
                           &Base,
                           &NonSp );
        if (NumItems != 3)
        {
            printf("Parse Error: Error reading COMPTABLE values.\n");
            return (1);
        }

        if (Verbose)
            printf("  PreComp = %x\tBase = %x\tNonSp = %x\n",
                      PreComp, Base, NonSp);

        //
        //  PRECOMPOSED TABLE:
        //
        //  Convert Base and NonSp into one DWORD value - Combo.
        //  Base = high word, NonSp = low word.
        //
        //  Insert Combo information into Precomposed 8:4:4 table.
        //
        Combo = MAKE_DWORD((WORD)NonSp, (WORD)Base);
        if (Insert844( pUnic->pPreComp,
                       (WORD)PreComp,
                       Combo,
                       &pUnic->PCBuf2,
                       &pUnic->PCBuf3,
                       sizeof(DWORD) ))
        {
            return (1);
        }

        if (Verbose)
            printf("    Combo = %x\n", Combo);

        //
        //  COMPOSITE TABLE:
        //
        //  Insert offsets into BASE and NONSPACE 8:4:4 tables.
        //  Insert PRECOMPOSED into 2D grid.
        //
        Get844Value( pUnic->pBase,
                     (WORD)Base,
                     &BOff );
        Get844Value( pUnic->pNonSp,
                     (WORD)NonSp,
                     &NOff );
        if (BOff == 0)
        {
            BOff = (WORD)(++(pUnic->NumBase));
            if (Insert844( pUnic->pBase,
                           (WORD)Base,
                           BOff,
                           &pUnic->BSBuf2,
                           &pUnic->BSBuf3,
                           sizeof(WORD) ))
            {
                return (1);
            }
        }
        if (NOff == 0)
        {
            NOff = (WORD)(++(pUnic->NumNonSp));
            if (Insert844( pUnic->pNonSp,
                           (WORD)NonSp,
                           NOff,
                           &pUnic->NSBuf2,
                           &pUnic->NSBuf3,
                           sizeof(WORD) ))
            {
                return (1);
            }
        }

        if (Verbose)
            printf("    BOff = %x\tNOff = %x\n", BOff, NOff);

        InsertCompGrid( pUnic->pCompGrid,
                        (WORD)PreComp,
                        BOff,
                        NOff );
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Get844Value
//
//  This routine gets the value in the 8:4:4 table of the given wide character.
//  If a value is found, it returns the value found in Value.  Otherwise,
//  it returns 0 in Value.
//
//  07-30-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void Get844Value(
    P844_ARRAY pArr,
    WORD WChar,
    WORD *Value)
{
    P844_ARRAY pMidFour;
    WORD *pFour;


    //
    //  Traverse 8:4:4 table for value.
    //
    if (pMidFour = (P844_ARRAY)(pArr[GET8(WChar)]))
    {
        if (pFour = pMidFour[GETHI4(WChar)])
        {
            *Value = pFour[GETLO4(WChar)];
        }
        else
        {
            *Value = 0;
        }
    }
    else
    {
        *Value = 0;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertCompGrid
//
//  This routine inserts the given precomposed character at the given
//  offset in the 2D grid.  The matrix size of the grid is located in
//  the first spot of the grid array.
//
//  The grid is set up in memory as follows:
//
//     [  base 1  ][  base 2 ][  base 3  ]
//
//        where the size of each is GridSize.
//
//     In other words, BASE     characters  =>  ROWS
//                     NONSPACE characters  =>  COLUMNS
//
//  NOTE: BaseOff and NonSpOff start at 1, not 0.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

void InsertCompGrid(
    PCOMP_GRID pCompGrid,
    WORD PreComp,
    WORD BaseOff,
    WORD NonSpOff)
{
    int Index;


    Index = ((BaseOff - 1) * pCompGrid[0] + (NonSpOff - 1)) + 1;
    pCompGrid[Index] = PreComp;

    if (Verbose)
        printf("    Grid Spot = %d\tMax = %d\n", Index, pCompGrid[0]);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteAsciiDigits
//
//  This routine writes the Ascii Digits information to the output file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WriteAsciiDigits(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Ascii Digits Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->ADBuf2,
                              pUnic->ADBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Ascii Digits table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Ascii Digits size" ))
    {
        return (1);
    }

    //
    //  Write Ascii Digits 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pADigit,
                       pUnic->ADBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteFoldCZone
//
//  This routine writes the Fold Compatibility Zone information to the
//  output file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WriteFoldCZone(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Fold CZone Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->CZBuf2,
                              pUnic->CZBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Fold CZone table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Fold CZone size" ))
    {
        return (1);
    }

    //
    //  Write Ascii Digits 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pCZone,
                       pUnic->CZBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteHiragana
//
//  This routine writes the Hiragana information to the output file.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteHiragana(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Hiragana Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->HGBuf2,
                              pUnic->HGBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Hiragana table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Hiragana size" ))
    {
        return (1);
    }

    //
    //  Write Hiragana 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pHiragana,
                       pUnic->HGBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteKatakana
//
//  This routine writes the Katakana information to the output file.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteKatakana(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Katakana Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->KKBuf2,
                              pUnic->KKBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Katakana table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Katakana size" ))
    {
        return (1);
    }

    //
    //  Write Katakana 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pKatakana,
                       pUnic->KKBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteHalfWidth
//
//  This routine writes the Half Width information to the output file.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteHalfWidth(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Half Width Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->HWBuf2,
                              pUnic->HWBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Half Width table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Half Width size" ))
    {
        return (1);
    }

    //
    //  Write Half Width 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pHalfWidth,
                       pUnic->HWBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteFullWidth
//
//  This routine writes the Full Width information to the output file.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteFullWidth(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Full Width Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->FWBuf2,
                              pUnic->FWBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Full Width table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Full Width size" ))
    {
        return (1);
    }

    //
    //  Write Full Width 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pFullWidth,
                       pUnic->FWBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteTraditional
//
//  This routine writes the Traditional information to the output file.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteTraditional(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Traditional Chinese Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->TRBuf2,
                              pUnic->TRBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Traditional Chinese table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Traditional Chinese size" ))
    {
        return (1);
    }

    //
    //  Write Traditional 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pTraditional,
                       pUnic->TRBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteSimplified
//
//  This routine writes the Simplified information to the output file.
//
//  05-07-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int WriteSimplified(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting Simplified Chinese Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->SPBuf2,
                              pUnic->SPBuf3,
                              sizeof(WORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of Simplified Chinese table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "Simplified Chinese size" ))
    {
        return (1);
    }

    //
    //  Write Simplified 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pSimplified,
                       pUnic->SPBuf2,
                       TblSize - 1,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WritePrecomposed
//
//  This routine writes the Precomposed information to the output file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WritePrecomposed(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int TblSize;                  // size of table
    WORD wValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting PRECOMPOSED Table...\n");

    //
    //  Compute size of table.
    //
    TblSize = Compute844Size( pUnic->PCBuf2,
                              pUnic->PCBuf3,
                              sizeof(DWORD) ) + 1;

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (TblSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of PRECOMPOSED table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)TblSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "PRECOMPOSED size" ))
    {
        return (1);
    }

    //
    //  Write PRECOMPOSED 8:4:4 table to file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pPreComp,
                       pUnic->PCBuf2,
                       TblSize - 1,
                       sizeof(DWORD) ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteComposite
//
//  This routine writes the Composite information to the output file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WriteComposite(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int BaseSize;                 // size of Base table
    int NonSpSize;                // size of NonSpace table
    WORD wValue;                  // temp storage value
    BYTE bValue;                  // temp storage value


    if (Verbose)
        printf("\nWriting COMPOSITE Table...\n");

    //
    //  Compute size of base table.
    //
    BaseSize = Compute844Size( pUnic->BSBuf2,
                               pUnic->BSBuf3,
                               sizeof(WORD) );

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (BaseSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of PRECOMPOSED table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)BaseSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "COMPOSITE BASE size" ))
    {
        return (1);
    }

    //
    //  Compute size of nonspace table.
    //
    NonSpSize = Compute844Size( pUnic->NSBuf2,
                                pUnic->NSBuf3,
                                sizeof(WORD) );

    //
    //  Make sure the total size of the table is not greater than 64K.
    //  If it is, then the WORD offsets are too small.
    //
    if (NonSpSize > MAX_844_TBL_SIZE)
    {
       printf("Write Error: Size of PRECOMPOSED table is greater than 64K.\n");
       return (1);
    }

    //
    //  Write the size to the output file.
    //
    wValue = (WORD)NonSpSize;
    if (FileWrite( pOutputFile,
                   &wValue,
                   sizeof(WORD),
                   1,
                   "COMPOSITE NONSPACE size" ))
    {
        return (1);
    }

    //
    //  Write number of base chars to output file.
    //
    bValue = (BYTE)(pUnic->NumBase);
    if (FileWrite( pOutputFile,
                   &bValue,
                   sizeof(BYTE),
                   1,
                   "COMPOSITE BASE number" ))
    {
        return (1);
    }

    //
    //  Write number of nonspace chars to output file.
    //
    bValue = (BYTE)(pUnic->NumNonSp);
    if (FileWrite( pOutputFile,
                   &bValue,
                   sizeof(BYTE),
                   1,
                   "COMPOSITE NONSPACE number" ))
    {
        return (1);
    }

    //
    //  Write Base Character 8:4:4 table to output file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pBase,
                       pUnic->BSBuf2,
                       BaseSize,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Write NonSpace Character 8:4:4 table to output file.
    //
    if (Write844Table( pOutputFile,
                       pUnic->pNonSp,
                       pUnic->NSBuf2,
                       NonSpSize,
                       sizeof(WORD) ))
    {
        return (1);
    }

    //
    //  Write 2D Grid to output file.
    //
    if (WriteGrid( pUnic,
                   pOutputFile ))
    {
        return (1);
    }

    //
    //  Return success.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteGrid
//
//  This routine writes the Composite Table 2D Grid to the output file.
//
//  07-30-91    JulieB    Created.
//  12-10-91    JulieB    Modified for new table format.
////////////////////////////////////////////////////////////////////////////

int WriteGrid(
    PUNICODE pUnic,
    FILE *pOutputFile)
{
    int GridSize;                      // get matrix size of grid
    register int Ctr;                  // loop counter
    register PCOMP_GRID ptr;           // temp ptr into grid


    GridSize = (pUnic->pCompGrid)[0];
    ptr = pUnic->pCompGrid + 1;

    for (Ctr = 0; Ctr < pUnic->NumBase; Ctr++)
    {
        if (FileWrite( pOutputFile,
                       ptr,
                       sizeof(WORD),
                       pUnic->NumNonSp,
                       "COMPOSITE GRID" ))
        {
            return (1);
        }

        ptr += GridSize;
    }

    //
    //  Return success.
    //
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\cstest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    cstest.c

Abstract:

    Test module for NLS API CompareString.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE           100              // buffer size in wide chars

#define  CS_INVALID_FLAGS  ((DWORD)(~(NORM_IGNORECASE |                     \
                                      NORM_IGNORENONSPACE |                 \
                                      NORM_IGNORESYMBOLS |                  \
                                      NORM_IGNOREKANATYPE |                 \
                                      NORM_IGNOREWIDTH |                    \
                                      NORM_STOP_ON_NULL)))




//
//  Global Variables.
//

LCID Locale;

#define wCompStr1  L"This Is A String"
#define wCompStr2  L"This Is A String Longer"
#define wCompStr3  L"THIS IS A STRing"
#define wCompStr4  L"This Is$ A String"
#define wCompStr5  L"This Is A Different String"

//  Sharp S
#define wCmpSharpS1     L"t\x00dft"
#define wCmpSharpS2     L"tSSt"
#define wCmpSharpS3     L"tSt"
#define wCmpSharpS4     L"tt"
#define wCmpSharpS5     L"tS"
#define wCmpSharpS6     L"\x00dft"

//  A-acute, E-acute
#define wCmpPre         L"\x00c1\x00c9"
#define wCmpPreLow      L"\x00e1\x00e9"
#define wCmpComp        L"\x0041\x0301\x0045\x0301"
#define wCmpComp2       L"\x0041\x0301\x0045\x0301\x0301"

//  A, E  -  Expansion
#define wCmpExp         L"\x00c6"
#define wCmpExp2        L"ae"

//  Unsortable character in string
#define wCmpUnsort      L"A\xffff\x0301\x0045\x0301"

//  Diacritics and Symbols
#define wCmpDiac1       L"\x00e4.ext"
#define wCmpDiac2       L"a\x00e4.ext"

//  Diacritics Only
#define wCmpDiac3       L"\x00e4"
#define wCmpDiac4       L"a\x00e4"

//  Nonspace
#define wCmpNS1         L"\x0301\x00a2\x0045"
#define wCmpNS2         L"\x00a2\x0045"
#define wCmpNS3         L"\x0301-E"
#define wCmpNS4         L"-E"


//  French Diacritic Sorting
#define wCmpFrench1     L"cot\x00e9"
#define wCmpFrench2     L"c\x00f4te"
#define wCmpFrench3     L"c\x00f4t\x00e9"

//  Danish Compression Sorting
#define wCmpAEMacronLg  L"\x01e2"
#define wCmpAEMacronSm  L"\x01e3"
#define wCmpAELg        L"\x00c6"
#define wCmpAESm        L"\x00e6"




//
//  Forward Declarations.
//

BOOL
InitCompStr();

int
CS_BadParamCheck();

int
CS_NormalCase();

int
CS_Ansi();

void
CheckReturnCompStr(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors);

void
CompareSortkeyStrings(
    LPBYTE pSort1,
    LPBYTE pSort2,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors);

UINT
GetCPFromLocale(
    LCID Locale);

void
CompareStringTester(
    LCID Locale,
    DWORD dwFlags,
    LPWSTR pString1,
    int Count1,
    LPWSTR pString2,
    int Count2,
    int ExpectedReturn,
    LPSTR pErrString,
    BOOL TestAVersion,
    int *pNumErrors);




////////////////////////////////////////////////////////////////////////////
//
//  TestCompareString
//
//  Test routine for CompareStringW API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestCompareString()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING CompareStringW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitCompStr())
    {
        printf("\nABORTED TestCompareString: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += CS_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += CS_NormalCase();

    //
    //  Test Ansi Version.
    //
    ErrCount += CS_Ansi();

    //
    //  Print out result.
    //
    printf("\nCompareStringW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitCompStr
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitCompStr()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);


    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CS_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CS_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = CompareStringW( (LCID)333,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpString1 = NULL
    rc = CompareStringW( Locale,
                         0,
                         NULL,
                         -1,
                         wCompStr2,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpString1 NULL",
                         &NumErrors );

    //  Variation 2  -  lpString2 = NULL
    rc = CompareStringW( Locale,
                         0,
                         wCompStr1,
                         -1,
                         NULL,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpString2 NULL",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  dwCmpFlags = invalid
    rc = CompareStringW( Locale,
                         CS_INVALID_FLAGS,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwCmpFlags invalid",
                         &NumErrors );

    //  Variation 2  -  dwCmpFlags = 0
    rc = CompareStringW( Locale,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         -1 );
    CheckReturnCompStr( rc,
                        1,
                        "dwCmpFlags zero",
                        &NumErrors );

    //  Variation 3  -  dwCmpFlags = Use CP ACP
    rc = CompareStringW( Locale,
                         LOCALE_USE_CP_ACP,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         -1 );
    CheckReturnCompStr( rc,
                        1,
                        "Use CP ACP",
                        &NumErrors );


//
//  CompareStringA.
//

    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = CompareStringA( (LCID)333,
                         0,
                         "foo",
                         -1,
                         "foo",
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version - Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpString1 = NULL
    rc = CompareStringA( Locale,
                         0,
                         NULL,
                         -1,
                         "foo",
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version - lpString1 NULL",
                         &NumErrors );

    //  Variation 2  -  lpString2 = NULL
    rc = CompareStringA( Locale,
                         0,
                         "foo",
                         -1,
                         NULL,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version - lpString2 NULL",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  dwCmpFlags = invalid
    rc = CompareStringA( Locale,
                         CS_INVALID_FLAGS,
                         "foo",
                         -1,
                         "foo",
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "A version - dwCmpFlags invalid",
                         &NumErrors );

    //  Variation 2  -  dwCmpFlags = 0
    rc = CompareStringA( Locale,
                         0,
                         "foo",
                         -1,
                         "foo",
                         -1 );
    CheckReturnCompStr( rc,
                        2,
                        "A version - dwCmpFlags zero",
                        &NumErrors );

    //  Variation 3  -  dwCmpFlags = Use CP ACP
    rc = CompareStringA( Locale,
                         LOCALE_USE_CP_ACP,
                         "foo",
                         -1,
                         "foo",
                         -1 );
    CheckReturnCompStr( rc,
                        2,
                        "A version - Use CP ACP",
                        &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CS_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CS_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    CompareStringTester( LOCALE_SYSTEM_DEFAULT,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "System Default Locale",
                         TRUE,
                         &NumErrors );

    //  Variation 2  -  Current User Locale
    CompareStringTester( LOCALE_USER_DEFAULT,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "Current User Locale",
                         TRUE,
                         &NumErrors );


    //
    //  Equal Strings.
    //

    //  Variation 1  -  equal strings
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "equal strings",
                         TRUE,
                         &NumErrors );

    //
    //  nCounts.
    //

    //  Variation 1  -  nCount1 = 0
    rc = CompareStringW( Locale,
                         0,
                         wCompStr1,
                         0,
                         wCompStr2,
                         -1 );
    CheckReturnCompStr( rc,
                         1,
                         "nCount1 = 0",
                         &NumErrors );

    //  Variation 2  -  nCount2 = 0
    rc = CompareStringW( Locale,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         0 );
    CheckReturnCompStr( rc,
                         3,
                         "nCount2 = 0",
                         &NumErrors );

    //  Variation 3  -  nCount1 and nCount2 = 0
    rc = CompareStringW( Locale,
                         0,
                         wCompStr1,
                         0,
                         wCompStr2,
                         0 );
    CheckReturnCompStr( rc,
                         2,
                         "nCount1 and nCount2 = 0",
                         &NumErrors );

    //  Variation 4  -  counts = -1
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "counts (-1)",
                         TRUE,
                         &NumErrors );

    //  Variation 5  -  counts = value
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         2,
                         "counts (value)",
                         TRUE,
                         &NumErrors );

    //  Variation 6  -  count1 bigger
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1) - 2,
                         3,
                         "count1 bigger",
                         TRUE,
                         &NumErrors );

    //  Variation 7  -  count2 bigger
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1) - 2,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         1,
                         "count2 bigger",
                         TRUE,
                         &NumErrors );

    //  Variation 8  -  count1 ONE bigger
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1) - 1,
                         3,
                         "count1 ONE bigger",
                         TRUE,
                         &NumErrors );

    //  Variation 9  -  count2 ONE bigger
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1) - 1,
                         wCompStr1,
                         WC_STRING_LEN(wCompStr1),
                         1,
                         "count2 ONE bigger",
                         TRUE,
                         &NumErrors );


    //
    //  Longer Strings.
    //

    //  Variation 1  -  string1 longer
    CompareStringTester( Locale,
                         0,
                         wCompStr2,
                         -1,
                         wCompStr1,
                         -1,
                         3,
                         "string1 longer",
                         TRUE,
                         &NumErrors );

    //  Variation 2  -  string2 longer
    CompareStringTester( Locale,
                         0,
                         wCompStr1,
                         -1,
                         wCompStr2,
                         -1,
                         1,
                         "string2 longer",
                         TRUE,
                         &NumErrors );


    //
    //  Flags.
    //

    //  Variation 0  -  Use CP ACP
    CompareStringTester( Locale,
                         LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                         wCompStr1,
                         -1,
                         wCompStr3,
                         -1,
                         2,
                         "Use CP ACP",
                         TRUE,
                         &NumErrors );

    //  Variation 1  -  upper/lower case
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCompStr1,
                         -1,
                         wCompStr3,
                         -1,
                         2,
                         "upper/lower case",
                         TRUE,
                         &NumErrors );

    //  Variation 2  -  symbols
    CompareStringTester( Locale,
                         NORM_IGNORESYMBOLS,
                         wCompStr1,
                         -1,
                         wCompStr4,
                         -1,
                         2,
                         "symbols",
                         TRUE,
                         &NumErrors );

    //  Variation 3  -  case and symbols
    CompareStringTester( Locale,
                         NORM_IGNORECASE | NORM_IGNORESYMBOLS,
                         wCompStr3,
                         -1,
                         wCompStr4,
                         -1,
                         2,
                         "case and symbols",
                         TRUE,
                         &NumErrors );

    //  Variation 4  -  different strings w/ case
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCompStr4,
                         -1,
                         wCompStr5,
                         -1,
                         3,
                         "different case",
                         TRUE,
                         &NumErrors );

    //  Variation 5  -  ignore case, sharp S
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpSharpS1,
                         -1,
                         wCmpSharpS2,
                         -1,
                         2,
                         "ignore case, sharp S",
                         TRUE,
                         &NumErrors );

    //  Variation 6  -  ignore case, sharp S diff
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpSharpS1,
                         -1,
                         wCmpSharpS3,
                         -1,
                         1,
                         "ignore case, sharp S diff",
                         TRUE,
                         &NumErrors );

    //  Variation 7  -  ignore case, sharp S diff2
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpSharpS1,
                         -1,
                         wCmpSharpS4,
                         -1,
                         1,
                         "ignore case, sharp S diff2",
                         TRUE,
                         &NumErrors );

    //  Variation 8  -  ignore case, sharp S diff3
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpSharpS1,
                         -1,
                         wCmpSharpS5,
                         -1,
                         3,
                         "ignore case, sharp S diff3",
                         TRUE,
                         &NumErrors );

    //  Variation 9  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"ab\x0000yy",
                         5,
                         L"ab\x0000zz",
                         5 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 1",
                         &NumErrors );

    //  Variation 10  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"ab\x0000yy",
                         -1,
                         L"ab\x0000zz",
                         -1 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 2",
                         &NumErrors );

    //  Variation 11  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"ab\x0000yy",
                         5,
                         L"ab\x0000zz",
                         -1 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 3",
                         &NumErrors );

    //  Variation 12  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"ab\x0000yy",
                         -1,
                         L"ab\x0000zz",
                         5 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 4",
                         &NumErrors );

    //  Variation 13  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"abyyy",
                         -1,
                         L"abyyy",
                         -1 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 5",
                         &NumErrors );

    //  Variation 14  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"abyyy",
                         5,
                         L"abyyy",
                         5 );
    CheckReturnCompStr( rc,
                         2,
                         "stop on null - 6",
                         &NumErrors );

    //  Variation 15  -  stop on null
    rc = CompareStringW( Locale,
                         NORM_STOP_ON_NULL,
                         L"ab\x0000yy",
                         5,
                         L"abyyy",
                         5 );
    CheckReturnCompStr( rc,
                         1,
                         "stop on null - 7",
                         &NumErrors );




    //
    //  Different Locale
    //

    //  Variation 1  -  locale 040c
    CompareStringTester( MAKELCID(0x040c, 0),
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "locale 040c - equal strings",
                         TRUE,
                         &NumErrors );

    //  Variation 2  -  locale 040c again
    CompareStringTester( MAKELCID(0x040c, 0),
                         0,
                         wCompStr1,
                         -1,
                         wCompStr1,
                         -1,
                         2,
                         "locale 040c again - equal strings",
                         TRUE,
                         &NumErrors );


    //
    //  Various Checks for Sorting.
    //

    // Variation 1 - Expansion first char
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpSharpS6,
                         -1,
                         L"SST",
                         -1,
                         2,
                         "expansion 1st char",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Comp vs. Precomp
    CompareStringTester( Locale,
                         0,
                         wCmpPre,
                         -1,
                         wCmpComp,
                         -1,
                         2,
                         "comp vs precomp",
                         FALSE,
                         &NumErrors );

    // Variation 3 - Comp vs. Precomp (ignore nonspace)
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpPre,
                         -1,
                         wCmpComp2,
                         -1,
                         2,
                         "comp vs precomp (ignore nonspace)",
                         FALSE,
                         &NumErrors );

    // Variation 4 - Comp vs. Precomp (ignore nonspace - diff)
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpPre,
                         -1,
                         wCmpComp2,
                         -1,
                         2,
                         "comp vs precomp (ignore nonspace - diff)",
                         FALSE,
                         &NumErrors );

    // Variation 5 - Comp vs. Precomp (diff)
    CompareStringTester( Locale,
                         0,
                         wCmpPre,
                         -1,
                         wCmpComp2,
                         -1,
                         1,
                         "comp vs precomp (diff)",
                         FALSE,
                         &NumErrors );

    // Variation 6 - Comp vs. Precomp (ignore case)
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpPreLow,
                         -1,
                         wCmpComp,
                         -1,
                         2,
                         "comp vs precomp (ignore case)",
                         FALSE,
                         &NumErrors );

    // Variation 7 - Expansion (ignore case)
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         wCmpExp,
                         -1,
                         wCmpExp2,
                         -1,
                         2,
                         "expansion (ignore case)",
                         TRUE,
                         &NumErrors );

    // Variation 8 - Expansion (ignore nonspace)
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpExp,
                         -1,
                         wCmpComp,
                         -1,
                         2,
                         "expansion (ignore nonspace)",
                         FALSE,
                         &NumErrors );

    // Variation 9 - Unsortable with Precomp
    CompareStringTester( Locale,
                         0,
                         wCmpUnsort,
                         -1,
                         wCmpComp,
                         -1,
                         2,
                         "unsortable with precomp",
                         FALSE,
                         &NumErrors );

    // Variation 10 - Extra symbols
    CompareStringTester( Locale,
                         NORM_IGNORESYMBOLS,
                         L"T*est",
                         -1,
                         L"Test*$@!",
                         -1,
                         2,
                         "extra symbols",
                         TRUE,
                         &NumErrors );

    // Variation 11 - Comp vs. Precomp (ignore case, nonspace)
    CompareStringTester( Locale,
                         NORM_IGNORECASE | NORM_IGNORENONSPACE,
                         wCmpPreLow,
                         -1,
                         L"AE",
                         -1,
                         2,
                         "comp vs precomp (ignore case, nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 12 - Comp vs. Precomp (ignore case, nonspace, symbol)
    CompareStringTester( Locale,
                         NORM_IGNORECASE | NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS,
                         wCmpPreLow,
                         -1,
                         L"A$E",
                         -1,
                         2,
                         "comp vs precomp (ignore case, nonspace, symbol)",
                         TRUE,
                         &NumErrors );

    // Variation 13 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         0,
                         L"ffi",
                         -1,
                         L"\xfb03",
                         -1,
                         2,
                         "expansion (1 to 3)",
                         FALSE,
                         &NumErrors );

    // Variation 14 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         0,
                         L"\xfb03",
                         -1,
                         L"ffi",
                         -1,
                         2,
                         "expansion (1 to 3) 2",
                         FALSE,
                         &NumErrors );

    // Variation 15 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         0,
                         L"\xfb03\x0061",
                         -1,
                         L"ffia",
                         -1,
                         2,
                         "expansion (1 to 3) 3",
                         FALSE,
                         &NumErrors );

    // Variation 16 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         0,
                         L"ffia",
                         -1,
                         L"\xfb03\x0061",
                         -1,
                         2,
                         "expansion (1 to 3) 4",
                         FALSE,
                         &NumErrors );

    // Variation 17 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         L"ffiA",
                         -1,
                         L"\xfb03\x0061",
                         -1,
                         2,
                         "expansion (1 to 3) 5",
                         FALSE,
                         &NumErrors );

    // Variation 18 - Expansion (1 to 3)
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         L"ffia",
                         -1,
                         L"\xfb03\x0041",
                         -1,
                         2,
                         "expansion (1 to 3) 6",
                         FALSE,
                         &NumErrors );


    //
    //  Symbol checks.
    //

    // Variation 1 - video vs vid_all
    CompareStringTester( Locale,
                         0,
                         L"video",
                         -1,
                         L"vid_all",
                         -1,
                         3,
                         "video vs vid_all",
                         TRUE,
                         &NumErrors );

    // Variation 2 - video vs vid_all (case)
    CompareStringTester( Locale,
                         NORM_IGNORECASE,
                         L"video",
                         -1,
                         L"vid_all",
                         -1,
                         3,
                         "video vs vid_all (case)",
                         TRUE,
                         &NumErrors );

    // Variation 3 - symbol first
    CompareStringTester( Locale,
                         0,
                         L"{Other}",
                         -1,
                         L"Novell",
                         -1,
                         1,
                         "symbol first",
                         TRUE,
                         &NumErrors );


    //
    //  Compression.
    //

    // Variation 1 - Spanish Castilian ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"ch",
                         -1,
                         L"cz",
                         -1,
                         3,
                         "Spanish Castilian ch vs cz",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Spanish Castilian ll
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"ll",
                         -1,
                         L"lz",
                         -1,
                         3,
                         "Spanish Castilian ll vs lz",
                         TRUE,
                         &NumErrors );

    // Variation 5 - Spanish Modern ch   --  ch does NOT sort after cz
    CompareStringTester( MAKELCID(0x0c0a, 0),
                         0,
                         L"ch",
                         -1,
                         L"cz",
                         -1,
                         1,
                         "Spanish Modern ch vs cz",
                         TRUE,
                         &NumErrors );

    // Variation 6 - Spanish Modern ll
    CompareStringTester( MAKELCID(0x0c0a, 0),
                         0,
                         L"ll",
                         -1,
                         L"lz",
                         -1,
                         1,
                         "Spanish Modern ll vs lz",
                         TRUE,
                         &NumErrors );

    // Variation 7 - Hungarian ccs
    CompareStringTester( MAKELCID(0x040e, 0),
                         0,
                         L"ccs",
                         -1,
                         L"cscs",
                         -1,
                         2,
                         "Hungarian ccs",
                         TRUE,
                         &NumErrors );

    // Variation 8 - Hungarian ddz
    CompareStringTester( MAKELCID(0x040e, 0),
                         0,
                         L"ddz",
                         -1,
                         L"dzdz",
                         -1,
                         2,
                         "Hungarian ddz",
                         TRUE,
                         &NumErrors );

    // Variation 9 - Hungarian ddzs
    CompareStringTester( MAKELCID(0x040e, 0),
                         0,
                         L"ddzs",
                         -1,
                         L"dzsdzs",
                         -1,
                         2,
                         "Hungarian ddzs",
                         TRUE,
                         &NumErrors );

    // Variation 10 - Danish aa vs. zoo
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"aa",
                         -1,
                         L"zoo",
                         -1,
                         3,
                         "Danish aa and zoo",
                         TRUE,
                         &NumErrors );

    // Variation 11 - Danish a$$a vs. zoo
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"a$$a",
                         -1,
                         L"zoo",
                         -1,
                         1,
                         "Danish a$$a and zoo",
                         TRUE,
                         &NumErrors );

    // Variation 12 - Danish a$$a vs. zoo
    CompareStringTester( MAKELCID(0x0406, 0),
                         NORM_IGNORESYMBOLS,
                         L"a$$a",
                         -1,
                         L"zoo",
                         -1,
                         1,
                         "Danish a$$a and zoo (ignore symbols)",
                         TRUE,
                         &NumErrors );



    //
    //  Compression - case differences.
    //

    // Variation 1 - Spanish Ch and cz
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"Ch",
                         -1,
                         L"cz",
                         -1,
                         3,
                         "Spanish Ch and cz",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Spanish Ch and ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"Ch",
                         -1,
                         L"ch",
                         -1,
                         3,
                         "Spanish Ch and ch",
                         TRUE,
                         &NumErrors );

    // Variation 3 - Spanish CH and ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"CH",
                         -1,
                         L"ch",
                         -1,
                         3,
                         "Spanish CH and ch",
                         TRUE,
                         &NumErrors );

    // Variation 4 - Spanish Ch and cH
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"Ch",
                         -1,
                         L"cH",
                         -1,
                         3,
                         "Spanish Ch and cH",
                         TRUE,
                         &NumErrors );

    // Variation 5 - Spanish ch and cH
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"ch",
                         -1,
                         L"cH",
                         -1,
                         3,
                         "Spanish ch and cH",
                         TRUE,
                         &NumErrors );

    // Variation 6 - Spanish CH and cH
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"CH",
                         -1,
                         L"cH",
                         -1,
                         3,
                         "Spanish CH and cH",
                         TRUE,
                         &NumErrors );

    // Variation 7 - Spanish ch and cZ
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"ch",
                         -1,
                         L"cZ",
                         -1,
                         3,
                         "Spanish ch and cZ",
                         TRUE,
                         &NumErrors );

    // Variation 8 - Spanish Castilian Ll and lz
    CompareStringTester( MAKELCID(0x040a, 0),
                         0,
                         L"Ll",
                         -1,
                         L"lz",
                         -1,
                         3,
                         "Spanish Castilian Ll vs lz",
                         TRUE,
                         &NumErrors );

    // Variation 9 - Hungarian ccs and csCs
    CompareStringTester( MAKELCID(0x040e, 0),
                         NORM_IGNORECASE,
                         L"ccs",
                         -1,
                         L"csCs",
                         -1,
                         2,
                         "Hungarian ccs and csCs",
                         TRUE,
                         &NumErrors );

    // Variation 10 - Hungarian ccs and Cscs
    CompareStringTester( MAKELCID(0x040e, 0),
                         NORM_IGNORECASE,
                         L"ccs",
                         -1,
                         L"Cscs",
                         -1,
                         2,
                         "Hungarian ccs and Cscs",
                         TRUE,
                         &NumErrors );

    // Variation 11 - Hungarian tty and tTy
    CompareStringTester( 0x040e,
                         0,
                         L"tty",
                         -1,
                         L"tTy",
                         -1,
                         1,
                         "Hungarian tty vs tTy",
                         TRUE,
                         &NumErrors );

    // Variation 12 - Hungarian tty and tTy
    CompareStringTester( 0x040e,
                         NORM_IGNORECASE,
                         L"tty",
                         -1,
                         L"tTy",
                         -1,
                         2,
                         "Hungarian tty vs tTy - ignore case",
                         TRUE,
                         &NumErrors );

    // Variation 13 - Danish aA vs. zoo
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"aA",
                         -1,
                         L"zoo",
                         -1,
                         1,
                         "Danish aA and zoo",
                         TRUE,
                         &NumErrors );


    //
    //  Ignore Case Compression
    //

    // Variation 1 - Spanish ch and cH
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"ch",
                         -1,
                         L"cH",
                         -1,
                         3,
                         "Spanish (case) ch and cH",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Spanish ch and Ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"ch",
                         -1,
                         L"Ch",
                         -1,
                         2,
                         "Spanish (case) ch and Ch",
                         TRUE,
                         &NumErrors );

    // Variation 3 - Spanish ch and CH
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"ch",
                         -1,
                         L"CH",
                         -1,
                         2,
                         "Spanish (case) ch and CH",
                         TRUE,
                         &NumErrors );

    // Variation 4 - Spanish CH and cH
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"CH",
                         -1,
                         L"cH",
                         -1,
                         3,
                         "Spanish (case) CH and cH",
                         TRUE,
                         &NumErrors );

    // Variation 5 - Spanish CH and Ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"CH",
                         -1,
                         L"Ch",
                         -1,
                         2,
                         "Spanish (case) CH and Ch",
                         TRUE,
                         &NumErrors );

    // Variation 6 - Spanish CH and ch
    CompareStringTester( MAKELCID(0x040a, 0),
                         NORM_IGNORECASE,
                         L"CH",
                         -1,
                         L"ch",
                         -1,
                         2,
                         "Spanish (case) CH and ch",
                         TRUE,
                         &NumErrors );


    //
    //  Check ae macron for Danish.
    //

    // Variation 1 - Danish AE macron vs. AA
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronLg,
                         -1,
                         L"AA",
                         -1,
                         1,
                         "Danish AE macron and AA",
                         FALSE,
                         &NumErrors );

    // Variation 2 - Danish ae macron vs. AA
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronSm,
                         -1,
                         L"AA",
                         -1,
                         1,
                         "Danish ae macron and AA",
                         FALSE,
                         &NumErrors );

    // Variation 3 - Danish AE macron vs. aa
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronLg,
                         -1,
                         L"aa",
                         -1,
                         1,
                         "Danish AE macron and aa",
                         FALSE,
                         &NumErrors );

    // Variation 4 - Danish ae macron vs. aa
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronSm,
                         -1,
                         L"aa",
                         -1,
                         1,
                         "Danish ae macron and aa",
                         FALSE,
                         &NumErrors );

    // Variation 5 - Danish AE macron vs. Z
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronLg,
                         -1,
                         L"Z",
                         -1,
                         3,
                         "Danish AE macron and Z",
                         FALSE,
                         &NumErrors );

    // Variation 6 - Danish ae macron vs. Z
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAEMacronSm,
                         -1,
                         L"Z",
                         -1,
                         3,
                         "Danish ae macron and Z",
                         FALSE,
                         &NumErrors );


    //
    //  Check ae for Danish.
    //

    // Variation 1 - Danish AE vs. AA
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAELg,
                         -1,
                         L"AA",
                         -1,
                         1,
                         "Danish AE and AA",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Danish ae vs. AA
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAESm,
                         -1,
                         L"AA",
                         -1,
                         1,
                         "Danish ae and AA",
                         TRUE,
                         &NumErrors );

    // Variation 3 - Danish AE vs. aa
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAELg,
                         -1,
                         L"aa",
                         -1,
                         1,
                         "Danish AE and aa",
                         TRUE,
                         &NumErrors );

    // Variation 4 - Danish ae vs. aa
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAESm,
                         -1,
                         L"aa",
                         -1,
                         1,
                         "Danish ae and aa",
                         TRUE,
                         &NumErrors );

    // Variation 5 - Danish AE vs. Z
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAELg,
                         -1,
                         L"Z",
                         -1,
                         3,
                         "Danish AE and Z",
                         TRUE,
                         &NumErrors );

    // Variation 6 - Danish ae vs. Z
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         wCmpAESm,
                         -1,
                         L"Z",
                         -1,
                         3,
                         "Danish ae and Z",
                         TRUE,
                         &NumErrors );


    //
    //  Check compression for Danish.
    //

    // Variation 1 - Danish aa vs. B
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"aa",
                         -1,
                         L"B",
                         -1,
                         3,
                         "Danish aa and B",
                         TRUE,
                         &NumErrors );

    // Variation 2 - Danish B vs. aa
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"B",
                         -1,
                         L"aa",
                         -1,
                         1,
                         "Danish B and aa",
                         TRUE,
                         &NumErrors );

    // Variation 3 - Danish aa vs. z
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"aa",
                         -1,
                         L"z",
                         -1,
                         3,
                         "Danish aa and z",
                         TRUE,
                         &NumErrors );

    // Variation 4 - Danish b vs. ya
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"b",
                         -1,
                         L"ya",
                         -1,
                         3,
                         "Danish b and ya",
                         TRUE,
                         &NumErrors );

    // Variation 5 - Danish  ya vs. b
    CompareStringTester( MAKELCID(0x0406, 0),
                         0,
                         L"ya",
                         -1,
                         L"b",
                         -1,
                         1,
                         "Danish ya and b",
                         TRUE,
                         &NumErrors );


    //
    //  Numeric check.
    //

    //  Variation 1 - numeric check
    CompareStringTester( Locale,
                         0,
                         L"1.ext",
                         -1,
                         L"a.ext",
                         -1,
                         1,
                         "numeric check",
                         TRUE,
                         &NumErrors );


    //
    //  Check diacritics and symbols.
    //

    //  Variation 1
    CompareStringTester( Locale,
                         0,
                         L"a.ext",
                         -1,
                         wCmpDiac1,
                         -1,
                         1,
                         "diacritic check 1",
                         TRUE,
                         &NumErrors );

    //  Variation 2
    CompareStringTester( Locale,
                         0,
                         L"a.ext",
                         -1,
                         wCmpDiac2,
                         -1,
                         1,
                         "diacritic check 2",
                         TRUE,
                         &NumErrors );

    //  Variation 3
    CompareStringTester( Locale,
                         0,
                         wCmpDiac1,
                         -1,
                         wCmpDiac2,
                         -1,
                         1,
                         "diacritic check 3",
                         TRUE,
                         &NumErrors );

    //  Variation 4
    CompareStringTester( Locale,
                         0,
                         wCmpDiac2,
                         -1,
                         L"az.ext",
                         -1,
                         1,
                         "diacritic check 4",
                         TRUE,
                         &NumErrors );


    //
    //  Check diacritics only.
    //

    //  Variation 5
    CompareStringTester( Locale,
                         0,
                         L"a",
                         -1,
                         wCmpDiac3,
                         -1,
                         1,
                         "diacritic check 5",
                         TRUE,
                         &NumErrors );

    //  Variation 6
    CompareStringTester( Locale,
                         0,
                         L"a",
                         -1,
                         wCmpDiac4,
                         -1,
                         1,
                         "diacritic check 6",
                         TRUE,
                         &NumErrors );

    //  Variation 7
    CompareStringTester( Locale,
                         0,
                         wCmpDiac3,
                         -1,
                         wCmpDiac4,
                         -1,
                         1,
                         "diacritic check 7",
                         TRUE,
                         &NumErrors );

    //  Variation 8
    CompareStringTester( Locale,
                         0,
                         wCmpDiac4,
                         -1,
                         L"az",
                         -1,
                         1,
                         "diacritic check 8",
                         TRUE,
                         &NumErrors );


    //
    //  Check Punctuation.
    //

    //  Variation 1
    CompareStringTester( Locale,
                         0,
                         L"coop",
                         -1,
                         L"co-op",
                         -1,
                         1,
                         "punctuation check 1",
                         TRUE,
                         &NumErrors );

    //  Variation 2
    CompareStringTester( Locale,
                         0,
                         L"co-op",
                         -1,
                         L"cop",
                         -1,
                         1,
                         "punctuation check 2",
                         TRUE,
                         &NumErrors );

    //  Variation 3
    CompareStringTester( Locale,
                         0,
                         L"co-op",
                         -1,
                         L"coop",
                         -1,
                         3,
                         "punctuation check 3",
                         TRUE,
                         &NumErrors );

    //  Variation 4
    CompareStringTester( Locale,
                         0,
                         L"cop",
                         -1,
                         L"co-op",
                         -1,
                         3,
                         "punctuation check 4",
                         TRUE,
                         &NumErrors );

    //  Variation 5
    CompareStringTester( 0x0409,
                         1,
                         L"A-ANNA",
                         -1,
                         L"A'JEFF",
                         -1,
                         1,
                         "hyphen, apostrophe",
                         FALSE,
                         &NumErrors );

    //  Variation 6
    CompareStringTester( 0x0409,
                         1,
                         L"A'JEFF",
                         -1,
                         L"A-ANNA",
                         -1,
                         3,
                         "apostrophe, hyphen",
                         FALSE,
                         &NumErrors );



    //
    //  Check Punctuation - STRING SORT.
    //

    //  Variation 1
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"coop",
                         -1,
                         L"co-op",
                         -1,
                         3,
                         "string sort punctuation check 1",
                         TRUE,
                         &NumErrors );

    //  Variation 2
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"co-op",
                         -1,
                         L"cop",
                         -1,
                         1,
                         "string sort punctuation check 2",
                         TRUE,
                         &NumErrors );

    //  Variation 3
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"co-op",
                         -1,
                         L"coop",
                         -1,
                         1,
                         "string sort punctuation check 3",
                         TRUE,
                         &NumErrors );

    //  Variation 4
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"cop",
                         -1,
                         L"co-op",
                         -1,
                         3,
                         "string sort punctuation check 4",
                         TRUE,
                         &NumErrors );

    //  Variation 5
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"cop",
                         -1,
                         L"coop",
                         -1,
                         3,
                         "string sort punctuation check 5",
                         TRUE,
                         &NumErrors );

    //  Variation 6
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"cop",
                         3,
                         L"coop",
                         3,
                         3,
                         "string sort punctuation check 6",
                         TRUE,
                         &NumErrors );

    //  Variation 7
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"a-coo",
                         -1,
                         L"a_coo",
                         -1,
                         1,
                         "string sort hyphen vs. unserscore 1",
                         TRUE,
                         &NumErrors );

    //  Variation 8
    CompareStringTester( Locale,
                         0,
                         L"a-coo",
                         -1,
                         L"a_coo",
                         -1,
                         3,
                         "string sort hyphen vs. unserscore 2",
                         TRUE,
                         &NumErrors );

    //  Variation 9
    CompareStringTester( Locale,
                         SORT_STRINGSORT,
                         L"a-coo",
                         5,
                         L"a_coo",
                         5,
                         1,
                         "string sort hyphen vs. unserscore 3",
                         TRUE,
                         &NumErrors );

    //  Variation 10
    CompareStringTester( Locale,
                         0,
                         L"a-coo",
                         5,
                         L"a_coo",
                         5,
                         3,
                         "string sort hyphen vs. unserscore 4",
                         TRUE,
                         &NumErrors );

    //  Variation 11
    CompareStringTester( Locale,
                         SORT_STRINGSORT | NORM_IGNORECASE,
                         L"AdministratorAdministrative User Accountdomain...",
                         0xb,
                         L"MpPwd223304MpPwd2233305MpPwd223306...",
                         0xb,
                         1,
                         "test for net stuff",
                         TRUE,
                         &NumErrors );


    //
    //  Check diacritic followed by nonspace - NORM_IGNORENONSPACE.
    //

    //  Variation 1
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpNS1,
                         -1,
                         wCmpNS2,
                         -1,
                         2,
                         "diacritic, ignorenonspace, symbol",
                         FALSE,
                         &NumErrors );

    //  Variation 2
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpNS3,
                         -1,
                         wCmpNS4,
                         -1,
                         2,
                         "diacritic, ignorenonspace, punct 1",
                         FALSE,
                         &NumErrors );

    //  Variation 3
    CompareStringTester( Locale,
                         NORM_IGNORENONSPACE,
                         wCmpNS4,
                         -1,
                         wCmpNS3,
                         -1,
                         2,
                         "diacritic, ignorenonspace, punct 2",
                         FALSE,
                         &NumErrors );



    //
    //  Check French vs. English diacritic sorting.
    //

    //  Variation 1
    CompareStringTester( Locale,
                         0,
                         wCmpFrench1,
                         -1,
                         wCmpFrench2,
                         -1,
                         1,
                         "English diacritic sort 1",
                         TRUE,
                         &NumErrors );

    //  Variation 2
    CompareStringTester( Locale,
                         0,
                         wCmpFrench2,
                         -1,
                         wCmpFrench3,
                         -1,
                         1,
                         "English diacritic sort 2",
                         TRUE,
                         &NumErrors );

    //  Variation 3
    CompareStringTester( Locale,
                         0,
                         wCmpFrench1,
                         -1,
                         wCmpFrench3,
                         -1,
                         1,
                         "English diacritic sort 3",
                         TRUE,
                         &NumErrors );

    //  Variation 4
    CompareStringTester( MAKELCID(0x040C, 0),
                         0,
                         wCmpFrench1,
                         -1,
                         wCmpFrench2,
                         -1,
                         3,
                         "French diacritic sort 1",
                         TRUE,
                         &NumErrors );

    //  Variation 5
    CompareStringTester( MAKELCID(0x040C, 0),
                         0,
                         wCmpFrench2,
                         -1,
                         wCmpFrench3,
                         -1,
                         1,
                         "French diacritic sort 2",
                         TRUE,
                         &NumErrors );

    //  Variation 6
    CompareStringTester( MAKELCID(0x040C, 0),
                         0,
                         wCmpFrench1,
                         -1,
                         wCmpFrench3,
                         -1,
                         1,
                         "French diacritic sort 3",
                         TRUE,
                         &NumErrors );



    //
    //  Diacritic tests.
    //

    //   Variation 1
    CompareStringTester( Locale,
                         0,
                         L"\x00c4\x00c4",
                         -1,
                         L"\x00c4\x0041\x0308",
                         -1,
                         2,
                         "Diacritic - A diaeresis",
                         FALSE,
                         &NumErrors );

    //   Variation 2
    CompareStringTester( Locale,
                         0,
                         L"\x00c4\x00c4",
                         2,
                         L"\x00c4\x0041\x0308",
                         3,
                         2,
                         "Diacritic - A diaeresis (size)",
                         FALSE,
                         &NumErrors );

    //   Variation 3
    CompareStringTester( Locale,
                         0,
                         L"\x00c4\x01e0",
                         -1,
                         L"\x0041\x0308\x0041\x0307\x0304",
                         -1,
                         2,
                         "Diacritic - A dot macron",
                         FALSE,
                         &NumErrors );

    //   Variation 4
    CompareStringTester( Locale,
                         0,
                         L"\x00c4\x01e0",
                         2,
                         L"\x0041\x0308\x0041\x0307\x0304",
                         5,
                         2,
                         "Diacritic - A dot macron (size)",
                         FALSE,
                         &NumErrors );




    //
    //  Kana and Width Flags.
    //

    //  Variation 1  -  ignore kana
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2",
                         -1,
                         L"\x3051\x3052",
                         -1,
                         2,
                         "ignore kana (equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2",
                         2,
                         L"\x3051\x3052",
                         2,
                         2,
                         "ignore kana (equal) (size)",
                         TRUE,
                         &NumErrors );

    //  Variation 2  -  ignore kana
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2",
                         -1,
                         L"\x3051\x3051",
                         -1,
                         3,
                         "ignore kana (not equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2",
                         2,
                         L"\x3051\x3051",
                         2,
                         3,
                         "ignore kana (not equal) (size)",
                         TRUE,
                         &NumErrors );

    //  Variation 3  -  ignore width
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x30b1\x30b2",
                         -1,
                         L"\xff79\x30b2",
                         -1,
                         2,
                         "ignore width (equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x30b1\x30b2",
                         2,
                         L"\xff79\x30b2",
                         2,
                         2,
                         "ignore width (equal) (size)",
                         TRUE,
                         &NumErrors );

    //  Variation 4  -  ignore width
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x30b1\x30b2",
                         -1,
                         L"\xff7a\x30b2",
                         -1,
                         1,
                         "ignore width (not equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x30b1\x30b2",
                         2,
                         L"\xff7a\x30b2",
                         2,
                         1,
                         "ignore width (not equal) (size)",
                         TRUE,
                         &NumErrors );

    //  Variation 5  -  ignore kana, width
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2\xff76",
                         -1,
                         L"\xff79\x3052\x304b",
                         -1,
                         2,
                         "ignore kana width (equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2\xff76",
                         2,
                         L"\xff79\x3052\x304b",
                         2,
                         2,
                         "ignore kana width (equal) (size)",
                         TRUE,
                         &NumErrors );

    //  Variation 6  -  ignore kana, width
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2\xff77",
                         -1,
                         L"\xff79\x3052\x304b",
                         -1,
                         3,
                         "ignore kana width (not equal)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE,
                         L"\x30b1\x30b2\xff77",
                         3,
                         L"\xff79\x3052\x304b",
                         3,
                         3,
                         "ignore kana width (not equal) (size)",
                         TRUE,
                         &NumErrors );



    //
    //  Japanese tests - REPEAT.
    //

    // Variation 1 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30fd",
                         -1,
                         L"\x30f1\x30f1",
                         -1,
                         3,
                         "repeat same",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1",
                         -1,
                         L"\x30f1\x30fd",
                         -1,
                         1,
                         "repeat same 2",
                         TRUE,
                         &NumErrors );

    // Variation 2 - repeat (1st char)
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30fd\x30f1\x30fd",
                         -1,
                         L"\x30f1\x30f1",
                         -1,
                         3,
                         "repeat (1st char)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1",
                         -1,
                         L"\x30fd\x30f1\x30fd",
                         -1,
                         1,
                         "repeat (1st char) 2",
                         TRUE,
                         &NumErrors );

    // Variation 3 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30fd",
                         2,
                         L"\x30f1\x30f1",
                         2,
                         3,
                         "repeat same (size)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1",
                         2,
                         L"\x30f1\x30fd",
                         2,
                         1,
                         "repeat same (size) 2",
                         TRUE,
                         &NumErrors );

    // Variation 4 - repeat (1st char)
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30fd\x30f1\x30fd",
                         3,
                         L"\x30f1\x30f1",
                         2,
                         3,
                         "repeat same (1st char) (size)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1",
                         2,
                         L"\x30fd\x30f1\x30fd",
                         3,
                         1,
                         "repeat same (1st char) (size) 2",
                         TRUE,
                         &NumErrors );

    // Variation 5 - repeat (twice)
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30fd\x30fd",
                         -1,
                         L"\x30f1\x30f1\x30f1",
                         -1,
                         3,
                         "repeat (twice)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1\x30f1",
                         -1,
                         L"\x30f1\x30fd\x30fd",
                         -1,
                         1,
                         "repeat (twice) 2",
                         TRUE,
                         &NumErrors );

    // Variation 6 - repeat (unsortable)
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30fd\xfffe\x30fd",
                         -1,
                         L"\x30f1\x30f1\x30f1",
                         -1,
                         3,
                         "repeat (unsortable)",
                         FALSE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1\x30f1",
                         -1,
                         L"\x30f1\x30fd\xfffe\x30fd",
                         -1,
                         1,
                         "repeat (unsortable) 2",
                         FALSE,
                         &NumErrors );

    // Variation 7 - repeat (unsortable)
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30fd\xfffe\x30fd",
                         4,
                         L"\x30f1\x30f1\x30f1",
                         3,
                         3,
                         "repeat (unsortable) (size)",
                         FALSE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f1\x30f1\x30f1",
                         3,
                         L"\x30f1\x30fd\xfffe\x30fd",
                         4,
                         1,
                         "repeat (unsortable) (size) 2",
                         FALSE,
                         &NumErrors );



    //
    //  Japanese tests - REPEAT with NORM_IGNORENONSPACE.
    //

    // Variation 1 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30ab\x30fe",
                         -1,
                         L"\x30ab\x30ab",
                         -1,
                         2,
                         "repeat same (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30ab\x30ab",
                         -1,
                         L"\x30ab\x30fe",
                         -1,
                         2,
                         "repeat same 2 (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 2 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30ab\x30fe",
                         2,
                         L"\x30ab\x30ab",
                         2,
                         2,
                         "repeat same (size) (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30ab\x30ab",
                         2,
                         L"\x30ab\x30fe",
                         2,
                         2,
                         "repeat same (size) 2 (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 3 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\x30fe",
                         -1,
                         L"\xff76\xff76",
                         -1,
                         2,
                         "repeat same half (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\xff76",
                         -1,
                         L"\xff76\x30fe",
                         -1,
                         2,
                         "repeat same 2 half (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 4 - repeat
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\x30fe",
                         2,
                         L"\xff76\xff76",
                         2,
                         2,
                         "repeat same (size) half (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\xff76",
                         2,
                         L"\xff76\x30fe",
                         2,
                         2,
                         "repeat same (size) 2 half (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 5 - repeat, vowel
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30b9\x30ba",
                         -1,
                         L"\x30b9\x30fe",
                         -1,
                         2,
                         "repeat vowel same (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30b9\x30fe",
                         -1,
                         L"\x30b9\x30ba",
                         -1,
                         2,
                         "repeat vowel same 2 (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 6 - repeat, vowel
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30b9\x30ba",
                         2,
                         L"\x30b9\x30fe",
                         2,
                         2,
                         "repeat vowel same (size) (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30b9\x30fe",
                         2,
                         L"\x30b9\x30ba",
                         2,
                         2,
                         "repeat vowel same (size) 2 (ignore nonspace)",
                         TRUE,
                         &NumErrors );





    //
    //  Japanese tests - CHO-ON.
    //

    // Variation 1 - cho-on
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f4\x30fc",
                         -1,
                         L"\x30f4\x30f4",
                         -1,
                         1,
                         "cho-on",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f4\x30f4",
                         -1,
                         L"\x30f4\x30fc",
                         -1,
                         3,
                         "cho-on 2",
                         TRUE,
                         &NumErrors );

    // Variation 2 - cho-on (ignore nonspace)
    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30f4\x30fc",
                         -1,
                         L"\x30f4\x30f4",
                         -1,
                         2,
                         "cho-on (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30f4\x30f4",
                         -1,
                         L"\x30f4\x30fc",
                         -1,
                         2,
                         "cho-on 2 (ignore nonspace)",
                         TRUE,
                         &NumErrors );

    // Variation 3 - cho-on, katakana N
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f3\x30fc",
                         -1,
                         L"\x30f3\x30f3",
                         -1,
                         3,
                         "cho-on, katakana N",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30f3\x30f3",
                         -1,
                         L"\x30f3\x30fc",
                         -1,
                         1,
                         "cho-on 2, katakana N",
                         TRUE,
                         &NumErrors );


    //
    //  Japanese tests - XJIS ordering.
    //
    CompareStringTester( MAKELCID(0x0411, SORT_JAPANESE_XJIS),
                         0,
                         L"\x337d",
                         -1,
                         L"\x337e",
                         -1,
                         3,
                         "XJIS order",
                         TRUE,
                         &NumErrors );


    //
    //  Chinese tests - BIG5 ordering.
    //
    CompareStringTester( MAKELCID(0x0404, SORT_CHINESE_BIG5),
                         0,
                         L"\x632f",
                         -1,
                         L"\x633e",
                         -1,
                         3,
                         "BIG5 order",
                         TRUE,
                         &NumErrors );


    //
    //  Korean tests - KSC ordering.
    //
    CompareStringTester( MAKELCID(0x0412, SORT_KOREAN_KSC),
                         0,
                         L"\x4e00",
                         -1,
                         L"\x4eba",
                         -1,
                         3,
                         "KSC order",
                         FALSE,
                         &NumErrors );


    //
    //  More Japanese Tests.
    //
    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x3042\x309b",
                         -1,
                         L"\x3042\xff9e",
                         -1,
                         2,
                         "Japanese Test 1",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x306f\x309c",
                         -1,
                         L"\x306f\xff9f",
                         -1,
                         2,
                         "Japanese Test 2",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\xff9e\xff71",
                         -1,
                         L"\xff76\xff9e\xff70",
                         -1,
                         2,
                         "Japanese Test 3",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff8a\xff9f\xff71",
                         -1,
                         L"\xff8a\xff9f\xff70",
                         -1,
                         2,
                         "Japanese Test 4",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff71\xff71",
                         -1,
                         L"\xff71\x30fd",
                         -1,
                         2,
                         "Japanese Test 5",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff71\xff71",
                         -1,
                         L"\xff71\x309d",
                         -1,
                         2,
                         "Japanese Test 6",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff67\xff71",
                         -1,
                         L"\xff67\x309e",
                         -1,
                         2,
                         "Japanese Test 7",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\xff76\xff9e",
                         -1,
                         L"\xff76\x30fe",
                         -1,
                         2,
                         "Japanese Test 8",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\xff76\xff76\xff9e",
                         -1,
                         L"\xff76\x309e",
                         -1,
                         2,
                         "Japanese Test 9",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\xffe3",
                         -1,
                         L"\x007e",
                         -1,
                         3,
                         "Japanese Test 10",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x2018",
                         -1,
                         L"\x0027",
                         -1,
                         3,
                         "Japanese Test 11",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x2019",
                         -1,
                         L"\x0027",
                         -1,
                         3,
                         "Japanese Test 12",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x201c",
                         -1,
                         L"\x0022",
                         -1,
                         3,
                         "Japanese Test 13",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\x201d",
                         -1,
                         L"\x0022",
                         -1,
                         3,
                         "Japanese Test 14",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\xffe5",
                         -1,
                         L"\x005c",
                         -1,
                         2,
                         "Japanese Test 15",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\xff70\x309b",
                         -1,
                         L"\xff70\xff9e",
                         -1,
                         2,
                         "Japanese Test 16",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\xff70\x309c",
                         -1,
                         L"\xff70\xff9f",
                         -1,
                         2,
                         "Japanese Test 17",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\x3000",
                         -1,
                         L"\x0020",
                         -1,
                         2,
                         "Japanese Test 18",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\x3001",
                         -1,
                         L"\xff64",
                         -1,
                         2,
                         "Japanese Test 19",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\x3002",
                         -1,
                         L"\xff61",
                         -1,
                         2,
                         "Japanese Test 20",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNORENONSPACE,
                         L"\x30ac\x30a2",
                         -1,
                         L"\xff76\xff9e\xff70",
                         -1,
                         2,
                         "Japanese Test 21",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH | NORM_IGNORENONSPACE | NORM_IGNOREKANATYPE,
                         L"\x30ac\x30a2",
                         -1,
                         L"\xff76\xff9e\xff70",
                         -1,
                         2,
                         "Japanese Test 22",
                         TRUE,
                         &NumErrors );


    //
    //  New Japanese Tests.
    //

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30cf\x30fc\x30c8",
                         -1,
                         L"\x30cf\x30a2\x30c8",
                         -1,
                         3,
                         "Cho-On test - 1",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30cf\x30fc\x30c8",
                         -1,
                         L"\x30cf\x30a2\x30c9",
                         -1,
                         1,
                         "Cho-On & Handaku/Daku-On - 2",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x3066\x3063",
                         -1,
                         L"\x3066\x3064",
                         -1,
                         1,
                         "BreathStop - 3",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x3066\x3063\x3071",
                         -1,
                         L"\x3066\x3064\x3070",
                         -1,
                         3,
                         "BreathStop & Handaku/Daku-On - 4",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30a2\x30a2",
                         -1,
                         L"\xff71\x3042",
                         -1,
                         1,
                         "Halfwidth & Hiragana/Katakana - 5",
                         TRUE,
                         &NumErrors );

    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\x3001",
                         -1,
                         L"\xff64",
                         -1,
                         2,
                         "ignore kana test - 6",
                         TRUE,
                         &NumErrors );




    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x3042\x309b",
                         -1,
                         L"\x3042\xff9e",
                         -1,
                         2,
                         "DakuOn (table) - 7",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x3042\x309c",
                         -1,
                         L"\x3042\xff9f",
                         -1,
                         2,
                         "HanDakuOn (table) - 8",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x3041",
                         -1,
                         L"\x3042",
                         -1,
                         2,
                         "IgnoreNonSpace - 9",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORECASE | NORM_IGNOREWIDTH,
                         L"\xffe3",
                         -1,
                         L"\x007e",
                         -1,
                         3,
                         "IgnoreCaseWidth - 10",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORECASE | NORM_IGNOREWIDTH,
                         L"\xff5e",
                         -1,
                         L"\x007e",
                         -1,
                         2,
                         "IgnoreCaseWidth - 11",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORECASE,
                         L"\xff71\xff70",
                         -1,
                         L"\x30a2\x2015",
                         -1,
                         1,
                         "IgnoreCase - 12",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                         L"\xff71\xff70",
                         -1,
                         L"\x30a2\x2015",
                         -1,
                         2,
                         "IgnoreKanaWidth - 13",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                         L"\xff71\xff70",
                         -1,
                         L"\x30a2\x30fc",
                         -1,
                         2,
                         "IgnoreKanaWidth - 14",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORESYMBOLS,
                         L"\xff70\x309b",
                         -1,
                         L"\xff70\xff9e",
                         -1,
                         2,
                         "IgnoreSymbol (table) - 15",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                         L"\x3041",
                         -1,
                         L"\x3042",
                         -1,
                         2,
                         "IgnoreWidthNonspaceKana - 16",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREWIDTH,
                         L"\xff67\xff70",
                         -1,
                         L"\x30a1\x30fc",
                         -1,
                         2,
                         "IgnoreWidth - 17",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                         L"\xff67\xff70",
                         -1,
                         L"\x30a1\x30fc",
                         -1,
                         2,
                         "IgnoreKanaWidth - 18",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x4e9c\x4e9c",
                         -1,
                         L"\x4e9c\x3005",
                         -1,
                         1,
                         "Ideograph, cho-on - 19",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x4e9c\x4e9c",
                         -1,
                         L"\x4e9c\x3005",
                         -1,
                         2,
                         "Ideograph, cho-on - 20",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         0,
                         L"\x30fb\x30fd",
                         -1,
                         L"\x30fb\x30fb",
                         -1,
                         1,
                         "Symbol, cho-on - 21",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x30fb\x30fd",
                         -1,
                         L"\x30fb\x30fb",
                         -1,
                         1,
                         "Symbol, cho-on - 22",
                         TRUE,
                         &NumErrors );


    CompareStringTester( MAKELCID(0x0411, 0),
                         NORM_IGNORENONSPACE,
                         L"\x308e\xff70",
                         -1,
                         L"\x308e\x30fc",
                         -1,
                         1,
                         "small cho-on (ignore nonspace) - 23",
                         TRUE,
                         &NumErrors );


    //
    //  Tests with extra diacritic on end of string.  Make sure it
    //  uses the first diacritic difference found rather than the
    //  "longer" string difference.
    //
    CompareStringTester( 0x0411,
                         0,
                         L"\x30cf\xff8a\xff9e",
                         -1,
                         L"\xff8a\xff9e\x30cf",
                         -1,
                         1,
                         "Different Compares",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0411,
                         NORM_IGNOREWIDTH,
                         L"\x30cf\xff8a\xff9e",
                         -1,
                         L"\xff8a\xff9e\x30cf",
                         -1,
                         1,
                         "Different Compares (ignore width)",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0411,
                         NORM_IGNORENONSPACE,
                         L"\x30cf\xff8a\xff9e",
                         -1,
                         L"\xff8a\xff9e\x30cf",
                         -1,
                         3,
                         "Different Compares (ignore nonspace)",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0411,
                         NORM_IGNORENONSPACE | NORM_IGNOREWIDTH,
                         L"\x30cf\xff8a\xff9e",
                         -1,
                         L"\xff8a\xff9e\x30cf",
                         -1,
                         2,
                         "Different Compares (ignore nonspace, width)",
                         FALSE,
                         &NumErrors );



    //
    //  Tests for Extension A.
    //
    CompareStringTester( 0x0409,
                         0,
                         L"\x3400",
                         -1,
                         L"\x3401",
                         -1,
                         1,
                         "Extension A - 1",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0409,
                         0,
                         L"ABC \x3400 ABC",
                         -1,
                         L"ABC \x3401 abc",
                         -1,
                         1,
                         "Extension A - 2",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0409,
                         NORM_IGNORECASE,
                         L"\x3400",
                         -1,
                         L"\x3401",
                         -1,
                         1,
                         "Extension A - 3",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0409,
                         NORM_IGNORECASE,
                         L"ABC \x3400 ABC",
                         -1,
                         L"ABC \x3401 abc",
                         -1,
                         1,
                         "Extension A - 4",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0409,
                         NORM_IGNORENONSPACE,
                         L"\x3400",
                         -1,
                         L"\x3401",
                         -1,
                         1,
                         "Extension A - 5",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0409,
                         NORM_IGNORENONSPACE,
                         L"ABC \x3400 ABC",
                         -1,
                         L"ABC \x3401 abc",
                         -1,
                         1,
                         "Extension A - 6",
                         FALSE,
                         &NumErrors );


    //
    //  Tests for Old Hangul.
    //
    CompareStringTester( 0x0412,
                         0,
                         L"\x1100\x1161\x11a8\x11ab",   // Old Hangul
                         -1,
                         L"\x1102\x1161",               // Modern Hangul in Jamo form
                         -1,
                         1,
                         "Old Hangul - 1",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0412,
                         0,
                         L"\xae4c",                     // Modern Hangul
                         -1,
                         L"\x1100\x1103\x1161\x11A8",   // Old Hangul
                         -1,
                         1,
                         "Old Hangul - 2",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0412,
                         0,
                         L"\x1100\x1103\x1161\x11A8",   // Old Hangul
                         -1,
                         L"\xb098",                     // Modern Hangul
                         -1,
                         1,
                         "Old Hangul - 3",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0412,
                         0,
                         L"\xae4c",                     // Modern Hangul
                         -1,
                         L"\xb098",                     // Modern Hangul
                         -1,
                         1,
                         "Old Hangul - 4",
                         FALSE,
                         &NumErrors );

    CompareStringTester( 0x0412,
                         0,
                         L"\x1100\x1103\x1161\x11A8",                   // Old Hangul
                         -1,
                         L"x115f\x1161\x11A8",             // Old Hangul with Hangul Choseong Filler (U+115f)
                         -1,
                         1,
                         "Old Hangul - 5",
                         FALSE,
                         &NumErrors );


    CompareStringTester( 0x0412,
                         0,
                         L"\x1100\x1103\x1161\x1160\x11A8",             // Old Hangul with Hangul Jungseong Filler (U+1160)
                         -1,
                         L"\x1100\x1103\x1161\x11A8",                   // Old Hangul
                         -1,
                         1,
                         "Old Hangul - 6",
                         FALSE,
                         &NumErrors );

    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CS_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CS_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  CompareStringA is tested by CompareStringTester routine.
    //


    //
    //  CompareString
    //

    //  Variation 1  -  foo bar
    rc = CompareString( Locale,
                        0,
                        TEXT("foo"),
                        -1,
                        TEXT("bar"),
                        -1 );
    CheckReturnCompStr( rc,
                        3,
                        "neutral version (foo, bar)",
                        &NumErrors );

    //  Variation 2  -  foo bar
    rc = CompareString( Locale,
                        0,
                        TEXT("foo"),
                        3,
                        TEXT("bar"),
                        3 );
    CheckReturnCompStr( rc,
                        3,
                        "neutral version (foo, bar) size",
                        &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnCompStr
//
//  Checks the return code from the CompareString[A/W] call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnCompStr(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors)
{
    if (CurrentReturn != ExpectedReturn)
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CompareSortkeyStrings
//
//  Checks that the result of the byte by byte compare of the sortkey strings
//  is the expected result.  It prints out the appropriate error if the
//  incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CompareSortkeyStrings(
    LPBYTE pSort1,
    LPBYTE pSort2,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors)
{
    int CurrentReturn;            // current return value
    int ctr;                      // loop counter


    CurrentReturn = strcmp(pSort1, pSort2) + 2;
    if (CurrentReturn != ExpectedReturn)
    {
        printf("ERROR: SortKey - %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        printf("   SortKey1 = ");
        for (ctr = 0; pSort1[ctr]; ctr++)
        {
            printf("%x ", pSort1[ctr]);
        }
        printf("\n");

        printf("   SortKey2 = ");
        for (ctr = 0; pSort2[ctr]; ctr++)
        {
            printf("%x ", pSort2[ctr]);
        }
        printf("\n");

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCPFromLocale
//
//  Gets the default code page for the given locale.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

UINT GetCPFromLocale(
    LCID Locale)
{
    WCHAR pBuf[BUFSIZE];
    LPWSTR pTmp;
    UINT CodePage;
    UINT Value;


    //
    //  Get the ACP.
    //
    if (!GetLocaleInfoW( Locale,
                         LOCALE_IDEFAULTANSICODEPAGE,
                         pBuf,
                         BUFSIZE ))
    {
        printf("FATAL ERROR: Could NOT get locale information for ACP.\n");
        return (0);
    }

    //
    //  Convert the string to an integer and return it.
    //
    pTmp = pBuf;
    for (CodePage = 0; *pTmp; pTmp++)
    {
        if ((Value = (UINT)(*pTmp - L'0')) > 9)
            break;
        CodePage = (UINT)(CodePage * 10 + Value);
    }
    return ( CodePage );
}


////////////////////////////////////////////////////////////////////////////
//
//  CompareStringTester
//
//  Call CompareStringW and CompareStringA and checks the return code.
//  It also calls LCMapStringW and LCMapStringA using the LCMAP_SORTKEY flag,
//  and then checks to be sure the byte by byte compare gives the same
//  result as CompareString.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CompareStringTester(
    LCID Locale,
    DWORD dwFlags,
    LPWSTR pString1,
    int Count1,
    LPWSTR pString2,
    int Count2,
    int ExpectedReturn,
    LPSTR pErrString,
    BOOL TestAVersion,
    int *pNumErrors)
{
    int rc;
    BYTE SortDest1[BUFSIZE];
    BYTE SortDest2[BUFSIZE];

    BYTE pString1A[BUFSIZE];
    BYTE pString2A[BUFSIZE];
    int Count1A;
    int Count2A;
    int Count1T = -1;
    int Count2T;


    //
    //  Call CompareStringW with the given counts.
    //
    rc = CompareStringW( Locale,
                         dwFlags,
                         pString1,
                         Count1,
                         pString2,
                         Count2 );
    CheckReturnCompStr( rc,
                        ExpectedReturn,
                        pErrString,
                        pNumErrors );


    //
    //  Call LCMapStringW with the given counts.
    //
    if ( (!LCMapStringW( Locale,
                         LCMAP_SORTKEY | dwFlags,
                         pString1,
                         Count1,
                         (LPWSTR)SortDest1,
                         BUFSIZE )) ||
         (!LCMapStringW( Locale,
                         LCMAP_SORTKEY | dwFlags,
                         pString2,
                         Count2,
                         (LPWSTR)SortDest2,
                         BUFSIZE )) )
    {
        printf("FATAL ERROR: Could NOT get SORTKEY value for string.\n");
        return;
    }

    CompareSortkeyStrings( SortDest1,
                           SortDest2,
                           ExpectedReturn,
                           pErrString,
                           pNumErrors );


    //
    //  See if we should make additional calls with the temp counts.
    //
    if ((Count1 < 0) || (Count2 < 0))
    {
        //
        //  Get the temp counts if either count is set to -1.  This is to make
        //  an additional call to CompareStringW with the actual count of the
        //  strings instead of -1.
        //
        Count1T = (Count1 < 0) ? wcslen(pString1) : Count1;
        Count2T = (Count2 < 0) ? wcslen(pString2) : Count2;


        //
        //  Call CompareStringW with the temp counts.
        //
        rc = CompareStringW( Locale,
                             dwFlags,
                             pString1,
                             Count1T,
                             pString2,
                             Count2T );
        CheckReturnCompStr( rc,
                            ExpectedReturn,
                            pErrString,
                            pNumErrors );


        //
        //  Call LCMapStringW with the temp counts.
        //
        if ( (!LCMapStringW( Locale,
                             LCMAP_SORTKEY | dwFlags,
                             pString1,
                             Count1T,
                             (LPWSTR)SortDest1,
                             BUFSIZE )) ||
             (!LCMapStringW( Locale,
                             LCMAP_SORTKEY | dwFlags,
                             pString2,
                             Count2T,
                             (LPWSTR)SortDest2,
                             BUFSIZE )) )
        {
            printf("FATAL ERROR: Could NOT get SORTKEY value for string.\n");
            return;
        }

        CompareSortkeyStrings( SortDest1,
                               SortDest2,
                               ExpectedReturn,
                               pErrString,
                               pNumErrors );
    }


    if (TestAVersion)
    {
        //
        //  Get the Ansi versions of the strings.
        //
        if ( ((Count1A = WideCharToMultiByte( GetCPFromLocale(Locale),
                                              0,
                                              pString1,
                                              Count1,
                                              pString1A,
                                              BUFSIZE,
                                              NULL,
                                              NULL )) == 0) ||
             ((Count2A = WideCharToMultiByte( GetCPFromLocale(Locale),
                                              0,
                                              pString2,
                                              Count2,
                                              pString2A,
                                              BUFSIZE,
                                              NULL,
                                              NULL )) == 0) )
        {
            printf("FATAL ERROR: Could NOT convert to MULTIBYTE string.\n");
            return;
        }


        //
        //  Call CompareStringA with the given counts.
        //
        rc = CompareStringA( Locale,
                             dwFlags,
                             pString1A,
                             (Count1 < 0) ? Count1 : Count1A,
                             pString2A,
                             (Count2 < 0) ? Count2 : Count2A );
        CheckReturnCompStr( rc,
                            ExpectedReturn,
                            pErrString,
                            pNumErrors );


        //
        //  Call LCMapStringA with the given counts.
        //
        if ( (!LCMapStringA( Locale,
                             LCMAP_SORTKEY | dwFlags,
                             pString1A,
                             (Count1 < 0) ? Count1 : Count1A,
                             (LPSTR)SortDest1,
                             BUFSIZE )) ||
             (!LCMapStringA( Locale,
                             LCMAP_SORTKEY | dwFlags,
                             pString2A,
                             (Count2 < 0) ? Count2 : Count2A,
                             (LPSTR)SortDest2,
                             BUFSIZE )) )
        {
            printf("FATAL ERROR: Could NOT get SORTKEY value for string.\n");
            return;
        }

        CompareSortkeyStrings( SortDest1,
                               SortDest2,
                               ExpectedReturn,
                               pErrString,
                               pNumErrors );

        //
        //  See if we should make additional calls with the temp counts.
        //
        if (Count1T != -1)
        {
            //
            //  Call CompareStringA with the temp counts.
            //
            rc = CompareStringA( Locale,
                                 dwFlags,
                                 pString1A,
                                 Count1A,
                                 pString2A,
                                 Count2A );
            CheckReturnCompStr( rc,
                                ExpectedReturn,
                                pErrString,
                                pNumErrors );


            //
            //  Call LCMapStringA with the given counts.
            //
            if ( (!LCMapStringA( Locale,
                                 LCMAP_SORTKEY | dwFlags,
                                 pString1A,
                                 Count1A,
                                 (LPSTR)SortDest1,
                                 BUFSIZE )) ||
                 (!LCMapStringA( Locale,
                                 LCMAP_SORTKEY | dwFlags,
                                 pString2A,
                                 Count2A,
                                 (LPSTR)SortDest2,
                                 BUFSIZE )) )
            {
                printf("FATAL ERROR: Could NOT get SORTKEY value for string.\n");
                return;
            }

            CompareSortkeyStrings( SortDest1,
                                   SortDest2,
                                   ExpectedReturn,
                                   pErrString,
                                   pNumErrors );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\cpitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    cpitest.c

Abstract:

    Test module for NLS API GetCPInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Definitions.
//

#define CPI_UNICODE     1
#define CPI_ANSI        2




//
//  Forward Declarations.
//

int
CPI_BadParamCheck();

int
CPI_NormalCase();

BOOL
CheckInfoStruct(
    LPCPINFO pInfo,
    UINT MaxCharSize,
    DWORD fExVer);

BOOL
CheckDBCSInfoStruct(
    LPCPINFO pInfo,
    DWORD fExVer);

void
PrintInfoStruct(
    LPCPINFO pInfo,
    DWORD fExVer);

void
CheckReturnCPInfo(
    int CurrentReturn,
    LPCPINFO pCurrentInfo,
    BOOL fIfDBCSInfo,
    UINT MaxCharSize,
    LPSTR pErrString,
    DWORD fExVer,
    int *pNumErrors);





////////////////////////////////////////////////////////////////////////////
//
//  TestGetCPInfo
//
//  Test routine for GetCPInfo API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetCPInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetCPInfo...\n\n");

    //
    //  Test bad parameters.
    //
    ErrCount += CPI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += CPI_NormalCase();

    //
    //  Print out result.
    //
    printf("\nGetCPInfo:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPI_BadParamCheck
//
//  This routine passes in bad parameters to the API routine and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CPI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    BOOL rc;                      // return code
    CPINFO Info;                  // CPINFO structure
    CPINFOEXW InfoEx;             // CPINFOEXW structure
    CPINFOEXA InfoExA;            // CPINFOEXA structure


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpCPInfo = NULL
    rc = GetCPInfo( 1252,
                    NULL );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "lpCPInfo NULL",
                         &NumErrors );


    //
    //  Invalid Code Page.
    //

    //  Variation 1  -  CodePage = invalid
    rc = GetCPInfo( 5,
                    &Info );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "CodePage Invalid",
                         &NumErrors );


    //
    //  EX Version - Null Pointers.
    //

    //  Variation 1  -  lpCPInfo = NULL
    rc = GetCPInfoExW( 1252,
                       0,
                       NULL );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "Ex lpCPInfo NULL",
                         &NumErrors );

    rc = GetCPInfoExA( 1252,
                       0,
                       NULL );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "A version Ex lpCPInfo NULL",
                         &NumErrors );


    //
    //  EX Version - Invalid Code Page.
    //

    //  Variation 1  -  CodePage = invalid
    rc = GetCPInfoExW( 5,
                       0,
                       &InfoEx );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "CodePage Invalid",
                         &NumErrors );

    rc = GetCPInfoExA( 5,
                       0,
                       &InfoExA );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "A version CodePage Invalid",
                         &NumErrors );


    //
    //  EX Version - Invalid Flags.
    //

    //  Variation 1  -  Flags = invalid
    rc = GetCPInfoExW( 1252,
                       1,
                       &InfoEx );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "Flags Invalid",
                         &NumErrors );

    rc = GetCPInfoExA( 1252,
                       1,
                       &InfoExA );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "A version Flags Invalid",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CPI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    CPINFO Info;                  // CPINFO structure
    CPINFOEXW InfoEx;             // CPINFOEXW structure
    CPINFOEXA InfoExA;            // CPINFOEXA structure


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  CodePage defaults.
    //

    //  Variation 1  -  CodePage = CP_ACP
    rc = GetCPInfo( CP_ACP,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage CP_ACP",
                       0,
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_OEMCP
    rc = GetCPInfo( CP_OEMCP,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage CP_OEMCP",
                       0,
                       &NumErrors );


    //
    //  CodePage 1252.
    //

    //  Variation 1  -  CodePage = 1252
    rc = GetCPInfo( 1252,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage 1252",
                       0,
                       &NumErrors );


    //
    //  CodePage 437.
    //

    //  Variation 1  -  CodePage = 437
    rc = GetCPInfo( 437,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage 437",
                       0,
                       &NumErrors );


    //
    //  CodePage 850.
    //

    //  Variation 1  -  CodePage = 850
    rc = GetCPInfo( 850,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage 850",
                       0,
                       &NumErrors );


    //
    //  CodePage 10000.
    //

    //  Variation 1  -  CodePage = 10000
    rc = GetCPInfo( 10000,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       1,
                       "CodePage 10000",
                       0,
                       &NumErrors );


    //
    //  CodePage 932.
    //

    //  Variation 1  -  CodePage = 932
    rc = GetCPInfo( 932,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       TRUE,
                       2,
                       "CodePage 932",
                       0,
                       &NumErrors );


    //
    //  CodePage UTF 7.
    //

    //  Variation 1  -  CodePage = UTF 7
    rc = GetCPInfo( CP_UTF7,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       5,
                       "CodePage UTF 7",
                       0,
                       &NumErrors );


    //
    //  CodePage UTF 8.
    //

    //  Variation 1  -  CodePage = UTF 8
    rc = GetCPInfo( CP_UTF8,
                    &Info );
    CheckReturnCPInfo( rc,
                       &Info,
                       FALSE,
                       4,
                       "CodePage UTF 8",
                       0,
                       &NumErrors );


// -------------------------------------------------------------

    //
    //  Ex CodePage defaults.
    //

    //  Variation 1  -  CodePage = CP_ACP
    rc = GetCPInfoExW( CP_ACP,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage CP_ACP",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( CP_ACP,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage CP_ACP",
                       CPI_ANSI,
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_OEMCP
    rc = GetCPInfoExW( CP_OEMCP,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage CP_OEMCP",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( CP_OEMCP,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage CP_OEMCP",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage 1252.
    //

    //  Variation 1  -  CodePage = 1252
    rc = GetCPInfoExW( 1252,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage 1252",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( 1252,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage 1252",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage 437.
    //

    //  Variation 1  -  CodePage = 437
    rc = GetCPInfoExW( 437,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage 437",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( 437,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage 437",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage 850.
    //

    //  Variation 1  -  CodePage = 850
    rc = GetCPInfoExW( 850,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage 850",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( 850,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage 850",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage 10000.
    //

    //  Variation 1  -  CodePage = 10000
    rc = GetCPInfoExW( 10000,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       1,
                       "CodePage 10000",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( 10000,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       1,
                       "A version CodePage 10000",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage 932.
    //

    //  Variation 1  -  CodePage = 932
    rc = GetCPInfoExW( 932,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       TRUE,
                       2,
                       "CodePage 932",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( 932,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       TRUE,
                       2,
                       "A version CodePage 932",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage UTF 7.
    //

    //  Variation 1  -  CodePage = UTF 7
    rc = GetCPInfoExW( CP_UTF7,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       5,
                       "CodePage UTF 7",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( CP_UTF7,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       5,
                       "A version CodePage UTF 7",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  CodePage UTF 8.
    //

    //  Variation 1  -  CodePage = UTF 8
    rc = GetCPInfoExW( CP_UTF8,
                       0,
                       &InfoEx );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoEx,
                       FALSE,
                       4,
                       "CodePage UTF 8",
                       CPI_UNICODE,
                       &NumErrors );

    rc = GetCPInfoExA( CP_UTF8,
                       0,
                       &InfoExA );
    CheckReturnCPInfo( rc,
                       (LPCPINFO)&InfoExA,
                       FALSE,
                       4,
                       "A version CodePage UTF 8",
                       CPI_ANSI,
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckInfoStruct
//
//  This routine checks the CPINFO structure to be sure the values are
//  consistent with code page 1252.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL CheckInfoStruct(
    LPCPINFO pInfo,
    UINT MaxCharSize,
    DWORD fExVer)
{
    int ctr;                      // loop counter


    //
    //  Check MaxCharSize field.
    //
    if (pInfo->MaxCharSize != MaxCharSize)
    {
        printf("ERROR: MaxCharSize = %x\n", pInfo->MaxCharSize);
        return (FALSE);
    }

    //
    //  Check DefaultChar field.
    //
    if (((pInfo->DefaultChar)[0] != (BYTE)0x3f) &&
        ((pInfo->DefaultChar)[1] != (BYTE)0))
    {
        printf("ERROR: DefaultChar = '%s'\n", pInfo->DefaultChar);
        return (FALSE);
    }

    //
    //  Check LeadByte field.
    //
    for (ctr = 0; ctr < MAX_LEADBYTES; ctr++)
    {
        if (pInfo->LeadByte[ctr] != 0)
        {
            printf("ERROR: LeadByte not 0 - ctr = %x\n", ctr);
            return (FALSE);
        }
    }

    //
    //  See if Ex version.
    //
    if (fExVer)
    {
        if (fExVer == CPI_ANSI)
        {
            LPCPINFOEXA pInfoA = (LPCPINFOEXA)pInfo;

            //
            //  Check UnicodeDefaultChar field.
            //
            if (pInfoA->UnicodeDefaultChar != L'?')
            {
                printf("ERROR: UnicodeDefaultChar = '%x'\n", pInfoA->UnicodeDefaultChar);
                return (FALSE);
            }
        }
        else if (fExVer == CPI_UNICODE)
        {
            LPCPINFOEXW pInfoW = (LPCPINFOEXW)pInfo;

            //
            //  Check UnicodeDefaultChar field.
            //
            if (pInfoW->UnicodeDefaultChar != L'?')
            {
                printf("ERROR: UnicodeDefaultChar = '%x'\n", pInfoW->UnicodeDefaultChar);
                return (FALSE);
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckDBCSInfoStruct
//
//  This routine checks the CPINFO structure to be sure the values are
//  consistent with code page 932.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL CheckDBCSInfoStruct(
    LPCPINFO pInfo,
    DWORD fExVer)
{
    int ctr;                      // loop counter


    //
    //  Check MaxCharSize field.
    //
    if (pInfo->MaxCharSize != 2)
    {
        printf("ERROR: MaxCharSize = %x\n", pInfo->MaxCharSize);
        return (FALSE);
    }

    //
    //  Check DefaultChar field.
    //
    if ((pInfo->DefaultChar)[0] != (BYTE)0x3f)
    {
        printf("ERROR: DefaultChar = '%s'\n", pInfo->DefaultChar);
        return (FALSE);
    }

    //
    //  Check LeadByte field.
    //
    if ( ((pInfo->LeadByte)[0] != 0x81) ||
         ((pInfo->LeadByte)[1] != 0x9f) ||
         ((pInfo->LeadByte)[2] != 0xe0) ||
         ((pInfo->LeadByte)[3] != 0xfc) )
    {
        printf("ERROR: LeadByte not correct\n");
        return (FALSE);
    }
    for (ctr = 4; ctr < MAX_LEADBYTES; ctr++)
    {
        if (pInfo->LeadByte[ctr] != 0)
        {
            printf("ERROR: LeadByte not 0 - ctr = %x\n", ctr);
            return (FALSE);
        }
    }

    //
    //  See if Ex version.
    //
    if (fExVer)
    {
        if (fExVer == CPI_ANSI)
        {
            LPCPINFOEXA pInfoA = (LPCPINFOEXA)pInfo;

            //
            //  Check UnicodeDefaultChar field.
            //
            if (pInfoA->UnicodeDefaultChar != 0x30fb)
            {
                printf("ERROR: UnicodeDefaultChar = '%x'\n", pInfoA->UnicodeDefaultChar);
                return (FALSE);
            }
        }
        else if (fExVer == CPI_UNICODE)
        {
            LPCPINFOEXW pInfoW = (LPCPINFOEXW)pInfo;

            //
            //  Check UnicodeDefaultChar field.
            //
            if (pInfoW->UnicodeDefaultChar != 0x30fb)
            {
                printf("ERROR: UnicodeDefaultChar = '%x'\n", pInfoW->UnicodeDefaultChar);
                return (FALSE);
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInfoStruct
//
//  This routine prints out the CPINFO structure.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void PrintInfoStruct(
    LPCPINFO pInfo,
    DWORD fExVer)
{
    int ctr;                      // loop counter


    //
    //  Print out MaxCharSize field.
    //
    printf("         MaxCharSize = %x\n",     pInfo->MaxCharSize);

    //
    //  Print out DefaultChar field.
    //
    printf("         DefaultChar = %x  %x\n",
            (pInfo->DefaultChar)[0], (pInfo->DefaultChar)[1] );

    //
    //  Print out LeadByte field.
    //
    for (ctr = 0; ctr < MAX_LEADBYTES; ctr += 2)
    {
        printf("         LeadByte    = %x  %x\n",
                pInfo->LeadByte[ctr], pInfo->LeadByte[ctr + 1]);
    }

    //
    //  See if we have the Ex version.
    //
    if (fExVer)
    {
        if (fExVer == CPI_ANSI)
        {
            LPCPINFOEXA pInfoA = (LPCPINFOEXA)pInfo;

            printf("         UnicodeDefaultChar = %x\n", pInfoA->UnicodeDefaultChar);
            printf("         CodePage = %d\n", pInfoA->CodePage);
            printf("         CodePageName = %s\n", pInfoA->CodePageName);
        }
        else if (fExVer == CPI_UNICODE)
        {
            LPCPINFOEXW pInfoW = (LPCPINFOEXW)pInfo;

            printf("         UnicodeDefaultChar = %x\n", pInfoW->UnicodeDefaultChar);
            printf("         CodePage = %d\n", pInfoW->CodePage);
            printf("         CodePageName = %ws\n", pInfoW->CodePageName);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnCPInfo
//
//  Checks the return code from the GetCPInfo call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnCPInfo(
    int CurrentReturn,
    LPCPINFO pCurrentInfo,
    BOOL fIfDBCSInfo,
    UINT MaxCharSize,
    LPSTR pErrString,
    DWORD fExVer,
    int *pNumErrors)
{
    if ( (CurrentReturn == FALSE) ||
         ( (fIfDBCSInfo == FALSE)
           ? (!CheckInfoStruct(pCurrentInfo, MaxCharSize, fExVer))
           : (!CheckDBCSInfoStruct(pCurrentInfo, fExVer)) ) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = 0\n", CurrentReturn);
        printf("  LastError = %d, Expected = 0\n", GetLastError());

        PrintInfoStruct(pCurrentInfo, fExVer);

        (*pNumErrors)++;
    }
    else if (Verbose)
    {
        PrintInfoStruct(pCurrentInfo, fExVer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\eslgtest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    eslgtest.c

Abstract:

    Test module for NLS API EnumSystemLanguageGroups.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    03-10-98    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE              50            // buffer size in wide chars
#define  ESLG_INVALID_FLAGS   ((DWORD)(~(LGRPID_INSTALLED | LGRPID_SUPPORTED)))

#define  NUM_INSTALLED_LGRPIDS  17
#define  NUM_SUPPORTED_LGRPIDS  17




//
//  Global Variables.
//

int LanguageGroupCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumSystemLanguageGroups();

int
ESLG_BadParamCheck();

int
ESLG_NormalCase();

int
ESLG_Ansi();

BOOL
CALLBACK
MyFuncLanguageGroup(
    LGRPID LangGroup,
    LPWSTR pStr1,
    LPWSTR pStr2,
    DWORD dwFlags,
    LONG_PTR lParam);

BOOL
CALLBACK
MyFuncLanguageGroupA(
    LGRPID LangGroup,
    LPSTR pStr1,
    LPSTR pStr2,
    DWORD dwFlags,
    LONG_PTR lParam);




//
//  Callback function
//

BOOL CALLBACK MyFuncLanguageGroup(
    LGRPID LangGroup,
    LPWSTR pStr1,
    LPWSTR pStr2,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        while (*pStr1)
        {
            printf((*pStr1 > 0xff) ? "(0x%x)" : "%wc", *pStr1);
            pStr1++;
        }
        printf("    -    ");
        while (*pStr2)
        {
            printf((*pStr2 > 0xff) ? "(0x%x)" : "%wc", *pStr2);
            pStr2++;
        }
        printf("    -    ");
        if (dwFlags & LGRPID_SUPPORTED)
        {
            printf("Supported");
        }
        if (dwFlags & LGRPID_INSTALLED)
        {
            printf("Installed");
        }
        printf("\n");
    }

    LanguageGroupCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncLanguageGroupA(
    LGRPID LangGroup,
    LPSTR pStr1,
    LPSTR pStr2,
    DWORD dwFlags,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        while (*pStr1)
        {
            printf((*pStr1 > 0xff) ? "(0x%x)" : "%c", *pStr1);
            pStr1++;
        }
        printf("    -    ");
        while (*pStr2)
        {
            printf((*pStr2 > 0xff) ? "(0x%x)" : "%c", *pStr2);
            pStr2++;
        }
        printf("    -    ");
        if (dwFlags & LGRPID_SUPPORTED)
        {
            printf("Supported");
        }
        if (dwFlags & LGRPID_INSTALLED)
        {
            printf("Installed");
        }
        printf("\n");
    }

    LanguageGroupCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumSystemLanguageGroups
//
//  Test routine for EnumSystemLanguageGroupsW API.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumSystemLanguageGroups()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumSystemLanguageGroupsW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumSystemLanguageGroups())
    {
        printf("\nABORTED TestEnumSystemLanguageGroups: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ESLG_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ESLG_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ESLG_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumSystemLanguageGroupsW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumSystemLanguageGroups
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumSystemLanguageGroups()
{
    //
    //  Initialize locale counter.
    //
    LanguageGroupCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESLG_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESLG_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  Invalid Function.
    //

    //  Variation 1  -  Function = invalid
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsW( NULL,
                                    LGRPID_INSTALLED,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             LanguageGroupCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsW( MyFuncLanguageGroup,
                                    ESLG_INVALID_FLAGS,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             LanguageGroupCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsW( MyFuncLanguageGroup,
                                    LGRPID_INSTALLED | LGRPID_SUPPORTED,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             LanguageGroupCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESLG_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESLG_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  Installed
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsW( MyFuncLanguageGroup,
                                    LGRPID_INSTALLED,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LanguageGroupCtr,
                          NUM_INSTALLED_LGRPIDS,
                          "Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsW( MyFuncLanguageGroup,
                                    LGRPID_SUPPORTED,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LanguageGroupCtr,
                          NUM_SUPPORTED_LGRPIDS,
                          "Flag supported",
                          &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESLG_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESLG_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  installed
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsA( MyFuncLanguageGroupA,
                                    LGRPID_INSTALLED,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LanguageGroupCtr,
                          NUM_INSTALLED_LGRPIDS,
                          "A version Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    LanguageGroupCtr = 0;
    rc = EnumSystemLanguageGroupsA( MyFuncLanguageGroupA,
                                    LGRPID_SUPPORTED,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LanguageGroupCtr,
                          NUM_SUPPORTED_LGRPIDS,
                          "A version Flag supported",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\esltest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    esltest.c

Abstract:

    Test module for NLS API EnumSystemLocales.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE              50            // buffer size in wide chars
#define  ESL_INVALID_FLAGS    ((DWORD)(~(LCID_INSTALLED | LCID_SUPPORTED)))

#define  NUM_INSTALLED_LCIDS  135
#define  NUM_SUPPORTED_LCIDS  135
#define  NUM_ALTERNATE_SORTS  7




//
//  Global Variables.
//

int LocaleCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumSystemLocales();

int
ESL_BadParamCheck();

int
ESL_NormalCase();

int
ESL_Ansi();

BOOL
CALLBACK
MyFuncLocale(
    LPWSTR pStr);

BOOL
CALLBACK
MyFuncLocaleA(
    LPSTR pStr);




//
//  Callback function
//

BOOL CALLBACK MyFuncLocale(
    LPWSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
//            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            printf("%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    LocaleCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncLocaleA(
    LPSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    LocaleCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumSystemLocales
//
//  Test routine for EnumSystemLocalesW API.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumSystemLocales()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumSystemLocalesW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumSystemLocales())
    {
        printf("\nABORTED TestEnumSystemLocales: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ESL_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ESL_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ESL_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumSystemLocalesW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumSystemLocales
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumSystemLocales()
{
    //
    //  Initialize locale counter.
    //
    LocaleCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESL_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESL_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  Invalid Function.
    //

    //  Variation 1  -  Function = invalid
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( NULL,
                             LCID_INSTALLED );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    LocaleCtr = 0;
    rc = EnumSystemLocalesW(MyFuncLocale, ESL_INVALID_FLAGS);
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    LocaleCtr = 0;
    rc = EnumSystemLocalesW(MyFuncLocale, LCID_INSTALLED | LCID_SUPPORTED);
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESL_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESL_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  Installed
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( MyFuncLocale,
                             LCID_INSTALLED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_INSTALLED_LCIDS,
                          "Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( MyFuncLocale,
                             LCID_SUPPORTED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_SUPPORTED_LCIDS,
                          "Flag supported",
                          &NumErrors );

    //  Variation 3  -  Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( MyFuncLocale,
                             LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_ALTERNATE_SORTS,
                          "Flag alternate sorts",
                          &NumErrors );


    //  Variation 4  -  Installed, Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( MyFuncLocale,
                             LCID_INSTALLED | LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_INSTALLED_LCIDS + NUM_ALTERNATE_SORTS,
                          "Flag installed, alternate sorts",
                          &NumErrors );


    //  Variation 5  -  Supported, Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesW( MyFuncLocale,
                             LCID_SUPPORTED | LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_SUPPORTED_LCIDS + NUM_ALTERNATE_SORTS,
                          "Flag supported, alternate sorts",
                          &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESL_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESL_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  installed
    LocaleCtr = 0;
    rc = EnumSystemLocalesA( MyFuncLocaleA,
                             LCID_INSTALLED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_INSTALLED_LCIDS,
                          "A version Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    LocaleCtr = 0;
    rc = EnumSystemLocalesA( MyFuncLocaleA,
                             LCID_SUPPORTED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_SUPPORTED_LCIDS,
                          "A version Flag supported",
                          &NumErrors );

    //  Variation 3  -  Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesA( MyFuncLocaleA,
                             LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_ALTERNATE_SORTS,
                          "A version Flag alternate sorts",
                          &NumErrors );


    //  Variation 4  -  Installed, Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesA( MyFuncLocaleA,
                             LCID_INSTALLED | LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_INSTALLED_LCIDS + NUM_ALTERNATE_SORTS,
                          "A version Flag installed, alternate sorts",
                          &NumErrors );


    //  Variation 5  -  Supported, Alternate Sorts
    LocaleCtr = 0;
    rc = EnumSystemLocalesA( MyFuncLocaleA,
                             LCID_SUPPORTED | LCID_ALTERNATE_SORTS );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_SUPPORTED_LCIDS + NUM_ALTERNATE_SORTS,
                          "A version Flag supported, alternate sorts",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\dbtest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    dbtest.c

Abstract:

    Test module for NLS API IsDBCSLeadByte and IsDBCSLeadByteEx.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Forward Declarations.
//

int
DB_BadParamCheck();

int
DB_NormalCase();

void
CheckReturnIsDBCS(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors);





////////////////////////////////////////////////////////////////////////////
//
//  TestIsDBCSLeadByte
//
//  Test routine for IsDBCSLeadByte API.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int TestIsDBCSLeadByte()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING IsDBCSLeadByte and IsDBCSLeadByteEx...\n\n");

    //
    //  Test bad parameters.
    //
    ErrCount += DB_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += DB_NormalCase();

    //
    //  Print out result.
    //
    printf("\nIsDBCSLeadByte:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  DB_BadParamCheck
//
//  This routine passes in bad parameters to the API routine and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int DB_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    BYTE ch;                      // character to check
    BOOL rc;                      // return code


    //
    //  Invalid Code Page.
    //

    //  Variation 1  -  CodePage = invalid
    ch = 0x00;
    rc = IsDBCSLeadByteEx(5, ch);
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "CodePage invalid",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  DB_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int DB_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    BYTE ch;                      // character to check
    BOOL rc;                      // return code


#ifdef PERF

  DbgBreakPoint();

#endif

    //--------------------//
    //  IsDBCSLeadByte    //
    //--------------------//


    //
    //  Different values for ch.
    //

    //  Variation 1  -  ch = 0x00
    ch = 0x00;
    rc = IsDBCSLeadByte(ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "ch = 0x00",
                       &NumErrors );

    //  Variation 2  -  ch = 0x23
    ch = 0x23;
    rc = IsDBCSLeadByte(ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "ch = 0x23",
                       &NumErrors );

    //  Variation 3  -  ch = 0xb3
    ch = 0xb3;
    rc = IsDBCSLeadByte(ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "ch = 0xb3",
                       &NumErrors );

    //  Variation 4  -  ch = 0xff
    ch = 0xff;
    rc = IsDBCSLeadByte(ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "ch = 0xff",
                       &NumErrors );



#ifdef JDB

    //
    //  DBCS Chars for Japanese - cp 932.
    //

    //  Variation 1  -  DBCS lead byte  0x81
    rc = IsDBCSLeadByte(0x81);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0x81",
                       &NumErrors );

    //  Variation 2  -  DBCS lead byte  0x85
    rc = IsDBCSLeadByte(0x85);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0x85",
                       &NumErrors );

    //  Variation 3  -  DBCS lead byte  0x9f
    rc = IsDBCSLeadByte(0x9f);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0x9f",
                       &NumErrors );

    //  Variation 4  -  DBCS lead byte  0xe0
    rc = IsDBCSLeadByte(0xe0);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0xe0",
                       &NumErrors );

    //  Variation 5  -  DBCS lead byte  0xfb
    rc = IsDBCSLeadByte(0xfb);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0xfb",
                       &NumErrors );

    //  Variation 6  -  DBCS lead byte  0xfc
    rc = IsDBCSLeadByte(0xfc);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "DBCS 0xfc",
                       &NumErrors );



    //
    //  Non DBCS Chars for Japanese - cp 932.
    //

    //  Variation 1  -  Non DBCS lead byte  0x80
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Non DBCS lead byte  0x80",
                       &NumErrors );

    //  Variation 2  -  Non DBCS lead byte  0xfd
    rc = IsDBCSLeadByte(0xfd);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Non DBCS lead byte  0xfd",
                       &NumErrors );

    //  Variation 3  -  Non DBCS lead byte  0xa0
    rc = IsDBCSLeadByte(0xa0);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Non DBCS lead byte  0xa0",
                       &NumErrors );

    //  Variation 4  -  Non DBCS lead byte  0xdf
    rc = IsDBCSLeadByte(0xdf);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Non DBCS lead byte  0xdf",
                       &NumErrors );

#endif



    //--------------------//
    //  IsDBCSLeadByteEx  //
    //--------------------//


    //
    //  Different values for ch.
    //

    //  Variation 1  -  ch = 0x00
    ch = 0x00;
    rc = IsDBCSLeadByteEx(1252, ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex ch = 0x00",
                       &NumErrors );

    //  Variation 2  -  ch = 0x23
    ch = 0x23;
    rc = IsDBCSLeadByteEx(1252, ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex ch = 0x23",
                       &NumErrors );

    //  Variation 3  -  ch = 0xb3
    ch = 0xb3;
    rc = IsDBCSLeadByteEx(1252, ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex ch = 0xb3",
                       &NumErrors );

    //  Variation 4  -  ch = 0xff
    ch = 0xff;
    rc = IsDBCSLeadByteEx(1252, ch);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex ch = 0xff",
                       &NumErrors );



    //
    //  DBCS Chars for Japanese - cp 932.
    //

    //  Variation 1  -  DBCS lead byte  0x81
    rc = IsDBCSLeadByteEx(932, 0x81);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0x81",
                       &NumErrors );

    //  Variation 2  -  DBCS lead byte  0x85
    rc = IsDBCSLeadByteEx(932, 0x85);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0x85",
                       &NumErrors );

    //  Variation 3  -  DBCS lead byte  0x9f
    rc = IsDBCSLeadByteEx(932, 0x9f);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0x9f",
                       &NumErrors );

    //  Variation 4  -  DBCS lead byte  0xe0
    rc = IsDBCSLeadByteEx(932, 0xe0);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0xe0",
                       &NumErrors );

    //  Variation 5  -  DBCS lead byte  0xfb
    rc = IsDBCSLeadByteEx(932, 0xfb);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0xfb",
                       &NumErrors );

    //  Variation 6  -  DBCS lead byte  0xfc
    rc = IsDBCSLeadByteEx(932, 0xfc);
    CheckReturnIsDBCS( rc,
                       TRUE,
                       "Ex DBCS 0xfc",
                       &NumErrors );



    //
    //  Non DBCS Chars for Japanese - cp 932.
    //

    //  Variation 1  -  Non DBCS lead byte  0x80
    rc = IsDBCSLeadByteEx(932, 0x80);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex Non DBCS lead byte  0x80",
                       &NumErrors );

    //  Variation 2  -  Non DBCS lead byte  0xfd
    rc = IsDBCSLeadByteEx(932, 0xfd);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex Non DBCS lead byte  0xfd",
                       &NumErrors );

    //  Variation 3  -  Non DBCS lead byte  0xa0
    rc = IsDBCSLeadByteEx(932, 0xa0);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex Non DBCS lead byte  0xa0",
                       &NumErrors );

    //  Variation 4  -  Non DBCS lead byte  0xdf
    rc = IsDBCSLeadByteEx(932, 0xdf);
    CheckReturnIsDBCS( rc,
                       FALSE,
                       "Ex Non DBCS lead byte  0xdf",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnIsDBCS
//
//  Checks the return code from the IsDBCSLeadByte call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnIsDBCS(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors)
{
    if ( (CurrentReturn != ExpectedReturn) ||
         ( (CurrentReturn == FALSE) &&
           (GetLastError() == ERROR_FILE_NOT_FOUND) ) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        (*pNumErrors)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\ecitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    ecitest.c

Abstract:

    Test module for NLS API EnumCalendarInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  ECI_INVALID_FLAG       0x00000100




//
//  Global Variables.
//

int CalendarCtr;


CALTYPE pCalFlag[] =
{
    CAL_ICALINTVALUE,
    CAL_SCALNAME,
    CAL_ITWODIGITYEARMAX,
    CAL_IYEAROFFSETRANGE,
    CAL_SERASTRING,
    CAL_SSHORTDATE,
    CAL_SLONGDATE,
    CAL_SYEARMONTH,
    CAL_SDAYNAME1,
    CAL_SMONTHNAME1,
    CAL_SMONTHNAME13
};
#define NUM_CAL_FLAGS  ( sizeof(pCalFlag) / sizeof(CALTYPE) )


//
//  pCalEnglish and pCalJapan_x must have the same number of entries
//  as pCalFlag.
//
int pCalEnglish[] =
{
    1,
    1,
    1,
    0,
    0,
    7,
    4,
    1,
    1,
    1,
    0
};

int pCalJapan_All[] =
{
    3,
    3,
    3,
    4,
    4,
    20,
    14,
    3,
    2,
    2,
    0
};

int pCalJapan_1[] =
{
    1,
    1,
    1,
    0,
    0,
    8,
    4,
    1,
    1,
    1,
    0
};

int pCalJapan_2[] =
{
    1,
    1,
    1,
    0,
    0,
    4,
    2,
    1,
    1,
    1,
    0
};

int pCalJapan_3[] =
{
    1,
    1,
    1,
    4,
    4,
    8,
    8,
    1,
    1,
    1,
    0
};




//
//  Forward Declarations.
//

BOOL
InitEnumCalendarInfo();

int
ECI_BadParamCheck();

int
ECI_NormalCase();

int
ECI_Ansi();

BOOL
CALLBACK
MyFuncCalendar(
    LPWSTR pStr);

BOOL
CALLBACK
MyFuncCalendarA(
    LPSTR pStr);

BOOL
CALLBACK
MyFuncCalendarEx(
    LPWSTR pStr,
    CALID CalId);

BOOL
CALLBACK
MyFuncCalendarExA(
    LPSTR pStr,
    CALID CalId);




//
//  Callback functions.
//

BOOL CALLBACK MyFuncCalendar(
    LPWSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CalendarCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncCalendarA(
    LPSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CalendarCtr++;

    return (TRUE);
}


//
//  Callback functions for EX version.
//

BOOL CALLBACK MyFuncCalendarEx(
    LPWSTR pStr,
    CALID CalId)
{
    if (Verbose)
    {
        printf("CalId = %d\n", CalId);

        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CalendarCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncCalendarExA(
    LPSTR pStr,
    CALID CalId)
{
    if (Verbose)
    {
        printf("CalId = %d\n", CalId);

        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CalendarCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumCalendarInfo
//
//  Test routine for EnumCalendarInfoW API.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumCalendarInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumCalendarInfoW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumCalendarInfo())
    {
        printf("\nABORTED TestEnumCalendarInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ECI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ECI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ECI_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumCalendarInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumCalendarInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumCalendarInfo()
{
    //
    //  Initialize date counter.
    //
    CalendarCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ECI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ECI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Function.
    //

    //  Variation 1  -  bad function
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( NULL,
                            0x0409,
                            ENUM_ALL_CALENDARS,
                            CAL_ICALINTVALUE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "function invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( NULL,
                              0x0409,
                              ENUM_ALL_CALENDARS,
                              CAL_ICALINTVALUE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Ex function invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );


    //
    //  Bad Locale.
    //

    //  Variation 1  -  bad locale
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            (LCID)333,
                            ENUM_ALL_CALENDARS,
                            CAL_ICALINTVALUE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Locale invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              (LCID)333,
                              ENUM_ALL_CALENDARS,
                              CAL_ICALINTVALUE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Ex Locale invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            0x0409,
                            ENUM_ALL_CALENDARS,
                            ECI_INVALID_FLAG );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              0x0409,
                              ENUM_ALL_CALENDARS,
                              ECI_INVALID_FLAG );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Ex Flag invalid",
                             &NumErrors,
                             CalendarCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ECI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ECI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //
    //  Single calendar id - English.
    //

    //  Variation 1  -  iCalIntValue - English
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            0x0409,
                            0,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "iCalIntValue English (cal 0)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              0x0409,
                              0,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex iCalIntValue English (cal 0)",
                          &NumErrors );

    //  Variation 2  -  iCalIntValue - English
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            0x0409,
                            2,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "iCalIntValue English (cal 2)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              0x0409,
                              2,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex iCalIntValue English (cal 2)",
                          &NumErrors );

    //  Variation 3  -  Use CP ACP
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            0x0409,
                            2,
                            CAL_ICALINTVALUE | LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Use CP ACP",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              0x0409,
                              2,
                              CAL_ICALINTVALUE | LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex Use CP ACP",
                          &NumErrors );


    //
    //  CALTYPE values - English.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0409,
                                1,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "English (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0409,
                                  1,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "Ex English (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }



    //
    //  Single calendar id - Japan.
    //

    //  Variation 1  -  iCalIntValue - Japan
    CalendarCtr = 0;
    rc = EnumCalendarInfoW( MyFuncCalendar,
                            0x0411,
                            0,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "iCalIntValue Japan (cal 0)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                              0x0411,
                              0,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex iCalIntValue Japan (cal 0)",
                          &NumErrors );



    //
    //  CALTYPE values - Japan.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                1,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_1[ctr],
                                  "Japan (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  1,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_1[ctr],
                                  "Ex Japan (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                2,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_2[ctr],
                                  "Japan (cal 2) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  2,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_2[ctr],
                                  "Ex Japan (cal 2) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                3,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_3[ctr],
                                  "Japan (cal 3) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  3,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_3[ctr],
                                  "Ex Japan (cal 3) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }



    //
    //  English - Enumerate ALL Calendars.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "English (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "Ex English (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "Ex English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "Ex English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }



    //
    //  Japan - Enumerate ALL Calendars.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_All[ctr],
                                  "Japan (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_All[ctr],
                                  "Ex Japan (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Ex Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoW( MyFuncCalendar,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExW( MyFuncCalendarEx,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Ex Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ECI_Ansi
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ECI_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //
    //  Single calendar id - English.
    //

    //  Variation 1  -  iCalIntValue - English
    CalendarCtr = 0;
    rc = EnumCalendarInfoA( MyFuncCalendarA,
                            0x0409,
                            0,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "A version iCalIntValue English (cal 0)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                              0x0409,
                              0,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex A version iCalIntValue English (cal 0)",
                          &NumErrors );

    //  Variation 2  -  iCalIntValue - English
    CalendarCtr = 0;
    rc = EnumCalendarInfoA( MyFuncCalendarA,
                            0x0409,
                            2,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "A version iCalIntValue English (cal 2)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                              0x0409,
                              2,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex A version iCalIntValue English (cal 2)",
                          &NumErrors );

    //  Variation 3  -  Use CP ACP
    CalendarCtr = 0;
    rc = EnumCalendarInfoA( MyFuncCalendarA,
                            0x0409,
                            0,
                            CAL_ICALINTVALUE | LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "A version Use CP ACP",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                              0x0409,
                              0,
                              CAL_ICALINTVALUE | LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex A version Use CP ACP",
                          &NumErrors );


    //
    //  CALTYPE values - English.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0409,
                                1,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "A version English (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0409,
                                  1,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "Ex A version English (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }



    //
    //  Single calendar id - Japan.
    //

    //  Variation 1  -  iCalIntValue - Japan
    CalendarCtr = 0;
    rc = EnumCalendarInfoA( MyFuncCalendarA,
                            0x0411,
                            0,
                            CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "A version iCalIntValue Japan (cal 0)",
                          &NumErrors );

    CalendarCtr = 0;
    rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                              0x0411,
                              0,
                              CAL_ICALINTVALUE );
    CheckReturnValidEnum( rc,
                          FALSE,
                          CalendarCtr,
                          0,
                          "Ex A version iCalIntValue Japan (cal 0)",
                          &NumErrors );



    //
    //  CALTYPE values - Japan.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                1,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_1[ctr],
                                  "A version Japan (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  1,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_1[ctr],
                                  "Ex A version Japan (cal 1) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                2,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_2[ctr],
                                  "A version Japan (cal 2) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  2,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_2[ctr],
                                  "Ex A version Japan (cal 2) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                3,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_3[ctr],
                                  "A version Japan (cal 3) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  3,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_3[ctr],
                                  "Ex A version Japan (cal 3) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }



    //
    //  English - Enumerate ALL Calendars.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "A version English (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalEnglish[ctr],
                                  "Ex A version English (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "A version English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "Ex A version English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0409,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "A version English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0409,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  1,
                                  "Ex A version English (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }



    //
    //  Japan - Enumerate ALL Calendars.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_All[ctr],
                                  "A version Japan (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  pCalFlag[ctr] );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  pCalJapan_All[ctr],
                                  "Ex A version Japan (all cal) Calendar Flag",
                                  pCalFlag[ctr],
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "A version Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SDAYNAME1; ctr <= CAL_SMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Ex A version Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoA( MyFuncCalendarA,
                                0x0411,
                                ENUM_ALL_CALENDARS,
                                ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "A version Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }

    for (ctr = CAL_SABBREVMONTHNAME1; ctr <= CAL_SABBREVMONTHNAME12; ctr++)
    {
        CalendarCtr = 0;
        rc = EnumCalendarInfoExA( MyFuncCalendarExA,
                                  0x0411,
                                  ENUM_ALL_CALENDARS,
                                  ctr );
        CheckReturnValidEnumLoop( rc,
                                  TRUE,
                                  CalendarCtr,
                                  2,
                                  "Ex A version Japan (all cal) Day/Month Calendar Flag",
                                  ctr,
                                  &NumErrors );
    }



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\elgltest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    elgltest.c

Abstract:

    Test module for NLS API EnumLanguageGroupLocales.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    03-10-98    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE              50            // buffer size in wide chars
#define  ELGL_INVALID_FLAGS   ((DWORD)(~(0)))

#define  NUM_LG1_LOCALES      67
#define  NUM_LG2_LOCALES      10
#define  NUM_LG3_LOCALES      3
#define  NUM_LG4_LOCALES      1
#define  NUM_LG5_LOCALES      12
#define  NUM_LG6_LOCALES      3
#define  NUM_LG7_LOCALES      1
#define  NUM_LG8_LOCALES      1
#define  NUM_LG9_LOCALES      5
#define  NUM_LG10_LOCALES     4
#define  NUM_LG11_LOCALES     1
#define  NUM_LG12_LOCALES     1
#define  NUM_LG13_LOCALES     20
#define  NUM_LG14_LOCALES     1
#define  NUM_LG15_LOCALES     9
#define  NUM_LG16_LOCALES     2
#define  NUM_LG17_LOCALES     1




//
//  Global Variables.
//

int LocaleCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumLanguageGroupLocales();

int
ELGL_BadParamCheck();

int
ELGL_NormalCase();

int
ELGL_Ansi();

BOOL
CALLBACK
MyFuncLanguageGroupLocale(
    LGRPID LangGroup,
    LCID Locale,
    LPWSTR pStr,
    LONG_PTR lParam);

BOOL
CALLBACK
MyFuncLanguageGroupLocaleA(
    LGRPID LangGroup,
    LCID Locale,
    LPSTR pStr,
    LONG_PTR lParam);




//
//  Callback function
//

BOOL CALLBACK MyFuncLanguageGroupLocale(
    LGRPID LangGroup,
    LCID Locale,
    LPWSTR pStr,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        printf("%x", LangGroup);
        printf("    -    ");
        printf("%x", Locale);
        printf("    -    ");
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    LocaleCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncLanguageGroupLocaleA(
    LGRPID LangGroup,
    LCID Locale,
    LPSTR pStr,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        printf("%x", LangGroup);
        printf("    -    ");
        printf("%x", Locale);
        printf("    -    ");
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    LocaleCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumLanguageGroupLocales
//
//  Test routine for EnumLanguageGroupLocalesW API.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumLanguageGroupLocales()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumLanguageGroupLocalesW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumLanguageGroupLocales())
    {
        printf("\nABORTED TestEnumLanguageGroupLocales: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ELGL_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ELGL_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ELGL_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumLanguageGroupLocalesW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumLanguageGroupLocales
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumLanguageGroupLocales()
{
    //
    //  Initialize locale counter.
    //
    LocaleCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ELGL_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ELGL_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  Invalid Function.
    //

    //  Variation 1  -  Function = invalid
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( NULL,
                                    1,
                                    0,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    1,
                                    ELGL_INVALID_FLAGS,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    1,
                                    LGRPID_INSTALLED | LGRPID_SUPPORTED,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             LocaleCtr,
                             0 );


    //
    //  Invalid Language Group.
    //

    //  Variation 1  -  LanguageGroup = invalid
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    0,
                                    0,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "LanguageGroup invalid (0)",
                             &NumErrors,
                             LocaleCtr,
                             0 );

    //  Variation 2  -  LanguageGroup = invalid
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    18,
                                    0,
                                    0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "LanguageGroup invalid (18)",
                             &NumErrors,
                             LocaleCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ELGL_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ELGL_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  Language Group 1
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    1,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG1_LOCALES,
                          "LanguageGroup 1",
                          &NumErrors );

    //  Variation 2  -  Language Group 2
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    2,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG2_LOCALES,
                          "LanguageGroup 2",
                          &NumErrors );

    //  Variation 3  -  Language Group 3
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    3,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG3_LOCALES,
                          "LanguageGroup 3",
                          &NumErrors );

    //  Variation 4  -  Language Group 4
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    4,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG4_LOCALES,
                          "LanguageGroup 4",
                          &NumErrors );

    //  Variation 5  -  Language Group 5
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    5,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG5_LOCALES,
                          "LanguageGroup 5",
                          &NumErrors );

    //  Variation 6  -  Language Group 6
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    6,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG6_LOCALES,
                          "LanguageGroup 6",
                          &NumErrors );

    //  Variation 7  -  Language Group 7
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    7,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG7_LOCALES,
                          "LanguageGroup 7",
                          &NumErrors );

    //  Variation 8  -  Language Group 8
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    8,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG8_LOCALES,
                          "LanguageGroup 8",
                          &NumErrors );

    //  Variation 9  -  Language Group 9
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    9,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG9_LOCALES,
                          "LanguageGroup 9",
                          &NumErrors );

    //  Variation 10  -  Language Group 10
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    10,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG10_LOCALES,
                          "LanguageGroup 10",
                          &NumErrors );

    //  Variation 11  -  Language Group 11
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    11,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG11_LOCALES,
                          "LanguageGroup 11",
                          &NumErrors );

    //  Variation 12  -  Language Group 12
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    12,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG12_LOCALES,
                          "LanguageGroup 12",
                          &NumErrors );

    //  Variation 13  -  Language Group 13
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    13,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG13_LOCALES,
                          "LanguageGroup 13",
                          &NumErrors );

    //  Variation 14  -  Language Group 14
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    14,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG14_LOCALES,
                          "LanguageGroup 14",
                          &NumErrors );

    //  Variation 15  -  Language Group 15
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    15,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG15_LOCALES,
                          "LanguageGroup 15",
                          &NumErrors );

    //  Variation 16  -  Language Group 16
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    16,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG16_LOCALES,
                          "LanguageGroup 16",
                          &NumErrors );

    //  Variation 17  -  Language Group 17
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesW( MyFuncLanguageGroupLocale,
                                    17,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG17_LOCALES,
                          "LanguageGroup 17",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ELGL_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ELGL_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  Language Group 1
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    1,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG1_LOCALES,
                          "A version Language Group 1",
                          &NumErrors );

    //  Variation 2  -  Language Group 2
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    2,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG2_LOCALES,
                          "A version Language Group 2",
                          &NumErrors );

    //  Variation 3  -  Language Group 3
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    3,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG3_LOCALES,
                          "A version Language Group 3",
                          &NumErrors );

    //  Variation 4  -  Language Group 4
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    4,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG4_LOCALES,
                          "A version Language Group 4",
                          &NumErrors );

    //  Variation 5  -  Language Group 5
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    5,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG5_LOCALES,
                          "A version Language Group 5",
                          &NumErrors );

    //  Variation 6  -  Language Group 6
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    6,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG6_LOCALES,
                          "A version Language Group 6",
                          &NumErrors );

    //  Variation 7  -  Language Group 7
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    7,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG7_LOCALES,
                          "A version Language Group 7",
                          &NumErrors );

    //  Variation 8  -  Language Group 8
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    8,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG8_LOCALES,
                          "A version Language Group 8",
                          &NumErrors );

    //  Variation 9  -  Language Group 9
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    9,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG9_LOCALES,
                          "A version Language Group 9",
                          &NumErrors );

    //  Variation 10  -  Language Group 10
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    10,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG10_LOCALES,
                          "A version Language Group 10",
                          &NumErrors );

    //  Variation 11  -  Language Group 11
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    11,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG11_LOCALES,
                          "A version Language Group 11",
                          &NumErrors );

    //  Variation 12  -  Language Group 12
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    12,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG12_LOCALES,
                          "A version Language Group 12",
                          &NumErrors );

    //  Variation 13  -  Language Group 13
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    13,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG13_LOCALES,
                          "A version Language Group 13",
                          &NumErrors );

    //  Variation 14  -  Language Group 14
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    14,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG14_LOCALES,
                          "A version Language Group 14",
                          &NumErrors );

    //  Variation 15  -  Language Group 15
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    15,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG15_LOCALES,
                          "A version Language Group 15",
                          &NumErrors );

    //  Variation 16  -  Language Group 16
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    16,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG16_LOCALES,
                          "A version Language Group 16",
                          &NumErrors );

    //  Variation 17  -  Language Group 17
    LocaleCtr = 0;
    rc = EnumLanguageGroupLocalesA( MyFuncLanguageGroupLocaleA,
                                    17,
                                    0,
                                    0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          LocaleCtr,
                          NUM_LG17_LOCALES,
                          "A version Language Group 17",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\edftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    edftest.c

Abstract:

    Test module for NLS API EnumDateFormats.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  EDF_INVALID_FLAGS      ((DWORD)(~(DATE_SHORTDATE | DATE_LONGDATE |  \
                                           DATE_YEARMONTH)))

#define  NUM_SHORT_DATES_ENGLISH  7
#define  NUM_LONG_DATES_ENGLISH   4
#define  NUM_YEAR_MONTH_ENGLISH   1

#define  NUM_SHORT_DATES_JAPAN    20
#define  NUM_LONG_DATES_JAPAN     14
#define  NUM_YEAR_MONTH_JAPAN     3




//
//  Global Variables.
//

int DateCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumDateFormats();

int
EDF_BadParamCheck();

int
EDF_NormalCase();

int
EDF_Ansi();

BOOL
CALLBACK
MyFuncDate(
    LPWSTR pStr);

BOOL
CALLBACK
MyFuncDateA(
    LPSTR pStr);

BOOL
CALLBACK
MyFuncDateEx(
    LPWSTR pStr,
    CALID CalId);

BOOL
CALLBACK
MyFuncDateExA(
    LPSTR pStr,
    CALID CalId);




//
//  Callback functions.
//

BOOL CALLBACK MyFuncDate(
    LPWSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    DateCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncDateA(
    LPSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    DateCtr++;

    return (TRUE);
}


//
//  Callback functions for EX version.
//

BOOL CALLBACK MyFuncDateEx(
    LPWSTR pStr,
    CALID CalId)
{
    if (Verbose)
    {
        printf("CalId = %d\n", CalId);

        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    DateCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncDateExA(
    LPSTR pStr,
    CALID CalId)
{
    if (Verbose)
    {
        printf("CalId = %d\n", CalId);

        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    DateCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumDateFormats
//
//  Test routine for EnumDateFormatsW API.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumDateFormats()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumDateFormatsW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumDateFormats())
    {
        printf("\nABORTED TestEnumDateFormats: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += EDF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += EDF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += EDF_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumDateFormatsW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumDateFormats
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumDateFormats()
{
    //
    //  Initialize date counter.
    //
    DateCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EDF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EDF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Function.
    //

    //  Variation 1  -  bad function
    DateCtr = 0;
    rc = EnumDateFormatsW( NULL,
                           0x0409,
                           DATE_SHORTDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( NULL,
                             0x0409,
                             DATE_SHORTDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Ex Function invalid",
                             &NumErrors,
                             DateCtr,
                             0 );


    //
    //  Bad Locale.
    //

    //  Variation 1  -  bad locale
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           (LCID)333,
                           DATE_SHORTDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Locale invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             (LCID)333,
                             DATE_SHORTDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Ex Locale invalid",
                             &NumErrors,
                             DateCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           EDF_INVALID_FLAGS );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             EDF_INVALID_FLAGS );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Ex Flag invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           DATE_SHORTDATE | DATE_LONGDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           DATE_SHORTDATE | DATE_YEARMONTH );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid 2",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             DATE_SHORTDATE | DATE_LONGDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Ex Flag both invalid",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             DATE_SHORTDATE | DATE_YEARMONTH );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Ex Flag both invalid 2",
                             &NumErrors,
                             DateCtr,
                             0 );

    //  Variation 3  -  dwFlags = 2 invalid and Use CP ACP
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           LOCALE_USE_CP_ACP |
                           DATE_SHORTDATE | DATE_LONGDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag 2 invalid, Use CP ACP",
                             &NumErrors,
                             DateCtr,
                             0 );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             LOCALE_USE_CP_ACP |
                             DATE_SHORTDATE | DATE_LONGDATE );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Ex Flag 2 invalid, Use CP ACP",
                             &NumErrors,
                             DateCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  EDF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EDF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  short date
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "short date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "Ex short date English",
                          &NumErrors );

    //  Variation 2  -  short date
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0411,
                           DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_JAPAN,
                          "short date Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0411,
                             DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_JAPAN,
                          "Ex short date Japan",
                          &NumErrors );

    //  Variation 3  -  long date
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_ENGLISH,
                          "long date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_ENGLISH,
                          "Ex long date English",
                          &NumErrors );

    //  Variation 4  -  long date
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0411,
                           DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_JAPAN,
                          "long date Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0411,
                             DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_JAPAN,
                          "Ex long date Japan",
                          &NumErrors );

    //  Variation 5  -  year month
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_ENGLISH,
                          "year month English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_ENGLISH,
                          "Ex year month English",
                          &NumErrors );

    //  Variation 6  -  year month
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0411,
                           DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_JAPAN,
                          "year month Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0411,
                             DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_JAPAN,
                          "Ex year month Japan",
                          &NumErrors );



    //
    //   Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP
    DateCtr = 0;
    rc = EnumDateFormatsW( MyFuncDate,
                           0x0409,
                           LOCALE_USE_CP_ACP | DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "Use CP ACP, short date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExW( MyFuncDateEx,
                             0x0409,
                             LOCALE_USE_CP_ACP | DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "Ex Use CP ACP, short date English",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  EDF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EDF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  short date
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0409,
                           DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "A version short date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0409,
                             DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "Ex A version short date English",
                          &NumErrors );

    //  Variation 2  -  short date
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0411,
                           DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_JAPAN,
                          "A version short date Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0411,
                             DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_JAPAN,
                          "Ex A version short date Japan",
                          &NumErrors );

    //  Variation 3  -  long date
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0409,
                           DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_ENGLISH,
                          "A version short date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0409,
                             DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_ENGLISH,
                          "Ex A version short date English",
                          &NumErrors );

    //  Variation 4  -  long date
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0411,
                           DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_JAPAN,
                          "A version long date Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0411,
                             DATE_LONGDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_LONG_DATES_JAPAN,
                          "Ex A version long date Japan",
                          &NumErrors );

    //  Variation 5  -  year month
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0409,
                           DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_ENGLISH,
                          "A version year month English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0409,
                             DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_ENGLISH,
                          "Ex A version year month English",
                          &NumErrors );

    //  Variation 5  -  year month
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0411,
                           DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_JAPAN,
                          "A version year month Japan",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0411,
                             DATE_YEARMONTH );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_YEAR_MONTH_JAPAN,
                          "Ex A version year month Japan",
                          &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP
    DateCtr = 0;
    rc = EnumDateFormatsA( MyFuncDateA,
                           0x0409,
                           LOCALE_USE_CP_ACP | DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "A version Use CP ACP, short date English",
                          &NumErrors );

    DateCtr = 0;
    rc = EnumDateFormatsExA( MyFuncDateExA,
                             0x0409,
                             LOCALE_USE_CP_ACP | DATE_SHORTDATE );
    CheckReturnValidEnum( rc,
                          TRUE,
                          DateCtr,
                          NUM_SHORT_DATES_ENGLISH,
                          "Ex A version Use CP ACP, short date English",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\esgitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    esgitest.c

Abstract:

    Test module for NLS API EnumSystemGeoID.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    09-12-2000    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  ESGI_INVALID_FLAG        3
#define  NUM_SUPPORTED_GEOIDS     260




//
//  Global Variables.
//

int GeoCtr;
int EnumErrors;




//
//  Forward Declarations.
//

BOOL
InitEnumSystemGeoID();

int
ESGI_BadParamCheck();

int
ESGI_NormalCase();

BOOL
CALLBACK
MyFuncGeo(
    GEOID GeoId);




//
//  Callback function.
//

BOOL CALLBACK MyFuncGeo(
    GEOID GeoId)
{
    TCHAR pData[128];

    pData[0] = 0;
    if (GetGeoInfoW( GeoId,
                     GEO_FRIENDLYNAME,
                     pData,
                     sizeof(pData) / sizeof(TCHAR),
                     0 ) == 0)
    {
        printf("GetGeoInfo failed during Enum for GeoId %d\n", GeoId);
        EnumErrors++;
    }
    else if (pData[0] == 0)
    {
        printf("GetGeoInfo returned null string during Enum for GeoId %d\n", GeoId);
        EnumErrors++;
    }

    if (Verbose)
    {
        printf("%d - %ws\n", GeoId, pData);
    }

    GeoCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumSystemGeoID
//
//  Test routine for EnumSystemGeoID API.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumSystemGeoID()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumSystemGeoID...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumSystemGeoID())
    {
        printf("\nABORTED TestEnumSystemGeoID: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ESGI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ESGI_NormalCase();

    //
    //  Print out result.
    //
    printf("\nEnumSystemGeoID:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumSystemGeoID
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumSystemGeoID()
{
    //
    //  Initialize geo counter.
    //
    GeoCtr = 0;

    //
    //  Initialize enum error counter.
    //
    EnumErrors = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESGI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESGI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  Invalid Function.
    //

    //  Variation 1  -  Function = invalid
    GeoCtr = 0;
    EnumErrors = 0;
    rc = EnumSystemGeoID(GEOCLASS_NATION, 0, NULL);
    NumErrors += EnumErrors;
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             GeoCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    GeoCtr = 0;
    EnumErrors = 0;
    rc = EnumSystemGeoID(ESGI_INVALID_FLAG, 0, MyFuncGeo);
    NumErrors += EnumErrors;
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             GeoCtr,
                             0 );

    //  Variation 2  -  dwFlags = invalid 2
    GeoCtr = 0;
    EnumErrors = 0;
    rc = EnumSystemGeoID(GEOCLASS_REGION, 0, MyFuncGeo);
    NumErrors += EnumErrors;
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid 2",
                             &NumErrors,
                             GeoCtr,
                             0 );


    //
    //  NOTE:  There is no validation on ParentGeoId.  This parameter
    //         isn't used.
    //


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESGI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESGI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //  Variation 1  -  Installed
    GeoCtr = 0;
    EnumErrors = 0;
    rc = EnumSystemGeoID(GEOCLASS_NATION, 0, MyFuncGeo);
    NumErrors += EnumErrors;
    CheckReturnValidEnum( rc,
                          TRUE,
                          GeoCtr,
                          NUM_SUPPORTED_GEOIDS,
                          "GeoClass Nation",
                          &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\escptest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    escptest.c

Abstract:

    Test module for NLS API EnumSystemCodePages.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             50             // buffer size in wide chars
#define  ESCP_INVALID_FLAGS  ((DWORD)(~(CP_INSTALLED | CP_SUPPORTED)))

#define  NUM_INSTALLED_CPS   93
#define  NUM_SUPPORTED_CPS   134




//
//  Global Variables.
//

int CodePageCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumSystemCodePages();

int
ESCP_BadParamCheck();

int
ESCP_NormalCase();

int
ESCP_Ansi();

BOOL
CALLBACK
MyFuncCP(
    LPWSTR pStr);

BOOL
CALLBACK
MyFuncCPA(
    LPSTR pStr);




//
//  Callback function
//

BOOL CALLBACK MyFuncCP(
    LPWSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CodePageCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncCPA(
    LPSTR pStr)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    CodePageCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumSystemCodePages
//
//  Test routine for EnumSystemCodePagesW API.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumSystemCodePages()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumSystemCodePagesW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumSystemCodePages())
    {
        printf("\nABORTED TestEnumSystemCodePages: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ESCP_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ESCP_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ESCP_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumSystemCodePagesW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumSystemCodePages
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumSystemCodePages()
{
    //
    //  Initialize code page counter.
    //
    CodePageCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESCP_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESCP_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Invalid Function.
    //

    //  Variation 1  -  function = invalid
    CodePageCtr = 0;
    rc = EnumSystemCodePagesW( NULL,
                               CP_INSTALLED );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             CodePageCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    CodePageCtr = 0;
    rc = EnumSystemCodePagesW( MyFuncCP,
                               ESCP_INVALID_FLAGS );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             CodePageCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    CodePageCtr = 0;
    rc = EnumSystemCodePagesW( MyFuncCP,
                               CP_INSTALLED | CP_SUPPORTED );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             CodePageCtr,
                             0 );

    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESCP_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESCP_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  installed
    CodePageCtr = 0;
    rc = EnumSystemCodePagesW( MyFuncCP,
                               CP_INSTALLED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          CodePageCtr,
                          NUM_INSTALLED_CPS,
                          "Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    CodePageCtr = 0;
    rc = EnumSystemCodePagesW( MyFuncCP,
                               CP_SUPPORTED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          CodePageCtr,
                          NUM_SUPPORTED_CPS,
                          "Flag supported",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ESCP_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ESCP_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  installed
    CodePageCtr = 0;
    rc = EnumSystemCodePagesA( MyFuncCPA,
                               CP_INSTALLED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          CodePageCtr,
                          NUM_INSTALLED_CPS,
                          "A version Flag installed",
                          &NumErrors );

    //  Variation 2  -  Supported
    CodePageCtr = 0;
    rc = EnumSystemCodePagesA( MyFuncCPA,
                               CP_SUPPORTED );
    CheckReturnValidEnum( rc,
                          TRUE,
                          CodePageCtr,
                          NUM_SUPPORTED_CPS,
                          "A version Flag supported",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gcftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gcftest.c

Abstract:

    Test module for NLS API GetCurrencyFormat.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    07-28-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             500            // buffer size in wide chars
#define  GCF_INVALID_FLAGS   ((DWORD)(~(LOCALE_NOUSEROVERRIDE)))

#define GCF_ENGLISH_US       L"$1,234,567.44"
#define GCF_CZECH            L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 K\x010d"




//
//  Global Variables.
//

LCID Locale;

LPWSTR pValue;
LPWSTR pNegValue;

CURRENCYFMT CurrFmt;

WCHAR lpCurrencyStr[BUFSIZE];


//
//  Currency format buffers must be in line with the pAllLocales global
//  buffer.
//
LPWSTR pPosCurrency[] =
{
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x043b\x0432",  //  0x0402
    L"NT$1,234,567.44",                                                    //  0x0404
    L"\xffe5\x0031,234,567.44",                                            //  0x0804
    L"HK$1,234,567.44",                                                    //  0x0c04
    L"$1,234,567.44",                                                      //  0x1004
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 K\x010d",       //  0x0405
    L"kr 1.234.567,44",                                                    //  0x0406
    L"1.234.567,44 \x20ac",                                                //  0x0407
    L"SFr. 1'234'567.44",                                                  //  0x0807
    L"\x20ac 1.234.567,44",                                                //  0x0c07
    L"1.234.567,44 \x20ac",                                                //  0x0408
    L"$1,234,567.44",                                                      //  0x0409
    L"1,234,567.44",                                                      //  0x0809
    L"$1,234,567.44",                                                      //  0x0c09
    L"$1,234,567.44",                                                      //  0x1009
    L"$1,234,567.44",                                                      //  0x1409
    L"\x20ac\x0031,234,567.44",                                            //  0x1809
    L"1.234.567,44 \x20ac",                                                //  0x040a
    L"$1,234,567.44",                                                      //  0x080a
    L"1.234.567,44 \x20ac",                                                //  0x0c0a
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x20ac",        //  0x040b
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x20ac",        //  0x040c
    L"1.234.567,44 \x20ac",                                                //  0x080c
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 $",             //  0x0c0c
    L"SFr. 1'234'567.44",                                                  //  0x100c
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 Ft",            //  0x040e
    L"1.234.567,44 kr.",                                                   //  0x040f
    L"\x20ac 1.234.567,44",                                                //  0x0410
    L"SFr. 1'234'567.44",                                                  //  0x0810
    L"\x00a5\x0031,234,567",                                               //  0x0411
    L"\x20a9\x0031,234,567",                                               //  0x0412
    L"\x20ac 1.234.567,44",                                                //  0x0413
    L"1.234.567,44 \x20ac",                                                //  0x0813
    L"kr 1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",            //  0x0414
    L"kr 1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",            //  0x0814
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 z\x0142",       //  0x0415
    L"R$ 1.234.567,44",                                                    //  0x0416
    L"1.234.567,44 \x20ac",                                                //  0x0816
    L"1.234.567,44 lei",                                                   //  0x0418
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44\x0440.",        //  0x0419
    L"1.234.567,44 kn",                                                    //  0x041a
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 Sk",            //  0x041b
    L"1.234.567,44 kr",                                                    //  0x041d
    L"1.234.567,44 TL",                                                    //  0x041f
    L"1.234.567,44 SIT"                                                    //  0x0424
};

LPWSTR pNegCurrency[] =
{
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x043b\x0432", //  0x0402
    L"-NT$1,234,567.44",                                                   //  0x0404
    L"\xffe5-1,234,567.44",                                                //  0x0804
    L"(HK$1,234,567.44)",                                                  //  0x0c04
    L"($1,234,567.44)",                                                    //  0x1004
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 K\x010d",      //  0x0405
    L"kr -1.234.567,44",                                                   //  0x0406
    L"-1.234.567,44 \x20ac",                                               //  0x0407
    L"SFr.-1'234'567.44",                                                  //  0x0807
    L"-\x20ac 1.234.567,44",                                               //  0x0c07
    L"-1.234.567,44 \x20ac",                                               //  0x0408
    L"($1,234,567.44)",                                                    //  0x0409
    L"-1,234,567.44",                                                     //  0x0809
    L"-$1,234,567.44",                                                     //  0x0c09
    L"-$1,234,567.44",                                                     //  0x1009
    L"-$1,234,567.44",                                                     //  0x1409
    L"-\x20ac\x0031,234,567.44",                                           //  0x1809
    L"-1.234.567,44 \x20ac",                                               //  0x040a
    L"-$1,234,567.44",                                                     //  0x080a
    L"-1.234.567,44 \x20ac",                                               //  0x0c0a
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x20ac",       //  0x040b
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 \x20ac",       //  0x040c
    L"-1.234.567,44 \x20ac",                                               //  0x080c
    L"(1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44$)",            //  0x0c0c
    L"SFr.-1'234'567.44",                                                  //  0x100c
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 Ft",           //  0x040e
    L"-1.234.567,44 kr.",                                                  //  0x040f
    L"-\x20ac 1.234.567,44",                                               //  0x0410
    L"SFr.-1'234'567.44",                                                  //  0x0810
    L"-\x00a5\x0031,234,567",                                              //  0x0411
    L"-\x20a9\x0031,234,567",                                              //  0x0412
    L"\x20ac 1.234.567,44-",                                               //  0x0413
    L"-1.234.567,44 \x20ac",                                               //  0x0813
    L"kr -1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",           //  0x0414
    L"kr -1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",           //  0x0814
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 z\x0142",      //  0x0415
    L"(R$ 1.234.567,44)",                                                  //  0x0416
    L"-1.234.567,44 \x20ac",                                               //  0x0816
    L"-1.234.567,44 lei",                                                  //  0x0418
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44\x0440.",       //  0x0419
    L"-1.234.567,44 kn",                                                   //  0x041a
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44 Sk",           //  0x041b
    L"-1.234.567,44 kr",                                                   //  0x041d
    L"-1.234.567,44 TL",                                                   //  0x041f
    L"-1.234.567,44 SIT"                                                   //  0x0424
};




//
//  Forward Declarations.
//

BOOL
InitGetCurrencyFormat();

int
GCF_BadParamCheck();

int
GCF_NormalCase();

int
GCF_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetCurrencyFormat
//
//  Test routine for GetCurrencyFormatW API.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetCurrencyFormat()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetCurrencyFormatW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetCurrencyFormat())
    {
        printf("\nABORTED TestGetCurrencyFormat: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GCF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GCF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GCF_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetCurrencyFormatW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetCurrencyFormat
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetCurrencyFormat()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Initialize the value.
    //
    pValue = L"1234567.4444";
    pNegValue = L"-1234567.4444";

    //
    //  Initialize the currency format structure.
    //
    CurrFmt.NumDigits = 3;
    CurrFmt.LeadingZero = 1;
    CurrFmt.Grouping = 3;
    CurrFmt.lpDecimalSep = L"/";
    CurrFmt.lpThousandSep = L";";
    CurrFmt.lpCurrencySymbol = L"*";
    CurrFmt.PositiveOrder = 3;
    CurrFmt.NegativeOrder = 6;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GCF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    CURRENCYFMT MyCurrFmt;        // currency format


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetCurrencyFormatW( (LCID)333,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpCurrencyStr = NULL
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             NULL,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpCurrencyStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpValue = NULL
    rc = GetCurrencyFormatW( Locale,
                             0,
                             NULL,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpValue NULL",
                         &NumErrors );


    //
    //  Bad Count.
    //

    //  Variation 1  -  cchCurrency < 0
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchCurrency < 0",
                         &NumErrors );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    rc = GetCurrencyFormatW( Locale,
                             GCF_INVALID_FLAGS,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Flag invalid",
                         &NumErrors );

    //  Variation 2  -  lpFormat and NoUserOverride
    rc = GetCurrencyFormatW( Locale,
                             LOCALE_NOUSEROVERRIDE,
                             pValue,
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "lpFormat and NoUserOverride",
                         &NumErrors );

    //  Variation 3  -  Use CP ACP, lpFormat and NoUserOverride
    rc = GetCurrencyFormatW( Locale,
                             LOCALE_USE_CP_ACP | LOCALE_NOUSEROVERRIDE,
                             pValue,
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, lpFormat and NoUserOverride",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchCurrency = too small
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchCurrency too small",
                         &NumErrors );


    //
    //  Bad format passed in.
    //

    //  Variation 1  -  bad NumDigits
    MyCurrFmt.NumDigits = 10;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad NumDigits",
                         &NumErrors );

    //  Variation 2  -  bad LeadingZero
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 2;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad LeadingZero",
                         &NumErrors );

    //  Variation 3  -  bad Grouping
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 10000;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Grouping",
                         &NumErrors );

    //  Variation 4  -  bad DecimalSep
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = NULL;
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep",
                         &NumErrors );

    //  Variation 5  -  bad DecimalSep 2
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"////";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep2",
                         &NumErrors );

    //  Variation 6  -  bad DecimalSep 3
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"6";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep3",
                         &NumErrors );

    //  Variation 7  -  bad ThousandSep
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = NULL;
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep",
                         &NumErrors );

    //  Variation 8  -  bad ThousandSep 2
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";;;;";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep2",
                         &NumErrors );

    //  Variation 9  -  bad ThousandSep 3
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L"6";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep3",
                         &NumErrors );

    //  Variation 10  -  bad Currency Symbol
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = NULL;
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Currency Symbol",
                         &NumErrors );

    //  Variation 11  -  bad Currency Symbol 2
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"******";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Currency Symbol 2",
                         &NumErrors );

    //  Variation 12  -  bad Currency Symbol 3
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*6";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Currency Symbol 3",
                         &NumErrors );

    //  Variation 13  -  bad Positive Order
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 4;
    MyCurrFmt.NegativeOrder = 6;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Positive Order",
                         &NumErrors );


    //  Variation 14  -  bad Negative Order
    MyCurrFmt.NumDigits = 3;
    MyCurrFmt.LeadingZero = 1;
    MyCurrFmt.Grouping = 3;
    MyCurrFmt.lpDecimalSep = L"/";
    MyCurrFmt.lpThousandSep = L";";
    MyCurrFmt.lpCurrencySymbol = L"*";
    MyCurrFmt.PositiveOrder = 3;
    MyCurrFmt.NegativeOrder = 16;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             &MyCurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Negative Order",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GCF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetCurrencyFormatW( LOCALE_SYSTEM_DEFAULT,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "System Default Locale",
                       &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetCurrencyFormatW( LOCALE_USER_DEFAULT,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "Current User Locale",
                       &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  neutral
    rc = GetCurrencyFormatW( 0x0000,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "neutral locale",
                       &NumErrors );

    //  Variation 2  -  sys default
    rc = GetCurrencyFormatW( 0x0400,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "sys default locale",
                       &NumErrors );

    //  Variation 3  -  user default
    rc = GetCurrencyFormatW( 0x0800,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "user default locale",
                       &NumErrors );

    //  Variation 4  -  sub lang neutral US
    rc = GetCurrencyFormatW( 0x0009,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "sub lang neutral US",
                       &NumErrors );

    //  Variation 5  -  sub lang neutral Czech
    rc = GetCurrencyFormatW( 0x0005,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_CZECH,
                       "sub lang neutral Czech",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  System Default Locale
    rc = GetCurrencyFormatW( LOCALE_SYSTEM_DEFAULT,
                             LOCALE_USE_CP_ACP,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "Use CP ACP, System Default Locale",
                       &NumErrors );


    //
    //  cchCurrency.
    //

    //  Variation 1  -  cchCurrency = size of lpCurrencyStr buffer
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "cchCurrency = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchCurrency = 0
    lpCurrencyStr[0] = 0x0000;
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       GCF_ENGLISH_US,
                       "cchCurrency zero",
                       &NumErrors );

    //  Variation 3  -  cchCurrency = 0, lpCurrencyStr = NULL
    rc = GetCurrencyFormatW( Locale,
                             0,
                             pValue,
                             NULL,
                             NULL,
                             0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       GCF_ENGLISH_US,
                       "cchCurrency (NULL ptr)",
                       &NumErrors );


    //
    //  lpFormat - pValue = 1234567.4444
    //
    //      CurrFmt.NumDigits = 3;
    //      CurrFmt.LeadingZero = 1;
    //      CurrFmt.Grouping = 3;
    //      CurrFmt.lpDecimalSep = L"/";
    //      CurrFmt.lpThousandSep = L";";
    //      CurrFmt.lpCurrencySymbol = L"*";
    //      CurrFmt.PositiveOrder = 3;
    //      CurrFmt.NegativeOrder = 6;
    //

    //  Variation 1  -  lpFormat
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             pValue,
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"1;234;567/444 *",
                       "lpFormat (1;234;567/444 *)",
                       &NumErrors );

    //  Variation 2  -  lpFormat leading zero
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L".4444",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"0/444 *",
                       "lpFormat (0/444 *)",
                       &NumErrors );

    //  Variation 3  -  lpFormat no decimal
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"1234567",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"1;234;567/000 *",
                       "lpFormat (1;234;567/000 *)",
                       &NumErrors );

    //  Variation 4  -  lpFormat
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-1234567.444",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"1;234;567/444-*",
                       "lpFormat (1;234;567/444-*)",
                       &NumErrors );

    //  Variation 5  -  lpFormat leading zero
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-.4444",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"0/444-*",
                       "lpFormat (0/444-*)",
                       &NumErrors );

    //  Variation 6  -  lpFormat no decimal
    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-1234567",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"1;234;567/000-*",
                       "lpFormat (1;234;567/000-*)",
                       &NumErrors );


    //
    //  Flag values.
    //

    //  Variation 1  -  NOUSEROVERRIDE
    rc = GetCurrencyFormatW( Locale,
                             LOCALE_NOUSEROVERRIDE,
                             pValue,
                             NULL,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       GCF_ENGLISH_US,
                       "NoUserOverride",
                       &NumErrors );


    //
    //  Test all locales - pValue = 1234567.4444
    //
    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetCurrencyFormatW( pAllLocales[ctr],
                                 0,
                                 pValue,
                                 NULL,
                                 lpCurrencyStr,
                                 BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpCurrencyStr,
                               pPosCurrency[ctr],
                               "Pos",
                               pAllLocales[ctr],
                               &NumErrors );
    }



    //
    //  Test all locales - pNegValue = -1234567.4444
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetCurrencyFormatW( pAllLocales[ctr],
                                 0,
                                 pNegValue,
                                 NULL,
                                 lpCurrencyStr,
                                 BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpCurrencyStr,
                               pNegCurrency[ctr],
                               "Neg",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  Special case checks.
    //

    //  Variation 1  -  rounding check

    CurrFmt.NumDigits = 3;
    CurrFmt.LeadingZero = 1;
    CurrFmt.Grouping = 2;
    CurrFmt.lpDecimalSep = L".";
    CurrFmt.lpThousandSep = L",";
    CurrFmt.NegativeOrder = 1;
    CurrFmt.PositiveOrder = 0;
    CurrFmt.lpCurrencySymbol = L"$";

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"799.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$8,00.000",
                       "rounding ($8,00.000)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-799.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$8,00.000",
                       "rounding (-$8,00.000)",
                       &NumErrors );


    //  Variation 2  -  rounding check

    CurrFmt.NumDigits = 0 ;
    CurrFmt.LeadingZero = 1 ;
    CurrFmt.Grouping = 2 ;
    CurrFmt.lpDecimalSep = L"." ;
    CurrFmt.lpThousandSep = L"," ;
    CurrFmt.NegativeOrder = 1 ;
    CurrFmt.PositiveOrder = 0 ;
    CurrFmt.lpCurrencySymbol = L"$" ;

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"9.500",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$10",
                       "rounding ($10)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-9.500",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$10",
                       "rounding (-$10)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"99.500",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$1,00",
                       "rounding ($1,00)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-99.500",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$1,00",
                       "rounding (-$1,00)",
                       &NumErrors );


    //  Variation 3  -  grouping check

    CurrFmt.NumDigits = 3;
    CurrFmt.LeadingZero = 1;
    CurrFmt.Grouping = 32;
    CurrFmt.lpDecimalSep = L".";
    CurrFmt.lpThousandSep = L",";
    CurrFmt.NegativeOrder = 1;
    CurrFmt.PositiveOrder = 0;
    CurrFmt.lpCurrencySymbol = L"$";

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"1234567.999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$12,34,567.999",
                       "grouping ($12,34,567.999)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-1234567.999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$12,34,567.999",
                       "grouping (-$12,34,567.999)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"9999999.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$1,00,00,000.000",
                       "grouping/rounding ($1,00,00,000.000)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-9999999.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$1,00,00,000.000",
                       "grouping/rounding (-$1,00,00,000.000)",
                       &NumErrors );


    //  Variation 4  -  grouping check

    CurrFmt.NumDigits = 3;
    CurrFmt.LeadingZero = 1;
    CurrFmt.Grouping = 320;
    CurrFmt.lpDecimalSep = L".";
    CurrFmt.lpThousandSep = L",";
    CurrFmt.NegativeOrder = 1;
    CurrFmt.PositiveOrder = 0;
    CurrFmt.lpCurrencySymbol = L"$";

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"123456789.999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$1234,56,789.999",
                       "grouping ($1234,56,789.999)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-123456789.999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$1234,56,789.999",
                       "grouping (-$1234,56789.999)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"9999999.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$100,00,000.000",
                       "grouping/rounding ($100,00,000.000)",
                       &NumErrors );

    rc = GetCurrencyFormatW( 0x0409,
                             0,
                             L"-9999999.9999",
                             &CurrFmt,
                             lpCurrencyStr,
                             BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"-$100,00,000.000",
                       "grouping/rounding (-$100,00,000.000)",
                       &NumErrors );


    //  Variation 5  -  large number check

    SetLastError(0);
    rc = GetCurrencyFormat( LOCALE_USER_DEFAULT,
                            0,
                            L"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                            NULL,
                            lpCurrencyStr,
                            BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpCurrencyStr,
                       L"$10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000.00",
                       "big number",
                       &NumErrors );
    CheckLastError( 0,
                    "Last Error should be 0 - call should have succeeded",
                    &NumErrors );





    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}

////////////////////////////////////////////////////////////////////////////
//
//  GCF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE pCurStrA[BUFSIZE];       // ptr to currency string buffer
    CURRENCYFMTA CurrFmtA;        // currency format structure


    //
    //  GetCurrencyFormatA.
    //

    //  Variation 1  -  cchCurrency = size of lpCurrencyStr buffer
    rc = GetCurrencyFormatA( Locale,
                             0,
                             "123456.789",
                             NULL,
                             pCurStrA,
                             BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pCurStrA,
                       "$123,456.79",
                       NULL,
                       "A version cchCurrency = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchCurrency = 0
    pCurStrA[0] = 0x00;
    rc = GetCurrencyFormatA( Locale,
                             0,
                             "123456.789",
                             NULL,
                             pCurStrA,
                             0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "$123,456.79",
                       NULL,
                       "A version cchCurrency = bufsize, no Dest",
                       &NumErrors );

    //  Variation 3  -  cchCurrency = 0, lpCurrencyStr = NULL
    rc = GetCurrencyFormatA(Locale, 0, "123456.789", NULL, NULL, 0);
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "$123,456.79",
                       NULL,
                       "A version cchCurrency (NULL ptr)",
                       &NumErrors );

    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, cchCurrency = bufsize
    rc = GetCurrencyFormatA( Locale,
                             LOCALE_USE_CP_ACP,
                             "123456.789",
                             NULL,
                             pCurStrA,
                             BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pCurStrA,
                       "$123,456.79",
                       NULL,
                       "A version Use CP ACP, cchCurrency = bufsize",
                       &NumErrors );


    //
    //  lpFormat - pValue = 1234567.4444
    //

    CurrFmtA.NumDigits = 3;
    CurrFmtA.LeadingZero = 1;
    CurrFmtA.Grouping = 3;
    CurrFmtA.lpDecimalSep = "/";
    CurrFmtA.lpThousandSep = ";";
    CurrFmtA.lpCurrencySymbol = "*";
    CurrFmtA.PositiveOrder = 3;
    CurrFmtA.NegativeOrder = 6;


    //  Variation 1  -  lpFormat
    rc = GetCurrencyFormatA( 0x0409,
                             0,
                             "1234567.4444",
                             &CurrFmtA,
                             pCurStrA,
                             BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pCurStrA,
                       "1;234;567/444 *",
                       NULL,
                       "A version cchCurrency (NULL ptr)",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\euiltest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    euiltest.c

Abstract:

    Test module for NLS API EnumUILanguages.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    03-10-98    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE              50            // buffer size in wide chars
#define  EUIL_INVALID_FLAGS   ((DWORD)(~(0)))

#define  NUM_UI_LANGS         1




//
//  Global Variables.
//

int UILanguageCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumUILanguages();

int
EUIL_BadParamCheck();

int
EUIL_NormalCase();

int
EUIL_Ansi();

BOOL
CALLBACK
MyFuncUILanguage(
    LPWSTR pStr,
    LONG_PTR lParam);

BOOL
CALLBACK
MyFuncUILanguageA(
    LPSTR pStr,
    LONG_PTR lParam);




//
//  Callback function
//

BOOL CALLBACK MyFuncUILanguage(
    LPWSTR pStr,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    UILanguageCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncUILanguageA(
    LPSTR pStr,
    LONG_PTR lParam)
{
    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    UILanguageCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumUILanguages
//
//  Test routine for EnumUILanguagesW API.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumUILanguages()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumUILanguagesW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumUILanguages())
    {
        printf("\nABORTED TestEnumUILanguages: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += EUIL_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += EUIL_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += EUIL_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumUILanguagesW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumUILanguages
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumUILanguages()
{
    //
    //  Initialize locale counter.
    //
    UILanguageCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EUIL_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EUIL_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  Invalid Function.
    //

    //  Variation 1  -  Function = invalid
    UILanguageCtr = 0;
    rc = EnumUILanguagesW( NULL,
                           0,
                           0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             UILanguageCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    UILanguageCtr = 0;
    rc = EnumUILanguagesW( MyFuncUILanguage,
                           EUIL_INVALID_FLAGS,
                           0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             UILanguageCtr,
                             0 );

    //  Variation 2  -  dwFlags = both invalid
    UILanguageCtr = 0;
    rc = EnumUILanguagesW( MyFuncUILanguage,
                           LGRPID_INSTALLED | LGRPID_SUPPORTED,
                           0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag both invalid",
                             &NumErrors,
                             UILanguageCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  EUIL_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EUIL_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  valid
    UILanguageCtr = 0;
    rc = EnumUILanguagesW( MyFuncUILanguage,
                           0,
                           0 );

    if (UILanguageCtr == 0) 
    {
        printf(">>>>ERROR: EnumUILanguagesW() returns no language.");
        NumErrors++;
    }
    //
    // TODO: YSLin Write a function to enumerate HKLM\System\CurrentControlSet\Contorl\Nls\MUILanguages for
    // the correct answer of UI languages.  For now, just assume that this function is doing the right thing.
    //
    CheckReturnValidEnum( rc,
                          TRUE,
                          UILanguageCtr,
                          UILanguageCtr,
                          "Valid",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  EUIL_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int EUIL_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  valid
    UILanguageCtr = 0;
    rc = EnumUILanguagesA( MyFuncUILanguageA,
                           0,
                           0 );
                           
    if (UILanguageCtr == 0) 
    {
        printf(">>>>ERROR: EnumUILanguagesA() returns no language.");
        NumErrors++;
    }
                           
    //
    // TODO: YSLin Write a function to enumerate HKLM\System\CurrentControlSet\Contorl\Nls\MUILanguages for
    // the correct answer of UI languages.  For now, just assume that this function is doing the right thing.
    //
    CheckReturnValidEnum( rc,
                          TRUE,
                          UILanguageCtr,
                          UILanguageCtr,
                          "A version Valid",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\etftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    etftest.c

Abstract:

    Test module for NLS API EnumTimeFormats.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    08-02-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  ETF_INVALID_FLAGS        ((DWORD)(~(0)))

#define  NUM_TIME_ENGLISH         4
#define  NUM_TIME_JAPAN           4
#define  NUM_TIME_GERMAN          4




//
//  Global Variables.
//

int TimeCtr;




//
//  Forward Declarations.
//

BOOL
InitEnumTimeFormats();

int
ETF_BadParamCheck();

int
ETF_NormalCase();

int
ETF_Ansi();

BOOL
CALLBACK
MyFuncTime(
    LPWSTR pStr);

BOOL
CALLBACK
MyFuncTimeA(
    LPSTR pStr);




//
//  Callback function
//

BOOL CALLBACK MyFuncTime(
    LPWSTR pStr)
{

    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%wc", *pStr);
            pStr++;
        }
        printf("\n");
    }

    TimeCtr++;

    return (TRUE);
}


BOOL CALLBACK MyFuncTimeA(
    LPSTR pStr)
{

    if (Verbose)
    {
        while (*pStr)
        {
            printf((*pStr > 0xff) ? "(0x%x)" : "%c", *pStr);
            pStr++;
        }
        printf("\n");
    }

    TimeCtr++;

    return (TRUE);
}





////////////////////////////////////////////////////////////////////////////
//
//  TestEnumTimeFormats
//
//  Test routine for EnumTimeFormatsW API.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestEnumTimeFormats()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING EnumTimeFormatsW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitEnumTimeFormats())
    {
        printf("\nABORTED TestEnumTimeFormats: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += ETF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += ETF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += ETF_Ansi();

    //
    //  Print out result.
    //
    printf("\nEnumTimeFormatsW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitEnumTimeFormats
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitEnumTimeFormats()
{
    //
    //  Initialize date counter.
    //
    TimeCtr = 0;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ETF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ETF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Function.
    //

    //  Variation 1  -  bad function
    TimeCtr = 0;
    rc = EnumTimeFormatsW( NULL,
                           0x0409,
                           0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Function invalid",
                             &NumErrors,
                             TimeCtr,
                             0 );


    //
    //  Bad Locale.
    //

    //  Variation 1  -  bad locale
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           (LCID)333,
                           0 );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_PARAMETER,
                             "Locale invalid",
                             &NumErrors,
                             TimeCtr,
                             0 );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           0x0409,
                           ETF_INVALID_FLAGS );
    CheckReturnBadParamEnum( rc,
                             FALSE,
                             ERROR_INVALID_FLAGS,
                             "Flag invalid",
                             &NumErrors,
                             TimeCtr,
                             0 );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ETF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ETF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  W version  ----\n\n");
    }

    //  Variation 1  -  english
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           0x0409,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_ENGLISH,
                          "English",
                          &NumErrors );

    //  Variation 2  -  japan
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           0x0411,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_JAPAN,
                          "Japan",
                          &NumErrors );

    //  Variation 3  -  german
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           0x0407,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_GERMAN,
                          "German",
                          &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP
    TimeCtr = 0;
    rc = EnumTimeFormatsW( MyFuncTime,
                           0x0409,
                           LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_ENGLISH,
                          "Use CP ACP, English",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  ETF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  08-02-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int ETF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    if (Verbose)
    {
        printf("\n----  A version  ----\n\n");
    }

    //  Variation 1  -  english
    TimeCtr = 0;
    rc = EnumTimeFormatsA( MyFuncTimeA,
                           0x0409,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_ENGLISH,
                          "A version English",
                          &NumErrors );

    //  Variation 2  -  japan
    TimeCtr = 0;
    rc = EnumTimeFormatsA( MyFuncTimeA,
                           0x0411,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_JAPAN,
                          "A version Japan",
                          &NumErrors );

    //  Variation 3  -  german
    TimeCtr = 0;
    rc = EnumTimeFormatsA( MyFuncTimeA,
                           0x0407,
                           0 );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_GERMAN,
                          "A version German",
                          &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP
    TimeCtr = 0;
    rc = EnumTimeFormatsA( MyFuncTimeA,
                           0x0409,
                           LOCALE_USE_CP_ACP );
    CheckReturnValidEnum( rc,
                          TRUE,
                          TimeCtr,
                          NUM_TIME_ENGLISH,
                          "A version Use CP ACP, English",
                          &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\fstest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    fstest.c

Abstract:

    Test module for NLS API FoldString.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE           50
#define  FS_INVALID_FLAGS  ((DWORD)(~(MAP_FOLDCZONE | MAP_PRECOMPOSED |          \
                                      MAP_COMPOSITE | MAP_FOLDDIGITS)))




//
//  Global Variables.
//

#define FoldSrc1                  L"This Is A String"

#define FoldSrc2                  L"This Is$ A Str,ing"


WCHAR FoldDest[BUFSIZE];


#define wcMultiComp               L"\x0065\x0301\x0300"

#define wcCompDigitCZone          L"\x0065\x0301\x0300\x00b2\xfe64"
#define wcFoldCompDigitCZone      L"\x00e9\x0300\x0032\x003c"

#define wcPrecompDigitCZone       L"\x00e9\x0300\x00b2\xfe64"
#define wcFoldPreDigitCZone       L"\x0065\x0301\x0300\x0032\x003c"




//
//  Forward Declarations.
//

BOOL
InitFoldStr();

int
FS_BadParamCheck();

int
FS_NormalCase();

int
FS_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestFoldString
//
//  Test routine for FoldStringW API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestFoldString()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING FoldStringW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitFoldStr())
    {
        printf("\nABORTED TestFoldString: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += FS_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += FS_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += FS_Ansi();

    //
    //  Print out result.
    //
    printf("\nFoldStringW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitFoldStr
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitFoldStr()
{
    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FS_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FS_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpSrcStr = NULL
    rc = FoldStringW( MAP_FOLDDIGITS,
                      NULL,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpSrcStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpDestStr = NULL
    rc = FoldStringW( MAP_FOLDDIGITS,
                      FoldSrc1,
                      -1,
                      NULL,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpDestStr NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cbSrc = 0
    rc = FoldStringW( MAP_FOLDDIGITS,
                      FoldSrc1,
                      0,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbSrc = 0",
                         &NumErrors );

    //  Variation 2  -  cbDest < 0
    rc = FoldStringW( MAP_FOLDDIGITS,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbDest < 0",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  dwMapFlags = invalid
    rc = FoldStringW( FS_INVALID_FLAGS,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwMapFlags invalid",
                         &NumErrors );

    //  Variation 2  -  dwMapFlags = 0
    rc = FoldStringW( 0,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwMapFlags zero",
                         &NumErrors );

    //  Variation 3  -  illegal combo comp
    rc = FoldStringW( MAP_PRECOMPOSED | MAP_COMPOSITE,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo comp",
                         &NumErrors );

    //  Variation 4  -  illegal combo ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_COMPOSITE,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo ligatures and comp",
                         &NumErrors );

    //  Variation 5  -  illegal combo ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_PRECOMPOSED,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo ligatures and precomp",
                         &NumErrors );


    //
    //  Same Buffer Check.
    //

    //  Variation 1  -  same buffer
    FoldDest[0] = 0;
    rc = FoldStringW( MAP_FOLDDIGITS,
                      FoldDest,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "same buffer",
                         &NumErrors );


    //
    //  Insufficient Buffer Check.
    //

    //  Variation 1  -  insufficient buffer
    FoldDest[0] = 0;
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      -1,
                      FoldDest,
                      2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "insufficient buffer",
                         &NumErrors );

    FoldDest[0] = 0;
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      1,
                      FoldDest,
                      1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "insufficient buffer 2",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  FS_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FS_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  cbDest = 0.
    //

    //  Variation 1  -  cbSrc = -1
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       FoldSrc1,
                       "cbDest (0) cbSrc (-1)",
                       &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      WC_STRING_LEN_NULL(FoldSrc1),
                      FoldDest,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       FoldSrc1,
                       "cbDest (0) cbSrc (value)",
                       &NumErrors );

    //  Variation 3  -  lpDestStr = NULL
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       FoldSrc1,
                       "cbDest (0) lpDestStr NULL",
                       &NumErrors );


    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       FoldSrc1,
                       "cbSrc (-1)",
                       &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      WC_STRING_LEN(FoldSrc1),
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(FoldSrc1),
                       FoldDest,
                       FoldSrc1,
                       "cbSrc (value)",
                       &NumErrors );

    //  Variation 3  -  cbSrc = -1, no DestStr
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       FoldSrc1,
                       "cbSrc (-1), no DestStr",
                       &NumErrors );

    //  Variation 4  -  cbSrc = value, no DestStr
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc1,
                      WC_STRING_LEN(FoldSrc1),
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(FoldSrc1),
                       NULL,
                       FoldSrc1,
                       "cbSrc (value), no DestStr",
                       &NumErrors );


    //
    //  MAP_PRECOMPOSED Flag.
    //

    //  Variation 1  -  precomposed
    rc = FoldStringW( MAP_PRECOMPOSED,
                      FoldSrc2,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       FoldSrc2,
                       "precomposed",
                       &NumErrors );

    //  Variation 2  -  precomposed
    rc = FoldStringW( MAP_PRECOMPOSED,
                      L"\x006e\x0303",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x00f1",
                       "precomposed (n tilde)",
                       &NumErrors );

    //  Variation 3  -  precomposed
    rc = FoldStringW( MAP_PRECOMPOSED,
                      L"\x006e\x0303",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x00f1",
                       "precomposed (n tilde), no DestStr",
                       &NumErrors );

    //  Variation 4  -  precomposed
    rc = FoldStringW( MAP_PRECOMPOSED,
                      L"\x0062\x0303",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0062\x0303",
                       "precomposed (b tilde)",
                       &NumErrors );

    //  Variation 5  -  precomposed
    rc = FoldStringW( MAP_PRECOMPOSED,
                      L"\x0062\x0303",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x0062\x0303",
                       "precomposed (b tilde), no DestStr",
                       &NumErrors );


    //
    //  MAP_COMPOSITE Flag.
    //

    //  Variation 1  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      FoldSrc2,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       FoldSrc2,
                       "composite",
                       &NumErrors );

    //  Variation 2  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x00f1",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x006e\x0303",
                       "composite (n tilde)",
                       &NumErrors );

    //  Variation 3  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x00f1",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x006e\x0303",
                       "composite (n tilde), no DestStr",
                       &NumErrors );

    //  Variation 4  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x01c4",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0044\x017d",
                       "composite (dz hacek)",
                       &NumErrors );

    //  Variation 5  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x01c4",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x0044\x017d",
                       "composite (dz hacek), no DestStr",
                       &NumErrors );

    //  Variation 6  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x0062\x0303",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0062\x0303",
                       "composite (b tilde)",
                       &NumErrors );

    //  Variation 7  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x0062\x0303",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x0062\x0303",
                       "composite (b tilde), no DestStr",
                       &NumErrors );

    //  Variation 8  -  composite
    rc = FoldStringW( MAP_COMPOSITE,
                      L"\x304c",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x304b\xff9e",
                       "composite (hiragana Ga)",
                       &NumErrors );



    //
    //  MAP_FOLDCZONE Flag.
    //

    //  Variation 1  -  fold compatibility zone
    rc = FoldStringW( MAP_FOLDCZONE,
                      FoldSrc2,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       FoldSrc2,
                       "fold czone",
                       &NumErrors );

    //  Variation 2  -  fold compatibility zone
    rc = FoldStringW( MAP_FOLDCZONE,
                      L"\x004a\xff24\xff22",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x004a\x0044\x0042",
                       "fold czone (JDB)",
                       &NumErrors );

    //  Variation 3  -  fold compatibility zone
    rc = FoldStringW( MAP_FOLDCZONE,
                      L"\x004a\xff24\xff22",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x004a\x0044\x0042",
                       "fold czone (JDB), no DestStr",
                       &NumErrors );


    //
    //  MAP_FOLDDIGITS Flag.
    //

    //  Variation 1  -  fold digits
    rc = FoldStringW( MAP_FOLDDIGITS,
                      FoldSrc2,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       FoldSrc2,
                       "fold digits",
                       &NumErrors );

    //  Variation 2  -  fold digits
    rc = FoldStringW( MAP_FOLDDIGITS,
                      L"\x00b2\x00b3",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0032\x0033",
                       "fold digits (23)",
                       &NumErrors );

    //  Variation 3  -  fold digits
    rc = FoldStringW( MAP_FOLDDIGITS,
                      L"\x00b2\x00b3",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x0032\x0033",
                       "fold digits (23), no DestStr",
                       &NumErrors );



    //
    //  Check precomposed with multiple diacritics.
    //
    //  Variation 1  -  precomp, multi diacritics
    rc = FoldStringW( MAP_PRECOMPOSED,
                      wcMultiComp,
                      3,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       FoldDest,
                       L"\x00e9\x0300",
                       "precomp, multi diacritics",
                       &NumErrors );

    //  Variation 2  -  precomp, czone
    rc = FoldStringW( MAP_PRECOMPOSED | MAP_FOLDCZONE,
                      wcCompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x00e9\x0300\x00b2\x003c",
                       "precomp, czone",
                       &NumErrors );

    //  Variation 3  -  precomp, digits
    rc = FoldStringW( MAP_PRECOMPOSED | MAP_FOLDDIGITS,
                      wcCompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x00e9\x0300\x0032\xfe64",
                       "precomp, digits",
                       &NumErrors );

    //  Variation 4  -  precomp, czone, digits
    rc = FoldStringW( MAP_PRECOMPOSED | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      wcCompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x00e9\x0300\x0032\x003c",
                       "precomp, czone, digits",
                       &NumErrors );


    //
    //  Check composite.
    //

    //  Variation 1  -  comp, czone
    rc = FoldStringW( MAP_COMPOSITE | MAP_FOLDCZONE,
                      wcPrecompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0065\x0301\x0300\x00b2\x003c",
                       "comp, czone",
                       &NumErrors );

    //  Variation 2  -  comp, digits
    rc = FoldStringW( MAP_COMPOSITE | MAP_FOLDDIGITS,
                      wcPrecompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0065\x0301\x0300\x0032\xfe64",
                       "comp, digits",
                       &NumErrors );

    //  Variation 3  -  comp, czone, digits
    rc = FoldStringW( MAP_COMPOSITE | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      wcPrecompDigitCZone,
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"\x0065\x0301\x0300\x0032\x003c",
                       "comp, czone, digits",
                       &NumErrors );


    //
    //  MAP_EXPAND_LIGATURES Flag.
    //

    //  Variation 1  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"abc",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"abc",
                       "expand ligatures 1",
                       &NumErrors );

    //  Variation 2  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"ae",
                       "expand ligatures 2",
                       &NumErrors );

    //  Variation 3  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      -1,
                      FoldDest,
                      3 );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"ae",
                       "expand ligatures 3",
                       &NumErrors );

    //  Variation 4  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      1,
                      FoldDest,
                      2 );
    CheckReturnValidW( rc,
                       2,
                       FoldDest,
                       L"ae",
                       "expand ligatures 4",
                       &NumErrors );

    //  Variation 5  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\x00e6",
                      1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"ae",
                       "expand ligatures 5 - no DestStr",
                       &NumErrors );

    //  Variation 6  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE,
                      L"\x00e6\xff26",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"aeF",
                       "expand ligatures 6 - lig & czone",
                       &NumErrors );

    //  Variation 7  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE,
                      L"\x00e6\xff26",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"aeF",
                       "expand ligatures 7 - lig & czone - no DestStr",
                       &NumErrors );

    //  Variation 8  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS,
                      L"\x00e6\x0660",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"ae0",
                       "expand ligatures 8 - lig & digits",
                       &NumErrors );

    //  Variation 9  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS,
                      L"\x00e6\x0660",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"ae0",
                       "expand ligatures 9 - lig & digits - no DestStr",
                       &NumErrors );

    //  Variation 10  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      L"\x00e6\xff26\x0660",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"aeF0",
                       "expand ligatures 10 - lig, czone, & digits",
                       &NumErrors );

    //  Variation 11  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      L"\x00e6\xff26\x0660",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"aeF0",
                       "expand ligatures 11 - lig, czone, & digits - no DestStr",
                       &NumErrors );

    //  Variation 12  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\xfb03",
                      -1,
                      FoldDest,
                      BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       FoldDest,
                       L"ffi",
                       "expand ligatures 12",
                       &NumErrors );

    //  Variation 13  -  expand ligatures
    rc = FoldStringW( MAP_EXPAND_LIGATURES,
                      L"\xfb03",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"ffi",
                       "expand ligatures 13",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}

////////////////////////////////////////////////////////////////////////////
//
//  FS_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int FS_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE pFoldDestA[BUFSIZE];     // ptr to buffer


    //
    //  FoldStringA.
    //

    //  Variation 1  -  cbSrc = -1
    rc = FoldStringA( MAP_PRECOMPOSED,
                      "AbCd",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "AbCd",
                       NULL,
                       "A version cbSrc (-1)",
                       &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = FoldStringA( MAP_PRECOMPOSED,
                      "AbCd",
                      4,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       4,
                       pFoldDestA,
                       "AbCd",
                       NULL,
                       "A version cbSrc (value)",
                       &NumErrors );

    //  Variation 3  -  cbSrc = -1, no DestStr
    rc = FoldStringA( MAP_PRECOMPOSED,
                      "AbCd",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "AbCd",
                       NULL,
                       "A version cbSrc (-1), no DestStr",
                       &NumErrors );

    //  Variation 4  -  cbSrc = value, no DestStr
    rc = FoldStringA( MAP_PRECOMPOSED,
                      "AbCd",
                      4,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       4,
                       NULL,
                       "AbCd",
                       NULL,
                       "A version cbSrc (value), no DestStr",
                       &NumErrors );


    //
    //  MAP_EXPAND_LIGATURES Flag.
    //

    //  Variation 1  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES,
                      "abc",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "abc",
                       NULL,
                       "A expand ligatures 1",
                       &NumErrors );

    //  Variation 2  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES,
                      "\xe6",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "ae",
                       NULL,
                       "A expand ligatures 2",
                       &NumErrors );

    //  Variation 3  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES,
                      "\xe6",
                      -1,
                      pFoldDestA,
                      3 );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "ae",
                       NULL,
                       "A expand ligatures 3",
                       &NumErrors );

    //  Variation 4  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES,
                      "\xe6",
                      1,
                      pFoldDestA,
                      2 );
    CheckReturnValidA( rc,
                       2,
                       pFoldDestA,
                       "ae",
                       NULL,
                       "A expand ligatures 4",
                       &NumErrors );

    //  Variation 5  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES,
                      "\xe6",
                      1,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       2,
                       NULL,
                       "ae",
                       NULL,
                       "A expand ligatures 5 - no DestStr",
                       &NumErrors );

    //  Variation 6  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE,
                      "\xe6G",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "aeG",
                       NULL,
                       "A expand ligatures 6 - lig & czone",
                       &NumErrors );

    //  Variation 7  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE,
                      "\xe6G",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "aeG",
                       NULL,
                       "A expand ligatures 7 - lig & czone - no DestStr",
                       &NumErrors );

    //  Variation 8  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS,
                      "\xe6\xb2",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "ae2",
                       NULL,
                       "A expand ligatures 8 - lig & digits",
                       &NumErrors );

    //  Variation 9  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDDIGITS,
                      "\xe6\xb2",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "ae2",
                       NULL,
                       "A expand ligatures 9 - lig & digits - no DestStr",
                       &NumErrors );

    //  Variation 10  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      "\xe6G\xb2",
                      -1,
                      pFoldDestA,
                      BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pFoldDestA,
                       "aeG2",
                       NULL,
                       "A expand ligatures 10 - lig, czone, & digits",
                       &NumErrors );

    //  Variation 11  -  expand ligatures
    rc = FoldStringA( MAP_EXPAND_LIGATURES | MAP_FOLDCZONE | MAP_FOLDDIGITS,
                      "\xe6G\xb2",
                      -1,
                      NULL,
                      0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "aeG2",
                       NULL,
                       "A expand ligatures 11 - lig, czone, & digits - no DestStr",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gcitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gcitest.c

Abstract:

    Test module for NLS API GetCalendarInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    03-10-98    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             50             // buffer size in wide chars
#define  CALTYPE_INVALID     0x0000100      // invalid CALTYPE
#define  LANG_INVALID        0x0417         // invalid lang id

#define  S_ITWODIGITYEARMAX  L"2029"
#define  I_ITWODIGITYEARMAX  2029




//
//  Global Variables.
//

LCID Locale;

WCHAR lpCalData[BUFSIZE];
BYTE  lpCalDataA[BUFSIZE];


//
//  pCalInfoFlag and pCalString must have the same number of entries.
//
CALTYPE pCalInfoFlag[] =
{
    CAL_ICALINTVALUE,
    CAL_SCALNAME,
    CAL_ITWODIGITYEARMAX,
    CAL_IYEAROFFSETRANGE,
    CAL_SERASTRING,
    CAL_SSHORTDATE,
    CAL_SLONGDATE,
    CAL_SYEARMONTH,
    CAL_SDAYNAME1,
    CAL_SMONTHNAME1,
    CAL_SMONTHNAME13
};

#define NUM_CAL_FLAGS  ( sizeof(pCalInfoFlag) / sizeof(CALTYPE) )


LPWSTR pCalString[] =
{
    L"1",
    L"Gregorian Calendar",
    L"2029",
    L"0",
    L"",
    L"M/d/yyyy",
    L"dddd, MMMM dd, yyyy",
    L"MMMM, yyyy",
    L"Monday",
    L"January",
    L""
};


LPWSTR pCalStringJapan[] =
{
    L"3",
    L"\x548c\x66a6",
    L"99",
    L"1989",
    L"\x5e73\x6210",
    L"gg y/M/d",
    L"gg y'\x5e74'M'\x6708'd'\x65e5'",
    L"gg y'\x5e74'M'\x6708'",
    L"\x6708\x66dc\x65e5",
    L"1\x6708",
    L""
};


LPWSTR pCalStringHebrew[] =
{
    L"8",
    L"\x05dc\x05d5\x05d7\x00a0\x05e9\x05e0\x05d4\x00a0\x05e2\x05d1\x05e8\x05d9",
    L"5790",
    L"0",
    L"",
    L"dd/MMM/yyyy",
    L"dddd dd MMMM yyyy",
    L"MMMM yyyy",
    L"\x05d9\x05d5\x05dd\x00a0\x05e9\x05e0\x05d9",
    L"\x05ea\x05e9\x05e8\x05d9",
    L"\x05d0\x05dc\x05d5\x05dc"
};


//
//  pCalIntFlag and pCalInt must have the same number of entries.
//
CALTYPE pCalIntFlag[] =
{
    CAL_ICALINTVALUE,
    CAL_ITWODIGITYEARMAX,
    CAL_IYEAROFFSETRANGE,
};

#define NUM_CAL_INT_FLAGS  ( sizeof(pCalIntFlag) / sizeof(CALTYPE) )


int pCalInt[] =
{
    1,
    2029,
    0
};


int pCalIntJapan[] =
{
    3,
    99,
    1989
};




//
//  Forward Declarations.
//

BOOL
InitGetCalInfo();

int
GCI_BadParamCheck();

int
GCI_NormalCase();

int
GCI_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetCalendarInfo
//
//  Test routine for GetCalendarInfoW API.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetCalendarInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetCalendarInfoW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetCalInfo())
    {
        printf("\nABORTED TestGetCalendarInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GCI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GCI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GCI_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetCalendarInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetCalInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetCalInfo()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);


    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GCI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCI_BadParamCheck()
{
    DWORD dwValue;                // value
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetCalendarInfoW( (LCID)333,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );

    //  Variation 2  -  Bad Locale
    rc = GetCalendarInfoW( LANG_INVALID,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "invalid locale - invalid",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpCalData = NULL
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpCalData NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cchData < 0
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           -1,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchData < 0",
                         &NumErrors );


    //
    //  Zero or Invalid Type.
    //

    //  Variation 1  -  CalType = invalid
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CALTYPE_INVALID,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "CalType invalid",
                         &NumErrors );

    //  Variation 2  -  CalType = 0
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           0,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "CalType zero",
                         &NumErrors );

    //  Variation 3  -  Use CP ACP, CalType = invalid
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CALTYPE_INVALID,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, CalType invalid",
                         &NumErrors );



    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchData = too small
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           1,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchData too small",
                         &NumErrors );


    //
    //  RETURN_NUMBER flag.
    //

    //  Variation 1  -  invalid flags
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_SCALNAME | CAL_RETURN_NUMBER,
                           NULL,
                           0,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "invalid flags - RETURN_NUMBER",
                         &NumErrors );

    //  Variation 2  -  wrong buffer 1
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 1 - RETURN_NUMBER",
                         &NumErrors );

    //  Variation 3  -  wrong buffer 2
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                           lpCalData,
                           0,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 2 - RETURN_NUMBER",
                         &NumErrors );

    //  Variation 4  -  wrong buffer 3
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                           NULL,
                           BUFSIZE,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 3 - RETURN_NUMBER",
                         &NumErrors );


    //
    //  Wrong Buffer.
    //

    //  Variation 1  -  wrong buffer 1
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 1",
                         &NumErrors );

    //  Variation 2  -  wrong buffer 2
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL,
                           0,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 2",
                         &NumErrors );

    //  Variation 3  -  wrong buffer 3
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           0,
                           &dwValue );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "wrong buffer 3",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GCI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCI_NormalCase()
{
    DWORD dwValue;                // value
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnEqual( rc,
                      0,
                      "system default locale",
                      &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetCalendarInfoW( LOCALE_USER_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnEqual( rc,
                      0,
                      "current user locale",
                      &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = GetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnEqual( rc,
                      0,
                      "Use CP ACP, system default locale",
                      &NumErrors );


    //
    //  cchData.
    //

    //  Variation 1  -  cchData = size of lpCalData buffer
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       S_ITWODIGITYEARMAX,
                       "cchData = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchData = 0
    lpCalData[0] = 0x0000;
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           0,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       S_ITWODIGITYEARMAX,
                       "cchData zero",
                       &NumErrors );

    //  Variation 3  -  cchData = 0, lpCalData = NULL
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL,
                           0,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       S_ITWODIGITYEARMAX,
                       "cchData (NULL ptr)",
                       &NumErrors );


    //
    //  CALTYPE values.
    //

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        rc = GetCalendarInfoW( Locale,
                               CAL_GREGORIAN,
                               pCalInfoFlag[ctr],
                               lpCalData,
                               BUFSIZE,
                               NULL );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpCalData,
                               pCalString[ctr],
                               "Calendar Flag",
                               pCalInfoFlag[ctr],
                               &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        rc = GetCalendarInfoW( 0x0411,
                               CAL_JAPAN,
                               pCalInfoFlag[ctr],
                               lpCalData,
                               BUFSIZE,
                               NULL );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpCalData,
                               pCalStringJapan[ctr],
                               "Japan Calendar Flag",
                               pCalInfoFlag[ctr],
                               &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_FLAGS; ctr++)
    {
        rc = GetCalendarInfoW( 0x040d,
                               CAL_HEBREW,
                               pCalInfoFlag[ctr],
                               lpCalData,
                               BUFSIZE,
                               NULL );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpCalData,
                               pCalStringHebrew[ctr],
                               "Hebrew Calendar Flag",
                               pCalInfoFlag[ctr],
                               &NumErrors );
    }


    //
    //  Language Neutral.
    //

    //  Variation 1  -  language neutral
    rc = GetCalendarInfoW( 0x0000,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       S_ITWODIGITYEARMAX,
                       "language neutral",
                       &NumErrors );

    //  Variation 2  -  sys default
    rc = GetCalendarInfoW( 0x0400,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       S_ITWODIGITYEARMAX,
                       "sys default",
                       &NumErrors );

    //  Variation 3  -  user default
    rc = GetCalendarInfoW( 0x0800,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       S_ITWODIGITYEARMAX,
                       "user default",
                       &NumErrors );

    //  Variation 4  -  sub lang neutral US
    rc = GetCalendarInfoW( 0x0009,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       S_ITWODIGITYEARMAX,
                       "sub lang neutral US",
                       &NumErrors );



    //
    //  Test Return Number flag.
    //
    //  Variation 1  -  RETURN_NUMBER
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                           NULL,
                           0,
                           &dwValue );
    CheckReturnValidInt( rc,
                         2,
                         dwValue,
                         2029,
                         "Return_Number - two digit year max",
                         &NumErrors );


    //
    //  Try all INT flags with CAL_RETURN_NUMBER flag.
    //
    for (ctr = 0; ctr < NUM_CAL_INT_FLAGS; ctr++)
    {
        rc = GetCalendarInfoW( Locale,
                               CAL_GREGORIAN,
                               pCalIntFlag[ctr] | CAL_RETURN_NUMBER,
                               NULL,
                               0,
                               &dwValue );
        CheckReturnValidInt( rc,
                             2,
                             dwValue,
                             pCalInt[ctr],
                             "Calendar Int Flag",
                             &NumErrors );
    }

    for (ctr = 0; ctr < NUM_CAL_INT_FLAGS; ctr++)
    {
        rc = GetCalendarInfoW( 0x0411,
                               CAL_JAPAN,
                               pCalIntFlag[ctr] | CAL_RETURN_NUMBER,
                               NULL,
                               0,
                               &dwValue );
        CheckReturnValidInt( rc,
                             2,
                             dwValue,
                             pCalIntJapan[ctr],
                             "Japan Calendar Int Flag",
                             &NumErrors );
    }


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GCI_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GCI_Ansi()
{
    DWORD dwValue;                // value
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


    //
    //  GetCalendarInfoA.
    //

    //  Variation 1  -  ITWODIGITYEARMAX
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalDataA,
                           BUFSIZE,
                           NULL );
    CheckReturnValidA( rc,
                       -1,
                       lpCalDataA,
                       "2029",
                       NULL,
                       "A version ITWODIGITYEARMAX",
                       &NumErrors );

    //  Variation 2  -  ITWODIGITYEARMAX
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL,
                           0,
                           NULL );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "2029",
                       NULL,
                       "A version ITWODIGITYEARMAX, no Dest",
                       &NumErrors );

    //  Variation 3  -  ITWODIGITYEARMAX
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL,
                           BUFSIZE,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version bad lpCalData",
                         &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, ITWODIGITYEARMAX
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           lpCalDataA,
                           BUFSIZE,
                           NULL );
    CheckReturnValidA( rc,
                       -1,
                       lpCalDataA,
                       "2029",
                       NULL,
                       "A version Use CP ACP, ITWODIGITYEARMAX",
                       &NumErrors );


    //
    //  Make sure the A and W versions set the same error value.
    //

    SetLastError( 0 );
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalDataA,
                           -1,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W error returns same - A version",
                         &NumErrors );

    SetLastError( 0 );
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           -1,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W error returns same - W version",
                         &NumErrors );


    //
    //  Test Return Number flag.
    //
    //  Variation 1  -  RETURN_NUMBER
    rc = GetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                           NULL,
                           0,
                           &dwValue );
    CheckReturnValidInt( rc,
                         4,
                         dwValue,
                         2029,
                         "A Version Return_Number - two digit year max",
                         &NumErrors );


    //
    //  Try all INT flags with CAL_RETURN_NUMBER flag.
    //
    for (ctr = 0; ctr < NUM_CAL_INT_FLAGS; ctr++)
    {
        rc = GetCalendarInfoA( Locale,
                               CAL_GREGORIAN,
                               pCalIntFlag[ctr] | CAL_RETURN_NUMBER,
                               NULL,
                               0,
                               &dwValue );
        CheckReturnValidInt( rc,
                             4,
                             dwValue,
                             pCalInt[ctr],
                             "A Version Calendar Int Flag",
                             &NumErrors );
    }


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gdftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gdftest.c

Abstract:

    Test module for NLS API GetDateFormat.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    04-30-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE                50          // buffer size in wide chars
#define  GDF_INVALID_FLAGS      ((DWORD)(~(LOCALE_NOUSEROVERRIDE |        \
                                           DATE_SHORTDATE |               \
                                           DATE_LONGDATE |                \
                                           DATE_YEARMONTH |               \
                                           DATE_USE_ALT_CALENDAR)))

#define  ENGLISH_US             L"5/1/1993"
#define  L_ENGLISH_US           L"Saturday, May 01, 1993"
#define  CZECH                  L"1.5.1993"

#define  YEAR                   L"1993"
#define  YEAR_2                 L"93"

#define  US_DAYOFWEEK           L"Saturday"
#define  US_MONTH               L"May"
#define  US_ABBREVDAY           L"Sat"
#define  US_ABBREVMONTH         L"May"

#define  SPANISH_DAYOFWEEK      L"sbado"
#define  SPANISH_MONTH          L"mayo"
#define  SPANISH_ABBREVDAY      L"sb"
#define  SPANISH_ABBREVMONTH    L"may"

#define  L_RUSSIAN_2            L"\x041c\x0430\x0439"
#define  L_RUSSIAN_3            L"\x043c\x0430\x044f 1"
#define  L_RUSSIAN_4            L"1 93 \x041c\x0430\x0439"

#define  L_POLISH_2             L"maj"
#define  L_POLISH_3             L"maja 1"
#define  L_POLISH_4             L"1 93 maj"

#define  JAPAN_ALT              L"\x5e73\x6210 5/5/1"
#define  CHINA_ALT              L"82/5/1"
#define  KOREA_ALT              L"\xb2e8\xae30 4326-05-01"

#define  L_JAPAN_ALT            L"\x5e73\x6210 5\x5e74\x0035\x6708\x0031\x65e5"
#define  L_CHINA_ALT            L"\x4e2d\x83ef\x6c11\x570b\x0038\x0032\x5e74\x0035\x6708\x0031\x65e5"
#define  L_KOREA_ALT            L"\xb2e8\xae30 4326\xb144 5\xc6d4 1\xc77c \xd1a0\xc694\xc77c"

#define  L_JAPAN_ALT_2          L"\x5927\x6b63 2\x5e74\x0035\x6708\x0031\x65e5"
#define  L_CHINA_ALT_2          L"1832\x5e74\x0035\x6708\x0031\x65e5"
#define  L_KOREA_ALT_2          L"\xb2e8\xae30 4165\xb144 5\xc6d4 1\xc77c \xd654\xc694\xc77c"

#define  L_JAPAN_ALT_3          L" 32\x5e74\x0035\x6708\x0031\x65e5"




//
//  Global Variables.
//

LCID Locale;

SYSTEMTIME SysDate;

WCHAR lpDateStr[BUFSIZE];

WCHAR pSShortDate[BUFSIZE];


//
//  Date format buffers must be in line with the pAllLocales global
//  buffer.
//
LPWSTR pShortDate[] =
{
    L"01.5.1993 \x0433.",                  //  0x0402
    L"1993/5/1",                           //  0x0404
    L"1993-5-1",                           //  0x0804
    L"1/5/1993",                           //  0x0c04
    L"1/5/1993",                           //  0x1004
    L"1.5.1993",                           //  0x0405
    L"01-05-1993",                         //  0x0406
    L"01.05.1993",                         //  0x0407
    L"01.05.1993",                         //  0x0807
    L"01.05.1993",                         //  0x0c07
    L"1/5/1993",                           //  0x0408
    L"5/1/1993",                           //  0x0409
    L"01/05/1993",                         //  0x0809
    L"1/05/1993",                          //  0x0c09
    L"01/05/1993",                         //  0x1009
    L"1/05/1993",                          //  0x1409
    L"01/05/1993",                         //  0x1809
    L"01/05/1993",                         //  0x040a
    L"01/05/1993",                         //  0x080a
    L"01/05/1993",                         //  0x0c0a
    L"1.5.1993",                           //  0x040b
    L"01/05/1993",                         //  0x040c
    L"1/05/1993",                          //  0x080c
    L"1993-05-01",                         //  0x0c0c
    L"01.05.1993",                         //  0x100c
    L"1993. 05. 01.",                      //  0x040e
    L"1.5.1993",                           //  0x040f
    L"01/05/1993",                         //  0x0410
    L"01.05.1993",                         //  0x0810
    L"1993/05/01",                         //  0x0411
    L"1993-05-01",                         //  0x0412
    L"1-5-1993",                           //  0x0413
    L"1/05/1993",                          //  0x0813
    L"01.05.1993",                         //  0x0414
    L"01.05.1993",                         //  0x0814
    L"1993-05-01",                         //  0x0415
    L"1/5/1993",                           //  0x0416
    L"01-05-1993",                         //  0x0816
    L"01.05.1993",                         //  0x0418
    L"01.05.1993",                         //  0x0419
    L"1.5.1993",                           //  0x041a
    L"1. 5. 1993",                         //  0x041b
    L"1993-05-01",                         //  0x041d
    L"01.05.1993",                         //  0x041f
    L"1.5.1993"                            //  0x0424
};

LPWSTR pLongDate[] =
{
    L"01 \x041c\x0430\x0439 1993 \x0433.",                                                    //  0x0402
    L"1993\x5e74\x0035\x6708\x0031\x65e5",                                                    //  0x0404
    L"1993\x5e74\x0035\x6708\x0031\x65e5",                                                    //  0x0804
    L"Saturday, 1 May, 1993",                                                                 //  0x0c04
    L"\x661f\x671f\x516d, 1 \x4e94\x6708, 1993",                                              //  0x1004
    L"1. kv\x011btna 1993",                                                                   //  0x0405
    L"1. maj 1993",                                                                           //  0x0406
    L"Samstag, 1. Mai 1993",                                                                  //  0x0407
    L"Samstag, 1. Mai 1993",                                                                  //  0x0807
    L"Samstag, 01. Mai 1993",                                                                 //  0x0c07
    L"\x03a3\x03ac\x03b2\x03b2\x03b1\x03c4\x03bf, 1 \x039c\x03b1\x0390\x03bf\x03c5 1993",     //  0x0408
    L"Saturday, May 01, 1993",                                                                //  0x0409
    L"01 May 1993",                                                                           //  0x0809
    L"Saturday, 1 May 1993",                                                                  //  0x0c09
    L"May 1, 1993",                                                                           //  0x1009
    L"Saturday, 1 May 1993",                                                                  //  0x1409
    L"01 May 1993",                                                                           //  0x1809
    L"sbado, 01 de mayo de 1993",                                                            //  0x040a
    L"Sbado, 01 de Mayo de 1993",                                                            //  0x080a
    L"sbado, 01 de mayo de 1993",                                                            //  0x0c0a
    L"1. toukokuuta 1993",                                                                    //  0x040b
    L"samedi 1 mai 1993",                                                                     //  0x040c
    L"samedi 1 mai 1993",                                                                     //  0x080c
    L"1 mai, 1993",                                                                           //  0x0c0c
    L"samedi, 1. mai 1993",                                                                   //  0x100c
    L"1993. mjus 1.",                                                                        //  0x040e
    L"1. ma 1993",                                                                           //  0x040f
    L"sabato 1 maggio 1993",                                                                  //  0x0410
    L"sabato, 1. maggio 1993",                                                                //  0x0810
    L"1993\x5e74\x0035\x6708\x0031\x65e5",                                                    //  0x0411
    L"1993\xb144 5\xc6d4 1\xc77c \xd1a0\xc694\xc77c",                                         //  0x0412
    L"zaterdag 1 mei 1993",                                                                   //  0x0413
    L"zaterdag 1 mei 1993",                                                                   //  0x0813
    L"1. mai 1993",                                                                           //  0x0414
    L"1. mai 1993",                                                                           //  0x0814
    L"1 maja 1993",                                                                           //  0x0415
    L"sbado, 1 de maio de 1993",                                                             //  0x0416
    L"sbado, 1 de Maio de 1993",                                                             //  0x0816
    L"1 mai 1993",                                                                            //  0x0418
    L"1 \x043c\x0430\x044f 1993 \x0433.",                                                     //  0x0419
    L"1. svibanj 1993",                                                                       //  0x041a
    L"1. m\x00e1ja 1993",                                                                     //  0x041b
    L"den 1 maj 1993",                                                                        //  0x041d
    L"01 May\x0131s 1993 Cumartesi",                                                          //  0x041f
    L"1. maj 1993"                                                                            //  0x0424
};

LPWSTR pYearMonth[] =
{
    L"\x041c\x0430\x0439 1993 \x0433.",                                                       //  0x0402
    L"1993\x5e74\x0035\x6708",                                                                //  0x0404
    L"1993\x5e74\x0035\x6708",                                                                //  0x0804
    L"May, 1993",                                                                             //  0x0c04
    L"\x4e94\x6708, 1993",                                                                    //  0x1004
    L"kv\x011bten 1993",                                                                      //  0x0405
    L"maj 1993",                                                                              //  0x0406
    L"Mai 1993",                                                                              //  0x0407
    L"Mai 1993",                                                                              //  0x0807
    L"Mai 1993",                                                                              //  0x0c07
    L"\x039c\x03ac\x03b9\x03bf\x03c2 1993",                                                   //  0x0408
    L"May, 1993",                                                                             //  0x0409
    L"May 1993",                                                                              //  0x0809
    L"May 1993",                                                                              //  0x0c09
    L"May, 1993",                                                                             //  0x1009
    L"May 1993",                                                                              //  0x1409
    L"May 1993",                                                                              //  0x1809
    L"mayo de 1993",                                                                          //  0x040a
    L"Mayo de 1993",                                                                          //  0x080a
    L"mayo de 1993",                                                                          //  0x0c0a
    L"toukokuu 1993",                                                                       //  0x040b
    L"mai 1993",                                                                              //  0x040c
    L"mai 1993",                                                                              //  0x080c
    L"mai, 1993",                                                                             //  0x0c0c
    L"mai 1993",                                                                              //  0x100c
    L"1993. mjus",                                                                           //  0x040e
    L"ma 1993",                                                                              //  0x040f
    L"maggio 1993",                                                                           //  0x0410
    L"maggio 1993",                                                                           //  0x0810
    L"1993\x5e74\x0035\x6708",                                                                //  0x0411
    L"1993\xb144 5\xc6d4",                                                                    //  0x0412
    L"mei 1993",                                                                              //  0x0413
    L"mei 1993",                                                                              //  0x0813
    L"mai 1993",                                                                              //  0x0414
    L"mai 1993",                                                                              //  0x0814
    L"maj 1993",                                                                              //  0x0415
    L"maio de 1993",                                                                          //  0x0416
    L"Maio de 1993",                                                                          //  0x0816
    L"mai 1993",                                                                              //  0x0418
    L"\x041c\x0430\x0439 1993 \x0433.",                                                       //  0x0419
    L"svibanj, 1993",                                                                         //  0x041a
    L"mj 1993",                                                                              //  0x041b
    L"maj 1993",                                                                              //  0x041d
    L"May\x0131s 1993",                                                                       //  0x041f
    L"maj 1993"                                                                               //  0x0424
};




//
//  Forward Declarations.
//

BOOL
InitGetDateFormat();

int
GDF_BadParamCheck();

int
GDF_NormalCase();

int
GDF_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetDateFormat
//
//  Test routine for GetDateFormatW API.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetDateFormat()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetDateFormatW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetDateFormat())
    {
        printf("\nABORTED TestGetDateFormat: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GDF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GDF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GDF_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetDateFormatW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetDateFormat
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetDateFormat()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Initialize the system date.
    //
    SysDate.wYear = 1993;
    SysDate.wMonth = 5;
    SysDate.wDayOfWeek = 6;
    SysDate.wDay = 1;
    SysDate.wHour = 15;
    SysDate.wMinute = 45;
    SysDate.wSecond = 25;
    SysDate.wMilliseconds = 13;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GDF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GDF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyDate;            // structure to hold custom date


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetDateFormatW( (LCID)333,
                         0,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpDateStr = NULL
    rc = GetDateFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         NULL,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpDateStr NULL",
                         &NumErrors );


    //
    //  Bad Count.
    //

    //  Variation 1  -  cchDate < 0
    rc = GetDateFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         lpDateStr,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchDate < 0",
                         &NumErrors );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  flags invalid
    rc = GetDateFormatW( Locale,
                         GDF_INVALID_FLAGS,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Flag invalid",
                         &NumErrors );

    //  Variation 2  -  short date AND long date
    rc = GetDateFormatW( Locale,
                         DATE_SHORTDATE | DATE_LONGDATE,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Flag invalid (shortdate and longdate)",
                         &NumErrors );

    //  Variation 3  -  pFormat not null AND short date
    rc = GetDateFormatW( Locale,
                         DATE_SHORTDATE,
                         NULL,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "pFormat not null and short date",
                         &NumErrors );

    //  Variation 4  -  pFormat not null AND long date
    rc = GetDateFormatW( Locale,
                         DATE_LONGDATE,
                         NULL,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "pFormat not null and long date",
                         &NumErrors );

    //  Variation 5  -  pFormat not null AND no user override
    rc = GetDateFormatW( Locale,
                         LOCALE_NOUSEROVERRIDE,
                         NULL,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "pFormat not null and no user override",
                         &NumErrors );

    //  Variation 6  -  Use CP ACP, pFormat not null AND no user override
    rc = GetDateFormatW( Locale,
                         LOCALE_USE_CP_ACP | LOCALE_NOUSEROVERRIDE,
                         NULL,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, pFormat not null and no user override",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchDate = too small
    rc = GetDateFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         lpDateStr,
                         2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchDate too small",
                         &NumErrors );


    //
    //  Bad date passed in.
    //

    //  Variation 1  -  bad wMonth (0)
    MyDate.wYear = 1993;
    MyDate.wMonth = 0;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wMonth (0)",
                         &NumErrors );

    //  Variation 2  -  bad wMonth (13)
    MyDate.wYear = 1993;
    MyDate.wMonth = 13;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wMonth (13)",
                         &NumErrors );

    //  Variation 3  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 32;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (May 32)",
                         &NumErrors );

    //  Variation 4  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 4;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 31;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (April 31)",
                         &NumErrors );

    //  Variation 5  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 6;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 31;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (June 31)",
                         &NumErrors );

    //  Variation 6  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 9;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 31;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (Sept 31)",
                         &NumErrors );

    //  Variation 7  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 11;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 31;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (Nov 31)",
                         &NumErrors );

    //  Variation 8  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 2;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 29;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (Feb 29, 1993)",
                         &NumErrors );

    //  Variation 9  -  bad wDay
    MyDate.wYear = 1993;
    MyDate.wMonth = 2;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 30;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (Feb 30, 1993)",
                         &NumErrors );

    //  Variation 10  -  bad wDay
    MyDate.wYear = 2100;
    MyDate.wMonth = 2;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 29;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wDay (Feb 29, 2100)",
                         &NumErrors );

    //  Variation 11  -  bad wDayOfWeek
    MyDate.wYear = 1993;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 7;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "bad wDayOfWeek (7)",
                       &NumErrors );

    //  Variation 12  -  bad wDayOfWeek
    MyDate.wYear = 1993;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 4;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( Locale,
                         0,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "bad wDayOfWeek (Thursday, May 1, 1993)",
                       &NumErrors );



    //
    //  DATE_LTRREADING and DATE_RTLREADING flags.
    //

    SetLastError(0);
    rc = GetDateFormatW( Locale,
                         DATE_LTRREADING | DATE_RTLREADING,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "LTR and RTL flags",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GDF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GDF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyDate;            // structure to hold custom date
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetDateFormatW( LOCALE_SYSTEM_DEFAULT,
                         0,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "system default locale",
                      &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetDateFormatW( LOCALE_USER_DEFAULT,
                         0,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "current user locale",
                      &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  neutral
    rc = GetDateFormatW( 0x0000,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "neutral locale",
                       &NumErrors );

    //  Variation 2  -  sys default
    rc = GetDateFormatW( 0x0400,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "sys default locale",
                       &NumErrors );

    //  Variation 3  -  user default
    rc = GetDateFormatW( 0x0800,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "user default locale",
                       &NumErrors );

    //  Variation 4  -  sub lang neutral US
    rc = GetDateFormatW( 0x0009,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "sub lang neutral US",
                       &NumErrors );

    //  Variation 5  -  sub lang neutral Czech
    rc = GetDateFormatW( 0x0005,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       CZECH,
                       "sub lang neutral Czech",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = GetDateFormatW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_USE_CP_ACP,
                         NULL,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "Use CP ACP, system default locale",
                      &NumErrors );


    //
    //  cchDate.
    //

    //  Variation 1  -  cchDate = size of lpDateStr buffer
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "cchDate = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchDate = 0
    lpDateStr[0] = 0x0000;
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       ENGLISH_US,
                       "cchDate zero",
                       &NumErrors );

    //  Variation 3  -  cchDate = 0, lpDateStr = NULL
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         NULL,
                         NULL,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       ENGLISH_US,
                       "cchDate (NULL ptr)",
                       &NumErrors );


    //
    //  lpFormat.
    //

    //  Variation 1  -  Year
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"yyyy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       YEAR,
                       "lpFormat year (yyyy)",
                       &NumErrors );

    //  Variation 2  -  Year
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"yyy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       YEAR,
                       "lpFormat year (yyy)",
                       &NumErrors );

    //  Variation 3  -  Year
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"yyyyy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       YEAR,
                       "lpFormat year (yyyyy)",
                       &NumErrors );

    //  Variation 4  -  Year
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"yy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       YEAR_2,
                       "lpFormat year (yy)",
                       &NumErrors );

    //  Variation 5  -  Year
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"y",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       YEAR_2,
                       "lpFormat year (y)",
                       &NumErrors );

    //  Variation 6  -  US day of week
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_DAYOFWEEK,
                       "US day of week",
                       &NumErrors );

    //  Variation 7  -  US day of week
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"ddddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_DAYOFWEEK,
                       "US day of week (ddddd)",
                       &NumErrors );

    //  Variation 8  -  US abbrev day of week
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"ddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_ABBREVDAY,
                       "US abbrev day of week",
                       &NumErrors );

    //  Variation 9  -  US Month
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_MONTH,
                       "US Month",
                       &NumErrors );

    //  Variation 10  -  US Month
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"MMMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_MONTH,
                       "US Month (MMMMM)",
                       &NumErrors );

    //  Variation 11  -  US Abbrev Month
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"MMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       US_ABBREVMONTH,
                       "US Abbrev Month",
                       &NumErrors );

    //  Variation 12  -  SPANISH day of week
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"dddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_DAYOFWEEK,
                       "SPANISH day of week",
                       &NumErrors );

    //  Variation 13  -  SPANISH day of week
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"ddddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_DAYOFWEEK,
                       "SPANISH day of week (ddddd)",
                       &NumErrors );

    //  Variation 14  -  SPANISH abbrev day of week
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"ddd",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_ABBREVDAY,
                       "SPANISH abbrev day of week",
                       &NumErrors );

    //  Variation 15  -  SPANISH Month
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_MONTH,
                       "SPANISH Month",
                       &NumErrors );

    //  Variation 16  -  SPANISH Month
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"MMMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_MONTH,
                       "SPANISH Month (MMMMM)",
                       &NumErrors );

    //  Variation 17  -  SPANISH Abbrev Month
    rc = GetDateFormatW( 0x040a,
                         0,
                         &SysDate,
                         L"MMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       SPANISH_ABBREVMONTH,
                       "SPANISH Abbrev Month",
                       &NumErrors );


    //
    //  Single quote usage.
    //

    //  Variation 1  -  US single quote
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"dddd, MMMM dd, '''yy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"Saturday, May 01, 'yy",
                       "US single quote",
                       &NumErrors );

    //  Variation 2  -  US single quote 2
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L"dddd, MMMM dd, ''''yy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"Saturday, May 01, '93",
                       "US single quote 2",
                       &NumErrors );

    //  Variation 3  -  US single quote 3
    rc = GetDateFormatW( Locale,
                         0,
                         &SysDate,
                         L" 'year: '''yy",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L" year: '93",
                       "US single quote 3",
                       &NumErrors );

    //  Variation 4  -  SHORTDATE single quote
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_SSHORTDATE,
                         pSShortDate,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GetLocaleInfoW SSHORTDATE",
                      &NumErrors );

    rc = SetLocaleInfoW( 0x0409,
                         LOCALE_SSHORTDATE,
                         L"MM''''dd''''yy" );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetLocaleInfoW SSHORTDATE",
                       &NumErrors );

    rc = GetDateFormatW( 0x0409,
                         DATE_SHORTDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"05'01'93",
                       "ShortDate single quote 1",
                       &NumErrors );

    rc = SetLocaleInfoW( 0x0409,
                         LOCALE_SSHORTDATE,
                         L"'Date: 'MMM ''''yy" );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetLocaleInfoW SSHORTDATE",
                       &NumErrors );

    rc = GetDateFormatW( 0x0409,
                         DATE_SHORTDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"Date: May '93",
                       "ShortDate single quote 2",
                       &NumErrors );

    rc = SetLocaleInfoW( 0x0409,
                         LOCALE_SSHORTDATE,
                         pSShortDate );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetLocaleInfoW SSHORTDATE Final",
                       &NumErrors );


    //
    //  Test all locales - Short Date flag value.
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetDateFormatW( pAllLocales[ctr],
                             DATE_SHORTDATE,
                             &SysDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpDateStr,
                               pShortDate[ctr],
                               "ShortDate",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  Test all locales - Long Date flag value.
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetDateFormatW( pAllLocales[ctr],
                             DATE_LONGDATE,
                             &SysDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpDateStr,
                               pLongDate[ctr],
                               "LongDate",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  Test all locales - Year Month flag value.
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetDateFormatW( pAllLocales[ctr],
                             DATE_YEARMONTH,
                             &SysDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpDateStr,
                               pYearMonth[ctr],
                               "YearMonth",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  NO User Override flag value.
    //

    //  Variation 1  -  NOUSEROVERRIDE
    rc = GetDateFormatW( Locale,
                         LOCALE_NOUSEROVERRIDE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "NoUserOverride",
                       &NumErrors );


    //
    //  Test Russian date formats.
    //
    //  Variation 1 -  LONGDATE Russian
    rc = GetDateFormatW( 0x0419,
                         0,
                         &SysDate,
                         L"MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_RUSSIAN_2,
                       "LongDate Russian 2",
                       &NumErrors );

    //  Variation 2 -  LONGDATE Russian
    rc = GetDateFormatW( 0x0419,
                         0,
                         &SysDate,
                         L"MMMM d",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_RUSSIAN_3,
                       "LongDate Russian 3",
                       &NumErrors );

    //  Variation 3 -  LONGDATE Russian
    rc = GetDateFormatW( 0x0419,
                         0,
                         &SysDate,
                         L"d yy MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_RUSSIAN_4,
                       "LongDate Russian 4",
                       &NumErrors );


    //
    //  Test Polish date formats.
    //
    //  Variation 1 -  LONGDATE Polish
    rc = GetDateFormatW( 0x0415,
                         0,
                         &SysDate,
                         L"MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_POLISH_2,
                       "LongDate Polish 2",
                       &NumErrors );

    //  Variation 2 -  LONGDATE Polish
    rc = GetDateFormatW( 0x0415,
                         0,
                         &SysDate,
                         L"MMMM d",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_POLISH_3,
                       "LongDate Polish 3",
                       &NumErrors );

    //  Variation 3 -  LONGDATE Polish
    rc = GetDateFormatW( 0x0415,
                         0,
                         &SysDate,
                         L"d yy MMMM",
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_POLISH_4,
                       "LongDate Polish 4",
                       &NumErrors );


    //
    //  Test various calendars.
    //

    //  Variation 1 -  English
    rc = GetDateFormatW( 0x0409,
                         DATE_USE_ALT_CALENDAR,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       ENGLISH_US,
                       "Alt Calendar English (ShortDate)",
                       &NumErrors );

    //  Variation 2 -  English
    rc = GetDateFormatW( 0x0409,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_ENGLISH_US,
                       "Alt Calendar English (LongDate)",
                       &NumErrors );

    //  Variation 3 -  Japan
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       JAPAN_ALT,
                       "Alt Calendar Japan (ShortDate)",
                       &NumErrors );

    //  Variation 4 -  Japan
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_JAPAN_ALT,
                       "Alt Calendar Japan (LongDate)",
                       &NumErrors );

#if 0
    //  Variation 5 -  China
    rc = GetDateFormatW( 0x0404,
                         DATE_USE_ALT_CALENDAR,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       CHINA_ALT,
                       "Alt Calendar China (ShortDate)",
                       &NumErrors );

    //  Variation 6 -  China
    rc = GetDateFormatW( 0x0404,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_CHINA_ALT,
                       "Alt Calendar China (LongDate)",
                       &NumErrors );
#endif

    //  Variation 7 -  Korea
    rc = GetDateFormatW( 0x0412,
                         DATE_USE_ALT_CALENDAR,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       KOREA_ALT,
                       "Alt Calendar Korea (ShortDate)",
                       &NumErrors );

    //  Variation 8 -  Korea
    rc = GetDateFormatW( 0x0412,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_KOREA_ALT,
                       "Alt Calendar Korea (LongDate)",
                       &NumErrors );



    //
    //  Different dates for calendars.
    //

    //  Variation 1 -  Japan
    MyDate.wYear = 1913;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_JAPAN_ALT_2,
                       "Alt Calendar Japan (long) 2",
                       &NumErrors );

#if 0
    //  Variation 2 -  China
    MyDate.wYear = 1832;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0404,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_CHINA_ALT_2,
                       "Alt Calendar China (long) 2",
                       &NumErrors );
#endif

    //  Variation 3 -  Korea
    MyDate.wYear = 1832;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0412,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_KOREA_ALT_2,
                       "Alt Calendar Korea (long) 2",
                       &NumErrors );

    //  Variation 4 -  Japan
    MyDate.wYear = 1832;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L_JAPAN_ALT_3,
                       "Alt Calendar Japan (long) 3",
                       &NumErrors );


    //  Variation 5 -  Japan
    MyDate.wYear = 1989;
    MyDate.wMonth = 1;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 8;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x5e73\x6210 1/1/8",
                       "Alt Calendar Japan (short) 1",
                       &NumErrors );

    //  Variation 6 -  Japan
    MyDate.wYear = 1989;
    MyDate.wMonth = 1;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 7;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x662d\x548c 64/1/7",
                       "Alt Calendar Japan (short) 2",
                       &NumErrors );

    //  Variation 7 -  Japan
    MyDate.wYear = 1989;
    MyDate.wMonth = 2;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 3;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x5e73\x6210 1/2/3",
                       "Alt Calendar Japan (short) 3",
                       &NumErrors );

    //  Variation 8 -  Japan
    MyDate.wYear = 1926;
    MyDate.wMonth = 2;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 3;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x5927\x6b63 15/2/3",
                       "Alt Calendar Japan (short) 4",
                       &NumErrors );

    //  Variation 9 -  Japan
    MyDate.wYear = 1989;
    MyDate.wMonth = 1;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 8;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x5e73\x6210 1\x5e74\x0031\x6708\x0038\x65e5",
                       "Alt Calendar Japan (long) 4",
                       &NumErrors );

    //  Variation 10 -  Japan
    MyDate.wYear = 1989;
    MyDate.wMonth = 1;
    MyDate.wDayOfWeek = 1;
    MyDate.wDay = 7;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;
    rc = GetDateFormatW( 0x0411,
                         DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x662d\x548c 64\x5e74\x0031\x6708\x0037\x65e5",
                       "Alt Calendar Japan (long) 5",
                       &NumErrors );


    //
    //  DATE_LTRREADING and DATE_RTLREADING flags.
    //

    rc = GetDateFormatW( Locale,
                         DATE_LTRREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200e\x0035/\x200e\x0031/\x200e\x0031\x0039\x0039\x0033",
                       "LTR flag (shortdate) - US",
                       &NumErrors );

    rc = GetDateFormatW( Locale,
                         DATE_RTLREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200f\x0035/\x200f\x0031/\x200f\x0031\x0039\x0039\x0033",
                       "RTL flag (shortdate) - US",
                       &NumErrors );

    rc = GetDateFormatW( Locale,
                         DATE_SHORTDATE | DATE_LTRREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200e\x0035/\x200e\x0031/\x200e\x0031\x0039\x0039\x0033",
                       "LTR flag (shortdate) - US 2",
                       &NumErrors );

    rc = GetDateFormatW( Locale,
                         DATE_SHORTDATE | DATE_RTLREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200f\x0035/\x200f\x0031/\x200f\x0031\x0039\x0039\x0033",
                       "RTL flag (shortdate) - US 2",
                       &NumErrors );

    rc = GetDateFormatW( Locale,
                         DATE_LONGDATE | DATE_LTRREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200eSaturday, \x200eMay \x200e\x0030\x0031, \x200e\x0031\x0039\x0039\x0033",
                       "LTR flag (longdate) - US",
                       &NumErrors );

    rc = GetDateFormatW( Locale,
                         DATE_LONGDATE | DATE_RTLREADING,
                         &SysDate,
                         NULL,
                         lpDateStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpDateStr,
                       L"\x200fSaturday, \x200fMay \x200f\x0030\x0031, \x200f\x0031\x0039\x0039\x0033",
                       "RTL flag (longdate) - US",
                       &NumErrors );

    // Iran - Farsi
    if (IsValidLocale(0x0429, LCID_INSTALLED))
    {
        rc = GetDateFormatW( 0x0429,
                             DATE_LTRREADING,
                             &SysDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"\x200e\x0035/\x200e\x0031/\x200e\x0031\x0039\x0039\x0033",
                           "LTR - Iran Farsi",
                           &NumErrors );

        rc = GetDateFormatW( 0x0429,
                             DATE_RTLREADING,
                             &SysDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"\x200f\x0035/\x200f\x0031/\x200f\x0031\x0039\x0039\x0033",
                           "RTL - Iran Farsi",
                           &NumErrors );
    }



    //
    //  Hijri Calendar.
    //

    if (IsValidLocale(0x0401, LCID_INSTALLED))
    {
        //  Variation 1  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x0401,
                             DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"07/12/64",
                           "Hijri (short) 1",
                           &NumErrors );

        //  Variation 2  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x0401,
                             DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"07/\x0630\x0648\x00a0\x0627\x0644\x062d\x062c\x0629/1364",   // year 1364
                           "Hijri (long) 1",
                           &NumErrors );

        //  Variation 3  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x0401,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"07/12/64",     // year 1364
                           "Alt Calendar Hijri (short) 1",
                           &NumErrors );

        //  Variation 4  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x0401,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"07/\x0630\x0648\x00a0\x0627\x0644\x062d\x062c\x0629/1364",   // year 1364
                           "Alt Calendar Hijri (long) 1",
                           &NumErrors );
    }



    //
    //  Hebrew Calendar.
    //

    if (IsValidLocale(0x040d, LCID_INSTALLED))
    {
        //  Variation 1  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"12/11/1945",
                           "Hebrew (short) 1",
                           &NumErrors );

        //  Variation 2  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,
                           -1,
                           lpDateStr,
                           L"\x05d9\x05d5\x05dd\x00a0\x05e9\x05e0\x05d9 12 \x05e0\x05d5\x05d1\x05de\x05d1\x05e8 1945",
                           "Hebrew (long) 1",
                           &NumErrors );

        //  Variation 3  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,                        // Kislev 7, 5706
                           -1,
                           lpDateStr,
                           L"\x05d6'/\x05db\x05e1\x05dc\x05d5/\x05ea\x05e9\"\x05d5",
                           "Alt Calendar Hebrew (short) 1",
                           &NumErrors );

        //  Variation 4  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,                        // Kislev 7, 5706
                           -1,
                           lpDateStr,
                           L"\x05d9\x05d5\x05dd\x00a0\x05e9\x05e0\x05d9 \x05d6' \x05db\x05e1\x05dc\x05d5 \x05ea\x05e9\"\x05d5",
                           "Alt Calendar Hebrew (long) 1",
                           &NumErrors );

        //  Variation 5  -  Hebrew
        MyDate.wYear = 1984;
        MyDate.wMonth = 9;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 27;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,                        // Tishri 1, 5745
                           -1,
                           lpDateStr,
                           L"\x05d0'/\x05ea\x05e9\x05e8\x05d9/\x05ea\x05e9\x05de\"\x05d4",
                           "Alt Calendar Hebrew (short) 2",
                           &NumErrors );


        //  Variation 6  -  Hebrew
        MyDate.wYear = 1984;
        MyDate.wMonth = 9;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 27;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatW( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             lpDateStr,
                             BUFSIZE );
        CheckReturnValidW( rc,                        // Tishri 1, 5745
                           -1,
                           lpDateStr,
                           L"\x05d9\x05d5\x05dd\x00a0\x05d7\x05de\x05d9\x05e9\x05d9 \x05d0' \x05ea\x05e9\x05e8\x05d9 \x05ea\x05e9\x05de\"\x05d4",
                           "Alt Calendar Hebrew (long) 2",
                           &NumErrors );
    }


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GDF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GDF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyDate;            // structure to hold custom date
    BYTE pDateStrA[BUFSIZE];      // ptr to date string


    MyDate.wYear = 1993;
    MyDate.wMonth = 5;
    MyDate.wDayOfWeek = 6;
    MyDate.wDay = 1;
    MyDate.wHour = 15;
    MyDate.wMinute = 45;
    MyDate.wSecond = 25;
    MyDate.wMilliseconds = 13;


    //
    //  GetDateFormatA.
    //

    //  Variation 1  -  US single quote
    rc = GetDateFormatA( Locale,
                         0,
                         &MyDate,
                         "dddd, MMMM dd, ''''yy",
                         pDateStrA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pDateStrA,
                       "Saturday, May 01, '93",
                       NULL,
                       "A version US single quote",
                       &NumErrors );

    //  Variation 2  -  US single quote (no dest)
    rc = GetDateFormatA( Locale,
                         0,
                         &MyDate,
                         "dddd, MMMM dd, ''''yy",
                         NULL,
                         0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "Saturday, May 01, '93",
                       NULL,
                       "A version US single quote, no Dest",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, US single quote
    rc = GetDateFormatA( Locale,
                         LOCALE_USE_CP_ACP,
                         &MyDate,
                         "dddd, MMMM dd, ''''yy",
                         pDateStrA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pDateStrA,
                       "Saturday, May 01, '93",
                       NULL,
                       "A version Use CP ACP, US single quote",
                       &NumErrors );


    //
    //  Make sure the A and W versions set the same error value.
    //

    SetLastError(0);
    rc = GetDateFormatA( Locale,
                         DATE_SHORTDATE,
                         &MyDate,
                         NULL,
                         pDateStrA,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W same bad param - A version",
                         &NumErrors );

    SetLastError(0);
    rc = GetDateFormatW( Locale,
                         DATE_SHORTDATE,
                         &MyDate,
                         NULL,
                         lpDateStr,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W same bad param - W version",
                         &NumErrors );


    //
    //  DATE_LTRREADING and DATE_RTLREADING flags.
    //

    SetLastError(0);
    rc = GetDateFormatA( Locale,
                         DATE_LTRREADING | DATE_RTLREADING,
                         &MyDate,
                         NULL,
                         pDateStrA,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "A version - LTR and RTL flags",
                         &NumErrors );

    SetLastError(0);
    rc = GetDateFormatA( Locale,
                         DATE_LTRREADING,
                         &MyDate,
                         NULL,
                         pDateStrA,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "A version - LTR flag",
                         &NumErrors );

    SetLastError(0);
    rc = GetDateFormatA( Locale,
                         DATE_RTLREADING,
                         &MyDate,
                         NULL,
                         pDateStrA,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "A version - RTL flag",
                         &NumErrors );

    // Iran - Farsi
    if (IsValidLocale(0x0429, LCID_INSTALLED))
    {
        rc = GetDateFormatA( 0x0429,
                             DATE_LTRREADING,
                             &SysDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "\xfd\x35/\xfd\x31/\xfd\x31\x39\x39\x33",
                           NULL,
                           "A version - LTR - Iran Farsi",
                           &NumErrors );

        rc = GetDateFormatA( 0x0429,
                             DATE_RTLREADING,
                             &SysDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "\xfe\x35/\xfe\x31/\xfe\x31\x39\x39\x33",
                           NULL,
                           "A version - RTL - Iran Farsi",
                           &NumErrors );
    }



    //
    //  Hijri Calendar.
    //

    if (IsValidLocale(0x0401, LCID_INSTALLED))
    {
        //  Variation 1  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x0401,
                             DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "07/12/64",
                           NULL,
                           "A version Hijri (short) 1",
                           &NumErrors );

        //  Variation 2  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x0401,
                             DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "07/\xd0\xe6\xa0\xc7\xe1\xcd\xcc\xc9/1364",   // year 1364
                           NULL,
                           "A version Hijri (long) 1",
                           &NumErrors );

        //  Variation 3  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x0401,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "07/12/64",     // year 1364
                           NULL,
                           "A version Alt Calendar Hijri (short) 1",
                           &NumErrors );

        //  Variation 4  -  Hijri
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x0401,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "07/\xd0\xe6\xa0\xc7\xe1\xcd\xcc\xc9/1364",   // year 1364
                           NULL,
                           "A version Alt Calendar Hijri (long) 1",
                           &NumErrors );
    }



    //
    //  Hebrew Calendar.
    //

    if (IsValidLocale(0x040d, LCID_INSTALLED))
    {
        //  Variation 1  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "12/11/1945",
                           NULL,
                           "A version Hebrew (short) 1",
                           &NumErrors );

        //  Variation 2  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,
                           -1,
                           pDateStrA,
                           "\xe9\xe5\xed\xa0\xf9\xf0\xe9 12 \xf0\xe5\xe1\xee\xe1\xf8 1945",
                           NULL,
                           "A version Hebrew (long) 1",
                           &NumErrors );

        //  Variation 3  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,                        // Kislev 7, 5706
                           -1,
                           pDateStrA,
                           "\xe6'/\xeb\xf1\xec\xe5/\xfa\xf9\"\xe5",
                           NULL,
                           "A version Alt Calendar Hebrew (short) 1",
                           &NumErrors );

        //  Variation 4  -  Hebrew
        MyDate.wYear = 1945;
        MyDate.wMonth = 11;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 12;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,                        // Kislev 7, 5706
                           -1,
                           pDateStrA,
                           "\xe9\xe5\xed\xa0\xf9\xf0\xe9 \xe6' \xeb\xf1\xec\xe5 \xfa\xf9\"\xe5",
                           NULL,
                           "A version Alt Calendar Hebrew (long) 1",
                           &NumErrors );

        //  Variation 5  -  Hebrew
        MyDate.wYear = 1984;
        MyDate.wMonth = 9;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 27;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_SHORTDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,                        // Tishri 1, 5745
                           -1,
                           pDateStrA,
                           "\xe0'/\xfa\xf9\xf8\xe9/\xfa\xf9\xee\"\xe4",
                           NULL,
                           "A version Alt Calendar Hebrew (short) 2",
                           &NumErrors );


        //  Variation 6  -  Hebrew
        MyDate.wYear = 1984;
        MyDate.wMonth = 9;
        MyDate.wDayOfWeek = 1;
        MyDate.wDay = 27;
        MyDate.wHour = 15;
        MyDate.wMinute = 45;
        MyDate.wSecond = 25;
        MyDate.wMilliseconds = 13;
        rc = GetDateFormatA( 0x040d,
                             DATE_USE_ALT_CALENDAR | DATE_LONGDATE,
                             &MyDate,
                             NULL,
                             pDateStrA,
                             BUFSIZE );
        CheckReturnValidA( rc,                        // Tishri 1, 5745
                           -1,
                           pDateStrA,
                           "\xe9\xe5\xed\xa0\xe7\xee\xe9\xf9\xe9 \xe0' \xfa\xf9\xf8\xe9 \xfa\xf9\xee\"\xe4",
                           NULL,
                           "A version Alt Calendar Hebrew (long) 2",
                           &NumErrors );
    }


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gettest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gettest.c

Abstract:

    Test module for NLS API IsValidCodePage, IsValidLocale, IsValidLanguageGroup,
                            GetACP, GetOEMCP,
                            GetSystemDefaultUILanguage, GetUserDefaultUILanguage,
                            GetSystemDefaultLangID, GetUserDefaultLangID,
                            GetSystemDefaultLCID, GetUserDefaultLCID,
                            GetThreadLocale, SetThreadLocale.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Forward Declarations.
//

int
IVCP_NormalCase();

int
IVLC_NormalCase();

int
IVLG_NormalCase();

int
GUAPI_NormalCase();





////////////////////////////////////////////////////////////////////////////
//
//  TestIsValidCodePage
//
//  Test routine for IsValidCodePage API.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int TestIsValidCodePage()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING IsValidCodePage...\n\n");

    //
    //  Test normal cases.
    //
    ErrCount += IVCP_NormalCase();

    //
    //  Print out result.
    //
    printf("\nIsValidCodePage:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  IVCP_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int IVCP_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    BOOL rc;                      // return code


    //
    //  Different values for CodePage.
    //

    //  Variation 1  -  CP_ACP
    rc = IsValidCodePage( CP_ACP );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "CP_ACP",
                       &NumErrors );

    //  Variation 2  -  CP_OEMCP
    rc = IsValidCodePage( CP_OEMCP );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "CP_OEMCP",
                       &NumErrors );

    //  Variation 3  -  CP 6
    rc = IsValidCodePage( 6 );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "CP 6",
                       &NumErrors );

    //  Variation 4  -  CP 1252
    rc = IsValidCodePage( 1252 );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "CP 1252",
                       &NumErrors );

    //  Variation 5  -  CP 437
    rc = IsValidCodePage( 437 );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "CP 437",
                       &NumErrors );

    //  Variation 6  -  CP 37
    rc = IsValidCodePage( 37 );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "CP 37",
                       &NumErrors );

    //  Variation 7  -  CP 65000 (UTF-7)
    rc = IsValidCodePage( 65000 );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "CP 65000",
                       &NumErrors );


    //  Variation 8  -  CP 65001 (UTF-8)
    rc = IsValidCodePage( 65001 );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "CP 65001",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  TestIsValidLocale
//
//  Test routine for IsValidLocale API.
//
//  07-26-93 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int TestIsValidLocale()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING IsValidLocale...\n\n");

    //
    //  Test normal cases.
    //
    ErrCount += IVLC_NormalCase();

    //
    //  Print out result.
    //
    printf("\nIsValidLocale:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  IVLC_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  07-26-93 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int IVLC_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    BOOL rc;                      // return code


    //
    //  Invalid values for Locale.
    //

    //  Variation 1  -  Neutral Locale
    rc = IsValidLocale( 0x00000000,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "LOCALE_NEUTRAL",
                       &NumErrors );

    //  Variation 2  -  System Default Locale
    rc = IsValidLocale( LOCALE_SYSTEM_DEFAULT,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "LOCALE_SYSTEM_DEFAULT",
                       &NumErrors );

    //  Variation 3  -  User Default Locale
    rc = IsValidLocale( LOCALE_USER_DEFAULT,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "LOCALE_USER_DEFAULT",
                       &NumErrors );

    //  Variation 4  -  LCID 01000409
    rc = IsValidLocale( 0x01000409,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "invalid (0x01000409)",
                       &NumErrors );

    //  Variation 5  -  invalid flag
    rc = IsValidLocale( 0x00000409,
                        0x10000000 );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "invalid flag",
                       &NumErrors );

    //  Variation 6  -  LCID 00010407
    rc = IsValidLocale( 0x00010407,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "sort bit (0x00010407)",
                       &NumErrors );

    //  Variation 7  -  LCID 00010409
    rc = IsValidLocale( 0x00010409,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "sort bit (0x00010409)",
                       &NumErrors );



    //
    //  Valid values for locale.
    //

    //  Variation 1  -  LCID 00000409 supported
    rc = IsValidLocale( 0x00000409,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 0x0409",
                       &NumErrors );

    //  Variation 2  -  LCID 00000409 installed
    rc = IsValidLocale( 0x00000409,
                        LCID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x0409",
                       &NumErrors );

    //  Variation 3  -  LCID 0000041f supported
    rc = IsValidLocale( 0x0000041f,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 0x041f",
                       &NumErrors );

    //  Variation 4  -  LCID 0000041f installed
    rc = IsValidLocale( 0x0000041f,
                        LCID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x041f",
                       &NumErrors );

    //  Variation 5  -  LCID 00000408 supported
    rc = IsValidLocale( 0x00000408,
                        LCID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 0x0408",
                       &NumErrors );

    //  Variation 6  -  LCID 00000408 installed
    rc = IsValidLocale( 0x00000408,
                        LCID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x0408",
                       &NumErrors );

    //  Variation 7  -  LCID 00000411 installed
    rc = IsValidLocale( 0x00000411,
                        LCID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed (0x00000411)",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  TestIsValidLanguageGroup
//
//  Test routine for IsValidLanguageGroup API.
//
//  03-10-98 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int TestIsValidLanguageGroup()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING IsValidLanguageGroup...\n\n");

    //
    //  Test normal cases.
    //
    ErrCount += IVLG_NormalCase();

    //
    //  Print out result.
    //
    printf("\nIsValidLanguageGroup:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  IVLG_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int IVLG_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    BOOL rc;                      // return code


    //
    //  Invalid values for Language Groups.
    //

    //  Variation 1  -  Neutral Language Group
    rc = IsValidLanguageGroup( 0x0,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "Language Group NEUTRAL",
                       &NumErrors );

    //  Variation 2  -  Invalid Language Group
    rc = IsValidLanguageGroup( 0x12,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "Invalid (0x12)",
                       &NumErrors );

    //  Variation 3  -  Invalid Language Group
    rc = IsValidLanguageGroup( 18,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "Invalid (18)",
                       &NumErrors );

    //  Variation 4  -  Invalid Language Group
    rc = IsValidLanguageGroup( 0x0100,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "invalid (0x0100)",
                       &NumErrors );

    //  Variation 5  -  invalid flag
    rc = IsValidLanguageGroup( 1,
                               0x10000000 );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "invalid flag",
                       &NumErrors );



    //
    //  Valid values for language groups.
    //

    //  Variation 1  -  LGRPID 1 supported
    rc = IsValidLanguageGroup( 1,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 1",
                       &NumErrors );

    //  Variation 2  -  LGRPID 1 installed
    rc = IsValidLanguageGroup( 1,
                               LGRPID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x0409",
                       &NumErrors );

    //  Variation 3  -  LGRPID 0x1 supported
    rc = IsValidLanguageGroup( 0x1,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 0x1",
                       &NumErrors );

    //  Variation 4  -  LGRPID 0x1 installed
    rc = IsValidLanguageGroup( 0x1,
                               LGRPID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x1",
                       &NumErrors );

    //  Variation 5  -  LGRPID 0x4 supported
    rc = IsValidLanguageGroup( 0x4,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported 0x4",
                       &NumErrors );

    //  Variation 6  -  LGRPID 0x4 installed
    rc = IsValidLanguageGroup( 0x4,
                               LGRPID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed 0x4",
                       &NumErrors );

    //  Variation 7  -  LGRPID 0xe supported
    rc = IsValidLanguageGroup( 0xe,
                               LGRPID_SUPPORTED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "supported (0xe)",
                       &NumErrors );

    //  Variation 8  -  LGRPID 0xe installed
    rc = IsValidLanguageGroup( 0xe,
                               LGRPID_INSTALLED );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "installed (0xe)",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  TestUtilityAPIs
//
//  Test routine for Utility APIs.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int TestUtilityAPIs()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetACP, GetOEMCP,\n");
    printf("        GetSystemDefaultUILanguage, GetUserDefaultUILanguage,\n");
    printf("        GetSystemDefaultLangID, GetUserDefaultLangID,\n");
    printf("        GetSystemDefaultLCID, GetUserDefaultLCID,\n");
    printf("        GetThreadLocale, SetThreadLocale...\n\n");

    //
    //  Test normal cases.
    //
    ErrCount += GUAPI_NormalCase();

    //
    //  Print out result.
    //
    printf("\nGetUtilityAPIs:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}

DWORD GetRegistryString(HKEY hRootKey, LPWSTR szKeyPath, LPWSTR szKeyName, LPWSTR pBuffer, DWORD dwBufferLen) 
{
    HKEY hKey;
    DWORD cbData;
    DWORD result = 0;
    DWORD dwType;
    
    if (RegOpenKeyW(hRootKey, szKeyPath, &hKey) == ERROR_SUCCESS) 
    {
        if (pBuffer == NULL) 
        {
            if (RegQueryValueExW(hKey, szKeyName, NULL, NULL, NULL, &cbData) == ERROR_SUCCESS) 
            {
                result = cbData;
            }            
        } else 
        {
            cbData = dwBufferLen;
            if (RegQueryValueExW(hKey, szKeyName, NULL, &dwType, (LPBYTE)pBuffer, &cbData) == ERROR_SUCCESS) 
            {
                if (dwType == REG_SZ) 
                {
                    result = cbData;
                }
            }            
        }
    }
    RegCloseKey(hRootKey);
    return (result);
}

////////////////////////////////////////////////////////////////////////////
//
//  PrivateGetUserDefaultUILanguage
//
//  This routine reads HKCU\Control Panel\Desktop\MultiUILanguageId
//  If that key is not available, return GetSystemDefaultUILanguage();
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

LANGID PrivateGetUserDefaultUILanguage()
{
    WCHAR szValue[256];
    BOOL  bSuccess = FALSE;
    LANGID result;
    
    if (GetRegistryString(HKEY_CURRENT_USER, L"Control Panel\\Desktop", L"MultiUILanguageId", szValue, sizeof(szValue)*sizeof(WCHAR)) > 0) {
        if (swscanf(szValue, L"%x", &result) > 0) 
        {
            return (result);
        }
    }    
    
    if (Verbose)
    {
        printf("....Failed to read HKCU\\Control Panel\\Desktop\\MultiUILanguageId\n");
    }
    return (GetSystemDefaultUILanguage());
}

////////////////////////////////////////////////////////////////////////////
//
//  GUAPI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91 JulieB       Created.
////////////////////////////////////////////////////////////////////////////

int GUAPI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    UINT rcInt;                   // return code
    LANGID rcLang;                // return code
    LCID rcLoc;                   // return code
    LCID rcLoc2;                  // return code
    BOOL rc;                      // return code
    LANGID expectedUILanguage;


#ifdef PERF

  DbgBreakPoint();

#endif


    //  Variation 1  -  GetACP
    rcInt = GetACP();
    CheckReturnValidW( rcInt,
                       1252,
                       NULL,
                       NULL,
                       "GetACP",
                       &NumErrors );

    //  Variation 2  -  GetOEMCP
    rcInt = GetOEMCP();
    CheckReturnValidW( rcInt,
                       437,
                       NULL,
                       NULL,
                       "GetOEMCP",
                       &NumErrors );

    //  Variation 3  -  GetSystemDefaultUILanguage
    rcLang = GetSystemDefaultUILanguage();
    CheckReturnValidW( rcLang,
                       0x0409,
                       NULL,
                       NULL,
                       "GetSystemDefaultUILanguage",
                       &NumErrors );

    //  Variation 4  -  GetUserDefaultUILanguage
    rcLang = GetUserDefaultUILanguage();
    expectedUILanguage = PrivateGetUserDefaultUILanguage();
    
    CheckReturnValidW( rcLang,
                       expectedUILanguage,
                       NULL,
                       NULL,
                       "GetUserDefaultUILanguage",
                       &NumErrors );

    //  Variation 5  -  GetSystemDefaultLangID
    rcLang = GetSystemDefaultLangID();
    CheckReturnValidW( rcLang,
                       0x0409,
                       NULL,
                       NULL,
                       "GetSystemDefaultLangID",
                       &NumErrors );

    //  Variation 6  -  GetUserDefaultLangID
    rcLang = GetUserDefaultLangID();
    CheckReturnValidW( rcLang,
                       0x0409,
                       NULL,
                       NULL,
                       "GetUserDefaultLangID",
                       &NumErrors );

    //  Variation 7  -  GetSystemDefaultLCID
    rcLoc = GetSystemDefaultLCID();
    CheckReturnValidW( rcLoc,
                       0x00000409,
                       NULL,
                       NULL,
                       "GetSystemDefaultLCID",
                       &NumErrors );

    //  Variation 8  -  GetUserDefaultLCID
    rcLoc = GetUserDefaultLCID();
    CheckReturnValidW( rcLoc,
                       0x00000409,
                       NULL,
                       NULL,
                       "GetUserDefaultLCID",
                       &NumErrors );


    //  Variation 9  -  GetThreadLocale and SetThreadLocale
    rcLoc = GetThreadLocale();
    CheckReturnValidW( rcLoc,
                       0x00000409,
                       NULL,
                       NULL,
                       "GetThreadLocale",
                       &NumErrors );

    rc = SetThreadLocale( 0x0000040a );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetThreadLocale 040a",
                       &NumErrors );

    rc = SetThreadLocale( 0x0000080b );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "SetThreadLocale invalid",
                       &NumErrors );

    rc = SetThreadLocale( 0x0100040a );
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "SetThreadLocale invalid 2",
                       &NumErrors );

    rcLoc2 = GetThreadLocale();
    CheckReturnValidW( rcLoc2,
                       0x0000040a,
                       NULL,
                       NULL,
                       "GetThreadLocale 040a",
                       &NumErrors );

    rc = SetThreadLocale( rcLoc );
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetThreadLocale back to original",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\ggitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    ggitest.c

Abstract:

    Test module for NLS API GetGeoInfo, GetUserGeoID, and SetUserGeoID.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    09-12-2000    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             50                  // buffer size in wide chars
#define  GEOTYPE_INVALID     0x0100              // invalid geo type
#define  GEO_INVALID         1                   // invalid geo id
#define  GEOCLASS_INVALID    3                   // invalid geo class

#define  US_NATION           L"244"
#define  US_FRIENDLYNAME     L"United States"
#define  US_OFFICIALNAME     L"United States of America"

#define  US_NATION_A         "244"
#define  US_FRIENDLYNAME_A   "United States"
#define  US_OFFICIALNAME_A   "United States of America"





//
//  Global Variables.
//

LCID Locale;
GEOID GeoId;

WCHAR lpGeoData[BUFSIZE];
BYTE  lpGeoDataA[BUFSIZE];

//
//  pGeoFlag and pGeoString must have the same number of entries.
//
GEOTYPE pGeoFlag[] =
{
    GEO_NATION,
    GEO_LATITUDE,
    GEO_LONGITUDE,
    GEO_ISO2,
    GEO_ISO3,
    GEO_RFC1766,
    GEO_LCID,
    GEO_FRIENDLYNAME,
    GEO_OFFICIALNAME
//  GEO_TIMEZONES,
//  GEO_OFFICIALLANGUAGES
};

#define NUM_GEO_FLAGS     ( sizeof(pGeoFlag) / sizeof(GEOTYPE) )

LPWSTR pGeoString[] =
{
    L"244",
    L"39.45",
    L"-98.908",
    L"US",
    L"USA",
    L"en-us",
    L"00000409",
    L"United States",
    L"United States of America",
};

LPSTR pGeoStringA[] =
{
    "244",
    "39.45",
    "-98.908",
    "US",
    "USA",
    "en-us",
    "00000409",
    "United States",
    "United States of America",
};

LPWSTR pGeoString2[] =
{
    L"122",
    L"35.156",
    L"136.06",
    L"JP",
    L"JPN",
    L"ja-jp",
    L"00000411",
    L"Japan",
    L"Japan",
};

LPSTR pGeoString2A[] =
{
    "122",
    "35.156",
    "136.06",
    "JP",
    "JPN",
    "ja-jp",
    "00000411",
    "Japan",
    "Japan",
};




//
//  Forward Declarations.
//

BOOL
InitGetGeoInfo();

int
GGI_BadParamCheck();

int
GGI_NormalCase();

int
GGI_Ansi();

int
GetSetUserGeoId();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetGeoInfo
//
//  Test routine for GetGeoInfoW API.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetGeoInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetGeoInfoW, GetUserGeoID, SetUserGeoID...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetGeoInfo())
    {
        printf("\nABORTED TestGetGeoInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GGI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GGI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GGI_Ansi();

    //
    //  Test Get and Set.
    //
    ErrCount += GetSetUserGeoId();

    //
    //  Print out result.
    //
    printf("\nGetGeoInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetGeoInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetGeoInfo()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Set the GeoId.
    //
    GeoId = 244;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GGI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GGI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetGeoInfoW( GEO_INVALID,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Geo Id",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpGeoData = NULL
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      NULL,
                      BUFSIZE,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpGeoData NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cbBuf < 0
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      -1,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbBuf < 0",
                         &NumErrors );


    //
    //  Zero or Invalid Type.
    //

    //  Variation 1  -  GeoType = invalid
    rc = GetGeoInfoW( GeoId,
                      GEOTYPE_INVALID,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "GeoType invalid",
                         &NumErrors );

    //  Variation 2  -  GeoType = 0
    rc = GetGeoInfoW( GeoId,
                      0,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "GeoType zero",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cbBuf = too small
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      2,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cbBuf too small",
                         &NumErrors );


    //
    //  Bad GeoId - Not valid in RC file.
    //
    //  Variation 1  -  GEO_NATION - invalid
    rc = GetGeoInfoW( GEO_INVALID,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "invalid geo id",
                         &NumErrors );


    //
    //  Bad LangId.
    //
    //  Variation 1  -  GEO_NATION - invalid
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      (LCID)333 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "invalid lang id",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GGI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GGI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  GeoIds.
    //

    //  Variation 1  -  Current User GeoId
    rc = GetGeoInfoW( GetUserGeoID(GEOCLASS_NATION),
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnEqual( rc,
                      0,
                      "current user geo id",
                      &NumErrors );


    //
    //  cbBuf.
    //

    //  Variation 1  -  cbBuf = size of lpGeoData buffer
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_NATION,
                       "cbBuf = bufsize",
                       &NumErrors );

    //  Variation 2  -  cbBuf = 0
    lpGeoData[0] = 0x0000;
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      0,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       US_NATION,
                       "cbBuf zero",
                       &NumErrors );

    //  Variation 3  -  cbBuf = 0, lpGeoData = NULL
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      NULL,
                      0,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       US_NATION,
                       "cbBuf (NULL ptr)",
                       &NumErrors );


    //
    //  GEOTYPE values.
    //

    for (ctr = 0; ctr < NUM_GEO_FLAGS; ctr++)
    {
        //
        //  United States
        //
        rc = GetGeoInfoW( GeoId,
                          pGeoFlag[ctr],
                          lpGeoData,
                          BUFSIZE,
                          0x0009 );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpGeoData,
                               pGeoString[ctr],
                               "Lang Id 0009, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );

        rc = GetGeoInfoW( GeoId,
                          pGeoFlag[ctr],
                          lpGeoData,
                          BUFSIZE,
                          0x0409 );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpGeoData,
                               pGeoString[ctr],
                               "Lang Id 0409, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );

        //
        //  Japan
        //
        rc = GetGeoInfoW( 122,
                          pGeoFlag[ctr],
                          lpGeoData,
                          BUFSIZE,
                          0x0011 );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpGeoData,
                               pGeoString2[ctr],
                               "Lang Id 0011, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );

        rc = GetGeoInfoW( 122,
                          pGeoFlag[ctr],
                          lpGeoData,
                          BUFSIZE,
                          0x0411 );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpGeoData,
                               pGeoString2[ctr],
                               "Lang Id 0411, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );
    }


    //
    //  RC file - FRIENDLYNAME and OFFICIALNAME.
    //

    //  Variation 1  -  FRIENDLYNAME US
    rc = GetGeoInfoW( 244,
                      GEO_FRIENDLYNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_FRIENDLYNAME,
                       "FriendlyName US",
                       &NumErrors );

    //  Variation 2  -  OFFICIALNAME US
    rc = GetGeoInfoW( 244,
                      GEO_OFFICIALNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_OFFICIALNAME,
                       "OfficialName US",
                       &NumErrors );

    //  Variation 3  -  FRIENDLYNAME Czech
    rc = GetGeoInfoW( 75,
                      GEO_FRIENDLYNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Czech Republic",
                       "FriendlyName Czech",
                       &NumErrors );

    //  Variation 4  -  OFFICIALNAME Czech
    rc = GetGeoInfoW( 75,
                      GEO_OFFICIALNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Czech Republic",
                       "OfficialName Czech",
                       &NumErrors );

    //  Variation 5  -  FRIENDLYNAME Venezuela
    rc = GetGeoInfoW( 249,
                      GEO_FRIENDLYNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Venezuela",
                       "FriendlyName Venezuela",
                       &NumErrors );

    //  Variation 6  -  OFFICIALNAME Venezuela
    rc = GetGeoInfoW( 249,
                      GEO_OFFICIALNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Bolivarian Republic of Venezuela",
                       "OfficialName Venezuela",
                       &NumErrors );

    //  Variation 7  -  FRIENDLYNAME Puerto Rico
    rc = GetGeoInfoW( 202,
                      GEO_FRIENDLYNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Puerto Rico",
                       "FriendlyName Puerto Rico",
                       &NumErrors );

    //  Variation 8  -  OFFICIALNAME Puerto Rico
    rc = GetGeoInfoW( 202,
                      GEO_OFFICIALNAME,
                      lpGeoData,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       L"Puerto Rico",
                       "OfficialName Puerto Rico",
                       &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  lang id - neutral
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_NATION,
                       "lang id (neutral)",
                       &NumErrors );

    //  Variation 2  -  lang id - sub lang neutral US
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0009 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_NATION,
                       "lang id (sub lang neutral US)",
                       &NumErrors );

    //  Variation 5  -  lang id - sub lang neutral Czech
    rc = GetGeoInfoW( GeoId,
                      GEO_NATION,
                      lpGeoData,
                      BUFSIZE,
                      0x0005 );
    CheckReturnValidW( rc,
                       -1,
                       lpGeoData,
                       US_NATION,
                       "lang id (sub lang neutral Czech)",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GGI_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GGI_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


    //
    //  GeoIds.
    //

    //  Variation 1  -  Current User GeoId
    rc = GetGeoInfoA( GetUserGeoID(GEOCLASS_NATION),
                      GEO_NATION,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnEqual( rc,
                      0,
                      "A version - current user geo id",
                      &NumErrors );


    //
    //  cbBuf.
    //

    //  Variation 1  -  cbBuf = size of lpGeoDataA buffer
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_NATION_A,
                       NULL,
                       "A version - cbBuf = bufsize",
                       &NumErrors );

    //  Variation 2  -  cbBuf = 0
    lpGeoDataA[0] = 0x0000;
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      lpGeoDataA,
                      0,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       US_NATION_A,
                       NULL,
                       "A version - cbBuf zero",
                       &NumErrors );

    //  Variation 3  -  cbBuf = 0, lpGeoDataA = NULL
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      NULL,
                      0,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       US_NATION_A,
                       NULL,
                       "A version - cbBuf (NULL ptr)",
                       &NumErrors );


    //
    //  GEOTYPE values.
    //

    for (ctr = 0; ctr < NUM_GEO_FLAGS; ctr++)
    {
        rc = GetGeoInfoA( GeoId,
                          pGeoFlag[ctr],
                          lpGeoDataA,
                          BUFSIZE,
                          0x0009 );
        CheckReturnValidLoopA( rc,
                               -1,
                               lpGeoDataA,
                               pGeoStringA[ctr],
                               "A version - Lang Id 0009, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );

        rc = GetGeoInfoA( GeoId,
                          pGeoFlag[ctr],
                          lpGeoDataA,
                          BUFSIZE,
                          0x0409 );
        CheckReturnValidLoopA( rc,
                               -1,
                               lpGeoDataA,
                               pGeoStringA[ctr],
                               "A version - Lang Id 0409, Geo Flag",
                               pGeoFlag[ctr],
                               &NumErrors );
    }


    //
    //  RC file - FRIENDLYNAME and OFFICIALNAME.
    //

    //  Variation 1  -  FRIENDLYNAME US
    rc = GetGeoInfoA( 244,
                      GEO_FRIENDLYNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_FRIENDLYNAME_A,
                       NULL,
                       "A version - FriendlyName US",
                       &NumErrors );

    //  Variation 2  -  OFFICIALNAME US
    rc = GetGeoInfoA( 244,
                      GEO_OFFICIALNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_OFFICIALNAME_A,
                       NULL,
                       "A version - OfficialName US",
                       &NumErrors );

    //  Variation 3  -  FRIENDLYNAME Czech
    rc = GetGeoInfoA( 75,
                      GEO_FRIENDLYNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       "Czech Republic",
                       NULL,
                       "A version - FriendlyName Czech",
                       &NumErrors );

    //  Variation 4  -  OFFICIALNAME Czech
    rc = GetGeoInfoA( 75,
                      GEO_OFFICIALNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       "Czech Republic",
                       NULL,
                       "A version - OfficialName Czech",
                       &NumErrors );

    //  Variation 5  -  FRIENDLYNAME Venezuela
    rc = GetGeoInfoA( 249,
                      GEO_FRIENDLYNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       "Venezuela",
                       NULL,
                       "A version - FriendlyName Venezuela",
                       &NumErrors );

    //  Variation 6  -  OFFICIALNAME Venezuela
    rc = GetGeoInfoA( 249,
                      GEO_OFFICIALNAME,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0409 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       "Bolivarian Republic of Venezuela",
                       NULL,
                       "A version - OfficialName Venezuela",
                       &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  lang id - neutral
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      lpGeoDataA,
                      BUFSIZE,
                      0 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_NATION_A,
                       NULL,
                       "A version - lang id (neutral)",
                       &NumErrors );

    //  Variation 2  -  lang id - sub lang neutral US
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0009 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_NATION_A,
                       NULL,
                       "A version - lang id (sub lang neutral US)",
                       &NumErrors );

    //  Variation 5  -  lang id - sub lang neutral Czech
    rc = GetGeoInfoA( GeoId,
                      GEO_NATION,
                      lpGeoDataA,
                      BUFSIZE,
                      0x0005 );
    CheckReturnValidA( rc,
                       -1,
                       lpGeoDataA,
                       US_NATION_A,
                       NULL,
                       "A version - lang id (sub lang neutral Czech)",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSetUserGeoId
//
//  This routine tests the normal cases of the Get and Set Geo APIs.
//
//  09-12-00    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GetSetUserGeoId()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    GEOID rcGeo;                  // return code
    GEOID rcGeo2;                 // return code


    rcGeo2 = GetUserGeoID(GEOCLASS_INVALID);
    CheckReturnValidW( rcGeo2,
                       GEOID_NOT_AVAILABLE,
                       NULL,
                       NULL,
                       "GetUserGeoID invalid geoclass",
                       &NumErrors );

    rcGeo2 = GetUserGeoID(GEOCLASS_REGION);
    CheckReturnValidW( rcGeo2,
                       GEOID_NOT_AVAILABLE,
                       NULL,
                       NULL,
                       "GetUserGeoID region geoclass",
                       &NumErrors );

    rcGeo = GetUserGeoID(GEOCLASS_NATION);
    CheckReturnValidW( rcGeo,
                       244,
                       NULL,
                       NULL,
                       "GetUserGeoID",
                       &NumErrors );

    rc = SetUserGeoID(242);
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetUserGeoID 242",
                       &NumErrors );

    rc = SetUserGeoID(1);
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "SetUserGeoID invalid",
                       &NumErrors );

    rc = SetUserGeoID(0);
    CheckReturnValidW( rc,
                       FALSE,
                       NULL,
                       NULL,
                       "SetUserGeoID invalid 2",
                       &NumErrors );

    rcGeo2 = GetUserGeoID(GEOCLASS_NATION);
    CheckReturnValidW( rcGeo2,
                       242,
                       NULL,
                       NULL,
                       "GetUserGeoID 242",
                       &NumErrors );

    rc = SetUserGeoID(rcGeo);
    CheckReturnValidW( rc,
                       TRUE,
                       NULL,
                       NULL,
                       "SetUserGeoID back to original",
                       &NumErrors );

    rcGeo2 = GetUserGeoID(GEOCLASS_NATION);
    CheckReturnValidW( rcGeo2,
                       rcGeo,
                       NULL,
                       NULL,
                       "GetUserGeoID original",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\mbtest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    mbtest.c

Abstract:

    Test module for NLS API MultiByteToWideChar.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE           1024               // buffer size in chars
#define  MB_INVALID_FLAGS  ((DWORD)(~(MB_PRECOMPOSED | MB_COMPOSITE)))




//
//  Global Variables.
//

#define mbMBStr   "This Is A String."

BYTE mbMBStr2[] = "This Is A String.";      // this could get overwritten

#define wcMBStr   L"This Is A String."

WCHAR wcMBDest[BUFSIZE];




//
//  Forward Declarations.
//

int
MB_BadParamCheck();

int
MB_NormalCase();

int
MB_TestFlags();

int
MB_TestDBCS();

int
DoUTF7FunctionTests();

////////////////////////////////////////////////////////////////////////////
//
//  DoTestMultiByteToWideChar
//
//  This routine help to test the MultiByteToWideChar() function.
//
//      lpErrorString   The title to be printed when the test case fails.
//      CodePage        The code page for the byte to be converted to Unicode.
//      dwFlags         The flag to be passed into MultiByteToWideChar()
//      lpMultiByteStr
//      StartIndex      The start index of lpMultiByteStr
//      Count           The char count of lpMultiByteStr
//      bTestNegativeLength Flag to indicate if the test of passing length as -1 should run or not.
//      ExpectReturn    The expected return value of MultiByteToWideChar().  
//                      If error is expected, the value should be 0.
//      lpExpectWdieCharStr The expected conversion result.
//      dwExpectError   The expecter value of GetLastError().  If no error is expected,
//                      this value should be 0.
//
// This rountine will test the following cases and verify them with the expected result.
//
//      1. Pass the count of lpMulitByteStr in to MB2WC() to get the expected return
//         char count.
//      2. Pass -1 as length of lpMulitByteStr to MB2WC() to get the expected return
//         char count.
//      3. Pass the length of lpMulitByteStr in to MB2WC() to get the conversion result.
//      4. Pass -1 as the length of lpMulitByteStr to MB2WC() to get the conversion result.
//
//  04-30-01    YSLin    Created.
////////////////////////////////////////////////////////////////////////////

int DoTestMultiByteToWideChar(
    LPSTR lpErrorString, UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, UINT StartIndex, UINT Count, 
    BOOL bTestNegativeLength,
    LPWSTR lpWideCharStr, int cchWideChar, int ExpectReturn, LPWSTR lpExpectWideCharStr, DWORD dwExpectError)
{
    DWORD dwLastError;
    int NumErrors = 0;
    CHAR TempString[BUFSIZE];
    CHAR ErrorString[BUFSIZE];

    // Check the WCHAR count first.
    int Result = MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr + StartIndex, Count, 
                                     NULL, 0);
    sprintf(ErrorString, "%s (MultiByteToWideChar(%d, 0x%x, \"%s\", %d, NULL, 0)", 
            lpErrorString, 
            CodePage, 
            dwFlags, 
            GetAnsiString((LPSTR)lpMultiByteStr + StartIndex, Count), 
            Count);
            
    if (dwExpectError == 0) 
    {                                             
        CheckReturnValidW( Result,
                           ExpectReturn,
                           NULL,
                           NULL,
                           ErrorString,
                           &NumErrors);
    } else 
    {
        CheckLastError(dwExpectError, lpErrorString, &NumErrors);
    }

    if (bTestNegativeLength) {
        // Check the WCHAR count first (lenght = -1).
        Result = MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr + StartIndex, -1, NULL, 0);
        sprintf(ErrorString, "%s (MultiByteToWideChar(%d, 0x%x, \"%s\", %d, NULL, 0)", 
                lpErrorString, 
                CodePage,
                dwFlags,
                GetAnsiString((LPSTR)lpMultiByteStr + StartIndex, -1), 
                -1);                                     
        if (dwExpectError == 0) 
        {                                             
            CheckReturnValidW( Result,
                               ExpectReturn + 1,
                               NULL,
                               NULL,
                               ErrorString,
                               &NumErrors);
        } else 
        {
            CheckLastError(dwExpectError, lpErrorString, &NumErrors);
        }
    }

    // Do the real conversion.
    Result = MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr + StartIndex, Count, 
                                     lpWideCharStr, cchWideChar);
    sprintf(ErrorString, "%s (MultiByteToWideChar(%d, 0x%x, \"%s\", %d)", 
        lpErrorString, 
        CodePage,
        dwFlags,
        GetAnsiString((LPSTR)lpMultiByteStr + StartIndex, Count), 
        Count);                                     
        
    if (dwExpectError == 0) 
    {                                             
        CheckReturnValidW( Result,
                           ExpectReturn,
                           lpWideCharStr,
                           lpExpectWideCharStr,
                           ErrorString,
                           &NumErrors);
    } else 
    {
        CheckLastError(dwExpectError, lpErrorString, &NumErrors);
    }

    // Do the real conversion with length -1.

    if (bTestNegativeLength)
    {
        strncpy(TempString, lpMultiByteStr + StartIndex, Count);
        TempString[Count] = '\0';

        Count = -1;
        sprintf(ErrorString, "%s (MultiByteToWideChar(%d, 0x%x, \"%s\", %d)", 
                lpErrorString, 
                CodePage,
                dwFlags,
                GetAnsiString((LPSTR)lpMultiByteStr + StartIndex, Count), 
                Count);                                     
        Result = MultiByteToWideChar(CodePage, dwFlags, TempString, Count,
                                         lpWideCharStr, cchWideChar);
        if (dwExpectError == 0) 
        {   
            CheckReturnValidW( Result,
                               ExpectReturn + 1,
                               lpWideCharStr,
                               lpExpectWideCharStr,
                               ErrorString,
                               &NumErrors);
        } else 
        {
            CheckLastError(dwExpectError, lpErrorString, &NumErrors);
        }
    }
    return (NumErrors);
}


//
// 376403  Client RC1  2   Active  Fix Ready   
// *Improper handling of invalid non-direct codes in UTF-7
//
int Regress376403()
{
    int rc;
    int NumErrors = 0;

    printf("\n    ---- Regress 376403 ----\n");
    
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x80\x81",  
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       3,
                       wcMBDest,
                       L"\x0080\x0081",
                       "CodePage CP_UTF7 - Invalid byte input",
                       &NumErrors );

    rc = MultiByteToWideChar( CP_UTF7, 
                              0,
                              "\x2B\x80\x81\x82\x83\x2D",
                              -1,
                              wcMBDest,
                              BUFSIZE);

    CheckReturnValidW( rc,
                       6,
                       wcMBDest,
                       L"\x0080\x0081\x0082\x0083\x002d",
                       "CodePage CP_UTF7 - Invalid byte input 2",
                       &NumErrors );

    return (NumErrors);
}

//
// 381323  Client RC1  2   Active  Fix Ready   
// *NLS: bad decoded multibyte sequences after unfinished multibyte sequences in UTF-8
//
int Regress381323()
{
    int rc;
    int NumErrors = 0;
    
    printf("\n    ---- Regress 381323 ----\n");
    
    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 - Leading byte before end of sequence 1" , 
        CP_UTF8, 0, "\xe1\x80\xe1\x80\x80", 0, 5, TRUE, wcMBDest, BUFSIZE, 1, L"\x1000", 0);

    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 - Leading byte before end of sequence 2" , 
        CP_UTF8, 0, "\xEF\xBF\xEF\xBF\xAE", 0, 5, TRUE, wcMBDest, BUFSIZE, 1, L"\xffee", 0);

    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 - Leading byte before end of sequence 3" , 
        CP_UTF8, 0, "\xF0\xC4\x80", 0, 3, TRUE, wcMBDest, BUFSIZE, 1, L"\x0100", 0);

    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Invalid byte - 1",
        CP_UTF8, 0, "\xEF\xFF\xEE", 0, 3, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION) ;        

    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Invalid byte - 2",
        CP_UTF8, 0, "\xEF\xFF\xAE", 0, 3, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION) ;        

    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Invalid byte - 3",
        CP_UTF8, 0, "\xEF\xBF\xAE", 0, 3, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION) ;        

    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Invalid byte - 4",
        CP_UTF8, 0, "\xEF\xBF\xC0\xBF", 0, 4, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION) ;        
        
    return (NumErrors);
} 

//
// 381433  Client RC1  2   Active  Fix Ready   
// *NLS: disparity decoding invalid (too high) scalar value
//
int Regress381433()
{
    int rc;
    int NumErrors = 0;

    printf("\n    ---- Regress 381433 ----\n");

    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Too high Unicode scalar value", 
        CP_UTF8, 0, "\xF4\x90\x80\x80" , 0, 4, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);
        
    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Too high Unicode scalar value", 
        CP_UTF8, 0, "\xF4\x90\x80\x80\x41\x42\x43" , 0, 7, TRUE, wcMBDest, BUFSIZE, 3, L"ABC", 0);

    return (NumErrors);
} 

//
// 371215  Client RC1  2   Active  Fix Ready   
// *NLS: UTF-8 MultiByteToWideChar does should support the MB_ERR_INVALID_BYTES flag
//
int Regress371215()
{
    int rc;
    int NumErrors = 0;

    printf("\n    ---- Regress 371215 ----\n");

    // Test MB_ERR_INVALID_CHARS flag for UTF8.
    
    // Trailing byte without leading byte.
    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 with MB_ERR_INVALID_CHARS - Trailing with leading", 
        CP_UTF8, MB_ERR_INVALID_CHARS, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_NO_UNICODE_TRANSLATION);

    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 - Trailing with leading", 
        CP_UTF8, 0, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    // Leading byte before end of sequence
    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 with MB_ERR_INVALID_CHARS - Leading byte before end of sequence 1" , 
        CP_UTF8, 0, "\xe1\x80\xe1\x80\x80", 0, 5, TRUE, wcMBDest, BUFSIZE, 1, L"", ERROR_NO_UNICODE_TRANSLATION);


    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 with MB_ERR_INVALID_CHARS - Leading byte before end of sequence 2" , 
        CP_UTF8, MB_ERR_INVALID_CHARS, "\xEF\xBF\xEF\xBF\xAE", 0, 5, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_NO_UNICODE_TRANSLATION);
        

    NumErrors += DoTestMultiByteToWideChar( 
        "Test UTF8 with MB_ERR_INVALID_CHARS - Leading byte before end of sequence 3" , 
        CP_UTF8, MB_ERR_INVALID_CHARS, "\xF0\xC4\x80", 0, 3, TRUE, wcMBDest, BUFSIZE, 1, NULL, ERROR_NO_UNICODE_TRANSLATION);


    // Too high Unicode value (over U+10FFFF)
    NumErrors += DoTestMultiByteToWideChar(
        "Test UTF8 - Too high Unicode scalar value with MB_ERR_INVALID_CHARS", 
        CP_UTF8, MB_ERR_INVALID_CHARS, "\xF4\x90\x80\x80" , 0, 4, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_NO_UNICODE_TRANSLATION);


    // Test invalid flags for UTF8.
    NumErrors += DoTestMultiByteToWideChar( 
        "Verify UTF8 will signal error on invalid flags", 
        CP_UTF8, MB_PRECOMPOSED, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_INVALID_FLAGS);
        
    NumErrors += DoTestMultiByteToWideChar( 
        "Verify UTF8 will signal error on invalid flags", 
        CP_UTF8, MB_COMPOSITE, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_INVALID_FLAGS);
        
    NumErrors += DoTestMultiByteToWideChar( 
        "Verify UTF8 will signal error on invalid flags", 
        CP_UTF8, MB_USEGLYPHCHARS, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_INVALID_FLAGS);

    NumErrors += DoTestMultiByteToWideChar( 
        "Verify UTF8 will signal error on invalid flags", 
        CP_UTF8, MB_PRECOMPOSED | MB_ERR_INVALID_CHARS, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_INVALID_FLAGS);

    // Test MB_ERR_INVALID_CHARS flag for UTF7.
    // Verify that UTF7 does not support this flag.
    NumErrors += DoTestMultiByteToWideChar( 
        "Verify UTF7 does not support MB_ERR_INVALID_CHARS", 
        CP_UTF7, MB_ERR_INVALID_CHARS, "\x80", 0, 1, TRUE, wcMBDest, BUFSIZE, 0, NULL, ERROR_INVALID_FLAGS);

    return (NumErrors);
} 


//
//385490    Client RC1  1   Active  Fix Ready   
//*NLS: broken decoding of correct sequences in UTF-8
//
BOOL Regress385490() {
    BOOL bPassed = TRUE;
    int NumErrors = 0;

    printf("\n    ---- Regress 385490 ----\n");

    NumErrors += DoTestMultiByteToWideChar( 
        "Bug 385490 - 1", 
        CP_UTF8, 0, "\x1f\x10\x00\x09", 0, 4, FALSE, wcMBDest, BUFSIZE, 4, L"\x001f\x0010\x0000\x0009", 0);
    
    NumErrors += DoTestMultiByteToWideChar( 
        "Bug 385490 - 2 Normal surrogate pair (lowset)", 
        CP_UTF8, 0, "\xf0\x90\x80\x80", 0, 4, TRUE, wcMBDest, BUFSIZE, 2, L"\xd800\xdc00", 0);

    NumErrors += DoTestMultiByteToWideChar( 
        "Bug 385490 - 3 Normal surrogate pair", 
        CP_UTF8, 0, "\xf3\xb0\x80\x80", 0, 4, TRUE, wcMBDest, BUFSIZE, 2, L"\xdb80\xdc00", 0);
        
    NumErrors += DoTestMultiByteToWideChar( 
        "Bug 385490 - 2 Normal surrogate pair (highest)", 
        CP_UTF8, 0, "\xf4\x8f\xbf\xbf", 0, 4, TRUE, wcMBDest, BUFSIZE, 2, L"\xdbff\xdfff", 0);

    return (NumErrors);
}

//
//389547    Client RC1  3   Active  
//NLS, UTF-8 , WideCharToMultiBytes()  returns wrong value for not finished code sequence
//
BOOL Regress389547() {
    int NumErrors = 0;

    printf("\n    ---- Regress 389547 ----\n");

    // 3-byte sequence
    NumErrors += DoTestMultiByteToWideChar( 
        "Bug 389547 - Three byte UTF8", 
        CP_UTF8, 0, "\xef\xbf\xae", 0, 3, FALSE, wcMBDest, BUFSIZE, 1, L"\xffee", 0);    

    // Just a trailing byte.
    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Trailing byte only",
        CP_UTF8, 0, "\xaa", 0, 1, FALSE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    // Unfinished 2 byte sequence
    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 2 byte sequence 1",
        CP_UTF8, 0, "\xc2", 0, 1, FALSE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 2 byte sequence 2",
        CP_UTF8, 0, "\xc2\x41\xc2\x41", 0, 4, FALSE, wcMBDest, BUFSIZE, 2, L"AA", 0);
    
    // Unfinished 3 byte sequence
    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 3 byte sequence 1",
        CP_UTF8, 0, "\xef\xbf", 0, 2, FALSE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 3 byte sequence 2",
        CP_UTF8, 0, "A\xef\xbf", 0, 2, FALSE, wcMBDest, BUFSIZE, 1, L"A", 0);
    
    // Unfinished 4 byte sequence
    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 4 byte sequence 1",
        CP_UTF8, 0, "\xf0\x90\x80", 0, 3, FALSE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 4 byte sequence 2",
        CP_UTF8, 0, "\xf4\x8f\xbf", 0, 3, FALSE, wcMBDest, BUFSIZE, 0, L"", ERROR_NO_UNICODE_TRANSLATION);

    NumErrors += DoTestMultiByteToWideChar(
        "Bug 389547 - Unfinished 4 byte sequence 3",
        CP_UTF8, 0, "\xf4\x8f\xbf\x41", 0, 4, FALSE, wcMBDest, BUFSIZE, 1, L"A", 0);
    
    return (NumErrors);
}

////////////////////////////////////////////////////////////////////////////
//
//  TestMBToWC
//
//  Test routine for MultiByteToWideChar API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestMBToWC()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING MultiByteToWideChar...\n\n");

    //
    //  Test bad parameters.
    //
    ErrCount += MB_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += MB_NormalCase();

    //
    //  Test flags.
    //
    ErrCount += MB_TestFlags();

    //
    //  Test DBCS.
    //
    ErrCount += MB_TestDBCS();
    ErrCount += DoUTF7FunctionTests();

    ErrCount += Regress376403();    
    ErrCount += Regress381323();
    ErrCount += Regress381433();
    ErrCount += Regress371215();
    ErrCount += Regress385490();
    ErrCount += Regress389547();

    //
    //  Print out result.
    //
    printf("\nMultiByteToWideChar:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  MB_BadParamCheck
//
//  This routine passes in bad parameters to the API routine and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MB_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Null Pointers and Equal Pointers.
    //

    //  Variation 1  -  lpMultiByteStr = NULL
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              NULL,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpMultiByteStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpWideCharStr = NULL
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpWideCharStr NULL",
                         &NumErrors );

    //  Variation 3  -  equal pointers
    rc = MultiByteToWideChar( 1252,
                              0,
                              mbMBStr2,
                              -1,
                              (LPWSTR)mbMBStr2,
                              sizeof(mbMBStr2) / sizeof(WCHAR) );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "equal pointers",
                         &NumErrors );


    //
    //  Negative or Zero Lengths.
    //

    //  Variation 1  -  cchMultiByte = 0
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              0,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchMultiByte zero",
                         &NumErrors );

    //  Variation 2  -  cchWideChar = negative
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchWideChar zero",
                         &NumErrors );


    //
    //  Invalid Code Page.
    //

    //  Variation 1  -  CodePage = invalid
    rc = MultiByteToWideChar( 8,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "CodePage invalid",
                         &NumErrors );


    //  Variation 2  -  CodePage = invalid
    rc = MultiByteToWideChar( 65002,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "CodePage invalid 2",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  wFlags = 0
    rc = MultiByteToWideChar( 1252,
                              0,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "wFlags zero",
                       &NumErrors );

    //  Variation 2  -  wFlags = invalid
    rc = MultiByteToWideChar( 1252,
                              MB_INVALID_FLAGS,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "wFlags invalid",
                         &NumErrors );

    //  Variation 3  -  precomp | comp
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED | MB_COMPOSITE,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "precomp | comp",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchWideChar = too small
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchWideChar too small",
                         &NumErrors );



    //
    //  No Unicode Translation - using MB_ERR_INVALID_CHARS flag.
    //

#if 0
    //  Variation 1  -  cp 875
    rc = MultiByteToWideChar( 875,
                              MB_ERR_INVALID_CHARS,
                              "fa\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (875)",
                         &NumErrors );

    //  Variation 2  -  cp 875
    rc = MultiByteToWideChar( 875,
                              MB_ERR_INVALID_CHARS,
                              "\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (875) 2",
                         &NumErrors );
#endif

    //  Variation 3  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS,
                              "fa\xd5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (857)",
                         &NumErrors );

    //  Variation 4  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS,
                              "\xd5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (857) 2",
                         &NumErrors );

    //  Variation 5  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS,
                              "fa\xd5t",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (857) 3",
                         &NumErrors );


    //  Variation 6  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE,
                              "\xd5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite flag (857)",
                         &NumErrors );


    //  Variation 7  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE,
                              "fa\xd5t",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite flag (857) 2",
                         &NumErrors );


    //  Variation 8  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE | MB_USEGLYPHCHARS,
                              "\xd5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite/glyph flag (857)",
                         &NumErrors );


    //  Variation 9  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE | MB_USEGLYPHCHARS,
                              "fa\xd5t",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite/glyph flag (857) 2",
                         &NumErrors );


    //  Variation 10  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_USEGLYPHCHARS,
                              "\xd5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/glyph flag (857)",
                         &NumErrors );


    //  Variation 10  -  cp 857
    rc = MultiByteToWideChar( 857,
                              MB_ERR_INVALID_CHARS | MB_USEGLYPHCHARS,
                              "fa\xd5t",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/glyph flag (857) 2",
                         &NumErrors );


    //
    //  DBCS - No Unicode Translation - using MB_ERR_INVALID_CHARS flag.
    //

    //  Variation 1  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS,
                              "\x81\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (932)",
                         &NumErrors );

    //  Variation 2  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS,
                              "\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (932) 2",
                         &NumErrors );

    //  Variation 3  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE,
                              "\x81\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char flag (932) 3",
                         &NumErrors );

    //  Variation 4  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE,
                              "\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite flag (932)",
                         &NumErrors );

    //  Variation 5  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE | MB_USEGLYPHCHARS,
                              "\x81\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite/glyph flag (932)",
                         &NumErrors );

    //  Variation 6  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_COMPOSITE | MB_USEGLYPHCHARS,
                              "\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/composite/glyph flag (932) 2",
                         &NumErrors );

    //  Variation 7  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_USEGLYPHCHARS,
                              "\x81\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/glyph flag (932)",
                         &NumErrors );

    //  Variation 8  -  cp 932
    rc = MultiByteToWideChar( 932,
                              MB_ERR_INVALID_CHARS | MB_USEGLYPHCHARS,
                              "\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_NO_UNICODE_TRANSLATION,
                         "invalid char/glyph flag (932) 2",
                         &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  MB_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MB_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE Ch;                      // buffer for one character
    WCHAR CheckBuf;               // return buffer for one character
    LPWSTR pBogus = NULL;         // bogus, uninitialized pointer
    LCID Locale;                  // save the old locale


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  cchWideChar.
    //

    //  Variation 1  -  cchWideChar = length of wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "cchWideChar (length)",
                       &NumErrors );

    //  Variation 2  -  cchWideChar = 0
    wcMBDest[0] = 0x0005;
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "cchWideChar zero",
                       &NumErrors );

    //  Variation 3  -  cchWideChar = 0, wcMBDest = NULL
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "cchWideChar (NULL ptr)",
                       &NumErrors );

    //  Variation 4  -  cchWideChar = 0, wcMBDest = uninitialized ptr
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              pBogus,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "cchWideChar (bogus ptr)",
                       &NumErrors );


    //
    //  cchMultiByte.
    //

    //  Variation 1  -  cchMultiByte = length of mbMBStr
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              MB_STRING_LEN(mbMBStr),
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(wcMBStr),
                       wcMBDest,
                       wcMBStr,
                       "cchMultiByte (length)",
                       &NumErrors );

    //  Variation 2  -  cchMultiByte = -1
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "cchMultiByte (-1)",
                       &NumErrors );

    //  Variation 3  -  cchMultiByte = length of mbMBStr, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              MB_STRING_LEN(mbMBStr),
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(wcMBStr),
                       NULL,
                       wcMBStr,
                       "cchMultiByte (length), no wcMBDest",
                       &NumErrors );

    //  Variation 4  -  cchMultiByte = -1, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "cchMultiByte (-1), no wcMBDest",
                       &NumErrors );


    //
    //  CodePage.
    //

    //  Variation 1  -  CodePage = CP_ACP
    rc = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage CP_ACP",
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_ACP, no wcMBDest
    rc = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage CP_ACP, no wcMBDest",
                       &NumErrors );

    //  Variation 3  -  CodePage = CP_OEMCP
    rc = MultiByteToWideChar( CP_OEMCP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage CP_OEMCP",
                       &NumErrors );

    //  Variation 4  -  CodePage = CP_OEMCP, no wcMBDest
    rc = MultiByteToWideChar( CP_OEMCP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage CP_OEMCP, no wcMBDest",
                       &NumErrors );

    //  Variation 5  -  CodePage = CP_MACCP
    rc = MultiByteToWideChar( CP_MACCP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage CP_MACCP",
                       &NumErrors );

    //  Variation 6  -  CodePage = CP_MACCP, no wcMBDest
    rc = MultiByteToWideChar( CP_MACCP,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage CP_MACCP, no wcMBDest",
                       &NumErrors );


    //  Variation 7  -  CodePage = 437
    rc = MultiByteToWideChar( 437,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage 437",
                       &NumErrors );

    //  Variation 8  -  CodePage = 437, no wcMBDest
    rc = MultiByteToWideChar( 437,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage 437, no wcMBDest",
                       &NumErrors );

    //  Variation 9  -  CodePage = 850
    rc = MultiByteToWideChar( 850,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage 850",
                       &NumErrors );

    //  Variation 10  -  CodePage = 850, no wcMBDest
    rc = MultiByteToWideChar( 850,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage 850, no wcMBDest",
                       &NumErrors );

    //  Variation 11  -  CodePage = 10000
    rc = MultiByteToWideChar( 10000,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage 10000",
                       &NumErrors );

    //  Variation 12  -  CodePage = 10000, no wcMBDest
    rc = MultiByteToWideChar( 10000,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage 10000, no wcMBDest",
                       &NumErrors );

    //  Variation 13  -  CodePage = CP_THREAD_ACP
    rc = MultiByteToWideChar( CP_THREAD_ACP,
                              0,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "CodePage CP_THREAD_ACP",
                       &NumErrors );

    //  Variation 14  -  CodePage = CP_THREAD_ACP, no wcMBDest
    rc = MultiByteToWideChar( CP_THREAD_ACP,
                              0,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "CodePage CP_THREAD_ACP, no wcMBDest",
                       &NumErrors );

    //  Variation 15  -  CodePage = CP_THREAD_ACP
    Locale = GetThreadLocale();
    SetThreadLocale(0x00000405);                 // Czech - cp 1250
    rc = MultiByteToWideChar( CP_THREAD_ACP,
                              0,
                              "\x9d\x9f",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0165\x017a",
                       "CodePage CP_THREAD_ACP - Czech cp 1250",
                       &NumErrors );
    SetThreadLocale(Locale);                     // US - cp 1252
    rc = MultiByteToWideChar( CP_THREAD_ACP,
                              0,
                              "\x9d\x9f",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x009d\x0178",
                       "CodePage CP_THREAD_ACP - US cp 1252",
                       &NumErrors );

    //  Variation 16  -  CodePage = CP_SYMBOL
    rc = MultiByteToWideChar( CP_SYMBOL,
                              0,
                              "\x20\x33\xca\x00",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\xf020\xf033\xf0ca\x0000",
                       "CodePage CP_SYMBOL",
                       &NumErrors );

    //  Variation 17  -  CodePage = CP_SYMBOL, no wcMBDest
    rc = MultiByteToWideChar( CP_SYMBOL,
                              0,
                              "\x20\x33\xca\x00",
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\xf020\xf033\xf0ca\x0000",
                       "CodePage CP_SYMBOL, no wcMBDest",
                       &NumErrors );

    //  Variation 18  -  CodePage = CP_SYMBOL
    rc = MultiByteToWideChar( CP_SYMBOL,
                              0,
                              "\x20\x33\xca\x00",
                              5,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       5,
                       wcMBDest,
                       L"\xf020\xf033\xf0ca\x0000",
                       "CodePage CP_SYMBOL, size",
                       &NumErrors );





    //
    //  UTF 7.
    //

    //  Variation 1  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x55\x78\x64\x4f\x72\x41\x2d",  // +UxdOrA-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x5317\x4eac",
                       "CodePage CP_UTF7 - 1",
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,                // +Ti1XC2b4Xpc-
                              0,
                              "\x2b\x54\x69\x31\x58\x43\x32\x62\x34\x58\x70\x63\x2d",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x4e2d\x570b\x66f8\x5e97",
                       "CodePage CP_UTF7 - 2",
                       &NumErrors );

    //  Variation 3  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x41\x44\x73\x2d",   // +ADs-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x003b",
                       "CodePage CP_UTF7 - 3",
                       &NumErrors );

    //  Variation 4  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,                // +XrdxmVtXUXg-
                              0,
                              "\x2b\x58\x72\x64\x78\x6d\x56\x74\x58\x55\x58\x67\x2d",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x5eb7\x7199\x5b57\x5178",
                       "CodePage CP_UTF7 - 4",
                       &NumErrors );

    //  Variation 5  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,                // +TpVPXGBG-
                              0,
                              "\x2b\x54\x70\x56\x50\x58\x47\x42\x47\x2d",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x4e95\x4f5c\x6046",
                       "CodePage CP_UTF7 - 5",
                       &NumErrors );

    //  Variation 6  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x41\x46\x38\x2d",   // +AF8-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x005f",
                       "CodePage CP_UTF7 - 6",
                       &NumErrors );

    //  Variation 7  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x41\x45\x41\x2d",   // +AEA-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0040",
                       "CodePage CP_UTF7 - 7",
                       &NumErrors );

    //  Variation 8  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x2d",        // +-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x002b",
                       "CodePage CP_UTF7 - 8",
                       &NumErrors );

    //  Variation 9  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x41\x2b\x2d",    // A+-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0041\x002b",
                       "CodePage CP_UTF7 - 9",
                       &NumErrors );

    //  Variation 10  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x2b\x41\x45\x41\x2d\x2b\x2d",  // +AEA-+-
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0040\x002b",
                       "CodePage CP_UTF7 - 10",
                       &NumErrors );

    //  Variation 11  -  CodePage = CP_UTF7
    rc = MultiByteToWideChar( CP_UTF7,
                              0,
                              "\x61\x62\x2b",
                              3,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       wcMBDest,
                       L"\x0061\x0062",
                       "CodePage CP_UTF7 - 11",
                       &NumErrors );


    //
    //  UTF 8.
    //

    //  Variation 1  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\xe5\x8c\x97\xe4\xba\xac",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x5317\x4eac",
                       "CodePage CP_UTF8 - 1",
                       &NumErrors );

    //  Variation 2  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\xe4\xb8\xad\xe5\x9c\x8b\xe6\x9b\xb8\xe5\xba\x97",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x4e2d\x570b\x66f8\x5e97",
                       "CodePage CP_UTF8 - 2",
                       &NumErrors );

    //  Variation 3  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\x3b",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x003b",
                       "CodePage CP_UTF8 - 3",
                       &NumErrors );

    //  Variation 4  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\xe5\xba\xb7\xe7\x86\x99\xe5\xad\x97\xe5\x85\xb8",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x5eb7\x7199\x5b57\x5178",
                       "CodePage CP_UTF8 - 4",
                       &NumErrors );

    //  Variation 5  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\xe4\xba\x95\xe4\xbd\x9c\xe6\x81\x86",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x4e95\x4f5c\x6046",
                       "CodePage CP_UTF8 - 5",
                       &NumErrors );

    //  Variation 6  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\x5f",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x005f",
                       "CodePage CP_UTF8 - 6",
                       &NumErrors );

    //  Variation 7  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\x40",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0040",
                       "CodePage CP_UTF8 - 7",
                       &NumErrors );

    //  Variation 8  -  CodePage = CP_UTF8
    rc = MultiByteToWideChar( CP_UTF8,
                              0,
                              "\x2b",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x002b",
                       "CodePage CP_UTF8 - 8",
                       &NumErrors );



    //
    //  Check 0xb3 by itself (to make sure not sign extended).
    //
    Ch = (BYTE)0xb3;
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              &Ch,
                              1,
                              &CheckBuf,
                              1 );
    CheckReturnValidW( rc,
                       1,
                       &CheckBuf,
                       L"\x00b3",
                       "Check Buffer",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}

////////////////////////////////////////////////////////////////////////////
//
//  MB_TestFlags
//
//  This routine tests the different flags of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MB_TestFlags()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE Ch;                      // buffer for one character
    WCHAR CheckBuf;               // return buffer for one character


    //
    //  MB_PRECOMPOSED flag.
    //

    //  Variation 1  -  normal
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "MB_PRECOMPOSED",
                       &NumErrors );

    //  Variation 2  -  normal, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "MB_PRECOMPOSED, no wcMBDest",
                       &NumErrors );

    //  Variation 3  -  normal
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              "\x6e\x7e",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x006e\x007e",
                       "MB_PRECOMPOSED (n tilde)",
                       &NumErrors );

    //  Variation 4  -  normal, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_PRECOMPOSED,
                              "\x6e\x7e",
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x006e\x007e",
                       "MB_PRECOMPOSED (n tilde), no wcMBDest",
                       &NumErrors );



    //
    //  MB_COMPOSITE flag.
    //

    //  Variation 1  -  normal
    rc = MultiByteToWideChar( 1252,
                              MB_COMPOSITE,
                              mbMBStr,
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       wcMBStr,
                       "MB_COMPOSITE",
                       &NumErrors );

    //  Variation 2  -  normal, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_COMPOSITE,
                              mbMBStr,
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       wcMBStr,
                       "MB_COMPOSITE, no wcMBDest",
                       &NumErrors );

    //  Variation 3  -  normal
    rc = MultiByteToWideChar( 1252,
                              MB_COMPOSITE,
                              "\xfc\xf5",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x0075\x0308\x006f\x0303",
                       "MB_COMPOSITE (u diaeresis, o tilde)",
                       &NumErrors );

    //  Variation 4  -  normal, no wcMBDest
    rc = MultiByteToWideChar( 1252,
                              MB_COMPOSITE,
                              "\xfc\xf5",
                              -1,
                              NULL,
                              0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       L"\x0075\x0308\x006f\x0303",
                       "MB_COMPOSITE (u diaeresis, o tilde), no wcMBDest",
                       &NumErrors );



    //
    //  MB_USEGLYPHCHARS flag.
    //

    //  Variation 1  -  Use Glyph
    Ch = (BYTE)0x0D;
    CheckBuf = (WCHAR)0;
    rc = MultiByteToWideChar( 437,
                              MB_USEGLYPHCHARS,
                              &Ch,
                              1,
                              &CheckBuf,
                              1 );
    CheckReturnValidW( rc,
                       1,
                       &CheckBuf,
                       L"\x266a",
                       "Use Glyph",
                       &NumErrors );

    //  Variation 2  -  Do NOT Use Glyph
    Ch = (BYTE)0x0D;
    CheckBuf = (WCHAR)0;
    rc = MultiByteToWideChar( 437,
                              0,
                              &Ch,
                              1,
                              &CheckBuf,
                              1 );
    CheckReturnValidW( rc,
                       1,
                       &CheckBuf,
                       L"\x000d",
                       "Do NOT Use Glyph",
                       &NumErrors );

    //  Variation 3  -  Use Glyph, Composite
    Ch = (BYTE)0x0D;
    CheckBuf = (WCHAR)0;
    rc = MultiByteToWideChar( 437,
                              MB_USEGLYPHCHARS | MB_COMPOSITE,
                              &Ch,
                              1,
                              &CheckBuf,
                              1 );
    CheckReturnValidW( rc,
                       1,
                       &CheckBuf,
                       L"\x266a",
                       "Use Glyph, Composite",
                       &NumErrors );

    //  Variation 4  -  Do NOT Use Glyph, Composite
    Ch = (BYTE)0x0D;
    CheckBuf = (WCHAR)0;
    rc = MultiByteToWideChar( 437,
                              MB_COMPOSITE,
                              &Ch,
                              1,
                              &CheckBuf,
                              1 );
    CheckReturnValidW( rc,
                       1,
                       &CheckBuf,
                       L"\x000d",
                       "Do NOT Use Glyph, Composite",
                       &NumErrors );

    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  MB_TestDBCS
//
//  This routine tests the DBCS code of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int MB_TestDBCS()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  No trail byte with lead byte.
    //

    //  Variation 1  -  1 char
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       1,
                       wcMBDest,
                       L"\x0000",
                       "no trail byte 1 char",
                       &NumErrors );

    //  Variation 2  -  1 char
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81",
                              1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       1,
                       wcMBDest,
                       L"\x0000",
                       "no trail byte 1 char 2",
                       &NumErrors );

    //  Variation 3  -  2 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\xdf\x81",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\xff9f",
                       "no trail byte 2 chars",
                       &NumErrors );

    //  Variation 4  -  2 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\xdf\x81",
                              2,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\xff9f",
                       "no trail byte 2 chars 2",
                       &NumErrors );


    //
    //  Invalid trail byte with lead byte.
    //

    //  Variation 1  -  2 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81\x30",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x30fb",
                       "invalid trail byte 2 chars",
                       &NumErrors );

    //  Variation 2  -  3 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81\x30\xdf",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x30fb\xff9f",
                       "invalid trail byte 3 chars",
                       &NumErrors );


    //
    //  Valid Double byte string.
    //

    //  Variation 1  -  2 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81\x40",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x3000",
                       "valid trail byte 2 chars",
                       &NumErrors );

    //  Variation 2  -  3 chars
    wcMBDest[0] = 0;
    rc = MultiByteToWideChar( 932,
                              0,
                              "\x81\x40\xdf",
                              -1,
                              wcMBDest,
                              BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       wcMBDest,
                       L"\x3000\xff9f",
                       "valid trail byte 3 chars",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}

int DoUTF7FunctionTests()
{
    int NumErrors = 0;            // error count - to be returned

    printf("\n    ---- DoUTF7FunctionTests ----\n");

    NumErrors += DoTestMultiByteToWideChar( 
        "DoUTF7FunctionTests - 1", 
        CP_UTF7, 0, "\x2B\x41\x43\x45\x41\x66\x51\x2D", 0, 8, TRUE, wcMBDest, BUFSIZE, 2, L"\x0021\x007D", 0);    

    NumErrors += DoTestMultiByteToWideChar( 
        "DoUTF7FunctionTests - 2", 
        CP_UTF7, 0, "\x2B\x44\x6C\x6B\x46\x30\x51\x2D", 0, 8, TRUE, wcMBDest, BUFSIZE, 2, L"\x0E59\x05D1", 0);    
    //
    //  Return total number of errors found.
    //
    return (NumErrors);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\mstest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    mstest.c

Abstract:

    Test module for NLS API LCMapString.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE  50
#define  LCMS_INVALID_FLAGS                                               \
               ((DWORD)(~( LCMAP_LOWERCASE    | LCMAP_UPPERCASE     |     \
                           LCMAP_SORTKEY      | LCMAP_BYTEREV       |     \
                           LCMAP_HIRAGANA     | LCMAP_KATAKANA      |     \
                           LCMAP_HALFWIDTH    | LCMAP_FULLWIDTH     |     \
                           LCMAP_TRADITIONAL_CHINESE                |     \
                           LCMAP_SIMPLIFIED_CHINESE                 |     \
                           NORM_IGNORECASE    | NORM_IGNORENONSPACE |     \
                           NORM_IGNORESYMBOLS | NORM_IGNOREKANATYPE |     \
                           NORM_IGNOREWIDTH )))




//
//  Global Variables.
//

LCID Locale;

#define MapSrc1              L"This Is A String"

#define MapSrc2              L"This Is$ A S-tr,in'g"

#define MapNoSymbols         L"ThisIsAString"


WCHAR MapDest[BUFSIZE];
BYTE  SortDest[BUFSIZE];
BYTE  MapDestA[BUFSIZE];


#define MapUpper             L"THIS IS A STRING"
#define MapLower             L"this is a string"
#define MapLower2            L"this is$ a str,ing"

//  Sharp S
#define wcSharpS             L"\x0074\x00df\x0074"

//  Nonspace
#define MapNS1               L"\x0074\x00e1\x0061\x0301"
#define MapNS2               L"\x0074\x0301\x00e1\x0061\x0301"
#define MapNoNS1             L"\x0074\x0061\x0061"
#define MapUpperNS           L"\x0054\x00c1\x0041\x0301"

//  Sortkey
#define SortPunctPre         L"\x00e1\x002d"          // a-acute, -
#define SortPunctComp        L"\x0061\x0301\x002d"    // a, acute, -

#define SortPunctExp1        L"\x00e6\x002d"          // ae, -
#define SortPunctExp2        L"\x0061\x0065\x002d"    // a, e, -

#define SortPunctUnsort      L"\x00e6\xffff\x002d"    // ae, unsort, -

#define SortSymbolPre        L"\x00e1\x002a"          // a-acute, *
#define SortSymbolComp       L"\x0061\x0301\x002a"    // a, acute, *

#define SortSymbolExp1       L"\x00e6\x002a"          // ae, *
#define SortSymbolExp2       L"\x0061\x0065\x002a"    // a, e, *

#define SortSymbolUnsort     L"\x00e6\xffff\x002a"    // ae, unsort, *




//
//  Forward Declarations.
//

BOOL
InitLCMapStr();

int
LCMS_BadParamCheck();

int
LCMS_NormalCase();

int
LCMS_Ansi();

void
CheckReturnValidSortKey(
    int CurrentReturn,
    int ExpectedReturn,
    LPBYTE pCurrentString,
    LPBYTE pExpectedString,
    LPBYTE pErrString,
    int *pNumErrors);





////////////////////////////////////////////////////////////////////////////
//
//  TestLCMapString
//
//  Test routine for LCMapStringW API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestLCMapString()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING LCMapStringW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitLCMapStr())
    {
        printf("\nABORTED TestLCMapString: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += LCMS_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += LCMS_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += LCMS_Ansi();

    //
    //  Print out result.
    //
    printf("\nLCMapStringW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitLCMapStr
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitLCMapStr()
{
    int size = BUFSIZE;           // size of string


    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);


    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMS_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int LCMS_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = LCMapStringW( (LCID)333,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpSrcStr = NULL
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       NULL,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpSrcStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpDestStr = NULL
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       NULL,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpDestStr NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cbSrc = 0
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       0,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbSrc = 0",
                         &NumErrors );

    //  Variation 2  -  cbDest < 0
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbDest < 0",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 0  -  Use CP ACP
    rc = LCMapStringW( Locale,
                       LOCALE_USE_CP_ACP,
                       L"Th",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP",
                         &NumErrors );

    //  Variation 0.1  -  byterev, ignore case
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | NORM_IGNORECASE,
                       L"Th",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "byterev, ignore case",
                         &NumErrors );

    //  Variation 1  -  dwMapFlags = invalid
    rc = LCMapStringW( Locale,
                       LCMS_INVALID_FLAGS,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwMapFlags invalid",
                         &NumErrors );

    //  Variation 2  -  dwMapFlags = 0
    rc = LCMapStringW( Locale,
                       0,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "dwMapFlags zero",
                         &NumErrors );

    //  Variation 3  -  illegal combo case
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE | LCMAP_UPPERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo case",
                         &NumErrors );

    //  Variation 4  -  illegal combo sortkey
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE | LCMAP_SORTKEY,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo sortkey",
                         &NumErrors );

    //  Variation 5  -  legal combo byterev
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE | LCMAP_BYTEREV,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapSrc1,
                       "legal combo byterev",
                       &NumErrors );

    //  Variation 6  -  illegal flag ignorecase
    rc = LCMapStringW( Locale,
                       NORM_IGNORECASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal flag ignorecase",
                         &NumErrors );

    //  Variation 7  -  illegal combo kana
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | LCMAP_KATAKANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo kana",
                         &NumErrors );

    //  Variation 8  -  illegal combo width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_FULLWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo width",
                         &NumErrors );

    //  Variation 9  -  illegal combo sortkey, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | LCMAP_HIRAGANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo sortkey, hiragana",
                         &NumErrors );

    //  Variation 10  -  illegal combo sortkey, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | LCMAP_KATAKANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo sortkey, katakana",
                         &NumErrors );

    //  Variation 11  -  illegal combo sortkey, half width
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | LCMAP_HALFWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo sortkey, half width",
                         &NumErrors );

    //  Variation 12  -  illegal combo sortkey, full width
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | LCMAP_FULLWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo sortkey, full width",
                         &NumErrors );

    //  Variation 13  -  illegal combo kana, ignore symbols
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | NORM_IGNORESYMBOLS,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo kana, symbols",
                         &NumErrors );

    //  Variation 14  -  illegal combo width, ignore symbols
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | NORM_IGNORESYMBOLS,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo width, symbols",
                         &NumErrors );

    //  Variation 15  -  illegal combo kana, ignore nonspace
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | NORM_IGNORENONSPACE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo kana, nonspace",
                         &NumErrors );

    //  Variation 16  -  illegal combo width, ignore nonspace
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | NORM_IGNORENONSPACE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo width, nonspace",
                         &NumErrors );

    //  Variation 17  -  illegal combo kana, ignore kana
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | NORM_IGNOREKANATYPE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo kana, ignore kana",
                         &NumErrors );

    //  Variation 18  -  illegal combo width, ignore kana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | NORM_IGNOREKANATYPE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo width, ignore kana",
                         &NumErrors );

    //  Variation 19  -  illegal combo kana, ignore width
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | NORM_IGNOREWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo kana, ignore width",
                         &NumErrors );

    //  Variation 20  -  illegal combo width, ignore width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | NORM_IGNOREWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo width, ignore width",
                         &NumErrors );

    //  Variation 21  -  illegal combo linguistic
    rc = LCMapStringW( Locale,
                       LCMAP_LINGUISTIC_CASING,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo linguistic",
                         &NumErrors );

    //  Variation 22  -  illegal combo linguistic, kana
    rc = LCMapStringW( Locale,
                       LCMAP_LINGUISTIC_CASING | LCMAP_HIRAGANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo linguistic, kana",
                         &NumErrors );

    //  Variation 23  -  illegal combo linguistic, sortkey
    rc = LCMapStringW( Locale,
                       LCMAP_LINGUISTIC_CASING | LCMAP_SORTKEY,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo linguistic, sortkey",
                         &NumErrors );

    //  Variation 24  -  illegal combo linguistic, norm
    rc = LCMapStringW( Locale,
                       LCMAP_LINGUISTIC_CASING | NORM_IGNORENONSPACE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo linguistic, norm",
                         &NumErrors );

    //  Variation 25  -  illegal combo traditional, kana
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_HIRAGANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo traditional, kana",
                         &NumErrors );

    //  Variation 26  -  illegal combo traditional, width
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_HALFWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo traditional, width",
                         &NumErrors );

    //  Variation 27  -  illegal combo traditional, sortkey
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_SORTKEY,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo traditional, sortkey",
                         &NumErrors );

    //  Variation 28  -  illegal combo simplified, kana
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_HIRAGANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo simplified, kana",
                         &NumErrors );

    //  Variation 29  -  illegal combo simplified, width
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_HALFWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo simplified, width",
                         &NumErrors );

    //  Variation 30  -  illegal combo simplified, sortkey
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_SORTKEY,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "illegal combo simplified, sortkey",
                         &NumErrors );





    //
    //  Check the error returns for A and W version.
    //

    //  Variation 1  -  NULL destination
    SetLastError(0);
    rc = LCMapStringW( 0x0409,
                       0,
                       L"xxx",
                       -1,
                       NULL,
                       100 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W errors same - NULL Dest - W version",
                         &NumErrors );

    SetLastError(0);
    rc = LCMapStringA( 0x0409,
                       0,
                       "xxx",
                       -1,
                       NULL,
                       100 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W errors same - NULL Dest - A version",
                         &NumErrors );


    //  Variation 2  -  Pointers equal
    SetLastError(0);
    rc = LCMapStringW( 0x0409,
                       0,
                       MapDest,
                       -1,
                       MapDest,
                       100 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W errors same - Pointers Equal - W version",
                         &NumErrors );

    SetLastError(0);
    rc = LCMapStringA( 0x0409,
                       0,
                       MapDestA,
                       -1,
                       MapDestA,
                       100 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W errors same - Pointers Equal - A version",
                         &NumErrors );


    //
    //  Check src = dest  -  W Version.
    //

    //  Variation 0
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_UPPERCASE | LCMAP_HIRAGANA,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - uppercase and hiragana",
                         &NumErrors );

    //  Variation 1
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_HIRAGANA,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and hiragana",
                         &NumErrors );

    //  Variation 2
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_KATAKANA,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and katakana",
                         &NumErrors );

    //  Variation 3
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_HALFWIDTH,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and halfwidth",
                         &NumErrors );

    //  Variation 4
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_FULLWIDTH,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and fullwidth",
                         &NumErrors );

    //  Variation 5
    SetLastError(0);
    MapDest[0] = L'x';
    MapDest[1] = 0;
    rc = LCMapStringW( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and fullwidth and hiragana",
                         &NumErrors );

    //  Variation 6
    MapDest[0] = L'x';
    MapDest[1] = L'y';
    MapDest[2] = 0;
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapDest,
                       -1,
                       MapDest,
                       2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "src = dest - uppercase, size - buffer too small",
                         &NumErrors );


    //
    //  Check src = dest  -  A Version.
    //

    //  Variation 0
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_UPPERCASE | LCMAP_HIRAGANA,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - uppercase and hiragana (A Version)",
                         &NumErrors );

    //  Variation 1
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_HIRAGANA,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and hiragana (A Version)",
                         &NumErrors );

    //  Variation 2
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_KATAKANA,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and katakana (A Version)",
                         &NumErrors );

    //  Variation 3
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_HALFWIDTH,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and halfwidth (A Version)",
                         &NumErrors );

    //  Variation 4
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_FULLWIDTH,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and fullwidth (A Version)",
                         &NumErrors );

    //  Variation 5
    SetLastError(0);
    MapDestA[0] = 'x';
    MapDestA[1] = 0;
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE | LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "src = dest - lowercase and fullwidth and hiragana (A Version)",
                         &NumErrors );

    //  Variation 6
    MapDestA[0] = 'x';
    MapDestA[1] = 'y';
    MapDestA[2] = 0;
    rc = LCMapStringA( Locale,
                       LCMAP_UPPERCASE,
                       MapDestA,
                       -1,
                       MapDestA,
                       2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "src = dest - uppercase, size - buffer too small (A Version)",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMS_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int LCMS_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = LCMapStringW( LOCALE_SYSTEM_DEFAULT,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "system default locale",
                       &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = LCMapStringW( LOCALE_USER_DEFAULT,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "current user locale",
                       &NumErrors );


    //
    //  cbDest = 0.
    //

    //  Variation 1  -  cbSrc = -1
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapLower,
                       "cbDest (0) cbSrc (-1)",
                       &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       WC_STRING_LEN_NULL(MapSrc1),
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapLower,
                       "cbDest (0) cbSrc (value)",
                       &NumErrors );

    //  Variation 3  -  lpDestStr = NULL
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapLower,
                       "cbDest (0) lpDestStr NULL",
                       &NumErrors );


    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "cbSrc (-1)",
                       &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       WC_STRING_LEN(MapSrc1),
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(MapSrc1),
                       MapDest,
                       MapLower,
                       "cbSrc (value)",
                       &NumErrors );

    //  Variation 3  -  cbSrc = -1, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapLower,
                       "cbSrc (-1), no DestStr",
                       &NumErrors );

    //  Variation 4  -  cbSrc = value, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       WC_STRING_LEN(MapSrc1),
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       WC_STRING_LEN(MapSrc1),
                       NULL,
                       MapLower,
                       "cbSrc (value), no DestStr",
                       &NumErrors );


    //
    //  LOCALE_USE_CP_ACP Flag.
    //

    //  Variation 1  -  Use CP ACP
    rc = LCMapStringW( Locale,
                       LOCALE_USE_CP_ACP | LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "Use CP ACP",
                       &NumErrors );


    //
    //  LCMAP_LOWERCASE Flag.
    //

    //  Variation 1  -  lowercase
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "lowercase",
                       &NumErrors );

    //  Variation 2  -  lowercase, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapSrc1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapLower,
                       "lowercase, no DestStr",
                       &NumErrors );


    //
    //  LCMAP_UPPERCASE Flag.
    //

    //  Variation 1  -  uppercase
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "uppercase",
                       &NumErrors );

    //  Variation 2  -  uppercase, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapSrc1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapUpper,
                       "uppercase, no DestStr",
                       &NumErrors );

    //  Variation 3  -  uppercase, sharp S
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       wcSharpS,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x0054\x00df\x0054",
                       "uppercase, sharp S",
                       &NumErrors );

    //  Variation 4  -  upper case nonspace
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapNS1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpperNS,
                       "uppercase, nonspace",
                       &NumErrors );

    //  Variation 5  -  upper case, no DestStr, nonspace
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapNS1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapUpperNS,
                       "uppercase, nonspace, no DestStr",
                       &NumErrors );

    //  Variation 6  -  uppercase Korean
    MapDest[0] = L'a';
    MapDest[1] = L'b';
    MapDest[2] = 0;
    rc = LCMapStringW( MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN), SORT_DEFAULT),
                       LCMAP_UPPERCASE,
                       MapDest,
                       3,
                       MapDest,
                       3 );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"AB",
                       "Korean uppercase",
                       &NumErrors );




    //
    //  LCMAP_LINGUISTIC_CASING Flag.
    //

    //  Variation 1  -  linguistic uppercase
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_LINGUISTIC_CASING,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "linguistic uppercase",
                       &NumErrors );

    //  Variation 2  -  linguistic uppercase
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_LINGUISTIC_CASING,
                       L"\xff41\xff5a\xff21",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff21\xff3a\xff21",
                       "linguistic uppercase (AZ)",
                       &NumErrors );

    //  Variation 3  -  linguistic uppercase
    rc = LCMapStringW( 0x041f,
                       LCMAP_UPPERCASE | LCMAP_LINGUISTIC_CASING,
                       L"\xff41\xff5a\x0069\x0131",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff21\xff3a\x0130\x0049",
                       "linguistic uppercase (Turkish)",
                       &NumErrors );

    //  Variation 4  -  linguistic lowercase
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE | LCMAP_LINGUISTIC_CASING,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapLower,
                       "linguistic lowercase",
                       &NumErrors );

    //  Variation 5  -  linguistic lowercase
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE | LCMAP_LINGUISTIC_CASING,
                       L"\xff21\xff3a\xff41",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff41\xff5a\xff41",
                       "linguistic lowercase (az)",
                       &NumErrors );

    //  Variation 6  -  linguistic lowercase
    rc = LCMapStringW( 0x041f,
                       LCMAP_LOWERCASE | LCMAP_LINGUISTIC_CASING,
                       L"\xff21\xff3a\x0049\x0130",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff41\xff5a\x0131\x0069",
                       "linguistic lowercase (Turkish)",
                       &NumErrors );


    //
    //  NORM_IGNORESYMBOLS Flag.
    //

    //  Variation 1  -  ignoresymbols
    rc = LCMapStringW( Locale,
                       NORM_IGNORESYMBOLS,
                       MapSrc2,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapNoSymbols,
                       "ignore symbols",
                       &NumErrors );

    //  Variation 2  -  ignoresymbols, no DestStr
    rc = LCMapStringW( Locale,
                       NORM_IGNORESYMBOLS,
                       MapSrc2,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapNoSymbols,
                       "ignore symbols, no DestStr",
                       &NumErrors );


    //
    //  NORM_IGNORENONSPACE Flag.
    //

    //  Variation 1  -  ignore nonspace
    rc = LCMapStringW( Locale,
                       NORM_IGNORENONSPACE,
                       MapNS1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapNoNS1,
                       "ignore nonspace",
                       &NumErrors );

    //  Variation 2  -  ignore nonspace, no translation
    rc = LCMapStringW( Locale,
                       NORM_IGNORENONSPACE,
                       MapNS2,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapNoNS1,
                       "ignore nonspace, no trans",
                       &NumErrors );

    //  Variation 3  -  ignore nonspace, no DestStr
    rc = LCMapStringW( Locale,
                       NORM_IGNORENONSPACE,
                       MapNS1,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapNoNS1,
                       "ignore nonspace, no DestStr",
                       &NumErrors );

    //  Variation 4  -  ignore nonspace, no translation, no DestStr
    rc = LCMapStringW( Locale,
                       NORM_IGNORENONSPACE,
                       MapNS2,
                       -1,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       MapNoNS1,
                       "ignore nonspace, no trans, no DestStr",
                       &NumErrors );


    //
    //  LCMAP_SORTKEY Flag.
    //

    //  Variation 1  -  sortkey
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       L"Th",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x99\x0e\x2c\x01\x01\x12\x01\x01",
                             "sortkey",
                             &NumErrors );

    //  Variation 2  -  sortkey, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       L"Th",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             -1,
                             NULL,
                             "\x0e\x99\x0e\x2c\x01\x01\x12\x01\x01",
                             "sortkey, no DestStr",
                             &NumErrors );

    //  Variation 3  -  sortkey (case)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | NORM_IGNORECASE,
                       L"Th",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x99\x0e\x2c\x01\x01\x01\x01",
                             "sortkey (case)",
                             &NumErrors );

    //  Variation 4  -  sortkey, no DestStr (case)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY | NORM_IGNORECASE,
                       L"Th",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             -1,
                             NULL,
                             "\x0e\x99\x0e\x2c\x01\x01\x01\x01",
                             "sortkey (case), no DestStr",
                             &NumErrors );

    //
    //  Check for punctuation position using nonspace chars.
    //  Make sure:
    //     a-acute, punct    is the same as
    //     a, acute, punct
    //

    //  Variation 5  -  sortkey (precomp punct position)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortPunctPre,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x01\x0e\x01\x01\x01\x80\x0b\x06\x82",
                             "sortkey (precomp punct position)",
                             &NumErrors );

    //  Variation 6  -  sortkey (comp punct position)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortPunctComp,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x01\x0e\x01\x01\x01\x80\x0b\x06\x82",
                             "sortkey (comp punct position)",
                             &NumErrors );

    //
    //  Check for punctuation position using expansion chars.
    //  Make sure:
    //     ae, punct    is the same as
    //     a, e, punct
    //
    //  Variation 7  -  sortkey (expansion 1 punct position)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortPunctExp1,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x01\x01\x01\x01\x80\x0f\x06\x82",
                             "sortkey (expansion 1 punct position)",
                             &NumErrors );

    //  Variation 8  -  sortkey (expansion 2 punct position)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortPunctExp2,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x01\x01\x01\x01\x80\x0f\x06\x82",
                             "sortkey (expansion 2 punct position)",
                             &NumErrors );

    //
    //  Check for punctuation position using unsortable chars.
    //  Make sure:
    //     ae, unsort, punct    is the same as
    //     a, e, punct
    //
    //  Variation 9  -  sortkey (unsortable punct position)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortPunctUnsort,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x01\x01\x01\x01\x80\x0f\x06\x82",
                             "sortkey (unsortable punct position)",
                             &NumErrors );

    //
    //  Check symbol and nonspace chars.
    //  Make sure:
    //     a-acute, symbol    is the same as
    //     a, acute, symbol
    //

    //  Variation 5  -  sortkey (precomp symbol)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortSymbolPre,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x07\x2d\x01\x0e\x01\x01\x01",
                             "sortkey (precomp symbol)",
                             &NumErrors );

    //  Variation 6  -  sortkey (comp symbol)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortSymbolComp,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x07\x2d\x01\x0e\x01\x01\x01",
                             "sortkey (comp symbol)",
                             &NumErrors );

    //
    //  Check symbol and expansion char.
    //  Make sure:
    //     ae, symbol    is the same as
    //     a, e, symbol
    //
    //  Variation 7  -  sortkey (expansion 1 symbol)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortSymbolExp1,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x07\x2d\x01\x01\x01\x01",
                             "sortkey (expansion 1 symbol)",
                             &NumErrors );

    //  Variation 8  -  sortkey (expansion 2 symbol)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortSymbolExp2,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x07\x2d\x01\x01\x01\x01",
                             "sortkey (expansion 2 symbol)",
                             &NumErrors );

    //
    //  Check symbol and unsortable char.
    //  Make sure:
    //     ae, unsort, symbol    is the same as
    //     a, e, symbol
    //
    //  Variation 9  -  sortkey (unsortable symbol)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       SortSymbolUnsort,
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x02\x0e\x21\x07\x2d\x01\x01\x01\x01",
                             "sortkey (unsortable symbol)",
                             &NumErrors );


    //
    //  Check Hungarian compression.
    //  Make sure:    ccs is the same as cs+cs
    //
    //  Variation 10  -  sortkey (Hungarian compression)
    rc = LCMapStringW( MAKELCID(0x040e, 0),
                       LCMAP_SORTKEY,
                       L"ccsddzs",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x0e\x0e\x0e\x0e\x1e\x0e\x1e\x01\x01\x01\x01",
                             "sortkey (hungarian compression)",
                             &NumErrors );


    //
    //  Check expansion (1 to 3).
    //
    //  Variation 11  -  sortkey (expansion 1 to 3)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       L"\xfb03",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x23\x0e\x23\x0e\x32\x01\x01\x01\x01",
                             "sortkey (expansion 1 to 3)",
                             &NumErrors );

    //  Variation 12  -  sortkey (expansion 1 to 3)
    rc = LCMapStringW( Locale,
                       LCMAP_SORTKEY,
                       L"ffi",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x23\x0e\x23\x0e\x32\x01\x01\x01\x01",
                             "sortkey (expansion 1 to 3) 2",
                             &NumErrors );


    //
    //  Check WORD sort versus STRING sort.
    //
    //  Variation 1  -  sortkey (WORD SORT)
    rc = LCMapStringW( MAKELCID(0x040e, 0),
                       LCMAP_SORTKEY,
                       L"co-op",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x0a\x0e\x7c\x0e\x7c\x0e\x7e\x01\x01\x01\x01\x80\x0f\x06\x82",
                             "sortkey (WORD SORT)",
                             &NumErrors );

    //  Variation 2  -  sortkey (STRING SORT)
    rc = LCMapStringW( MAKELCID(0x040e, 0),
                       LCMAP_SORTKEY | SORT_STRINGSORT,
                       L"co-op",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x0a\x0e\x7c\x06\x82\x0e\x7c\x0e\x7e\x01\x01\x01\x01",
                             "sortkey (STRING SORT)",
                             &NumErrors );




    //
    //  LCMAP_BYTEREV Flag.
    //

    //  Variation 1  -  byterev
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV,
                       L"Th",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x5400\x6800",
                       "byterev",
                       &NumErrors );

    //  Variation 2  -  byterev, no DestStr
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV,
                       L"Th",
                       2,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x5400\x6800",
                       "byterev, no DestStr",
                       &NumErrors );

    // Variation 3  -  sortkey, byterev
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_SORTKEY,
                       L"Th",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             10,
                             SortDest,
                             "\x99\x0e\x2c\x0e\x01\x01\x01\x12\x00\x01",
                             "sortkey, byterev",
                             &NumErrors );

    // Variation 4  -  sortkey, byterev (-1)
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_SORTKEY,
                       L"Th",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             10,
                             SortDest,
                             "\x99\x0e\x2c\x0e\x01\x01\x01\x12\x00\x01",
                             "sortkey, byterev (-1)",
                             &NumErrors );

    //  Variation 5  -  byterev, ignore nonspace
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | NORM_IGNORENONSPACE,
                       L"T\x0300h",
                       3,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x5400\x6800",
                       "byterev, ignore nonspace",
                       &NumErrors );

    //  Variation 6  -  byterev, ignore symbols
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | NORM_IGNORESYMBOLS,
                       L"T*h",
                       3,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x5400\x6800",
                       "byterev, ignore symbols",
                       &NumErrors );

    //  Variation 7  -  byterev, ignore nonspace and symbols
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | NORM_IGNORENONSPACE | NORM_IGNORESYMBOLS,
                       L"*T\x0300h@",
                       5,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x5400\x6800",
                       "byterev, ignore nonspace and symbols",
                       &NumErrors );

    //  Variation 8  -  byterev, no DestStr, cchDest 0
    rc = LCMapStringW( 0x0409,
                       LCMAP_BYTEREV,
                       L"Th",
                       2,
                       NULL,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x5400\x6800",
                       "byterev, no DestStr",
                       &NumErrors );

    //  Variation 9 -  sortkey | byterev, no DestStr, cchDest 0
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY | LCMAP_BYTEREV,
                       L"Th",
                       2,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             10,
                             NULL,
                             "\x99\x0e\x2c\x0e\x01\x01\x01\x12\x00\x01",
                             "sortkey, byterev (-1), no DestStr",
                             &NumErrors );



    //
    //  LCMAP_HIRAGANA, LCMAP_KATAKANA, LCMAP_HALFWIDTH, LCMAP_FULLWIDTH Flags.
    //

    //  Variation 1  -  hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x3041Th\x304a",
                       "hiragana",
                       &NumErrors );

    //  Variation 2  -  katakana
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x30a1Th\x30aa",
                       "katakana",
                       &NumErrors );

    //  Variation 3  -  halfwidth
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30a6Th\x3131",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff73Th\xffa1",
                       "half width",
                       &NumErrors );

    //  Variation 4  -  fullwidth
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\xff61Th\xffca",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x3002\xff34\xff48\x3155",
                       "full width",
                       &NumErrors );

    //  Variation 5  -  hiragana, half width
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | LCMAP_HALFWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x3041Th\x304a",
                       "hiragana, half width",
                       &NumErrors );

    //  Variation 6  -  hiragana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | LCMAP_FULLWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x3041\xff34\xff48\x304a",
                       "hiragana, full width",
                       &NumErrors );

    //  Variation 7  -  katakana, half width
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA | LCMAP_HALFWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff67Th\xff75",
                       "katakana, half width",
                       &NumErrors );

    //  Variation 8  -  katakana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA | LCMAP_FULLWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x30a1\xff34\xff48\x30aa",
                       "katakana, full width",
                       &NumErrors );

    //  Variation 9  -  byterev, hiragana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_HIRAGANA | LCMAP_FULLWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x4130\x34ff\x48ff\x4a30",
                       "byterev, hiragana, full width",
                       &NumErrors );

    //  Variation 10 -  byterev, katakana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_KATAKANA | LCMAP_FULLWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xa130\x34ff\x48ff\xaa30",
                       "byterev, katakana, full width",
                       &NumErrors );

    //  Variation 11  -  uppercase, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_KATAKANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "uppercase, katakana",
                       &NumErrors );


    //  Variation 12 -  uppercase, half width
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_HALFWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "uppercase, half width",
                       &NumErrors );




    //
    //  LCMAP_HIRAGANA, LCMAP_KATAKANA, LCMAP_HALFWIDTH, LCMAP_FULLWIDTH Flags.
    //  cchDest == 0
    //

    //  Variation 1  -  hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x3041Th\x304a",
                       "hiragana (cchDest = 0)",
                       &NumErrors );

    //  Variation 2  -  katakana
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x30a1Th\x30aa",
                       "katakana (cchDest = 0)",
                       &NumErrors );

    //  Variation 3  -  halfwidth
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30a6Th\x3131",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff73Th\xffa1",
                       "half width (cchDest = 0)",
                       &NumErrors );

    //  Variation 4  -  fullwidth
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\xff61Th\xffca",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x3002\xff34\xff48\x3155",
                       "full width (cchDest = 0)",
                       &NumErrors );

    //  Variation 5  -  hiragana, half width
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | LCMAP_HALFWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x3041Th\x304a",
                       "hiragana, half width (cchDest = 0)",
                       &NumErrors );

    //  Variation 6  -  hiragana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_HIRAGANA | LCMAP_FULLWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x3041\xff34\xff48\x304a",
                       "hiragana, full width (cchDest = 0)",
                       &NumErrors );

    //  Variation 7  -  katakana, half width
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA | LCMAP_HALFWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff67Th\xff75",
                       "katakana, half width (cchDest = 0)",
                       &NumErrors );

    //  Variation 8  -  katakana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_KATAKANA | LCMAP_FULLWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x30a1\xff34\xff48\x30aa",
                       "katakana, full width (cchDest = 0)",
                       &NumErrors );

    //  Variation 9  -  byterev, hiragana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_HIRAGANA | LCMAP_FULLWIDTH,
                       L"\x30a1Th\x30aa",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x4130\x34ff\x48ff\x4a30",
                       "byterev, hiragana, full width (cchDest = 0)",
                       &NumErrors );

    //  Variation 10 -  byterev, katakana, full width
    rc = LCMapStringW( Locale,
                       LCMAP_BYTEREV | LCMAP_KATAKANA | LCMAP_FULLWIDTH,
                       L"\x3041Th\x304a",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xa130\x34ff\x48ff\xaa30",
                       "byterev, katakana, full width (cchDest = 0)",
                       &NumErrors );

    //  Variation 11  -  uppercase, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_KATAKANA,
                       MapSrc1,
                       -1,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "uppercase, katakana (cchDest = 0)",
                       &NumErrors );


    //  Variation 12 -  uppercase, half width
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE | LCMAP_HALFWIDTH,
                       MapSrc1,
                       -1,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       MapUpper,
                       "uppercase, half width (cchDest = 0)",
                       &NumErrors );



    //
    //  Kana and Width - precomposed forms.
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half precomp",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x3070\x3071",
                       "half, hiragana precomp",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana precomp",
                       &NumErrors );

    //  Variation 4 -  case, half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30d0\xff2a\x30d1J",
                       5,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       7,
                       MapDest,
                       L"j\xff8a\xff9ej\xff8a\xff9fj",
                       "case, half, katakana precomp",
                       &NumErrors );

    //  Variation 5 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full precomp",
                       &NumErrors );

    //  Variation 6 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x3070\x3071",
                       "full, hiragana precomp",
                       &NumErrors );

    //  Variation 7 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full, katakana precomp",
                       &NumErrors );



    //
    //  Kana and Width - precomposed forms.
    //  cchDest = 0
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half precomp (cchDest = 0)",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x3070\x3071",
                       "half, hiragana precomp (cchDest = 0)",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana precomp (cchDest = 0)",
                       &NumErrors );

    //  Variation 4 -  case, half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30d0\xff2a\x30d1J",
                       5,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       7,
                       NULL,
                       L"j\xff8a\xff9ej\xff8a\xff9fj",
                       "case, half, katakana precomp (cchDest = 0)",
                       &NumErrors );

    //  Variation 5 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full precomp",
                       &NumErrors );

    //  Variation 6 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x3070\x3071",
                       "full, hiragana precomp (cchDest = 0)",
                       &NumErrors );

    //  Variation 7 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\x30d0\x30d1",
                       2,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full, katakana precomp (cchDest = 0)",
                       &NumErrors );



    //
    //  Kana and Width - composite forms.
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half comp",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\x306f\xff9e\x306f\xff9f",
                       "half, hiragana comp",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana comp",
                       &NumErrors );

    //  Variation 4 -  case, half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30cf\x309b\xff2a\x30cf\x309cJ",
                       7,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       7,
                       MapDest,
                       L"j\xff8a\xff9ej\xff8a\xff9fj",
                       "case, half, katakana comp",
                       &NumErrors );

    //  Variation 5 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full comp",
                       &NumErrors );

    //  Variation 6 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x3070\x3071",
                       "full, hiragana comp",
                       &NumErrors );

    //  Variation 7 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full, katakana comp",
                       &NumErrors );

    //  Variation 8 -  case, full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30cf\x309bJ\x30cf\x309cJ",
                       7,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       5,
                       MapDest,
                       L"\xff4a\x30d0\xff4a\x30d1\xff4a",
                       "case, full, katakana comp",
                       &NumErrors );


    //
    //  Kana and Width - composite forms.
    //  cchDest == 0
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\x306f\xff9e\x306f\xff9f",
                       "half, hiragana comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 4 -  case, half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30cf\x309b\xff2a\x30cf\x309cJ",
                       7,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       7,
                       NULL,
                       L"j\xff8a\xff9ej\xff8a\xff9fj",
                       "case, half, katakana comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 5 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 6 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x3070\x3071",
                       "full, hiragana comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 7 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\x30cf\x309b\x30cf\x309c",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full, katakana comp (cchDest = 0)",
                       &NumErrors );

    //  Variation 8 -  case, full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\x30cf\x309bJ\x30cf\x309cJ",
                       7,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       5,
                       NULL,
                       L"\xff4a\x30d0\xff4a\x30d1\xff4a",
                       "case, full, katakana comp (cchDest = 0)",
                       &NumErrors );



    //
    //  Kana and Width - half width composite forms.
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half comp (half)",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, hiragana comp (half)",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       4,
                       MapDest,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana comp (half)",
                       &NumErrors );

    //  Variation 4 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full comp (half)",
                       &NumErrors );

    //  Variation 5 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x3070\x3071",
                       "full, hiragana comp (half)",
                       &NumErrors );

    //  Variation 6 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"\x30d0\x30d1",
                       "full, katakana comp (half)",
                       &NumErrors );

    //  Variation 7 -  case, full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\xff8a\xff9eJ\xff8a\xff9fJ",
                       7,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       5,
                       MapDest,
                       L"\xff4a\x30d0\xff4a\x30d1\xff4a",
                       "case, full, katakana comp (half)",
                       &NumErrors );


    //
    //  Kana and Width - half width composite forms.
    //  cchDest == 0
    //

    //  Variation 1 -  half width
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 2 -  half width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_HIRAGANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, hiragana comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 3 -  half width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_HALFWIDTH | LCMAP_KATAKANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       4,
                       NULL,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       "half, katakana comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 4 -  full width
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 5 -  full width, hiragana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_HIRAGANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x3070\x3071",
                       "full, hiragana comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 6 -  full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA,
                       L"\xff8a\xff9e\xff8a\xff9f",
                       4,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       2,
                       NULL,
                       L"\x30d0\x30d1",
                       "full, katakana comp (half) (cchDest = 0)",
                       &NumErrors );

    //  Variation 7 -  case, full width, katakana
    rc = LCMapStringW( Locale,
                       LCMAP_FULLWIDTH | LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"\xff2a\xff8a\xff9eJ\xff8a\xff9fJ",
                       7,
                       MapDest,
                       0 );
    CheckReturnValidW( rc,
                       5,
                       NULL,
                       L"\xff4a\x30d0\xff4a\x30d1\xff4a",
                       "case, full, katakana comp (half) (cchDest = 0)",
                       &NumErrors );



    //
    //  LCMAP_TRADITIONAL_CHINESE Flag.
    //

    //  Variation 1  -  map simplified to traditional
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE,
                       L"\x4e07\x4e0e\x9f95\x9f9f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x842c\x8207\x9f95\x9f9c",
                       "traditional",
                       &NumErrors );

    //  Variation 2  -  map simplified to traditional
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_LOWERCASE,
                       L"\x4e07\x4e0e\x9f95\x9f9f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x842c\x8207\x9f95\x9f9c",
                       "traditional, lowercase",
                       &NumErrors );

    //  Variation 3  -  map simplified to traditional
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_LOWERCASE,
                       L"YYz\x4e07\x4e0e\x9f95\x9f9fYzY",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"yyz\x842c\x8207\x9f95\x9f9cyzy",
                       "traditional, lowercase 2",
                       &NumErrors );

    //  Variation 4  -  map simplified to traditional
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_UPPERCASE,
                       L"\x4e07\x4e0e\x9f95\x9f9f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x842c\x8207\x9f95\x9f9c",
                       "traditional, uppercase",
                       &NumErrors );

    //  Variation 5  -  map simplified to traditional
    rc = LCMapStringW( Locale,
                       LCMAP_TRADITIONAL_CHINESE | LCMAP_UPPERCASE,
                       L"Yyz\x4e07\x4e0e\x9f95\x9f9fyzY",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"YYZ\x842c\x8207\x9f95\x9f9cYZY",
                       "traditional, uppercase 2",
                       &NumErrors );



    //
    //  LCMAP_SIMPLIFIED_CHINESE Flag.
    //

    //  Variation 1  -  map traditional to simplified
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE,
                       L"\x4e1f\xfa26\x9038",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x4e22\x90fd\x9038",
                       "simplified",
                       &NumErrors );

    //  Variation 2  -  map traditional to simplified
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_LOWERCASE,
                       L"\x4e1f\xfa26\x9038",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x4e22\x90fd\x9038",
                       "simplified, lowercase",
                       &NumErrors );

    //  Variation 3  -  map traditional to simplified
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_LOWERCASE,
                       L"YYz\x4e1f\xfa26\x9038YzY",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"yyz\x4e22\x90fd\x9038yzy",
                       "simplified, lowercase 2",
                       &NumErrors );

    //  Variation 4  -  map traditional to simplified
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_UPPERCASE,
                       L"\x4e1f\xfa26\x9038",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x4e22\x90fd\x9038",
                       "simplified, uppercase",
                       &NumErrors );

    //  Variation 5  -  map traditional to simplified
    rc = LCMapStringW( Locale,
                       LCMAP_SIMPLIFIED_CHINESE | LCMAP_UPPERCASE,
                       L"Yyz\x4e1f\xfa26\x9038yzY",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"YYZ\x4e22\x90fd\x9038YZY",
                       "simplified, uppercase 2",
                       &NumErrors );



    //
    //  Japanese sortkey tests - CHO-ON.
    //

    //  Variation 1  -  cho-on
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30f6\x30fc",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0d\x22\x05\x01\x01\x01\xc4\xc4\xff\x03\x05\x02\xc4\xc4\xff\xff\x01",
                             "cho-on",
                             &NumErrors );

    //  Variation 2  -  cho-on first char
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30fc\x30f6\x30fc",
                       3,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\xff\xff\x22\x0d\x22\x05\x01\x01\x01\xc4\xc4\xff\x03\x05\x02\xc4\xc4\xff\xff\x01",
                             "cho-on first char",
                             &NumErrors );

    //  Variation 3  -  cho-on first and second char
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30fc\x30fc\x30f6\x30fc",
                       4,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\xff\xff\xff\xff\x22\x0d\x22\x05\x01\x01\x01\xc4\xc4\xff\x03\x05\x02\xc4\xc4\xff\xff\x01",
                             "cho-on first and second char",
                             &NumErrors );


    //  Variation 4  -  cho-on with ignore nonspace flag
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY | NORM_IGNORENONSPACE,
                       L"\xff76\xff9e\xff70",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0a\x22\x02\x01\x01\x01\xff\x02\xc4\xc4\xff\xc4\xc4\xff\x01",
                             "cho-on with ignore nonspace flag",
                             &NumErrors );

    //  Variation 5  -  cho-on without ignore nonspace flag
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY,
                       L"\xff76\xff9e\xff70",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0a\x22\x02\x01\x03\x01\x01\xff\x03\x05\x02\xc4\xc4\xff\xc4\xc4\xff\x01",
                             "cho-on without ignore nonspace flag",
                             &NumErrors );

    //  Variation 6  -  cho-on with ignore nonspace flag
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY | NORM_IGNORENONSPACE,
                       L"\xff76\xff9e\xff71",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0a\x22\x02\x01\x01\x01\xff\x02\xc4\xc4\xff\xc4\xc4\xff\x01",
                             "cho-on with ignore nonspace flag 2",
                             &NumErrors );

    //  Variation 7  -  cho-on without ignore nonspace flag
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY,
                       L"\xff76\xff9e\xff71",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0a\x22\x02\x01\x03\x01\x01\xff\x02\xc4\xc4\xff\xc4\xc4\xff\x01",
                             "cho-on without ignore nonspace flag 2",
                             &NumErrors );



    //
    //  Japanese sortkey tests - REPEAT.
    //

    //  Variation 1  -  repeat
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30f6\x30fd",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0d\x22\x0d\x01\x01\x01\xc4\xc4\xff\x03\x04\x02\xc4\xc4\xff\xff\x01",
                             "repeat",
                             &NumErrors );

    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30f6\x30f6",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x0d\x22\x0d\x01\x01\x01\xc4\xc4\xff\x02\xc4\xc4\xff\xff\x01",
                             "repeat (actual)",
                             &NumErrors );


    //  Variation 2  -  repeat first char
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30fd\x30f6\x30fd",
                       3,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\xff\xff\x22\x0d\x22\x0d\x01\x01\x01\xc4\xc4\xff\x03\x04\x02\xc4\xc4\xff\xff\x01",
                             "repeat first char",
                             &NumErrors );

    //  Variation 3  -  repeat first and second char
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30fd\x30fd\x30f6\x30fd",
                       4,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\xff\xff\xff\xff\x22\x0d\x22\x0d\x01\x01\x01\xc4\xc4\xff\x03\x04\x02\xc4\xc4\xff\xff\x01",
                             "repeat first and second char",
                             &NumErrors );

    //  Variation 4  -  repeat (0x30fb)
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x30fb\x30fd",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0a\x0e\x0a\x0e\x01\x01\x03\x01\x01",
                             "repeat (0x30fb)",
                             &NumErrors );

    //  Variation 5  -  repeat alone
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY,
                       L"\x3094\x309d",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x04\x22\x04\x01\x03\x01\x01\xff\x03\x04\x02\xff\xff\x01",
                             "repeat alone",
                             &NumErrors );

    //  Variation 6  -  repeat, ignore kana
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY | NORM_IGNOREKANATYPE,
                       L"\x3094\x309d",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x04\x22\x04\x01\x03\x01\x01\xff\x03\x04\x02\xc4\xc4\xff\xff\x01",
                             "repeat, ignore kana",
                             &NumErrors );

    //  Variation 7  -  repeat, ignore width
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY | NORM_IGNOREWIDTH,
                       L"\x3094\x309d",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x04\x22\x04\x01\x03\x01\x01\xff\x03\x04\x02\xff\xc4\xc4\xff\x01",
                             "repeat, ignore width",
                             &NumErrors );

    //  Variation 8  -  repeat, ignore kana and width
    rc = LCMapStringW( 0x0409,
                       LCMAP_SORTKEY | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH,
                       L"\x3094\x309d",
                       2,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x22\x04\x22\x04\x01\x03\x01\x01\xff\x03\x04\x02\xc4\xc4\xff\xc4\xc4\xff\x01",
                             "repeat, ignore kana and width",
                             &NumErrors );



    //
    //  Test for upper case.
    //

    //  Variation 1  -  uppercase
    rc = LCMapStringW( 0x0409,
                       LCMAP_UPPERCASE,
                       L"\x00e7",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x00c7",
                       "uppercase check",
                       &NumErrors );


    //
    //  More Japanese Tests.
    //
    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x0020",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3000",
                       "Japanese Test 1",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x0022",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff02",
                       "Japanese Test 2",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x0027",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff07",
                       "Japanese Test 3",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x005c",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x005c",
                       "Japanese Test 4",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x007e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff5e",
                       "Japanese Test 5",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x30fb",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x30fb",
                       "Japanese Test 6",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x3046\xff9e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3094",
                       "Japanese Test 7",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x3046\x309b",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3094",
                       "Japanese Test 8",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x304b\xff9e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x304c",
                       "Japanese Test 9",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_FULLWIDTH,
                       L"\x306f\xff9f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3071",
                       "Japanese Test 10",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x3000",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x0020",
                       "Japanese Test 11",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\xffe3",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x00af",
                       "Japanese Test 12",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x2015",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x2015",
                       "Japanese Test 13",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\xff3c",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff3c",
                       "Japanese Test 14",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\xff5e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x007e",
                       "Japanese Test 15",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x2018",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"'",
                       "Japanese Test 16",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x2019",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"'",
                       "Japanese Test 17",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x201c",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\"",
                       "Japanese Test 18",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x201d",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\"",
                       "Japanese Test 19",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\x30fb",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\xff65",
                       "Japanese Test 20",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HALFWIDTH,
                       L"\xffe5",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x00a5",
                       "Japanese Test 21",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HIRAGANA | LCMAP_LOWERCASE,
                       L"\x30fb",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x30fb",
                       "Japanese Test 22",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HIRAGANA,
                       L"\x30f4",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3094",
                       "Japanese Test 23",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_HIRAGANA,
                       L"\x30f4\xff9e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3094\xff9e",
                       "Japanese Test 24",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_UPPERCASE,
                       L"\x3046\xff9e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x3046\xff9e",
                       "Japanese Test 25",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_UPPERCASE,
                       L"\x304b\xff9e",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x304b\xff9e",
                       "Japanese Test 26",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_UPPERCASE,
                       L"\x304b\x309b",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x304b\x309b",
                       "Japanese Test 27",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_KATAKANA,
                       L"\x304f\x309b",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"\x30af\x309b",
                       "Japanese Test 28",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_KATAKANA | LCMAP_UPPERCASE,
                       L"a\x304f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"A\x30af",
                       "Japanese Test 29",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_KATAKANA | LCMAP_LOWERCASE,
                       L"A\x304f",
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"a\x30af",
                       "Japanese Test 30",
                       &NumErrors );

    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY,
                       L"\x005c",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0a\x05\x01\x01\x01\x01",
                             "Japanese 0x005c",
                             &NumErrors );


    //
    //  Ideograph LCMAP_SORTKEY Tests.
    //

    //  Variation 1  -  ideograph sortkey
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY,
                       L"\x99d5",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x81\x22\x01\x01\x01\x01",
                             "ideograph sortkey Japanese",
                             &NumErrors );

    //  Variation 2  -  ideograph sortkey, no DestStr
    rc = LCMapStringW( 0x0411,
                       LCMAP_SORTKEY,
                       L"\x99d5",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             -1,
                             NULL,
                             "\x81\x22\x01\x01\x01\x01",
                             "ideograph sortkey Japanese, no DestStr",
                             &NumErrors );

    //  Variation 3  -  ideograph sortkey
    rc = LCMapStringW( 0x0412,
                       LCMAP_SORTKEY,
                       L"\x99d5",
                       -1,
                       (LPWSTR)SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x03\x01\x79\x01\x01\x01",
                             "ideograph sortkey Korean",
                             &NumErrors );

    //  Variation 4  -  ideograph sortkey, no DestStr
    rc = LCMapStringW( 0x0412,
                       LCMAP_SORTKEY,
                       L"\x99d5",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             -1,
                             NULL,
                             "\x80\x03\x01\x79\x01\x01\x01",
                             "ideograph sortkey Korean, no DestStr",
                             &NumErrors );


    //
    //  Src = Dest - W Version.
    //

    //  Variation 1  -  lowercase
    MapDest[0] = L'X';
    MapDest[1] = L'Y';
    MapDest[2] = 0;
    rc = LCMapStringW( Locale,
                       LCMAP_LOWERCASE,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"xy",
                       "src = dest - lowercase",
                       &NumErrors );

    //  Variation 2  -  uppercase
    MapDest[0] = L'x';
    MapDest[1] = L'y';
    MapDest[2] = 0;
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapDest,
                       -1,
                       MapDest,
                       BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       MapDest,
                       L"XY",
                       "src = dest - uppercase",
                       &NumErrors );

    //  Variation 3  -  uppercase
    MapDest[0] = L'x';
    MapDest[1] = L'y';
    MapDest[2] = 0;
    rc = LCMapStringW( Locale,
                       LCMAP_UPPERCASE,
                       MapDest,
                       2,
                       MapDest,
                       2 );
    CheckReturnValidW( rc,
                       2,
                       MapDest,
                       L"XY",
                       "src = dest - uppercase, size",
                       &NumErrors );


    //
    //  Src = Dest - A Version.
    //

    //  Variation 1  -  lowercase
    MapDestA[0] = 'X';
    MapDestA[1] = 'Y';
    MapDestA[2] = 0;
    rc = LCMapStringA( Locale,
                       LCMAP_LOWERCASE,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       MapDestA,
                       "xy",
                       NULL,
                       "src = dest - lowercase (A Version)",
                       &NumErrors );

    //  Variation 2  -  uppercase
    MapDestA[0] = 'x';
    MapDestA[1] = 'y';
    MapDestA[2] = 0;
    rc = LCMapStringA( Locale,
                       LCMAP_UPPERCASE,
                       MapDestA,
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       MapDestA,
                       "XY",
                       NULL,
                       "src = dest - uppercase (A Version)",
                       &NumErrors );

    //  Variation 3  -  uppercase
    MapDestA[0] = 'x';
    MapDestA[1] = 'y';
    MapDestA[2] = 0;
    rc = LCMapStringA( Locale,
                       LCMAP_UPPERCASE,
                       MapDestA,
                       2,
                       MapDestA,
                       2 );
    CheckReturnValidA( rc,
                       2,
                       MapDestA,
                       "XY",
                       NULL,
                       "src = dest - uppercase, size (A Version)",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  LCMS_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int LCMS_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  LCMapStringA - USE CP ACP.
    //

    //  Variation 1  -  Use CP ACP
    rc = LCMapStringA( 0x0409,
                       LOCALE_USE_CP_ACP | LCMAP_LOWERCASE,
                       "ABCD",
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       MapDestA,
                       "abcd",
                       NULL,
                       "A Version Use CP ACP",
                       &NumErrors );


    //
    //  LCMapStringA - LOWER case.
    //

    //  Variation 1  -  Lower case
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE,
                       "ABCD",
                       -1,
                       MapDestA,
                       BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       MapDestA,
                       "abcd",
                       NULL,
                       "A version lower",
                       &NumErrors );

    //  Variation 2  -  Lower case
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE,
                       "ABCD",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "abcd",
                       NULL,
                       "A version lower (cchDest = 0)",
                       &NumErrors );

    //  Variation 3  -  Lower case
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE,
                       "ABCD",
                       4,
                       MapDestA,
                       BUFSIZE );
    CheckReturnValidA( rc,
                       4,
                       MapDestA,
                       "abcd",
                       NULL,
                       "A version lower size",
                       &NumErrors );

    //  Variation 4  -  Lower case
    rc = LCMapStringA( 0x0409,
                       LCMAP_LOWERCASE,
                       "ABCD",
                       4,
                       NULL,
                       0 );
    CheckReturnValidA( rc,
                       4,
                       NULL,
                       "abcd",
                       NULL,
                       "A version lower size (cchDest = 0)",
                       &NumErrors );


    //
    //  LCMapStringA - SORTKEY.
    //
    //  Variation 1  -  sortkey
    rc = LCMapStringA( Locale,
                       LCMAP_SORTKEY,
                       "Th",
                       -1,
                       SortDest,
                       BUFSIZE );
    CheckReturnValidSortKey( rc,
                             -1,
                             SortDest,
                             "\x0e\x99\x0e\x2c\x01\x01\x12\x01\x01",
                             "A version sortkey",
                             &NumErrors );

    //  Variation 2  -  sortkey, no DestStr
    rc = LCMapStringA( Locale,
                       LCMAP_SORTKEY,
                       "Th",
                       -1,
                       NULL,
                       0 );
    CheckReturnValidSortKey( rc,
                             -1,
                             NULL,
                             "\x0e\x99\x0e\x2c\x01\x01\x12\x01\x01",
                             "A version sortkey (cchDest = 0)",
                             &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidSortKey
//
//  Checks the return code from the valid LCMapString[A|W] call with the
//  LCMAP_SOTRKEY flag set.  It prints out the appropriate error if the
//  incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidSortKey(
    int CurrentReturn,
    int ExpectedReturn,
    LPBYTE pCurrentString,
    LPBYTE pExpectedString,
    LPBYTE pErrString,
    int *pNumErrors)
{
    int ctr;                 // loop counter


    if (ExpectedReturn == -1)
    {
        ExpectedReturn = MB_STRING_LEN_NULL(pExpectedString);
    }

    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsA(pCurrentString, pExpectedString, CurrentReturn)) ) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        if (pCurrentString != NULL)
        {
            printf("       ");
            for (ctr = 0; ctr < CurrentReturn; ctr++)
            {
                printf("%x ", pCurrentString[ctr]);
            }
            printf("\n");
        }

        (*pNumErrors)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gtftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gtftest.c

Abstract:

    Test module for NLS API GetTimeFormat.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    04-30-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE                50          // buffer size in wide chars
#define  GTF_INVALID_FLAGS      ((DWORD)(~(LOCALE_NOUSEROVERRIDE |       \
                                           TIME_NOMINUTESORSECONDS |     \
                                           TIME_NOSECONDS |              \
                                           TIME_NOTIMEMARKER |           \
                                           TIME_FORCE24HOURFORMAT)))

#define  ENGLISH_US             L"3:45:25 AM"
#define  CZECH                  L"3:45:25"
#define  DANISH                 L"03.45.25"

#define  US_NOMINSEC            L"3 AM"
#define  US_NOSEC               L"3:45 AM"
#define  US_NOTM                L"3:45:25"
#define  US_NOTM_NOMINSEC       L"3"
#define  US_NOTM_NOSEC          L"3:45"

#define  CZECH_NOMINSEC         L"3"
#define  CZECH_NOSEC            L"3:45"
#define  CZECH_NOTM             L"3:45:25"
#define  CZECH_NOTM_NOMINSEC    L"3"
#define  CZECH_NOTM_NOSEC       L"3:45"


#define  US_24HR                L"3:45:25 AM"
#define  US_24HR_2              L"15:45:25 PM"
#define  CZECH_24HR             L"3:45:25"
#define  CZECH_24HR_2           L"15:45:25"




//
//  Global Variables.
//

LCID Locale;

SYSTEMTIME SysTime;
SYSTEMTIME SysTime2;

WCHAR lpTimeStr[BUFSIZE];


//
//  Time format buffers must be in line with the pAllLocales global
//  buffer.
//
LPWSTR pTimeAM[] =
{
    L"03:45:25",                                 //  0x0402
    L"\x4e0a\x5348 03:45:25",                    //  0x0404
    L"3:45:25",                                  //  0x0804
    L"3:45:25",                                  //  0x0c04
    L"AM 3:45:25",                               //  0x1004
    L"3:45:25",                                  //  0x0405
    L"03:45:25",                                 //  0x0406
    L"03:45:25",                                 //  0x0407
    L"03:45:25",                                 //  0x0807
    L"03:45:25",                                 //  0x0c07
    L"3:45:25 \x03c0\x03bc",                     //  0x0408
    L"3:45:25 AM",                               //  0x0409
    L"03:45:25",                                 //  0x0809
    L"3:45:25 AM",                               //  0x0c09
    L"3:45:25 AM",                               //  0x1009
    L"3:45:25 a.m.",                             //  0x1409
    L"03:45:25",                                 //  0x1809
    L"3:45:25",                                  //  0x040a
    L"03:45:25 a.m.",                            //  0x080a
    L"3:45:25",                                  //  0x0c0a
    L"3:45:25",                                  //  0x040b
    L"03:45:25",                                 //  0x040c
    L"3:45:25",                                  //  0x080c
    L"03:45:25",                                 //  0x0c0c
    L"03:45:25",                                 //  0x100c
    L"3:45:25",                                  //  0x040e
    L"03:45:25",                                 //  0x040f
    L"3.45.25",                                  //  0x0410
    L"03:45:25",                                 //  0x0810
    L"3:45:25",                                  //  0x0411
    L"\xc624\xc804 3:45:25",                     //  0x0412
    L"3:45:25",                                  //  0x0413
    L"3:45:25",                                  //  0x0813
    L"03:45:25",                                 //  0x0414
    L"03:45:25",                                 //  0x0814
    L"03:45:25",                                 //  0x0415
    L"03:45:25",                                 //  0x0416
    L"3:45:25",                                  //  0x0816
    L"03:45:25",                                 //  0x0418
    L"3:45:25",                                  //  0x0419
    L"3:45:25",                                  //  0x041a
    L"3:45:25",                                  //  0x041b
    L"03:45:25",                                 //  0x041d
    L"03:45:25",                                 //  0x041f
    L"3:45:25"                                   //  0x0424
};

LPWSTR pTimePM[] =
{
    L"15:45:25",                                 //  0x0402
    L"\x4e0b\x5348 03:45:25",                    //  0x0404
    L"15:45:25",                                 //  0x0804
    L"15:45:25",                                 //  0x0c04
    L"PM 3:45:25",                               //  0x1004
    L"15:45:25",                                 //  0x0405
    L"15:45:25",                                 //  0x0406
    L"15:45:25",                                 //  0x0407
    L"15:45:25",                                 //  0x0807
    L"15:45:25",                                 //  0x0c07
    L"3:45:25 \x03bc\x03bc",                     //  0x0408
    L"3:45:25 PM",                               //  0x0409
    L"15:45:25",                                 //  0x0809
    L"3:45:25 PM",                               //  0x0c09
    L"3:45:25 PM",                               //  0x1009
    L"3:45:25 p.m.",                             //  0x1409
    L"15:45:25",                                 //  0x1809
    L"15:45:25",                                 //  0x040a
    L"03:45:25 p.m.",                            //  0x080a
    L"15:45:25",                                 //  0x0c0a
    L"15:45:25",                                 //  0x040b
    L"15:45:25",                                 //  0x040c
    L"15:45:25",                                 //  0x080c
    L"15:45:25",                                 //  0x0c0c
    L"15:45:25",                                 //  0x100c
    L"15:45:25",                                 //  0x040e
    L"15:45:25",                                 //  0x040f
    L"15.45.25",                                 //  0x0410
    L"15:45:25",                                 //  0x0810
    L"15:45:25",                                 //  0x0411
    L"\xc624\xd6c4 3:45:25",                     //  0x0412
    L"15:45:25",                                 //  0x0413
    L"15:45:25",                                 //  0x0813
    L"15:45:25",                                 //  0x0414
    L"15:45:25",                                 //  0x0814
    L"15:45:25",                                 //  0x0415
    L"15:45:25",                                 //  0x0416
    L"15:45:25",                                 //  0x0816
    L"15:45:25",                                 //  0x0418
    L"15:45:25",                                 //  0x0419
    L"15:45:25",                                 //  0x041a
    L"15:45:25",                                 //  0x041b
    L"15:45:25",                                 //  0x041d
    L"15:45:25",                                 //  0x041f
    L"15:45:25"                                  //  0x0424
};




//
//  Forward Declarations.
//

BOOL
InitGetTimeFormat();

int
GTF_BadParamCheck();

int
GTF_NormalCase();

int
GTF_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetTimeFormat
//
//  Test routine for GetTimeFormatW API.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetTimeFormat()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetTimeFormatW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetTimeFormat())
    {
        printf("\nABORTED TestGetTimeFormat: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GTF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GTF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GTF_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetTimeFormatW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetTimeFormat
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetTimeFormat()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Initialize the system time.
    //
    SysTime.wYear = 1993;
    SysTime.wMonth = 5;
    SysTime.wDayOfWeek = 6;
    SysTime.wDay = 1;
    SysTime.wHour = 3;
    SysTime.wMinute = 45;
    SysTime.wSecond = 25;
    SysTime.wMilliseconds = 13;

    SysTime2.wYear = 1993;
    SysTime2.wMonth = 5;
    SysTime2.wDayOfWeek = 6;
    SysTime2.wDay = 1;
    SysTime2.wHour = 15;
    SysTime2.wMinute = 45;
    SysTime2.wSecond = 25;
    SysTime2.wMilliseconds = 13;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GTF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GTF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyTime;            // structure to hold custom time


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetTimeFormatW( (LCID)333,
                          0,
                          NULL,
                          NULL,
                          lpTimeStr,
                          BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpTimeStr = NULL
    rc = GetTimeFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         NULL,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpTimeStr NULL",
                         &NumErrors );


    //
    //  Bad Count.
    //

    //  Variation 1  -  cchTime < 0
    rc = GetTimeFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         lpTimeStr,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchTime < 0",
                         &NumErrors );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  LCType = invalid
    rc = GetTimeFormatW( Locale,
                         GTF_INVALID_FLAGS,
                         NULL,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Flag invalid",
                         &NumErrors );

    //  Variation 2  -  lpFormat and NoUserOverride
    rc = GetTimeFormatW( Locale,
                         LOCALE_NOUSEROVERRIDE,
                         NULL,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "lpFormat and NoUserOverride",
                         &NumErrors );

    //  Variation 3  -  Use CP ACP, lpFormat and NoUserOverride
    rc = GetTimeFormatW( Locale,
                         LOCALE_USE_CP_ACP | LOCALE_NOUSEROVERRIDE,
                         NULL,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, lpFormat and NoUserOverride",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchTime = too small
    rc = GetTimeFormatW( Locale,
                         0,
                         NULL,
                         NULL,
                         lpTimeStr,
                         2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchTime too small",
                         &NumErrors );


    //
    //  Bad time passed in.
    //

    //  Variation 1  -  bad wHour
    MyTime.wYear = 1993;
    MyTime.wMonth = 5;
    MyTime.wDayOfWeek = 6;
    MyTime.wDay = 1;
    MyTime.wHour = 24;
    MyTime.wMinute = 45;
    MyTime.wSecond = 25;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( Locale,
                         0,
                         &MyTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wHour",
                         &NumErrors );

    //  Variation 2  -  bad wMinute
    MyTime.wYear = 1993;
    MyTime.wMonth = 5;
    MyTime.wDayOfWeek = 6;
    MyTime.wDay = 1;
    MyTime.wHour = 15;
    MyTime.wMinute = 60;
    MyTime.wSecond = 25;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( Locale,
                         0,
                         &MyTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wMinute",
                         &NumErrors );

    //  Variation 3  -  bad wSecond
    MyTime.wYear = 1993;
    MyTime.wMonth = 5;
    MyTime.wDayOfWeek = 6;
    MyTime.wDay = 1;
    MyTime.wHour = 15;
    MyTime.wMinute = 45;
    MyTime.wSecond = 60;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( Locale,
                         0,
                         &MyTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wSecond",
                         &NumErrors );

    //  Variation 4  -  bad wMilliseconds
    MyTime.wYear = 1993;
    MyTime.wMonth = 5;
    MyTime.wDayOfWeek = 6;
    MyTime.wDay = 1;
    MyTime.wHour = 15;
    MyTime.wMinute = 45;
    MyTime.wSecond = 25;
    MyTime.wMilliseconds = 1000;
    rc = GetTimeFormatW( Locale,
                         0,
                         &MyTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad wMilliseconds",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GTF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GTF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyTime;            // structure to hold custom time
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetTimeFormatW( LOCALE_SYSTEM_DEFAULT,
                         0,
                         NULL,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "system default locale",
                      &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetTimeFormatW( LOCALE_USER_DEFAULT,
                         0,
                         NULL,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "current user locale",
                      &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  neutral
    rc = GetTimeFormatW( 0x0000,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "neutral locale",
                       &NumErrors );

    //  Variation 2  -  sys default
    rc = GetTimeFormatW( 0x0400,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "sys default locale",
                       &NumErrors );

    //  Variation 3  -  user default
    rc = GetTimeFormatW( 0x0800,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "user default locale",
                       &NumErrors );

    //  Variation 4  -  sub lang neutral US
    rc = GetTimeFormatW( 0x0009,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "sub lang neutral US",
                       &NumErrors );

    //  Variation 5  -  sub lang neutral Czech
    rc = GetTimeFormatW( 0x0005,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH,
                       "sub lang neutral Czech",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = GetTimeFormatW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_USE_CP_ACP,
                         NULL,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "Use CP ACP, system default locale",
                      &NumErrors );


    //
    //  cchTime.
    //

    //  Variation 1  -  cchTime = size of lpTimeStr buffer
    rc = GetTimeFormatW( Locale,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "cchTime = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchTime = 0
    lpTimeStr[0] = 0x0000;
    rc = GetTimeFormatW( Locale,
                         0,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       ENGLISH_US,
                       "cchTime zero",
                       &NumErrors );

    //  Variation 3  -  cchTime = 0, lpTimeStr = NULL
    rc = GetTimeFormatW( Locale,
                         0,
                         &SysTime,
                         NULL,
                         NULL,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       ENGLISH_US,
                       "cchTime (NULL ptr)",
                       &NumErrors );


    //
    //  lpFormat.
    //

    //  Variation 1  -  AM/PM
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &SysTime,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"AM 03:45:25",
                       "lpFormat AM/PM (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 2  -  AM/PM
    rc = GetTimeFormatW( 0x0409,
                         TIME_NOTIMEMARKER,
                         &SysTime,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"03:45:25",
                       "lpFormat NoTimeMarker (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 3  -  AM/PM
    rc = GetTimeFormatW( 0x0409,
                         TIME_NOTIMEMARKER | TIME_NOSECONDS,
                         &SysTime,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"03:45",
                       "lpFormat NoTimeMarker, NoSeconds (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 4  -  AM/PM
    rc = GetTimeFormatW( 0x0409,
                         TIME_NOTIMEMARKER | TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"03",
                       "lpFormat NoTimeMarker, NoMinutesOrSeconds (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 5  -  AM/PM
    rc = GetTimeFormatW( 0x0409,
                         TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         L"tt hh:mm:ss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"AM 03",
                       "lpFormat NoMinutesOrSeconds (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 6  -  Extra h, m, s
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &SysTime,
                         L"hhh:mmm:sss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"03:45:25",
                       "lpFormat (hhh:mmm:sss)",
                       &NumErrors );

    //  Variation 7  -  Extra H, m, s
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &SysTime2,
                         L"HHH:mmm:sss",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"15:45:25",
                       "lpFormat (HHH:mmm:sss)",
                       &NumErrors );

    //  Variation 8  -  h:m:s
    MyTime.wHour = 15;
    MyTime.wMinute = 4;
    MyTime.wSecond = 5;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &MyTime,
                         L"h:m:s",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"3:4:5",
                       "lpFormat (h:m:s)",
                       &NumErrors );

    //  Variation 9  -  H:m:s
    MyTime.wHour = 15;
    MyTime.wMinute = 4;
    MyTime.wSecond = 5;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &MyTime,
                         L"H:m:s",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"15:4:5",
                       "lpFormat (H:m:s)",
                       &NumErrors );

    //  Variation 10  -  single quote
    MyTime.wHour = 15;
    MyTime.wMinute = 4;
    MyTime.wSecond = 5;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &MyTime,
                         L"h 'oclock'",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"3 oclock",
                       "lpFormat (h 'oclock')",
                       &NumErrors );

    //  Variation 11  -  single quote
    MyTime.wHour = 15;
    MyTime.wMinute = 4;
    MyTime.wSecond = 5;
    MyTime.wMilliseconds = 13;
    rc = GetTimeFormatW( 0x0409,
                         0,
                         &MyTime,
                         L"h 'o''clock' tt",
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       L"3 o'clock PM",
                       "lpFormat (h 'o''clock' tt)",
                       &NumErrors );


    //
    //  Flag values.
    //

    //  Variation 1  -  NOUSEROVERRIDE
    rc = GetTimeFormatW( Locale,
                         LOCALE_NOUSEROVERRIDE,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       ENGLISH_US,
                       "NoUserOverride",
                       &NumErrors );

    //  Variation 2  -  US NOMINUTESORSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOMINSEC,
                       "US NoMinutesOrSeconds",
                       &NumErrors );

    //  Variation 3  -  US NOSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOSEC,
                       "US NoSeconds",
                       &NumErrors );

    //  Variation 4  -  US NOMINUTESORSECONDS and NOSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOMINUTESORSECONDS | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOMINSEC,
                       "US NoMinutesOrSeconds, NoSeconds",
                       &NumErrors );

    //  Variation 5  -  US NOTIMEMARKER
    rc = GetTimeFormatW( Locale,
                         TIME_NOTIMEMARKER,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOTM,
                       "US NoTimeMarker",
                       &NumErrors );

    //  Variation 6  -  US NOTIMEMARKER and NOMINUTESORSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOTIMEMARKER | TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOTM_NOMINSEC,
                       "US NoTimeMarker, NoMinutesOrSeconds",
                       &NumErrors );

    //  Variation 7  -  US NOTIMEMARKER and NOSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOTIMEMARKER | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOTM_NOSEC,
                       "US NoTimeMarker, NoSeconds",
                       &NumErrors );

    //  Variation 8  -  US NOTIMEMARKER and NOMINUTESORSECONDS and NOSECONDS
    rc = GetTimeFormatW( Locale,
                         TIME_NOTIMEMARKER | TIME_NOMINUTESORSECONDS | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_NOTM_NOMINSEC,
                       "US NoTimeMarker, NoMinutesOrSeconds, NoSeconds",
                       &NumErrors );

    //  Variation 9  -  CZECH NOMINUTESORSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOMINSEC,
                       "Czech NoMinutesOrSeconds",
                       &NumErrors );

    //  Variation 10 -  CZECH NOSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOSEC,
                       "Czech NoSeconds",
                       &NumErrors );

    //  Variation 11 -  CZECH NOMINUTESORSECONDS and NOSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOMINUTESORSECONDS | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOMINSEC,
                       "Czech NoMinutesOrSeconds, NoSeconds",
                       &NumErrors );

    //  Variation 12 -  CZECH NOTIMEMARKER
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOTIMEMARKER,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOTM,
                       "Czech NoTimeMarker",
                       &NumErrors );

    //  Variation 13 -  CZECH NOTIMEMARKER and NOMINUTESORSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOTIMEMARKER | TIME_NOMINUTESORSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOTM_NOMINSEC,
                       "Czech NoTimeMarker, NoMinutesOrSeconds",
                       &NumErrors );

    //  Variation 14 -  CZECH NOTIMEMARKER and NOSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOTIMEMARKER | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOTM_NOSEC,
                       "Czech NoTimeMarker, NoSeconds",
                       &NumErrors );

    //  Variation 15 -  CZECH NOTIMEMARKER and NOMINUTESORSECONDS and NOSECONDS
    rc = GetTimeFormatW( 0x0405,
                         TIME_NOTIMEMARKER | TIME_NOMINUTESORSECONDS | TIME_NOSECONDS,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_NOTM_NOMINSEC,
                       "Czech NoTimeMarker, NoMinutesOrSeconds, NoSeconds",
                       &NumErrors );


    //  Variation 16  -  US FORCE24HOURFORMAT
    rc = GetTimeFormatW( Locale,
                         TIME_FORCE24HOURFORMAT,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_24HR,
                       "US Force24HourFormat 1",
                       &NumErrors );

    //  Variation 17  -  US FORCE24HOURFORMAT
    rc = GetTimeFormatW( Locale,
                         TIME_FORCE24HOURFORMAT,
                         &SysTime2,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       US_24HR_2,
                       "US Force24HourFormat 2",
                       &NumErrors );

    //  Variation 18 -  CZECH FORCE24HOURFORMAT
    rc = GetTimeFormatW( 0x0405,
                         TIME_FORCE24HOURFORMAT,
                         &SysTime,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_24HR,
                       "Czech Force24HourFormat",
                       &NumErrors );

    //  Variation 19 -  CZECH FORCE24HOURFORMAT
    rc = GetTimeFormatW( 0x0405,
                         TIME_FORCE24HOURFORMAT,
                         &SysTime2,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpTimeStr,
                       CZECH_24HR_2,
                       "Czech Force24HourFormat 2",
                       &NumErrors );



    //
    //  Test all locales - 3:45:25 AM
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetTimeFormatW( pAllLocales[ctr],
                             0,
                             &SysTime,
                             NULL,
                             lpTimeStr,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpTimeStr,
                               pTimeAM[ctr],
                               "Time AM",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  Test all locales - 3:45:25 PM
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetTimeFormatW( pAllLocales[ctr],
                             0,
                             &SysTime2,
                             NULL,
                             lpTimeStr,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpTimeStr,
                               pTimePM[ctr],
                               "Time PM",
                               pAllLocales[ctr],
                               &NumErrors );
    }



    //
    //  System Time.
    //
    //  NOTE: For this test, must use a locale that has the same length
    //        for both the AM and PM, since I don't check if the test
    //        is run in the AM or PM.
    //

    //  Variation 1  -  Danish system time
    rc = GetTimeFormatW( 0x0406,
                         0,
                         NULL,
                         NULL,
                         lpTimeStr,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       DANISH,
                       "Danish System Time",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GTF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  04-30-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GTF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    SYSTEMTIME MyTime;            // structure to hold custom time
    BYTE pTimeStrA[BUFSIZE];      // ptr to time string


    MyTime.wYear = 1993;
    MyTime.wMonth = 5;
    MyTime.wDayOfWeek = 6;
    MyTime.wDay = 1;
    MyTime.wHour = 15;
    MyTime.wMinute = 4;
    MyTime.wSecond = 5;
    MyTime.wMilliseconds = 13;


    //
    //  GetTimeFormatA
    //

    //  Variation 1  -  AM/PM
    rc = GetTimeFormatA( 0x0409,
                         0,
                         &MyTime,
                         "tt hh:mm:ss",
                         pTimeStrA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pTimeStrA,
                       "PM 03:04:05",
                       NULL,
                       "A version (tt hh:mm:ss)",
                       &NumErrors );

    //  Variation 2  -  AM/PM (no dest)
    rc = GetTimeFormatA( 0x0409,
                         0,
                         &MyTime,
                         "tt hh:mm:ss",
                         NULL,
                         0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "PM 03:04:05",
                       NULL,
                       "A version (tt hh:mm:ss), no Dest",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, AM/PM
    rc = GetTimeFormatA( 0x0409,
                         LOCALE_USE_CP_ACP,
                         &MyTime,
                         "tt hh:mm:ss",
                         pTimeStrA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pTimeStrA,
                       "PM 03:04:05",
                       NULL,
                       "A version Use CP ACP (tt hh:mm:ss)",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gsttest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gsttest.c

Abstract:

    Test module for NLS API GetStringType.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             50
#define  GST_INVALID_FLAGS   ((DWORD)(~(CT_CTYPE1 | CT_CTYPE2 | CT_CTYPE3)))

#define  CT1_LOCASE_LETTER   L"\x0302\x0302"
#define  CT1_UPCASE_LETTER   L"\x0301\x0301"


#ifdef JDB

    // JDB - Fix to get around C compiler bug - it tries to translate
    //       from Unicode to Ansi
    #define  CT1_NUMBER          L"\x0284\x0284"

#else

    // JDB - Fix to get around C compiler bug.
    WCHAR CT1_NUMBER[] = {0x0284, 0x0284, 0x0000};

#endif


#define  CT1_PUNCTUATION     L"\x0210\x0210"

#define  CT2_LOCASE_LETTER   L"\x0001\x0001"
#define  CT2_UPCASE_LETTER   L"\x0001\x0001"
#define  CT2_NUMBER          L"\x0003\x0003"
#define  CT2_PUNCTUATION     L"\x000b\x000b"

#define  CT3_VALUE           L"\x8040\x8040"
#define  CT3_SYMBOL          L"\x0048\x0048"




//
//  Global Variables.
//

#define pGSTSrcLower    L"th"

#define pGSTSrcUpper    L"TH"

#define pGSTSrcNumber   L"12"

#define pGSTSrcPunct    L";?"


WORD  pCharType[BUFSIZE * 2];




//
//  Forward Declarations.
//

BOOL
InitGetStringType();

int
GST_BadParamCheck();

int
GST_NormalCase();

int
GST_Ansi();

void
CheckReturnGetStringType(
    int CurrentReturn,
    int ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    int ExpectedSize,
    LPSTR pErrString,
    int *pNumErrors);





////////////////////////////////////////////////////////////////////////////
//
//  TestGetStringType
//
//  Test routine for GetStringTypeW API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetStringType()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetStringTypeW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetStringType())
    {
        printf("\nABORTED TestGetStringType: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GST_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GST_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GST_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetStringTypeW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetStringType
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetStringType()
{
    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GST_BadParamCheck
//
//  This routine passes in bad parameters to the API routine and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GST_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    BOOL rc;                      // return code


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpSrcStr = NULL
    rc = GetStringTypeW( CT_CTYPE1,
                         NULL,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "lpSrcStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpCharType = NULL
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcUpper,
                         -1,
                         NULL );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "lpCharType NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cbSrc = 0
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcUpper,
                         0,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_PARAMETER,
                         "cbSrc = 0",
                         &NumErrors );


    //
    //  Zero or Invalid Flag Values.
    //

    //  Variation 1  -  dwInfoType = invalid
    rc = GetStringTypeW( GST_INVALID_FLAGS,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "dwInfoType invalid",
                         &NumErrors );

    //  Variation 2  -  dwInfoType = 0
    rc = GetStringTypeW( 0,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "dwInfoType zero",
                         &NumErrors );

    //  Variation 3  -  illegal combo case 1,2
    rc = GetStringTypeW( CT_CTYPE1 | CT_CTYPE2,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "illegal combo case 1,2",
                         &NumErrors );

    //  Variation 4  -  illegal combo case 1,3
    rc = GetStringTypeW( CT_CTYPE1 | CT_CTYPE3,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "illegal combo case 1,3",
                         &NumErrors );

    //  Variation 5  -  illegal combo case 2,3
    rc = GetStringTypeW( CT_CTYPE2 | CT_CTYPE3,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnBadParam( rc,
                         FALSE,
                         ERROR_INVALID_FLAGS,
                         "illegal combo case 2,3",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GST_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GST_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  GetStringTypeW
    //

    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnEqual( rc,
                      FALSE,
                      "cbSrc (-1)",
                      &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcUpper,
                         WC_STRING_LEN(pGSTSrcUpper),
                         pCharType );
    CheckReturnEqual( rc,
                      FALSE,
                      "cbSrc (value)",
                      &NumErrors );


    //
    //  CTYPE 1.
    //

    //  Variation 1  -  ctype1, lower
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcLower,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_LOCASE_LETTER,
                              2,
                              "ctype1, lower",
                              &NumErrors );

    //  Variation 2  -  ctype1, upper case letter
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_UPCASE_LETTER,
                              2,
                              "ctype1, upper",
                              &NumErrors );

    //  Variation 3  -  ctype1, number
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcNumber,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_NUMBER,
                              2,
                              "ctype1, number",
                              &NumErrors );

    //  Variation 4  -  ctype1, punctuation
    rc = GetStringTypeW( CT_CTYPE1,
                         pGSTSrcPunct,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_PUNCTUATION,
                              2,
                              "ctype1, punctuation",
                              &NumErrors );

    //  Variation 5  -  ctype 1
    rc = GetStringTypeW( CT_CTYPE1,
                         L"\xff53",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0302\x0220",
                              2,
                              "ctype1 (0xff53)",
                              &NumErrors );



    //
    //  CTYPE 2.
    //

    //  Variation 1  -  ctype2, lower
    rc = GetStringTypeW( CT_CTYPE2,
                         pGSTSrcLower,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT2_LOCASE_LETTER,
                              2,
                              "ctype2, lower",
                              &NumErrors );

    //  Variation 2  -  ctype2, upper case letter
    rc = GetStringTypeW( CT_CTYPE2,
                         pGSTSrcUpper,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT2_UPCASE_LETTER,
                              2,
                              "ctype2, upper",
                              &NumErrors );

    //  Variation 3  -  ctype2, number
    rc = GetStringTypeW( CT_CTYPE2,
                         pGSTSrcNumber,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT2_NUMBER,
                              2,
                              "ctype2, number",
                              &NumErrors );

    //  Variation 4  -  ctype2, punctuation
    rc = GetStringTypeW( CT_CTYPE2,
                         pGSTSrcPunct,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT2_PUNCTUATION,
                              2,
                              "ctype2, punctuation",
                              &NumErrors );

    //  Variation 5  -  ctype 2
    rc = GetStringTypeW( CT_CTYPE2,
                         L"\xff53",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0001\x0000",
                              2,
                              "ctype2 (0xff53)",
                              &NumErrors );



    //
    //  CTYPE 3.
    //

    //  Variation 1  -  ctype 3 should return zeros
    rc = GetStringTypeW( CT_CTYPE3,
                         pGSTSrcLower,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT3_VALUE,
                              2,
                              "ctype3 zero",
                              &NumErrors );

    //  Variation 2  -  ctype 3 symbol
    rc = GetStringTypeW( CT_CTYPE3,
                         pGSTSrcPunct,
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT3_SYMBOL,
                              2,
                              "ctype3 symbol",
                              &NumErrors );

    //  Variation 3  -  ctype 3
    rc = GetStringTypeW( CT_CTYPE3,
                         L"\xff53",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x8080\x0000",
                              2,
                              "ctype3 (0xff53)",
                              &NumErrors );



////////////////////////////////////////////////////////////////////////////


    //
    //  GetStringTypeExW
    //

    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = GetStringTypeExW( 0x0409,
                           CT_CTYPE1,
                           pGSTSrcUpper,
                           -1,
                           pCharType );
    CheckReturnEqual( rc,
                      FALSE,
                      "Ex cbSrc (-1)",
                      &NumErrors );


    //
    //  CTYPE 1.
    //

    //  Variation 1  -  ctype1, lower
    rc = GetStringTypeExW( 0x0409,
                           CT_CTYPE1,
                           pGSTSrcLower,
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_LOCASE_LETTER,
                              2,
                              "Ex ctype1 lower",
                              &NumErrors );


    //
    //  CTYPE 2.
    //

    //  Variation 1  -  ctype2, lower
    rc = GetStringTypeExW( 0x0409,
                           CT_CTYPE2,
                           pGSTSrcLower,
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT2_LOCASE_LETTER,
                              2,
                              "Ex ctype2 lower",
                              &NumErrors );


    //
    //  CTYPE 3.
    //

    //  Variation 1  -  ctype 3 should return zeros
    rc = GetStringTypeExW( 0x0409,
                           CT_CTYPE3,
                           pGSTSrcLower,
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT3_VALUE,
                              2,
                              "Ex ctype3 zero",
                              &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GST_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GST_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code



    //
    //  GetStringTypeA
    //

    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = GetStringTypeA( 0x0409,
                         CT_CTYPE1,
                         "TH",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_UPCASE_LETTER,
                              2,
                              "A version cbSrc (-1)",
                              &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = GetStringTypeA( 0x0409,
                         CT_CTYPE1,
                         "TH",
                         2,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_UPCASE_LETTER,
                              2,
                              "A version cbSrc (value)",
                              &NumErrors );


    //
    //  CTYPE 1.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeA( 0x0409,
                         CT_CTYPE1,
                         "Ab",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0381\x0382\x0220",
                              3,
                              "A version ctype1 (Ab)",
                              &NumErrors );


    //
    //  CTYPE 2.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeA( 0x0409,
                         CT_CTYPE2,
                         "Ab",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0001\x0001\x0000",
                              3,
                              "A version ctype2 (Ab)",
                              &NumErrors );


    //
    //  CTYPE 3.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeA( 0x0409,
                         CT_CTYPE3,
                         "Ab",
                         -1,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x8040\x8040\x0000",
                              3,
                              "A version ctype3 (Ab)",
                              &NumErrors );


    //
    //   Check invalid chars.
    //

    //  Variation 1  -  invalid chars
    rc = GetStringTypeA( 0x0411,
                         CT_CTYPE1,
                         "\xa0\xfd\xfe\xff\x85\x40\x81\x02\x81",
                         9,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0000\x0000\x0000\x0000\x0000\x0000\x0000",
                              7,
                              "A version ctype1 (invalid chars)",
                              &NumErrors );

    //  Variation 2  -  invalid chars
    rc = GetStringTypeA( 0x0411,
                         CT_CTYPE2,
                         "\xa0\xfd\xfe\xff\x85\x40\x81\x02\x81",
                         9,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0000\x0000\x0000\x0000\x0000\x0000\x0000",
                              7,
                              "A version ctype2 (invalid chars)",
                              &NumErrors );

    //  Variation 3  -  invalid chars
    rc = GetStringTypeA( 0x0411,
                         CT_CTYPE3,
                         "\xa0\xfd\xfe\xff\x85\x40\x81\x02\x81",
                         9,
                         pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0000\x0000\x0000\x0000\x0000\x0000\x0000",
                              7,
                              "A version ctype3 (invalid chars)",
                              &NumErrors );



////////////////////////////////////////////////////////////////////////////


    //
    //  GetStringTypeExA
    //

    //
    //  cbSrc.
    //

    //  Variation 1  -  cbSrc = -1
    rc = GetStringTypeExA( 0x0409,
                           CT_CTYPE1,
                           "TH",
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_UPCASE_LETTER,
                              2,
                              "Ex A version cbSrc (-1)",
                              &NumErrors );

    //  Variation 2  -  cbSrc = value
    rc = GetStringTypeExA( 0x0409,
                           CT_CTYPE1,
                           "TH",
                           2,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              CT1_UPCASE_LETTER,
                              2,
                              "Ex A version cbSrc (value)",
                              &NumErrors );


    //
    //  CTYPE 1.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeExA( 0x0409,
                           CT_CTYPE1,
                           "Ab",
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0381\x0382\x0220",
                              3,
                              "Ex A version ctype1 (Ab)",
                              &NumErrors );


    //
    //  CTYPE 2.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeExA( 0x0409,
                           CT_CTYPE2,
                           "Ab",
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x0001\x0001\x0000",
                              3,
                              "Ex A version ctype2 (Ab)",
                              &NumErrors );


    //
    //  CTYPE 3.
    //

    //  Variation 1  -  Ab
    rc = GetStringTypeExA( 0x0409,
                           CT_CTYPE3,
                           "Ab",
                           -1,
                           pCharType );
    CheckReturnGetStringType( rc,
                              TRUE,
                              pCharType,
                              L"\x8040\x8040\x0000",
                              3,
                              "Ex A version ctype3 (Ab)",
                              &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnGetStringType
//
//  Checks the return code from the valid GetStringType[A|W] call.  It
//  prints out the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnGetStringType(
    int CurrentReturn,
    int ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    int ExpectedSize,
    LPSTR pErrString,
    int *pNumErrors)
{
    int ctr;                 // loop counter


    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsW(pCurrentString, pExpectedString, ExpectedSize)) ) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        if (pCurrentString != NULL)
        {
            printf("       ");
            for (ctr = 0; ctr < ExpectedSize; ctr++)
            {
                printf("%x ", pCurrentString[ctr]);
            }
            printf("\n");
        }

        (*pNumErrors)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\glitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    glitest.c

Abstract:

    Test module for NLS API GetLocaleInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE         50                 // buffer size in wide chars
#define  LCTYPE_INVALID  0x0000100          // invalid LCTYPE
#define  LANG_INVALID    0x0417             // invalid lang id


#define  S_ILANGUAGE            L"0409"
#define  S_SLANGUAGE            L"English (United States)"

#define  S_SMONTHNAME1_RUSSIAN  L"\x042f\x043d\x0432\x0430\x0440\x044c"
#define  S_SMONTHNAME2_RUSSIAN  L"\x0424\x0435\x0432\x0440\x0430\x043b\x044c"

#define  FONTSIG_ENGLISH        L"\x00af\x8000\x38cb\x0000\x0000\x0000\x0000\x0000\x0001\x0000\x0000\x8000\x01ff\x003f\x8000\xffff"
#define  FONTSIG_RUSSIAN        L"\x0203\x8000\x3848\x0000\x0000\x0000\x0000\x0000\x0004\x0000\x0000\x0002\x0004\x0000\x0000\x0202"

#define  FONTSIG_ENGLISH_A      "\xaf\x00\x00\x80\xcb\x38\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x80\xff\x01\x3f\x00\x00\x80\xff\xff"
#define  FONTSIG_RUSSIAN_A      "\x03\x02\x00\x80\x48\x38\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x02\x00\x04\x00\x00\x00\x00\x00\x02\x02"




//
//  Global Variables.
//

LCID Locale;

WCHAR lpLCData[BUFSIZE];
BYTE  lpLCDataA[BUFSIZE];

//
//  pLocaleFlag and pLocaleString must have the same number of entries.
//
LCTYPE pLocaleFlag[] =
{
    LOCALE_ILANGUAGE,
    LOCALE_SLANGUAGE,
    LOCALE_SENGLANGUAGE,
    LOCALE_SABBREVLANGNAME,
    LOCALE_SNATIVELANGNAME,

    LOCALE_ICOUNTRY,
    LOCALE_SCOUNTRY,
    LOCALE_SENGCOUNTRY,
    LOCALE_SABBREVCTRYNAME,
    LOCALE_SNATIVECTRYNAME,
    LOCALE_IGEOID,

    LOCALE_SSORTNAME,

    LOCALE_IDEFAULTLANGUAGE,
    LOCALE_IDEFAULTCOUNTRY,
    LOCALE_IDEFAULTANSICODEPAGE,
    LOCALE_IDEFAULTCODEPAGE,
    LOCALE_IDEFAULTMACCODEPAGE,
    LOCALE_IDEFAULTEBCDICCODEPAGE,

    LOCALE_SLIST,
    LOCALE_IMEASURE,
    LOCALE_IPAPERSIZE,

    LOCALE_SDECIMAL,
    LOCALE_STHOUSAND,
    LOCALE_SGROUPING,
    LOCALE_IDIGITS,
    LOCALE_ILZERO,
    LOCALE_SNATIVEDIGITS,

    LOCALE_SCURRENCY,
    LOCALE_SINTLSYMBOL,
    LOCALE_SENGCURRNAME,
    LOCALE_SNATIVECURRNAME,
    LOCALE_SMONDECIMALSEP,
    LOCALE_SMONTHOUSANDSEP,
    LOCALE_SMONGROUPING,
    LOCALE_ICURRDIGITS,
    LOCALE_IINTLCURRDIGITS,
    LOCALE_ICURRENCY,
    LOCALE_INEGCURR,
    LOCALE_SPOSITIVESIGN,
    LOCALE_SNEGATIVESIGN,

    LOCALE_IPOSSIGNPOSN,
    LOCALE_INEGSIGNPOSN,
    LOCALE_IPOSSYMPRECEDES,
    LOCALE_IPOSSEPBYSPACE,
    LOCALE_INEGSYMPRECEDES,
    LOCALE_INEGSEPBYSPACE,

    LOCALE_STIMEFORMAT,
    LOCALE_STIME,
    LOCALE_ITIME,
    LOCALE_ITLZERO,
    LOCALE_ITIMEMARKPOSN,
    LOCALE_S1159,
    LOCALE_S2359,

    LOCALE_SSHORTDATE,
    LOCALE_SDATE,
    LOCALE_IDATE,
    LOCALE_ICENTURY,
    LOCALE_IDAYLZERO,
    LOCALE_IMONLZERO,

    LOCALE_SYEARMONTH,
    LOCALE_SLONGDATE,
    LOCALE_ILDATE,

    LOCALE_ICALENDARTYPE,
    LOCALE_IOPTIONALCALENDAR,

    LOCALE_IFIRSTDAYOFWEEK,
    LOCALE_IFIRSTWEEKOFYEAR,

    LOCALE_SDAYNAME1,
    LOCALE_SDAYNAME2,
    LOCALE_SDAYNAME3,
    LOCALE_SDAYNAME4,
    LOCALE_SDAYNAME5,
    LOCALE_SDAYNAME6,
    LOCALE_SDAYNAME7,

    LOCALE_SABBREVDAYNAME1,
    LOCALE_SABBREVDAYNAME2,
    LOCALE_SABBREVDAYNAME3,
    LOCALE_SABBREVDAYNAME4,
    LOCALE_SABBREVDAYNAME5,
    LOCALE_SABBREVDAYNAME6,
    LOCALE_SABBREVDAYNAME7,

    LOCALE_SMONTHNAME1,
    LOCALE_SMONTHNAME2,
    LOCALE_SMONTHNAME3,
    LOCALE_SMONTHNAME4,
    LOCALE_SMONTHNAME5,
    LOCALE_SMONTHNAME6,
    LOCALE_SMONTHNAME7,
    LOCALE_SMONTHNAME8,
    LOCALE_SMONTHNAME9,
    LOCALE_SMONTHNAME10,
    LOCALE_SMONTHNAME11,
    LOCALE_SMONTHNAME12,
    LOCALE_SMONTHNAME13,

    LOCALE_SABBREVMONTHNAME1,
    LOCALE_SABBREVMONTHNAME2,
    LOCALE_SABBREVMONTHNAME3,
    LOCALE_SABBREVMONTHNAME4,
    LOCALE_SABBREVMONTHNAME5,
    LOCALE_SABBREVMONTHNAME6,
    LOCALE_SABBREVMONTHNAME7,
    LOCALE_SABBREVMONTHNAME8,
    LOCALE_SABBREVMONTHNAME9,
    LOCALE_SABBREVMONTHNAME10,
    LOCALE_SABBREVMONTHNAME11,
    LOCALE_SABBREVMONTHNAME12,
    LOCALE_SABBREVMONTHNAME13
};

#define NUM_LOCALE_FLAGS     ( sizeof(pLocaleFlag) / sizeof(LCTYPE) )

LPWSTR pLocaleString[] =
{
    L"0409",
    L"English (United States)",
    L"English",
    L"ENU",
    L"English",

    L"1",
    L"United States",
    L"United States",
    L"USA",
    L"United States",
    L"244",

    L"Default",

    L"0409",
    L"1",
    L"1252",
    L"437",
    L"10000",
    L"037",

    L",",
    L"1",
    L"1",

    L".",
    L",",
    L"3;0",
    L"2",
    L"1",
    L"0123456789",

    L"$",
    L"USD",
    L"US Dollar",
    L"US Dollar",
    L".",
    L",",
    L"3;0",
    L"2",
    L"2",
    L"0",
    L"0",
    L"",
    L"-",

    L"3",
    L"0",
    L"1",
    L"0",
    L"1",
    L"0",

    L"h:mm:ss tt",
    L":",
    L"0",
    L"0",
    L"0",
    L"AM",
    L"PM",

    L"M/d/yyyy",
    L"/",
    L"0",
    L"1",
    L"0",
    L"0",

    L"MMMM, yyyy",
    L"dddd, MMMM dd, yyyy",
    L"0",

    L"1",
    L"0",

    L"6",
    L"0",

    L"Monday",
    L"Tuesday",
    L"Wednesday",
    L"Thursday",
    L"Friday",
    L"Saturday",
    L"Sunday",

    L"Mon",
    L"Tue",
    L"Wed",
    L"Thu",
    L"Fri",
    L"Sat",
    L"Sun",

    L"January",
    L"February",
    L"March",
    L"April",
    L"May",
    L"June",
    L"July",
    L"August",
    L"September",
    L"October",
    L"November",
    L"December",
    L"",

    L"Jan",
    L"Feb",
    L"Mar",
    L"Apr",
    L"May",
    L"Jun",
    L"Jul",
    L"Aug",
    L"Sep",
    L"Oct",
    L"Nov",
    L"Dec",
    L""
};


//
//  pLocaleIntFlag and pLocaleInt must have the same number of entries.
//
LCTYPE pLocaleIntFlag[] =
{
    LOCALE_ILANGUAGE,
    LOCALE_ICOUNTRY,

    LOCALE_IDEFAULTLANGUAGE,
    LOCALE_IDEFAULTCOUNTRY,
    LOCALE_IDEFAULTANSICODEPAGE,
    LOCALE_IDEFAULTCODEPAGE,
    LOCALE_IDEFAULTMACCODEPAGE,
    LOCALE_IGEOID,

    LOCALE_IMEASURE,

    LOCALE_IDIGITS,
    LOCALE_ILZERO,

    LOCALE_ICURRDIGITS,
    LOCALE_IINTLCURRDIGITS,
    LOCALE_ICURRENCY,
    LOCALE_INEGCURR,

    LOCALE_IPOSSIGNPOSN,
    LOCALE_INEGSIGNPOSN,
    LOCALE_IPOSSYMPRECEDES,
    LOCALE_IPOSSEPBYSPACE,
    LOCALE_INEGSYMPRECEDES,
    LOCALE_INEGSEPBYSPACE,

    LOCALE_ITIME,
    LOCALE_ITLZERO,
    LOCALE_ITIMEMARKPOSN,

    LOCALE_IDATE,
    LOCALE_ICENTURY,
    LOCALE_IDAYLZERO,
    LOCALE_IMONLZERO,
    LOCALE_ILDATE,

    LOCALE_ICALENDARTYPE,
    LOCALE_IOPTIONALCALENDAR,

    LOCALE_IFIRSTDAYOFWEEK,
    LOCALE_IFIRSTWEEKOFYEAR
};

#define NUM_LOCALE_INT_FLAGS ( sizeof(pLocaleIntFlag) / sizeof(LCTYPE) )

DWORD pLocaleInt[] =
{
    0x0409,
    1,

    0x0409,
    1,
    1252,
    437,
    10000,
    244,

    1,

    2,
    1,

    2,
    2,
    0,
    0,

    3,
    0,
    1,
    0,
    1,
    0,

    0,
    0,
    0,

    0,
    1,
    0,
    0,
    0,

    1,
    0,

    6,
    0
};




//
//  Forward Declarations.
//

BOOL
InitGetLocInfo();

int
GLI_BadParamCheck();

int
GLI_NormalCase();

int
GLI_Ansi();

int
VER_NormalCase();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetLocaleInfo
//
//  Test routine for GetLocaleInfoW API.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetLocaleInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetLocaleInfoW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetLocInfo())
    {
        printf("\nABORTED TestGetLocaleInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GLI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GLI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GLI_Ansi();

    //
    //  Test Version Routines.
    //
    ErrCount += VER_NormalCase();

    //
    //  Print out result.
    //
    printf("\nGetLocaleInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetLocInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetLocInfo()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);


    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GLI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GLI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetLocaleInfoW( (LCID)333,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpLCData = NULL
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         NULL,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpLCData NULL",
                         &NumErrors );


    //
    //  Bad Counts.
    //

    //  Variation 1  -  cbBuf < 0
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cbBuf < 0",
                         &NumErrors );


    //
    //  Zero or Invalid Type.
    //

    //  Variation 1  -  LCType = invalid
    rc = GetLocaleInfoW( Locale,
                         LCTYPE_INVALID,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "LCType invalid",
                         &NumErrors );

    //  Variation 2  -  LCType = 0
    rc = GetLocaleInfoW( Locale,
                         0,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "LCType zero",
                         &NumErrors );

    //  Variation 3  -  Use CP ACP, LCType = invalid
    rc = GetLocaleInfoW( Locale,
                         LOCALE_USE_CP_ACP | LCTYPE_INVALID,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, LCType invalid",
                         &NumErrors );



    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cbBuf = too small
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cbBuf too small",
                         &NumErrors );


    //
    //  Bad locale - Not valid in RC file.
    //
    //  Variation 1  -  SLANGUAGE - invalid
    rc = GetLocaleInfoW( LANG_INVALID,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "invalid locale - invalid",
                         &NumErrors );


    //
    //  RETURN_NUMBER flag.
    //
    //  Variation 1  -  invalid flags
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_SLANGUAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "invalid flags - RETURN_NUMBER",
                         &NumErrors );

    //  Variation 2  -  insufficent buffer
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_ILANGUAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "insufficient buffer 1 - RETURN_NUMBER",
                         &NumErrors );

    //  Variation 3  -  insufficent buffer
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "insufficient buffer 2 - RETURN_NUMBER",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GLI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GLI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "system default locale",
                      &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetLocaleInfoW( LOCALE_USER_DEFAULT,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "current user locale",
                      &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = GetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_USE_CP_ACP | LOCALE_ILANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "Use CP ACP, system default locale",
                      &NumErrors );


    //
    //  cbBuf.
    //

    //  Variation 1  -  cbBuf = size of lpLCData buffer
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_ILANGUAGE,
                       "cbBuf = bufsize",
                       &NumErrors );

    //  Variation 2  -  cbBuf = 0
    lpLCData[0] = 0x0000;
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         lpLCData,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       S_ILANGUAGE,
                       "cbBuf zero",
                       &NumErrors );

    //  Variation 3  -  cbBuf = 0, lpLCData = NULL
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILANGUAGE,
                         NULL,
                         0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       S_ILANGUAGE,
                       "cbBuf (NULL ptr)",
                       &NumErrors );


    //
    //  LCTYPE values.
    //

    for (ctr = 0; ctr < NUM_LOCALE_FLAGS; ctr++)
    {
        rc = GetLocaleInfoW( Locale,
                             pLocaleFlag[ctr],
                             lpLCData,
                             BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpLCData,
                               pLocaleString[ctr],
                               "Locale Flag",
                               pLocaleFlag[ctr],
                               &NumErrors );
    }


    //
    //  RC file - SLANGUAGE and SCOUNTRY.
    //

    //  Variation 1  -  SLANGUAGE - Czech
    rc = GetLocaleInfoW( 0x0405,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Czech",
                       "SLANGUAGE (Czech)",
                       &NumErrors );

    //  Variation 2  -  SCOUNTRY - Czech
    rc = GetLocaleInfoW( 0x0405,
                         LOCALE_SCOUNTRY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Czech Republic",
                       "SCOUNTRY (Czech)",
                       &NumErrors );

    //  Variation 3  -  SCOUNTRY - Slovak
    rc = GetLocaleInfoW( 0x041B,
                         LOCALE_SCOUNTRY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Slovakia",
                       "SCOUNTRY (Slovak)",
                       &NumErrors );

    //  Variation 4  -  SENGCOUNTRY - Czech
    rc = GetLocaleInfoW( 0x0405,
                         LOCALE_SENGCOUNTRY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Czech Republic",
                       "SENGCOUNTRY (Czech)",
                       &NumErrors );

    //  Variation 5  -  SENGCOUNTRY - Slovak
    rc = GetLocaleInfoW( 0x041B,
                         LOCALE_SENGCOUNTRY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Slovakia",
                       "SENGCOUNTRY (Slovak)",
                       &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  SLANGUAGE - neutral
    rc = GetLocaleInfoW( 0x0000,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SLANGUAGE,
                       "SLANGUAGE (neutral)",
                       &NumErrors );

    //  Variation 2  -  SLANGUAGE - sys default
    rc = GetLocaleInfoW( 0x0400,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SLANGUAGE,
                       "SLANGUAGE (sys default)",
                       &NumErrors );

    //  Variation 3  -  SLANGUAGE - user default
    rc = GetLocaleInfoW( 0x0800,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SLANGUAGE,
                       "SLANGUAGE (user default)",
                       &NumErrors );

    //  Variation 4  -  SLANGUAGE - sub lang neutral US
    rc = GetLocaleInfoW( 0x0009,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SLANGUAGE,
                       "SLANGUAGE (sub lang neutral US)",
                       &NumErrors );

    //  Variation 5  -  SLANGUAGE - sub lang neutral Czech
    rc = GetLocaleInfoW( 0x0005,
                         LOCALE_SLANGUAGE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Czech",
                       "SLANGUAGE (sub lang neutral Czech)",
                       &NumErrors );



    //
    //  Test Russian Month Names.
    //
    //  Variation 1  -  SMONTHNAME1
    rc = GetLocaleInfoW( 0x0419,
                         LOCALE_SMONTHNAME1,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SMONTHNAME1_RUSSIAN,
                       "Russian SMONTHNAME1",
                       &NumErrors );

    //  Variation 2  -  SMONTHNAME2
    rc = GetLocaleInfoW( 0x0419,
                         LOCALE_SMONTHNAME2,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       S_SMONTHNAME2_RUSSIAN,
                       "Russian SMONTHNAME2",
                       &NumErrors );



    //
    //  Test Font Signature.
    //
    //  Variation 1  -  FONTSIGNATURE
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_FONTSIGNATURE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       16,
                       lpLCData,
                       FONTSIG_ENGLISH,
                       "English FONTSIGNATURE",
                       &NumErrors );

    //  Variation 2  -  FONTSIGNATURE
    rc = GetLocaleInfoW( 0x0419,
                         LOCALE_FONTSIGNATURE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       16,
                       lpLCData,
                       FONTSIG_RUSSIAN,
                       "Russian FONTSIGNATURE",
                       &NumErrors );



    //
    //  Test Return Number flag.
    //
    //  Variation 1  -  RETURN_NUMBER
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         2,
                         *((LPDWORD)lpLCData),
                         1252,
                         "Return_Number - ansi codepage for 0x0409",
                         &NumErrors );

    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         2,
                         1252,
                         1252,
                         "Return_Number - ansi codepage for 0x0409 (no cchData)",
                         &NumErrors );

    //  Variation 2  -  RETURN_NUMBER
    rc = GetLocaleInfoW( 0x041f,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         2,
                         *((LPDWORD)lpLCData),
                         1254,
                         "Return_Number - ansi codepage for 0x041f",
                         &NumErrors );

    rc = GetLocaleInfoW( 0x041f,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         2,
                         1254,
                         1254,
                         "Return_Number - ansi codepage for 0x041f (no cchData)",
                         &NumErrors );

    //  Variation 3  -  RETURN_NUMBER
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_ILANGUAGE | LOCALE_RETURN_NUMBER,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         2,
                         *((LPDWORD)lpLCData),
                         0x0409,
                         "Return_Number - iLanguage",
                         &NumErrors );

    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_ILANGUAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         2,
                         0x0409,
                         0x0409,
                         "Return_Number - iLanguage (no cchData)",
                         &NumErrors );


    //
    //   Try all INT flags with LOCALE_RETURN_NUMBER flag.
    //
    for (ctr = 0; ctr < NUM_LOCALE_INT_FLAGS; ctr++)
    {
        rc = GetLocaleInfoW( 0x0409,
                             pLocaleIntFlag[ctr] | LOCALE_RETURN_NUMBER,
                             lpLCData,
                             BUFSIZE );
        CheckReturnValidInt( rc,
                             2,
                             *((LPDWORD)lpLCData),
                             pLocaleInt[ctr],
                             "Locale Int Flag",
                             &NumErrors );
    }



    //
    //  Test SSORTNAME.
    //
    //  Variation 1  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00000407,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Dictionary",
                       "SSORTNAME 0x00000407",
                       &NumErrors );

    //  Variation 2  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00010407,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Phone Book (DIN)",
                       "SSORTNAME 0x00010407",
                       &NumErrors );

    //  Variation 3  -  SSORTNAME
    rc = GetLocaleInfoW( 0x0000040a,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Traditional",
                       "SSORTNAME 0x0000040a",
                       &NumErrors );

    //  Variation 4  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00000c0a,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"International",
                       "SSORTNAME 0x00000c0a",
                       &NumErrors );

    //  Variation 5  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00000404,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Stroke Count",
                       "SSORTNAME 0x00000404",
                       &NumErrors );

    //  Variation 7  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00020404,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "SSORTNAME 0x00020404",
                         &NumErrors );

    //  Variation 8  -  SSORTNAME
    rc = GetLocaleInfoW( 0x00000804,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Pronunciation",
                       "SSORTNAME 0x00000804",
                       &NumErrors );

    //  Variation 10 -  SSORTNAME
    rc = GetLocaleInfoW( 0x00020804,
                         LOCALE_SSORTNAME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"Stroke Count",
                       "SSORTNAME 0x00020804",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GLI_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GLI_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


    //
    //  GetLocaleInfoA.
    //

    //  Variation 1  -  ILANGUAGE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_ILANGUAGE,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "0409",
                       NULL,
                       "A version ILANGUAGE",
                       &NumErrors );

    //  Variation 2  -  ILANGUAGE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_ILANGUAGE,
                         NULL,
                         0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "0409",
                       NULL,
                       "A version ILANGUAGE, no Dest",
                       &NumErrors );

    //  Variation 3  -  ILANGUAGE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_ILANGUAGE,
                         NULL,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version bad lpLCData",
                         &NumErrors );

    //  Variation 4  -  SSHORTDATE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_SSHORTDATE,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "M/d/yyyy",
                       NULL,
                       "A version SSHORTDATE",
                       &NumErrors );

    //  Variation 5  -  SSHORTDATE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_SSHORTDATE,
                         NULL,
                         0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "M/d/yyyy",
                       NULL,
                       "A version SSHORTDATE, no Dest",
                       &NumErrors );




    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, ILANGUAGE
    rc = GetLocaleInfoA( Locale,
                         LOCALE_USE_CP_ACP | LOCALE_ILANGUAGE,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "0409",
                       NULL,
                       "A version Use CP ACP, ILANGUAGE",
                       &NumErrors );


    //
    //  Make sure the A and W versions set the same error value.
    //

    SetLastError( 0 );
    rc = GetLocaleInfoA( Locale,
                         LOCALE_SLIST,
                         lpLCDataA,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W error returns same - A version",
                         &NumErrors );

    SetLastError( 0 );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         lpLCData,
                         -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A and W error returns same - W version",
                         &NumErrors );


    //
    //  Test Font Signature.
    //
    //  Variation 1  -  FONTSIGNATURE
    rc = GetLocaleInfoA( 0x0409,
                         LOCALE_FONTSIGNATURE,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       32,
                       lpLCDataA,
                       FONTSIG_ENGLISH_A,
                       NULL,
                       "A Version English FONTSIGNATURE",
                       &NumErrors );

    //  Variation 2  -  FONTSIGNATURE
    rc = GetLocaleInfoA( 0x0419,
                         LOCALE_FONTSIGNATURE,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       32,
                       lpLCDataA,
                       FONTSIG_RUSSIAN_A,
                       NULL,
                       "A Version Russian FONTSIGNATURE",
                       &NumErrors );


    //
    //  Test Return Number flag.
    //
    //  Variation 1  -  RETURN_NUMBER
    rc = GetLocaleInfoA( 0x0409,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         4,
                         *((LPDWORD)lpLCDataA),
                         1252,
                         "A Version Return_Number - ansi codepage for 0x0409",
                         &NumErrors );

    rc = GetLocaleInfoA( 0x0409,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         4,
                         1252,
                         1252,
                         "A Version Return_Number - ansi codepage for 0x0409 (no cchData)",
                         &NumErrors );

    //  Variation 2  -  RETURN_NUMBER
    rc = GetLocaleInfoA( 0x041f,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         4,
                         *((LPDWORD)lpLCDataA),
                         1254,
                         "A Version Return_Number - ansi codepage for 0x041f",
                         &NumErrors );

    rc = GetLocaleInfoA( 0x041f,
                         LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         4,
                         1254,
                         1254,
                         "A Version Return_Number - ansi codepage for 0x041f (no cchData)",
                         &NumErrors );

    //  Variation 3  -  RETURN_NUMBER
    rc = GetLocaleInfoA( 0x0409,
                         LOCALE_ILANGUAGE | LOCALE_RETURN_NUMBER,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidInt( rc,
                         4,
                         *((LPDWORD)lpLCDataA),
                         0x0409,
                         "A Version Return_Number - iLanguage",
                         &NumErrors );

    rc = GetLocaleInfoA( 0x0409,
                         LOCALE_ILANGUAGE | LOCALE_RETURN_NUMBER,
                         NULL,
                         0 );
    CheckReturnValidInt( rc,
                         4,
                         0x0409,
                         0x0409,
                         "A Version Return_Number - iLanguage (no cchData)",
                         &NumErrors );



    //
    //   Try all INT flags with LOCALE_RETURN_NUMBER flag.
    //
    for (ctr = 0; ctr < NUM_LOCALE_INT_FLAGS; ctr++)
    {
        rc = GetLocaleInfoA( 0x0409,
                             pLocaleIntFlag[ctr] | LOCALE_RETURN_NUMBER,
                             lpLCDataA,
                             BUFSIZE );
        CheckReturnValidInt( rc,
                             4,
                             *((LPDWORD)lpLCDataA),
                             pLocaleInt[ctr],
                             "A Version Locale Int Flag",
                             &NumErrors );
    }



    //
    //  Test SSORTNAME.
    //
    //  Variation 1  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00000407,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Dictionary",
                       NULL,
                       "A version SSORTNAME 0x00000407",
                       &NumErrors );

    //  Variation 2  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00010407,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Phone Book (DIN)",
                       NULL,
                       "A version SSORTNAME 0x00010407",
                       &NumErrors );

    //  Variation 3  -  SSORTNAME
    rc = GetLocaleInfoA( 0x0000040a,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Traditional",
                       NULL,
                       "A version SSORTNAME 0x0000040a",
                       &NumErrors );

    //  Variation 4  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00000c0a,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "International",
                       NULL,
                       "A version SSORTNAME 0x00000c0a",
                       &NumErrors );

    //  Variation 5  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00000404,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Stroke Count",
                       NULL,
                       "A version SSORTNAME 0x00000404",
                       &NumErrors );

    //  Variation 7  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00020404,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version SSORTNAME 0x00020404",
                         &NumErrors );

    //  Variation 8  -  SSORTNAME
    rc = GetLocaleInfoA( 0x00000804,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Pronunciation",
                       NULL,
                       "A version SSORTNAME 0x00000804",
                       &NumErrors );

    //  Variation 10 -  SSORTNAME
    rc = GetLocaleInfoA( 0x00020804,
                         LOCALE_SSORTNAME,
                         lpLCDataA,
                         BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       lpLCDataA,
                       "Stroke Count",
                       NULL,
                       "A version SSORTNAME 0x00020804",
                       &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  VER_NormalCase
//
//  This routine tests the normal cases of the VERSION API routines.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int VER_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE pVersionA[BUFSIZE];      // byte buffer for string
    WCHAR pVersionW[BUFSIZE];     // word buffer for string


    //
    //  VerLanguageNameW
    //

    //  Variation 1  -  U.S.
    rc = VerLanguageNameW( 0x0409,
                           pVersionW,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       23,
                       pVersionW,
                       L"English (United States)",
                       "VerLanguageNameW (US)",
                       &NumErrors );

    //  Variation 2  -  Czech
    rc = VerLanguageNameW( 0x0405,
                           pVersionW,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       5,
                       pVersionW,
                       L"Czech",
                       "VerLanguageNameW (Czech)",
                       &NumErrors );


    //
    //  VerLanguageNameA
    //

    //  Variation 1  -  U.S.
    rc = VerLanguageNameA( 0x0409,
                           pVersionA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       23,
                       pVersionA,
                       "English (United States)",
                       NULL,
                       "VerLanguageNameA (US)",
                       &NumErrors );

    //  Variation 2  -  Czech
    rc = VerLanguageNameA( 0x0405,
                           pVersionA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       5,
                       pVersionA,
                       "Czech",
                       NULL,
                       "VerLanguageNameA (Czech)",
                       &NumErrors );


    //
    //  Bad locale - Not valid in RC file.
    //

    //  Variation 1  -  SLANGUAGE - invalid (W)
    rc = VerLanguageNameW( LANG_INVALID,
                           pVersionW,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       16,
                       pVersionW,
                       L"Language Neutral",
                       "VerLanguageNameW (invalid)",
                       &NumErrors );

    //  Variation 2  -  SLANGUAGE - invalid (A)
    rc = VerLanguageNameA( LANG_INVALID,
                           pVersionA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       16,
                       pVersionA,
                       "Language Neutral",
                       NULL,
                       "VerLanguageNameA (invalid)",
                       &NumErrors );


    //
    //  Invalid parameters.
    //

    //  Variation 1  -  wSize - invalid (W)
    pVersionW[0] = 0;
    rc = VerLanguageNameW( 0x0409,
                           pVersionW,
                           0 );
    CheckReturnValidW( rc,
                       0,
                       NULL,
                       NULL,
                       "VerLanguageNameW (invalid size)",
                       &NumErrors );

    //  Variation 2  -  wSize - invalid (A)
    pVersionA[0] = 0;
    rc = VerLanguageNameA( 0x0409,
                           pVersionA,
                           0 );
    CheckReturnValidA( rc,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       "VerLanguageNameA (invalid size)",
                       &NumErrors );

    //  Variation 3  - szLang - invalid (W)
    rc = VerLanguageNameW( 0x0409,
                           NULL,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       0,
                       NULL,
                       NULL,
                       "VerLanguageNameW (invalid buffer)",
                       &NumErrors );

    //  Variation 4  -  szLang - invalid (A)
    pVersionA[0] = 0;
    rc = VerLanguageNameA( 0x0409,
                           NULL,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       "VerLanguageNameA (invalid buffer)",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\gnftest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    gnftest.c

Abstract:

    Test module for NLS API GetNumberFormat.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    07-28-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE             500            // buffer size in wide chars
#define  GNF_INVALID_FLAGS   ((DWORD)(~(LOCALE_NOUSEROVERRIDE)))

#define  GNF_ENGLISH_US      L"1,234,567.44"
#define  GNF_CZECH           L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44"




//
//  Global Variables.
//

LCID Locale;

LPWSTR pValue;
LPWSTR pNegValue;

NUMBERFMT NumFmt;

WCHAR lpNumberStr[BUFSIZE];


//
//  Number format buffers must be in line with the pAllLocales global
//  buffer.
//
LPWSTR pPosNumber[] =
{
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0402
    L"1,234,567.44",                                            //  0x0404
    L"1,234,567.44",                                            //  0x0804
    L"1,234,567.44",                                            //  0x0c04
    L"1,234,567.44",                                            //  0x1004
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0405
    L"1.234.567,44",                                            //  0x0406
    L"1.234.567,44",                                            //  0x0407
    L"1'234'567.44",                                            //  0x0807
    L"1.234.567,44",                                            //  0x0c07
    L"1.234.567,44",                                            //  0x0408
    L"1,234,567.44",                                            //  0x0409
    L"1,234,567.44",                                            //  0x0809
    L"1,234,567.44",                                            //  0x0c09
    L"1,234,567.44",                                            //  0x1009
    L"1,234,567.44",                                            //  0x1409
    L"1,234,567.44",                                            //  0x1809
    L"1.234.567,44",                                            //  0x040a
    L"1,234,567.44",                                            //  0x080a
    L"1.234.567,44",                                            //  0x0c0a
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x040b
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x040c
    L"1.234.567,44",                                            //  0x080c
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0c0c
    L"1'234'567.44",                                            //  0x100c
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x040e
    L"1.234.567,44",                                            //  0x040f
    L"1.234.567,44",                                            //  0x0410
    L"1'234'567.44",                                            //  0x0810
    L"1,234,567.44",                                            //  0x0411
    L"1,234,567.44",                                            //  0x0412
    L"1.234.567,44",                                            //  0x0413
    L"1.234.567,44",                                            //  0x0813
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0414
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0814
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0415
    L"1.234.567,44",                                            //  0x0416
    L"1.234.567,44",                                            //  0x0816
    L"1.234.567,44",                                            //  0x0418
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x0419
    L"1.234.567,44",                                            //  0x041a
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x041b
    L"1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",    //  0x041d
    L"1.234.567,44",                                            //  0x041f
    L"1.234.567,44"                                             //  0x0424
};

LPWSTR pNegNumber[] =
{
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0402
    L"-1,234,567.44",                                           //  0x0404
    L"-1,234,567.44",                                           //  0x0804
    L"-1,234,567.44",                                           //  0x0c04
    L"-1,234,567.44",                                           //  0x1004
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0405
    L"-1.234.567,44",                                           //  0x0406
    L"-1.234.567,44",                                           //  0x0407
    L"-1'234'567.44",                                           //  0x0807
    L"-1.234.567,44",                                           //  0x0c07
    L"-1.234.567,44",                                           //  0x0408
    L"-1,234,567.44",                                           //  0x0409
    L"-1,234,567.44",                                           //  0x0809
    L"-1,234,567.44",                                           //  0x0c09
    L"-1,234,567.44",                                           //  0x1009
    L"-1,234,567.44",                                           //  0x1409
    L"-1,234,567.44",                                           //  0x1809
    L"-1.234.567,44",                                           //  0x040a
    L"-1,234,567.44",                                           //  0x080a
    L"-1.234.567,44",                                           //  0x0c0a
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x040b
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x040c
    L"-1.234.567,44",                                           //  0x080c
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0c0c
    L"-1'234'567.44",                                           //  0x100c
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x040e
    L"-1.234.567,44",                                           //  0x040f
    L"-1.234.567,44",                                           //  0x0410
    L"-1'234'567.44",                                           //  0x0810
    L"-1,234,567.44",                                           //  0x0411
    L"-1,234,567.44",                                           //  0x0412
    L"-1.234.567,44",                                           //  0x0413
    L"-1.234.567,44",                                           //  0x0813
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0414
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0814
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0415
    L"-1.234.567,44",                                           //  0x0416
    L"-1.234.567,44",                                           //  0x0816
    L"-1.234.567,44",                                           //  0x0418
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x0419
    L"- 1.234.567,44",                                          //  0x041a
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x041b
    L"-1\x00a0\x0032\x0033\x0034\x00a0\x0035\x0036\x0037,44",   //  0x041d
    L"-1.234.567,44",                                           //  0x041f
    L"-1.234.567,44"                                            //  0x0424
};




//
//  Forward Declarations.
//

BOOL
InitGetNumberFormat();

int
GNF_BadParamCheck();

int
GNF_NormalCase();

int
GNF_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestGetNumberFormat
//
//  Test routine for GetNumberFormatW API.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestGetNumberFormat()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING GetNumberFormatW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitGetNumberFormat())
    {
        printf("\nABORTED TestGetNumberFormat: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += GNF_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += GNF_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += GNF_Ansi();

    //
    //  Print out result.
    //
    printf("\nGetNumberFormatW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitGetNumberFormat
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitGetNumberFormat()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Initialize the value.
    //
    pValue = L"1234567.4444";
    pNegValue = L"-1234567.4444";

    //
    //  Initialize the number format structure.
    //
    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 3;
    NumFmt.lpDecimalSep = L"/";
    NumFmt.lpThousandSep = L";";
    NumFmt.NegativeOrder = 1;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GNF_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GNF_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    NUMBERFMT MyNumFmt;           // number format


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = GetNumberFormatW( (LCID)333,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpNumberStr = NULL
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           NULL,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpNumberStr NULL",
                         &NumErrors );

    //  Variation 2  -  lpValue = NULL
    rc = GetNumberFormatW( Locale,
                           0,
                           NULL,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpNumberStr NULL",
                         &NumErrors );


    //
    //  Bad Count.
    //

    //  Variation 1  -  cchNumber < 0
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           -1 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "cchNumber < 0",
                         &NumErrors );


    //
    //  Invalid Flag.
    //

    //  Variation 1  -  dwFlags = invalid
    rc = GetNumberFormatW( Locale,
                           GNF_INVALID_FLAGS,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Flag invalid",
                         &NumErrors );

    //  Variation 2  -  lpFormat and NoUserOverride
    rc = GetNumberFormatW( Locale,
                           LOCALE_NOUSEROVERRIDE,
                           pValue,
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "lpFormat and NoUserOverride",
                         &NumErrors );

    //  Variation 3  -  Use CP ACP, lpFormat and NoUserOverride
    rc = GetNumberFormatW( Locale,
                           LOCALE_USE_CP_ACP | LOCALE_NOUSEROVERRIDE,
                           pValue,
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, lpFormat and NoUserOverride",
                         &NumErrors );


    //
    //  Buffer Too Small.
    //

    //  Variation 1  -  cchNumber = too small
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           2 );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INSUFFICIENT_BUFFER,
                         "cchNumber too small",
                         &NumErrors );


    //
    //  Bad format passed in.
    //

    //  Variation 1  -  bad NumDigits
    MyNumFmt.NumDigits = 10;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad NumDigits",
                         &NumErrors );

    //  Variation 2  -  bad LeadingZero
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 2;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad LeadingZero",
                         &NumErrors );

    //  Variation 3  -  bad Grouping
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 10000;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad Grouping",
                         &NumErrors );

    //  Variation 4  -  bad DecimalSep
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = NULL;
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep",
                         &NumErrors );

    //  Variation 5  -  bad DecimalSep 2
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"////";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep 2",
                         &NumErrors );

    //  Variation 6  -  bad DecimalSep 3
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"6";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad DecimalSep 3",
                         &NumErrors );

    //  Variation 7  -  bad ThousandSep
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = NULL;
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep",
                         &NumErrors );

    //  Variation 8  -  bad ThousandSep 2
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L";;;;";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep 2",
                         &NumErrors );

    //  Variation 9  -  bad ThousandSep 3
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L"6";
    MyNumFmt.NegativeOrder = 1;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad ThousandSep 3",
                         &NumErrors );

    //  Variation 10  -  bad negative order
    MyNumFmt.NumDigits = 3;
    MyNumFmt.LeadingZero = 1;
    MyNumFmt.Grouping = 3;
    MyNumFmt.lpDecimalSep = L"/";
    MyNumFmt.lpThousandSep = L";";
    MyNumFmt.NegativeOrder = 5;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           &MyNumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "bad negative order",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GNF_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GNF_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    int ctr;                      // loop counter


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = GetNumberFormatW( LOCALE_SYSTEM_DEFAULT,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "sys default locale",
                       &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = GetNumberFormatW( LOCALE_USER_DEFAULT,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "current user locale",
                       &NumErrors );


    //
    //  Language Neutral.
    //

    //  Variation 1  -  neutral
    rc = GetNumberFormatW( 0x0000,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "neutral locale",
                       &NumErrors );

    //  Variation 2  -  sys default
    rc = GetNumberFormatW( 0x0400,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "sys default locale",
                       &NumErrors );

    //  Variation 3  -  user default
    rc = GetNumberFormatW( 0x0800,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "user default locale",
                       &NumErrors );

    //  Variation 4  -  sub lang neutral US
    rc = GetNumberFormatW( 0x0009,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "sub lang neutral US",
                       &NumErrors );

    //  Variation 5  -  sub lang neutral Czech
    rc = GetNumberFormatW( 0x0005,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_CZECH,
                       "sub lang neutral Czech",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = GetNumberFormatW( LOCALE_SYSTEM_DEFAULT,
                           LOCALE_USE_CP_ACP,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "Use CP ACP, sys default locale",
                       &NumErrors );


    //
    //  cchNumber.
    //

    //  Variation 1  -  cchNumber = size of lpNumberStr buffer
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "cchNumber = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchNumber = 0
    lpNumberStr[0] = 0x0000;
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           lpNumberStr,
                           0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       GNF_ENGLISH_US,
                       "cchNumber zero",
                       &NumErrors );

    //  Variation 3  -  cchNumber = 0, lpNumberStr = NULL
    rc = GetNumberFormatW( Locale,
                           0,
                           pValue,
                           NULL,
                           NULL,
                           0 );
    CheckReturnValidW( rc,
                       -1,
                       NULL,
                       GNF_ENGLISH_US,
                       "cchNumber (NULL ptr)",
                       &NumErrors );


    //
    //  lpFormat - pValue = 1234567.4444
    //
    //      NumFmt.NumDigits = 3;
    //      NumFmt.LeadingZero = 1;
    //      NumFmt.Grouping = 3;
    //      NumFmt.lpDecimalSep = L"/";
    //      NumFmt.lpThousandSep = L";";
    //      NumFmt.NegativeOrder = 1;
    //

    //  Variation 1  -  lpFormat
    rc = GetNumberFormatW( 0x0409,
                           0,
                           pValue,
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1;234;567/444",
                       "lpFormat (1;234;567/444)",
                       &NumErrors );

    //  Variation 2  -  lpFormat leading zero
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".4444",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"0/444",
                       "lpFormat (0/444)",
                       &NumErrors );

    //  Variation 3  -  lpFormat no decimal
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"1234567",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1;234;567/000",
                       "lpFormat (1;234;567/000)",
                       &NumErrors );

    //  Variation 4  -  grouping check
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"123456",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"123;456/000",
                       "lpFormat (123;456/000)",
                       &NumErrors );

    //  Variation 5  -  grouping check
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"12",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"12/000",
                       "grouping (12/000)",
                       &NumErrors );

    //  Variation 6  -  rounding check
    NumFmt.NumDigits = 0;
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1",
                       "rounding (1)",
                       &NumErrors );
    NumFmt.NumDigits = 3;

    //  Variation 7  -  rounding check
    NumFmt.NumDigits = 0;
    NumFmt.LeadingZero = 0;
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1",
                       "rounding (1) 2",
                       &NumErrors );
    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;

    //  Variation 8  -  rounding check
    NumFmt.NumDigits = 0;
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".4999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"0",
                       "rounding (0)",
                       &NumErrors );
    NumFmt.NumDigits = 3;

    //  Variation 9  -  rounding check
    NumFmt.NumDigits = 0;
    NumFmt.LeadingZero = 0;
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".4999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"0",
                       "rounding (0) 2",
                       &NumErrors );
    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;

    //  Variation 10  -  strip leading zeros
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"000000034.5",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"34/500",
                       "strip zeros (34/500)",
                       &NumErrors );

    //  Variation 11  -  neg zero value
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-0.0001",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"0/000",
                       "neg zero (0/000)",
                       &NumErrors );

    //  Variation 12  -  neg zero value
    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-0.0009",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-0/001",
                       "neg zero (-0/001)",
                       &NumErrors );


    //
    //  Flag values.
    //

    //  Variation 1  -  NOUSEROVERRIDE
    rc = GetNumberFormatW( Locale,
                           LOCALE_NOUSEROVERRIDE,
                           pValue,
                           NULL,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       GNF_ENGLISH_US,
                       "NoUserOverride",
                       &NumErrors );


    //
    //  Test all locales - pValue = 1234567.4444
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetNumberFormatW( pAllLocales[ctr],
                               0,
                               pValue,
                               NULL,
                               lpNumberStr,
                               BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpNumberStr,
                               pPosNumber[ctr],
                               "Pos",
                               pAllLocales[ctr],
                               &NumErrors );
    }


    //
    //  Test all locales - pNegValue = -1234567.4444
    //

    for (ctr = 0; ctr < NumLocales; ctr++)
    {
        rc = GetNumberFormatW( pAllLocales[ctr],
                               0,
                               pNegValue,
                               NULL,
                               lpNumberStr,
                               BUFSIZE );
        CheckReturnValidLoopW( rc,
                               -1,
                               lpNumberStr,
                               pNegNumber[ctr],
                               "Neg",
                               pAllLocales[ctr],
                               &NumErrors );
    }



    //
    //  Special case checks.
    //

    //  Variation 1  -  rounding check

    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 0;
    NumFmt.lpDecimalSep = L".";
    NumFmt.lpThousandSep = L",";
    NumFmt.NegativeOrder = 1;

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"799.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"800.000",
                       "rounding (800.000)",
                       &NumErrors );

    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 2;
    NumFmt.lpDecimalSep = L".";
    NumFmt.lpThousandSep = L",";
    NumFmt.NegativeOrder = 1;

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"799.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"8,00.000",
                       "rounding (8,00.000)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-799.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-8,00.000",
                       "rounding (-8,00.000)",
                       &NumErrors );


    //  Variation 2  -  rounding check

    NumFmt.NumDigits = 0 ;
    NumFmt.LeadingZero = 1 ;
    NumFmt.Grouping = 2 ;
    NumFmt.lpDecimalSep = L"." ;
    NumFmt.lpThousandSep = L"," ;
    NumFmt.NegativeOrder = 1 ;

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"9.500",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"10",
                       "rounding (10)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-9.500",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-10",
                       "rounding (-10)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"99.500",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1,00",
                       "rounding (1,00)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-99.500",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-1,00",
                       "rounding (-1,00)",
                       &NumErrors );


    //  Variation 3  -  rounding check

    NumFmt.NumDigits = 2;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 3;
    NumFmt.NegativeOrder = 1;
    NumFmt.lpDecimalSep = L"/";
    NumFmt.lpThousandSep = L";";

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"1.3",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1/30",
                       "rounding (1/30)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"1.399",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1/40",
                       "rounding (1/40)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"0.999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1/00",
                       "rounding (1/00)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1/00",
                       "rounding (1/00) 2",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-1.3",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-1/30",
                       "rounding (-1/30)",
                       &NumErrors );



    //
    //  Variation 4 - rounding check
    //

    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 0;
    NumFmt.Grouping = 2;
    NumFmt.NegativeOrder = 1;
    NumFmt.lpDecimalSep = L".";
    NumFmt.lpThousandSep = L",";

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L".9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1.000",
                       "rounding (1.000)",
                       &NumErrors );


    //  Variation 5  -  grouping check

    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 32;
    NumFmt.lpDecimalSep = L".";
    NumFmt.lpThousandSep = L",";
    NumFmt.NegativeOrder = 1;

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"1234567.999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"12,34,567.999",
                       "grouping (12,34,567.999)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-1234567.999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-12,34,567.999",
                       "grouping (-12,34,567.999)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"9999999.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1,00,00,000.000",
                       "grouping/rounding (1,00,00,000.000)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-9999999.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-1,00,00,000.000",
                       "grouping/rounding (-1,00,00,000.000)",
                       &NumErrors );


    //  Variation 6  -  grouping check

    NumFmt.NumDigits = 3;
    NumFmt.LeadingZero = 1;
    NumFmt.Grouping = 320;
    NumFmt.lpDecimalSep = L".";
    NumFmt.lpThousandSep = L",";
    NumFmt.NegativeOrder = 1;

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"123456789.999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"1234,56,789.999",
                       "grouping (1234,56789.999)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-123456789.999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-1234,56,789.999",
                       "grouping (-1234,56,789.999)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"9999999.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"100,00,000.000",
                       "grouping/rounding (100,00,000.000)",
                       &NumErrors );

    rc = GetNumberFormatW( 0x0409,
                           0,
                           L"-9999999.9999",
                           &NumFmt,
                           lpNumberStr,
                           BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"-100,00,000.000",
                       "grouping/rounding (-100,00,000.000)",
                       &NumErrors );


    //  Variation 7  -  large number check

    SetLastError(0);
    rc = GetNumberFormat( LOCALE_USER_DEFAULT,
                          0,
                          L"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                          NULL,
                          lpNumberStr,
                          BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpNumberStr,
                       L"10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000.00",
                       "big number",
                       &NumErrors );
    CheckLastError( 0,
                    "Last Error should be 0 - call should have succeeded",
                    &NumErrors );



    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  GNF_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  07-28-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int GNF_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code
    BYTE pNumStrA[BUFSIZE];       // ptr to number string buffer
    NUMBERFMTA NumFmtA;           // number format structure


    //
    //  GetNumberFormatA.
    //

    //  Variation 1  -  cchNumber = size of lpNumberStr buffer
    rc = GetNumberFormatA( Locale,
                           0,
                           "123456.789",
                           NULL,
                           pNumStrA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pNumStrA,
                       "123,456.79",
                       NULL,
                       "A version cchNumber = bufsize",
                       &NumErrors );

    //  Variation 2  -  cchNumber = 0
    pNumStrA[0] = 0x00;
    rc = GetNumberFormatA( Locale,
                           0,
                           "123456.789",
                           NULL,
                           pNumStrA,
                           0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "123,456.79",
                       NULL,
                       "A version cchNumber zero",
                       &NumErrors );

    //  Variation 3  -  cchNumber = 0, lpNumberStr = NULL
    rc = GetNumberFormatA( Locale,
                           0,
                           "123456.789",
                           NULL,
                           NULL,
                           0 );
    CheckReturnValidA( rc,
                       -1,
                       NULL,
                       "123,456.79",
                       NULL,
                       "A version cchNumber (NULL ptr)",
                       &NumErrors );


    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, cchNumber = bufsize
    rc = GetNumberFormatA( Locale,
                           LOCALE_USE_CP_ACP,
                           "123456.789",
                           NULL,
                           pNumStrA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pNumStrA,
                       "123,456.79",
                       NULL,
                       "A version Use CP ACP, cchNumber = bufsize",
                       &NumErrors );


    //
    //  lpFormat - pValue = 1234567.4444
    //

    NumFmtA.NumDigits = 3;
    NumFmtA.LeadingZero = 1;
    NumFmtA.Grouping = 3;
    NumFmtA.lpDecimalSep = "/";
    NumFmtA.lpThousandSep = NULL;
    NumFmtA.NegativeOrder = 3;


    //  Variation 1  -  lpFormat
    rc = GetNumberFormatA( 0x0409,
                           0,
                           "1234567.4444",
                           &NumFmtA,
                           pNumStrA,
                           BUFSIZE );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "A version bad ThousandSep",
                         &NumErrors );


    NumFmtA.NumDigits = 3;
    NumFmtA.LeadingZero = 1;
    NumFmtA.Grouping = 3;
    NumFmtA.lpDecimalSep = "/";
    NumFmtA.lpThousandSep = ";";
    NumFmtA.NegativeOrder = 3;

    //  Variation 1  -  lpFormat
    rc = GetNumberFormatA( 0x0409,
                           0,
                           "1234567.4444",
                           &NumFmtA,
                           pNumStrA,
                           BUFSIZE );
    CheckReturnValidA( rc,
                       -1,
                       pNumStrA,
                       "1;234;567/444",
                       NULL,
                       "lpFormat (1;234;567/444)",
                       &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\nlstest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    nlstest.c

Abstract:

    Test module for NLS API.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Global Variables.
//

BOOL Verbose = 0;                      // verbose flag

LCID pAllLocales[] =                   // all supported locale ids
{
    0x0402,
    0x0404,
    0x0804,
    0x0c04,
    0x1004,
    0x0405,
    0x0406,
    0x0407,
    0x0807,
    0x0c07,
    0x0408,
    0x0409,
    0x0809,
    0x0c09,
    0x1009,
    0x1409,
    0x1809,
    0x040a,
    0x080a,
    0x0c0a,
    0x040b,
    0x040c,
    0x080c,
    0x0c0c,
    0x100c,
    0x040e,
    0x040f,
    0x0410,
    0x0810,
    0x0411,
    0x0412,
    0x0413,
    0x0813,
    0x0414,
    0x0814,
    0x0415,
    0x0416,
    0x0816,
    0x0418,
    0x0419,
    0x041a,
    0x041b,
    0x041d,
    0x041f,
    0x0424
};

int NumLocales = ( sizeof(pAllLocales) / sizeof(LCID) );

// Buffer used in GetUnicodeString()/GetAnsiString()
CHAR TempStringBuffer[1024];


////////////////////////////////////////////////////////////////////////////
//
//  main
//
//  Main Routine.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int _cdecl main(
    int argc,
    char *argv[])
{
    int NumErrs = 0;              // number of errors


    //
    //  Check for verbose switch.
    //
    if ( (argc > 1) && (_stricmp(argv[1], "-v") == 0) )
    {
        Verbose = 1;
    }


    //
    //  Print out what's being done.
    //
    printf("\nTesting NLS Component.\n");


    //
    //  Test MultiByteToWideChar.
    //
    NumErrs += TestMBToWC();


    //
    //  Test WideCharToMultiByte.
    //
    NumErrs += TestWCToMB();


    //
    //  Test GetCPInfo.
    //
    NumErrs += TestGetCPInfo();


    //
    //  Test CompareString.
    //
    NumErrs += TestCompareString();


    //
    //  Test GetStringType.
    //
    NumErrs += TestGetStringType();


    //
    //  Test FoldString.
    //
    NumErrs += TestFoldString();


    //
    //  Test LCMapString.
    //
    NumErrs += TestLCMapString();


    //
    //  Test GetLocaleInfo.
    //
    NumErrs += TestGetLocaleInfo();


    //
    //  Test SetLocaleInfo.
    //
    NumErrs += TestSetLocaleInfo();


    //
    //  Test GetCalendarInfo.
    //
    NumErrs += TestGetCalendarInfo();


    //
    //  Test SetCalendarInfo.
    //
    NumErrs += TestSetCalendarInfo();


    //
    //  Test GetGeoInfo.
    //
    NumErrs += TestGetGeoInfo();


    //
    //  Test GetTimeFormat.
    //
    NumErrs += TestGetTimeFormat();


    //
    //  Test GetDateFormat.
    //
    NumErrs += TestGetDateFormat();


    //
    //  Test GetNumberFormat.
    //
    NumErrs += TestGetNumberFormat();


    //
    //  Test GetCurrencyFormat.
    //
    NumErrs += TestGetCurrencyFormat();


    //
    //  Test IsDBCSLeadByte.
    //
    NumErrs += TestIsDBCSLeadByte();


    //
    //  Test IsValidCodePage.
    //
    NumErrs += TestIsValidCodePage();


    //
    //  Test IsValidLanguageGroup.
    //
    NumErrs += TestIsValidLanguageGroup();


    //
    //  Test IsValidLocale.
    //
    NumErrs += TestIsValidLocale();


    //
    //  Test GetACP, GetOEMCP,
    //       GetSystemDefaultUILanguage, GetUserDefaultUILanguage,
    //       GetSystemDefaultLangID, GetUserDefaultLangID,
    //       GetSystemDefaultLCID, GetUserDefaultLCID,
    //       GetThreadLocale, SetThreadLocale
    //
    NumErrs += TestUtilityAPIs();


    //
    //  Test EnumUILanguages.
    //
    NumErrs += TestEnumUILanguages();


    //
    //  Test EnumSystemLanguageGroups.
    //
    NumErrs += TestEnumSystemLanguageGroups();


    //
    //  Test EnumLanguageGroupLocales.
    //
    NumErrs += TestEnumLanguageGroupLocales();


    //
    //  Test EnumSystemLocales.
    //
    NumErrs += TestEnumSystemLocales();


    //
    //  Test EnumSystemCodePages.
    //
    NumErrs += TestEnumSystemCodePages();


    //
    //  Test EnumCalendarInfo.
    //
    NumErrs += TestEnumCalendarInfo();


    //
    //  Test EnumTimeFormats.
    //
    NumErrs += TestEnumTimeFormats();


    //
    //  Test EnumDateFormats.
    //
    NumErrs += TestEnumDateFormats();


    //
    //  Test EnumSystemGeoID.
    //
    NumErrs += TestEnumSystemGeoID();


    //
    //  Print out final result.
    //
    if (NumErrs == 0)
        printf("\n\n\nNO Errors Found.\n\n");
    else
        printf("\n\n\n%d  ERRORS FOUND.\n\n", NumErrs);


    //
    //  Return number of errors found.
    //
    return (NumErrs);


    argc;
    argv;
}


////////////////////////////////////////////////////////////////////////////
//
//  CompStringsW
//
//  Compares a wide character string to another wide character string.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CompStringsW(
    WCHAR *WCStr1,
    WCHAR *WCStr2,
    int   size)
{
    int ctr;                      // loop counter


    for (ctr = 0; WCStr1[ctr] == WCStr2[ctr]; ctr++)
    {
        if (ctr == (size - 1))
            return (0);
    }

    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  CompStringsA
//
//  Compares a multibyte string to another multibyte character string.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int CompStringsA(
    BYTE *MBStr1,
    BYTE *MBStr2,
    int  size)
{
    int ctr;                      // loop counter

    for (ctr = 0; MBStr1[ctr] == MBStr2[ctr]; ctr++)
    {
        if (ctr == (size - 1))
            return (0);
    }

    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintWC
//
//  Prints out a wide character string to the screen.
//  Need the size parameter because the string may not be zero terminated.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void PrintWC(
    WCHAR *WCStr,
    int   size)
{
    int ctr;                      // loop counter

    //
    //  Print the wide character string.
    //
    printf("       WC String  =>  [%s]\n", GetUnicodeString(WCStr, size));
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintMB
//
//  Prints out a multibyte character string to the screen.
//  Need the size parameter because the string may not be zero terminated.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void PrintMB(
    BYTE *MBStr,
    int   size)
{
    int ctr;                      // loop counter


    //
    //  Print the multibyte character string.
    //
    printf("       MB String  =>  [");
    for (ctr = 0; ctr < size; ctr++)
    {
        printf(((MBStr[ctr] < 0x21) || (MBStr[ctr] > 0x7e)) ? "(0x%x)" : "%c",
               MBStr[ctr]);
    }
    printf("]\n");
}

LPSTR GetUnicodeString(LPWSTR wstr, int count)
{
    int i;
    LPSTR lpResult = TempStringBuffer;
    if (count == -1)
    {
        count = wcslen(wstr) + 1;
    }


    for (i = 0; i < count; i++)
    {
        lpResult += sprintf(lpResult, "\\x%04x", (int)wstr[i]);
    }
    lpResult = L'\0';

    return (TempStringBuffer);
}

LPSTR GetAnsiString(LPSTR str, int count)
{
    int i;
    LPSTR lpResult = TempStringBuffer;
    if (count == -1)
    {
        count = strlen(str);
    }

    for (i = 0; i < count; i++)
    {
        lpResult += sprintf(lpResult, "\\x%02x", (unsigned char)str[i]);
    }
    lpResult = L'\0';

    return (TempStringBuffer);
}

////////////////////////////////////////////////////////////////////////////
//
//  CheckLastError
//
//  Checks the last error value.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckLastError(
    DWORD ExpectedLastError,
    LPSTR pErrString,
    int *pNumErrors)
{
    DWORD CurrentLastError;       // last error
    WCHAR Buffer[512];


    if ((CurrentLastError = GetLastError()) != ExpectedLastError)
    {
        printf(">>>>ERROR: %s - \n", pErrString);
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, CurrentLastError, 0, Buffer, 512, NULL);
        wprintf(L"    LastError = %x, String: %s\n", CurrentLastError, Buffer);
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, ExpectedLastError, 0, Buffer, 512, NULL);
        wprintf(L"    Expected = %x, String: %s\n", ExpectedLastError, Buffer);

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnBadParam
//
//  Checks the return code from a call with a bad parameter.  It prints out
//  the appropriate error if either the return code or the last error is
//  incorrect.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnBadParam(
    int CurrentReturn,
    int ExpectedReturn,
    DWORD ExpectedLastError,
    LPSTR pErrString,
    int *pNumErrors)
{
    DWORD CurrentLastError;       // last error


    if ( (CurrentReturn != ExpectedReturn) ||
         ((CurrentLastError = GetLastError()) != ExpectedLastError) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);
        printf("  LastError = %d, Expected = %d\n", CurrentLastError, ExpectedLastError);
        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnBadParamEnum
//
//  Checks the return code from an enumeration call with a bad parameter.
//  It prints out the appropriate error if either the return code, the last
//  error, or the enumeration counter is incorrect.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnBadParamEnum(
    int CurrentReturn,
    int ExpectedReturn,
    DWORD ExpectedLastError,
    LPSTR pErrString,
    int *pNumErrors,
    int CurrentEnumCtr,
    int ExpectedEnumCtr)
{
    DWORD CurrentLastError;       // last error


    if ( (CurrentReturn != ExpectedReturn) ||
         ((CurrentLastError = GetLastError()) != ExpectedLastError) ||
         (CurrentEnumCtr != ExpectedEnumCtr) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);
        printf("  LastError = %d, Expected = %d\n", CurrentLastError, ExpectedLastError);
        printf("  EnumCtr = %d, Expected = %d\n", CurrentEnumCtr, ExpectedEnumCtr);
        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnEqual
//
//  Checks the return code from the valid NLS api "A" call to be sure that
//  it does NOT equal a particular value.  If it does equal that value,
//  then it prints out the appropriate error.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnEqual(
    int CurrentReturn,
    int NonExpectedReturn,
    LPSTR pErrString,
    int *pNumErrors)
{
    if (CurrentReturn == NonExpectedReturn)
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Unexpected Return = %d\n", CurrentReturn);
        printf("  Last Error = %d\n", GetLastError());

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidEnumLoop
//
//  Checks the return code from the valid NLS api "Enum" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidEnumLoop(
    int CurrentReturn,
    int ExpectedReturn,
    int CurrentCtr,
    int ExpectedCtr,
    LPSTR pErrString,
    DWORD ItemValue,
    int *pNumErrors)
{
    if ( (CurrentReturn != ExpectedReturn) ||
         (CurrentCtr != ExpectedCtr) )
    {
        printf("ERROR: %s  %x - \n", pErrString, ItemValue);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);
        printf("  Counter = %d, Expected = %d\n", CurrentCtr, ExpectedCtr);

        (*pNumErrors)++;
    }

    if (Verbose)
    {
        printf("\n");
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidEnum
//
//  Checks the return code from the valid NLS api "Enum" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidEnum(
    int CurrentReturn,
    int ExpectedReturn,
    int CurrentCtr,
    int ExpectedCtr,
    LPSTR pErrString,
    int *pNumErrors)
{
    if ( (CurrentReturn != ExpectedReturn) ||
         (CurrentCtr != ExpectedCtr) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);
        printf("  Counter = %d, Expected = %d\n", CurrentCtr, ExpectedCtr);

        (*pNumErrors)++;
    }

    if (Verbose)
    {
        printf("\n");
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidLoopW
//
//  Checks the return code from the valid NLS api "W" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidLoopW(
    int CurrentReturn,
    int ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    LPSTR pErrString,
    DWORD ItemValue,
    int *pNumErrors)
{
    if ((ExpectedReturn == -1) && (pExpectedString != NULL))
    {
        ExpectedReturn = WC_STRING_LEN_NULL(pExpectedString);
    }

    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsW(pCurrentString, pExpectedString, CurrentReturn)) ) )
    {
        printf("ERROR: %s  %x - \n", pErrString, ItemValue);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        if (pCurrentString != NULL)
        {
            PrintWC(pCurrentString, CurrentReturn);
        }

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidLoopA
//
//  Checks the return code from the valid NLS api "A" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidLoopA(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pCurrentString,
    LPSTR pExpectedString,
    LPSTR pErrString,
    DWORD ItemValue,
    int *pNumErrors)
{
    if ((ExpectedReturn == -1) && (pExpectedString != NULL))
    {
        ExpectedReturn = MB_STRING_LEN_NULL(pExpectedString);
    }

    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsA(pCurrentString, pExpectedString, CurrentReturn)) ) )
    {
        printf("ERROR: %s  %x - \n", pErrString, ItemValue);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        if (pCurrentString != NULL)
        {
            PrintMB(pCurrentString, CurrentReturn);
        }

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidW
//
//  Checks the return code from the valid NLS api "W" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidW(
    int CurrentReturn,
    int ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    LPSTR pErrString,
    int *pNumErrors)
{
    if ((ExpectedReturn == -1) && (pExpectedString != NULL))
    {
        ExpectedReturn = WC_STRING_LEN_NULL(pExpectedString);
    }

    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsW(pCurrentString, pExpectedString, CurrentReturn)) ) )
    {
        printf(">>>>ERROR: %s - \n", pErrString);
        printf("    Return = %d\n", CurrentReturn);
        printf("    Expected = %d\n", ExpectedReturn);

        if (pCurrentString != NULL)
        {
            PrintWC(pCurrentString, CurrentReturn);
        }

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidA
//
//  Checks the return code from the valid NLS api "A" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidA(
    int CurrentReturn,
    int ExpectedReturn,
    LPSTR pCurrentString,
    LPSTR pExpectedString,
    LPBOOL pUsedDef,
    LPSTR pErrString,
    int *pNumErrors)
{
    if ((ExpectedReturn == -1) && (pExpectedString != NULL))
    {
        ExpectedReturn = MB_STRING_LEN_NULL(pExpectedString);
    }

    if ( (CurrentReturn != ExpectedReturn) ||
         ( (pCurrentString != NULL) &&
           (CompStringsA(pCurrentString, pExpectedString, CurrentReturn)) ) ||
         ( (pUsedDef != NULL) &&
           (*pUsedDef != TRUE) ) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);

        if (pUsedDef != NULL)
        {
            printf("  UsedDef = %d\n", *pUsedDef);
        }

        if (pCurrentString != NULL)
        {
            PrintMB(pCurrentString, CurrentReturn);
        }

        (*pNumErrors)++;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckReturnValidInt
//
//  Checks the return code from the valid NLS api "W" call.  It prints out
//  the appropriate error if the incorrect result is found.
//
//  06-14-91    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

void CheckReturnValidInt(
    int CurrentReturn,
    int ExpectedReturn,
    DWORD CurrentInt,
    DWORD ExpectedInt,
    LPSTR pErrString,
    int *pNumErrors)
{
    if ( (CurrentReturn != ExpectedReturn) ||
         (CurrentInt != ExpectedInt) )
    {
        printf("ERROR: %s - \n", pErrString);
        printf("  Return = %d, Expected = %d\n", CurrentReturn, ExpectedReturn);
        printf("  Return Int = %d, Expected Int = %d\n", CurrentInt, ExpectedInt);

        (*pNumErrors)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\nlstest.h ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    nlstest.h

Abstract:

    This file contains the header information for the NLS test module.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    06-14-91    JulieB    Created.

--*/




////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <excpt.h>
#include <windows.h>
#include <winerror.h>
#include <winnlsp.h>

#include <stdio.h>
#include <string.h>




////////////////////////////////////////////////////////////////////////////
//
//  Constant Declarations.
//
////////////////////////////////////////////////////////////////////////////

//
//  Error codes.
//

#ifndef NO_ERROR

  #define NO_ERROR  0

#endif



//
//  Performance Break Points.
//  Uncomment this definition to enable the break points.
//
//#define PERF




////////////////////////////////////////////////////////////////////////////
//
//  Typedef Declarations.
//
////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////
//
//  Macro Definitions.
//
////////////////////////////////////////////////////////////////////////////

//
//  Macros for getting string lengths.
//
#define  MB_STRING_LEN(pStr)           ((int)(strlen(pStr)))
#define  MB_STRING_LEN_NULL(pStr)      ((int)(strlen(pStr) + 1))

#define  WC_STRING_LEN(pStr)           ((int)(wcslen(pStr)))
#define  WC_STRING_LEN_NULL(pStr)      ((int)(wcslen(pStr) + 1))




////////////////////////////////////////////////////////////////////////////
//
//  Function Prototypes
//
////////////////////////////////////////////////////////////////////////////

int
CompStringsW(
    WCHAR  *WCStr1,
    WCHAR  *WCStr2,
    int    size);

int
CompStringsA(
    BYTE   *MBStr1,
    BYTE   *MBStr2,
    int    size);

void
PrintWC(
    WCHAR  *WCStr,
    int    size);

void
PrintMB(
    BYTE   *MBStr,
    int    size);
    
LPSTR 
GetAnsiString(
    LPSTR str, 
    int count);

LPSTR 
GetUnicodeString(
    LPWSTR wstr, 
    int count);

void
CheckLastError(
    DWORD ExpectedLastError,
    LPSTR pErrString,
    int *pNumErrors);

void
CheckReturnBadParam(
    int    CurrentReturn,
    int    ExpectedReturn,
    DWORD  ExpectedLastError,
    LPSTR  pErrString,
    int    *pNumErrors);

void
CheckReturnBadParamEnum(
    int    CurrentReturn,
    int    ExpectedReturn,
    DWORD  ExpectedLastError,
    LPSTR  pErrString,
    int    *pNumErrors,
    int    CurrentEnumCtr,
    int    ExpectedEnumCtr);

void
CheckReturnEqual(
    int    CurrentReturn,
    int    NonExpectedReturn,
    LPSTR  pErrString,
    int    *pNumErrors);

void
CheckReturnValidEnumLoop(
    int    CurrentReturn,
    int    ExpectedReturn,
    int    CurrentCtr,
    int    ExpectedCtr,
    LPSTR  pErrString,
    DWORD  ItemValue,
    int    *pNumErrors);

void
CheckReturnValidEnum(
    int    CurrentReturn,
    int    ExpectedReturn,
    int    CurrentCtr,
    int    ExpectedCtr,
    LPSTR  pErrString,
    int    *pNumErrors);

void
CheckReturnValidLoopW(
    int    CurrentReturn,
    int    ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    LPSTR  pErrString,
    DWORD  ItemValue,
    int    *pNumErrors);

void
CheckReturnValidLoopA(
    int    CurrentReturn,
    int    ExpectedReturn,
    LPSTR  pCurrentString,
    LPSTR  pExpectedString,
    LPSTR  pErrString,
    DWORD  ItemValue,
    int    *pNumErrors);

void
CheckReturnValidW(
    int    CurrentReturn,
    int    ExpectedReturn,
    LPWSTR pCurrentString,
    LPWSTR pExpectedString,
    LPSTR  pErrString,
    int    *pNumErrors);

void
CheckReturnValidA(
    int    CurrentReturn,
    int    ExpectedReturn,
    LPSTR  pCurrentString,
    LPSTR  pExpectedString,
    LPBOOL pUsedDef,
    LPSTR  pErrString,
    int    *pNumErrors);

void
CheckReturnValidInt(
    int    CurrentReturn,
    int    ExpectedReturn,
    DWORD  CurrentInt,
    DWORD  ExpectedInt,
    LPSTR  pErrString,
    int    *pNumErrors);


int
TestMBToWC(void);

int
TestWCToMB(void);

int
TestGetCPInfo(void);

int
TestCompareString(void);

int
TestGetStringType(void);

int
TestFoldString(void);

int
TestLCMapString(void);

int
TestGetLocaleInfo(void);

int
TestSetLocaleInfo(void);

int
TestGetCalendarInfo(void);

int
TestSetCalendarInfo(void);

int
TestGetGeoInfo(void);

int
TestIsDBCSLeadByte(void);

int
TestIsValidCodePage(void);

int
TestIsValidLanguageGroup(void);

int
TestIsValidLocale(void);

int
TestUtilityAPIs(void);

int
TestGetTimeFormat(void);

int
TestGetDateFormat(void);

int
TestGetNumberFormat(void);

int
TestGetCurrencyFormat(void);

int
TestEnumUILanguages(void);

int
TestEnumSystemLanguageGroups(void);

int
TestEnumLanguageGroupLocales(void);

int
TestEnumSystemLocales(void);

int
TestEnumSystemCodePages(void);

int
TestEnumCalendarInfo(void);

int
TestEnumTimeFormats(void);

int
TestEnumDateFormats(void);

int
TestEnumSystemGeoID(void);




////////////////////////////////////////////////////////////////////////////
//
//  Global Variables
//
//  All of the global variables for the NLSTEST should be put here.
//
//  Globals are included last because they may require some of the types
//  being defined above.
//
////////////////////////////////////////////////////////////////////////////

extern BOOL    Verbose;           // verbose flag
extern LCID    pAllLocales[];     // all supported locale ids
extern int     NumLocales;        // number of all supported locale ids
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\scitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    scitest.c

Abstract:

    Test module for NLS API SetCalendarInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    03-10-98    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE          100               // buffer size in wide chars
#define  CALTYPE_INVALID  0x0000002         // invalid CALTYPE




//
//  Global Variables.
//

LCID Locale;

WCHAR lpCalData[BUFSIZE];
WCHAR pTwoDigitYearMax[BUFSIZE];




//
//  Forward Declarations.
//

BOOL
InitSetCalInfo();

int
SCI_BadParamCheck();

int
SCI_NormalCase();

int
SCI_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestSetCalendarInfo
//
//  Test routine for SetCalendarInfoW API.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestSetCalendarInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING SetCalendarInfoW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitSetCalInfo())
    {
        printf("\nABORTED TestSetCalendarInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += SCI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += SCI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += SCI_Ansi();

    //
    //  Print out result.
    //
    printf("\nSetCalendarInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSetCalInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitSetCalInfo()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Save the ITWODIGITYEARMAX value to be restored later.
    //
    if (!GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           pTwoDigitYearMax,
                           BUFSIZE,
                           NULL ))
    {
        printf("ERROR: Initialization ITWODIGITYEARMAX - error = %d\n", GetLastError());
        return (FALSE);
    }


    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SCI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SCI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = SetCalendarInfoW( (LCID)333,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"2029" );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpCalData = NULL
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpCalData NULL",
                         &NumErrors );


    //
    //  Zero or Invalid Type.
    //

    //  Variation 1  -  CalType = invalid
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CALTYPE_INVALID,
                           L"2029" );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "CalType invalid",
                         &NumErrors );

    //  Variation 2  -  CalType = 0
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           0,
                           L"2029" );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "CalType zero",
                         &NumErrors );

    //  Variation 1  -  Use CP ACP, CalType = invalid
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CALTYPE_INVALID,
                           L"2029" );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, CalType invalid",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  SCI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SCI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = SetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"2035" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - system default locale",
                      &NumErrors );
    rc = GetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"2035",
                       "GET - system default locale",
                       &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = SetCalendarInfoW( LOCALE_USER_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"2040" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - current user locale",
                      &NumErrors );
    rc = GetCalendarInfoW( LOCALE_USER_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"2040",
                       "GET - current user locale",
                       &NumErrors );

    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = SetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           L"2050" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - Use CP ACP, system default locale",
                      &NumErrors );
    rc = GetCalendarInfoW( LOCALE_SYSTEM_DEFAULT,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"2050",
                       "GET - Use CP ACP, system default locale",
                       &NumErrors );

    //
    //  CALTYPE values.
    //

    //  Variation 1  -  ITWODIGITYEARMAX
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"10000" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - MAX ITWODIGITYEARMAX",
                      &NumErrors );
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"98" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - MIN ITWODIGITYEARMAX",
                      &NumErrors );
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           L"3030" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ITWODIGITYEARMAX",
                      &NumErrors );
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"3030",
                       "GET - ITWODIGITYEARMAX",
                       &NumErrors );
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           pTwoDigitYearMax );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ITWODIGITYEARMAX",
                      &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  SCI_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  03-10-98    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SCI_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  SetCalendarInfoA.
    //

    //  Variation 1  -  ITWODIGITYEARMAX
    rc = SetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           "4040" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - system default locale",
                      &NumErrors );
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"4040",
                       "GET - system default locale",
                       &NumErrors );

    //  Variation 2  -  Use CP ACP, ITWODIGITYEARMAX
    rc = SetCalendarInfoA( Locale,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           "4141" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - Use CP ACP, system default locale",
                      &NumErrors );
    rc = GetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_USE_CP_ACP | CAL_ITWODIGITYEARMAX,
                           lpCalData,
                           BUFSIZE,
                           NULL );
    CheckReturnValidW( rc,
                       -1,
                       lpCalData,
                       L"4141",
                       "GET - Use CP ACP, system default locale",
                       &NumErrors );


    //
    //  Reset the ITWODIGITYEARMAX value.
    //
    rc = SetCalendarInfoW( Locale,
                           CAL_GREGORIAN,
                           CAL_ITWODIGITYEARMAX,
                           pTwoDigitYearMax );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ITWODIGITYEARMAX",
                      &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\win32\winnls\test\nlstest\slitest.c ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    slitest.c

Abstract:

    Test module for NLS API SetLocaleInfo.

    NOTE: This code was simply hacked together quickly in order to
          test the different code modules of the NLS component.
          This is NOT meant to be a formal regression test.

Revision History:

    07-14-93    JulieB    Created.

--*/



//
//  Include Files.
//

#include "nlstest.h"




//
//  Constant Declarations.
//

#define  BUFSIZE         100                // buffer size in wide chars
#define  LCTYPE_INVALID  0x0000002          // invalid LCTYPE




//
//  Global Variables.
//

LCID Locale;

WCHAR lpLCData[BUFSIZE];
WCHAR pTemp[BUFSIZE];
WCHAR pSList[BUFSIZE];
WCHAR pSTimeFormat[BUFSIZE];
WCHAR pSTime[BUFSIZE];
WCHAR pITime[BUFSIZE];
WCHAR pSShortDate[BUFSIZE];
WCHAR pSDate[BUFSIZE];




//
//  Forward Declarations.
//

BOOL
InitSetLocInfo();

int
SLI_BadParamCheck();

int
SLI_NormalCase();

int
SLI_Ansi();





////////////////////////////////////////////////////////////////////////////
//
//  TestSetLocaleInfo
//
//  Test routine for SetLocaleInfoW API.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int TestSetLocaleInfo()
{
    int ErrCount = 0;             // error count


    //
    //  Print out what's being done.
    //
    printf("\n\nTESTING SetLocaleInfoW...\n\n");

    //
    //  Initialize global variables.
    //
    if (!InitSetLocInfo())
    {
        printf("\nABORTED TestSetLocaleInfo: Could not Initialize.\n");
        return (1);
    }

    //
    //  Test bad parameters.
    //
    ErrCount += SLI_BadParamCheck();

    //
    //  Test normal cases.
    //
    ErrCount += SLI_NormalCase();

    //
    //  Test Ansi version.
    //
    ErrCount += SLI_Ansi();

    //
    //  Print out result.
    //
    printf("\nSetLocaleInfoW:  ERRORS = %d\n", ErrCount);

    //
    //  Return total number of errors found.
    //
    return (ErrCount);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSetLocInfo
//
//  This routine initializes the global variables.  If no errors were
//  encountered, then it returns TRUE.  Otherwise, it returns FALSE.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

BOOL InitSetLocInfo()
{
    //
    //  Make a Locale.
    //
    Locale = MAKELCID(0x0409, 0);

    //
    //  Save the SLIST value to be restored later.
    //
    if ( !GetLocaleInfoW( Locale,
                          LOCALE_SLIST,
                          pSList,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization SLIST - error = %d\n", GetLastError());
        return (FALSE);
    }

    if ( !GetLocaleInfoW( Locale,
                          LOCALE_STIMEFORMAT,
                          pSTimeFormat,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization STIMEFORMAT - error = %d\n", GetLastError());
        return (FALSE);
    }

    if ( !GetLocaleInfoW( Locale,
                          LOCALE_STIME,
                          pSTime,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization STIME - error = %d\n", GetLastError());
        return (FALSE);
    }

    if ( !GetLocaleInfoW( Locale,
                          LOCALE_ITIME,
                          pITime,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization ITIME - error = %d\n", GetLastError());
        return (FALSE);
    }

    if ( !GetLocaleInfoW( Locale,
                          LOCALE_SSHORTDATE,
                          pSShortDate,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization SSHORTDATE - error = %d\n", GetLastError());
        return (FALSE);
    }

    if ( !GetLocaleInfoW( Locale,
                          LOCALE_SDATE,
                          pSDate,
                          BUFSIZE ) )
    {
        printf("ERROR: Initialization SDATE - error = %d\n", GetLastError());
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SLI_BadParamCheck
//
//  This routine passes in bad parameters to the API routines and checks to
//  be sure they are handled properly.  The number of errors encountered
//  is returned to the caller.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SLI_BadParamCheck()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  Bad Locale.
    //

    //  Variation 1  -  Bad Locale
    rc = SetLocaleInfoW( (LCID)333,
                         LOCALE_SLIST,
                         L"," );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "Bad Locale",
                         &NumErrors );


    //
    //  Null Pointers.
    //

    //  Variation 1  -  lpLCData = NULL
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         NULL );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_PARAMETER,
                         "lpLCData NULL",
                         &NumErrors );


    //
    //  Zero or Invalid Type.
    //

    //  Variation 1  -  LCType = invalid
    rc = SetLocaleInfoW( Locale,
                         LCTYPE_INVALID,
                         L"," );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "LCType invalid",
                         &NumErrors );

    //  Variation 2  -  LCType = 0
    rc = SetLocaleInfoW( Locale,
                         0,
                         L"," );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "LCType zero",
                         &NumErrors );

    //  Variation 1  -  Use CP ACP, LCType = invalid
    rc = SetLocaleInfoW( Locale,
                         LOCALE_USE_CP_ACP | LCTYPE_INVALID,
                         L"," );
    CheckReturnBadParam( rc,
                         0,
                         ERROR_INVALID_FLAGS,
                         "Use CP ACP, LCType invalid",
                         &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  SLI_NormalCase
//
//  This routine tests the normal cases of the API routine.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SLI_NormalCase()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


#ifdef PERF

  DbgBreakPoint();

#endif


    //
    //  Locales.
    //

    //  Variation 1  -  System Default Locale
    rc = SetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_SLIST,
                         L"::" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - system default locale",
                      &NumErrors );
    rc = GetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"::",
                       "GET - system default locale",
                       &NumErrors );

    //  Variation 2  -  Current User Locale
    rc = SetLocaleInfoW( LOCALE_USER_DEFAULT,
                         LOCALE_SLIST,
                         L";;" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - current user locale",
                      &NumErrors );
    rc = GetLocaleInfoW( LOCALE_USER_DEFAULT,
                         LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L";;",
                       "GET - current user locale",
                       &NumErrors );

    //
    //  Use CP ACP.
    //

    //  Variation 1  -  Use CP ACP, System Default Locale
    rc = SetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_USE_CP_ACP | LOCALE_SLIST,
                         L".." );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - Use CP ACP, system default locale",
                      &NumErrors );
    rc = GetLocaleInfoW( LOCALE_SYSTEM_DEFAULT,
                         LOCALE_USE_CP_ACP | LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"..",
                       "GET - Use CP ACP, system default locale",
                       &NumErrors );

    //
    //  LCTYPE values.
    //

    //  Variation 1  -  SLIST
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         L"::::" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - MAX SLIST",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         L"''" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SLIST",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"''",
                       "GET - SLIST",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLIST,
                         pSList );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SLIST",
                      &NumErrors );


    //  Variation 2  -  IMEASURE
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IMEASURE,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current IMEASURE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IMEASURE,
                         L"2" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid IMEASURE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IMEASURE,
                         L"0" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - IMEASURE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IMEASURE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"0",
                       "GET - IMEASURE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IMEASURE,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - IMEASURE",
                      &NumErrors );


    //  Variation 3  -  SDECIMAL
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SDECIMAL",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         L"[][]" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SDECIMAL",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         L"6" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SDECIMAL (6)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         L"{" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SDECIMAL",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"{",
                       "GET - SDECIMAL",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDECIMAL,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SDECIMAL",
                      &NumErrors );


    //  Variation 4  -  STHOUSAND
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current STHOUSAND",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         L"[][]" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid STHOUSAND",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         L"6" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid STHOUSAND (6)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         L"{" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STHOUSAND",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"{",
                       "GET - STHOUSAND",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STHOUSAND,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STHOUSAND",
                      &NumErrors );


    //  Variation 5  -  SGROUPING
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SGROUPING",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"3;" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SGROUPING 1",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"3;2;" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SGROUPING 2",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"10;0" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SGROUPING 3",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"3:0" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SGROUPING 4",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"5;0" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SGROUPING",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"5;0",
                       "GET - SGROUPING",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         L"3;2;0" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SGROUPING",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"3;2;0",
                       "GET - SGROUPING",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SGROUPING,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SGROUPING",
                      &NumErrors );


    //  Variation 6  -  IDIGITS
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IDIGITS,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current IDIGITS",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IDIGITS,
                         L"a" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid IDIGITS",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IDIGITS,
                         L"5" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - IDIGITS",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IDIGITS,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"5",
                       "GET - IDIGITS",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IDIGITS,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - IDIGITS",
                      &NumErrors );


    //  Variation 7  -  ILZERO
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILZERO,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current ILZERO",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ILZERO,
                         L"2" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ILZERO",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ILZERO,
                         L"1" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ILZERO",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ILZERO,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ILZERO",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ILZERO,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ILZERO",
                      &NumErrors );


    //  Variation 8  -  SCURRENCY
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SCURRENCY",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         L"[][][]" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SCURRENCY",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         L"x5" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SCURRENCY (x5)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         L"%@%" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SCURRENCY",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"%@%",
                       "GET - SCURRENCY",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SCURRENCY,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SCURRENCY",
                      &NumErrors );


    //  Variation 9  -  SMONDECIMALSEP
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SMONDECIMALSEP",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         L"{}{}" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONDECIMALSEP",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         L"6" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONDECIMALSEP (6)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         L"%" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SMONDECIMALSEP",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"%",
                       "GET - SMONDECIMALSEP",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONDECIMALSEP,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SMONDECIMALSEP",
                      &NumErrors );


    //  Variation 10  -  SMONTHOUSANDSEP
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SMONTHOUSANDSEP",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         L"{}{}" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONTHOUSANDSEP",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         L"6" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONTHOUSANDSEP (6)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         L"%" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SMONTHOUSANDSEP",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"%",
                       "GET - SMONTHOUSANDSEP",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONTHOUSANDSEP,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SMONTHOUSANDSEP",
                      &NumErrors );


    //  Variation 11  -  SMONGROUPING
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SMONGROUPING",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"3;" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONGROUPING 1",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"3;2;" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONGROUPING 2",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"10;0" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONGROUPING 3",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"3:0" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SMONGROUPING 4",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"5;0" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SMONGROUPING",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"5;0",
                       "GET - SMONGROUPING",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         L"3;2;0" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SMONGROUPING",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"3;2;0",
                       "GET - SMONGROUPING",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SMONGROUPING,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SMONGROUPING",
                      &NumErrors );


    //  Variation 12  -  ICURRDIGITS
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICURRDIGITS,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current ICURRDIGITS",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRDIGITS,
                         L"aa" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ICURRDIGITS",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRDIGITS,
                         L"85" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ICURRDIGITS",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICURRDIGITS,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"85",
                       "GET - ICURRDIGITS",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRDIGITS,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ICURRDIGITS",
                      &NumErrors );


    //  Variation 13  -  ICURRENCY
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICURRENCY,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current ICURRENCY",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRENCY,
                         L"4" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ICURRENCY",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRENCY,
                         L"3" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ICURRENCY",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICURRENCY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"3",
                       "GET - ICURRENCY",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICURRENCY,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ICURRENCY",
                      &NumErrors );


    //  Variation 14  -  INEGCURR
    rc = GetLocaleInfoW( Locale,
                         LOCALE_INEGCURR,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current INEGCURR",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_INEGCURR,
                         L"16" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid INEGCURR",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_INEGCURR,
                         L"13" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - INEGCURR",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_INEGCURR,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"13",
                       "GET - INEGCURR",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_INEGCURR,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - INEGCURR",
                      &NumErrors );


    //  Variation 15  -  SPOSITIVESIGN
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SPOSITIVESIGN",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         L"{}{}{" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SPOSITIVESIGN",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         L"x5" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SPOSITIVESIGN (x5)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         L"[]" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SPOSITIVESIGN",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"[]",
                       "GET - SPOSITIVESIGN",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SPOSITIVESIGN,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SPOSITIVESIGN",
                      &NumErrors );


    //  Variation 16  -  SNEGATIVESIGN
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - SNEGATIVESIGN",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         L"{}{}{" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SNEGATIVESIGN",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         L"x5" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SNEGATIVESIGN (x5)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         L"[]" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SNEGATIVESIGN",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"[]",
                       "GET - SNEGATIVESIGN",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SNEGATIVESIGN,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SNEGATIVESIGN",
                      &NumErrors );


    //  Variation 17  -  STIMEFORMAT
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         L"HHHHHmmmmmsssssHHHHHmmmmmsssssHHHHHmmmmmsssssHHHHHmmmmmsssssHHHHHmmmmmsssssHHHHH" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid STIMEFORMAT",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         L"tt HH/mm/ss" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIMEFORMAT",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"tt HH/mm/ss",
                       "GET - STIMEFORMAT",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"/",
                       "GET - STIME from STIMEFORMAT",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ITIME from STIMEFORMAT",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ITLZERO,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ITLZERO from STIMEFORMAT",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ITIMEMARKPOSN,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ITIMEMARKPOSN from STIMEFORMAT",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         pSTimeFormat );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIMEFORMAT",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         pSTime );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIME from STIMEFORMAT",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         pITime );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ITIME from STIMEFORMAT",
                      &NumErrors );


    //  Variation 18  -  STIME
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         L"{**}" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid STIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         L"x5" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid STIME (x5)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         L"HH/mm/ss" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIMEFORMAT from STIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         L"[]" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIME",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"[]",
                       "GET - STIME",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"HH[]mm[]ss",
                       "GET - STIMEFORMAT from STIME",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         pSTime );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         pSTimeFormat );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIMEFORMAT from STIME",
                      &NumErrors );


    //  Variation 18.1  -  STIME
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         L"HH/mm/ss' ('hh' oclock)'" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIMEFORMAT from STIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         L"[]" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIME",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"[]",
                       "GET - STIME",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"HH[]mm[]ss' ('hh' oclock)'",
                       "GET - STIMEFORMAT from STIME",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIME,
                         pSTime );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         pSTimeFormat );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIMEFORMAT from STIME",
                      &NumErrors );


    //  Variation 19  -  ITIME
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         L"2" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ITIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         L"hh/mm/ss" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - STIMEFORMAT from ITIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         L"1" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ITIME",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ITIME",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"HH/mm/ss",
                       "GET - STIMEFORMAT from ITIME",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ITIME,
                         pITime );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ITIME",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_STIMEFORMAT,
                         pSTimeFormat );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - STIMEFORMAT from ITIME",
                      &NumErrors );


    //  Variation 20  -  S1159
    rc = GetLocaleInfoW( Locale,
                         LOCALE_S1159,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current S1159",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S1159,
                         L"123456789012345" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid S1159",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S1159,
                         L"DAWN" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - S1159",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_S1159,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"DAWN",
                       "GET - S1159",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S1159,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - S1159",
                      &NumErrors );


    //  Variation 21  -  S2359
    rc = GetLocaleInfoW( Locale,
                         LOCALE_S2359,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - S2359",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S2359,
                         L"123456789012345" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid S2359",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S2359,
                         L"DUSK" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - S2359",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_S2359,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"DUSK",
                       "GET - S2359",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_S2359,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - S2359",
                      &NumErrors );


    //  Variation 22  -  SSHORTDATE
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         L"dddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyyddddd" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SSHORTDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         L"yyyy:MM:dd" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SSHORTDATE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"yyyy:MM:dd",
                       "GET - SSHORTDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L":",
                       "GET - SDATE from SSHORTDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"2",
                       "GET - IDATE from SSHORTDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IMONLZERO,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - IMONLZERO from SSHORTDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IDAYLZERO,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - IDAYLZERO from SSHORTDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICENTURY,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - ICENTURY from SSHORTDATE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         pSShortDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SSHORTDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         pSDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SDATE from SSHORTDATE",
                      &NumErrors );


    //  Variation 23  -  SDATE
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         L"{}{}" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         L"6" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SDATE (6)",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         L"yy:MM:dd" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SSHORTDATE from SDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         L"+" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SDATE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"+",
                       "GET - SDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"yy+MM+dd",
                       "GET - SSHORTDATE from SDATE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         pSDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         pSShortDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SSHORTDATE from SDATE",
                      &NumErrors );


    //  Variation 23.1  -  SDATE
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         L"yy:MM:dd' ('ddd')'" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SSHORTDATE from SDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         L"+" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SDATE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"+",
                       "GET - SDATE",
                       &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"yy+MM+dd' ('ddd')'",
                       "GET - SSHORTDATE from SDATE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SDATE,
                         pSDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SSHORTDATE,
                         pSShortDate );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SSHORTDATE from SDATE",
                      &NumErrors );


    //  Variation 24  -  SLONGDATE
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SLONGDATE,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current SLONGDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLONGDATE,
                         L"dddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyydddddMMMMMyyyyyddddd" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid SLONGDATE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLONGDATE,
                         L"yy, MMMM dd, dddd" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - SLONGDATE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_SLONGDATE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"yy, MMMM dd, dddd",
                       "GET - SLONGDATE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_SLONGDATE,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - SLONGDATE",
                      &NumErrors );


    //  Variation 25  -  ICALENDARTYPE
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICALENDARTYPE,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current ICALENDARTYPE",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICALENDARTYPE,
                         L"0" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ICALENDARTYPE 0",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICALENDARTYPE,
                         L"8" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid ICALENDARTYPE 8",
                      &NumErrors );
    rc = SetLocaleInfoW( 0x0411,
                         LOCALE_ICALENDARTYPE,
                         L"3" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - ICALENDARTYPE",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_ICALENDARTYPE,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"3",
                       "GET - ICALENDARTYPE",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_ICALENDARTYPE,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - ICALENDARTYPE",
                      &NumErrors );


    //  Variation 26  -  IFIRSTDAYOFWEEK
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IFIRSTDAYOFWEEK,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current IFIRSTDAYOFWEEK",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTDAYOFWEEK,
                         L"7" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid IFIRSTDAYOFWEEK",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTDAYOFWEEK,
                         L"3" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - IFIRSTDAYOFWEEK",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IFIRSTDAYOFWEEK,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"3",
                       "GET - IFIRSTDAYOFWEEK",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTDAYOFWEEK,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - IFIRSTDAYOFWEEK",
                      &NumErrors );


    //  Variation 27  -  IFIRSTWEEKOFYEAR
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         pTemp,
                         BUFSIZE );
    CheckReturnEqual( rc,
                      0,
                      "GET - current IFIRSTWEEKOFYEAR",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         L"3" );
    CheckReturnEqual( rc,
                      TRUE,
                      "SET - invalid IFIRSTWEEKOFYEAR",
                      &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         L"1" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - IFIRSTWEEKOFYEAR",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"1",
                       "GET - IFIRSTWEEKOFYEAR",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         L"2" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - IFIRSTWEEKOFYEAR 2",
                      &NumErrors );
    rc = GetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"2",
                       "GET - IFIRSTWEEKOFYEAR 2",
                       &NumErrors );
    rc = SetLocaleInfoW( Locale,
                         LOCALE_IFIRSTWEEKOFYEAR,
                         pTemp );
    CheckReturnEqual( rc,
                      FALSE,
                      "ReSET - IFIRSTWEEKOFYEAR",
                      &NumErrors );


    //
    //  Return total number of errors found.
    //
    return (NumErrors);
}


////////////////////////////////////////////////////////////////////////////
//
//  SLI_Ansi
//
//  This routine tests the Ansi version of the API routine.
//
//  07-14-93    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

int SLI_Ansi()
{
    int NumErrors = 0;            // error count - to be returned
    int rc;                       // return code


    //
    //  SetLocaleInfoA.
    //

    //  Variation 1  -  SList
    rc = SetLocaleInfoA( 0x0409,
                         LOCALE_SLIST,
                         "::" );
    CheckReturnEqual( rc,
                      FALSE,
                      "SET - system default locale",
                      &NumErrors );
    rc = GetLocaleInfoW( 0x0409,
                         LOCALE_SLIST,
                         lpLCData,
                         BUFSIZE );
    CheckReturnValidW( rc,
                       -1,
                       lpLCData,
                       L"::",
                       "GET - system default locale",
                       &NumErrors );

    //  Variation 2  -  Use CP ACP, SList
    rc = SetLocaleInfoA( 0x0409,
                         LOCALE_USE_CP_ACP | LOCALE_SLIST,
                         ".." );
 